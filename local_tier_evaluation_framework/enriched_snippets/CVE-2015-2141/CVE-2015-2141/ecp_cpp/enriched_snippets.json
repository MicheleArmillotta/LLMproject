[
  {
    "function_name": "CascadeScalarMultiply",
    "container": "ECP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "459-469",
    "snippet": "ECP::Point ECP::CascadeScalarMultiply(const Point &P, const Integer &k1, const Point &Q, const Integer &k2) const\n{\n\tif (!GetField().IsMontgomeryRepresentation())\n\t{\n\t\tECP ecpmr(*this, true);\n\t\tconst ModularArithmetic &mr = ecpmr.GetField();\n\t\treturn FromMontgomery(mr, ecpmr.CascadeScalarMultiply(ToMontgomery(mr, P), k1, ToMontgomery(mr, Q), k2));\n\t}\n\telse\n\t\treturn AbstractGroup<Point>::CascadeScalarMultiply(P, k1, Q, k2);\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AbstractGroup<Point>::CascadeScalarMultiply",
          "args": [
            "P",
            "k1",
            "Q",
            "k2"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "CascadeScalarMultiply",
          "container": "ECP",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
          "lines": "459-469",
          "snippet": "ECP::Point ECP::CascadeScalarMultiply(const Point &P, const Integer &k1, const Point &Q, const Integer &k2) const\n{\n\tif (!GetField().IsMontgomeryRepresentation())\n\t{\n\t\tECP ecpmr(*this, true);\n\t\tconst ModularArithmetic &mr = ecpmr.GetField();\n\t\treturn FromMontgomery(mr, ecpmr.CascadeScalarMultiply(ToMontgomery(mr, P), k1, ToMontgomery(mr, Q), k2));\n\t}\n\telse\n\t\treturn AbstractGroup<Point>::CascadeScalarMultiply(P, k1, Q, k2);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "FromMontgomery",
          "args": [
            "mr",
            "ecpmr.CascadeScalarMultiply(ToMontgomery(mr, P), k1, ToMontgomery(mr, Q), k2)"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "FromMontgomery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
          "lines": "21-24",
          "snippet": "static inline ECP::Point FromMontgomery(const ModularArithmetic &mr, const ECP::Point &P)\n{\n\treturn P.identity ? P : ECP::Point(mr.ConvertOut(P.x), mr.ConvertOut(P.y));\n}",
          "includes": [
            "#include \"algebra.cpp\"",
            "#include \"nbtheory.h\"",
            "#include \"asn.h\"",
            "#include \"ecp.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nstatic inline ECP::Point FromMontgomery(const ModularArithmetic &mr, const ECP::Point &P)\n{\n\treturn P.identity ? P : ECP::Point(mr.ConvertOut(P.x), mr.ConvertOut(P.y));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ToMontgomery",
          "args": [
            "mr",
            "Q"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "ToMontgomery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
          "lines": "15-19",
          "snippet": "ANONYMOUS_NAMESPACE_BEGIN\nstatic inline ECP::Point ToMontgomery(const ModularArithmetic &mr, const ECP::Point &P)\n{\n\treturn P.identity ? P : ECP::Point(mr.ConvertIn(P.x), mr.ConvertIn(P.y));\n}",
          "includes": [
            "#include \"algebra.cpp\"",
            "#include \"nbtheory.h\"",
            "#include \"asn.h\"",
            "#include \"ecp.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nANONYMOUS_NAMESPACE_BEGIN\nstatic inline ECP::Point ToMontgomery(const ModularArithmetic &mr, const ECP::Point &P)\n{\n\treturn P.identity ? P : ECP::Point(mr.ConvertIn(P.x), mr.ConvertIn(P.y));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecpmr.GetField",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "GetFieldType",
          "container": "DL_GroupParameters_LUC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.h",
          "lines": "168-168",
          "snippet": "int GetFieldType() const {return 2;}",
          "includes": [
            "#include <limits.h>",
            "#include \"dh.h\"",
            "#include \"integer.h\"",
            "#include \"oaep.h\"",
            "#include \"pkcspad.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"dh.h\"\n#include \"integer.h\"\n#include \"oaep.h\"\n#include \"pkcspad.h\"\n\nDL_GroupParameters_LUC {\n  int GetFieldType() const {return 2;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  ECP::Point ECP::CascadeScalarMultiply(const Point &P, const Integer &k1, const Point &Q, const Integer &k2) const\n  {\n  \tif (!GetField().IsMontgomeryRepresentation())\n  \t{\n  \t\tECP ecpmr(*this, true);\n  \t\tconst ModularArithmetic &mr = ecpmr.GetField();\n  \t\treturn FromMontgomery(mr, ecpmr.CascadeScalarMultiply(ToMontgomery(mr, P), k1, ToMontgomery(mr, Q), k2));\n  \t}\n  \telse\n  \t\treturn AbstractGroup<Point>::CascadeScalarMultiply(P, k1, Q, k2);\n  }\n}"
  },
  {
    "function_name": "SimultaneousMultiply",
    "container": "ECP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "361-457",
    "snippet": "void ECP::SimultaneousMultiply(ECP::Point *results, const ECP::Point &P, const Integer *expBegin, unsigned int expCount) const\n{\n\tif (!GetField().IsMontgomeryRepresentation())\n\t{\n\t\tECP ecpmr(*this, true);\n\t\tconst ModularArithmetic &mr = ecpmr.GetField();\n\t\tecpmr.SimultaneousMultiply(results, ToMontgomery(mr, P), expBegin, expCount);\n\t\tfor (unsigned int i=0; i<expCount; i++)\n\t\t\tresults[i] = FromMontgomery(mr, results[i]);\n\t\treturn;\n\t}\n\n\tProjectiveDoubling rd(GetField(), m_a, m_b, P);\n\tstd::vector<ProjectivePoint> bases;\n\tstd::vector<WindowSlider> exponents;\n\texponents.reserve(expCount);\n\tstd::vector<std::vector<word32> > baseIndices(expCount);\n\tstd::vector<std::vector<bool> > negateBase(expCount);\n\tstd::vector<std::vector<word32> > exponentWindows(expCount);\n\tunsigned int i;\n\n\tfor (i=0; i<expCount; i++)\n\t{\n\t\tassert(expBegin->NotNegative());\n\t\texponents.push_back(WindowSlider(*expBegin++, InversionIsFast(), 5));\n\t\texponents[i].FindNextWindow();\n\t}\n\n\tunsigned int expBitPosition = 0;\n\tbool notDone = true;\n\n\twhile (notDone)\n\t{\n\t\tnotDone = false;\n\t\tbool baseAdded = false;\n\t\tfor (i=0; i<expCount; i++)\n\t\t{\n\t\t\tif (!exponents[i].finished && expBitPosition == exponents[i].windowBegin)\n\t\t\t{\n\t\t\t\tif (!baseAdded)\n\t\t\t\t{\n\t\t\t\t\tbases.push_back(rd.P);\n\t\t\t\t\tbaseAdded =true;\n\t\t\t\t}\n\n\t\t\t\texponentWindows[i].push_back(exponents[i].expWindow);\n\t\t\t\tbaseIndices[i].push_back((word32)bases.size()-1);\n\t\t\t\tnegateBase[i].push_back(exponents[i].negateNext);\n\n\t\t\t\texponents[i].FindNextWindow();\n\t\t\t}\n\t\t\tnotDone = notDone || !exponents[i].finished;\n\t\t}\n\n\t\tif (notDone)\n\t\t{\n\t\t\trd.Double();\n\t\t\texpBitPosition++;\n\t\t}\n\t}\n\n\t// convert from projective to affine coordinates\n\tParallelInvert(GetField(), ZIterator(bases.begin()), ZIterator(bases.end()));\n\tfor (i=0; i<bases.size(); i++)\n\t{\n\t\tif (bases[i].z.NotZero())\n\t\t{\n\t\t\tbases[i].y = GetField().Multiply(bases[i].y, bases[i].z);\n\t\t\tbases[i].z = GetField().Square(bases[i].z);\n\t\t\tbases[i].x = GetField().Multiply(bases[i].x, bases[i].z);\n\t\t\tbases[i].y = GetField().Multiply(bases[i].y, bases[i].z);\n\t\t}\n\t}\n\n\tstd::vector<BaseAndExponent<Point, Integer> > finalCascade;\n\tfor (i=0; i<expCount; i++)\n\t{\n\t\tfinalCascade.resize(baseIndices[i].size());\n\t\tfor (unsigned int j=0; j<baseIndices[i].size(); j++)\n\t\t{\n\t\t\tProjectivePoint &base = bases[baseIndices[i][j]];\n\t\t\tif (base.z.IsZero())\n\t\t\t\tfinalCascade[j].base.identity = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfinalCascade[j].base.identity = false;\n\t\t\t\tfinalCascade[j].base.x = base.x;\n\t\t\t\tif (negateBase[i][j])\n\t\t\t\t\tfinalCascade[j].base.y = GetField().Inverse(base.y);\n\t\t\t\telse\n\t\t\t\t\tfinalCascade[j].base.y = base.y;\n\t\t\t}\n\t\t\tfinalCascade[j].exponent = Integer(Integer::POSITIVE, 0, exponentWindows[i][j]);\n\t\t}\n\t\tresults[i] = GeneralCascadeMultiplication(*this, finalCascade.begin(), finalCascade.end());\n\t}\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GeneralCascadeMultiplication",
          "args": [
            "*this",
            "finalCascade.begin()",
            "finalCascade.end()"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "GeneralCascadeMultiplication",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algebra.cpp",
          "lines": "172-204",
          "snippet": "Element GeneralCascadeMultiplication(const AbstractGroup<Element> &group, Iterator begin, Iterator end)\n{\n\tif (end-begin == 1)\n\t\treturn group.ScalarMultiply(begin->base, begin->exponent);\n\telse if (end-begin == 2)\n\t\treturn group.CascadeScalarMultiply(begin->base, begin->exponent, (begin+1)->base, (begin+1)->exponent);\n\telse\n\t{\n\t\tInteger q, t;\n\t\tIterator last = end;\n\t\t--last;\n\n\t\tstd::make_heap(begin, end);\n\t\tstd::pop_heap(begin, end);\n\n\t\twhile (!!begin->exponent)\n\t\t{\n\t\t\t// last->exponent is largest exponent, begin->exponent is next largest\n\t\t\tt = last->exponent;\n\t\t\tInteger::Divide(last->exponent, q, t, begin->exponent);\n\n\t\t\tif (q == Integer::One())\n\t\t\t\tgroup.Accumulate(begin->base, last->base);\t// avoid overhead of ScalarMultiply()\n\t\t\telse\n\t\t\t\tgroup.Accumulate(begin->base, group.ScalarMultiply(last->base, q));\n\n\t\t\tstd::push_heap(begin, end);\n\t\t\tstd::pop_heap(begin, end);\n\t\t}\n\n\t\treturn group.ScalarMultiply(last->base, last->exponent);\n\t}\n}",
          "includes": [
            "#include <vector>",
            "#include \"integer.h\"",
            "#include \"algebra.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"integer.h\"\n#include \"algebra.h\"\n#include \"pch.h\"\n\nElement GeneralCascadeMultiplication(const AbstractGroup<Element> &group, Iterator begin, Iterator end)\n{\n\tif (end-begin == 1)\n\t\treturn group.ScalarMultiply(begin->base, begin->exponent);\n\telse if (end-begin == 2)\n\t\treturn group.CascadeScalarMultiply(begin->base, begin->exponent, (begin+1)->base, (begin+1)->exponent);\n\telse\n\t{\n\t\tInteger q, t;\n\t\tIterator last = end;\n\t\t--last;\n\n\t\tstd::make_heap(begin, end);\n\t\tstd::pop_heap(begin, end);\n\n\t\twhile (!!begin->exponent)\n\t\t{\n\t\t\t// last->exponent is largest exponent, begin->exponent is next largest\n\t\t\tt = last->exponent;\n\t\t\tInteger::Divide(last->exponent, q, t, begin->exponent);\n\n\t\t\tif (q == Integer::One())\n\t\t\t\tgroup.Accumulate(begin->base, last->base);\t// avoid overhead of ScalarMultiply()\n\t\t\telse\n\t\t\t\tgroup.Accumulate(begin->base, group.ScalarMultiply(last->base, q));\n\n\t\t\tstd::push_heap(begin, end);\n\t\t\tstd::pop_heap(begin, end);\n\t\t}\n\n\t\treturn group.ScalarMultiply(last->base, last->exponent);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "finalCascade.end",
          "args": [],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "finalCascade.begin",
          "args": [],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer",
          "args": [
            "Integer::POSITIVE",
            "0",
            "exponentWindows[i][j]"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "Randomize",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3210-3225",
          "snippet": "void Integer::Randomize(RandomNumberGenerator &rng, const Integer &min, const Integer &max)\n{\n\tif (min > max)\n\t\tthrow InvalidArgument(\"Integer: Min must be no greater than Max\");\n\n\tInteger range = max - min;\n\tconst unsigned int nbits = range.BitCount();\n\n\tdo\n\t{\n\t\tRandomize(rng, nbits);\n\t}\n\twhile (*this > range);\n\n\t*this += min;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  void Integer::Randomize(RandomNumberGenerator &rng, const Integer &min, const Integer &max)\n  {\n  \tif (min > max)\n  \t\tthrow InvalidArgument(\"Integer: Min must be no greater than Max\");\n  \n  \tInteger range = max - min;\n  \tconst unsigned int nbits = range.BitCount();\n  \n  \tdo\n  \t{\n  \t\tRandomize(rng, nbits);\n  \t}\n  \twhile (*this > range);\n  \n  \t*this += min;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [
            "base.y"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "GetFieldType",
          "container": "DL_GroupParameters_LUC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.h",
          "lines": "168-168",
          "snippet": "int GetFieldType() const {return 2;}",
          "includes": [
            "#include <limits.h>",
            "#include \"dh.h\"",
            "#include \"integer.h\"",
            "#include \"oaep.h\"",
            "#include \"pkcspad.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"dh.h\"\n#include \"integer.h\"\n#include \"oaep.h\"\n#include \"pkcspad.h\"\n\nDL_GroupParameters_LUC {\n  int GetFieldType() const {return 2;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "base.z.IsZero",
          "args": [],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "IsZero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "197-197",
          "snippet": "bool IsZero() const {return !*this;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsZero() const {return !*this;}"
        }
      },
      {
        "call_info": {
          "callee": "baseIndices[i].size",
          "args": [],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "finalCascade.resize",
          "args": [
            "baseIndices[i].size()"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "203-211",
          "snippet": "void resize(size_t newSize)\n\t{\n\t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n\t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n\t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n\t\tdelete [] this->m_ptr;\n\t\tthis->m_size = newSize;\n\t\tthis->m_ptr = newPtr;\n\t}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  void resize(size_t newSize)\n  \t{\n  \t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n  \t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n  \t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n  \t\tdelete [] this->m_ptr;\n  \t\tthis->m_size = newSize;\n  \t\tthis->m_ptr = newPtr;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [
            "bases[i].y",
            "bases[i].z"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [
            "bases[i].x",
            "bases[i].z"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [
            "bases[i].z"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [
            "bases[i].y",
            "bases[i].z"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bases[i].z.NotZero",
          "args": [],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "NotZero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "199-199",
          "snippet": "bool NotZero() const {return !IsZero();}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool NotZero() const {return !IsZero();}"
        }
      },
      {
        "call_info": {
          "callee": "ParallelInvert",
          "args": [
            "GetField()",
            "ZIterator(bases.begin())",
            "ZIterator(bases.end())"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "ParallelInvert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
          "lines": "250-285",
          "snippet": "void ParallelInvert(const AbstractRing<T> &ring, Iterator begin, Iterator end)\n{\n\tsize_t n = end-begin;\n\tif (n == 1)\n\t\t*begin = ring.MultiplicativeInverse(*begin);\n\telse if (n > 1)\n\t{\n\t\tstd::vector<T> vec((n+1)/2);\n\t\tunsigned int i;\n\t\tIterator it;\n\n\t\tfor (i=0, it=begin; i<n/2; i++, it+=2)\n\t\t\tvec[i] = ring.Multiply(*it, *(it+1));\n\t\tif (n%2 == 1)\n\t\t\tvec[n/2] = *it;\n\n\t\tParallelInvert(ring, vec.begin(), vec.end());\n\n\t\tfor (i=0, it=begin; i<n/2; i++, it+=2)\n\t\t{\n\t\t\tif (!vec[i])\n\t\t\t{\n\t\t\t\t*it = ring.MultiplicativeInverse(*it);\n\t\t\t\t*(it+1) = ring.MultiplicativeInverse(*(it+1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::swap(*it, *(it+1));\n\t\t\t\t*it = ring.Multiply(*it, vec[i]);\n\t\t\t\t*(it+1) = ring.Multiply(*(it+1), vec[i]);\n\t\t\t}\n\t\t}\n\t\tif (n%2 == 1)\n\t\t\t*it = vec[n/2];\n\t}\n}",
          "includes": [
            "#include \"algebra.cpp\"",
            "#include \"nbtheory.h\"",
            "#include \"asn.h\"",
            "#include \"ecp.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nvoid ParallelInvert(const AbstractRing<T> &ring, Iterator begin, Iterator end)\n{\n\tsize_t n = end-begin;\n\tif (n == 1)\n\t\t*begin = ring.MultiplicativeInverse(*begin);\n\telse if (n > 1)\n\t{\n\t\tstd::vector<T> vec((n+1)/2);\n\t\tunsigned int i;\n\t\tIterator it;\n\n\t\tfor (i=0, it=begin; i<n/2; i++, it+=2)\n\t\t\tvec[i] = ring.Multiply(*it, *(it+1));\n\t\tif (n%2 == 1)\n\t\t\tvec[n/2] = *it;\n\n\t\tParallelInvert(ring, vec.begin(), vec.end());\n\n\t\tfor (i=0, it=begin; i<n/2; i++, it+=2)\n\t\t{\n\t\t\tif (!vec[i])\n\t\t\t{\n\t\t\t\t*it = ring.MultiplicativeInverse(*it);\n\t\t\t\t*(it+1) = ring.MultiplicativeInverse(*(it+1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::swap(*it, *(it+1));\n\t\t\t\t*it = ring.Multiply(*it, vec[i]);\n\t\t\t\t*(it+1) = ring.Multiply(*(it+1), vec[i]);\n\t\t\t}\n\t\t}\n\t\tif (n%2 == 1)\n\t\t\t*it = vec[n/2];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ZIterator",
          "args": [
            "bases.end()"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "ZIterator",
          "container": "ZIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
          "lines": "343-343",
          "snippet": "ZIterator(std::vector<ProjectivePoint>::iterator it) : it(it) {}",
          "includes": [
            "#include \"algebra.cpp\"",
            "#include \"nbtheory.h\"",
            "#include \"asn.h\"",
            "#include \"ecp.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nZIterator {\n  ZIterator(std::vector<ProjectivePoint>::iterator it) : it(it) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rd.Double",
          "args": [],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "Double",
          "container": "ProjectiveDoubling",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
          "lines": "316-332",
          "snippet": "void Double()\n\t{\n\t\ttwoY = mr.Double(P.y);\n\t\tP.z = mr.Multiply(P.z, twoY);\n\t\tfourY2 = mr.Square(twoY);\n\t\tS = mr.Multiply(fourY2, P.x);\n\t\taZ4 = mr.Multiply(aZ4, sixteenY4);\n\t\tM = mr.Square(P.x);\n\t\tM = mr.Add(mr.Add(mr.Double(M), M), aZ4);\n\t\tP.x = mr.Square(M);\n\t\tmr.Reduce(P.x, S);\n\t\tmr.Reduce(P.x, S);\n\t\tmr.Reduce(S, P.x);\n\t\tP.y = mr.Multiply(M, S);\n\t\tsixteenY4 = mr.Square(fourY2);\n\t\tmr.Reduce(P.y, mr.Half(sixteenY4));\n\t}",
          "includes": [
            "#include \"algebra.cpp\"",
            "#include \"nbtheory.h\"",
            "#include \"asn.h\"",
            "#include \"ecp.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nProjectiveDoubling {\n  void Double()\n  \t{\n  \t\ttwoY = mr.Double(P.y);\n  \t\tP.z = mr.Multiply(P.z, twoY);\n  \t\tfourY2 = mr.Square(twoY);\n  \t\tS = mr.Multiply(fourY2, P.x);\n  \t\taZ4 = mr.Multiply(aZ4, sixteenY4);\n  \t\tM = mr.Square(P.x);\n  \t\tM = mr.Add(mr.Add(mr.Double(M), M), aZ4);\n  \t\tP.x = mr.Square(M);\n  \t\tmr.Reduce(P.x, S);\n  \t\tmr.Reduce(P.x, S);\n  \t\tmr.Reduce(S, P.x);\n  \t\tP.y = mr.Multiply(M, S);\n  \t\tsixteenY4 = mr.Square(fourY2);\n  \t\tmr.Reduce(P.y, mr.Half(sixteenY4));\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exponents[i].FindNextWindow",
          "args": [],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "FindNextWindow",
          "container": "WindowSlider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algebra.cpp",
          "lines": "219-246",
          "snippet": "void FindNextWindow()\n\t{\n\t\tunsigned int expLen = exp.WordCount() * WORD_BITS;\n\t\tunsigned int skipCount = firstTime ? 0 : windowSize;\n\t\tfirstTime = false;\n\t\twhile (!exp.GetBit(skipCount))\n\t\t{\n\t\t\tif (skipCount >= expLen)\n\t\t\t{\n\t\t\t\tfinished = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tskipCount++;\n\t\t}\n\n\t\texp >>= skipCount;\n\t\twindowBegin += skipCount;\n\t\texpWindow = word32(exp % (word(1) << windowSize));\n\n\t\tif (fastNegate && exp.GetBit(windowSize))\n\t\t{\n\t\t\tnegateNext = true;\n\t\t\texpWindow = (word32(1) << windowSize) - expWindow;\n\t\t\texp += windowModulus;\n\t\t}\n\t\telse\n\t\t\tnegateNext = false;\n\t}",
          "includes": [
            "#include <vector>",
            "#include \"integer.h\"",
            "#include \"algebra.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"integer.h\"\n#include \"algebra.h\"\n#include \"pch.h\"\n\nWindowSlider {\n  void FindNextWindow()\n  \t{\n  \t\tunsigned int expLen = exp.WordCount() * WORD_BITS;\n  \t\tunsigned int skipCount = firstTime ? 0 : windowSize;\n  \t\tfirstTime = false;\n  \t\twhile (!exp.GetBit(skipCount))\n  \t\t{\n  \t\t\tif (skipCount >= expLen)\n  \t\t\t{\n  \t\t\t\tfinished = true;\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t\tskipCount++;\n  \t\t}\n  \n  \t\texp >>= skipCount;\n  \t\twindowBegin += skipCount;\n  \t\texpWindow = word32(exp % (word(1) << windowSize));\n  \n  \t\tif (fastNegate && exp.GetBit(windowSize))\n  \t\t{\n  \t\t\tnegateNext = true;\n  \t\t\texpWindow = (word32(1) << windowSize) - expWindow;\n  \t\t\texp += windowModulus;\n  \t\t}\n  \t\telse\n  \t\t\tnegateNext = false;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "negateBase[i].push_back",
          "args": [
            "exponents[i].negateNext"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "baseIndices[i].push_back",
          "args": [
            "(word32)bases.size()-1"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exponentWindows[i].push_back",
          "args": [
            "exponents[i].expWindow"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bases.push_back",
          "args": [
            "rd.P"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exponents.push_back",
          "args": [
            "WindowSlider(*expBegin++, InversionIsFast(), 5)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WindowSlider",
          "args": [
            "*expBegin++",
            "InversionIsFast()",
            "5"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InversionIsFast",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "expBegin->NotNegative()"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expBegin->NotNegative",
          "args": [],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "NotNegative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "203-203",
          "snippet": "bool NotNegative() const {return !IsNegative();}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool NotNegative() const {return !IsNegative();}"
        }
      },
      {
        "call_info": {
          "callee": "exponents.reserve",
          "args": [
            "expCount"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FromMontgomery",
          "args": [
            "mr",
            "results[i]"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "FromMontgomery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
          "lines": "21-24",
          "snippet": "static inline ECP::Point FromMontgomery(const ModularArithmetic &mr, const ECP::Point &P)\n{\n\treturn P.identity ? P : ECP::Point(mr.ConvertOut(P.x), mr.ConvertOut(P.y));\n}",
          "includes": [
            "#include \"algebra.cpp\"",
            "#include \"nbtheory.h\"",
            "#include \"asn.h\"",
            "#include \"ecp.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nstatic inline ECP::Point FromMontgomery(const ModularArithmetic &mr, const ECP::Point &P)\n{\n\treturn P.identity ? P : ECP::Point(mr.ConvertOut(P.x), mr.ConvertOut(P.y));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecpmr.SimultaneousMultiply",
          "args": [
            "results",
            "ToMontgomery(mr, P)",
            "expBegin",
            "expCount"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "SimultaneousMultiply",
          "container": "ECP",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
          "lines": "361-457",
          "snippet": "void ECP::SimultaneousMultiply(ECP::Point *results, const ECP::Point &P, const Integer *expBegin, unsigned int expCount) const\n{\n\tif (!GetField().IsMontgomeryRepresentation())\n\t{\n\t\tECP ecpmr(*this, true);\n\t\tconst ModularArithmetic &mr = ecpmr.GetField();\n\t\tecpmr.SimultaneousMultiply(results, ToMontgomery(mr, P), expBegin, expCount);\n\t\tfor (unsigned int i=0; i<expCount; i++)\n\t\t\tresults[i] = FromMontgomery(mr, results[i]);\n\t\treturn;\n\t}\n\n\tProjectiveDoubling rd(GetField(), m_a, m_b, P);\n\tstd::vector<ProjectivePoint> bases;\n\tstd::vector<WindowSlider> exponents;\n\texponents.reserve(expCount);\n\tstd::vector<std::vector<word32> > baseIndices(expCount);\n\tstd::vector<std::vector<bool> > negateBase(expCount);\n\tstd::vector<std::vector<word32> > exponentWindows(expCount);\n\tunsigned int i;\n\n\tfor (i=0; i<expCount; i++)\n\t{\n\t\tassert(expBegin->NotNegative());\n\t\texponents.push_back(WindowSlider(*expBegin++, InversionIsFast(), 5));\n\t\texponents[i].FindNextWindow();\n\t}\n\n\tunsigned int expBitPosition = 0;\n\tbool notDone = true;\n\n\twhile (notDone)\n\t{\n\t\tnotDone = false;\n\t\tbool baseAdded = false;\n\t\tfor (i=0; i<expCount; i++)\n\t\t{\n\t\t\tif (!exponents[i].finished && expBitPosition == exponents[i].windowBegin)\n\t\t\t{\n\t\t\t\tif (!baseAdded)\n\t\t\t\t{\n\t\t\t\t\tbases.push_back(rd.P);\n\t\t\t\t\tbaseAdded =true;\n\t\t\t\t}\n\n\t\t\t\texponentWindows[i].push_back(exponents[i].expWindow);\n\t\t\t\tbaseIndices[i].push_back((word32)bases.size()-1);\n\t\t\t\tnegateBase[i].push_back(exponents[i].negateNext);\n\n\t\t\t\texponents[i].FindNextWindow();\n\t\t\t}\n\t\t\tnotDone = notDone || !exponents[i].finished;\n\t\t}\n\n\t\tif (notDone)\n\t\t{\n\t\t\trd.Double();\n\t\t\texpBitPosition++;\n\t\t}\n\t}\n\n\t// convert from projective to affine coordinates\n\tParallelInvert(GetField(), ZIterator(bases.begin()), ZIterator(bases.end()));\n\tfor (i=0; i<bases.size(); i++)\n\t{\n\t\tif (bases[i].z.NotZero())\n\t\t{\n\t\t\tbases[i].y = GetField().Multiply(bases[i].y, bases[i].z);\n\t\t\tbases[i].z = GetField().Square(bases[i].z);\n\t\t\tbases[i].x = GetField().Multiply(bases[i].x, bases[i].z);\n\t\t\tbases[i].y = GetField().Multiply(bases[i].y, bases[i].z);\n\t\t}\n\t}\n\n\tstd::vector<BaseAndExponent<Point, Integer> > finalCascade;\n\tfor (i=0; i<expCount; i++)\n\t{\n\t\tfinalCascade.resize(baseIndices[i].size());\n\t\tfor (unsigned int j=0; j<baseIndices[i].size(); j++)\n\t\t{\n\t\t\tProjectivePoint &base = bases[baseIndices[i][j]];\n\t\t\tif (base.z.IsZero())\n\t\t\t\tfinalCascade[j].base.identity = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfinalCascade[j].base.identity = false;\n\t\t\t\tfinalCascade[j].base.x = base.x;\n\t\t\t\tif (negateBase[i][j])\n\t\t\t\t\tfinalCascade[j].base.y = GetField().Inverse(base.y);\n\t\t\t\telse\n\t\t\t\t\tfinalCascade[j].base.y = base.y;\n\t\t\t}\n\t\t\tfinalCascade[j].exponent = Integer(Integer::POSITIVE, 0, exponentWindows[i][j]);\n\t\t}\n\t\tresults[i] = GeneralCascadeMultiplication(*this, finalCascade.begin(), finalCascade.end());\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ToMontgomery",
          "args": [
            "mr",
            "P"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "ToMontgomery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
          "lines": "15-19",
          "snippet": "ANONYMOUS_NAMESPACE_BEGIN\nstatic inline ECP::Point ToMontgomery(const ModularArithmetic &mr, const ECP::Point &P)\n{\n\treturn P.identity ? P : ECP::Point(mr.ConvertIn(P.x), mr.ConvertIn(P.y));\n}",
          "includes": [
            "#include \"algebra.cpp\"",
            "#include \"nbtheory.h\"",
            "#include \"asn.h\"",
            "#include \"ecp.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nANONYMOUS_NAMESPACE_BEGIN\nstatic inline ECP::Point ToMontgomery(const ModularArithmetic &mr, const ECP::Point &P)\n{\n\treturn P.identity ? P : ECP::Point(mr.ConvertIn(P.x), mr.ConvertIn(P.y));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecpmr.GetField",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  void ECP::SimultaneousMultiply(ECP::Point *results, const ECP::Point &P, const Integer *expBegin, unsigned int expCount) const\n  {\n  \tif (!GetField().IsMontgomeryRepresentation())\n  \t{\n  \t\tECP ecpmr(*this, true);\n  \t\tconst ModularArithmetic &mr = ecpmr.GetField();\n  \t\tecpmr.SimultaneousMultiply(results, ToMontgomery(mr, P), expBegin, expCount);\n  \t\tfor (unsigned int i=0; i<expCount; i++)\n  \t\t\tresults[i] = FromMontgomery(mr, results[i]);\n  \t\treturn;\n  \t}\n  \n  \tProjectiveDoubling rd(GetField(), m_a, m_b, P);\n  \tstd::vector<ProjectivePoint> bases;\n  \tstd::vector<WindowSlider> exponents;\n  \texponents.reserve(expCount);\n  \tstd::vector<std::vector<word32> > baseIndices(expCount);\n  \tstd::vector<std::vector<bool> > negateBase(expCount);\n  \tstd::vector<std::vector<word32> > exponentWindows(expCount);\n  \tunsigned int i;\n  \n  \tfor (i=0; i<expCount; i++)\n  \t{\n  \t\tassert(expBegin->NotNegative());\n  \t\texponents.push_back(WindowSlider(*expBegin++, InversionIsFast(), 5));\n  \t\texponents[i].FindNextWindow();\n  \t}\n  \n  \tunsigned int expBitPosition = 0;\n  \tbool notDone = true;\n  \n  \twhile (notDone)\n  \t{\n  \t\tnotDone = false;\n  \t\tbool baseAdded = false;\n  \t\tfor (i=0; i<expCount; i++)\n  \t\t{\n  \t\t\tif (!exponents[i].finished && expBitPosition == exponents[i].windowBegin)\n  \t\t\t{\n  \t\t\t\tif (!baseAdded)\n  \t\t\t\t{\n  \t\t\t\t\tbases.push_back(rd.P);\n  \t\t\t\t\tbaseAdded =true;\n  \t\t\t\t}\n  \n  \t\t\t\texponentWindows[i].push_back(exponents[i].expWindow);\n  \t\t\t\tbaseIndices[i].push_back((word32)bases.size()-1);\n  \t\t\t\tnegateBase[i].push_back(exponents[i].negateNext);\n  \n  \t\t\t\texponents[i].FindNextWindow();\n  \t\t\t}\n  \t\t\tnotDone = notDone || !exponents[i].finished;\n  \t\t}\n  \n  \t\tif (notDone)\n  \t\t{\n  \t\t\trd.Double();\n  \t\t\texpBitPosition++;\n  \t\t}\n  \t}\n  \n  \t// convert from projective to affine coordinates\n  \tParallelInvert(GetField(), ZIterator(bases.begin()), ZIterator(bases.end()));\n  \tfor (i=0; i<bases.size(); i++)\n  \t{\n  \t\tif (bases[i].z.NotZero())\n  \t\t{\n  \t\t\tbases[i].y = GetField().Multiply(bases[i].y, bases[i].z);\n  \t\t\tbases[i].z = GetField().Square(bases[i].z);\n  \t\t\tbases[i].x = GetField().Multiply(bases[i].x, bases[i].z);\n  \t\t\tbases[i].y = GetField().Multiply(bases[i].y, bases[i].z);\n  \t\t}\n  \t}\n  \n  \tstd::vector<BaseAndExponent<Point, Integer> > finalCascade;\n  \tfor (i=0; i<expCount; i++)\n  \t{\n  \t\tfinalCascade.resize(baseIndices[i].size());\n  \t\tfor (unsigned int j=0; j<baseIndices[i].size(); j++)\n  \t\t{\n  \t\t\tProjectivePoint &base = bases[baseIndices[i][j]];\n  \t\t\tif (base.z.IsZero())\n  \t\t\t\tfinalCascade[j].base.identity = true;\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tfinalCascade[j].base.identity = false;\n  \t\t\t\tfinalCascade[j].base.x = base.x;\n  \t\t\t\tif (negateBase[i][j])\n  \t\t\t\t\tfinalCascade[j].base.y = GetField().Inverse(base.y);\n  \t\t\t\telse\n  \t\t\t\t\tfinalCascade[j].base.y = base.y;\n  \t\t\t}\n  \t\t\tfinalCascade[j].exponent = Integer(Integer::POSITIVE, 0, exponentWindows[i][j]);\n  \t\t}\n  \t\tresults[i] = GeneralCascadeMultiplication(*this, finalCascade.begin(), finalCascade.end());\n  \t}\n  }\n}"
  },
  {
    "function_name": "ScalarMultiply",
    "container": "ECP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "351-359",
    "snippet": "ECP::Point ECP::ScalarMultiply(const Point &P, const Integer &k) const\n{\n\tElement result;\n\tif (k.BitCount() <= 5)\n\t\tAbstractGroup<ECPPoint>::SimultaneousMultiply(&result, P, &k, 1);\n\telse\n\t\tECP::SimultaneousMultiply(&result, P, &k, 1);\n\treturn result;\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ECP::SimultaneousMultiply",
          "args": [
            "&result",
            "P",
            "&k",
            "1"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "SimultaneousMultiply",
          "container": "ECP",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
          "lines": "361-457",
          "snippet": "void ECP::SimultaneousMultiply(ECP::Point *results, const ECP::Point &P, const Integer *expBegin, unsigned int expCount) const\n{\n\tif (!GetField().IsMontgomeryRepresentation())\n\t{\n\t\tECP ecpmr(*this, true);\n\t\tconst ModularArithmetic &mr = ecpmr.GetField();\n\t\tecpmr.SimultaneousMultiply(results, ToMontgomery(mr, P), expBegin, expCount);\n\t\tfor (unsigned int i=0; i<expCount; i++)\n\t\t\tresults[i] = FromMontgomery(mr, results[i]);\n\t\treturn;\n\t}\n\n\tProjectiveDoubling rd(GetField(), m_a, m_b, P);\n\tstd::vector<ProjectivePoint> bases;\n\tstd::vector<WindowSlider> exponents;\n\texponents.reserve(expCount);\n\tstd::vector<std::vector<word32> > baseIndices(expCount);\n\tstd::vector<std::vector<bool> > negateBase(expCount);\n\tstd::vector<std::vector<word32> > exponentWindows(expCount);\n\tunsigned int i;\n\n\tfor (i=0; i<expCount; i++)\n\t{\n\t\tassert(expBegin->NotNegative());\n\t\texponents.push_back(WindowSlider(*expBegin++, InversionIsFast(), 5));\n\t\texponents[i].FindNextWindow();\n\t}\n\n\tunsigned int expBitPosition = 0;\n\tbool notDone = true;\n\n\twhile (notDone)\n\t{\n\t\tnotDone = false;\n\t\tbool baseAdded = false;\n\t\tfor (i=0; i<expCount; i++)\n\t\t{\n\t\t\tif (!exponents[i].finished && expBitPosition == exponents[i].windowBegin)\n\t\t\t{\n\t\t\t\tif (!baseAdded)\n\t\t\t\t{\n\t\t\t\t\tbases.push_back(rd.P);\n\t\t\t\t\tbaseAdded =true;\n\t\t\t\t}\n\n\t\t\t\texponentWindows[i].push_back(exponents[i].expWindow);\n\t\t\t\tbaseIndices[i].push_back((word32)bases.size()-1);\n\t\t\t\tnegateBase[i].push_back(exponents[i].negateNext);\n\n\t\t\t\texponents[i].FindNextWindow();\n\t\t\t}\n\t\t\tnotDone = notDone || !exponents[i].finished;\n\t\t}\n\n\t\tif (notDone)\n\t\t{\n\t\t\trd.Double();\n\t\t\texpBitPosition++;\n\t\t}\n\t}\n\n\t// convert from projective to affine coordinates\n\tParallelInvert(GetField(), ZIterator(bases.begin()), ZIterator(bases.end()));\n\tfor (i=0; i<bases.size(); i++)\n\t{\n\t\tif (bases[i].z.NotZero())\n\t\t{\n\t\t\tbases[i].y = GetField().Multiply(bases[i].y, bases[i].z);\n\t\t\tbases[i].z = GetField().Square(bases[i].z);\n\t\t\tbases[i].x = GetField().Multiply(bases[i].x, bases[i].z);\n\t\t\tbases[i].y = GetField().Multiply(bases[i].y, bases[i].z);\n\t\t}\n\t}\n\n\tstd::vector<BaseAndExponent<Point, Integer> > finalCascade;\n\tfor (i=0; i<expCount; i++)\n\t{\n\t\tfinalCascade.resize(baseIndices[i].size());\n\t\tfor (unsigned int j=0; j<baseIndices[i].size(); j++)\n\t\t{\n\t\t\tProjectivePoint &base = bases[baseIndices[i][j]];\n\t\t\tif (base.z.IsZero())\n\t\t\t\tfinalCascade[j].base.identity = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfinalCascade[j].base.identity = false;\n\t\t\t\tfinalCascade[j].base.x = base.x;\n\t\t\t\tif (negateBase[i][j])\n\t\t\t\t\tfinalCascade[j].base.y = GetField().Inverse(base.y);\n\t\t\t\telse\n\t\t\t\t\tfinalCascade[j].base.y = base.y;\n\t\t\t}\n\t\t\tfinalCascade[j].exponent = Integer(Integer::POSITIVE, 0, exponentWindows[i][j]);\n\t\t}\n\t\tresults[i] = GeneralCascadeMultiplication(*this, finalCascade.begin(), finalCascade.end());\n\t}\n}",
          "includes": [
            "#include \"algebra.cpp\"",
            "#include \"nbtheory.h\"",
            "#include \"asn.h\"",
            "#include \"ecp.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  void ECP::SimultaneousMultiply(ECP::Point *results, const ECP::Point &P, const Integer *expBegin, unsigned int expCount) const\n  {\n  \tif (!GetField().IsMontgomeryRepresentation())\n  \t{\n  \t\tECP ecpmr(*this, true);\n  \t\tconst ModularArithmetic &mr = ecpmr.GetField();\n  \t\tecpmr.SimultaneousMultiply(results, ToMontgomery(mr, P), expBegin, expCount);\n  \t\tfor (unsigned int i=0; i<expCount; i++)\n  \t\t\tresults[i] = FromMontgomery(mr, results[i]);\n  \t\treturn;\n  \t}\n  \n  \tProjectiveDoubling rd(GetField(), m_a, m_b, P);\n  \tstd::vector<ProjectivePoint> bases;\n  \tstd::vector<WindowSlider> exponents;\n  \texponents.reserve(expCount);\n  \tstd::vector<std::vector<word32> > baseIndices(expCount);\n  \tstd::vector<std::vector<bool> > negateBase(expCount);\n  \tstd::vector<std::vector<word32> > exponentWindows(expCount);\n  \tunsigned int i;\n  \n  \tfor (i=0; i<expCount; i++)\n  \t{\n  \t\tassert(expBegin->NotNegative());\n  \t\texponents.push_back(WindowSlider(*expBegin++, InversionIsFast(), 5));\n  \t\texponents[i].FindNextWindow();\n  \t}\n  \n  \tunsigned int expBitPosition = 0;\n  \tbool notDone = true;\n  \n  \twhile (notDone)\n  \t{\n  \t\tnotDone = false;\n  \t\tbool baseAdded = false;\n  \t\tfor (i=0; i<expCount; i++)\n  \t\t{\n  \t\t\tif (!exponents[i].finished && expBitPosition == exponents[i].windowBegin)\n  \t\t\t{\n  \t\t\t\tif (!baseAdded)\n  \t\t\t\t{\n  \t\t\t\t\tbases.push_back(rd.P);\n  \t\t\t\t\tbaseAdded =true;\n  \t\t\t\t}\n  \n  \t\t\t\texponentWindows[i].push_back(exponents[i].expWindow);\n  \t\t\t\tbaseIndices[i].push_back((word32)bases.size()-1);\n  \t\t\t\tnegateBase[i].push_back(exponents[i].negateNext);\n  \n  \t\t\t\texponents[i].FindNextWindow();\n  \t\t\t}\n  \t\t\tnotDone = notDone || !exponents[i].finished;\n  \t\t}\n  \n  \t\tif (notDone)\n  \t\t{\n  \t\t\trd.Double();\n  \t\t\texpBitPosition++;\n  \t\t}\n  \t}\n  \n  \t// convert from projective to affine coordinates\n  \tParallelInvert(GetField(), ZIterator(bases.begin()), ZIterator(bases.end()));\n  \tfor (i=0; i<bases.size(); i++)\n  \t{\n  \t\tif (bases[i].z.NotZero())\n  \t\t{\n  \t\t\tbases[i].y = GetField().Multiply(bases[i].y, bases[i].z);\n  \t\t\tbases[i].z = GetField().Square(bases[i].z);\n  \t\t\tbases[i].x = GetField().Multiply(bases[i].x, bases[i].z);\n  \t\t\tbases[i].y = GetField().Multiply(bases[i].y, bases[i].z);\n  \t\t}\n  \t}\n  \n  \tstd::vector<BaseAndExponent<Point, Integer> > finalCascade;\n  \tfor (i=0; i<expCount; i++)\n  \t{\n  \t\tfinalCascade.resize(baseIndices[i].size());\n  \t\tfor (unsigned int j=0; j<baseIndices[i].size(); j++)\n  \t\t{\n  \t\t\tProjectivePoint &base = bases[baseIndices[i][j]];\n  \t\t\tif (base.z.IsZero())\n  \t\t\t\tfinalCascade[j].base.identity = true;\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tfinalCascade[j].base.identity = false;\n  \t\t\t\tfinalCascade[j].base.x = base.x;\n  \t\t\t\tif (negateBase[i][j])\n  \t\t\t\t\tfinalCascade[j].base.y = GetField().Inverse(base.y);\n  \t\t\t\telse\n  \t\t\t\t\tfinalCascade[j].base.y = base.y;\n  \t\t\t}\n  \t\t\tfinalCascade[j].exponent = Integer(Integer::POSITIVE, 0, exponentWindows[i][j]);\n  \t\t}\n  \t\tresults[i] = GeneralCascadeMultiplication(*this, finalCascade.begin(), finalCascade.end());\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "k.BitCount",
          "args": [],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "BitCount",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3054-3061",
          "snippet": "unsigned int Integer::BitCount() const\n{\n\tunsigned wordCount = WordCount();\n\tif (wordCount)\n\t\treturn (wordCount-1)*WORD_BITS + BitPrecision(reg[wordCount-1]);\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  unsigned int Integer::BitCount() const\n  {\n  \tunsigned wordCount = WordCount();\n  \tif (wordCount)\n  \t\treturn (wordCount-1)*WORD_BITS + BitPrecision(reg[wordCount-1]);\n  \telse\n  \t\treturn 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  ECP::Point ECP::ScalarMultiply(const Point &P, const Integer &k) const\n  {\n  \tElement result;\n  \tif (k.BitCount() <= 5)\n  \t\tAbstractGroup<ECPPoint>::SimultaneousMultiply(&result, P, &k, 1);\n  \telse\n  \t\tECP::SimultaneousMultiply(&result, P, &k, 1);\n  \treturn result;\n  }\n}"
  },
  {
    "function_name": "ZIterator",
    "container": "ZIterator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "343-343",
    "snippet": "ZIterator(std::vector<ProjectivePoint>::iterator it) : it(it) {}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nZIterator {\n  ZIterator(std::vector<ProjectivePoint>::iterator it) : it(it) {}\n}"
  },
  {
    "function_name": "ZIterator",
    "container": "ZIterator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "342-342",
    "snippet": "ZIterator() {}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nZIterator {\n  ZIterator() {}\n}"
  },
  {
    "function_name": "Double",
    "container": "ProjectiveDoubling",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "316-332",
    "snippet": "void Double()\n\t{\n\t\ttwoY = mr.Double(P.y);\n\t\tP.z = mr.Multiply(P.z, twoY);\n\t\tfourY2 = mr.Square(twoY);\n\t\tS = mr.Multiply(fourY2, P.x);\n\t\taZ4 = mr.Multiply(aZ4, sixteenY4);\n\t\tM = mr.Square(P.x);\n\t\tM = mr.Add(mr.Add(mr.Double(M), M), aZ4);\n\t\tP.x = mr.Square(M);\n\t\tmr.Reduce(P.x, S);\n\t\tmr.Reduce(P.x, S);\n\t\tmr.Reduce(S, P.x);\n\t\tP.y = mr.Multiply(M, S);\n\t\tsixteenY4 = mr.Square(fourY2);\n\t\tmr.Reduce(P.y, mr.Half(sixteenY4));\n\t}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mr.Reduce",
          "args": [
            "P.y",
            "mr.Half(sixteenY4)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mr.Half",
          "args": [
            "sixteenY4"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mr.Square",
          "args": [
            "fourY2"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "Square",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "49-50",
          "snippet": "Element Square(Element a) const\n\t\t{return Multiply(a, a);}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Square(Element a) const\n  \t\t{return Multiply(a, a);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mr.Multiply",
          "args": [
            "M",
            "S"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "Multiply",
          "container": "Word",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "309-314",
          "snippet": "static Word Multiply(hword a, hword b)\n\t{\n\t\tWord r;\n\t\tr.m_whole = (word)a * b;\n\t\treturn r;\n\t}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nWord {\n  static Word Multiply(hword a, hword b)\n  \t{\n  \t\tWord r;\n  \t\tr.m_whole = (word)a * b;\n  \t\treturn r;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mr.Reduce",
          "args": [
            "S",
            "P.x"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mr.Reduce",
          "args": [
            "P.x",
            "S"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mr.Reduce",
          "args": [
            "P.x",
            "S"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mr.Add",
          "args": [
            "mr.Add(mr.Double(M), M)",
            "aZ4"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "Add",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "26-27",
          "snippet": "Element Add(Element a, Element b) const\n\t\t{return a^b;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Add(Element a, Element b) const\n  \t\t{return a^b;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mr.Double",
          "args": [
            "M"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "Double",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "41-42",
          "snippet": "Element Double(Element a) const\n\t\t{return 0;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Double(Element a) const\n  \t\t{return 0;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nProjectiveDoubling {\n  void Double()\n  \t{\n  \t\ttwoY = mr.Double(P.y);\n  \t\tP.z = mr.Multiply(P.z, twoY);\n  \t\tfourY2 = mr.Square(twoY);\n  \t\tS = mr.Multiply(fourY2, P.x);\n  \t\taZ4 = mr.Multiply(aZ4, sixteenY4);\n  \t\tM = mr.Square(P.x);\n  \t\tM = mr.Add(mr.Add(mr.Double(M), M), aZ4);\n  \t\tP.x = mr.Square(M);\n  \t\tmr.Reduce(P.x, S);\n  \t\tmr.Reduce(P.x, S);\n  \t\tmr.Reduce(S, P.x);\n  \t\tP.y = mr.Multiply(M, S);\n  \t\tsixteenY4 = mr.Square(fourY2);\n  \t\tmr.Reduce(P.y, mr.Half(sixteenY4));\n  \t}\n}"
  },
  {
    "function_name": "ProjectiveDoubling",
    "container": "ProjectiveDoubling",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "299-314",
    "snippet": "ProjectiveDoubling(const ModularArithmetic &mr, const Integer &m_a, const Integer &m_b, const ECPPoint &Q)\n\t\t: mr(mr), firstDoubling(true), negated(false)\n\t{\n\t\tif (Q.identity)\n\t\t{\n\t\t\tsixteenY4 = P.x = P.y = mr.MultiplicativeIdentity();\n\t\t\taZ4 = P.z = mr.Identity();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tP.x = Q.x;\n\t\t\tP.y = Q.y;\n\t\t\tsixteenY4 = P.z = mr.MultiplicativeIdentity();\n\t\t\taZ4 = m_a;\n\t\t}\n\t}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mr.MultiplicativeIdentity",
          "args": [],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "MultiplicativeIdentity",
          "container": "GF2_32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf2_32.h",
          "lines": "44-45",
          "snippet": "Element MultiplicativeIdentity() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF2_32 {\n  Element MultiplicativeIdentity() const\n  \t\t{return 1;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mr.Identity",
          "args": [],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "Identity",
          "container": "GF2_32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf2_32.h",
          "lines": "23-24",
          "snippet": "Element Identity() const\n\t\t{return 0;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF2_32 {\n  Element Identity() const\n  \t\t{return 0;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nProjectiveDoubling {\n  ProjectiveDoubling(const ModularArithmetic &mr, const Integer &m_a, const Integer &m_b, const ECPPoint &Q)\n  \t\t: mr(mr), firstDoubling(true), negated(false)\n  \t{\n  \t\tif (Q.identity)\n  \t\t{\n  \t\t\tsixteenY4 = P.x = P.y = mr.MultiplicativeIdentity();\n  \t\t\taZ4 = P.z = mr.Identity();\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tP.x = Q.x;\n  \t\t\tP.y = Q.y;\n  \t\t\tsixteenY4 = P.z = mr.MultiplicativeIdentity();\n  \t\t\taZ4 = m_a;\n  \t\t}\n  \t}\n}"
  },
  {
    "function_name": "ProjectivePoint",
    "container": "ProjectivePoint",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "290-291",
    "snippet": "ProjectivePoint(const Integer &x, const Integer &y, const Integer &z)\n\t\t: x(x), y(y), z(z)\t{}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nProjectivePoint {\n  ProjectivePoint(const Integer &x, const Integer &y, const Integer &z)\n  \t\t: x(x), y(y), z(z)\t{}\n}"
  },
  {
    "function_name": "ProjectivePoint",
    "container": "ProjectivePoint",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "289-289",
    "snippet": "ProjectivePoint() {}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nProjectivePoint {\n  ProjectivePoint() {}\n}"
  },
  {
    "function_name": "ParallelInvert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "250-285",
    "snippet": "void ParallelInvert(const AbstractRing<T> &ring, Iterator begin, Iterator end)\n{\n\tsize_t n = end-begin;\n\tif (n == 1)\n\t\t*begin = ring.MultiplicativeInverse(*begin);\n\telse if (n > 1)\n\t{\n\t\tstd::vector<T> vec((n+1)/2);\n\t\tunsigned int i;\n\t\tIterator it;\n\n\t\tfor (i=0, it=begin; i<n/2; i++, it+=2)\n\t\t\tvec[i] = ring.Multiply(*it, *(it+1));\n\t\tif (n%2 == 1)\n\t\t\tvec[n/2] = *it;\n\n\t\tParallelInvert(ring, vec.begin(), vec.end());\n\n\t\tfor (i=0, it=begin; i<n/2; i++, it+=2)\n\t\t{\n\t\t\tif (!vec[i])\n\t\t\t{\n\t\t\t\t*it = ring.MultiplicativeInverse(*it);\n\t\t\t\t*(it+1) = ring.MultiplicativeInverse(*(it+1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::swap(*it, *(it+1));\n\t\t\t\t*it = ring.Multiply(*it, vec[i]);\n\t\t\t\t*(it+1) = ring.Multiply(*(it+1), vec[i]);\n\t\t\t}\n\t\t}\n\t\tif (n%2 == 1)\n\t\t\t*it = vec[n/2];\n\t}\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring.Multiply",
          "args": [
            "*(it+1)",
            "vec[i]"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "Multiply",
          "container": "Word",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "309-314",
          "snippet": "static Word Multiply(hword a, hword b)\n\t{\n\t\tWord r;\n\t\tr.m_whole = (word)a * b;\n\t\treturn r;\n\t}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nWord {\n  static Word Multiply(hword a, hword b)\n  \t{\n  \t\tWord r;\n  \t\tr.m_whole = (word)a * b;\n  \t\treturn r;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::swap",
          "args": [
            "*it",
            "*(it+1)"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "453-456",
          "snippet": "inline void swap(CryptoPP::PolynomialOverFixedRing<T,i> &a, CryptoPP::PolynomialOverFixedRing<T,i> &b)\n{\n\ta.swap(b);\n}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\ninline void swap(CryptoPP::PolynomialOverFixedRing<T,i> &a, CryptoPP::PolynomialOverFixedRing<T,i> &b)\n{\n\ta.swap(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring.MultiplicativeInverse",
          "args": [
            "*(it+1)"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "MultiplicativeInverse",
          "container": "PolynomialOver<T>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.cpp",
          "lines": "325-328",
          "snippet": "PolynomialOver<T> PolynomialOver<T>::MultiplicativeInverse(const Ring &ring) const\n{\n\treturn Degree(ring)==0 ? ring.MultiplicativeInverse(m_coefficients[0]) : ring.Identity();\n}",
          "includes": [
            "#include <iostream>",
            "#include <sstream>",
            "#include \"secblock.h\"",
            "#include \"polynomi.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <sstream>\n#include \"secblock.h\"\n#include \"polynomi.h\"\n#include \"pch.h\"\n\nPolynomialOver<T> {\n  PolynomialOver<T> PolynomialOver<T>::MultiplicativeInverse(const Ring &ring) const\n  {\n  \treturn Degree(ring)==0 ? ring.MultiplicativeInverse(m_coefficients[0]) : ring.Identity();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParallelInvert",
          "args": [
            "ring",
            "vec.begin()",
            "vec.end()"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "ParallelInvert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
          "lines": "250-285",
          "snippet": "void ParallelInvert(const AbstractRing<T> &ring, Iterator begin, Iterator end)\n{\n\tsize_t n = end-begin;\n\tif (n == 1)\n\t\t*begin = ring.MultiplicativeInverse(*begin);\n\telse if (n > 1)\n\t{\n\t\tstd::vector<T> vec((n+1)/2);\n\t\tunsigned int i;\n\t\tIterator it;\n\n\t\tfor (i=0, it=begin; i<n/2; i++, it+=2)\n\t\t\tvec[i] = ring.Multiply(*it, *(it+1));\n\t\tif (n%2 == 1)\n\t\t\tvec[n/2] = *it;\n\n\t\tParallelInvert(ring, vec.begin(), vec.end());\n\n\t\tfor (i=0, it=begin; i<n/2; i++, it+=2)\n\t\t{\n\t\t\tif (!vec[i])\n\t\t\t{\n\t\t\t\t*it = ring.MultiplicativeInverse(*it);\n\t\t\t\t*(it+1) = ring.MultiplicativeInverse(*(it+1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::swap(*it, *(it+1));\n\t\t\t\t*it = ring.Multiply(*it, vec[i]);\n\t\t\t\t*(it+1) = ring.Multiply(*(it+1), vec[i]);\n\t\t\t}\n\t\t}\n\t\tif (n%2 == 1)\n\t\t\t*it = vec[n/2];\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "vec.end",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vec.begin",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nvoid ParallelInvert(const AbstractRing<T> &ring, Iterator begin, Iterator end)\n{\n\tsize_t n = end-begin;\n\tif (n == 1)\n\t\t*begin = ring.MultiplicativeInverse(*begin);\n\telse if (n > 1)\n\t{\n\t\tstd::vector<T> vec((n+1)/2);\n\t\tunsigned int i;\n\t\tIterator it;\n\n\t\tfor (i=0, it=begin; i<n/2; i++, it+=2)\n\t\t\tvec[i] = ring.Multiply(*it, *(it+1));\n\t\tif (n%2 == 1)\n\t\t\tvec[n/2] = *it;\n\n\t\tParallelInvert(ring, vec.begin(), vec.end());\n\n\t\tfor (i=0, it=begin; i<n/2; i++, it+=2)\n\t\t{\n\t\t\tif (!vec[i])\n\t\t\t{\n\t\t\t\t*it = ring.MultiplicativeInverse(*it);\n\t\t\t\t*(it+1) = ring.MultiplicativeInverse(*(it+1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::swap(*it, *(it+1));\n\t\t\t\t*it = ring.Multiply(*it, vec[i]);\n\t\t\t\t*(it+1) = ring.Multiply(*(it+1), vec[i]);\n\t\t\t}\n\t\t}\n\t\tif (n%2 == 1)\n\t\t\t*it = vec[n/2];\n\t}\n}"
  },
  {
    "function_name": "Equal",
    "container": "ECP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "186-198",
    "snippet": "bool ECP::Equal(const Point &P, const Point &Q) const\n{\n\tif (P.identity && Q.identity)\n\t\treturn true;\n\n\tif (P.identity && !Q.identity)\n\t\treturn false;\n\n\tif (!P.identity && Q.identity)\n\t\treturn false;\n\n\treturn (GetField().Equal(P.x,Q.x) && GetField().Equal(P.y,Q.y));\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetField",
          "args": [
            "P.y",
            "Q.y"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "GetFieldType",
          "container": "DL_GroupParameters_LUC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.h",
          "lines": "168-168",
          "snippet": "int GetFieldType() const {return 2;}",
          "includes": [
            "#include <limits.h>",
            "#include \"dh.h\"",
            "#include \"integer.h\"",
            "#include \"oaep.h\"",
            "#include \"pkcspad.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"dh.h\"\n#include \"integer.h\"\n#include \"oaep.h\"\n#include \"pkcspad.h\"\n\nDL_GroupParameters_LUC {\n  int GetFieldType() const {return 2;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [
            "P.x",
            "Q.x"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  bool ECP::Equal(const Point &P, const Point &Q) const\n  {\n  \tif (P.identity && Q.identity)\n  \t\treturn true;\n  \n  \tif (P.identity && !Q.identity)\n  \t\treturn false;\n  \n  \tif (!P.identity && Q.identity)\n  \t\treturn false;\n  \n  \treturn (GetField().Equal(P.x,Q.x) && GetField().Equal(P.y,Q.y));\n  }\n}"
  },
  {
    "function_name": "VerifyPoint",
    "container": "ECP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "177-184",
    "snippet": "bool ECP::VerifyPoint(const Point &P) const\n{\n\tconst FieldElement &x = P.x, &y = P.y;\n\tInteger p = FieldSize();\n\treturn P.identity ||\n\t\t(!x.IsNegative() && x<p && !y.IsNegative() && y<p\n\t\t&& !(((x*x+m_a)*x+m_b-y*y)%p));\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y.IsNegative",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "IsNegative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "201-201",
          "snippet": "bool IsNegative() const {return sign == NEGATIVE;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsNegative() const {return sign == NEGATIVE;}"
        }
      },
      {
        "call_info": {
          "callee": "FieldSize",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  bool ECP::VerifyPoint(const Point &P) const\n  {\n  \tconst FieldElement &x = P.x, &y = P.y;\n  \tInteger p = FieldSize();\n  \treturn P.identity ||\n  \t\t(!x.IsNegative() && x<p && !y.IsNegative() && y<p\n  \t\t&& !(((x*x+m_a)*x+m_b-y*y)%p));\n  }\n}"
  },
  {
    "function_name": "ValidateParameters",
    "container": "ECP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "161-175",
    "snippet": "bool ECP::ValidateParameters(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tInteger p = FieldSize();\n\n\tbool pass = p.IsOdd();\n\tpass = pass && !m_a.IsNegative() && m_a<p && !m_b.IsNegative() && m_b<p;\n\n\tif (level >= 1)\n\t\tpass = pass && ((4*m_a*m_a*m_a+27*m_b*m_b)%p).IsPositive();\n\n\tif (level >= 2)\n\t\tpass = pass && VerifyPrime(rng, p);\n\n\treturn pass;\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VerifyPrime",
          "args": [
            "rng",
            "p"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_b.IsNegative",
          "args": [],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "IsNegative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "201-201",
          "snippet": "bool IsNegative() const {return sign == NEGATIVE;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsNegative() const {return sign == NEGATIVE;}"
        }
      },
      {
        "call_info": {
          "callee": "p.IsOdd",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "IsOdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "211-211",
          "snippet": "bool IsOdd() const\t{return GetBit(0) == 1;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsOdd() const\t{return GetBit(0) == 1;}"
        }
      },
      {
        "call_info": {
          "callee": "FieldSize",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  bool ECP::ValidateParameters(RandomNumberGenerator &rng, unsigned int level) const\n  {\n  \tInteger p = FieldSize();\n  \n  \tbool pass = p.IsOdd();\n  \tpass = pass && !m_a.IsNegative() && m_a<p && !m_b.IsNegative() && m_b<p;\n  \n  \tif (level >= 1)\n  \t\tpass = pass && ((4*m_a*m_a*m_a+27*m_b*m_b)%p).IsPositive();\n  \n  \tif (level >= 2)\n  \t\tpass = pass && VerifyPrime(rng, p);\n  \n  \treturn pass;\n  }\n}"
  },
  {
    "function_name": "DEREncodePoint",
    "container": "ECP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "154-159",
    "snippet": "void ECP::DEREncodePoint(BufferedTransformation &bt, const Point &P, bool compressed) const\n{\n\tSecByteBlock str(EncodedPointSize(compressed));\n\tEncodePoint(str, P, compressed);\n\tDEREncodeOctetString(bt, str);\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEREncodeOctetString",
          "args": [
            "bt",
            "str"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncodeOctetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "111-114",
          "snippet": "size_t DEREncodeOctetString(BufferedTransformation &bt, const SecByteBlock &str)\n{\n\treturn DEREncodeOctetString(bt, str.begin(), str.size());\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nsize_t DEREncodeOctetString(BufferedTransformation &bt, const SecByteBlock &str)\n{\n\treturn DEREncodeOctetString(bt, str.begin(), str.size());\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodePoint",
          "args": [
            "str",
            "P",
            "compressed"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncodePoint",
          "container": "ECP",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
          "lines": "154-159",
          "snippet": "void ECP::DEREncodePoint(BufferedTransformation &bt, const Point &P, bool compressed) const\n{\n\tSecByteBlock str(EncodedPointSize(compressed));\n\tEncodePoint(str, P, compressed);\n\tDEREncodeOctetString(bt, str);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  void ECP::DEREncodePoint(BufferedTransformation &bt, const Point &P, bool compressed) const\n  {\n  \tSecByteBlock str(EncodedPointSize(compressed));\n  \tEncodePoint(str, P, compressed);\n  \tDEREncodeOctetString(bt, str);\n  }\n}"
  },
  {
    "function_name": "BERDecodePoint",
    "container": "ECP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "144-152",
    "snippet": "ECP::Point ECP::BERDecodePoint(BufferedTransformation &bt) const\n{\n\tSecByteBlock str;\n\tBERDecodeOctetString(bt, str);\n\tPoint P;\n\tif (!DecodePoint(P, str, str.size()))\n\t\tBERDecodeError();\n\treturn P;\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BERDecodeError",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecodeError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.h",
          "lines": "49-49",
          "snippet": "inline void BERDecodeError() {throw BERDecodeErr();}",
          "includes": [
            "#include <vector>",
            "#include \"queue.h\"",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"queue.h\"\n#include \"filters.h\"\n\ninline void BERDecodeError() {throw BERDecodeErr();}"
        }
      },
      {
        "call_info": {
          "callee": "DecodePoint",
          "args": [
            "P",
            "str",
            "str.size()"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "DecodePoint",
          "container": "ECP",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
          "lines": "70-117",
          "snippet": "bool ECP::DecodePoint(ECP::Point &P, BufferedTransformation &bt, size_t encodedPointLen) const\n{\n\tbyte type;\n\tif (encodedPointLen < 1 || !bt.Get(type))\n\t\treturn false;\n\n\tswitch (type)\n\t{\n\tcase 0:\n\t\tP.identity = true;\n\t\treturn true;\n\tcase 2:\n\tcase 3:\n\t{\n\t\tif (encodedPointLen != EncodedPointSize(true))\n\t\t\treturn false;\n\n\t\tInteger p = FieldSize();\n\n\t\tP.identity = false;\n\t\tP.x.Decode(bt, GetField().MaxElementByteLength()); \n\t\tP.y = ((P.x*P.x+m_a)*P.x+m_b) % p;\n\n\t\tif (Jacobi(P.y, p) !=1)\n\t\t\treturn false;\n\n\t\tP.y = ModularSquareRoot(P.y, p);\n\n\t\tif ((type & 1) != P.y.GetBit(0))\n\t\t\tP.y = p-P.y;\n\n\t\treturn true;\n\t}\n\tcase 4:\n\t{\n\t\tif (encodedPointLen != EncodedPointSize(false))\n\t\t\treturn false;\n\n\t\tunsigned int len = GetField().MaxElementByteLength();\n\t\tP.identity = false;\n\t\tP.x.Decode(bt, len);\n\t\tP.y.Decode(bt, len);\n\t\treturn true;\n\t}\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"algebra.cpp\"",
            "#include \"nbtheory.h\"",
            "#include \"asn.h\"",
            "#include \"ecp.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  bool ECP::DecodePoint(ECP::Point &P, BufferedTransformation &bt, size_t encodedPointLen) const\n  {\n  \tbyte type;\n  \tif (encodedPointLen < 1 || !bt.Get(type))\n  \t\treturn false;\n  \n  \tswitch (type)\n  \t{\n  \tcase 0:\n  \t\tP.identity = true;\n  \t\treturn true;\n  \tcase 2:\n  \tcase 3:\n  \t{\n  \t\tif (encodedPointLen != EncodedPointSize(true))\n  \t\t\treturn false;\n  \n  \t\tInteger p = FieldSize();\n  \n  \t\tP.identity = false;\n  \t\tP.x.Decode(bt, GetField().MaxElementByteLength()); \n  \t\tP.y = ((P.x*P.x+m_a)*P.x+m_b) % p;\n  \n  \t\tif (Jacobi(P.y, p) !=1)\n  \t\t\treturn false;\n  \n  \t\tP.y = ModularSquareRoot(P.y, p);\n  \n  \t\tif ((type & 1) != P.y.GetBit(0))\n  \t\t\tP.y = p-P.y;\n  \n  \t\treturn true;\n  \t}\n  \tcase 4:\n  \t{\n  \t\tif (encodedPointLen != EncodedPointSize(false))\n  \t\t\treturn false;\n  \n  \t\tunsigned int len = GetField().MaxElementByteLength();\n  \t\tP.identity = false;\n  \t\tP.x.Decode(bt, len);\n  \t\tP.y.Decode(bt, len);\n  \t\treturn true;\n  \t}\n  \tdefault:\n  \t\treturn false;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.size",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BERDecodeOctetString",
          "args": [
            "bt",
            "str"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecodeOctetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "132-144",
          "snippet": "size_t BERDecodeOctetString(BufferedTransformation &bt, BufferedTransformation &str)\n{\n\tbyte b;\n\tif (!bt.Get(b) || b != OCTET_STRING)\n\t\tBERDecodeError();\n\n\tsize_t bc;\n\tif (!BERLengthDecode(bt, bc))\n\t\tBERDecodeError();\n\n\tbt.TransferTo(str, bc);\n\treturn bc;\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nsize_t BERDecodeOctetString(BufferedTransformation &bt, BufferedTransformation &str)\n{\n\tbyte b;\n\tif (!bt.Get(b) || b != OCTET_STRING)\n\t\tBERDecodeError();\n\n\tsize_t bc;\n\tif (!BERLengthDecode(bt, bc))\n\t\tBERDecodeError();\n\n\tbt.TransferTo(str, bc);\n\treturn bc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  ECP::Point ECP::BERDecodePoint(BufferedTransformation &bt) const\n  {\n  \tSecByteBlock str;\n  \tBERDecodeOctetString(bt, str);\n  \tPoint P;\n  \tif (!DecodePoint(P, str, str.size()))\n  \t\tBERDecodeError();\n  \treturn P;\n  }\n}"
  },
  {
    "function_name": "EncodePoint",
    "container": "ECP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "137-142",
    "snippet": "void ECP::EncodePoint(byte *encodedPoint, const Point &P, bool compressed) const\n{\n\tArraySink sink(encodedPoint, EncodedPointSize(compressed));\n\tEncodePoint(sink, P, compressed);\n\tassert(sink.TotalPutLength() == EncodedPointSize(compressed));\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "sink.TotalPutLength() == EncodedPointSize(compressed)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodedPointSize",
          "args": [
            "compressed"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sink.TotalPutLength",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodePoint",
          "args": [
            "sink",
            "P",
            "compressed"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncodePoint",
          "container": "ECP",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
          "lines": "154-159",
          "snippet": "void ECP::DEREncodePoint(BufferedTransformation &bt, const Point &P, bool compressed) const\n{\n\tSecByteBlock str(EncodedPointSize(compressed));\n\tEncodePoint(str, P, compressed);\n\tDEREncodeOctetString(bt, str);\n}",
          "includes": [
            "#include \"algebra.cpp\"",
            "#include \"nbtheory.h\"",
            "#include \"asn.h\"",
            "#include \"ecp.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  void ECP::DEREncodePoint(BufferedTransformation &bt, const Point &P, bool compressed) const\n  {\n  \tSecByteBlock str(EncodedPointSize(compressed));\n  \tEncodePoint(str, P, compressed);\n  \tDEREncodeOctetString(bt, str);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  void ECP::EncodePoint(byte *encodedPoint, const Point &P, bool compressed) const\n  {\n  \tArraySink sink(encodedPoint, EncodedPointSize(compressed));\n  \tEncodePoint(sink, P, compressed);\n  \tassert(sink.TotalPutLength() == EncodedPointSize(compressed));\n  }\n}"
  },
  {
    "function_name": "EncodePoint",
    "container": "ECP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "119-135",
    "snippet": "void ECP::EncodePoint(BufferedTransformation &bt, const Point &P, bool compressed) const\n{\n\tif (P.identity)\n\t\tNullStore().TransferTo(bt, EncodedPointSize(compressed));\n\telse if (compressed)\n\t{\n\t\tbt.Put(2 + P.y.GetBit(0));\n\t\tP.x.Encode(bt, GetField().MaxElementByteLength());\n\t}\n\telse\n\t{\n\t\tunsigned int len = GetField().MaxElementByteLength();\n\t\tbt.Put(4);\t// uncompressed\n\t\tP.x.Encode(bt, len);\n\t\tP.y.Encode(bt, len);\n\t}\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "P.y.Encode",
          "args": [
            "bt",
            "len"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bt.Put",
          "args": [
            "4"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "785-786",
          "snippet": "size_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nsize_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "GetFieldType",
          "container": "DL_GroupParameters_LUC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.h",
          "lines": "168-168",
          "snippet": "int GetFieldType() const {return 2;}",
          "includes": [
            "#include <limits.h>",
            "#include \"dh.h\"",
            "#include \"integer.h\"",
            "#include \"oaep.h\"",
            "#include \"pkcspad.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"dh.h\"\n#include \"integer.h\"\n#include \"oaep.h\"\n#include \"pkcspad.h\"\n\nDL_GroupParameters_LUC {\n  int GetFieldType() const {return 2;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "P.y.GetBit",
          "args": [
            "0"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "GetBit",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "2894-2900",
          "snippet": "bool Integer::GetBit(size_t n) const\n{\n\tif (n/WORD_BITS >= reg.size())\n\t\treturn 0;\n\telse\n\t\treturn bool((reg[n/WORD_BITS] >> (n % WORD_BITS)) & 1);\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  bool Integer::GetBit(size_t n) const\n  {\n  \tif (n/WORD_BITS >= reg.size())\n  \t\treturn 0;\n  \telse\n  \t\treturn bool((reg[n/WORD_BITS] >> (n % WORD_BITS)) & 1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NullStore",
          "args": [
            "bt",
            "EncodedPointSize(compressed)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodedPointSize",
          "args": [
            "compressed"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NullStore",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  void ECP::EncodePoint(BufferedTransformation &bt, const Point &P, bool compressed) const\n  {\n  \tif (P.identity)\n  \t\tNullStore().TransferTo(bt, EncodedPointSize(compressed));\n  \telse if (compressed)\n  \t{\n  \t\tbt.Put(2 + P.y.GetBit(0));\n  \t\tP.x.Encode(bt, GetField().MaxElementByteLength());\n  \t}\n  \telse\n  \t{\n  \t\tunsigned int len = GetField().MaxElementByteLength();\n  \t\tbt.Put(4);\t// uncompressed\n  \t\tP.x.Encode(bt, len);\n  \t\tP.y.Encode(bt, len);\n  \t}\n  }\n}"
  },
  {
    "function_name": "DecodePoint",
    "container": "ECP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "70-117",
    "snippet": "bool ECP::DecodePoint(ECP::Point &P, BufferedTransformation &bt, size_t encodedPointLen) const\n{\n\tbyte type;\n\tif (encodedPointLen < 1 || !bt.Get(type))\n\t\treturn false;\n\n\tswitch (type)\n\t{\n\tcase 0:\n\t\tP.identity = true;\n\t\treturn true;\n\tcase 2:\n\tcase 3:\n\t{\n\t\tif (encodedPointLen != EncodedPointSize(true))\n\t\t\treturn false;\n\n\t\tInteger p = FieldSize();\n\n\t\tP.identity = false;\n\t\tP.x.Decode(bt, GetField().MaxElementByteLength()); \n\t\tP.y = ((P.x*P.x+m_a)*P.x+m_b) % p;\n\n\t\tif (Jacobi(P.y, p) !=1)\n\t\t\treturn false;\n\n\t\tP.y = ModularSquareRoot(P.y, p);\n\n\t\tif ((type & 1) != P.y.GetBit(0))\n\t\t\tP.y = p-P.y;\n\n\t\treturn true;\n\t}\n\tcase 4:\n\t{\n\t\tif (encodedPointLen != EncodedPointSize(false))\n\t\t\treturn false;\n\n\t\tunsigned int len = GetField().MaxElementByteLength();\n\t\tP.identity = false;\n\t\tP.x.Decode(bt, len);\n\t\tP.y.Decode(bt, len);\n\t\treturn true;\n\t}\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "P.y.Decode",
          "args": [
            "bt",
            "len"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "Decode",
          "container": "PolynomialMod2",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf2n.cpp",
          "lines": "145-155",
          "snippet": "void PolynomialMod2::Decode(BufferedTransformation &bt, size_t inputLen)\n{\n\treg.CleanNew(BytesToWords(inputLen));\n\n\tfor (size_t i=inputLen; i > 0; i--)\n\t{\n\t\tbyte b;\n\t\tbt.Get(b);\n\t\treg[(i-1)/WORD_SIZE] |= word(b) << ((i-1)%WORD_SIZE)*8;\n\t}\n}",
          "includes": [
            "#include <iostream>",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"randpool.h\"",
            "#include \"words.h\"",
            "#include \"algebra.h\"",
            "#include \"gf2n.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"randpool.h\"\n#include \"words.h\"\n#include \"algebra.h\"\n#include \"gf2n.h\"\n#include \"pch.h\"\n\nPolynomialMod2 {\n  void PolynomialMod2::Decode(BufferedTransformation &bt, size_t inputLen)\n  {\n  \treg.CleanNew(BytesToWords(inputLen));\n  \n  \tfor (size_t i=inputLen; i > 0; i--)\n  \t{\n  \t\tbyte b;\n  \t\tbt.Get(b);\n  \t\treg[(i-1)/WORD_SIZE] |= word(b) << ((i-1)%WORD_SIZE)*8;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "GetFieldType",
          "container": "DL_GroupParameters_LUC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.h",
          "lines": "168-168",
          "snippet": "int GetFieldType() const {return 2;}",
          "includes": [
            "#include <limits.h>",
            "#include \"dh.h\"",
            "#include \"integer.h\"",
            "#include \"oaep.h\"",
            "#include \"pkcspad.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"dh.h\"\n#include \"integer.h\"\n#include \"oaep.h\"\n#include \"pkcspad.h\"\n\nDL_GroupParameters_LUC {\n  int GetFieldType() const {return 2;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodedPointSize",
          "args": [
            "false"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P.y.GetBit",
          "args": [
            "0"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "GetBit",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "2894-2900",
          "snippet": "bool Integer::GetBit(size_t n) const\n{\n\tif (n/WORD_BITS >= reg.size())\n\t\treturn 0;\n\telse\n\t\treturn bool((reg[n/WORD_BITS] >> (n % WORD_BITS)) & 1);\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  bool Integer::GetBit(size_t n) const\n  {\n  \tif (n/WORD_BITS >= reg.size())\n  \t\treturn 0;\n  \telse\n  \t\treturn bool((reg[n/WORD_BITS] >> (n % WORD_BITS)) & 1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ModularSquareRoot",
          "args": [
            "P.y",
            "p"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "ModularSquareRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "572-619",
          "snippet": "Integer ModularSquareRoot(const Integer &a, const Integer &p)\n{\n\tif (p%4 == 3)\n\t\treturn a_exp_b_mod_c(a, (p+1)/4, p);\n\n\tInteger q=p-1;\n\tunsigned int r=0;\n\twhile (q.IsEven())\n\t{\n\t\tr++;\n\t\tq >>= 1;\n\t}\n\n\tInteger n=2;\n\twhile (Jacobi(n, p) != -1)\n\t\t++n;\n\n\tInteger y = a_exp_b_mod_c(n, q, p);\n\tInteger x = a_exp_b_mod_c(a, (q-1)/2, p);\n\tInteger b = (x.Squared()%p)*a%p;\n\tx = a*x%p;\n\tInteger tempb, t;\n\n\twhile (b != 1)\n\t{\n\t\tunsigned m=0;\n\t\ttempb = b;\n\t\tdo\n\t\t{\n\t\t\tm++;\n\t\t\tb = b.Squared()%p;\n\t\t\tif (m==r)\n\t\t\t\treturn Integer::Zero();\n\t\t}\n\t\twhile (b != 1);\n\n\t\tt = y;\n\t\tfor (unsigned i=0; i<r-m-1; i++)\n\t\t\tt = t.Squared()%p;\n\t\ty = t.Squared()%p;\n\t\tr = m;\n\t\tx = x*t%p;\n\t\tb = tempb*y%p;\n\t}\n\n\tassert(x.Squared()%p == a);\n\treturn x;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger ModularSquareRoot(const Integer &a, const Integer &p)\n{\n\tif (p%4 == 3)\n\t\treturn a_exp_b_mod_c(a, (p+1)/4, p);\n\n\tInteger q=p-1;\n\tunsigned int r=0;\n\twhile (q.IsEven())\n\t{\n\t\tr++;\n\t\tq >>= 1;\n\t}\n\n\tInteger n=2;\n\twhile (Jacobi(n, p) != -1)\n\t\t++n;\n\n\tInteger y = a_exp_b_mod_c(n, q, p);\n\tInteger x = a_exp_b_mod_c(a, (q-1)/2, p);\n\tInteger b = (x.Squared()%p)*a%p;\n\tx = a*x%p;\n\tInteger tempb, t;\n\n\twhile (b != 1)\n\t{\n\t\tunsigned m=0;\n\t\ttempb = b;\n\t\tdo\n\t\t{\n\t\t\tm++;\n\t\t\tb = b.Squared()%p;\n\t\t\tif (m==r)\n\t\t\t\treturn Integer::Zero();\n\t\t}\n\t\twhile (b != 1);\n\n\t\tt = y;\n\t\tfor (unsigned i=0; i<r-m-1; i++)\n\t\t\tt = t.Squared()%p;\n\t\ty = t.Squared()%p;\n\t\tr = m;\n\t\tx = x*t%p;\n\t\tb = tempb*y%p;\n\t}\n\n\tassert(x.Squared()%p == a);\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Jacobi",
          "args": [
            "P.y",
            "p"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "Jacobi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "785-810",
          "snippet": "int Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nint Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FieldSize",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodedPointSize",
          "args": [
            "true"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt.Get",
          "args": [
            "type"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "BlockGetAndPut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1201-1201",
          "snippet": "static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nBlockGetAndPut {\n  static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  bool ECP::DecodePoint(ECP::Point &P, BufferedTransformation &bt, size_t encodedPointLen) const\n  {\n  \tbyte type;\n  \tif (encodedPointLen < 1 || !bt.Get(type))\n  \t\treturn false;\n  \n  \tswitch (type)\n  \t{\n  \tcase 0:\n  \t\tP.identity = true;\n  \t\treturn true;\n  \tcase 2:\n  \tcase 3:\n  \t{\n  \t\tif (encodedPointLen != EncodedPointSize(true))\n  \t\t\treturn false;\n  \n  \t\tInteger p = FieldSize();\n  \n  \t\tP.identity = false;\n  \t\tP.x.Decode(bt, GetField().MaxElementByteLength()); \n  \t\tP.y = ((P.x*P.x+m_a)*P.x+m_b) % p;\n  \n  \t\tif (Jacobi(P.y, p) !=1)\n  \t\t\treturn false;\n  \n  \t\tP.y = ModularSquareRoot(P.y, p);\n  \n  \t\tif ((type & 1) != P.y.GetBit(0))\n  \t\t\tP.y = p-P.y;\n  \n  \t\treturn true;\n  \t}\n  \tcase 4:\n  \t{\n  \t\tif (encodedPointLen != EncodedPointSize(false))\n  \t\t\treturn false;\n  \n  \t\tunsigned int len = GetField().MaxElementByteLength();\n  \t\tP.identity = false;\n  \t\tP.x.Decode(bt, len);\n  \t\tP.y.Decode(bt, len);\n  \t\treturn true;\n  \t}\n  \tdefault:\n  \t\treturn false;\n  \t}\n  }\n}"
  },
  {
    "function_name": "DecodePoint",
    "container": "ECP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "64-68",
    "snippet": "bool ECP::DecodePoint(ECP::Point &P, const byte *encodedPoint, size_t encodedPointLen) const\n{\n\tStringStore store(encodedPoint, encodedPointLen);\n\treturn DecodePoint(P, store, encodedPointLen);\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DecodePoint",
          "args": [
            "P",
            "store",
            "encodedPointLen"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "DecodePoint",
          "container": "ECP",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
          "lines": "70-117",
          "snippet": "bool ECP::DecodePoint(ECP::Point &P, BufferedTransformation &bt, size_t encodedPointLen) const\n{\n\tbyte type;\n\tif (encodedPointLen < 1 || !bt.Get(type))\n\t\treturn false;\n\n\tswitch (type)\n\t{\n\tcase 0:\n\t\tP.identity = true;\n\t\treturn true;\n\tcase 2:\n\tcase 3:\n\t{\n\t\tif (encodedPointLen != EncodedPointSize(true))\n\t\t\treturn false;\n\n\t\tInteger p = FieldSize();\n\n\t\tP.identity = false;\n\t\tP.x.Decode(bt, GetField().MaxElementByteLength()); \n\t\tP.y = ((P.x*P.x+m_a)*P.x+m_b) % p;\n\n\t\tif (Jacobi(P.y, p) !=1)\n\t\t\treturn false;\n\n\t\tP.y = ModularSquareRoot(P.y, p);\n\n\t\tif ((type & 1) != P.y.GetBit(0))\n\t\t\tP.y = p-P.y;\n\n\t\treturn true;\n\t}\n\tcase 4:\n\t{\n\t\tif (encodedPointLen != EncodedPointSize(false))\n\t\t\treturn false;\n\n\t\tunsigned int len = GetField().MaxElementByteLength();\n\t\tP.identity = false;\n\t\tP.x.Decode(bt, len);\n\t\tP.y.Decode(bt, len);\n\t\treturn true;\n\t}\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  bool ECP::DecodePoint(ECP::Point &P, const byte *encodedPoint, size_t encodedPointLen) const\n  {\n  \tStringStore store(encodedPoint, encodedPointLen);\n  \treturn DecodePoint(P, store, encodedPointLen);\n  }\n}"
  },
  {
    "function_name": "DEREncode",
    "container": "ECP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "55-62",
    "snippet": "void ECP::DEREncode(BufferedTransformation &bt) const\n{\n\tGetField().DEREncode(bt);\n\tDERSequenceEncoder seq(bt);\n\tGetField().DEREncodeElement(seq, m_a);\n\tGetField().DEREncodeElement(seq, m_b);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [
            "seq",
            "m_b"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "GetFieldType",
          "container": "DL_GroupParameters_LUC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.h",
          "lines": "168-168",
          "snippet": "int GetFieldType() const {return 2;}",
          "includes": [
            "#include <limits.h>",
            "#include \"dh.h\"",
            "#include \"integer.h\"",
            "#include \"oaep.h\"",
            "#include \"pkcspad.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"dh.h\"\n#include \"integer.h\"\n#include \"oaep.h\"\n#include \"pkcspad.h\"\n\nDL_GroupParameters_LUC {\n  int GetFieldType() const {return 2;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [
            "seq",
            "m_a"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [
            "bt"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  void ECP::DEREncode(BufferedTransformation &bt) const\n  {\n  \tGetField().DEREncode(bt);\n  \tDERSequenceEncoder seq(bt);\n  \tGetField().DEREncodeElement(seq, m_a);\n  \tGetField().DEREncodeElement(seq, m_b);\n  \tseq.MessageEnd();\n  }\n}"
  },
  {
    "function_name": "ECP",
    "container": "ECP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "39-53",
    "snippet": "ECP::ECP(BufferedTransformation &bt)\n\t: m_fieldPtr(new Field(bt))\n{\n\tBERSequenceDecoder seq(bt);\n\tGetField().BERDecodeElement(seq, m_a);\n\tGetField().BERDecodeElement(seq, m_b);\n\t// skip optional seed\n\tif (!seq.EndReached())\n\t{\n\t\tSecByteBlock seed;\n\t\tunsigned int unused;\n\t\tBERDecodeBitString(seq, seed, unused);\n\t}\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BERDecodeBitString",
          "args": [
            "seq",
            "seed",
            "unused"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecodeBitString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "181-199",
          "snippet": "size_t BERDecodeBitString(BufferedTransformation &bt, SecByteBlock &str, unsigned int &unusedBits)\n{\n\tbyte b;\n\tif (!bt.Get(b) || b != BIT_STRING)\n\t\tBERDecodeError();\n\n\tsize_t bc;\n\tif (!BERLengthDecode(bt, bc))\n\t\tBERDecodeError();\n\n\tbyte unused;\n\tif (!bt.Get(unused))\n\t\tBERDecodeError();\n\tunusedBits = unused;\n\tstr.resize(bc-1);\n\tif ((bc-1) != bt.Get(str, bc-1))\n\t\tBERDecodeError();\n\treturn bc-1;\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nsize_t BERDecodeBitString(BufferedTransformation &bt, SecByteBlock &str, unsigned int &unusedBits)\n{\n\tbyte b;\n\tif (!bt.Get(b) || b != BIT_STRING)\n\t\tBERDecodeError();\n\n\tsize_t bc;\n\tif (!BERLengthDecode(bt, bc))\n\t\tBERDecodeError();\n\n\tbyte unused;\n\tif (!bt.Get(unused))\n\t\tBERDecodeError();\n\tunusedBits = unused;\n\tstr.resize(bc-1);\n\tif ((bc-1) != bt.Get(str, bc-1))\n\t\tBERDecodeError();\n\treturn bc-1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq.EndReached",
          "args": [],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "EndReached",
          "container": "BERGeneralDecoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "413-422",
          "snippet": "bool BERGeneralDecoder::EndReached() const\n{\n\tif (m_definiteLength)\n\t\treturn m_length == 0;\n\telse\n\t{\t// check end-of-content octets\n\t\tword16 i;\n\t\treturn (m_inQueue.PeekWord16(i)==2 && i==0);\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nBERGeneralDecoder {\n  bool BERGeneralDecoder::EndReached() const\n  {\n  \tif (m_definiteLength)\n  \t\treturn m_length == 0;\n  \telse\n  \t{\t// check end-of-content octets\n  \t\tword16 i;\n  \t\treturn (m_inQueue.PeekWord16(i)==2 && i==0);\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [
            "seq",
            "m_b"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "GetFieldType",
          "container": "DL_GroupParameters_LUC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.h",
          "lines": "168-168",
          "snippet": "int GetFieldType() const {return 2;}",
          "includes": [
            "#include <limits.h>",
            "#include \"dh.h\"",
            "#include \"integer.h\"",
            "#include \"oaep.h\"",
            "#include \"pkcspad.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"dh.h\"\n#include \"integer.h\"\n#include \"oaep.h\"\n#include \"pkcspad.h\"\n\nDL_GroupParameters_LUC {\n  int GetFieldType() const {return 2;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [
            "seq",
            "m_a"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  ECP::ECP(BufferedTransformation &bt)\n  \t: m_fieldPtr(new Field(bt))\n  {\n  \tBERSequenceDecoder seq(bt);\n  \tGetField().BERDecodeElement(seq, m_a);\n  \tGetField().BERDecodeElement(seq, m_b);\n  \t// skip optional seed\n  \tif (!seq.EndReached())\n  \t{\n  \t\tSecByteBlock seed;\n  \t\tunsigned int unused;\n  \t\tBERDecodeBitString(seq, seed, unused);\n  \t}\n  \tseq.MessageEnd();\n  }\n}"
  },
  {
    "function_name": "ECP",
    "container": "ECP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "25-37",
    "snippet": "NAMESPACE_END\n\nECP::ECP(const ECP &ecp, bool convertToMontgomeryRepresentation)\n{\n\tif (convertToMontgomeryRepresentation && !ecp.GetField().IsMontgomeryRepresentation())\n\t{\n\t\tm_fieldPtr.reset(new MontgomeryRepresentation(ecp.GetField().GetModulus()));\n\t\tm_a = GetField().ConvertIn(ecp.m_a);\n\t\tm_b = GetField().ConvertIn(ecp.m_b);\n\t}\n\telse\n\t\toperator=(ecp);\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetField",
          "args": [
            "ecp.m_b"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "GetFieldType",
          "container": "DL_GroupParameters_LUC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.h",
          "lines": "168-168",
          "snippet": "int GetFieldType() const {return 2;}",
          "includes": [
            "#include <limits.h>",
            "#include \"dh.h\"",
            "#include \"integer.h\"",
            "#include \"oaep.h\"",
            "#include \"pkcspad.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"dh.h\"\n#include \"integer.h\"\n#include \"oaep.h\"\n#include \"pkcspad.h\"\n\nDL_GroupParameters_LUC {\n  int GetFieldType() const {return 2;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [
            "ecp.m_a"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fieldPtr.reset",
          "args": [
            "new MontgomeryRepresentation(ecp.GetField().GetModulus())"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "reset",
          "container": "member_ptr<T>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "50-50",
          "snippet": "void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nmember_ptr<T> {\n  void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecp.GetField",
          "args": [],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecp.GetField",
          "args": [],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecp.GetField",
          "args": [],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecp.GetField",
          "args": [],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nECP {\n  NAMESPACE_END\n  \n  ECP::ECP(const ECP &ecp, bool convertToMontgomeryRepresentation)\n  {\n  \tif (convertToMontgomeryRepresentation && !ecp.GetField().IsMontgomeryRepresentation())\n  \t{\n  \t\tm_fieldPtr.reset(new MontgomeryRepresentation(ecp.GetField().GetModulus()));\n  \t\tm_a = GetField().ConvertIn(ecp.m_a);\n  \t\tm_b = GetField().ConvertIn(ecp.m_b);\n  \t}\n  \telse\n  \t\toperator=(ecp);\n  }\n}"
  },
  {
    "function_name": "FromMontgomery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "21-24",
    "snippet": "static inline ECP::Point FromMontgomery(const ModularArithmetic &mr, const ECP::Point &P)\n{\n\treturn P.identity ? P : ECP::Point(mr.ConvertOut(P.x), mr.ConvertOut(P.y));\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ECP::Point",
          "args": [
            "mr.ConvertOut(P.x)",
            "mr.ConvertOut(P.y)"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mr.ConvertOut",
          "args": [
            "P.y"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "ConvertOut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.h",
          "lines": "106-107",
          "snippet": "Element ConvertOut(const Element &P) const\n\t\t{return P.identity ? P : ECP::Point(m_ec->GetField().ConvertOut(P.x), m_ec->GetField().ConvertOut(P.y));}",
          "includes": [
            "#include \"pubkey.h\"",
            "#include \"smartptr.h\"",
            "#include \"eprecomp.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pubkey.h\"\n#include \"smartptr.h\"\n#include \"eprecomp.h\"\n#include \"modarith.h\"\n\nElement ConvertOut(const Element &P) const\n\t\t{return P.identity ? P : ECP::Point(m_ec->GetField().ConvertOut(P.x), m_ec->GetField().ConvertOut(P.y));}"
        }
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nstatic inline ECP::Point FromMontgomery(const ModularArithmetic &mr, const ECP::Point &P)\n{\n\treturn P.identity ? P : ECP::Point(mr.ConvertOut(P.x), mr.ConvertOut(P.y));\n}"
  },
  {
    "function_name": "ToMontgomery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.cpp",
    "lines": "15-19",
    "snippet": "ANONYMOUS_NAMESPACE_BEGIN\nstatic inline ECP::Point ToMontgomery(const ModularArithmetic &mr, const ECP::Point &P)\n{\n\treturn P.identity ? P : ECP::Point(mr.ConvertIn(P.x), mr.ConvertIn(P.y));\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"ecp.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ECP::Point",
          "args": [
            "mr.ConvertIn(P.x)",
            "mr.ConvertIn(P.y)"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mr.ConvertIn",
          "args": [
            "P.y"
          ],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "ConvertIn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.h",
          "lines": "104-105",
          "snippet": "Element ConvertIn(const Element &P) const\n\t\t{return P.identity ? P : ECP::Point(m_ec->GetField().ConvertIn(P.x), m_ec->GetField().ConvertIn(P.y));}",
          "includes": [
            "#include \"pubkey.h\"",
            "#include \"smartptr.h\"",
            "#include \"eprecomp.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pubkey.h\"\n#include \"smartptr.h\"\n#include \"eprecomp.h\"\n#include \"modarith.h\"\n\nElement ConvertIn(const Element &P) const\n\t\t{return P.identity ? P : ECP::Point(m_ec->GetField().ConvertIn(P.x), m_ec->GetField().ConvertIn(P.y));}"
        }
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"ecp.h\"\n#include \"pch.h\"\n\nANONYMOUS_NAMESPACE_BEGIN\nstatic inline ECP::Point ToMontgomery(const ModularArithmetic &mr, const ECP::Point &P)\n{\n\treturn P.identity ? P : ECP::Point(mr.ConvertIn(P.x), mr.ConvertIn(P.y));\n}"
  }
]