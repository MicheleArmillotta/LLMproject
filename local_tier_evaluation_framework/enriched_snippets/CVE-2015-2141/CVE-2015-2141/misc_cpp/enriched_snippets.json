[
  {
    "function_name": "UnalignedDeallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
    "lines": "180-183",
    "snippet": "void UnalignedDeallocate(void *p)\n{\n\tfree(p);\n}",
    "includes": [
      "#include <malloc.h>",
      "#include <new>",
      "#include \"words.h\"",
      "#include \"misc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid UnalignedDeallocate(void *p)\n{\n\tfree(p);\n}"
  },
  {
    "function_name": "AlignedDeallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
    "lines": "158-168",
    "snippet": "void AlignedDeallocate(void *p)\n{\n#ifdef CRYPTOPP_MM_MALLOC_AVAILABLE\n\t_mm_free(p);\n#elif defined(CRYPTOPP_NO_ALIGNED_ALLOC)\n\tp = (byte *)p - ((byte *)p)[-1];\n\tfree(p);\n#else\n\tfree(p);\n#endif\n}",
    "includes": [
      "#include <malloc.h>",
      "#include <new>",
      "#include \"words.h\"",
      "#include \"misc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_free",
          "args": [
            "p"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid AlignedDeallocate(void *p)\n{\n#ifdef CRYPTOPP_MM_MALLOC_AVAILABLE\n\t_mm_free(p);\n#elif defined(CRYPTOPP_NO_ALIGNED_ALLOC)\n\tp = (byte *)p - ((byte *)p)[-1];\n\tfree(p);\n#else\n\tfree(p);\n#endif\n}"
  },
  {
    "function_name": "CallNewHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
    "lines": "120-130",
    "snippet": "void CallNewHandler()\n{\n\tnew_handler newHandler = set_new_handler(NULL);\n\tif (newHandler)\n\t\tset_new_handler(newHandler);\n\n\tif (newHandler)\n\t\tnewHandler();\n\telse\n\t\tthrow std::bad_alloc();\n}",
    "includes": [
      "#include <malloc.h>",
      "#include <new>",
      "#include \"words.h\"",
      "#include \"misc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::bad_alloc",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newHandler",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_new_handler",
          "args": [
            "newHandler"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_new_handler",
          "args": [
            "NULL"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid CallNewHandler()\n{\n\tnew_handler newHandler = set_new_handler(NULL);\n\tif (newHandler)\n\t\tset_new_handler(newHandler);\n\n\tif (newHandler)\n\t\tnewHandler();\n\telse\n\t\tthrow std::bad_alloc();\n}"
  },
  {
    "function_name": "VerifyBufsEqual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
    "lines": "79-113",
    "snippet": "bool VerifyBufsEqual(const byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\tbyte acc8 = 0;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tword32 acc32 = 0;\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tword64 acc64 = 0;\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\tacc64 |= ((word64*)buf)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn acc64 == 0;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t\tacc32 = word32(acc64) | word32(acc64>>32);\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\tacc32 |= ((word32*)buf)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn acc32 == 0;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t\tacc8 = byte(acc32) | byte(acc32>>8) | byte(acc32>>16) | byte(acc32>>24);\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tacc8 |= buf[i] ^ mask[i];\n\treturn acc8 == 0;\n}",
    "includes": [
      "#include <malloc.h>",
      "#include <new>",
      "#include \"words.h\"",
      "#include \"misc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "byte",
          "args": [
            "acc32>>24"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "byte",
          "args": [
            "acc32>>16"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "byte",
          "args": [
            "acc32>>8"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "byte",
          "args": [
            "acc32"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "acc64>>32"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "acc64"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAligned<word64>",
          "args": [
            "mask"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "IsAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "387-390",
          "snippet": "inline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nbool VerifyBufsEqual(const byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\tbyte acc8 = 0;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tword32 acc32 = 0;\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tword64 acc64 = 0;\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\tacc64 |= ((word64*)buf)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn acc64 == 0;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t\tacc32 = word32(acc64) | word32(acc64>>32);\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\tacc32 |= ((word32*)buf)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn acc32 == 0;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t\tacc8 = byte(acc32) | byte(acc32>>8) | byte(acc32>>16) | byte(acc32>>24);\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tacc8 |= buf[i] ^ mask[i];\n\treturn acc8 == 0;\n}"
  },
  {
    "function_name": "xorbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
    "lines": "47-77",
    "snippet": "void xorbuf(byte *output, const byte *input, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(output) && IsAligned<word32>(input) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(output) && IsAligned<word64>(input) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)output)[i] = ((word64*)input)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\toutput += 8*i;\n\t\t\tinput += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)output)[i] = ((word32*)input)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\toutput += 4*i;\n\t\tinput += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\toutput[i] = input[i] ^ mask[i];\n}",
    "includes": [
      "#include <malloc.h>",
      "#include <new>",
      "#include \"words.h\"",
      "#include \"misc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsAligned<word64>",
          "args": [
            "mask"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "IsAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "387-390",
          "snippet": "inline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *output, const byte *input, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(output) && IsAligned<word32>(input) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(output) && IsAligned<word64>(input) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)output)[i] = ((word64*)input)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\toutput += 8*i;\n\t\t\tinput += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)output)[i] = ((word32*)input)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\toutput += 4*i;\n\t\tinput += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\toutput[i] = input[i] ^ mask[i];\n}"
  },
  {
    "function_name": "xorbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
    "lines": "17-45",
    "snippet": "void xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}",
    "includes": [
      "#include <malloc.h>",
      "#include <new>",
      "#include \"words.h\"",
      "#include \"misc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsAligned<word64>",
          "args": [
            "mask"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "IsAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "387-390",
          "snippet": "inline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}"
  }
]