[
  {
    "function_name": "TruncatedFinal",
    "container": "AuthenticatedSymmetricCipherBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/authenc.cpp",
    "lines": "136-176",
    "snippet": "void AuthenticatedSymmetricCipherBase::TruncatedFinal(byte *mac, size_t macSize)\r\n{\r\n\tif (m_totalHeaderLength > MaxHeaderLength())\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": header length of \" + IntToString(m_totalHeaderLength) + \" exceeds the maximum of \" + IntToString(MaxHeaderLength()));\r\n\r\n\tif (m_totalFooterLength > MaxFooterLength())\r\n\t{\r\n\t\tif (MaxFooterLength() == 0)\r\n\t\t\tthrow InvalidArgument(AlgorithmName() + \": additional authenticated data (AAD) cannot be input after data to be encrypted or decrypted\");\r\n\t\telse\r\n\t\t\tthrow InvalidArgument(AlgorithmName() + \": footer length of \" + IntToString(m_totalFooterLength) + \" exceeds the maximum of \" + IntToString(MaxFooterLength()));\r\n\t}\r\n\r\n\tswitch (m_state)\r\n\t{\r\n\tcase State_Start:\r\n\tcase State_KeySet:\r\n\t\tthrow BadState(AlgorithmName(), \"TruncatedFinal\", \"setting key and IV\");\r\n\r\n\tcase State_IVSet:\r\n\t\tAuthenticateLastHeaderBlock();\r\n\t\tm_bufferedDataLength = 0;\r\n\t\t// fall through\r\n\r\n\tcase State_AuthUntransformed:\r\n\tcase State_AuthTransformed:\r\n\t\tAuthenticateLastConfidentialBlock();\r\n\t\tm_bufferedDataLength = 0;\r\n\t\t// fall through\r\n\r\n\tcase State_AuthFooter:\r\n\t\tAuthenticateLastFooterBlock(mac, macSize);\r\n\t\tm_bufferedDataLength = 0;\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\tassert(false);\r\n\t}\r\n\r\n\tm_state = State_KeySet;\r\n}",
    "includes": [
      "#include \"authenc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AuthenticateLastFooterBlock",
          "args": [
            "mac",
            "macSize"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "AuthenticateLastFooterBlock",
          "container": "EAX_Base",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/eax.cpp",
          "lines": "49-57",
          "snippet": "void EAX_Base::AuthenticateLastFooterBlock(byte *tag, size_t macSize)\r\n{\r\n\tassert(m_bufferedDataLength == 0);\r\n\tMessageAuthenticationCode &mac = AccessMAC();\r\n\tunsigned int blockSize = mac.TagSize();\r\n\r\n\tmac.TruncatedFinal(m_buffer, macSize);\r\n\txorbuf(tag, m_buffer, m_buffer+blockSize, macSize);\r\n}",
          "includes": [
            "#include \"eax.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"eax.h\"\n#include \"pch.h\"\n\nEAX_Base {\n  void EAX_Base::AuthenticateLastFooterBlock(byte *tag, size_t macSize)\r\n  {\r\n  \tassert(m_bufferedDataLength == 0);\r\n  \tMessageAuthenticationCode &mac = AccessMAC();\r\n  \tunsigned int blockSize = mac.TagSize();\r\n  \r\n  \tmac.TruncatedFinal(m_buffer, macSize);\r\n  \txorbuf(tag, m_buffer, m_buffer+blockSize, macSize);\r\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AuthenticateLastConfidentialBlock",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "AuthenticateLastConfidentialBlock",
          "container": "CCM_Base",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.cpp",
          "lines": "116-130",
          "snippet": "void CCM_Base::AuthenticateLastConfidentialBlock()\r\n{\r\n\tbyte *cbcBuffer = CBC_Buffer();\r\n\tconst BlockCipher &cipher = GetBlockCipher();\r\n\r\n\tif (m_messageLength != m_totalMessageLength)\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": message length doesn't match that given in SpecifyDataLengths\");\r\n\r\n\tif (m_bufferedDataLength > 0)\r\n\t{\r\n\t\txorbuf(cbcBuffer, m_buffer, m_bufferedDataLength);\r\n\t\tcipher.ProcessBlock(cbcBuffer);\r\n\t\tm_bufferedDataLength = 0;\r\n\t}\r\n}",
          "includes": [
            "#include \"ccm.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ccm.h\"\n#include \"pch.h\"\n\nCCM_Base {\n  void CCM_Base::AuthenticateLastConfidentialBlock()\r\n  {\r\n  \tbyte *cbcBuffer = CBC_Buffer();\r\n  \tconst BlockCipher &cipher = GetBlockCipher();\r\n  \r\n  \tif (m_messageLength != m_totalMessageLength)\r\n  \t\tthrow InvalidArgument(AlgorithmName() + \": message length doesn't match that given in SpecifyDataLengths\");\r\n  \r\n  \tif (m_bufferedDataLength > 0)\r\n  \t{\r\n  \t\txorbuf(cbcBuffer, m_buffer, m_bufferedDataLength);\r\n  \t\tcipher.ProcessBlock(cbcBuffer);\r\n  \t\tm_bufferedDataLength = 0;\r\n  \t}\r\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AuthenticateLastHeaderBlock",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "AuthenticateLastHeaderBlock",
          "container": "EAX_Base",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/eax.cpp",
          "lines": "35-47",
          "snippet": "void EAX_Base::AuthenticateLastHeaderBlock()\r\n{\r\n\tassert(m_bufferedDataLength == 0);\r\n\tMessageAuthenticationCode &mac = AccessMAC();\r\n\tunsigned int blockSize = mac.TagSize();\r\n\r\n\tmac.Final(m_buffer);\r\n\txorbuf(m_buffer+blockSize, m_buffer, blockSize);\r\n\r\n\tmemset(m_buffer, 0, blockSize);\r\n\tm_buffer[blockSize-1] = 2;\r\n\tmac.Update(m_buffer, blockSize);\r\n}",
          "includes": [
            "#include \"eax.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"eax.h\"\n#include \"pch.h\"\n\nEAX_Base {\n  void EAX_Base::AuthenticateLastHeaderBlock()\r\n  {\r\n  \tassert(m_bufferedDataLength == 0);\r\n  \tMessageAuthenticationCode &mac = AccessMAC();\r\n  \tunsigned int blockSize = mac.TagSize();\r\n  \r\n  \tmac.Final(m_buffer);\r\n  \txorbuf(m_buffer+blockSize, m_buffer, blockSize);\r\n  \r\n  \tmemset(m_buffer, 0, blockSize);\r\n  \tm_buffer[blockSize-1] = 2;\r\n  \tmac.Update(m_buffer, blockSize);\r\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BadState",
          "args": [
            "AlgorithmName()",
            "\"TruncatedFinal\"",
            "\"setting key and IV\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "CBC_MAC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cbcmac.h",
          "lines": "41-41",
          "snippet": "static std::string StaticAlgorithmName() {return std::string(\"CBC-MAC(\") + T::StaticAlgorithmName() + \")\";}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"seckey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"seckey.h\"\n\nCBC_MAC {\n  static std::string StaticAlgorithmName() {return std::string(\"CBC-MAC(\") + T::StaticAlgorithmName() + \")\";}\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": footer length of \" + IntToString(m_totalFooterLength) + \" exceeds the maximum of \" + IntToString(MaxFooterLength())"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "MaxFooterLength()"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MaxFooterLength",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": additional authenticated data (AAD) cannot be input after data to be encrypted or decrypted\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MaxFooterLength",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MaxFooterLength",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": header length of \" + IntToString(m_totalHeaderLength) + \" exceeds the maximum of \" + IntToString(MaxHeaderLength())"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MaxHeaderLength",
          "args": [],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "MaxHeaderLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/eax.h",
          "lines": "39-40",
          "snippet": "lword MaxHeaderLength() const\n\t\t{return LWORD_MAX;}",
          "includes": [
            "#include \"cmac.h\"",
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cmac.h\"\n#include \"modes.h\"\n#include \"authenc.h\"\n\nlword MaxHeaderLength() const\n\t\t{return LWORD_MAX;}"
        }
      }
    ],
    "contextual_snippet": "#include \"authenc.h\"\n#include \"pch.h\"\n\nAuthenticatedSymmetricCipherBase {\n  void AuthenticatedSymmetricCipherBase::TruncatedFinal(byte *mac, size_t macSize)\r\n  {\r\n  \tif (m_totalHeaderLength > MaxHeaderLength())\r\n  \t\tthrow InvalidArgument(AlgorithmName() + \": header length of \" + IntToString(m_totalHeaderLength) + \" exceeds the maximum of \" + IntToString(MaxHeaderLength()));\r\n  \r\n  \tif (m_totalFooterLength > MaxFooterLength())\r\n  \t{\r\n  \t\tif (MaxFooterLength() == 0)\r\n  \t\t\tthrow InvalidArgument(AlgorithmName() + \": additional authenticated data (AAD) cannot be input after data to be encrypted or decrypted\");\r\n  \t\telse\r\n  \t\t\tthrow InvalidArgument(AlgorithmName() + \": footer length of \" + IntToString(m_totalFooterLength) + \" exceeds the maximum of \" + IntToString(MaxFooterLength()));\r\n  \t}\r\n  \r\n  \tswitch (m_state)\r\n  \t{\r\n  \tcase State_Start:\r\n  \tcase State_KeySet:\r\n  \t\tthrow BadState(AlgorithmName(), \"TruncatedFinal\", \"setting key and IV\");\r\n  \r\n  \tcase State_IVSet:\r\n  \t\tAuthenticateLastHeaderBlock();\r\n  \t\tm_bufferedDataLength = 0;\r\n  \t\t// fall through\r\n  \r\n  \tcase State_AuthUntransformed:\r\n  \tcase State_AuthTransformed:\r\n  \t\tAuthenticateLastConfidentialBlock();\r\n  \t\tm_bufferedDataLength = 0;\r\n  \t\t// fall through\r\n  \r\n  \tcase State_AuthFooter:\r\n  \t\tAuthenticateLastFooterBlock(mac, macSize);\r\n  \t\tm_bufferedDataLength = 0;\r\n  \t\tbreak;\r\n  \r\n  \tdefault:\r\n  \t\tassert(false);\r\n  \t}\r\n  \r\n  \tm_state = State_KeySet;\r\n  }\n}"
  },
  {
    "function_name": "ProcessData",
    "container": "AuthenticatedSymmetricCipherBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/authenc.cpp",
    "lines": "104-134",
    "snippet": "void AuthenticatedSymmetricCipherBase::ProcessData(byte *outString, const byte *inString, size_t length)\r\n{\r\n\tm_totalMessageLength += length;\r\n\tif (m_state >= State_IVSet && m_totalMessageLength > MaxMessageLength())\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": message length exceeds maximum\");\r\n\r\nreswitch:\r\n\tswitch (m_state)\r\n\t{\r\n\tcase State_Start:\r\n\tcase State_KeySet:\r\n\t\tthrow BadState(AlgorithmName(), \"ProcessData\", \"setting key and IV\");\r\n\tcase State_AuthFooter:\r\n\t\tthrow BadState(AlgorithmName(), \"ProcessData was called after footer input has started\");\r\n\tcase State_IVSet:\r\n\t\tAuthenticateLastHeaderBlock();\r\n\t\tm_bufferedDataLength = 0;\r\n\t\tm_state = AuthenticationIsOnPlaintext()==IsForwardTransformation() ? State_AuthUntransformed : State_AuthTransformed;\r\n\t\tgoto reswitch;\r\n\tcase State_AuthUntransformed:\r\n\t\tAuthenticateData(inString, length);\r\n\t\tAccessSymmetricCipher().ProcessData(outString, inString, length);\r\n\t\tbreak;\r\n\tcase State_AuthTransformed:\r\n\t\tAccessSymmetricCipher().ProcessData(outString, inString, length);\r\n\t\tAuthenticateData(outString, length);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tassert(false);\r\n\t}\r\n}",
    "includes": [
      "#include \"authenc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AuthenticateData",
          "args": [
            "outString",
            "length"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "AuthenticateData",
          "container": "AuthenticatedSymmetricCipherBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/authenc.cpp",
          "lines": "11-46",
          "snippet": "void AuthenticatedSymmetricCipherBase::AuthenticateData(const byte *input, size_t len)\r\n{\r\n\tunsigned int blockSize = AuthenticationBlockSize();\r\n\tunsigned int &num = m_bufferedDataLength;\r\n\tbyte* data = m_buffer.begin();\r\n\r\n\tif (num != 0)\t// process left over data\r\n\t{\r\n\t\tif (num+len >= blockSize)\r\n\t\t{\r\n\t\t\tmemcpy(data+num, input, blockSize-num);\r\n\t\t\tAuthenticateBlocks(data, blockSize);\r\n\t\t\tinput += (blockSize-num);\r\n\t\t\tlen -= (blockSize-num);\r\n\t\t\tnum = 0;\r\n\t\t\t// drop through and do the rest\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmemcpy(data+num, input, len);\r\n\t\t\tnum += (unsigned int)len;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\t// now process the input data in blocks of blockSize bytes and save the leftovers to m_data\r\n\tif (len >= blockSize)\r\n\t{\r\n\t\tsize_t leftOver = AuthenticateBlocks(input, len);\r\n\t\tinput += (len - leftOver);\r\n\t\tlen = leftOver;\r\n\t}\r\n\r\n\tmemcpy(data, input, len);\r\n\tnum = (unsigned int)len;\r\n}",
          "includes": [
            "#include \"authenc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authenc.h\"\n#include \"pch.h\"\n\nAuthenticatedSymmetricCipherBase {\n  void AuthenticatedSymmetricCipherBase::AuthenticateData(const byte *input, size_t len)\r\n  {\r\n  \tunsigned int blockSize = AuthenticationBlockSize();\r\n  \tunsigned int &num = m_bufferedDataLength;\r\n  \tbyte* data = m_buffer.begin();\r\n  \r\n  \tif (num != 0)\t// process left over data\r\n  \t{\r\n  \t\tif (num+len >= blockSize)\r\n  \t\t{\r\n  \t\t\tmemcpy(data+num, input, blockSize-num);\r\n  \t\t\tAuthenticateBlocks(data, blockSize);\r\n  \t\t\tinput += (blockSize-num);\r\n  \t\t\tlen -= (blockSize-num);\r\n  \t\t\tnum = 0;\r\n  \t\t\t// drop through and do the rest\r\n  \t\t}\r\n  \t\telse\r\n  \t\t{\r\n  \t\t\tmemcpy(data+num, input, len);\r\n  \t\t\tnum += (unsigned int)len;\r\n  \t\t\treturn;\r\n  \t\t}\r\n  \t}\r\n  \r\n  \t// now process the input data in blocks of blockSize bytes and save the leftovers to m_data\r\n  \tif (len >= blockSize)\r\n  \t{\r\n  \t\tsize_t leftOver = AuthenticateBlocks(input, len);\r\n  \t\tinput += (len - leftOver);\r\n  \t\tlen = leftOver;\r\n  \t}\r\n  \r\n  \tmemcpy(data, input, len);\r\n  \tnum = (unsigned int)len;\r\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AccessSymmetricCipher",
          "args": [
            "outString",
            "inString",
            "length"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessSymmetricCipher",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessSymmetricCipher",
          "args": [
            "outString",
            "inString",
            "length"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessSymmetricCipher",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsForwardTransformation",
          "args": [],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "IsForwardTransformation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/arc4.h",
          "lines": "25-25",
          "snippet": "bool IsForwardTransformation() const {return true;}",
          "includes": [
            "#include \"strciphr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.h\"\n\nbool IsForwardTransformation() const {return true;}"
        }
      },
      {
        "call_info": {
          "callee": "AuthenticationIsOnPlaintext",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AuthenticateLastHeaderBlock",
          "args": [],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "AuthenticateLastHeaderBlock",
          "container": "EAX_Base",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/eax.cpp",
          "lines": "35-47",
          "snippet": "void EAX_Base::AuthenticateLastHeaderBlock()\r\n{\r\n\tassert(m_bufferedDataLength == 0);\r\n\tMessageAuthenticationCode &mac = AccessMAC();\r\n\tunsigned int blockSize = mac.TagSize();\r\n\r\n\tmac.Final(m_buffer);\r\n\txorbuf(m_buffer+blockSize, m_buffer, blockSize);\r\n\r\n\tmemset(m_buffer, 0, blockSize);\r\n\tm_buffer[blockSize-1] = 2;\r\n\tmac.Update(m_buffer, blockSize);\r\n}",
          "includes": [
            "#include \"eax.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"eax.h\"\n#include \"pch.h\"\n\nEAX_Base {\n  void EAX_Base::AuthenticateLastHeaderBlock()\r\n  {\r\n  \tassert(m_bufferedDataLength == 0);\r\n  \tMessageAuthenticationCode &mac = AccessMAC();\r\n  \tunsigned int blockSize = mac.TagSize();\r\n  \r\n  \tmac.Final(m_buffer);\r\n  \txorbuf(m_buffer+blockSize, m_buffer, blockSize);\r\n  \r\n  \tmemset(m_buffer, 0, blockSize);\r\n  \tm_buffer[blockSize-1] = 2;\r\n  \tmac.Update(m_buffer, blockSize);\r\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BadState",
          "args": [
            "AlgorithmName()",
            "\"ProcessData was called after footer input has started\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "CBC_MAC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cbcmac.h",
          "lines": "41-41",
          "snippet": "static std::string StaticAlgorithmName() {return std::string(\"CBC-MAC(\") + T::StaticAlgorithmName() + \")\";}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"seckey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"seckey.h\"\n\nCBC_MAC {\n  static std::string StaticAlgorithmName() {return std::string(\"CBC-MAC(\") + T::StaticAlgorithmName() + \")\";}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BadState",
          "args": [
            "AlgorithmName()",
            "\"ProcessData\"",
            "\"setting key and IV\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": message length exceeds maximum\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MaxMessageLength",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "MaxMessageLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/eax.h",
          "lines": "41-42",
          "snippet": "lword MaxMessageLength() const\n\t\t{return LWORD_MAX;}",
          "includes": [
            "#include \"cmac.h\"",
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cmac.h\"\n#include \"modes.h\"\n#include \"authenc.h\"\n\nlword MaxMessageLength() const\n\t\t{return LWORD_MAX;}"
        }
      }
    ],
    "contextual_snippet": "#include \"authenc.h\"\n#include \"pch.h\"\n\nAuthenticatedSymmetricCipherBase {\n  void AuthenticatedSymmetricCipherBase::ProcessData(byte *outString, const byte *inString, size_t length)\r\n  {\r\n  \tm_totalMessageLength += length;\r\n  \tif (m_state >= State_IVSet && m_totalMessageLength > MaxMessageLength())\r\n  \t\tthrow InvalidArgument(AlgorithmName() + \": message length exceeds maximum\");\r\n  \r\n  reswitch:\r\n  \tswitch (m_state)\r\n  \t{\r\n  \tcase State_Start:\r\n  \tcase State_KeySet:\r\n  \t\tthrow BadState(AlgorithmName(), \"ProcessData\", \"setting key and IV\");\r\n  \tcase State_AuthFooter:\r\n  \t\tthrow BadState(AlgorithmName(), \"ProcessData was called after footer input has started\");\r\n  \tcase State_IVSet:\r\n  \t\tAuthenticateLastHeaderBlock();\r\n  \t\tm_bufferedDataLength = 0;\r\n  \t\tm_state = AuthenticationIsOnPlaintext()==IsForwardTransformation() ? State_AuthUntransformed : State_AuthTransformed;\r\n  \t\tgoto reswitch;\r\n  \tcase State_AuthUntransformed:\r\n  \t\tAuthenticateData(inString, length);\r\n  \t\tAccessSymmetricCipher().ProcessData(outString, inString, length);\r\n  \t\tbreak;\r\n  \tcase State_AuthTransformed:\r\n  \t\tAccessSymmetricCipher().ProcessData(outString, inString, length);\r\n  \t\tAuthenticateData(outString, length);\r\n  \t\tbreak;\r\n  \tdefault:\r\n  \t\tassert(false);\r\n  \t}\r\n  }\n}"
  },
  {
    "function_name": "Update",
    "container": "AuthenticatedSymmetricCipherBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/authenc.cpp",
    "lines": "75-102",
    "snippet": "void AuthenticatedSymmetricCipherBase::Update(const byte *input, size_t length)\r\n{\r\n\tif (length == 0)\r\n\t\treturn;\r\n\r\n\tswitch (m_state)\r\n\t{\r\n\tcase State_Start:\r\n\tcase State_KeySet:\r\n\t\tthrow BadState(AlgorithmName(), \"Update\", \"setting key and IV\");\r\n\tcase State_IVSet:\r\n\t\tAuthenticateData(input, length);\r\n\t\tm_totalHeaderLength += length;\r\n\t\tbreak;\r\n\tcase State_AuthUntransformed:\r\n\tcase State_AuthTransformed:\r\n\t\tAuthenticateLastConfidentialBlock();\r\n\t\tm_bufferedDataLength = 0;\r\n\t\tm_state = State_AuthFooter;\r\n\t\t// fall through\r\n\tcase State_AuthFooter:\r\n\t\tAuthenticateData(input, length);\r\n\t\tm_totalFooterLength += length;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tassert(false);\r\n\t}\r\n}",
    "includes": [
      "#include \"authenc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AuthenticateData",
          "args": [
            "input",
            "length"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "AuthenticateData",
          "container": "AuthenticatedSymmetricCipherBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/authenc.cpp",
          "lines": "11-46",
          "snippet": "void AuthenticatedSymmetricCipherBase::AuthenticateData(const byte *input, size_t len)\r\n{\r\n\tunsigned int blockSize = AuthenticationBlockSize();\r\n\tunsigned int &num = m_bufferedDataLength;\r\n\tbyte* data = m_buffer.begin();\r\n\r\n\tif (num != 0)\t// process left over data\r\n\t{\r\n\t\tif (num+len >= blockSize)\r\n\t\t{\r\n\t\t\tmemcpy(data+num, input, blockSize-num);\r\n\t\t\tAuthenticateBlocks(data, blockSize);\r\n\t\t\tinput += (blockSize-num);\r\n\t\t\tlen -= (blockSize-num);\r\n\t\t\tnum = 0;\r\n\t\t\t// drop through and do the rest\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmemcpy(data+num, input, len);\r\n\t\t\tnum += (unsigned int)len;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\t// now process the input data in blocks of blockSize bytes and save the leftovers to m_data\r\n\tif (len >= blockSize)\r\n\t{\r\n\t\tsize_t leftOver = AuthenticateBlocks(input, len);\r\n\t\tinput += (len - leftOver);\r\n\t\tlen = leftOver;\r\n\t}\r\n\r\n\tmemcpy(data, input, len);\r\n\tnum = (unsigned int)len;\r\n}",
          "includes": [
            "#include \"authenc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authenc.h\"\n#include \"pch.h\"\n\nAuthenticatedSymmetricCipherBase {\n  void AuthenticatedSymmetricCipherBase::AuthenticateData(const byte *input, size_t len)\r\n  {\r\n  \tunsigned int blockSize = AuthenticationBlockSize();\r\n  \tunsigned int &num = m_bufferedDataLength;\r\n  \tbyte* data = m_buffer.begin();\r\n  \r\n  \tif (num != 0)\t// process left over data\r\n  \t{\r\n  \t\tif (num+len >= blockSize)\r\n  \t\t{\r\n  \t\t\tmemcpy(data+num, input, blockSize-num);\r\n  \t\t\tAuthenticateBlocks(data, blockSize);\r\n  \t\t\tinput += (blockSize-num);\r\n  \t\t\tlen -= (blockSize-num);\r\n  \t\t\tnum = 0;\r\n  \t\t\t// drop through and do the rest\r\n  \t\t}\r\n  \t\telse\r\n  \t\t{\r\n  \t\t\tmemcpy(data+num, input, len);\r\n  \t\t\tnum += (unsigned int)len;\r\n  \t\t\treturn;\r\n  \t\t}\r\n  \t}\r\n  \r\n  \t// now process the input data in blocks of blockSize bytes and save the leftovers to m_data\r\n  \tif (len >= blockSize)\r\n  \t{\r\n  \t\tsize_t leftOver = AuthenticateBlocks(input, len);\r\n  \t\tinput += (len - leftOver);\r\n  \t\tlen = leftOver;\r\n  \t}\r\n  \r\n  \tmemcpy(data, input, len);\r\n  \tnum = (unsigned int)len;\r\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AuthenticateLastConfidentialBlock",
          "args": [],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "AuthenticateLastConfidentialBlock",
          "container": "CCM_Base",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.cpp",
          "lines": "116-130",
          "snippet": "void CCM_Base::AuthenticateLastConfidentialBlock()\r\n{\r\n\tbyte *cbcBuffer = CBC_Buffer();\r\n\tconst BlockCipher &cipher = GetBlockCipher();\r\n\r\n\tif (m_messageLength != m_totalMessageLength)\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": message length doesn't match that given in SpecifyDataLengths\");\r\n\r\n\tif (m_bufferedDataLength > 0)\r\n\t{\r\n\t\txorbuf(cbcBuffer, m_buffer, m_bufferedDataLength);\r\n\t\tcipher.ProcessBlock(cbcBuffer);\r\n\t\tm_bufferedDataLength = 0;\r\n\t}\r\n}",
          "includes": [
            "#include \"ccm.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ccm.h\"\n#include \"pch.h\"\n\nCCM_Base {\n  void CCM_Base::AuthenticateLastConfidentialBlock()\r\n  {\r\n  \tbyte *cbcBuffer = CBC_Buffer();\r\n  \tconst BlockCipher &cipher = GetBlockCipher();\r\n  \r\n  \tif (m_messageLength != m_totalMessageLength)\r\n  \t\tthrow InvalidArgument(AlgorithmName() + \": message length doesn't match that given in SpecifyDataLengths\");\r\n  \r\n  \tif (m_bufferedDataLength > 0)\r\n  \t{\r\n  \t\txorbuf(cbcBuffer, m_buffer, m_bufferedDataLength);\r\n  \t\tcipher.ProcessBlock(cbcBuffer);\r\n  \t\tm_bufferedDataLength = 0;\r\n  \t}\r\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BadState",
          "args": [
            "AlgorithmName()",
            "\"Update\"",
            "\"setting key and IV\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "CBC_MAC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cbcmac.h",
          "lines": "41-41",
          "snippet": "static std::string StaticAlgorithmName() {return std::string(\"CBC-MAC(\") + T::StaticAlgorithmName() + \")\";}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"seckey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"seckey.h\"\n\nCBC_MAC {\n  static std::string StaticAlgorithmName() {return std::string(\"CBC-MAC(\") + T::StaticAlgorithmName() + \")\";}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authenc.h\"\n#include \"pch.h\"\n\nAuthenticatedSymmetricCipherBase {\n  void AuthenticatedSymmetricCipherBase::Update(const byte *input, size_t length)\r\n  {\r\n  \tif (length == 0)\r\n  \t\treturn;\r\n  \r\n  \tswitch (m_state)\r\n  \t{\r\n  \tcase State_Start:\r\n  \tcase State_KeySet:\r\n  \t\tthrow BadState(AlgorithmName(), \"Update\", \"setting key and IV\");\r\n  \tcase State_IVSet:\r\n  \t\tAuthenticateData(input, length);\r\n  \t\tm_totalHeaderLength += length;\r\n  \t\tbreak;\r\n  \tcase State_AuthUntransformed:\r\n  \tcase State_AuthTransformed:\r\n  \t\tAuthenticateLastConfidentialBlock();\r\n  \t\tm_bufferedDataLength = 0;\r\n  \t\tm_state = State_AuthFooter;\r\n  \t\t// fall through\r\n  \tcase State_AuthFooter:\r\n  \t\tAuthenticateData(input, length);\r\n  \t\tm_totalFooterLength += length;\r\n  \t\tbreak;\r\n  \tdefault:\r\n  \t\tassert(false);\r\n  \t}\r\n  }\n}"
  },
  {
    "function_name": "Resynchronize",
    "container": "AuthenticatedSymmetricCipherBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/authenc.cpp",
    "lines": "62-73",
    "snippet": "void AuthenticatedSymmetricCipherBase::Resynchronize(const byte *iv, int length)\r\n{\r\n\tif (m_state < State_KeySet)\r\n\t\tthrow BadState(AlgorithmName(), \"Resynchronize\", \"key is set\");\r\n\r\n\tm_bufferedDataLength = 0;\r\n\tm_totalHeaderLength = m_totalMessageLength = m_totalFooterLength = 0;\r\n\tm_state = State_KeySet;\r\n\r\n\tResync(iv, this->ThrowIfInvalidIVLength(length));\r\n\tm_state = State_IVSet;\r\n}",
    "includes": [
      "#include \"authenc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Resync",
          "args": [
            "iv",
            "this->ThrowIfInvalidIVLength(length)"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "Resynchronize",
          "container": "AuthenticatedSymmetricCipherBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/authenc.cpp",
          "lines": "62-73",
          "snippet": "void AuthenticatedSymmetricCipherBase::Resynchronize(const byte *iv, int length)\r\n{\r\n\tif (m_state < State_KeySet)\r\n\t\tthrow BadState(AlgorithmName(), \"Resynchronize\", \"key is set\");\r\n\r\n\tm_bufferedDataLength = 0;\r\n\tm_totalHeaderLength = m_totalMessageLength = m_totalFooterLength = 0;\r\n\tm_state = State_KeySet;\r\n\r\n\tResync(iv, this->ThrowIfInvalidIVLength(length));\r\n\tm_state = State_IVSet;\r\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "this->ThrowIfInvalidIVLength",
          "args": [
            "length"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "ThrowIfInvalidIVLength",
          "container": "SimpleKeyingInterface",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "94-104",
          "snippet": "size_t SimpleKeyingInterface::ThrowIfInvalidIVLength(int size)\n{\n\tif (size < 0)\n\t\treturn IVSize();\n\telse if ((size_t)size < MinIVLength())\n\t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": IV length \" + IntToString(size) + \" is less than the minimum of \" + IntToString(MinIVLength()));\n\telse if ((size_t)size > MaxIVLength())\n\t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": IV length \" + IntToString(size) + \" exceeds the maximum of \" + IntToString(MaxIVLength()));\n\telse\n\t\treturn size;\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nSimpleKeyingInterface {\n  size_t SimpleKeyingInterface::ThrowIfInvalidIVLength(int size)\n  {\n  \tif (size < 0)\n  \t\treturn IVSize();\n  \telse if ((size_t)size < MinIVLength())\n  \t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": IV length \" + IntToString(size) + \" is less than the minimum of \" + IntToString(MinIVLength()));\n  \telse if ((size_t)size > MaxIVLength())\n  \t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": IV length \" + IntToString(size) + \" exceeds the maximum of \" + IntToString(MaxIVLength()));\n  \telse\n  \t\treturn size;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BadState",
          "args": [
            "AlgorithmName()",
            "\"Resynchronize\"",
            "\"key is set\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "CBC_MAC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cbcmac.h",
          "lines": "41-41",
          "snippet": "static std::string StaticAlgorithmName() {return std::string(\"CBC-MAC(\") + T::StaticAlgorithmName() + \")\";}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"seckey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"seckey.h\"\n\nCBC_MAC {\n  static std::string StaticAlgorithmName() {return std::string(\"CBC-MAC(\") + T::StaticAlgorithmName() + \")\";}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authenc.h\"\n#include \"pch.h\"\n\nAuthenticatedSymmetricCipherBase {\n  void AuthenticatedSymmetricCipherBase::Resynchronize(const byte *iv, int length)\r\n  {\r\n  \tif (m_state < State_KeySet)\r\n  \t\tthrow BadState(AlgorithmName(), \"Resynchronize\", \"key is set\");\r\n  \r\n  \tm_bufferedDataLength = 0;\r\n  \tm_totalHeaderLength = m_totalMessageLength = m_totalFooterLength = 0;\r\n  \tm_state = State_KeySet;\r\n  \r\n  \tResync(iv, this->ThrowIfInvalidIVLength(length));\r\n  \tm_state = State_IVSet;\r\n  }\n}"
  },
  {
    "function_name": "SetKey",
    "container": "AuthenticatedSymmetricCipherBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/authenc.cpp",
    "lines": "48-60",
    "snippet": "void AuthenticatedSymmetricCipherBase::SetKey(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n{\r\n\tm_bufferedDataLength = 0;\r\n\tm_state = State_Start;\r\n\r\n\tSetKeyWithoutResync(userKey, keylength, params);\r\n\tm_state = State_KeySet;\r\n\r\n\tsize_t length;\r\n\tconst byte *iv = GetIVAndThrowIfInvalid(params, length);\r\n\tif (iv)\r\n\t\tResynchronize(iv, (int)length);\r\n}",
    "includes": [
      "#include \"authenc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Resynchronize",
          "args": [
            "iv",
            "(int)length"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "Resynchronize",
          "container": "AuthenticatedSymmetricCipherBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/authenc.cpp",
          "lines": "62-73",
          "snippet": "void AuthenticatedSymmetricCipherBase::Resynchronize(const byte *iv, int length)\r\n{\r\n\tif (m_state < State_KeySet)\r\n\t\tthrow BadState(AlgorithmName(), \"Resynchronize\", \"key is set\");\r\n\r\n\tm_bufferedDataLength = 0;\r\n\tm_totalHeaderLength = m_totalMessageLength = m_totalFooterLength = 0;\r\n\tm_state = State_KeySet;\r\n\r\n\tResync(iv, this->ThrowIfInvalidIVLength(length));\r\n\tm_state = State_IVSet;\r\n}",
          "includes": [
            "#include \"authenc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authenc.h\"\n#include \"pch.h\"\n\nAuthenticatedSymmetricCipherBase {\n  void AuthenticatedSymmetricCipherBase::Resynchronize(const byte *iv, int length)\r\n  {\r\n  \tif (m_state < State_KeySet)\r\n  \t\tthrow BadState(AlgorithmName(), \"Resynchronize\", \"key is set\");\r\n  \r\n  \tm_bufferedDataLength = 0;\r\n  \tm_totalHeaderLength = m_totalMessageLength = m_totalFooterLength = 0;\r\n  \tm_state = State_KeySet;\r\n  \r\n  \tResync(iv, this->ThrowIfInvalidIVLength(length));\r\n  \tm_state = State_IVSet;\r\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetIVAndThrowIfInvalid",
          "args": [
            "params",
            "length"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetKeyWithoutResync",
          "args": [
            "userKey",
            "keylength",
            "params"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "SetKeyWithoutResync",
          "container": "EAX_Base",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/eax.cpp",
          "lines": "8-12",
          "snippet": "void EAX_Base::SetKeyWithoutResync(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n{\r\n\tAccessMAC().SetKey(userKey, keylength, params);\r\n\tm_buffer.New(2*AccessMAC().TagSize());\r\n}",
          "includes": [
            "#include \"eax.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"eax.h\"\n#include \"pch.h\"\n\nEAX_Base {\n  void EAX_Base::SetKeyWithoutResync(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n  {\r\n  \tAccessMAC().SetKey(userKey, keylength, params);\r\n  \tm_buffer.New(2*AccessMAC().TagSize());\r\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"authenc.h\"\n#include \"pch.h\"\n\nAuthenticatedSymmetricCipherBase {\n  void AuthenticatedSymmetricCipherBase::SetKey(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n  {\r\n  \tm_bufferedDataLength = 0;\r\n  \tm_state = State_Start;\r\n  \r\n  \tSetKeyWithoutResync(userKey, keylength, params);\r\n  \tm_state = State_KeySet;\r\n  \r\n  \tsize_t length;\r\n  \tconst byte *iv = GetIVAndThrowIfInvalid(params, length);\r\n  \tif (iv)\r\n  \t\tResynchronize(iv, (int)length);\r\n  }\n}"
  },
  {
    "function_name": "AuthenticateData",
    "container": "AuthenticatedSymmetricCipherBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/authenc.cpp",
    "lines": "11-46",
    "snippet": "void AuthenticatedSymmetricCipherBase::AuthenticateData(const byte *input, size_t len)\r\n{\r\n\tunsigned int blockSize = AuthenticationBlockSize();\r\n\tunsigned int &num = m_bufferedDataLength;\r\n\tbyte* data = m_buffer.begin();\r\n\r\n\tif (num != 0)\t// process left over data\r\n\t{\r\n\t\tif (num+len >= blockSize)\r\n\t\t{\r\n\t\t\tmemcpy(data+num, input, blockSize-num);\r\n\t\t\tAuthenticateBlocks(data, blockSize);\r\n\t\t\tinput += (blockSize-num);\r\n\t\t\tlen -= (blockSize-num);\r\n\t\t\tnum = 0;\r\n\t\t\t// drop through and do the rest\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmemcpy(data+num, input, len);\r\n\t\t\tnum += (unsigned int)len;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\t// now process the input data in blocks of blockSize bytes and save the leftovers to m_data\r\n\tif (len >= blockSize)\r\n\t{\r\n\t\tsize_t leftOver = AuthenticateBlocks(input, len);\r\n\t\tinput += (len - leftOver);\r\n\t\tlen = leftOver;\r\n\t}\r\n\r\n\tmemcpy(data, input, len);\r\n\tnum = (unsigned int)len;\r\n}",
    "includes": [
      "#include \"authenc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "input",
            "len"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AuthenticateBlocks",
          "args": [
            "input",
            "len"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "AuthenticateBlocks",
          "container": "EAX_Base",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/eax.cpp",
          "lines": "29-33",
          "snippet": "size_t EAX_Base::AuthenticateBlocks(const byte *data, size_t len)\r\n{\r\n\tAccessMAC().Update(data, len);\r\n\treturn 0;\r\n}",
          "includes": [
            "#include \"eax.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"eax.h\"\n#include \"pch.h\"\n\nEAX_Base {\n  size_t EAX_Base::AuthenticateBlocks(const byte *data, size_t len)\r\n  {\r\n  \tAccessMAC().Update(data, len);\r\n  \treturn 0;\r\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data+num",
            "input",
            "len"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data+num",
            "input",
            "blockSize-num"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_buffer.begin",
          "args": [],
          "line": 15
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AuthenticationBlockSize",
          "args": [],
          "line": 13
        },
        "resolved": true,
        "details": {
          "function_name": "AuthenticationBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/eax.h",
          "lines": "48-49",
          "snippet": "unsigned int AuthenticationBlockSize() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cmac.h\"",
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cmac.h\"\n#include \"modes.h\"\n#include \"authenc.h\"\n\nunsigned int AuthenticationBlockSize() const\n\t\t{return 1;}"
        }
      }
    ],
    "contextual_snippet": "#include \"authenc.h\"\n#include \"pch.h\"\n\nAuthenticatedSymmetricCipherBase {\n  void AuthenticatedSymmetricCipherBase::AuthenticateData(const byte *input, size_t len)\r\n  {\r\n  \tunsigned int blockSize = AuthenticationBlockSize();\r\n  \tunsigned int &num = m_bufferedDataLength;\r\n  \tbyte* data = m_buffer.begin();\r\n  \r\n  \tif (num != 0)\t// process left over data\r\n  \t{\r\n  \t\tif (num+len >= blockSize)\r\n  \t\t{\r\n  \t\t\tmemcpy(data+num, input, blockSize-num);\r\n  \t\t\tAuthenticateBlocks(data, blockSize);\r\n  \t\t\tinput += (blockSize-num);\r\n  \t\t\tlen -= (blockSize-num);\r\n  \t\t\tnum = 0;\r\n  \t\t\t// drop through and do the rest\r\n  \t\t}\r\n  \t\telse\r\n  \t\t{\r\n  \t\t\tmemcpy(data+num, input, len);\r\n  \t\t\tnum += (unsigned int)len;\r\n  \t\t\treturn;\r\n  \t\t}\r\n  \t}\r\n  \r\n  \t// now process the input data in blocks of blockSize bytes and save the leftovers to m_data\r\n  \tif (len >= blockSize)\r\n  \t{\r\n  \t\tsize_t leftOver = AuthenticateBlocks(input, len);\r\n  \t\tinput += (len - leftOver);\r\n  \t\tlen = leftOver;\r\n  \t}\r\n  \r\n  \tmemcpy(data, input, len);\r\n  \tnum = (unsigned int)len;\r\n  }\n}"
  }
]