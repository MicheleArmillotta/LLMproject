[
  {
    "function_name": "DSAConvertSignatureFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/dsa.cpp",
    "lines": "12-59",
    "snippet": "size_t DSAConvertSignatureFormat(byte *buffer, size_t bufferSize, DSASignatureFormat toFormat, const byte *signature, size_t signatureLen, DSASignatureFormat fromFormat)\n{\n\tInteger r, s;\n\tStringStore store(signature, signatureLen);\n\tArraySink sink(buffer, bufferSize);\n\n\tswitch (fromFormat)\n\t{\n\tcase DSA_P1363:\n\t\tr.Decode(store, signatureLen/2);\n\t\ts.Decode(store, signatureLen/2);\n\t\tbreak;\n\tcase DSA_DER:\n\t{\n\t\tBERSequenceDecoder seq(store);\n\t\tr.BERDecode(seq);\n\t\ts.BERDecode(seq);\n\t\tseq.MessageEnd();\n\t\tbreak;\n\t}\n\tcase DSA_OPENPGP:\n\t\tr.OpenPGPDecode(store);\n\t\ts.OpenPGPDecode(store);\n\t\tbreak;\n\t}\n\n\tswitch (toFormat)\n\t{\n\tcase DSA_P1363:\n\t\tr.Encode(sink, bufferSize/2);\n\t\ts.Encode(sink, bufferSize/2);\n\t\tbreak;\n\tcase DSA_DER:\n\t{\n\t\tDERSequenceEncoder seq(sink);\n\t\tr.DEREncode(seq);\n\t\ts.DEREncode(seq);\n\t\tseq.MessageEnd();\n\t\tbreak;\n\t}\n\tcase DSA_OPENPGP:\n\t\tr.OpenPGPEncode(sink);\n\t\ts.OpenPGPEncode(sink);\n\t\tbreak;\n\t}\n\n\treturn (size_t)sink.TotalPutLength();\n}",
    "includes": [
      "#include \"nbtheory.h\"",
      "#include \"dsa.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sink.TotalPutLength",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.OpenPGPEncode",
          "args": [
            "sink"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "OpenPGPEncode",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3177-3184",
          "snippet": "size_t Integer::OpenPGPEncode(BufferedTransformation &bt) const\n{\n\tword16 bitCount = BitCount();\n\tbt.PutWord16(bitCount);\n\tsize_t byteCount = BitsToBytes(bitCount);\n\tEncode(bt, byteCount);\n\treturn 2 + byteCount;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  size_t Integer::OpenPGPEncode(BufferedTransformation &bt) const\n  {\n  \tword16 bitCount = BitCount();\n  \tbt.PutWord16(bitCount);\n  \tsize_t byteCount = BitsToBytes(bitCount);\n  \tEncode(bt, byteCount);\n  \treturn 2 + byteCount;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.DEREncode",
          "args": [
            "seq"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncode",
          "container": "DL_GroupParameters_IntegerBased",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gfpcrypt.cpp",
          "lines": "216-223",
          "snippet": "void DL_GroupParameters_IntegerBased::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder parameters(bt);\n\t\tGetModulus().DEREncode(parameters);\n\t\tm_q.DEREncode(parameters);\n\t\tGetSubgroupGenerator().DEREncode(parameters);\n\tparameters.MessageEnd();\n}",
          "includes": [
            "#include \"nbtheory.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"gfpcrypt.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nbtheory.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"gfpcrypt.h\"\n#include \"pch.h\"\n\nDL_GroupParameters_IntegerBased {\n  void DL_GroupParameters_IntegerBased::DEREncode(BufferedTransformation &bt) const\n  {\n  \tDERSequenceEncoder parameters(bt);\n  \t\tGetModulus().DEREncode(parameters);\n  \t\tm_q.DEREncode(parameters);\n  \t\tGetSubgroupGenerator().DEREncode(parameters);\n  \tparameters.MessageEnd();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r.DEREncode",
          "args": [
            "seq"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncode",
          "container": "ModularArithmetic",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "4021-4027",
          "snippet": "void ModularArithmetic::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\tASN1::prime_field().DEREncode(seq);\n\tm_modulus.DEREncode(seq);\n\tseq.MessageEnd();\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nModularArithmetic {\n  void ModularArithmetic::DEREncode(BufferedTransformation &bt) const\n  {\n  \tDERSequenceEncoder seq(bt);\n  \tASN1::prime_field().DEREncode(seq);\n  \tm_modulus.DEREncode(seq);\n  \tseq.MessageEnd();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.Encode",
          "args": [
            "sink",
            "bufferSize/2"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "r.Encode",
          "args": [
            "sink",
            "bufferSize/2"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeBlock",
          "container": "Deflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "632-736",
          "snippet": "void Deflator::EncodeBlock(bool eof, unsigned int blockType)\n{\n\tPutBits(eof, 1);\n\tPutBits(blockType, 2);\n\n\tif (blockType == STORED)\n\t{\n\t\tassert(m_blockStart + m_blockLength <= m_byteBuffer.size());\n\t\tassert(m_blockLength <= 0xffff);\n\t\tFlushBitBuffer();\n\t\tAttachedTransformation()->PutWord16(m_blockLength, LITTLE_ENDIAN_ORDER);\n\t\tAttachedTransformation()->PutWord16(~m_blockLength, LITTLE_ENDIAN_ORDER);\n\t\tAttachedTransformation()->Put(m_byteBuffer + m_blockStart, m_blockLength);\n\t}\n\telse\n\t{\n\t\tif (blockType == DYNAMIC)\n\t\t{\n#if defined(_MSC_VER) && !defined(__MWERKS__) && (_MSC_VER <= 1300)\n\t\t\t// VC60 and VC7 workaround: built-in reverse_iterator has two template parameters, Dinkumware only has one\n\t\t\ttypedef reverse_bidirectional_iterator<unsigned int *, unsigned int> RevIt;\n#elif defined(_RWSTD_NO_CLASS_PARTIAL_SPEC)\n\ttypedef reverse_iterator<unsigned int *, random_access_iterator_tag, unsigned int> RevIt;\n#else\n\t\t\ttypedef reverse_iterator<unsigned int *> RevIt;\n#endif\n\n\t\t\tFixedSizeSecBlock<unsigned int, 286> literalCodeLengths;\n\t\t\tFixedSizeSecBlock<unsigned int, 30> distanceCodeLengths;\n\n\t\t\tm_literalCounts[256] = 1;\n\t\t\tHuffmanEncoder::GenerateCodeLengths(literalCodeLengths, 15, m_literalCounts, 286);\n\t\t\tm_dynamicLiteralEncoder.Initialize(literalCodeLengths, 286);\n\t\t\tunsigned int hlit = (unsigned int)(find_if(RevIt(literalCodeLengths.end()), RevIt(literalCodeLengths.begin()+257), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (literalCodeLengths.begin()+257));\n\n\t\t\tHuffmanEncoder::GenerateCodeLengths(distanceCodeLengths, 15, m_distanceCounts, 30);\n\t\t\tm_dynamicDistanceEncoder.Initialize(distanceCodeLengths, 30);\n\t\t\tunsigned int hdist = (unsigned int)(find_if(RevIt(distanceCodeLengths.end()), RevIt(distanceCodeLengths.begin()+1), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (distanceCodeLengths.begin()+1));\n\n\t\t\tSecBlockWithHint<unsigned int, 286+30> combinedLengths(hlit+257+hdist+1);\n\t\t\tmemcpy(combinedLengths, literalCodeLengths, (hlit+257)*sizeof(unsigned int));\n\t\t\tmemcpy(combinedLengths+hlit+257, distanceCodeLengths, (hdist+1)*sizeof(unsigned int));\n\n\t\t\tFixedSizeSecBlock<unsigned int, 19> codeLengthCodeCounts, codeLengthCodeLengths;\n\t\t\tfill(codeLengthCodeCounts.begin(), codeLengthCodeCounts.end(), 0);\n\t\t\tconst unsigned int *p = combinedLengths.begin(), *begin = combinedLengths.begin(), *end = combinedLengths.end();\n\t\t\twhile (p != end)\n\t\t\t{\n\t\t\t\tunsigned int code, extraBits, extraBitsLength;\n\t\t\t\tcode = CodeLengthEncode(begin, end, p, extraBits, extraBitsLength);\n\t\t\t\tcodeLengthCodeCounts[code]++;\n\t\t\t}\n\t\t\tHuffmanEncoder::GenerateCodeLengths(codeLengthCodeLengths, 7, codeLengthCodeCounts, 19);\n\t\t\tHuffmanEncoder codeLengthEncoder(codeLengthCodeLengths, 19);\n\t\t\tstatic const unsigned int border[] = {    // Order of the bit length code lengths\n\t\t\t\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\t\t\tunsigned int hclen = 19;\n\t\t\twhile (hclen > 4 && codeLengthCodeLengths[border[hclen-1]] == 0)\n\t\t\t\thclen--;\n\t\t\thclen -= 4;\n\n\t\t\tPutBits(hlit, 5);\n\t\t\tPutBits(hdist, 5);\n\t\t\tPutBits(hclen, 4);\n\n\t\t\tfor (unsigned int i=0; i<hclen+4; i++)\n\t\t\t\tPutBits(codeLengthCodeLengths[border[i]], 3);\n\n\t\t\tp = combinedLengths.begin();\n\t\t\twhile (p != end)\n\t\t\t{\n\t\t\t\tunsigned int code, extraBits, extraBitsLength;\n\t\t\t\tcode = CodeLengthEncode(begin, end, p, extraBits, extraBitsLength);\n\t\t\t\tcodeLengthEncoder.Encode(*this, code);\n\t\t\t\tPutBits(extraBits, extraBitsLength);\n\t\t\t}\n\t\t}\n\n\t\tstatic const unsigned int lengthExtraBits[] = {\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n\t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n\t\tstatic const unsigned int distanceExtraBits[] = {\n\t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n\t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n\t\t\t12, 12, 13, 13};\n\n\t\tconst HuffmanEncoder &literalEncoder = (blockType == STATIC) ? m_staticLiteralEncoder : m_dynamicLiteralEncoder;\n\t\tconst HuffmanEncoder &distanceEncoder = (blockType == STATIC) ? m_staticDistanceEncoder : m_dynamicDistanceEncoder;\n\n\t\tfor (unsigned int i=0; i<m_matchBufferEnd; i++)\n\t\t{\n\t\t\tunsigned int literalCode = m_matchBuffer[i].literalCode;\n\t\t\tliteralEncoder.Encode(*this, literalCode);\n\t\t\tif (literalCode >= 257)\n\t\t\t{\n\t\t\t\tassert(literalCode <= 285);\n\t\t\t\tPutBits(m_matchBuffer[i].literalExtra, lengthExtraBits[literalCode-257]);\n\t\t\t\tunsigned int distanceCode = m_matchBuffer[i].distanceCode;\n\t\t\t\tdistanceEncoder.Encode(*this, distanceCode);\n\t\t\t\tPutBits(m_matchBuffer[i].distanceExtra, distanceExtraBits[distanceCode]);\n\t\t\t}\n\t\t}\n\t\tliteralEncoder.Encode(*this, 256);\t// end of block\n\t}\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nDeflator {\n  void Deflator::EncodeBlock(bool eof, unsigned int blockType)\n  {\n  \tPutBits(eof, 1);\n  \tPutBits(blockType, 2);\n  \n  \tif (blockType == STORED)\n  \t{\n  \t\tassert(m_blockStart + m_blockLength <= m_byteBuffer.size());\n  \t\tassert(m_blockLength <= 0xffff);\n  \t\tFlushBitBuffer();\n  \t\tAttachedTransformation()->PutWord16(m_blockLength, LITTLE_ENDIAN_ORDER);\n  \t\tAttachedTransformation()->PutWord16(~m_blockLength, LITTLE_ENDIAN_ORDER);\n  \t\tAttachedTransformation()->Put(m_byteBuffer + m_blockStart, m_blockLength);\n  \t}\n  \telse\n  \t{\n  \t\tif (blockType == DYNAMIC)\n  \t\t{\n  #if defined(_MSC_VER) && !defined(__MWERKS__) && (_MSC_VER <= 1300)\n  \t\t\t// VC60 and VC7 workaround: built-in reverse_iterator has two template parameters, Dinkumware only has one\n  \t\t\ttypedef reverse_bidirectional_iterator<unsigned int *, unsigned int> RevIt;\n  #elif defined(_RWSTD_NO_CLASS_PARTIAL_SPEC)\n  \ttypedef reverse_iterator<unsigned int *, random_access_iterator_tag, unsigned int> RevIt;\n  #else\n  \t\t\ttypedef reverse_iterator<unsigned int *> RevIt;\n  #endif\n  \n  \t\t\tFixedSizeSecBlock<unsigned int, 286> literalCodeLengths;\n  \t\t\tFixedSizeSecBlock<unsigned int, 30> distanceCodeLengths;\n  \n  \t\t\tm_literalCounts[256] = 1;\n  \t\t\tHuffmanEncoder::GenerateCodeLengths(literalCodeLengths, 15, m_literalCounts, 286);\n  \t\t\tm_dynamicLiteralEncoder.Initialize(literalCodeLengths, 286);\n  \t\t\tunsigned int hlit = (unsigned int)(find_if(RevIt(literalCodeLengths.end()), RevIt(literalCodeLengths.begin()+257), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (literalCodeLengths.begin()+257));\n  \n  \t\t\tHuffmanEncoder::GenerateCodeLengths(distanceCodeLengths, 15, m_distanceCounts, 30);\n  \t\t\tm_dynamicDistanceEncoder.Initialize(distanceCodeLengths, 30);\n  \t\t\tunsigned int hdist = (unsigned int)(find_if(RevIt(distanceCodeLengths.end()), RevIt(distanceCodeLengths.begin()+1), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (distanceCodeLengths.begin()+1));\n  \n  \t\t\tSecBlockWithHint<unsigned int, 286+30> combinedLengths(hlit+257+hdist+1);\n  \t\t\tmemcpy(combinedLengths, literalCodeLengths, (hlit+257)*sizeof(unsigned int));\n  \t\t\tmemcpy(combinedLengths+hlit+257, distanceCodeLengths, (hdist+1)*sizeof(unsigned int));\n  \n  \t\t\tFixedSizeSecBlock<unsigned int, 19> codeLengthCodeCounts, codeLengthCodeLengths;\n  \t\t\tfill(codeLengthCodeCounts.begin(), codeLengthCodeCounts.end(), 0);\n  \t\t\tconst unsigned int *p = combinedLengths.begin(), *begin = combinedLengths.begin(), *end = combinedLengths.end();\n  \t\t\twhile (p != end)\n  \t\t\t{\n  \t\t\t\tunsigned int code, extraBits, extraBitsLength;\n  \t\t\t\tcode = CodeLengthEncode(begin, end, p, extraBits, extraBitsLength);\n  \t\t\t\tcodeLengthCodeCounts[code]++;\n  \t\t\t}\n  \t\t\tHuffmanEncoder::GenerateCodeLengths(codeLengthCodeLengths, 7, codeLengthCodeCounts, 19);\n  \t\t\tHuffmanEncoder codeLengthEncoder(codeLengthCodeLengths, 19);\n  \t\t\tstatic const unsigned int border[] = {    // Order of the bit length code lengths\n  \t\t\t\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n  \t\t\tunsigned int hclen = 19;\n  \t\t\twhile (hclen > 4 && codeLengthCodeLengths[border[hclen-1]] == 0)\n  \t\t\t\thclen--;\n  \t\t\thclen -= 4;\n  \n  \t\t\tPutBits(hlit, 5);\n  \t\t\tPutBits(hdist, 5);\n  \t\t\tPutBits(hclen, 4);\n  \n  \t\t\tfor (unsigned int i=0; i<hclen+4; i++)\n  \t\t\t\tPutBits(codeLengthCodeLengths[border[i]], 3);\n  \n  \t\t\tp = combinedLengths.begin();\n  \t\t\twhile (p != end)\n  \t\t\t{\n  \t\t\t\tunsigned int code, extraBits, extraBitsLength;\n  \t\t\t\tcode = CodeLengthEncode(begin, end, p, extraBits, extraBitsLength);\n  \t\t\t\tcodeLengthEncoder.Encode(*this, code);\n  \t\t\t\tPutBits(extraBits, extraBitsLength);\n  \t\t\t}\n  \t\t}\n  \n  \t\tstatic const unsigned int lengthExtraBits[] = {\n  \t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n  \t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n  \t\tstatic const unsigned int distanceExtraBits[] = {\n  \t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n  \t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n  \t\t\t12, 12, 13, 13};\n  \n  \t\tconst HuffmanEncoder &literalEncoder = (blockType == STATIC) ? m_staticLiteralEncoder : m_dynamicLiteralEncoder;\n  \t\tconst HuffmanEncoder &distanceEncoder = (blockType == STATIC) ? m_staticDistanceEncoder : m_dynamicDistanceEncoder;\n  \n  \t\tfor (unsigned int i=0; i<m_matchBufferEnd; i++)\n  \t\t{\n  \t\t\tunsigned int literalCode = m_matchBuffer[i].literalCode;\n  \t\t\tliteralEncoder.Encode(*this, literalCode);\n  \t\t\tif (literalCode >= 257)\n  \t\t\t{\n  \t\t\t\tassert(literalCode <= 285);\n  \t\t\t\tPutBits(m_matchBuffer[i].literalExtra, lengthExtraBits[literalCode-257]);\n  \t\t\t\tunsigned int distanceCode = m_matchBuffer[i].distanceCode;\n  \t\t\t\tdistanceEncoder.Encode(*this, distanceCode);\n  \t\t\t\tPutBits(m_matchBuffer[i].distanceExtra, distanceExtraBits[distanceCode]);\n  \t\t\t}\n  \t\t}\n  \t\tliteralEncoder.Encode(*this, 256);\t// end of block\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.OpenPGPDecode",
          "args": [
            "store"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "OpenPGPDecode",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3192-3198",
          "snippet": "void Integer::OpenPGPDecode(BufferedTransformation &bt)\n{\n\tword16 bitCount;\n\tif (bt.GetWord16(bitCount) != 2 || bt.MaxRetrievable() < BitsToBytes(bitCount))\n\t\tthrow OpenPGPDecodeErr();\n\tDecode(bt, BitsToBytes(bitCount));\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  void Integer::OpenPGPDecode(BufferedTransformation &bt)\n  {\n  \tword16 bitCount;\n  \tif (bt.GetWord16(bitCount) != 2 || bt.MaxRetrievable() < BitsToBytes(bitCount))\n  \t\tthrow OpenPGPDecodeErr();\n  \tDecode(bt, BitsToBytes(bitCount));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.BERDecode",
          "args": [
            "seq"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecode",
          "container": "DL_GroupParameters_IntegerBased",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gfpcrypt.cpp",
          "lines": "197-214",
          "snippet": "void DL_GroupParameters_IntegerBased::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder parameters(bt);\n\t\tInteger p(parameters);\n\t\tInteger q(parameters);\n\t\tInteger g;\n\t\tif (parameters.EndReached())\n\t\t{\n\t\t\tg = q;\n\t\t\tq = ComputeGroupOrder(p) / 2;\n\t\t}\n\t\telse\n\t\t\tg.BERDecode(parameters);\n\tparameters.MessageEnd();\n\n\tSetModulusAndSubgroupGenerator(p, g);\n\tSetSubgroupOrder(q);\n}",
          "includes": [
            "#include \"nbtheory.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"gfpcrypt.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nbtheory.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"gfpcrypt.h\"\n#include \"pch.h\"\n\nDL_GroupParameters_IntegerBased {\n  void DL_GroupParameters_IntegerBased::BERDecode(BufferedTransformation &bt)\n  {\n  \tBERSequenceDecoder parameters(bt);\n  \t\tInteger p(parameters);\n  \t\tInteger q(parameters);\n  \t\tInteger g;\n  \t\tif (parameters.EndReached())\n  \t\t{\n  \t\t\tg = q;\n  \t\t\tq = ComputeGroupOrder(p) / 2;\n  \t\t}\n  \t\telse\n  \t\t\tg.BERDecode(parameters);\n  \tparameters.MessageEnd();\n  \n  \tSetModulusAndSubgroupGenerator(p, g);\n  \tSetSubgroupOrder(q);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r.BERDecode",
          "args": [
            "seq"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecode",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3146-3153",
          "snippet": "void Integer::BERDecode(BufferedTransformation &bt)\n{\n\tBERGeneralDecoder dec(bt, INTEGER);\n\tif (!dec.IsDefiniteLength() || dec.MaxRetrievable() < dec.RemainingLength())\n\t\tBERDecodeError();\n\tDecode(dec, (size_t)dec.RemainingLength(), SIGNED);\n\tdec.MessageEnd();\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  void Integer::BERDecode(BufferedTransformation &bt)\n  {\n  \tBERGeneralDecoder dec(bt, INTEGER);\n  \tif (!dec.IsDefiniteLength() || dec.MaxRetrievable() < dec.RemainingLength())\n  \t\tBERDecodeError();\n  \tDecode(dec, (size_t)dec.RemainingLength(), SIGNED);\n  \tdec.MessageEnd();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.Decode",
          "args": [
            "store",
            "signatureLen/2"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "Decode",
          "container": "PolynomialMod2",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf2n.cpp",
          "lines": "145-155",
          "snippet": "void PolynomialMod2::Decode(BufferedTransformation &bt, size_t inputLen)\n{\n\treg.CleanNew(BytesToWords(inputLen));\n\n\tfor (size_t i=inputLen; i > 0; i--)\n\t{\n\t\tbyte b;\n\t\tbt.Get(b);\n\t\treg[(i-1)/WORD_SIZE] |= word(b) << ((i-1)%WORD_SIZE)*8;\n\t}\n}",
          "includes": [
            "#include <iostream>",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"randpool.h\"",
            "#include \"words.h\"",
            "#include \"algebra.h\"",
            "#include \"gf2n.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"randpool.h\"\n#include \"words.h\"\n#include \"algebra.h\"\n#include \"gf2n.h\"\n#include \"pch.h\"\n\nPolynomialMod2 {\n  void PolynomialMod2::Decode(BufferedTransformation &bt, size_t inputLen)\n  {\n  \treg.CleanNew(BytesToWords(inputLen));\n  \n  \tfor (size_t i=inputLen; i > 0; i--)\n  \t{\n  \t\tbyte b;\n  \t\tbt.Get(b);\n  \t\treg[(i-1)/WORD_SIZE] |= word(b) << ((i-1)%WORD_SIZE)*8;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r.Decode",
          "args": [
            "store",
            "signatureLen/2"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "Decode",
          "container": "HuffmanDecoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "202-210",
          "snippet": "bool HuffmanDecoder::Decode(LowFirstBitReader &reader, value_t &value) const\n{\n\treader.FillBuffer(m_maxCodeBits);\n\tunsigned int codeBits = Decode(reader.PeekBuffer(), value);\n\tif (codeBits > reader.BitsBuffered())\n\t\treturn false;\n\treader.SkipBits(codeBits);\n\treturn true;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nHuffmanDecoder {\n  bool HuffmanDecoder::Decode(LowFirstBitReader &reader, value_t &value) const\n  {\n  \treader.FillBuffer(m_maxCodeBits);\n  \tunsigned int codeBits = Decode(reader.PeekBuffer(), value);\n  \tif (codeBits > reader.BitsBuffered())\n  \t\treturn false;\n  \treader.SkipBits(codeBits);\n  \treturn true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nbtheory.h\"\n#include \"dsa.h\"\n#include \"pch.h\"\n\nsize_t DSAConvertSignatureFormat(byte *buffer, size_t bufferSize, DSASignatureFormat toFormat, const byte *signature, size_t signatureLen, DSASignatureFormat fromFormat)\n{\n\tInteger r, s;\n\tStringStore store(signature, signatureLen);\n\tArraySink sink(buffer, bufferSize);\n\n\tswitch (fromFormat)\n\t{\n\tcase DSA_P1363:\n\t\tr.Decode(store, signatureLen/2);\n\t\ts.Decode(store, signatureLen/2);\n\t\tbreak;\n\tcase DSA_DER:\n\t{\n\t\tBERSequenceDecoder seq(store);\n\t\tr.BERDecode(seq);\n\t\ts.BERDecode(seq);\n\t\tseq.MessageEnd();\n\t\tbreak;\n\t}\n\tcase DSA_OPENPGP:\n\t\tr.OpenPGPDecode(store);\n\t\ts.OpenPGPDecode(store);\n\t\tbreak;\n\t}\n\n\tswitch (toFormat)\n\t{\n\tcase DSA_P1363:\n\t\tr.Encode(sink, bufferSize/2);\n\t\ts.Encode(sink, bufferSize/2);\n\t\tbreak;\n\tcase DSA_DER:\n\t{\n\t\tDERSequenceEncoder seq(sink);\n\t\tr.DEREncode(seq);\n\t\ts.DEREncode(seq);\n\t\tseq.MessageEnd();\n\t\tbreak;\n\t}\n\tcase DSA_OPENPGP:\n\t\tr.OpenPGPEncode(sink);\n\t\ts.OpenPGPEncode(sink);\n\t\tbreak;\n\t}\n\n\treturn (size_t)sink.TotalPutLength();\n}"
  }
]