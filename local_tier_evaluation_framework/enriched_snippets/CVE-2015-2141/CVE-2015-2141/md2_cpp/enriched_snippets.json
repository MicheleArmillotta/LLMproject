[
  {
    "function_name": "TruncatedFinal",
    "container": "MD2",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/md2.cpp",
    "lines": "102-117",
    "snippet": "void MD2::TruncatedFinal(byte *hash, size_t size)\n{\n\tThrowIfInvalidTruncatedSize(size);\n\n\tbyte padding[16];\n\tword32 padlen;\n\tunsigned int i;\n\n\tpadlen= 16-m_count;\n\tfor(i=0; i<padlen; i++) padding[i]=(byte)padlen;\n\tUpdate(padding, padlen);\n\tUpdate(m_C, 16);\n\tmemcpy(hash, m_X, size);\n\n\tInit();\n}",
    "includes": [
      "#include \"md2.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Init",
          "args": [],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "Init",
          "container": "MD2",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/md2.cpp",
          "lines": "30-36",
          "snippet": "void MD2::Init()\n{\n\tmemset(m_X, 0, 48);\n\tmemset(m_C, 0, 16);\n\tmemset(m_buf, 0, 16);\n\tm_count = 0;\n}",
          "includes": [
            "#include \"md2.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md2.h\"\n#include \"pch.h\"\n\nMD2 {\n  void MD2::Init()\n  {\n  \tmemset(m_X, 0, 48);\n  \tmemset(m_C, 0, 16);\n  \tmemset(m_buf, 0, 16);\n  \tm_count = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hash",
            "m_X",
            "size"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Update",
          "args": [
            "m_C",
            "16"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "Update",
          "container": "MD2",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/md2.cpp",
          "lines": "38-100",
          "snippet": "void MD2::Update(const byte *buf, size_t len)\n{\n\tstatic const byte S[256] = {\n\t\t41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6,\n\t\t19, 98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188,\n\t\t76, 130, 202, 30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24,\n\t\t138, 23, 229, 18, 190, 78, 196, 214, 218, 158, 222, 73, 160, 251,\n\t\t245, 142, 187, 47, 238, 122, 169, 104, 121, 145, 21, 178, 7, 63,\n\t\t148, 194, 16, 137, 11, 34, 95, 33, 128, 127, 93, 154, 90, 144, 50,\n\t\t39, 53, 62, 204, 231, 191, 247, 151, 3, 255, 25, 48, 179, 72, 165,\n\t\t181, 209, 215, 94, 146, 42, 172, 86, 170, 198, 79, 184, 56, 210,\n\t\t150, 164, 125, 182, 118, 252, 107, 226, 156, 116, 4, 241, 69, 157,\n\t\t112, 89, 100, 113, 135, 32, 134, 91, 207, 101, 230, 45, 168, 2, 27,\n\t\t96, 37, 173, 174, 176, 185, 246, 28, 70, 97, 105, 52, 64, 126, 15,\n\t\t85, 71, 163, 35, 221, 81, 175, 58, 195, 92, 249, 206, 186, 197,\n\t\t234, 38, 44, 83, 13, 110, 133, 40, 132, 9, 211, 223, 205, 244, 65,\n\t\t129, 77, 82, 106, 220, 55, 200, 108, 193, 171, 250, 36, 225, 123,\n\t\t8, 12, 189, 177, 74, 120, 136, 149, 139, 227, 99, 232, 109, 233,\n\t\t203, 213, 254, 59, 0, 29, 57, 242, 239, 183, 14, 102, 88, 208, 228,\n\t\t166, 119, 114, 248, 235, 117, 75, 10, 49, 68, 80, 180, 143, 237,\n\t\t31, 26, 219, 153, 141, 51, 159, 17, 131, 20\n\t};\n\n\twhile (len) \n    {\n\t\tunsigned int L = UnsignedMin(16U-m_count, len);\n\t\tmemcpy(m_buf+m_count, buf, L);\n\t\tm_count+=L;\n\t\tbuf+=L;\n\t\tlen-=L;\n\t\tif (m_count==16) \n\t\t{\n\t\t\tbyte t;\n\t\t\tint i,j;\n\t\t\t\n\t\t\tm_count=0;\n\t\t\tmemcpy(m_X+16, m_buf, 16);\n\t\t\tt=m_C[15];\n\t\t\tfor(i=0; i<16; i++)\n\t\t\t{\n\t\t\t\tm_X[32+i]=m_X[16+i]^m_X[i];\n\t\t\t\tt=m_C[i]^=S[m_buf[i]^t];\n\t\t\t}\n\t\t\t\n\t\t\tt=0;\n\t\t\tfor(i=0; i<18; i++)\n\t\t\t{\n\t\t\t\tfor(j=0; j<48; j+=8)\n\t\t\t\t{\n\t\t\t\t\tt=m_X[j+0]^=S[t];\n\t\t\t\t\tt=m_X[j+1]^=S[t];\n\t\t\t\t\tt=m_X[j+2]^=S[t];\n\t\t\t\t\tt=m_X[j+3]^=S[t];\n\t\t\t\t\tt=m_X[j+4]^=S[t];\n\t\t\t\t\tt=m_X[j+5]^=S[t];\n\t\t\t\t\tt=m_X[j+6]^=S[t];\n\t\t\t\t\tt=m_X[j+7]^=S[t];\n\t\t\t\t}\n\t\t\t\tt=(t+i) & 0xFF;\n\t\t\t}\n\t\t}\n    }\n}",
          "includes": [
            "#include \"md2.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md2.h\"\n#include \"pch.h\"\n\nMD2 {\n  void MD2::Update(const byte *buf, size_t len)\n  {\n  \tstatic const byte S[256] = {\n  \t\t41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6,\n  \t\t19, 98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188,\n  \t\t76, 130, 202, 30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24,\n  \t\t138, 23, 229, 18, 190, 78, 196, 214, 218, 158, 222, 73, 160, 251,\n  \t\t245, 142, 187, 47, 238, 122, 169, 104, 121, 145, 21, 178, 7, 63,\n  \t\t148, 194, 16, 137, 11, 34, 95, 33, 128, 127, 93, 154, 90, 144, 50,\n  \t\t39, 53, 62, 204, 231, 191, 247, 151, 3, 255, 25, 48, 179, 72, 165,\n  \t\t181, 209, 215, 94, 146, 42, 172, 86, 170, 198, 79, 184, 56, 210,\n  \t\t150, 164, 125, 182, 118, 252, 107, 226, 156, 116, 4, 241, 69, 157,\n  \t\t112, 89, 100, 113, 135, 32, 134, 91, 207, 101, 230, 45, 168, 2, 27,\n  \t\t96, 37, 173, 174, 176, 185, 246, 28, 70, 97, 105, 52, 64, 126, 15,\n  \t\t85, 71, 163, 35, 221, 81, 175, 58, 195, 92, 249, 206, 186, 197,\n  \t\t234, 38, 44, 83, 13, 110, 133, 40, 132, 9, 211, 223, 205, 244, 65,\n  \t\t129, 77, 82, 106, 220, 55, 200, 108, 193, 171, 250, 36, 225, 123,\n  \t\t8, 12, 189, 177, 74, 120, 136, 149, 139, 227, 99, 232, 109, 233,\n  \t\t203, 213, 254, 59, 0, 29, 57, 242, 239, 183, 14, 102, 88, 208, 228,\n  \t\t166, 119, 114, 248, 235, 117, 75, 10, 49, 68, 80, 180, 143, 237,\n  \t\t31, 26, 219, 153, 141, 51, 159, 17, 131, 20\n  \t};\n  \n  \twhile (len) \n      {\n  \t\tunsigned int L = UnsignedMin(16U-m_count, len);\n  \t\tmemcpy(m_buf+m_count, buf, L);\n  \t\tm_count+=L;\n  \t\tbuf+=L;\n  \t\tlen-=L;\n  \t\tif (m_count==16) \n  \t\t{\n  \t\t\tbyte t;\n  \t\t\tint i,j;\n  \t\t\t\n  \t\t\tm_count=0;\n  \t\t\tmemcpy(m_X+16, m_buf, 16);\n  \t\t\tt=m_C[15];\n  \t\t\tfor(i=0; i<16; i++)\n  \t\t\t{\n  \t\t\t\tm_X[32+i]=m_X[16+i]^m_X[i];\n  \t\t\t\tt=m_C[i]^=S[m_buf[i]^t];\n  \t\t\t}\n  \t\t\t\n  \t\t\tt=0;\n  \t\t\tfor(i=0; i<18; i++)\n  \t\t\t{\n  \t\t\t\tfor(j=0; j<48; j+=8)\n  \t\t\t\t{\n  \t\t\t\t\tt=m_X[j+0]^=S[t];\n  \t\t\t\t\tt=m_X[j+1]^=S[t];\n  \t\t\t\t\tt=m_X[j+2]^=S[t];\n  \t\t\t\t\tt=m_X[j+3]^=S[t];\n  \t\t\t\t\tt=m_X[j+4]^=S[t];\n  \t\t\t\t\tt=m_X[j+5]^=S[t];\n  \t\t\t\t\tt=m_X[j+6]^=S[t];\n  \t\t\t\t\tt=m_X[j+7]^=S[t];\n  \t\t\t\t}\n  \t\t\t\tt=(t+i) & 0xFF;\n  \t\t\t}\n  \t\t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThrowIfInvalidTruncatedSize",
          "args": [
            "size"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "ThrowIfInvalidTruncatedSize",
          "container": "HashTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "309-313",
          "snippet": "void HashTransformation::ThrowIfInvalidTruncatedSize(size_t size) const\n{\n\tif (size > DigestSize())\n\t\tthrow InvalidArgument(\"HashTransformation: can't truncate a \" + IntToString(DigestSize()) + \" byte digest to \" + IntToString(size) + \" bytes\");\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nHashTransformation {\n  void HashTransformation::ThrowIfInvalidTruncatedSize(size_t size) const\n  {\n  \tif (size > DigestSize())\n  \t\tthrow InvalidArgument(\"HashTransformation: can't truncate a \" + IntToString(DigestSize()) + \" byte digest to \" + IntToString(size) + \" bytes\");\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"md2.h\"\n#include \"pch.h\"\n\nMD2 {\n  void MD2::TruncatedFinal(byte *hash, size_t size)\n  {\n  \tThrowIfInvalidTruncatedSize(size);\n  \n  \tbyte padding[16];\n  \tword32 padlen;\n  \tunsigned int i;\n  \n  \tpadlen= 16-m_count;\n  \tfor(i=0; i<padlen; i++) padding[i]=(byte)padlen;\n  \tUpdate(padding, padlen);\n  \tUpdate(m_C, 16);\n  \tmemcpy(hash, m_X, size);\n  \n  \tInit();\n  }\n}"
  },
  {
    "function_name": "Update",
    "container": "MD2",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/md2.cpp",
    "lines": "38-100",
    "snippet": "void MD2::Update(const byte *buf, size_t len)\n{\n\tstatic const byte S[256] = {\n\t\t41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6,\n\t\t19, 98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188,\n\t\t76, 130, 202, 30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24,\n\t\t138, 23, 229, 18, 190, 78, 196, 214, 218, 158, 222, 73, 160, 251,\n\t\t245, 142, 187, 47, 238, 122, 169, 104, 121, 145, 21, 178, 7, 63,\n\t\t148, 194, 16, 137, 11, 34, 95, 33, 128, 127, 93, 154, 90, 144, 50,\n\t\t39, 53, 62, 204, 231, 191, 247, 151, 3, 255, 25, 48, 179, 72, 165,\n\t\t181, 209, 215, 94, 146, 42, 172, 86, 170, 198, 79, 184, 56, 210,\n\t\t150, 164, 125, 182, 118, 252, 107, 226, 156, 116, 4, 241, 69, 157,\n\t\t112, 89, 100, 113, 135, 32, 134, 91, 207, 101, 230, 45, 168, 2, 27,\n\t\t96, 37, 173, 174, 176, 185, 246, 28, 70, 97, 105, 52, 64, 126, 15,\n\t\t85, 71, 163, 35, 221, 81, 175, 58, 195, 92, 249, 206, 186, 197,\n\t\t234, 38, 44, 83, 13, 110, 133, 40, 132, 9, 211, 223, 205, 244, 65,\n\t\t129, 77, 82, 106, 220, 55, 200, 108, 193, 171, 250, 36, 225, 123,\n\t\t8, 12, 189, 177, 74, 120, 136, 149, 139, 227, 99, 232, 109, 233,\n\t\t203, 213, 254, 59, 0, 29, 57, 242, 239, 183, 14, 102, 88, 208, 228,\n\t\t166, 119, 114, 248, 235, 117, 75, 10, 49, 68, 80, 180, 143, 237,\n\t\t31, 26, 219, 153, 141, 51, 159, 17, 131, 20\n\t};\n\n\twhile (len) \n    {\n\t\tunsigned int L = UnsignedMin(16U-m_count, len);\n\t\tmemcpy(m_buf+m_count, buf, L);\n\t\tm_count+=L;\n\t\tbuf+=L;\n\t\tlen-=L;\n\t\tif (m_count==16) \n\t\t{\n\t\t\tbyte t;\n\t\t\tint i,j;\n\t\t\t\n\t\t\tm_count=0;\n\t\t\tmemcpy(m_X+16, m_buf, 16);\n\t\t\tt=m_C[15];\n\t\t\tfor(i=0; i<16; i++)\n\t\t\t{\n\t\t\t\tm_X[32+i]=m_X[16+i]^m_X[i];\n\t\t\t\tt=m_C[i]^=S[m_buf[i]^t];\n\t\t\t}\n\t\t\t\n\t\t\tt=0;\n\t\t\tfor(i=0; i<18; i++)\n\t\t\t{\n\t\t\t\tfor(j=0; j<48; j+=8)\n\t\t\t\t{\n\t\t\t\t\tt=m_X[j+0]^=S[t];\n\t\t\t\t\tt=m_X[j+1]^=S[t];\n\t\t\t\t\tt=m_X[j+2]^=S[t];\n\t\t\t\t\tt=m_X[j+3]^=S[t];\n\t\t\t\t\tt=m_X[j+4]^=S[t];\n\t\t\t\t\tt=m_X[j+5]^=S[t];\n\t\t\t\t\tt=m_X[j+6]^=S[t];\n\t\t\t\t\tt=m_X[j+7]^=S[t];\n\t\t\t\t}\n\t\t\t\tt=(t+i) & 0xFF;\n\t\t\t}\n\t\t}\n    }\n}",
    "includes": [
      "#include \"md2.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_X+16",
            "m_buf",
            "16"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_buf+m_count",
            "buf",
            "L"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "16U-m_count",
            "len"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"md2.h\"\n#include \"pch.h\"\n\nMD2 {\n  void MD2::Update(const byte *buf, size_t len)\n  {\n  \tstatic const byte S[256] = {\n  \t\t41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6,\n  \t\t19, 98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188,\n  \t\t76, 130, 202, 30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24,\n  \t\t138, 23, 229, 18, 190, 78, 196, 214, 218, 158, 222, 73, 160, 251,\n  \t\t245, 142, 187, 47, 238, 122, 169, 104, 121, 145, 21, 178, 7, 63,\n  \t\t148, 194, 16, 137, 11, 34, 95, 33, 128, 127, 93, 154, 90, 144, 50,\n  \t\t39, 53, 62, 204, 231, 191, 247, 151, 3, 255, 25, 48, 179, 72, 165,\n  \t\t181, 209, 215, 94, 146, 42, 172, 86, 170, 198, 79, 184, 56, 210,\n  \t\t150, 164, 125, 182, 118, 252, 107, 226, 156, 116, 4, 241, 69, 157,\n  \t\t112, 89, 100, 113, 135, 32, 134, 91, 207, 101, 230, 45, 168, 2, 27,\n  \t\t96, 37, 173, 174, 176, 185, 246, 28, 70, 97, 105, 52, 64, 126, 15,\n  \t\t85, 71, 163, 35, 221, 81, 175, 58, 195, 92, 249, 206, 186, 197,\n  \t\t234, 38, 44, 83, 13, 110, 133, 40, 132, 9, 211, 223, 205, 244, 65,\n  \t\t129, 77, 82, 106, 220, 55, 200, 108, 193, 171, 250, 36, 225, 123,\n  \t\t8, 12, 189, 177, 74, 120, 136, 149, 139, 227, 99, 232, 109, 233,\n  \t\t203, 213, 254, 59, 0, 29, 57, 242, 239, 183, 14, 102, 88, 208, 228,\n  \t\t166, 119, 114, 248, 235, 117, 75, 10, 49, 68, 80, 180, 143, 237,\n  \t\t31, 26, 219, 153, 141, 51, 159, 17, 131, 20\n  \t};\n  \n  \twhile (len) \n      {\n  \t\tunsigned int L = UnsignedMin(16U-m_count, len);\n  \t\tmemcpy(m_buf+m_count, buf, L);\n  \t\tm_count+=L;\n  \t\tbuf+=L;\n  \t\tlen-=L;\n  \t\tif (m_count==16) \n  \t\t{\n  \t\t\tbyte t;\n  \t\t\tint i,j;\n  \t\t\t\n  \t\t\tm_count=0;\n  \t\t\tmemcpy(m_X+16, m_buf, 16);\n  \t\t\tt=m_C[15];\n  \t\t\tfor(i=0; i<16; i++)\n  \t\t\t{\n  \t\t\t\tm_X[32+i]=m_X[16+i]^m_X[i];\n  \t\t\t\tt=m_C[i]^=S[m_buf[i]^t];\n  \t\t\t}\n  \t\t\t\n  \t\t\tt=0;\n  \t\t\tfor(i=0; i<18; i++)\n  \t\t\t{\n  \t\t\t\tfor(j=0; j<48; j+=8)\n  \t\t\t\t{\n  \t\t\t\t\tt=m_X[j+0]^=S[t];\n  \t\t\t\t\tt=m_X[j+1]^=S[t];\n  \t\t\t\t\tt=m_X[j+2]^=S[t];\n  \t\t\t\t\tt=m_X[j+3]^=S[t];\n  \t\t\t\t\tt=m_X[j+4]^=S[t];\n  \t\t\t\t\tt=m_X[j+5]^=S[t];\n  \t\t\t\t\tt=m_X[j+6]^=S[t];\n  \t\t\t\t\tt=m_X[j+7]^=S[t];\n  \t\t\t\t}\n  \t\t\t\tt=(t+i) & 0xFF;\n  \t\t\t}\n  \t\t}\n      }\n  }\n}"
  },
  {
    "function_name": "Init",
    "container": "MD2",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/md2.cpp",
    "lines": "30-36",
    "snippet": "void MD2::Init()\n{\n\tmemset(m_X, 0, 48);\n\tmemset(m_C, 0, 16);\n\tmemset(m_buf, 0, 16);\n\tm_count = 0;\n}",
    "includes": [
      "#include \"md2.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "m_buf",
            "0",
            "16"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "m_C",
            "0",
            "16"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "m_X",
            "0",
            "48"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"md2.h\"\n#include \"pch.h\"\n\nMD2 {\n  void MD2::Init()\n  {\n  \tmemset(m_X, 0, 48);\n  \tmemset(m_C, 0, 16);\n  \tmemset(m_buf, 0, 16);\n  \tm_count = 0;\n  }\n}"
  },
  {
    "function_name": "MD2",
    "container": "MD2",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/md2.cpp",
    "lines": "24-28",
    "snippet": "MD2::MD2()\n\t: m_X(48), m_C(16), m_buf(16)\n{\n\tInit();\n}",
    "includes": [
      "#include \"md2.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Init",
          "args": [],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "Init",
          "container": "MD2",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/md2.cpp",
          "lines": "30-36",
          "snippet": "void MD2::Init()\n{\n\tmemset(m_X, 0, 48);\n\tmemset(m_C, 0, 16);\n\tmemset(m_buf, 0, 16);\n\tm_count = 0;\n}",
          "includes": [
            "#include \"md2.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md2.h\"\n#include \"pch.h\"\n\nMD2 {\n  void MD2::Init()\n  {\n  \tmemset(m_X, 0, 48);\n  \tmemset(m_C, 0, 16);\n  \tmemset(m_buf, 0, 16);\n  \tm_count = 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"md2.h\"\n#include \"pch.h\"\n\nMD2 {\n  MD2::MD2()\n  \t: m_X(48), m_C(16), m_buf(16)\n  {\n  \tInit();\n  }\n}"
  }
]