[
  {
    "function_name": "HashBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.h",
    "lines": "44-44",
    "snippet": "void HashBlock(const HashWordType *input) {HashMultipleBlocks(input, this->BlockSize());}",
    "includes": [
      "#include \"simple.h\"",
      "#include \"misc.h\"",
      "#include \"secblock.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HashMultipleBlocks",
          "args": [
            "input",
            "this->BlockSize()"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "HashMultipleBlocks",
          "container": "IteratedHashBase<T, BASE>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
          "lines": "81-101",
          "snippet": "size_t IteratedHashBase<T, BASE>::HashMultipleBlocks(const T *input, size_t length)\n{\n\tunsigned int blockSize = this->BlockSize();\n\tbool noReverse = NativeByteOrderIs(this->GetByteOrder());\n\tT* dataBuf = this->DataBuf();\n\tdo\n\t{\n\t\tif (noReverse)\n\t\t\tthis->HashEndianCorrectedBlock(input);\n\t\telse\n\t\t{\n\t\t\tByteReverse(dataBuf, input, this->BlockSize());\n\t\t\tthis->HashEndianCorrectedBlock(dataBuf);\n\t\t}\n\n\t\tinput += blockSize/sizeof(T);\n\t\tlength -= blockSize;\n\t}\n\twhile (length >= blockSize);\n\treturn length;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nIteratedHashBase<T, BASE> {\n  size_t IteratedHashBase<T, BASE>::HashMultipleBlocks(const T *input, size_t length)\n  {\n  \tunsigned int blockSize = this->BlockSize();\n  \tbool noReverse = NativeByteOrderIs(this->GetByteOrder());\n  \tT* dataBuf = this->DataBuf();\n  \tdo\n  \t{\n  \t\tif (noReverse)\n  \t\t\tthis->HashEndianCorrectedBlock(input);\n  \t\telse\n  \t\t{\n  \t\t\tByteReverse(dataBuf, input, this->BlockSize());\n  \t\t\tthis->HashEndianCorrectedBlock(dataBuf);\n  \t\t}\n  \n  \t\tinput += blockSize/sizeof(T);\n  \t\tlength -= blockSize;\n  \t}\n  \twhile (length >= blockSize);\n  \treturn length;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->BlockSize",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      }
    ],
    "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nvoid HashBlock(const HashWordType *input) {HashMultipleBlocks(input, this->BlockSize());}"
  },
  {
    "function_name": "GetBitCountLo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.h",
    "lines": "36-36",
    "snippet": "inline T GetBitCountLo() const {return m_countLo << 3;}",
    "includes": [
      "#include \"simple.h\"",
      "#include \"misc.h\"",
      "#include \"secblock.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\ninline T GetBitCountLo() const {return m_countLo << 3;}"
  }
]