[
  {
    "function_name": "Put2",
    "container": "FileSink",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
    "lines": "233-255",
    "snippet": "size_t FileSink::Put2(const byte *inString, size_t length, int messageEnd, bool blocking)\n{\n\tif (!m_stream)\n\t\tthrow Err(\"FileSink: output stream not opened\");\n\n\twhile (length > 0)\n\t{\n\t\tstd::streamsize size;\n\t\tif (!SafeConvert(length, size))\n\t\t\tsize = numeric_limits<std::streamsize>::max();\n\t\tm_stream->write((const char *)inString, size);\n\t\tinString += size;\n\t\tlength -= (size_t)size;\n\t}\n\n\tif (messageEnd)\n\t\tm_stream->flush();\n\n\tif (!m_stream->good())\n\t\tthrow WriteErr();\n\n\treturn 0;\n}",
    "includes": [
      "#include <limits>",
      "#include \"files.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WriteErr",
          "args": [],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "WriteErr",
          "container": "WriteErr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.h",
          "lines": "86-86",
          "snippet": "WriteErr() : Err(\"FileSink: error writing file\") {}",
          "includes": [
            "#include <fstream>",
            "#include <iostream>",
            "#include \"argnames.h\"",
            "#include \"filters.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <iostream>\n#include \"argnames.h\"\n#include \"filters.h\"\n#include \"cryptlib.h\"\n\nWriteErr {\n  WriteErr() : Err(\"FileSink: error writing file\") {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_stream->good",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->flush",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->write",
          "args": [
            "(const char *)inString",
            "size"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numeric_limits<std::streamsize>::max",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SafeConvert",
          "args": [
            "length",
            "size"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "SafeConvert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "299-305",
          "snippet": "inline bool SafeConvert(T1 from, T2 &to)\n{\n\tto = (T2)from;\n\tif (from != to || (from > 0) != (to > 0))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool SafeConvert(T1 from, T2 &to)\n{\n\tto = (T2)from;\n\tif (from != to || (from > 0) != (to > 0))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Err",
          "args": [
            "\"FileSink: output stream not opened\""
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "OpenErr",
          "container": "OpenErr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.h",
          "lines": "85-85",
          "snippet": "OpenErr(const std::string &filename) : Err(\"FileSink: error opening file for writing: \" + filename) {}",
          "includes": [
            "#include <fstream>",
            "#include <iostream>",
            "#include \"argnames.h\"",
            "#include \"filters.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <iostream>\n#include \"argnames.h\"\n#include \"filters.h\"\n#include \"cryptlib.h\"\n\nOpenErr {\n  OpenErr(const std::string &filename) : Err(\"FileSink: error opening file for writing: \" + filename) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileSink {\n  size_t FileSink::Put2(const byte *inString, size_t length, int messageEnd, bool blocking)\n  {\n  \tif (!m_stream)\n  \t\tthrow Err(\"FileSink: output stream not opened\");\n  \n  \twhile (length > 0)\n  \t{\n  \t\tstd::streamsize size;\n  \t\tif (!SafeConvert(length, size))\n  \t\t\tsize = numeric_limits<std::streamsize>::max();\n  \t\tm_stream->write((const char *)inString, size);\n  \t\tinString += size;\n  \t\tlength -= (size_t)size;\n  \t}\n  \n  \tif (messageEnd)\n  \t\tm_stream->flush();\n  \n  \tif (!m_stream->good())\n  \t\tthrow WriteErr();\n  \n  \treturn 0;\n  }\n}"
  },
  {
    "function_name": "IsolatedFlush",
    "container": "FileSink",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
    "lines": "221-231",
    "snippet": "bool FileSink::IsolatedFlush(bool hardFlush, bool blocking)\n{\n\tif (!m_stream)\n\t\tthrow Err(\"FileSink: output stream not opened\");\n\n\tm_stream->flush();\n\tif (!m_stream->good())\n\t\tthrow WriteErr();\n\n\treturn false;\n}",
    "includes": [
      "#include <limits>",
      "#include \"files.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WriteErr",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "WriteErr",
          "container": "WriteErr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.h",
          "lines": "86-86",
          "snippet": "WriteErr() : Err(\"FileSink: error writing file\") {}",
          "includes": [
            "#include <fstream>",
            "#include <iostream>",
            "#include \"argnames.h\"",
            "#include \"filters.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <iostream>\n#include \"argnames.h\"\n#include \"filters.h\"\n#include \"cryptlib.h\"\n\nWriteErr {\n  WriteErr() : Err(\"FileSink: error writing file\") {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_stream->good",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->flush",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Err",
          "args": [
            "\"FileSink: output stream not opened\""
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "OpenErr",
          "container": "OpenErr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.h",
          "lines": "85-85",
          "snippet": "OpenErr(const std::string &filename) : Err(\"FileSink: error opening file for writing: \" + filename) {}",
          "includes": [
            "#include <fstream>",
            "#include <iostream>",
            "#include \"argnames.h\"",
            "#include \"filters.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <iostream>\n#include \"argnames.h\"\n#include \"filters.h\"\n#include \"cryptlib.h\"\n\nOpenErr {\n  OpenErr(const std::string &filename) : Err(\"FileSink: error opening file for writing: \" + filename) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileSink {\n  bool FileSink::IsolatedFlush(bool hardFlush, bool blocking)\n  {\n  \tif (!m_stream)\n  \t\tthrow Err(\"FileSink: output stream not opened\");\n  \n  \tm_stream->flush();\n  \tif (!m_stream->good())\n  \t\tthrow WriteErr();\n  \n  \treturn false;\n  }\n}"
  },
  {
    "function_name": "IsolatedInitialize",
    "container": "FileSink",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
    "lines": "181-219",
    "snippet": "void FileSink::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tm_stream = NULL;\n\tm_file.release();\n\n\tconst char *fileName = NULL;\n#if defined(CRYPTOPP_UNIX_AVAILABLE) || _MSC_VER >= 1400\n\tconst wchar_t *fileNameWide = NULL;\n\tif (!parameters.GetValue(Name::OutputFileNameWide(), fileNameWide))\n#endif\n\t\tif (!parameters.GetValue(Name::OutputFileName(), fileName))\n\t\t{\n\t\t\tparameters.GetValue(Name::OutputStreamPointer(), m_stream);\n\t\t\treturn;\n\t\t}\n\n\tios::openmode binary = parameters.GetValueWithDefault(Name::OutputBinaryMode(), true) ? ios::binary : ios::openmode(0);\n\tm_file.reset(new std::ofstream);\n#ifdef CRYPTOPP_UNIX_AVAILABLE\n\tstd::string narrowed;\n\tif (fileNameWide)\n\t\tfileName = (narrowed = StringNarrow(fileNameWide)).c_str();\n#endif\n#if _MSC_VER >= 1400\n\tif (fileNameWide)\n\t{\n\t\tm_file->open(fileNameWide, ios::out | ios::trunc | binary);\n\t\tif (!*m_file)\n\t\t\tthrow OpenErr(StringNarrow(fileNameWide, false));\n\t}\n#endif\n\tif (fileName)\n\t{\n\t\tm_file->open(fileName, ios::out | ios::trunc | binary);\n\t\tif (!*m_file)\n\t\t\tthrow OpenErr(fileName);\n\t}\n\tm_stream = m_file.get();\n}",
    "includes": [
      "#include <limits>",
      "#include \"files.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_file.get",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OpenErr",
          "args": [
            "fileName"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "OpenErr",
          "container": "OpenErr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.h",
          "lines": "85-85",
          "snippet": "OpenErr(const std::string &filename) : Err(\"FileSink: error opening file for writing: \" + filename) {}",
          "includes": [
            "#include <fstream>",
            "#include <iostream>",
            "#include \"argnames.h\"",
            "#include \"filters.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <iostream>\n#include \"argnames.h\"\n#include \"filters.h\"\n#include \"cryptlib.h\"\n\nOpenErr {\n  OpenErr(const std::string &filename) : Err(\"FileSink: error opening file for writing: \" + filename) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_file->open",
          "args": [
            "fileName",
            "ios::out | ios::trunc | binary"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringNarrow",
          "args": [
            "fileNameWide",
            "false"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_file->open",
          "args": [
            "fileNameWide",
            "ios::out | ios::trunc | binary"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringNarrow",
          "args": [
            "fileNameWide"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "StringNarrow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "548-568",
          "snippet": "static std::string StringNarrow(const wchar_t *str, bool throwOnError = true)\n{\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable: 4996)\t//  'wcstombs': This function or variable may be unsafe.\n#endif\n\tsize_t size = wcstombs(NULL, str, 0);\n\tif (size == size_t(0)-1)\n\t{\n\t\tif (throwOnError)\n\t\t\tthrow InvalidArgument(\"StringNarrow: wcstombs() call failed\");\n\t\telse\n\t\t\treturn std::string();\n\t}\n\tstd::string result(size, 0);\n\twcstombs(&result[0], str, size);\n\treturn result;\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstatic std::string StringNarrow(const wchar_t *str, bool throwOnError = true)\n{\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable: 4996)\t//  'wcstombs': This function or variable may be unsafe.\n#endif\n\tsize_t size = wcstombs(NULL, str, 0);\n\tif (size == size_t(0)-1)\n\t{\n\t\tif (throwOnError)\n\t\t\tthrow InvalidArgument(\"StringNarrow: wcstombs() call failed\");\n\t\telse\n\t\t\treturn std::string();\n\t}\n\tstd::string result(size, 0);\n\twcstombs(&result[0], str, size);\n\treturn result;\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_file.reset",
          "args": [
            "new std::ofstream"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "reset",
          "container": "member_ptr<T>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "50-50",
          "snippet": "void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nmember_ptr<T> {\n  void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ios::openmode",
          "args": [
            "0"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parameters.GetValueWithDefault",
          "args": [
            "Name::OutputBinaryMode()",
            "true"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Name::OutputBinaryMode",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parameters.GetValue",
          "args": [
            "Name::OutputStreamPointer()",
            "m_stream"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Name::OutputStreamPointer",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parameters.GetValue",
          "args": [
            "Name::OutputFileName()",
            "fileName"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Name::OutputFileName",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parameters.GetValue",
          "args": [
            "Name::OutputFileNameWide()",
            "fileNameWide"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Name::OutputFileNameWide",
          "args": [],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_file.release",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileSink {\n  void FileSink::IsolatedInitialize(const NameValuePairs &parameters)\n  {\n  \tm_stream = NULL;\n  \tm_file.release();\n  \n  \tconst char *fileName = NULL;\n  #if defined(CRYPTOPP_UNIX_AVAILABLE) || _MSC_VER >= 1400\n  \tconst wchar_t *fileNameWide = NULL;\n  \tif (!parameters.GetValue(Name::OutputFileNameWide(), fileNameWide))\n  #endif\n  \t\tif (!parameters.GetValue(Name::OutputFileName(), fileName))\n  \t\t{\n  \t\t\tparameters.GetValue(Name::OutputStreamPointer(), m_stream);\n  \t\t\treturn;\n  \t\t}\n  \n  \tios::openmode binary = parameters.GetValueWithDefault(Name::OutputBinaryMode(), true) ? ios::binary : ios::openmode(0);\n  \tm_file.reset(new std::ofstream);\n  #ifdef CRYPTOPP_UNIX_AVAILABLE\n  \tstd::string narrowed;\n  \tif (fileNameWide)\n  \t\tfileName = (narrowed = StringNarrow(fileNameWide)).c_str();\n  #endif\n  #if _MSC_VER >= 1400\n  \tif (fileNameWide)\n  \t{\n  \t\tm_file->open(fileNameWide, ios::out | ios::trunc | binary);\n  \t\tif (!*m_file)\n  \t\t\tthrow OpenErr(StringNarrow(fileNameWide, false));\n  \t}\n  #endif\n  \tif (fileName)\n  \t{\n  \t\tm_file->open(fileName, ios::out | ios::trunc | binary);\n  \t\tif (!*m_file)\n  \t\t\tthrow OpenErr(fileName);\n  \t}\n  \tm_stream = m_file.get();\n  }\n}"
  },
  {
    "function_name": "Skip",
    "container": "FileStore",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
    "lines": "168-179",
    "snippet": "lword FileStore::Skip(lword skipMax)\n{\n\tif (!m_stream)\n\t\treturn 0;\n\n\tlword oldPos = m_stream->tellg();\n\tstd::istream::off_type offset;\n\tif (!SafeConvert(skipMax, offset))\n\t\tthrow InvalidArgument(\"FileStore: maximum seek offset exceeded\");\n\tm_stream->seekg(offset, ios::cur);\n\treturn (lword)m_stream->tellg() - oldPos;\n}",
    "includes": [
      "#include <limits>",
      "#include \"files.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_stream->tellg",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->seekg",
          "args": [
            "offset",
            "ios::cur"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"FileStore: maximum seek offset exceeded\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SafeConvert",
          "args": [
            "skipMax",
            "offset"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "SafeConvert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "299-305",
          "snippet": "inline bool SafeConvert(T1 from, T2 &to)\n{\n\tto = (T2)from;\n\tif (from != to || (from > 0) != (to > 0))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool SafeConvert(T1 from, T2 &to)\n{\n\tto = (T2)from;\n\tif (from != to || (from > 0) != (to > 0))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_stream->tellg",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  lword FileStore::Skip(lword skipMax)\n  {\n  \tif (!m_stream)\n  \t\treturn 0;\n  \n  \tlword oldPos = m_stream->tellg();\n  \tstd::istream::off_type offset;\n  \tif (!SafeConvert(skipMax, offset))\n  \t\tthrow InvalidArgument(\"FileStore: maximum seek offset exceeded\");\n  \tm_stream->seekg(offset, ios::cur);\n  \treturn (lword)m_stream->tellg() - oldPos;\n  }\n}"
  },
  {
    "function_name": "CopyRangeTo2",
    "container": "FileStore",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
    "lines": "115-166",
    "snippet": "size_t FileStore::CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end, const std::string &channel, bool blocking) const\n{\n\tif (!m_stream)\n\t\treturn 0;\n\n\tif (begin == 0 && end == 1)\n\t{\n\t\tint result = m_stream->peek();\n\t\tif (result == char_traits<char>::eof())\n\t\t\treturn 0;\n\t\telse\n\t\t{\n\t\t\tsize_t blockedBytes = target.ChannelPut(channel, byte(result), blocking);\n\t\t\tbegin += 1-blockedBytes;\n\t\t\treturn blockedBytes;\n\t\t}\n\t}\n\n\t// TODO: figure out what happens on cin\n\tstreampos current = m_stream->tellg();\n\tstreampos endPosition = m_stream->seekg(0, ios::end).tellg();\n\tstreampos newPosition = current + (streamoff)begin;\n\n\tif (newPosition >= endPosition)\n\t{\n\t\tm_stream->seekg(current);\n\t\treturn 0;\t// don't try to seek beyond the end of file\n\t}\n\tm_stream->seekg(newPosition);\n\ttry\n\t{\n\t\tassert(!m_waiting);\n\t\tlword copyMax = end-begin;\n\t\tsize_t blockedBytes = const_cast<FileStore *>(this)->TransferTo2(target, copyMax, channel, blocking);\n\t\tbegin += copyMax;\n\t\tif (blockedBytes)\n\t\t{\n\t\t\tconst_cast<FileStore *>(this)->m_waiting = false;\n\t\t\treturn blockedBytes;\n\t\t}\n\t}\n\tcatch(...)\n\t{\n\t\tm_stream->clear();\n\t\tm_stream->seekg(current);\n\t\tthrow;\n\t}\n\tm_stream->clear();\n\tm_stream->seekg(current);\n\n\treturn 0;\n}",
    "includes": [
      "#include <limits>",
      "#include \"files.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_stream->seekg",
          "args": [
            "current"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->clear",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->seekg",
          "args": [
            "current"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->clear",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<FileStore *>",
          "args": [
            "this"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<FileStore *>",
          "args": [
            "target",
            "copyMax",
            "channel",
            "blocking"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<FileStore *>",
          "args": [
            "this"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!m_waiting"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->seekg",
          "args": [
            "newPosition"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->seekg",
          "args": [
            "current"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->seekg",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->seekg",
          "args": [
            "0",
            "ios::end"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->tellg",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.ChannelPut",
          "args": [
            "channel",
            "byte(result)",
            "blocking"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "ChannelPut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "975-976",
          "snippet": "size_t ChannelPut(const std::string &channel, const byte *inString, size_t length, bool blocking=true)\n\t\t\t{return ChannelPut2(channel, inString, length, 0, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nsize_t ChannelPut(const std::string &channel, const byte *inString, size_t length, bool blocking=true)\n\t\t\t{return ChannelPut2(channel, inString, length, 0, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "byte",
          "args": [
            "result"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "char_traits<char>::eof",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->peek",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  size_t FileStore::CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end, const std::string &channel, bool blocking) const\n  {\n  \tif (!m_stream)\n  \t\treturn 0;\n  \n  \tif (begin == 0 && end == 1)\n  \t{\n  \t\tint result = m_stream->peek();\n  \t\tif (result == char_traits<char>::eof())\n  \t\t\treturn 0;\n  \t\telse\n  \t\t{\n  \t\t\tsize_t blockedBytes = target.ChannelPut(channel, byte(result), blocking);\n  \t\t\tbegin += 1-blockedBytes;\n  \t\t\treturn blockedBytes;\n  \t\t}\n  \t}\n  \n  \t// TODO: figure out what happens on cin\n  \tstreampos current = m_stream->tellg();\n  \tstreampos endPosition = m_stream->seekg(0, ios::end).tellg();\n  \tstreampos newPosition = current + (streamoff)begin;\n  \n  \tif (newPosition >= endPosition)\n  \t{\n  \t\tm_stream->seekg(current);\n  \t\treturn 0;\t// don't try to seek beyond the end of file\n  \t}\n  \tm_stream->seekg(newPosition);\n  \ttry\n  \t{\n  \t\tassert(!m_waiting);\n  \t\tlword copyMax = end-begin;\n  \t\tsize_t blockedBytes = const_cast<FileStore *>(this)->TransferTo2(target, copyMax, channel, blocking);\n  \t\tbegin += copyMax;\n  \t\tif (blockedBytes)\n  \t\t{\n  \t\t\tconst_cast<FileStore *>(this)->m_waiting = false;\n  \t\t\treturn blockedBytes;\n  \t\t}\n  \t}\n  \tcatch(...)\n  \t{\n  \t\tm_stream->clear();\n  \t\tm_stream->seekg(current);\n  \t\tthrow;\n  \t}\n  \tm_stream->clear();\n  \tm_stream->seekg(current);\n  \n  \treturn 0;\n  }\n}"
  },
  {
    "function_name": "TransferTo2",
    "container": "FileStore",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
    "lines": "76-113",
    "snippet": "size_t FileStore::TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel, bool blocking)\n{\n\tif (!m_stream)\n\t{\n\t\ttransferBytes = 0;\n\t\treturn 0;\n\t}\n\n\tlword size=transferBytes;\n\ttransferBytes = 0;\n\n\tif (m_waiting)\n\t\tgoto output;\n\n\twhile (size && m_stream->good())\n\t{\n\t\t{\n\t\tsize_t spaceSize = 1024;\n\t\tm_space = HelpCreatePutSpace(target, channel, 1, UnsignedMin(size_t(0)-1, size), spaceSize);\n\n\t\tm_stream->read((char *)m_space, (unsigned int)STDMIN(size, (lword)spaceSize));\n\t\t}\n\t\tm_len = (size_t)m_stream->gcount();\n\t\tsize_t blockedBytes;\noutput:\n\t\tblockedBytes = target.ChannelPutModifiable2(channel, m_space, m_len, 0, blocking);\n\t\tm_waiting = blockedBytes > 0;\n\t\tif (m_waiting)\n\t\t\treturn blockedBytes;\n\t\tsize -= m_len;\n\t\ttransferBytes += m_len;\n\t}\n\n\tif (!m_stream->good() && !m_stream->eof())\n\t\tthrow ReadErr();\n\n\treturn 0;\n}",
    "includes": [
      "#include <limits>",
      "#include \"files.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReadErr",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "ReadErr",
          "container": "ReadErr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.h",
          "lines": "23-23",
          "snippet": "ReadErr() : Err(\"FileStore: error reading file\") {}",
          "includes": [
            "#include <fstream>",
            "#include <iostream>",
            "#include \"argnames.h\"",
            "#include \"filters.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <iostream>\n#include \"argnames.h\"\n#include \"filters.h\"\n#include \"cryptlib.h\"\n\nReadErr {\n  ReadErr() : Err(\"FileStore: error reading file\") {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_stream->eof",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->good",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.ChannelPutModifiable2",
          "args": [
            "channel",
            "m_space",
            "m_len",
            "0",
            "blocking"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "ChannelPutModifiable2",
          "container": "ChannelSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/channels.cpp",
          "lines": "242-257",
          "snippet": "size_t ChannelSwitch::ChannelPutModifiable2(const std::string &channel, byte *inString, size_t length, int messageEnd, bool blocking)\n{\n\tChannelRouteIterator it(*this);\n\tit.Reset(channel);\n\n\tif (!it.End())\n\t{\n\t\tBufferedTransformation &target = it.Destination();\n\t\tconst std::string &targetChannel = it.Channel();\n\t\tit.Next();\n\t\tif (it.End())\t// there is only one target channel\n\t\t\treturn target.ChannelPutModifiable2(targetChannel, inString, length, messageEnd, blocking);\n\t}\n\n\treturn ChannelPut2(channel, inString, length, messageEnd, blocking);\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"pch.h\"\n\nChannelSwitch {\n  size_t ChannelSwitch::ChannelPutModifiable2(const std::string &channel, byte *inString, size_t length, int messageEnd, bool blocking)\n  {\n  \tChannelRouteIterator it(*this);\n  \tit.Reset(channel);\n  \n  \tif (!it.End())\n  \t{\n  \t\tBufferedTransformation &target = it.Destination();\n  \t\tconst std::string &targetChannel = it.Channel();\n  \t\tit.Next();\n  \t\tif (it.End())\t// there is only one target channel\n  \t\t\treturn target.ChannelPutModifiable2(targetChannel, inString, length, messageEnd, blocking);\n  \t}\n  \n  \treturn ChannelPut2(channel, inString, length, messageEnd, blocking);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_stream->gcount",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->read",
          "args": [
            "(char *)m_space",
            "(unsigned int)STDMIN(size, (lword)spaceSize)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "size",
            "(lword)spaceSize"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HelpCreatePutSpace",
          "args": [
            "target",
            "channel",
            "1",
            "UnsignedMin(size_t(0)-1, size)",
            "spaceSize"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "size_t(0)-1",
            "size"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "0"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->good",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  size_t FileStore::TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel, bool blocking)\n  {\n  \tif (!m_stream)\n  \t{\n  \t\ttransferBytes = 0;\n  \t\treturn 0;\n  \t}\n  \n  \tlword size=transferBytes;\n  \ttransferBytes = 0;\n  \n  \tif (m_waiting)\n  \t\tgoto output;\n  \n  \twhile (size && m_stream->good())\n  \t{\n  \t\t{\n  \t\tsize_t spaceSize = 1024;\n  \t\tm_space = HelpCreatePutSpace(target, channel, 1, UnsignedMin(size_t(0)-1, size), spaceSize);\n  \n  \t\tm_stream->read((char *)m_space, (unsigned int)STDMIN(size, (lword)spaceSize));\n  \t\t}\n  \t\tm_len = (size_t)m_stream->gcount();\n  \t\tsize_t blockedBytes;\n  output:\n  \t\tblockedBytes = target.ChannelPutModifiable2(channel, m_space, m_len, 0, blocking);\n  \t\tm_waiting = blockedBytes > 0;\n  \t\tif (m_waiting)\n  \t\t\treturn blockedBytes;\n  \t\tsize -= m_len;\n  \t\ttransferBytes += m_len;\n  \t}\n  \n  \tif (!m_stream->good() && !m_stream->eof())\n  \t\tthrow ReadErr();\n  \n  \treturn 0;\n  }\n}"
  },
  {
    "function_name": "MaxRetrievable",
    "container": "FileStore",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
    "lines": "65-74",
    "snippet": "lword FileStore::MaxRetrievable() const\n{\n\tif (!m_stream)\n\t\treturn 0;\n\n\tstreampos current = m_stream->tellg();\n\tstreampos end = m_stream->seekg(0, ios::end).tellg();\n\tm_stream->seekg(current);\n\treturn end-current;\n}",
    "includes": [
      "#include <limits>",
      "#include \"files.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_stream->seekg",
          "args": [
            "current"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->seekg",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->seekg",
          "args": [
            "0",
            "ios::end"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_stream->tellg",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  lword FileStore::MaxRetrievable() const\n  {\n  \tif (!m_stream)\n  \t\treturn 0;\n  \n  \tstreampos current = m_stream->tellg();\n  \tstreampos end = m_stream->seekg(0, ios::end).tellg();\n  \tm_stream->seekg(current);\n  \treturn end-current;\n  }\n}"
  },
  {
    "function_name": "StoreInitialize",
    "container": "FileStore",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
    "lines": "24-63",
    "snippet": "void FileStore::StoreInitialize(const NameValuePairs &parameters)\n{\n\tm_waiting = false;\n\tm_stream = NULL;\n\tm_file.release();\n\n\tconst char *fileName = NULL;\n#if defined(CRYPTOPP_UNIX_AVAILABLE) || _MSC_VER >= 1400\n\tconst wchar_t *fileNameWide = NULL;\n\tif (!parameters.GetValue(Name::InputFileNameWide(), fileNameWide))\n#endif\n\t\tif (!parameters.GetValue(Name::InputFileName(), fileName))\n\t\t{\n\t\t\tparameters.GetValue(Name::InputStreamPointer(), m_stream);\n\t\t\treturn;\n\t\t}\n\n\tios::openmode binary = parameters.GetValueWithDefault(Name::InputBinaryMode(), true) ? ios::binary : ios::openmode(0);\n\tm_file.reset(new std::ifstream);\n#ifdef CRYPTOPP_UNIX_AVAILABLE\n\tstd::string narrowed;\n\tif (fileNameWide)\n\t\tfileName = (narrowed = StringNarrow(fileNameWide)).c_str();\n#endif\n#if _MSC_VER >= 1400\n\tif (fileNameWide)\n\t{\n\t\tm_file->open(fileNameWide, ios::in | binary);\n\t\tif (!*m_file)\n\t\t\tthrow OpenErr(StringNarrow(fileNameWide, false));\n\t}\n#endif\n\tif (fileName)\n\t{\n\t\tm_file->open(fileName, ios::in | binary);\n\t\tif (!*m_file)\n\t\t\tthrow OpenErr(fileName);\n\t}\n\tm_stream = m_file.get();\n}",
    "includes": [
      "#include <limits>",
      "#include \"files.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_file.get",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OpenErr",
          "args": [
            "fileName"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "OpenErr",
          "container": "OpenErr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.h",
          "lines": "85-85",
          "snippet": "OpenErr(const std::string &filename) : Err(\"FileSink: error opening file for writing: \" + filename) {}",
          "includes": [
            "#include <fstream>",
            "#include <iostream>",
            "#include \"argnames.h\"",
            "#include \"filters.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <iostream>\n#include \"argnames.h\"\n#include \"filters.h\"\n#include \"cryptlib.h\"\n\nOpenErr {\n  OpenErr(const std::string &filename) : Err(\"FileSink: error opening file for writing: \" + filename) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_file->open",
          "args": [
            "fileName",
            "ios::in | binary"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringNarrow",
          "args": [
            "fileNameWide",
            "false"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_file->open",
          "args": [
            "fileNameWide",
            "ios::in | binary"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringNarrow",
          "args": [
            "fileNameWide"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "StringNarrow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "548-568",
          "snippet": "static std::string StringNarrow(const wchar_t *str, bool throwOnError = true)\n{\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable: 4996)\t//  'wcstombs': This function or variable may be unsafe.\n#endif\n\tsize_t size = wcstombs(NULL, str, 0);\n\tif (size == size_t(0)-1)\n\t{\n\t\tif (throwOnError)\n\t\t\tthrow InvalidArgument(\"StringNarrow: wcstombs() call failed\");\n\t\telse\n\t\t\treturn std::string();\n\t}\n\tstd::string result(size, 0);\n\twcstombs(&result[0], str, size);\n\treturn result;\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstatic std::string StringNarrow(const wchar_t *str, bool throwOnError = true)\n{\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable: 4996)\t//  'wcstombs': This function or variable may be unsafe.\n#endif\n\tsize_t size = wcstombs(NULL, str, 0);\n\tif (size == size_t(0)-1)\n\t{\n\t\tif (throwOnError)\n\t\t\tthrow InvalidArgument(\"StringNarrow: wcstombs() call failed\");\n\t\telse\n\t\t\treturn std::string();\n\t}\n\tstd::string result(size, 0);\n\twcstombs(&result[0], str, size);\n\treturn result;\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_file.reset",
          "args": [
            "new std::ifstream"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "reset",
          "container": "member_ptr<T>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "50-50",
          "snippet": "void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nmember_ptr<T> {\n  void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ios::openmode",
          "args": [
            "0"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parameters.GetValueWithDefault",
          "args": [
            "Name::InputBinaryMode()",
            "true"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Name::InputBinaryMode",
          "args": [],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parameters.GetValue",
          "args": [
            "Name::InputStreamPointer()",
            "m_stream"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Name::InputStreamPointer",
          "args": [],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parameters.GetValue",
          "args": [
            "Name::InputFileName()",
            "fileName"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Name::InputFileName",
          "args": [],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parameters.GetValue",
          "args": [
            "Name::InputFileNameWide()",
            "fileNameWide"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Name::InputFileNameWide",
          "args": [],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_file.release",
          "args": [],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  void FileStore::StoreInitialize(const NameValuePairs &parameters)\n  {\n  \tm_waiting = false;\n  \tm_stream = NULL;\n  \tm_file.release();\n  \n  \tconst char *fileName = NULL;\n  #if defined(CRYPTOPP_UNIX_AVAILABLE) || _MSC_VER >= 1400\n  \tconst wchar_t *fileNameWide = NULL;\n  \tif (!parameters.GetValue(Name::InputFileNameWide(), fileNameWide))\n  #endif\n  \t\tif (!parameters.GetValue(Name::InputFileName(), fileName))\n  \t\t{\n  \t\t\tparameters.GetValue(Name::InputStreamPointer(), m_stream);\n  \t\t\treturn;\n  \t\t}\n  \n  \tios::openmode binary = parameters.GetValueWithDefault(Name::InputBinaryMode(), true) ? ios::binary : ios::openmode(0);\n  \tm_file.reset(new std::ifstream);\n  #ifdef CRYPTOPP_UNIX_AVAILABLE\n  \tstd::string narrowed;\n  \tif (fileNameWide)\n  \t\tfileName = (narrowed = StringNarrow(fileNameWide)).c_str();\n  #endif\n  #if _MSC_VER >= 1400\n  \tif (fileNameWide)\n  \t{\n  \t\tm_file->open(fileNameWide, ios::in | binary);\n  \t\tif (!*m_file)\n  \t\t\tthrow OpenErr(StringNarrow(fileNameWide, false));\n  \t}\n  #endif\n  \tif (fileName)\n  \t{\n  \t\tm_file->open(fileName, ios::in | binary);\n  \t\tif (!*m_file)\n  \t\t\tthrow OpenErr(fileName);\n  \t}\n  \tm_stream = m_file.get();\n  }\n}"
  },
  {
    "function_name": "Files_TestInstantiations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
    "lines": "16-21",
    "snippet": "void Files_TestInstantiations()\n{\n\tFileStore f0;\n\tFileSource f1;\n\tFileSink f2;\n}",
    "includes": [
      "#include <limits>",
      "#include \"files.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nvoid Files_TestInstantiations()\n{\n\tFileStore f0;\n\tFileSource f1;\n\tFileSink f2;\n}"
  }
]