[
  {
    "function_name": "VMAC_Base::HashEndianCorrectedBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.cpp",
    "lines": "133-137",
    "snippet": "void VMAC_Base::HashEndianCorrectedBlock(const word64 *data)\n{\n\tassert(false);\n\tthrow 0;\n}",
    "includes": [
      "#include <intrin.h>",
      "#include \"cpu.h\"",
      "#include \"argnames.h\"",
      "#include \"vmac.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [
      "#define const\t// Turbo C++ 2006 workaround"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <intrin.h>\n#include \"cpu.h\"\n#include \"argnames.h\"\n#include \"vmac.h\"\n#include \"pch.h\"\n\n#define const\t// Turbo C++ 2006 workaround\n\nvoid VMAC_Base::HashEndianCorrectedBlock(const word64 *data)\n{\n\tassert(false);\n\tthrow 0;\n}"
  },
  {
    "function_name": "VMAC_Base::Resynchronize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.cpp",
    "lines": "99-131",
    "snippet": "void VMAC_Base::Resynchronize(const byte *nonce, int len)\n{\n\tsize_t length = ThrowIfInvalidIVLength(len);\n\tsize_t s = IVSize();\n\tbyte *storedNonce = m_nonce();\n\n\tif (m_is128)\n\t{\n\t\tmemset(storedNonce, 0, s-length);\n\t\tmemcpy(storedNonce+s-length, nonce, length);\n\t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n\t}\n\telse\n\t{\n\t\tif (m_padCached && (storedNonce[s-1] | 1) == (nonce[length-1] | 1))\n\t\t{\n\t\t\tm_padCached = VerifyBufsEqual(storedNonce+s-length, nonce, length-1);\n\t\t\tfor (size_t i=0; m_padCached && i<s-length; i++)\n\t\t\t\tm_padCached = (storedNonce[i] == 0);\n\t\t}\n\t\tif (!m_padCached)\n\t\t{\n\t\t\tmemset(storedNonce, 0, s-length);\n\t\t\tmemcpy(storedNonce+s-length, nonce, length-1);\n\t\t\tstoredNonce[s-1] = nonce[length-1] & 0xfe;\n\t\t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n\t\t\tm_padCached = true;\n\t\t}\n\t\tstoredNonce[s-1] = nonce[length-1];\n\t}\n\tm_isFirstBlock = true;\n\tRestart();\n}",
    "includes": [
      "#include <intrin.h>",
      "#include \"cpu.h\"",
      "#include \"argnames.h\"",
      "#include \"vmac.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [
      "#define const\t// Turbo C++ 2006 workaround"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Restart",
          "args": [],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "IteratedHashBase<T, BASE>::Restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
          "lines": "120-124",
          "snippet": "void IteratedHashBase<T, BASE>::Restart()\n{\n\tm_countLo = m_countHi = 0;\n\tInit();\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nvoid IteratedHashBase<T, BASE>::Restart()\n{\n\tm_countLo = m_countHi = 0;\n\tInit();\n}"
        }
      },
      {
        "call_info": {
          "callee": "AccessCipher",
          "args": [
            "storedNonce",
            "m_pad()"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_pad",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessCipher",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "storedNonce+s-length",
            "nonce",
            "length-1"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "storedNonce",
            "0",
            "s-length"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VerifyBufsEqual",
          "args": [
            "storedNonce+s-length",
            "nonce",
            "length-1"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "VerifyBufsEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "79-113",
          "snippet": "bool VerifyBufsEqual(const byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\tbyte acc8 = 0;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tword32 acc32 = 0;\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tword64 acc64 = 0;\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\tacc64 |= ((word64*)buf)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn acc64 == 0;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t\tacc32 = word32(acc64) | word32(acc64>>32);\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\tacc32 |= ((word32*)buf)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn acc32 == 0;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t\tacc8 = byte(acc32) | byte(acc32>>8) | byte(acc32>>16) | byte(acc32>>24);\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tacc8 |= buf[i] ^ mask[i];\n\treturn acc8 == 0;\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nbool VerifyBufsEqual(const byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\tbyte acc8 = 0;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tword32 acc32 = 0;\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tword64 acc64 = 0;\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\tacc64 |= ((word64*)buf)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn acc64 == 0;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t\tacc32 = word32(acc64) | word32(acc64>>32);\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\tacc32 |= ((word32*)buf)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn acc32 == 0;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t\tacc8 = byte(acc32) | byte(acc32>>8) | byte(acc32>>16) | byte(acc32>>24);\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tacc8 |= buf[i] ^ mask[i];\n\treturn acc8 == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AccessCipher",
          "args": [
            "storedNonce",
            "m_pad()"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_pad",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessCipher",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "storedNonce+s-length",
            "nonce",
            "length"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "storedNonce",
            "0",
            "s-length"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_nonce",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IVSize",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "IVSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "14-14",
          "snippet": "unsigned int IVSize() const {return GetCipher().BlockSize();}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int IVSize() const {return GetCipher().BlockSize();}"
        }
      },
      {
        "call_info": {
          "callee": "ThrowIfInvalidIVLength",
          "args": [
            "len"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "SimpleKeyingInterface::ThrowIfInvalidIVLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "94-104",
          "snippet": "size_t SimpleKeyingInterface::ThrowIfInvalidIVLength(int size)\n{\n\tif (size < 0)\n\t\treturn IVSize();\n\telse if ((size_t)size < MinIVLength())\n\t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": IV length \" + IntToString(size) + \" is less than the minimum of \" + IntToString(MinIVLength()));\n\telse if ((size_t)size > MaxIVLength())\n\t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": IV length \" + IntToString(size) + \" exceeds the maximum of \" + IntToString(MaxIVLength()));\n\telse\n\t\treturn size;\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nsize_t SimpleKeyingInterface::ThrowIfInvalidIVLength(int size)\n{\n\tif (size < 0)\n\t\treturn IVSize();\n\telse if ((size_t)size < MinIVLength())\n\t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": IV length \" + IntToString(size) + \" is less than the minimum of \" + IntToString(MinIVLength()));\n\telse if ((size_t)size > MaxIVLength())\n\t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": IV length \" + IntToString(size) + \" exceeds the maximum of \" + IntToString(MaxIVLength()));\n\telse\n\t\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <intrin.h>\n#include \"cpu.h\"\n#include \"argnames.h\"\n#include \"vmac.h\"\n#include \"pch.h\"\n\n#define const\t// Turbo C++ 2006 workaround\n\nvoid VMAC_Base::Resynchronize(const byte *nonce, int len)\n{\n\tsize_t length = ThrowIfInvalidIVLength(len);\n\tsize_t s = IVSize();\n\tbyte *storedNonce = m_nonce();\n\n\tif (m_is128)\n\t{\n\t\tmemset(storedNonce, 0, s-length);\n\t\tmemcpy(storedNonce+s-length, nonce, length);\n\t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n\t}\n\telse\n\t{\n\t\tif (m_padCached && (storedNonce[s-1] | 1) == (nonce[length-1] | 1))\n\t\t{\n\t\t\tm_padCached = VerifyBufsEqual(storedNonce+s-length, nonce, length-1);\n\t\t\tfor (size_t i=0; m_padCached && i<s-length; i++)\n\t\t\t\tm_padCached = (storedNonce[i] == 0);\n\t\t}\n\t\tif (!m_padCached)\n\t\t{\n\t\t\tmemset(storedNonce, 0, s-length);\n\t\t\tmemcpy(storedNonce+s-length, nonce, length-1);\n\t\t\tstoredNonce[s-1] = nonce[length-1] & 0xfe;\n\t\t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n\t\t\tm_padCached = true;\n\t\t}\n\t\tstoredNonce[s-1] = nonce[length-1];\n\t}\n\tm_isFirstBlock = true;\n\tRestart();\n}"
  },
  {
    "function_name": "VMAC_Base::GetNextIV",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.cpp",
    "lines": "93-97",
    "snippet": "void VMAC_Base::GetNextIV(RandomNumberGenerator &rng, byte *IV)\n{\n\tSimpleKeyingInterface::GetNextIV(rng, IV);\n\tIV[0] &= 0x7f;\n}",
    "includes": [
      "#include <intrin.h>",
      "#include \"cpu.h\"",
      "#include \"argnames.h\"",
      "#include \"vmac.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SimpleKeyingInterface::GetNextIV",
          "args": [
            "rng",
            "IV"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "SimpleKeyingInterface::GetNextIV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "136-139",
          "snippet": "void SimpleKeyingInterface::GetNextIV(RandomNumberGenerator &rng, byte *IV)\n{\n\trng.GenerateBlock(IV, IVSize());\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nvoid SimpleKeyingInterface::GetNextIV(RandomNumberGenerator &rng, byte *IV)\n{\n\trng.GenerateBlock(IV, IVSize());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <intrin.h>\n#include \"cpu.h\"\n#include \"argnames.h\"\n#include \"vmac.h\"\n#include \"pch.h\"\n\nvoid VMAC_Base::GetNextIV(RandomNumberGenerator &rng, byte *IV)\n{\n\tSimpleKeyingInterface::GetNextIV(rng, IV);\n\tIV[0] &= 0x7f;\n}"
  },
  {
    "function_name": "VMAC_Base::UncheckedSetKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.cpp",
    "lines": "36-91",
    "snippet": "void VMAC_Base::UncheckedSetKey(const byte *userKey, unsigned int keylength, const NameValuePairs &params)\n{\n\tint digestLength = params.GetIntValueWithDefault(Name::DigestSize(), DefaultDigestSize());\n\tif (digestLength != 8 && digestLength != 16)\n\t\tthrow InvalidArgument(\"VMAC: DigestSize must be 8 or 16\");\n\tm_is128 = digestLength == 16;\n\n\tm_L1KeyLength = params.GetIntValueWithDefault(Name::L1KeyLength(), 128);\n\tif (m_L1KeyLength <= 0 || m_L1KeyLength % 128 != 0)\n\t\tthrow InvalidArgument(\"VMAC: L1KeyLength must be a positive multiple of 128\");\n\n\tAllocateBlocks();\n\n\tBlockCipher &cipher = AccessCipher();\n\tcipher.SetKey(userKey, keylength, params);\n\tunsigned int blockSize = cipher.BlockSize();\n\tunsigned int blockSizeInWords = blockSize / sizeof(word64);\n\tSecBlock<word64> out(blockSizeInWords);\n\tSecByteBlock in;\n\tin.CleanNew(blockSize);\n\tsize_t i;\n\n\t/* Fill nh key */\n\tin[0] = 0x80; \n\tcipher.AdvancedProcessBlocks(in, NULL, (byte *)m_nhKey(), m_nhKeySize()*sizeof(word64), cipher.BT_InBlockIsCounter);\n\tConditionalByteReverse<word64>(BIG_ENDIAN_ORDER, m_nhKey(), m_nhKey(), m_nhKeySize()*sizeof(word64));\n\n\t/* Fill poly key */\n\tin[0] = 0xC0;\n\tin[15] = 0;\n\tfor (i = 0; i <= (size_t)m_is128; i++)\n\t{\n\t\tcipher.ProcessBlock(in, out.BytePtr());\n\t\tm_polyState()[i*4+2] = GetWord<word64>(true, BIG_ENDIAN_ORDER, out.BytePtr()) & mpoly;\n\t\tm_polyState()[i*4+3]  = GetWord<word64>(true, BIG_ENDIAN_ORDER, out.BytePtr()+8) & mpoly;\n\t\tin[15]++;\n\t}\n\n\t/* Fill ip key */\n\tin[0] = 0xE0;\n\tin[15] = 0;\n\tword64 *l3Key = m_l3Key();\n\tfor (i = 0; i <= (size_t)m_is128; i++)\n\t\tdo\n\t\t{\n\t\t\tcipher.ProcessBlock(in, out.BytePtr());\n\t\t\tl3Key[i*2+0] = GetWord<word64>(true, BIG_ENDIAN_ORDER, out.BytePtr());\n\t\t\tl3Key[i*2+1] = GetWord<word64>(true, BIG_ENDIAN_ORDER, out.BytePtr()+8);\n\t\t\tin[15]++;\n\t\t} while ((l3Key[i*2+0] >= p64) || (l3Key[i*2+1] >= p64));\n\n\tm_padCached = false;\n\tsize_t nonceLength;\n\tconst byte *nonce = GetIVAndThrowIfInvalid(params, nonceLength);\n\tResynchronize(nonce, (int)nonceLength);\n}",
    "includes": [
      "#include <intrin.h>",
      "#include \"cpu.h\"",
      "#include \"argnames.h\"",
      "#include \"vmac.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [
      "#define const\t// Turbo C++ 2006 workaround"
    ],
    "globals_used": [
      "static const word64 p64   = W64LIT(0xfffffffffffffeff);",
      "static const word64 mpoly = W64LIT(0x1fffffff1fffffff);",
      "word32 L1KeyLength = m_L1KeyLength;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Resynchronize",
          "args": [
            "nonce",
            "(int)nonceLength"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "VMAC_Base::Resynchronize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.cpp",
          "lines": "99-131",
          "snippet": "void VMAC_Base::Resynchronize(const byte *nonce, int len)\n{\n\tsize_t length = ThrowIfInvalidIVLength(len);\n\tsize_t s = IVSize();\n\tbyte *storedNonce = m_nonce();\n\n\tif (m_is128)\n\t{\n\t\tmemset(storedNonce, 0, s-length);\n\t\tmemcpy(storedNonce+s-length, nonce, length);\n\t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n\t}\n\telse\n\t{\n\t\tif (m_padCached && (storedNonce[s-1] | 1) == (nonce[length-1] | 1))\n\t\t{\n\t\t\tm_padCached = VerifyBufsEqual(storedNonce+s-length, nonce, length-1);\n\t\t\tfor (size_t i=0; m_padCached && i<s-length; i++)\n\t\t\t\tm_padCached = (storedNonce[i] == 0);\n\t\t}\n\t\tif (!m_padCached)\n\t\t{\n\t\t\tmemset(storedNonce, 0, s-length);\n\t\t\tmemcpy(storedNonce+s-length, nonce, length-1);\n\t\t\tstoredNonce[s-1] = nonce[length-1] & 0xfe;\n\t\t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n\t\t\tm_padCached = true;\n\t\t}\n\t\tstoredNonce[s-1] = nonce[length-1];\n\t}\n\tm_isFirstBlock = true;\n\tRestart();\n}",
          "includes": [
            "#include <intrin.h>",
            "#include \"cpu.h\"",
            "#include \"argnames.h\"",
            "#include \"vmac.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [
            "#define const\t// Turbo C++ 2006 workaround"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <intrin.h>\n#include \"cpu.h\"\n#include \"argnames.h\"\n#include \"vmac.h\"\n#include \"pch.h\"\n\n#define const\t// Turbo C++ 2006 workaround\n\nvoid VMAC_Base::Resynchronize(const byte *nonce, int len)\n{\n\tsize_t length = ThrowIfInvalidIVLength(len);\n\tsize_t s = IVSize();\n\tbyte *storedNonce = m_nonce();\n\n\tif (m_is128)\n\t{\n\t\tmemset(storedNonce, 0, s-length);\n\t\tmemcpy(storedNonce+s-length, nonce, length);\n\t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n\t}\n\telse\n\t{\n\t\tif (m_padCached && (storedNonce[s-1] | 1) == (nonce[length-1] | 1))\n\t\t{\n\t\t\tm_padCached = VerifyBufsEqual(storedNonce+s-length, nonce, length-1);\n\t\t\tfor (size_t i=0; m_padCached && i<s-length; i++)\n\t\t\t\tm_padCached = (storedNonce[i] == 0);\n\t\t}\n\t\tif (!m_padCached)\n\t\t{\n\t\t\tmemset(storedNonce, 0, s-length);\n\t\t\tmemcpy(storedNonce+s-length, nonce, length-1);\n\t\t\tstoredNonce[s-1] = nonce[length-1] & 0xfe;\n\t\t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n\t\t\tm_padCached = true;\n\t\t}\n\t\tstoredNonce[s-1] = nonce[length-1];\n\t}\n\tm_isFirstBlock = true;\n\tRestart();\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetIVAndThrowIfInvalid",
          "args": [
            "params",
            "nonceLength"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetWord<word64>",
          "args": [
            "true",
            "BIG_ENDIAN_ORDER",
            "out.BytePtr()+8"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "GetWord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1127-1135",
          "snippet": "inline T GetWord(bool assumeAligned, ByteOrder order, const byte *block)\n{\n#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (!assumeAligned)\n\t\treturn UnalignedGetWordNonTemplate(order, block, (T*)NULL);\n\tassert(IsAligned<T>(block));\n#endif\n\treturn ConditionalByteReverse(order, *reinterpret_cast<const T *>(block));\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T GetWord(bool assumeAligned, ByteOrder order, const byte *block)\n{\n#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (!assumeAligned)\n\t\treturn UnalignedGetWordNonTemplate(order, block, (T*)NULL);\n\tassert(IsAligned<T>(block));\n#endif\n\treturn ConditionalByteReverse(order, *reinterpret_cast<const T *>(block));\n}"
        }
      },
      {
        "call_info": {
          "callee": "out.BytePtr",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.BytePtr",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher.ProcessBlock",
          "args": [
            "in",
            "out.BytePtr()"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.BytePtr",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_l3Key",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.BytePtr",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_polyState",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.BytePtr",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_polyState",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher.ProcessBlock",
          "args": [
            "in",
            "out.BytePtr()"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.BytePtr",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ConditionalByteReverse<word64>",
          "args": [
            "BIG_ENDIAN_ORDER",
            "m_nhKey()",
            "m_nhKey()",
            "m_nhKeySize()*sizeof(word64)"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "ConditionalByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "937-943",
          "snippet": "inline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_nhKeySize",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_nhKey",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_nhKey",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher.AdvancedProcessBlocks",
          "args": [
            "in",
            "NULL",
            "(byte *)m_nhKey()",
            "m_nhKeySize()*sizeof(word64)",
            "cipher.BT_InBlockIsCounter"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_nhKeySize",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_nhKey",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.CleanNew",
          "args": [
            "blockSize"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "CleanNew",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "368-372",
          "snippet": "void CleanNew(size_type newSize)\n\t{\n\t\tNew(newSize);\n\t\tmemset_z(m_ptr, 0, m_size*sizeof(T));\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void CleanNew(size_type newSize)\n  \t{\n  \t\tNew(newSize);\n  \t\tmemset_z(m_ptr, 0, m_size*sizeof(T));\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher.BlockSize",
          "args": [],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      },
      {
        "call_info": {
          "callee": "cipher.SetKey",
          "args": [
            "userKey",
            "keylength",
            "params"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessCipher",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateBlocks",
          "args": [],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"VMAC: L1KeyLength must be a positive multiple of 128\""
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetIntValueWithDefault",
          "args": [
            "Name::L1KeyLength()",
            "128"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Name::L1KeyLength",
          "args": [],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"VMAC: DigestSize must be 8 or 16\""
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetIntValueWithDefault",
          "args": [
            "Name::DigestSize()",
            "DefaultDigestSize()"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultDigestSize",
          "args": [],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "DefaultDigestSize",
          "container": "VMAC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "62-62",
          "snippet": "int DefaultDigestSize() const {return T_DigestBitSize/8;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nVMAC {\n  int DefaultDigestSize() const {return T_DigestBitSize/8;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Name::DigestSize",
          "args": [],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "18-18",
          "snippet": "unsigned int DigestSize() const {return m_is128 ? 16 : 8;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int DigestSize() const {return m_is128 ? 16 : 8;}"
        }
      }
    ],
    "contextual_snippet": "#include <intrin.h>\n#include \"cpu.h\"\n#include \"argnames.h\"\n#include \"vmac.h\"\n#include \"pch.h\"\n\n#define const\t// Turbo C++ 2006 workaround\n\nstatic const word64 p64   = W64LIT(0xfffffffffffffeff);\nstatic const word64 mpoly = W64LIT(0x1fffffff1fffffff);\nword32 L1KeyLength = m_L1KeyLength;\n\nvoid VMAC_Base::UncheckedSetKey(const byte *userKey, unsigned int keylength, const NameValuePairs &params)\n{\n\tint digestLength = params.GetIntValueWithDefault(Name::DigestSize(), DefaultDigestSize());\n\tif (digestLength != 8 && digestLength != 16)\n\t\tthrow InvalidArgument(\"VMAC: DigestSize must be 8 or 16\");\n\tm_is128 = digestLength == 16;\n\n\tm_L1KeyLength = params.GetIntValueWithDefault(Name::L1KeyLength(), 128);\n\tif (m_L1KeyLength <= 0 || m_L1KeyLength % 128 != 0)\n\t\tthrow InvalidArgument(\"VMAC: L1KeyLength must be a positive multiple of 128\");\n\n\tAllocateBlocks();\n\n\tBlockCipher &cipher = AccessCipher();\n\tcipher.SetKey(userKey, keylength, params);\n\tunsigned int blockSize = cipher.BlockSize();\n\tunsigned int blockSizeInWords = blockSize / sizeof(word64);\n\tSecBlock<word64> out(blockSizeInWords);\n\tSecByteBlock in;\n\tin.CleanNew(blockSize);\n\tsize_t i;\n\n\t/* Fill nh key */\n\tin[0] = 0x80; \n\tcipher.AdvancedProcessBlocks(in, NULL, (byte *)m_nhKey(), m_nhKeySize()*sizeof(word64), cipher.BT_InBlockIsCounter);\n\tConditionalByteReverse<word64>(BIG_ENDIAN_ORDER, m_nhKey(), m_nhKey(), m_nhKeySize()*sizeof(word64));\n\n\t/* Fill poly key */\n\tin[0] = 0xC0;\n\tin[15] = 0;\n\tfor (i = 0; i <= (size_t)m_is128; i++)\n\t{\n\t\tcipher.ProcessBlock(in, out.BytePtr());\n\t\tm_polyState()[i*4+2] = GetWord<word64>(true, BIG_ENDIAN_ORDER, out.BytePtr()) & mpoly;\n\t\tm_polyState()[i*4+3]  = GetWord<word64>(true, BIG_ENDIAN_ORDER, out.BytePtr()+8) & mpoly;\n\t\tin[15]++;\n\t}\n\n\t/* Fill ip key */\n\tin[0] = 0xE0;\n\tin[15] = 0;\n\tword64 *l3Key = m_l3Key();\n\tfor (i = 0; i <= (size_t)m_is128; i++)\n\t\tdo\n\t\t{\n\t\t\tcipher.ProcessBlock(in, out.BytePtr());\n\t\t\tl3Key[i*2+0] = GetWord<word64>(true, BIG_ENDIAN_ORDER, out.BytePtr());\n\t\t\tl3Key[i*2+1] = GetWord<word64>(true, BIG_ENDIAN_ORDER, out.BytePtr()+8);\n\t\t\tin[15]++;\n\t\t} while ((l3Key[i*2+0] >= p64) || (l3Key[i*2+1] >= p64));\n\n\tm_padCached = false;\n\tsize_t nonceLength;\n\tconst byte *nonce = GetIVAndThrowIfInvalid(params, nonceLength);\n\tResynchronize(nonce, (int)nonceLength);\n}"
  }
]