[
  {
    "function_name": "DeriveKey",
    "container": "PKCS12_PBKDF<T>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pwdbased.h",
    "lines": "150-210",
    "snippet": "unsigned int PKCS12_PBKDF<T>::DeriveKey(byte *derived, size_t derivedLen, byte purpose, const byte *password, size_t passwordLen, const byte *salt, size_t saltLen, unsigned int iterations, double timeInSeconds) const\n{\n\tassert(derivedLen <= MaxDerivedKeyLength());\n\tassert(iterations > 0 || timeInSeconds > 0);\n\n\tif (!iterations)\n\t\titerations = 1;\n\n\tconst size_t v = T::BLOCKSIZE;\t// v is in bytes rather than bits as in PKCS #12\n\tconst size_t DLen = v, SLen = RoundUpToMultipleOf(saltLen, v);\n\tconst size_t PLen = RoundUpToMultipleOf(passwordLen, v), ILen = SLen + PLen;\n\tSecByteBlock buffer(DLen + SLen + PLen);\n\tbyte *D = buffer, *S = buffer+DLen, *P = buffer+DLen+SLen, *I = S;\n\n\tmemset(D, purpose, DLen);\n\tsize_t i;\n\tfor (i=0; i<SLen; i++)\n\t\tS[i] = salt[i % saltLen];\n\tfor (i=0; i<PLen; i++)\n\t\tP[i] = password[i % passwordLen];\n\n\n\tT hash;\n\tSecByteBlock Ai(T::DIGESTSIZE), B(v);\n\tThreadUserTimer timer;\n\n\twhile (derivedLen > 0)\n\t{\n\t\thash.CalculateDigest(Ai, buffer, buffer.size());\n\n\t\tif (timeInSeconds)\n\t\t{\n\t\t\ttimeInSeconds = timeInSeconds / ((derivedLen + Ai.size() - 1) / Ai.size());\n\t\t\ttimer.StartTimer();\n\t\t}\n\n\t\tfor (i=1; i<iterations || (timeInSeconds && (i%128!=0 || timer.ElapsedTimeAsDouble() < timeInSeconds)); i++)\n\t\t\thash.CalculateDigest(Ai, Ai, Ai.size());\n\n\t\tif (timeInSeconds)\n\t\t{\n\t\t\titerations = (unsigned int)i;\n\t\t\ttimeInSeconds = 0;\n\t\t}\n\n\t\tfor (i=0; i<B.size(); i++)\n\t\t\tB[i] = Ai[i % Ai.size()];\n\n\t\tInteger B1(B, B.size());\n\t\t++B1;\n\t\tfor (i=0; i<ILen; i+=v)\n\t\t\t(Integer(I+i, v) + B1).Encode(I+i, v);\n\n\t\tsize_t segmentLen = STDMIN(derivedLen, Ai.size());\n\t\tmemcpy(derived, Ai, segmentLen);\n\t\tderived += segmentLen;\n\t\tderivedLen -= segmentLen;\n\t}\n\n\treturn iterations;\n}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"hrtimer.h\"",
      "#include \"hmac.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "derived",
            "Ai",
            "segmentLen"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "derivedLen",
            "Ai.size()"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Ai.size",
          "args": [],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "I+i",
            "v"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer",
          "args": [
            "I+i",
            "v"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "Gcd",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3953-3956",
          "snippet": "Integer Integer::Gcd(const Integer &a, const Integer &b)\n{\n\treturn EuclideanDomainOf<Integer>().Gcd(a, b);\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  Integer Integer::Gcd(const Integer &a, const Integer &b)\n  {\n  \treturn EuclideanDomainOf<Integer>().Gcd(a, b);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "B.size",
          "args": [],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ByteArrayParameter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "63-63",
          "snippet": "size_t size() const {return m_size;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nByteArrayParameter {\n  size_t size() const {return m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.CalculateDigest",
          "args": [
            "Ai",
            "Ai",
            "Ai.size()"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer.ElapsedTimeAsDouble",
          "args": [],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "ElapsedTimeAsDouble",
          "container": "TimerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/hrtimer.cpp",
          "lines": "37-52",
          "snippet": "double TimerBase::ElapsedTimeAsDouble()\n{\n\tif (m_stuckAtZero)\n\t\treturn 0;\n\n\tif (m_started)\n\t{\n\t\tTimerWord now = GetCurrentTimerValue();\n\t\tif (m_last < now)\t// protect against OS bugs where time goes backwards\n\t\t\tm_last = now;\n\t\treturn ConvertTo(m_last - m_start, m_timerUnit);\n\t}\n\n\tStartTimer();\n\treturn 0;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/times.h>",
            "#include <sys/time.h>",
            "#include <windows.h>",
            "#include <time.h>",
            "#include <stddef.h>\t\t// for NULL",
            "#include \"misc.h\"",
            "#include \"hrtimer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/time.h>\n#include <windows.h>\n#include <time.h>\n#include <stddef.h>\t\t// for NULL\n#include \"misc.h\"\n#include \"hrtimer.h\"\n#include \"pch.h\"\n\nTimerBase {\n  double TimerBase::ElapsedTimeAsDouble()\n  {\n  \tif (m_stuckAtZero)\n  \t\treturn 0;\n  \n  \tif (m_started)\n  \t{\n  \t\tTimerWord now = GetCurrentTimerValue();\n  \t\tif (m_last < now)\t// protect against OS bugs where time goes backwards\n  \t\t\tm_last = now;\n  \t\treturn ConvertTo(m_last - m_start, m_timerUnit);\n  \t}\n  \n  \tStartTimer();\n  \treturn 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.StartTimer",
          "args": [],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "StartTimer",
          "container": "TimerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/hrtimer.cpp",
          "lines": "31-35",
          "snippet": "void TimerBase::StartTimer()\n{\n\tm_last = m_start = GetCurrentTimerValue();\n\tm_started = true;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/times.h>",
            "#include <sys/time.h>",
            "#include <windows.h>",
            "#include <time.h>",
            "#include <stddef.h>\t\t// for NULL",
            "#include \"misc.h\"",
            "#include \"hrtimer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/time.h>\n#include <windows.h>\n#include <time.h>\n#include <stddef.h>\t\t// for NULL\n#include \"misc.h\"\n#include \"hrtimer.h\"\n#include \"pch.h\"\n\nTimerBase {\n  void TimerBase::StartTimer()\n  {\n  \tm_last = m_start = GetCurrentTimerValue();\n  \tm_started = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.CalculateDigest",
          "args": [
            "Ai",
            "buffer",
            "buffer.size()"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "D",
            "purpose",
            "DLen"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RoundUpToMultipleOf",
          "args": [
            "passwordLen",
            "v"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "RoundUpToMultipleOf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "355-360",
          "snippet": "inline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "iterations > 0 || timeInSeconds > 0"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "derivedLen <= MaxDerivedKeyLength()"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MaxDerivedKeyLength",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "MaxDerivedKeyLength",
          "container": "PKCS12_PBKDF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pwdbased.h",
          "lines": "144-144",
          "snippet": "size_t MaxDerivedKeyLength() const {return size_t(0)-1;}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"hrtimer.h\"",
            "#include \"hmac.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"hrtimer.h\"\n#include \"hmac.h\"\n#include \"cryptlib.h\"\n\nPKCS12_PBKDF {\n  size_t MaxDerivedKeyLength() const {return size_t(0)-1;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"integer.h\"\n#include \"hrtimer.h\"\n#include \"hmac.h\"\n#include \"cryptlib.h\"\n\nPKCS12_PBKDF<T> {\n  unsigned int PKCS12_PBKDF<T>::DeriveKey(byte *derived, size_t derivedLen, byte purpose, const byte *password, size_t passwordLen, const byte *salt, size_t saltLen, unsigned int iterations, double timeInSeconds) const\n  {\n  \tassert(derivedLen <= MaxDerivedKeyLength());\n  \tassert(iterations > 0 || timeInSeconds > 0);\n  \n  \tif (!iterations)\n  \t\titerations = 1;\n  \n  \tconst size_t v = T::BLOCKSIZE;\t// v is in bytes rather than bits as in PKCS #12\n  \tconst size_t DLen = v, SLen = RoundUpToMultipleOf(saltLen, v);\n  \tconst size_t PLen = RoundUpToMultipleOf(passwordLen, v), ILen = SLen + PLen;\n  \tSecByteBlock buffer(DLen + SLen + PLen);\n  \tbyte *D = buffer, *S = buffer+DLen, *P = buffer+DLen+SLen, *I = S;\n  \n  \tmemset(D, purpose, DLen);\n  \tsize_t i;\n  \tfor (i=0; i<SLen; i++)\n  \t\tS[i] = salt[i % saltLen];\n  \tfor (i=0; i<PLen; i++)\n  \t\tP[i] = password[i % passwordLen];\n  \n  \n  \tT hash;\n  \tSecByteBlock Ai(T::DIGESTSIZE), B(v);\n  \tThreadUserTimer timer;\n  \n  \twhile (derivedLen > 0)\n  \t{\n  \t\thash.CalculateDigest(Ai, buffer, buffer.size());\n  \n  \t\tif (timeInSeconds)\n  \t\t{\n  \t\t\ttimeInSeconds = timeInSeconds / ((derivedLen + Ai.size() - 1) / Ai.size());\n  \t\t\ttimer.StartTimer();\n  \t\t}\n  \n  \t\tfor (i=1; i<iterations || (timeInSeconds && (i%128!=0 || timer.ElapsedTimeAsDouble() < timeInSeconds)); i++)\n  \t\t\thash.CalculateDigest(Ai, Ai, Ai.size());\n  \n  \t\tif (timeInSeconds)\n  \t\t{\n  \t\t\titerations = (unsigned int)i;\n  \t\t\ttimeInSeconds = 0;\n  \t\t}\n  \n  \t\tfor (i=0; i<B.size(); i++)\n  \t\t\tB[i] = Ai[i % Ai.size()];\n  \n  \t\tInteger B1(B, B.size());\n  \t\t++B1;\n  \t\tfor (i=0; i<ILen; i+=v)\n  \t\t\t(Integer(I+i, v) + B1).Encode(I+i, v);\n  \n  \t\tsize_t segmentLen = STDMIN(derivedLen, Ai.size());\n  \t\tmemcpy(derived, Ai, segmentLen);\n  \t\tderived += segmentLen;\n  \t\tderivedLen -= segmentLen;\n  \t}\n  \n  \treturn iterations;\n  }\n}"
  },
  {
    "function_name": "UsesPurposeByte",
    "container": "PKCS12_PBKDF",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pwdbased.h",
    "lines": "145-145",
    "snippet": "bool UsesPurposeByte() const {return true;}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"hrtimer.h\"",
      "#include \"hmac.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"integer.h\"\n#include \"hrtimer.h\"\n#include \"hmac.h\"\n#include \"cryptlib.h\"\n\nPKCS12_PBKDF {\n  bool UsesPurposeByte() const {return true;}\n}"
  },
  {
    "function_name": "MaxDerivedKeyLength",
    "container": "PKCS12_PBKDF",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pwdbased.h",
    "lines": "144-144",
    "snippet": "size_t MaxDerivedKeyLength() const {return size_t(0)-1;}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"hrtimer.h\"",
      "#include \"hmac.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "0"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"integer.h\"\n#include \"hrtimer.h\"\n#include \"hmac.h\"\n#include \"cryptlib.h\"\n\nPKCS12_PBKDF {\n  size_t MaxDerivedKeyLength() const {return size_t(0)-1;}\n}"
  },
  {
    "function_name": "DeriveKey",
    "container": "PKCS5_PBKDF2_HMAC<T>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pwdbased.h",
    "lines": "86-137",
    "snippet": "unsigned int PKCS5_PBKDF2_HMAC<T>::DeriveKey(byte *derived, size_t derivedLen, byte purpose, const byte *password, size_t passwordLen, const byte *salt, size_t saltLen, unsigned int iterations, double timeInSeconds) const\n{\n\tassert(derivedLen <= MaxDerivedKeyLength());\n\tassert(iterations > 0 || timeInSeconds > 0);\n\n\tif (!iterations)\n\t\titerations = 1;\n\n\tHMAC<T> hmac(password, passwordLen);\n\tSecByteBlock buffer(hmac.DigestSize());\n\tThreadUserTimer timer;\n\n\tunsigned int i=1;\n\twhile (derivedLen > 0)\n\t{\n\t\thmac.Update(salt, saltLen);\n\t\tunsigned int j;\n\t\tfor (j=0; j<4; j++)\n\t\t{\n\t\t\tbyte b = byte(i >> ((3-j)*8));\n\t\t\thmac.Update(&b, 1);\n\t\t}\n\t\thmac.Final(buffer);\n\n\t\tsize_t segmentLen = STDMIN(derivedLen, buffer.size());\n\t\tmemcpy(derived, buffer, segmentLen);\n\n\t\tif (timeInSeconds)\n\t\t{\n\t\t\ttimeInSeconds = timeInSeconds / ((derivedLen + buffer.size() - 1) / buffer.size());\n\t\t\ttimer.StartTimer();\n\t\t}\n\n\t\tfor (j=1; j<iterations || (timeInSeconds && (j%128!=0 || timer.ElapsedTimeAsDouble() < timeInSeconds)); j++)\n\t\t{\n\t\t\thmac.CalculateDigest(buffer, buffer, buffer.size());\n\t\t\txorbuf(derived, buffer, segmentLen);\n\t\t}\n\n\t\tif (timeInSeconds)\n\t\t{\n\t\t\titerations = j;\n\t\t\ttimeInSeconds = 0;\n\t\t}\n\n\t\tderived += segmentLen;\n\t\tderivedLen -= segmentLen;\n\t\ti++;\n\t}\n\n\treturn iterations;\n}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"hrtimer.h\"",
      "#include \"hmac.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "derived",
            "buffer",
            "segmentLen"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "17-45",
          "snippet": "void xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "hmac.CalculateDigest",
          "args": [
            "buffer",
            "buffer",
            "buffer.size()"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer.size",
          "args": [],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.ElapsedTimeAsDouble",
          "args": [],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "ElapsedTimeAsDouble",
          "container": "TimerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/hrtimer.cpp",
          "lines": "37-52",
          "snippet": "double TimerBase::ElapsedTimeAsDouble()\n{\n\tif (m_stuckAtZero)\n\t\treturn 0;\n\n\tif (m_started)\n\t{\n\t\tTimerWord now = GetCurrentTimerValue();\n\t\tif (m_last < now)\t// protect against OS bugs where time goes backwards\n\t\t\tm_last = now;\n\t\treturn ConvertTo(m_last - m_start, m_timerUnit);\n\t}\n\n\tStartTimer();\n\treturn 0;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/times.h>",
            "#include <sys/time.h>",
            "#include <windows.h>",
            "#include <time.h>",
            "#include <stddef.h>\t\t// for NULL",
            "#include \"misc.h\"",
            "#include \"hrtimer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/time.h>\n#include <windows.h>\n#include <time.h>\n#include <stddef.h>\t\t// for NULL\n#include \"misc.h\"\n#include \"hrtimer.h\"\n#include \"pch.h\"\n\nTimerBase {\n  double TimerBase::ElapsedTimeAsDouble()\n  {\n  \tif (m_stuckAtZero)\n  \t\treturn 0;\n  \n  \tif (m_started)\n  \t{\n  \t\tTimerWord now = GetCurrentTimerValue();\n  \t\tif (m_last < now)\t// protect against OS bugs where time goes backwards\n  \t\t\tm_last = now;\n  \t\treturn ConvertTo(m_last - m_start, m_timerUnit);\n  \t}\n  \n  \tStartTimer();\n  \treturn 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.StartTimer",
          "args": [],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "StartTimer",
          "container": "TimerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/hrtimer.cpp",
          "lines": "31-35",
          "snippet": "void TimerBase::StartTimer()\n{\n\tm_last = m_start = GetCurrentTimerValue();\n\tm_started = true;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/times.h>",
            "#include <sys/time.h>",
            "#include <windows.h>",
            "#include <time.h>",
            "#include <stddef.h>\t\t// for NULL",
            "#include \"misc.h\"",
            "#include \"hrtimer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/time.h>\n#include <windows.h>\n#include <time.h>\n#include <stddef.h>\t\t// for NULL\n#include \"misc.h\"\n#include \"hrtimer.h\"\n#include \"pch.h\"\n\nTimerBase {\n  void TimerBase::StartTimer()\n  {\n  \tm_last = m_start = GetCurrentTimerValue();\n  \tm_started = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "derived",
            "buffer",
            "segmentLen"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "derivedLen",
            "buffer.size()"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmac.Final",
          "args": [
            "buffer"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmac.Update",
          "args": [
            "&b",
            "1"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "Update",
          "container": "Adler32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/adler32.cpp",
          "lines": "8-54",
          "snippet": "void Adler32::Update(const byte *input, size_t length)\n{\n\tconst unsigned long BASE = 65521;\n\n\tunsigned long s1 = m_s1;\n\tunsigned long s2 = m_s2;\n\n\tif (length % 8 != 0)\n\t{\n\t\tdo\n\t\t{\n\t\t\ts1 += *input++;\n\t\t\ts2 += s1;\n\t\t\tlength--;\n\t\t} while (length % 8 != 0);\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\ts2 %= BASE;\n\t}\n\n\twhile (length > 0)\n\t{\n\t\ts1 += input[0]; s2 += s1;\n\t\ts1 += input[1]; s2 += s1;\n\t\ts1 += input[2]; s2 += s1;\n\t\ts1 += input[3]; s2 += s1;\n\t\ts1 += input[4]; s2 += s1;\n\t\ts1 += input[5]; s2 += s1;\n\t\ts1 += input[6]; s2 += s1;\n\t\ts1 += input[7]; s2 += s1;\n\n\t\tlength -= 8;\n\t\tinput += 8;\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\tif (length % 0x8000 == 0)\n\t\t\ts2 %= BASE;\n\t}\n\n\tassert(s1 < BASE);\n\tassert(s2 < BASE);\n\n\tm_s1 = (word16)s1;\n\tm_s2 = (word16)s2;\n}",
          "includes": [
            "#include \"adler32.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adler32.h\"\n#include \"pch.h\"\n\nAdler32 {\n  void Adler32::Update(const byte *input, size_t length)\n  {\n  \tconst unsigned long BASE = 65521;\n  \n  \tunsigned long s1 = m_s1;\n  \tunsigned long s2 = m_s2;\n  \n  \tif (length % 8 != 0)\n  \t{\n  \t\tdo\n  \t\t{\n  \t\t\ts1 += *input++;\n  \t\t\ts2 += s1;\n  \t\t\tlength--;\n  \t\t} while (length % 8 != 0);\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\ts2 %= BASE;\n  \t}\n  \n  \twhile (length > 0)\n  \t{\n  \t\ts1 += input[0]; s2 += s1;\n  \t\ts1 += input[1]; s2 += s1;\n  \t\ts1 += input[2]; s2 += s1;\n  \t\ts1 += input[3]; s2 += s1;\n  \t\ts1 += input[4]; s2 += s1;\n  \t\ts1 += input[5]; s2 += s1;\n  \t\ts1 += input[6]; s2 += s1;\n  \t\ts1 += input[7]; s2 += s1;\n  \n  \t\tlength -= 8;\n  \t\tinput += 8;\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\tif (length % 0x8000 == 0)\n  \t\t\ts2 %= BASE;\n  \t}\n  \n  \tassert(s1 < BASE);\n  \tassert(s2 < BASE);\n  \n  \tm_s1 = (word16)s1;\n  \tm_s2 = (word16)s2;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "byte",
          "args": [
            "i >> ((3-j)*8)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmac.DigestSize",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "iterations > 0 || timeInSeconds > 0"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "derivedLen <= MaxDerivedKeyLength()"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MaxDerivedKeyLength",
          "args": [],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "MaxDerivedKeyLength",
          "container": "PKCS12_PBKDF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pwdbased.h",
          "lines": "144-144",
          "snippet": "size_t MaxDerivedKeyLength() const {return size_t(0)-1;}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"hrtimer.h\"",
            "#include \"hmac.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"hrtimer.h\"\n#include \"hmac.h\"\n#include \"cryptlib.h\"\n\nPKCS12_PBKDF {\n  size_t MaxDerivedKeyLength() const {return size_t(0)-1;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"integer.h\"\n#include \"hrtimer.h\"\n#include \"hmac.h\"\n#include \"cryptlib.h\"\n\nPKCS5_PBKDF2_HMAC<T> {\n  unsigned int PKCS5_PBKDF2_HMAC<T>::DeriveKey(byte *derived, size_t derivedLen, byte purpose, const byte *password, size_t passwordLen, const byte *salt, size_t saltLen, unsigned int iterations, double timeInSeconds) const\n  {\n  \tassert(derivedLen <= MaxDerivedKeyLength());\n  \tassert(iterations > 0 || timeInSeconds > 0);\n  \n  \tif (!iterations)\n  \t\titerations = 1;\n  \n  \tHMAC<T> hmac(password, passwordLen);\n  \tSecByteBlock buffer(hmac.DigestSize());\n  \tThreadUserTimer timer;\n  \n  \tunsigned int i=1;\n  \twhile (derivedLen > 0)\n  \t{\n  \t\thmac.Update(salt, saltLen);\n  \t\tunsigned int j;\n  \t\tfor (j=0; j<4; j++)\n  \t\t{\n  \t\t\tbyte b = byte(i >> ((3-j)*8));\n  \t\t\thmac.Update(&b, 1);\n  \t\t}\n  \t\thmac.Final(buffer);\n  \n  \t\tsize_t segmentLen = STDMIN(derivedLen, buffer.size());\n  \t\tmemcpy(derived, buffer, segmentLen);\n  \n  \t\tif (timeInSeconds)\n  \t\t{\n  \t\t\ttimeInSeconds = timeInSeconds / ((derivedLen + buffer.size() - 1) / buffer.size());\n  \t\t\ttimer.StartTimer();\n  \t\t}\n  \n  \t\tfor (j=1; j<iterations || (timeInSeconds && (j%128!=0 || timer.ElapsedTimeAsDouble() < timeInSeconds)); j++)\n  \t\t{\n  \t\t\thmac.CalculateDigest(buffer, buffer, buffer.size());\n  \t\t\txorbuf(derived, buffer, segmentLen);\n  \t\t}\n  \n  \t\tif (timeInSeconds)\n  \t\t{\n  \t\t\titerations = j;\n  \t\t\ttimeInSeconds = 0;\n  \t\t}\n  \n  \t\tderived += segmentLen;\n  \t\tderivedLen -= segmentLen;\n  \t\ti++;\n  \t}\n  \n  \treturn iterations;\n  }\n}"
  },
  {
    "function_name": "DeriveKey",
    "container": "PKCS5_PBKDF1<T>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pwdbased.h",
    "lines": "57-83",
    "snippet": "unsigned int PKCS5_PBKDF1<T>::DeriveKey(byte *derived, size_t derivedLen, byte purpose, const byte *password, size_t passwordLen, const byte *salt, size_t saltLen, unsigned int iterations, double timeInSeconds) const\n{\n\tassert(derivedLen <= MaxDerivedKeyLength());\n\tassert(iterations > 0 || timeInSeconds > 0);\n\n\tif (!iterations)\n\t\titerations = 1;\n\n\tT hash;\n\thash.Update(password, passwordLen);\n\thash.Update(salt, saltLen);\n\n\tSecByteBlock buffer(hash.DigestSize());\n\thash.Final(buffer);\n\n\tunsigned int i;\n\tThreadUserTimer timer;\n\n\tif (timeInSeconds)\n\t\ttimer.StartTimer();\n\n\tfor (i=1; i<iterations || (timeInSeconds && (i%128!=0 || timer.ElapsedTimeAsDouble() < timeInSeconds)); i++)\n\t\thash.CalculateDigest(buffer, buffer, buffer.size());\n\n\tmemcpy(derived, buffer, derivedLen);\n\treturn i;\n}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"hrtimer.h\"",
      "#include \"hmac.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "derived",
            "buffer",
            "derivedLen"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash.CalculateDigest",
          "args": [
            "buffer",
            "buffer",
            "buffer.size()"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer.size",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.ElapsedTimeAsDouble",
          "args": [],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "ElapsedTimeAsDouble",
          "container": "TimerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/hrtimer.cpp",
          "lines": "37-52",
          "snippet": "double TimerBase::ElapsedTimeAsDouble()\n{\n\tif (m_stuckAtZero)\n\t\treturn 0;\n\n\tif (m_started)\n\t{\n\t\tTimerWord now = GetCurrentTimerValue();\n\t\tif (m_last < now)\t// protect against OS bugs where time goes backwards\n\t\t\tm_last = now;\n\t\treturn ConvertTo(m_last - m_start, m_timerUnit);\n\t}\n\n\tStartTimer();\n\treturn 0;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/times.h>",
            "#include <sys/time.h>",
            "#include <windows.h>",
            "#include <time.h>",
            "#include <stddef.h>\t\t// for NULL",
            "#include \"misc.h\"",
            "#include \"hrtimer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/time.h>\n#include <windows.h>\n#include <time.h>\n#include <stddef.h>\t\t// for NULL\n#include \"misc.h\"\n#include \"hrtimer.h\"\n#include \"pch.h\"\n\nTimerBase {\n  double TimerBase::ElapsedTimeAsDouble()\n  {\n  \tif (m_stuckAtZero)\n  \t\treturn 0;\n  \n  \tif (m_started)\n  \t{\n  \t\tTimerWord now = GetCurrentTimerValue();\n  \t\tif (m_last < now)\t// protect against OS bugs where time goes backwards\n  \t\t\tm_last = now;\n  \t\treturn ConvertTo(m_last - m_start, m_timerUnit);\n  \t}\n  \n  \tStartTimer();\n  \treturn 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.StartTimer",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "StartTimer",
          "container": "TimerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/hrtimer.cpp",
          "lines": "31-35",
          "snippet": "void TimerBase::StartTimer()\n{\n\tm_last = m_start = GetCurrentTimerValue();\n\tm_started = true;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/times.h>",
            "#include <sys/time.h>",
            "#include <windows.h>",
            "#include <time.h>",
            "#include <stddef.h>\t\t// for NULL",
            "#include \"misc.h\"",
            "#include \"hrtimer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/time.h>\n#include <windows.h>\n#include <time.h>\n#include <stddef.h>\t\t// for NULL\n#include \"misc.h\"\n#include \"hrtimer.h\"\n#include \"pch.h\"\n\nTimerBase {\n  void TimerBase::StartTimer()\n  {\n  \tm_last = m_start = GetCurrentTimerValue();\n  \tm_started = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.Final",
          "args": [
            "buffer"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash.DigestSize",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.Update",
          "args": [
            "salt",
            "saltLen"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "Update",
          "container": "Adler32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/adler32.cpp",
          "lines": "8-54",
          "snippet": "void Adler32::Update(const byte *input, size_t length)\n{\n\tconst unsigned long BASE = 65521;\n\n\tunsigned long s1 = m_s1;\n\tunsigned long s2 = m_s2;\n\n\tif (length % 8 != 0)\n\t{\n\t\tdo\n\t\t{\n\t\t\ts1 += *input++;\n\t\t\ts2 += s1;\n\t\t\tlength--;\n\t\t} while (length % 8 != 0);\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\ts2 %= BASE;\n\t}\n\n\twhile (length > 0)\n\t{\n\t\ts1 += input[0]; s2 += s1;\n\t\ts1 += input[1]; s2 += s1;\n\t\ts1 += input[2]; s2 += s1;\n\t\ts1 += input[3]; s2 += s1;\n\t\ts1 += input[4]; s2 += s1;\n\t\ts1 += input[5]; s2 += s1;\n\t\ts1 += input[6]; s2 += s1;\n\t\ts1 += input[7]; s2 += s1;\n\n\t\tlength -= 8;\n\t\tinput += 8;\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\tif (length % 0x8000 == 0)\n\t\t\ts2 %= BASE;\n\t}\n\n\tassert(s1 < BASE);\n\tassert(s2 < BASE);\n\n\tm_s1 = (word16)s1;\n\tm_s2 = (word16)s2;\n}",
          "includes": [
            "#include \"adler32.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adler32.h\"\n#include \"pch.h\"\n\nAdler32 {\n  void Adler32::Update(const byte *input, size_t length)\n  {\n  \tconst unsigned long BASE = 65521;\n  \n  \tunsigned long s1 = m_s1;\n  \tunsigned long s2 = m_s2;\n  \n  \tif (length % 8 != 0)\n  \t{\n  \t\tdo\n  \t\t{\n  \t\t\ts1 += *input++;\n  \t\t\ts2 += s1;\n  \t\t\tlength--;\n  \t\t} while (length % 8 != 0);\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\ts2 %= BASE;\n  \t}\n  \n  \twhile (length > 0)\n  \t{\n  \t\ts1 += input[0]; s2 += s1;\n  \t\ts1 += input[1]; s2 += s1;\n  \t\ts1 += input[2]; s2 += s1;\n  \t\ts1 += input[3]; s2 += s1;\n  \t\ts1 += input[4]; s2 += s1;\n  \t\ts1 += input[5]; s2 += s1;\n  \t\ts1 += input[6]; s2 += s1;\n  \t\ts1 += input[7]; s2 += s1;\n  \n  \t\tlength -= 8;\n  \t\tinput += 8;\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\tif (length % 0x8000 == 0)\n  \t\t\ts2 %= BASE;\n  \t}\n  \n  \tassert(s1 < BASE);\n  \tassert(s2 < BASE);\n  \n  \tm_s1 = (word16)s1;\n  \tm_s2 = (word16)s2;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "iterations > 0 || timeInSeconds > 0"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "derivedLen <= MaxDerivedKeyLength()"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MaxDerivedKeyLength",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "MaxDerivedKeyLength",
          "container": "PKCS12_PBKDF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pwdbased.h",
          "lines": "144-144",
          "snippet": "size_t MaxDerivedKeyLength() const {return size_t(0)-1;}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"hrtimer.h\"",
            "#include \"hmac.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"hrtimer.h\"\n#include \"hmac.h\"\n#include \"cryptlib.h\"\n\nPKCS12_PBKDF {\n  size_t MaxDerivedKeyLength() const {return size_t(0)-1;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"integer.h\"\n#include \"hrtimer.h\"\n#include \"hmac.h\"\n#include \"cryptlib.h\"\n\nPKCS5_PBKDF1<T> {\n  unsigned int PKCS5_PBKDF1<T>::DeriveKey(byte *derived, size_t derivedLen, byte purpose, const byte *password, size_t passwordLen, const byte *salt, size_t saltLen, unsigned int iterations, double timeInSeconds) const\n  {\n  \tassert(derivedLen <= MaxDerivedKeyLength());\n  \tassert(iterations > 0 || timeInSeconds > 0);\n  \n  \tif (!iterations)\n  \t\titerations = 1;\n  \n  \tT hash;\n  \thash.Update(password, passwordLen);\n  \thash.Update(salt, saltLen);\n  \n  \tSecByteBlock buffer(hash.DigestSize());\n  \thash.Final(buffer);\n  \n  \tunsigned int i;\n  \tThreadUserTimer timer;\n  \n  \tif (timeInSeconds)\n  \t\ttimer.StartTimer();\n  \n  \tfor (i=1; i<iterations || (timeInSeconds && (i%128!=0 || timer.ElapsedTimeAsDouble() < timeInSeconds)); i++)\n  \t\thash.CalculateDigest(buffer, buffer, buffer.size());\n  \n  \tmemcpy(derived, buffer, derivedLen);\n  \treturn i;\n  }\n}"
  },
  {
    "function_name": "UsesPurposeByte",
    "container": "PKCS5_PBKDF2_HMAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pwdbased.h",
    "lines": "42-42",
    "snippet": "bool UsesPurposeByte() const {return false;}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"hrtimer.h\"",
      "#include \"hmac.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"integer.h\"\n#include \"hrtimer.h\"\n#include \"hmac.h\"\n#include \"cryptlib.h\"\n\nPKCS5_PBKDF2_HMAC {\n  bool UsesPurposeByte() const {return false;}\n}"
  },
  {
    "function_name": "MaxDerivedKeyLength",
    "container": "PKCS5_PBKDF2_HMAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pwdbased.h",
    "lines": "41-41",
    "snippet": "size_t MaxDerivedKeyLength() const {return 0xffffffffU;}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"hrtimer.h\"",
      "#include \"hmac.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"integer.h\"\n#include \"hrtimer.h\"\n#include \"hmac.h\"\n#include \"cryptlib.h\"\n\nPKCS5_PBKDF2_HMAC {\n  size_t MaxDerivedKeyLength() const {return 0xffffffffU;}\n}"
  },
  {
    "function_name": "UsesPurposeByte",
    "container": "PKCS5_PBKDF1",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pwdbased.h",
    "lines": "31-31",
    "snippet": "bool UsesPurposeByte() const {return false;}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"hrtimer.h\"",
      "#include \"hmac.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"integer.h\"\n#include \"hrtimer.h\"\n#include \"hmac.h\"\n#include \"cryptlib.h\"\n\nPKCS5_PBKDF1 {\n  bool UsesPurposeByte() const {return false;}\n}"
  },
  {
    "function_name": "MaxDerivedKeyLength",
    "container": "PKCS5_PBKDF1",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pwdbased.h",
    "lines": "30-30",
    "snippet": "size_t MaxDerivedKeyLength() const {return T::DIGESTSIZE;}",
    "includes": [
      "#include \"integer.h\"",
      "#include \"hrtimer.h\"",
      "#include \"hmac.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"integer.h\"\n#include \"hrtimer.h\"\n#include \"hmac.h\"\n#include \"cryptlib.h\"\n\nPKCS5_PBKDF1 {\n  size_t MaxDerivedKeyLength() const {return T::DIGESTSIZE;}\n}"
  }
]