[
  {
    "function_name": "DetectX86Features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.cpp",
    "lines": "149-193",
    "snippet": "void DetectX86Features()\n{\n\tword32 cpuid[4], cpuid1[4];\n\tif (!CpuId(0, cpuid))\n\t\treturn;\n\tif (!CpuId(1, cpuid1))\n\t\treturn;\n\n\tg_hasMMX = (cpuid1[3] & (1 << 23)) != 0;\n\tif ((cpuid1[3] & (1 << 26)) != 0)\n\t\tg_hasSSE2 = TrySSE2();\n\tg_hasSSSE3 = g_hasSSE2 && (cpuid1[2] & (1<<9));\n\tg_hasAESNI = g_hasSSE2 && (cpuid1[2] & (1<<25));\n\tg_hasCLMUL = g_hasSSE2 && (cpuid1[2] & (1<<1));\n\n\tif ((cpuid1[3] & (1 << 25)) != 0)\n\t\tg_hasISSE = true;\n\telse\n\t{\n\t\tword32 cpuid2[4];\n\t\tCpuId(0x080000000, cpuid2);\n\t\tif (cpuid2[0] >= 0x080000001)\n\t\t{\n\t\t\tCpuId(0x080000001, cpuid2);\n\t\t\tg_hasISSE = (cpuid2[3] & (1 << 22)) != 0;\n\t\t}\n\t}\n\n\tstd::swap(cpuid[2], cpuid[3]);\n\tif (memcmp(cpuid+1, \"GenuineIntel\", 12) == 0)\n\t{\n\t\tg_isP4 = ((cpuid1[0] >> 8) & 0xf) == 0xf;\n\t\tg_cacheLineSize = 8 * GETBYTE(cpuid1[1], 1);\n\t}\n\telse if (memcmp(cpuid+1, \"AuthenticAMD\", 12) == 0)\n\t{\n\t\tCpuId(0x80000005, cpuid);\n\t\tg_cacheLineSize = GETBYTE(cpuid[2], 0);\n\t}\n\n\tif (!g_cacheLineSize)\n\t\tg_cacheLineSize = CRYPTOPP_L1_CACHE_LINE_SIZE;\n\n\tg_x86DetectionDone = true;\n}",
    "includes": [
      "#include <emmintrin.h>",
      "#include <setjmp.h>",
      "#include <signal.h>",
      "#include <algorithm>",
      "#include \"misc.h\"",
      "#include \"cpu.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "cpuid[2]",
            "0"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CpuId",
          "args": [
            "0x80000005",
            "cpuid"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "CpuId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.cpp",
          "lines": "52-99",
          "snippet": "bool CpuId(word32 input, word32 *output)\n{\n#ifdef CRYPTOPP_MS_STYLE_INLINE_ASSEMBLY\n    __try\n\t{\n\t\t__asm\n\t\t{\n\t\t\tmov eax, input\n\t\t\tcpuid\n\t\t\tmov edi, output\n\t\t\tmov [edi], eax\n\t\t\tmov [edi+4], ebx\n\t\t\tmov [edi+8], ecx\n\t\t\tmov [edi+12], edx\n\t\t}\n\t}\n    __except (1)\n\t{\n\t\treturn false;\n    }\n\treturn true;\n#else\n\tSigHandler oldHandler = signal(SIGILL, SigIllHandlerCPUID);\n\tif (oldHandler == SIG_ERR)\n\t\treturn false;\n\n\tbool result = true;\n\tif (setjmp(s_jmpNoCPUID))\n\t\tresult = false;\n\telse\n\t{\n\t\tasm\n\t\t(\n\t\t\t// save ebx in case -fPIC is being used\n#if CRYPTOPP_BOOL_X86\n\t\t\t\"push %%ebx; cpuid; mov %%ebx, %%edi; pop %%ebx\"\n#else\n\t\t\t\"pushq %%rbx; cpuid; mov %%ebx, %%edi; popq %%rbx\"\n#endif\n\t\t\t: \"=a\" (output[0]), \"=D\" (output[1]), \"=c\" (output[2]), \"=d\" (output[3])\n\t\t\t: \"a\" (input)\n\t\t);\n\t}\n\n\tsignal(SIGILL, oldHandler);\n\treturn result;\n#endif\n}",
          "includes": [
            "#include <emmintrin.h>",
            "#include <setjmp.h>",
            "#include <signal.h>",
            "#include <algorithm>",
            "#include \"misc.h\"",
            "#include \"cpu.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <emmintrin.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <algorithm>\n#include \"misc.h\"\n#include \"cpu.h\"\n#include \"pch.h\"\n\nbool CpuId(word32 input, word32 *output)\n{\n#ifdef CRYPTOPP_MS_STYLE_INLINE_ASSEMBLY\n    __try\n\t{\n\t\t__asm\n\t\t{\n\t\t\tmov eax, input\n\t\t\tcpuid\n\t\t\tmov edi, output\n\t\t\tmov [edi], eax\n\t\t\tmov [edi+4], ebx\n\t\t\tmov [edi+8], ecx\n\t\t\tmov [edi+12], edx\n\t\t}\n\t}\n    __except (1)\n\t{\n\t\treturn false;\n    }\n\treturn true;\n#else\n\tSigHandler oldHandler = signal(SIGILL, SigIllHandlerCPUID);\n\tif (oldHandler == SIG_ERR)\n\t\treturn false;\n\n\tbool result = true;\n\tif (setjmp(s_jmpNoCPUID))\n\t\tresult = false;\n\telse\n\t{\n\t\tasm\n\t\t(\n\t\t\t// save ebx in case -fPIC is being used\n#if CRYPTOPP_BOOL_X86\n\t\t\t\"push %%ebx; cpuid; mov %%ebx, %%edi; pop %%ebx\"\n#else\n\t\t\t\"pushq %%rbx; cpuid; mov %%ebx, %%edi; popq %%rbx\"\n#endif\n\t\t\t: \"=a\" (output[0]), \"=D\" (output[1]), \"=c\" (output[2]), \"=d\" (output[3])\n\t\t\t: \"a\" (input)\n\t\t);\n\t}\n\n\tsignal(SIGILL, oldHandler);\n\treturn result;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "cpuid+1",
            "\"AuthenticAMD\"",
            "12"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "cpuid1[1]",
            "1"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "cpuid+1",
            "\"GenuineIntel\"",
            "12"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::swap",
          "args": [
            "cpuid[2]",
            "cpuid[3]"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "453-456",
          "snippet": "inline void swap(CryptoPP::PolynomialOverFixedRing<T,i> &a, CryptoPP::PolynomialOverFixedRing<T,i> &b)\n{\n\ta.swap(b);\n}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\ninline void swap(CryptoPP::PolynomialOverFixedRing<T,i> &a, CryptoPP::PolynomialOverFixedRing<T,i> &b)\n{\n\ta.swap(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TrySSE2",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "TrySSE2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.cpp",
          "lines": "103-143",
          "snippet": "static bool TrySSE2()\n{\n#if CRYPTOPP_BOOL_X64\n\treturn true;\n#elif defined(CRYPTOPP_MS_STYLE_INLINE_ASSEMBLY)\n    __try\n\t{\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n        AS2(por xmm0, xmm0)        // executing SSE2 instruction\n#elif CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE\n\t\t__m128i x = _mm_setzero_si128();\n\t\treturn _mm_cvtsi128_si32(x) == 0;\n#endif\n\t}\n    __except (1)\n\t{\n\t\treturn false;\n    }\n\treturn true;\n#else\n\tSigHandler oldHandler = signal(SIGILL, SigIllHandlerSSE2);\n\tif (oldHandler == SIG_ERR)\n\t\treturn false;\n\n\tbool result = true;\n\tif (setjmp(s_jmpNoSSE2))\n\t\tresult = false;\n\telse\n\t{\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n\t\t__asm __volatile (\"por %xmm0, %xmm0\");\n#elif CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE\n\t\t__m128i x = _mm_setzero_si128();\n\t\tresult = _mm_cvtsi128_si32(x) == 0;\n#endif\n\t}\n\n\tsignal(SIGILL, oldHandler);\n\treturn result;\n#endif\n}",
          "includes": [
            "#include <emmintrin.h>",
            "#include <setjmp.h>",
            "#include <signal.h>",
            "#include <algorithm>",
            "#include \"misc.h\"",
            "#include \"cpu.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <emmintrin.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <algorithm>\n#include \"misc.h\"\n#include \"cpu.h\"\n#include \"pch.h\"\n\nstatic bool TrySSE2()\n{\n#if CRYPTOPP_BOOL_X64\n\treturn true;\n#elif defined(CRYPTOPP_MS_STYLE_INLINE_ASSEMBLY)\n    __try\n\t{\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n        AS2(por xmm0, xmm0)        // executing SSE2 instruction\n#elif CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE\n\t\t__m128i x = _mm_setzero_si128();\n\t\treturn _mm_cvtsi128_si32(x) == 0;\n#endif\n\t}\n    __except (1)\n\t{\n\t\treturn false;\n    }\n\treturn true;\n#else\n\tSigHandler oldHandler = signal(SIGILL, SigIllHandlerSSE2);\n\tif (oldHandler == SIG_ERR)\n\t\treturn false;\n\n\tbool result = true;\n\tif (setjmp(s_jmpNoSSE2))\n\t\tresult = false;\n\telse\n\t{\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n\t\t__asm __volatile (\"por %xmm0, %xmm0\");\n#elif CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE\n\t\t__m128i x = _mm_setzero_si128();\n\t\tresult = _mm_cvtsi128_si32(x) == 0;\n#endif\n\t}\n\n\tsignal(SIGILL, oldHandler);\n\treturn result;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <emmintrin.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <algorithm>\n#include \"misc.h\"\n#include \"cpu.h\"\n#include \"pch.h\"\n\nvoid DetectX86Features()\n{\n\tword32 cpuid[4], cpuid1[4];\n\tif (!CpuId(0, cpuid))\n\t\treturn;\n\tif (!CpuId(1, cpuid1))\n\t\treturn;\n\n\tg_hasMMX = (cpuid1[3] & (1 << 23)) != 0;\n\tif ((cpuid1[3] & (1 << 26)) != 0)\n\t\tg_hasSSE2 = TrySSE2();\n\tg_hasSSSE3 = g_hasSSE2 && (cpuid1[2] & (1<<9));\n\tg_hasAESNI = g_hasSSE2 && (cpuid1[2] & (1<<25));\n\tg_hasCLMUL = g_hasSSE2 && (cpuid1[2] & (1<<1));\n\n\tif ((cpuid1[3] & (1 << 25)) != 0)\n\t\tg_hasISSE = true;\n\telse\n\t{\n\t\tword32 cpuid2[4];\n\t\tCpuId(0x080000000, cpuid2);\n\t\tif (cpuid2[0] >= 0x080000001)\n\t\t{\n\t\t\tCpuId(0x080000001, cpuid2);\n\t\t\tg_hasISSE = (cpuid2[3] & (1 << 22)) != 0;\n\t\t}\n\t}\n\n\tstd::swap(cpuid[2], cpuid[3]);\n\tif (memcmp(cpuid+1, \"GenuineIntel\", 12) == 0)\n\t{\n\t\tg_isP4 = ((cpuid1[0] >> 8) & 0xf) == 0xf;\n\t\tg_cacheLineSize = 8 * GETBYTE(cpuid1[1], 1);\n\t}\n\telse if (memcmp(cpuid+1, \"AuthenticAMD\", 12) == 0)\n\t{\n\t\tCpuId(0x80000005, cpuid);\n\t\tg_cacheLineSize = GETBYTE(cpuid[2], 0);\n\t}\n\n\tif (!g_cacheLineSize)\n\t\tg_cacheLineSize = CRYPTOPP_L1_CACHE_LINE_SIZE;\n\n\tg_x86DetectionDone = true;\n}"
  },
  {
    "function_name": "TrySSE2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.cpp",
    "lines": "103-143",
    "snippet": "static bool TrySSE2()\n{\n#if CRYPTOPP_BOOL_X64\n\treturn true;\n#elif defined(CRYPTOPP_MS_STYLE_INLINE_ASSEMBLY)\n    __try\n\t{\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n        AS2(por xmm0, xmm0)        // executing SSE2 instruction\n#elif CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE\n\t\t__m128i x = _mm_setzero_si128();\n\t\treturn _mm_cvtsi128_si32(x) == 0;\n#endif\n\t}\n    __except (1)\n\t{\n\t\treturn false;\n    }\n\treturn true;\n#else\n\tSigHandler oldHandler = signal(SIGILL, SigIllHandlerSSE2);\n\tif (oldHandler == SIG_ERR)\n\t\treturn false;\n\n\tbool result = true;\n\tif (setjmp(s_jmpNoSSE2))\n\t\tresult = false;\n\telse\n\t{\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n\t\t__asm __volatile (\"por %xmm0, %xmm0\");\n#elif CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE\n\t\t__m128i x = _mm_setzero_si128();\n\t\tresult = _mm_cvtsi128_si32(x) == 0;\n#endif\n\t}\n\n\tsignal(SIGILL, oldHandler);\n\treturn result;\n#endif\n}",
    "includes": [
      "#include <emmintrin.h>",
      "#include <setjmp.h>",
      "#include <signal.h>",
      "#include <algorithm>",
      "#include \"misc.h\"",
      "#include \"cpu.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGILL",
            "oldHandler"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_cvtsi128_si32",
          "args": [
            "x"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_setzero_si128",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__volatile",
          "args": [
            "\"por %xmm0, %xmm0\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setjmp",
          "args": [
            "s_jmpNoSSE2"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGILL",
            "SigIllHandlerSSE2"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_cvtsi128_si32",
          "args": [
            "x"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_setzero_si128",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <emmintrin.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <algorithm>\n#include \"misc.h\"\n#include \"cpu.h\"\n#include \"pch.h\"\n\nstatic bool TrySSE2()\n{\n#if CRYPTOPP_BOOL_X64\n\treturn true;\n#elif defined(CRYPTOPP_MS_STYLE_INLINE_ASSEMBLY)\n    __try\n\t{\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n        AS2(por xmm0, xmm0)        // executing SSE2 instruction\n#elif CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE\n\t\t__m128i x = _mm_setzero_si128();\n\t\treturn _mm_cvtsi128_si32(x) == 0;\n#endif\n\t}\n    __except (1)\n\t{\n\t\treturn false;\n    }\n\treturn true;\n#else\n\tSigHandler oldHandler = signal(SIGILL, SigIllHandlerSSE2);\n\tif (oldHandler == SIG_ERR)\n\t\treturn false;\n\n\tbool result = true;\n\tif (setjmp(s_jmpNoSSE2))\n\t\tresult = false;\n\telse\n\t{\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\n\t\t__asm __volatile (\"por %xmm0, %xmm0\");\n#elif CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE\n\t\t__m128i x = _mm_setzero_si128();\n\t\tresult = _mm_cvtsi128_si32(x) == 0;\n#endif\n\t}\n\n\tsignal(SIGILL, oldHandler);\n\treturn result;\n#endif\n}"
  },
  {
    "function_name": "CpuId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.cpp",
    "lines": "52-99",
    "snippet": "bool CpuId(word32 input, word32 *output)\n{\n#ifdef CRYPTOPP_MS_STYLE_INLINE_ASSEMBLY\n    __try\n\t{\n\t\t__asm\n\t\t{\n\t\t\tmov eax, input\n\t\t\tcpuid\n\t\t\tmov edi, output\n\t\t\tmov [edi], eax\n\t\t\tmov [edi+4], ebx\n\t\t\tmov [edi+8], ecx\n\t\t\tmov [edi+12], edx\n\t\t}\n\t}\n    __except (1)\n\t{\n\t\treturn false;\n    }\n\treturn true;\n#else\n\tSigHandler oldHandler = signal(SIGILL, SigIllHandlerCPUID);\n\tif (oldHandler == SIG_ERR)\n\t\treturn false;\n\n\tbool result = true;\n\tif (setjmp(s_jmpNoCPUID))\n\t\tresult = false;\n\telse\n\t{\n\t\tasm\n\t\t(\n\t\t\t// save ebx in case -fPIC is being used\n#if CRYPTOPP_BOOL_X86\n\t\t\t\"push %%ebx; cpuid; mov %%ebx, %%edi; pop %%ebx\"\n#else\n\t\t\t\"pushq %%rbx; cpuid; mov %%ebx, %%edi; popq %%rbx\"\n#endif\n\t\t\t: \"=a\" (output[0]), \"=D\" (output[1]), \"=c\" (output[2]), \"=d\" (output[3])\n\t\t\t: \"a\" (input)\n\t\t);\n\t}\n\n\tsignal(SIGILL, oldHandler);\n\treturn result;\n#endif\n}",
    "includes": [
      "#include <emmintrin.h>",
      "#include <setjmp.h>",
      "#include <signal.h>",
      "#include <algorithm>",
      "#include \"misc.h\"",
      "#include \"cpu.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGILL",
            "oldHandler"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setjmp",
          "args": [
            "s_jmpNoCPUID"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGILL",
            "SigIllHandlerCPUID"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <emmintrin.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <algorithm>\n#include \"misc.h\"\n#include \"cpu.h\"\n#include \"pch.h\"\n\nbool CpuId(word32 input, word32 *output)\n{\n#ifdef CRYPTOPP_MS_STYLE_INLINE_ASSEMBLY\n    __try\n\t{\n\t\t__asm\n\t\t{\n\t\t\tmov eax, input\n\t\t\tcpuid\n\t\t\tmov edi, output\n\t\t\tmov [edi], eax\n\t\t\tmov [edi+4], ebx\n\t\t\tmov [edi+8], ecx\n\t\t\tmov [edi+12], edx\n\t\t}\n\t}\n    __except (1)\n\t{\n\t\treturn false;\n    }\n\treturn true;\n#else\n\tSigHandler oldHandler = signal(SIGILL, SigIllHandlerCPUID);\n\tif (oldHandler == SIG_ERR)\n\t\treturn false;\n\n\tbool result = true;\n\tif (setjmp(s_jmpNoCPUID))\n\t\tresult = false;\n\telse\n\t{\n\t\tasm\n\t\t(\n\t\t\t// save ebx in case -fPIC is being used\n#if CRYPTOPP_BOOL_X86\n\t\t\t\"push %%ebx; cpuid; mov %%ebx, %%edi; pop %%ebx\"\n#else\n\t\t\t\"pushq %%rbx; cpuid; mov %%ebx, %%edi; popq %%rbx\"\n#endif\n\t\t\t: \"=a\" (output[0]), \"=D\" (output[1]), \"=c\" (output[2]), \"=d\" (output[3])\n\t\t\t: \"a\" (input)\n\t\t);\n\t}\n\n\tsignal(SIGILL, oldHandler);\n\treturn result;\n#endif\n}"
  },
  {
    "function_name": "SigIllHandlerSSE2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.cpp",
    "lines": "45-48",
    "snippet": "static void SigIllHandlerSSE2(int)\n{\n\tlongjmp(s_jmpNoSSE2, 1);\n}",
    "includes": [
      "#include <emmintrin.h>",
      "#include <setjmp.h>",
      "#include <signal.h>",
      "#include <algorithm>",
      "#include \"misc.h\"",
      "#include \"cpu.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "longjmp",
          "args": [
            "s_jmpNoSSE2",
            "1"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <emmintrin.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <algorithm>\n#include \"misc.h\"\n#include \"cpu.h\"\n#include \"pch.h\"\n\nstatic void SigIllHandlerSSE2(int)\n{\n\tlongjmp(s_jmpNoSSE2, 1);\n}"
  },
  {
    "function_name": "SigIllHandlerCPUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.cpp",
    "lines": "39-42",
    "snippet": "static void SigIllHandlerCPUID(int)\n{\n\tlongjmp(s_jmpNoCPUID, 1);\n}",
    "includes": [
      "#include <emmintrin.h>",
      "#include <setjmp.h>",
      "#include <signal.h>",
      "#include <algorithm>",
      "#include \"misc.h\"",
      "#include \"cpu.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "longjmp",
          "args": [
            "s_jmpNoCPUID",
            "1"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <emmintrin.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <algorithm>\n#include \"misc.h\"\n#include \"cpu.h\"\n#include \"pch.h\"\n\nstatic void SigIllHandlerCPUID(int)\n{\n\tlongjmp(s_jmpNoCPUID, 1);\n}"
  },
  {
    "function_name": "CpuId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.cpp",
    "lines": "26-30",
    "snippet": "bool CpuId(word32 input, word32 *output)\n{\n\t__cpuid((int *)output, input);\n\treturn true;\n}",
    "includes": [
      "#include <emmintrin.h>",
      "#include <setjmp.h>",
      "#include <signal.h>",
      "#include <algorithm>",
      "#include \"misc.h\"",
      "#include \"cpu.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cpuid",
          "args": [
            "(int *)output",
            "input"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <emmintrin.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <algorithm>\n#include \"misc.h\"\n#include \"cpu.h\"\n#include \"pch.h\"\n\nbool CpuId(word32 input, word32 *output)\n{\n\t__cpuid((int *)output, input);\n\treturn true;\n}"
  }
]