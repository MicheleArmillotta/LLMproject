[
  {
    "function_name": "AssignFrom",
    "container": "InvertibleRWFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
    "lines": "185-192",
    "snippet": "void InvertibleRWFunction::AssignFrom(const NameValuePairs &source)\n{\n\tAssignFromHelper<RWFunction>(this, source)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime1)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime2)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n\t\t;\n}",
    "includes": [
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rw.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "MultiplicativeInverseOfPrime2ModPrime1"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "Prime2"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "Prime1"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssignFromHelper<RWFunction>",
          "args": [
            "this",
            "source"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "AssignFromHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "235-238",
          "snippet": "AssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nInvertibleRWFunction {\n  void InvertibleRWFunction::AssignFrom(const NameValuePairs &source)\n  {\n  \tAssignFromHelper<RWFunction>(this, source)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime1)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime2)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n  \t\t;\n  }\n}"
  },
  {
    "function_name": "GetVoidValue",
    "container": "InvertibleRWFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
    "lines": "176-183",
    "snippet": "bool InvertibleRWFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n{\n\treturn GetValueHelper<RWFunction>(this, name, valueType, pValue).Assignable()\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Prime1)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Prime2)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n\t\t;\n}",
    "includes": [
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rw.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "MultiplicativeInverseOfPrime2ModPrime1"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "Prime2"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "Prime1"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper<RWFunction>",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper<RWFunction>",
          "args": [
            "this",
            "name",
            "valueType",
            "pValue"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "GetValueHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "161-164",
          "snippet": "GetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nGetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nInvertibleRWFunction {\n  bool InvertibleRWFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n  {\n  \treturn GetValueHelper<RWFunction>(this, name, valueType, pValue).Assignable()\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(Prime1)\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(Prime2)\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n  \t\t;\n  }\n}"
  },
  {
    "function_name": "Validate",
    "container": "InvertibleRWFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
    "lines": "160-174",
    "snippet": "bool InvertibleRWFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = RWFunction::Validate(rng, level);\n\tpass = pass && m_p > Integer::One() && m_p%8 == 3 && m_p < m_n;\n\tpass = pass && m_q > Integer::One() && m_q%8 == 7 && m_q < m_n;\n\tpass = pass && m_u.IsPositive() && m_u < m_p;\n\tif (level >= 1)\n\t{\n\t\tpass = pass && m_p * m_q == m_n;\n\t\tpass = pass && m_u * m_q % m_p == 1;\n\t}\n\tif (level >= 2)\n\t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n\treturn pass;\n}",
    "includes": [
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rw.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VerifyPrime",
          "args": [
            "rng",
            "m_q",
            "level-2"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "VerifyPrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "247-253",
          "snippet": "bool VerifyPrime(RandomNumberGenerator &rng, const Integer &p, unsigned int level)\n{\n\tbool pass = IsPrime(p) && RabinMillerTest(rng, p, 1);\n\tif (level >= 1)\n\t\tpass = pass && RabinMillerTest(rng, p, 10);\n\treturn pass;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool VerifyPrime(RandomNumberGenerator &rng, const Integer &p, unsigned int level)\n{\n\tbool pass = IsPrime(p) && RabinMillerTest(rng, p, 1);\n\tif (level >= 1)\n\t\tpass = pass && RabinMillerTest(rng, p, 10);\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_u.IsPositive",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "IsPositive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "205-205",
          "snippet": "bool IsPositive() const {return NotNegative() && NotZero();}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsPositive() const {return NotNegative() && NotZero();}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::One",
          "args": [],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "One",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "44-45",
          "snippet": "Element One() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element One() const\n  \t\t{return 1;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RWFunction::Validate",
          "args": [
            "rng",
            "level"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "Validate",
          "container": "InvertibleRWFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
          "lines": "160-174",
          "snippet": "bool InvertibleRWFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = RWFunction::Validate(rng, level);\n\tpass = pass && m_p > Integer::One() && m_p%8 == 3 && m_p < m_n;\n\tpass = pass && m_q > Integer::One() && m_q%8 == 7 && m_q < m_n;\n\tpass = pass && m_u.IsPositive() && m_u < m_p;\n\tif (level >= 1)\n\t{\n\t\tpass = pass && m_p * m_q == m_n;\n\t\tpass = pass && m_u * m_q % m_p == 1;\n\t}\n\tif (level >= 2)\n\t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n\treturn pass;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nInvertibleRWFunction {\n  bool InvertibleRWFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n  {\n  \tbool pass = RWFunction::Validate(rng, level);\n  \tpass = pass && m_p > Integer::One() && m_p%8 == 3 && m_p < m_n;\n  \tpass = pass && m_q > Integer::One() && m_q%8 == 7 && m_q < m_n;\n  \tpass = pass && m_u.IsPositive() && m_u < m_p;\n  \tif (level >= 1)\n  \t{\n  \t\tpass = pass && m_p * m_q == m_n;\n  \t\tpass = pass && m_u * m_q % m_p == 1;\n  \t}\n  \tif (level >= 2)\n  \t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n  \treturn pass;\n  }\n}"
  },
  {
    "function_name": "CalculateInverse",
    "container": "InvertibleRWFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
    "lines": "124-158",
    "snippet": "Integer InvertibleRWFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const\n{\n\tDoQuickSanityCheck();\n\tModularArithmetic modn(m_n);\n\tInteger r, rInv;\n\tdo {\t// do this in a loop for people using small numbers for testing\n\t\tr.Randomize(rng, Integer::One(), m_n - Integer::One());\n\t\trInv = modn.MultiplicativeInverse(r);\n\t} while (rInv.IsZero());\n\tInteger re = modn.Square(r);\n\tre = modn.Multiply(re, x);\t\t\t// blind\n\n\tInteger cp=re%m_p, cq=re%m_q;\n\tif (Jacobi(cp, m_p) * Jacobi(cq, m_q) != 1)\n\t{\n\t\tcp = cp.IsOdd() ? (cp+m_p) >> 1 : cp >> 1;\n\t\tcq = cq.IsOdd() ? (cq+m_q) >> 1 : cq >> 1;\n\t}\n\n\t#pragma omp parallel\n\t\t#pragma omp sections\n\t\t{\n\t\t\t#pragma omp section\n\t\t\t\tcp = ModularSquareRoot(cp, m_p);\n\t\t\t#pragma omp section\n\t\t\t\tcq = ModularSquareRoot(cq, m_q);\n\t\t}\n\n\tInteger y = CRT(cq, m_q, cp, m_p, m_u);\n\ty = modn.Multiply(y, rInv);\t\t\t\t// unblind\n\ty = STDMIN(y, m_n-y);\n\tif (ApplyFunction(y) != x)\t\t\t\t// check\n\t\tthrow Exception(Exception::OTHER_ERROR, \"InvertibleRWFunction: computational error during private key operation\");\n\treturn y;\n}",
    "includes": [
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rw.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Exception",
          "args": [
            "Exception::OTHER_ERROR",
            "\"InvertibleRWFunction: computational error during private key operation\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ApplyFunction",
          "args": [
            "y"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "ApplyFunction",
          "container": "RWFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
          "lines": "26-61",
          "snippet": "Integer RWFunction::ApplyFunction(const Integer &in) const\n{\n\tDoQuickSanityCheck();\n\n\tInteger out = in.Squared()%m_n;\n\tconst word r = 12;\n\t// this code was written to handle both r = 6 and r = 12,\n\t// but now only r = 12 is used in P1363\n\tconst word r2 = r/2;\n\tconst word r3a = (16 + 5 - r) % 16;\t// n%16 could be 5 or 13\n\tconst word r3b = (16 + 13 - r) % 16;\n\tconst word r4 = (8 + 5 - r/2) % 8;\t// n%8 == 5\n\tswitch (out % 16)\n\t{\n\tcase r:\n\t\tbreak;\n\tcase r2:\n\tcase r2+8:\n\t\tout <<= 1;\n\t\tbreak;\n\tcase r3a:\n\tcase r3b:\n\t\tout.Negate();\n\t\tout += m_n;\n\t\tbreak;\n\tcase r4:\n\tcase r4+8:\n\t\tout.Negate();\n\t\tout += m_n;\n\t\tout <<= 1;\n\t\tbreak;\n\tdefault:\n\t\tout = Integer::Zero();\n\t}\n\treturn out;\n}",
          "includes": [
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"rw.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nRWFunction {\n  Integer RWFunction::ApplyFunction(const Integer &in) const\n  {\n  \tDoQuickSanityCheck();\n  \n  \tInteger out = in.Squared()%m_n;\n  \tconst word r = 12;\n  \t// this code was written to handle both r = 6 and r = 12,\n  \t// but now only r = 12 is used in P1363\n  \tconst word r2 = r/2;\n  \tconst word r3a = (16 + 5 - r) % 16;\t// n%16 could be 5 or 13\n  \tconst word r3b = (16 + 13 - r) % 16;\n  \tconst word r4 = (8 + 5 - r/2) % 8;\t// n%8 == 5\n  \tswitch (out % 16)\n  \t{\n  \tcase r:\n  \t\tbreak;\n  \tcase r2:\n  \tcase r2+8:\n  \t\tout <<= 1;\n  \t\tbreak;\n  \tcase r3a:\n  \tcase r3b:\n  \t\tout.Negate();\n  \t\tout += m_n;\n  \t\tbreak;\n  \tcase r4:\n  \tcase r4+8:\n  \t\tout.Negate();\n  \t\tout += m_n;\n  \t\tout <<= 1;\n  \t\tbreak;\n  \tdefault:\n  \t\tout = Integer::Zero();\n  \t}\n  \treturn out;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "y",
            "m_n-y"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modn.Multiply",
          "args": [
            "y",
            "rInv"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "Multiply",
          "container": "Word",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "309-314",
          "snippet": "static Word Multiply(hword a, hword b)\n\t{\n\t\tWord r;\n\t\tr.m_whole = (word)a * b;\n\t\treturn r;\n\t}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nWord {\n  static Word Multiply(hword a, hword b)\n  \t{\n  \t\tWord r;\n  \t\tr.m_whole = (word)a * b;\n  \t\treturn r;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CRT",
          "args": [
            "cq",
            "m_q",
            "cp",
            "m_p",
            "m_u"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "CRT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "553-570",
          "snippet": "Integer CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u)\n{\n\t// isn't operator overloading great?\n\treturn p * (u * (xq-xp) % q) + xp;\n/*\n\tInteger t1 = xq-xp;\n\tcout << hex << t1 << endl;\n\tInteger t2 = u * t1;\n\tcout << hex << t2 << endl;\n\tInteger t3 = t2 % q;\n\tcout << hex << t3 << endl;\n\tInteger t4 = p * t3;\n\tcout << hex << t4 << endl;\n\tInteger t5 = t4 + xp;\n\tcout << hex << t5 << endl;\n\treturn t5;\n*/\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u)\n{\n\t// isn't operator overloading great?\n\treturn p * (u * (xq-xp) % q) + xp;\n/*\n\tInteger t1 = xq-xp;\n\tcout << hex << t1 << endl;\n\tInteger t2 = u * t1;\n\tcout << hex << t2 << endl;\n\tInteger t3 = t2 % q;\n\tcout << hex << t3 << endl;\n\tInteger t4 = p * t3;\n\tcout << hex << t4 << endl;\n\tInteger t5 = t4 + xp;\n\tcout << hex << t5 << endl;\n\treturn t5;\n*/\n}"
        }
      },
      {
        "call_info": {
          "callee": "ModularSquareRoot",
          "args": [
            "cq",
            "m_q"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "ModularSquareRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "572-619",
          "snippet": "Integer ModularSquareRoot(const Integer &a, const Integer &p)\n{\n\tif (p%4 == 3)\n\t\treturn a_exp_b_mod_c(a, (p+1)/4, p);\n\n\tInteger q=p-1;\n\tunsigned int r=0;\n\twhile (q.IsEven())\n\t{\n\t\tr++;\n\t\tq >>= 1;\n\t}\n\n\tInteger n=2;\n\twhile (Jacobi(n, p) != -1)\n\t\t++n;\n\n\tInteger y = a_exp_b_mod_c(n, q, p);\n\tInteger x = a_exp_b_mod_c(a, (q-1)/2, p);\n\tInteger b = (x.Squared()%p)*a%p;\n\tx = a*x%p;\n\tInteger tempb, t;\n\n\twhile (b != 1)\n\t{\n\t\tunsigned m=0;\n\t\ttempb = b;\n\t\tdo\n\t\t{\n\t\t\tm++;\n\t\t\tb = b.Squared()%p;\n\t\t\tif (m==r)\n\t\t\t\treturn Integer::Zero();\n\t\t}\n\t\twhile (b != 1);\n\n\t\tt = y;\n\t\tfor (unsigned i=0; i<r-m-1; i++)\n\t\t\tt = t.Squared()%p;\n\t\ty = t.Squared()%p;\n\t\tr = m;\n\t\tx = x*t%p;\n\t\tb = tempb*y%p;\n\t}\n\n\tassert(x.Squared()%p == a);\n\treturn x;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger ModularSquareRoot(const Integer &a, const Integer &p)\n{\n\tif (p%4 == 3)\n\t\treturn a_exp_b_mod_c(a, (p+1)/4, p);\n\n\tInteger q=p-1;\n\tunsigned int r=0;\n\twhile (q.IsEven())\n\t{\n\t\tr++;\n\t\tq >>= 1;\n\t}\n\n\tInteger n=2;\n\twhile (Jacobi(n, p) != -1)\n\t\t++n;\n\n\tInteger y = a_exp_b_mod_c(n, q, p);\n\tInteger x = a_exp_b_mod_c(a, (q-1)/2, p);\n\tInteger b = (x.Squared()%p)*a%p;\n\tx = a*x%p;\n\tInteger tempb, t;\n\n\twhile (b != 1)\n\t{\n\t\tunsigned m=0;\n\t\ttempb = b;\n\t\tdo\n\t\t{\n\t\t\tm++;\n\t\t\tb = b.Squared()%p;\n\t\t\tif (m==r)\n\t\t\t\treturn Integer::Zero();\n\t\t}\n\t\twhile (b != 1);\n\n\t\tt = y;\n\t\tfor (unsigned i=0; i<r-m-1; i++)\n\t\t\tt = t.Squared()%p;\n\t\ty = t.Squared()%p;\n\t\tr = m;\n\t\tx = x*t%p;\n\t\tb = tempb*y%p;\n\t}\n\n\tassert(x.Squared()%p == a);\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cq.IsOdd",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "IsOdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "211-211",
          "snippet": "bool IsOdd() const\t{return GetBit(0) == 1;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsOdd() const\t{return GetBit(0) == 1;}"
        }
      },
      {
        "call_info": {
          "callee": "Jacobi",
          "args": [
            "cq",
            "m_q"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "Jacobi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "785-810",
          "snippet": "int Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nint Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "modn.Square",
          "args": [
            "r"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "Square",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "49-50",
          "snippet": "Element Square(Element a) const\n\t\t{return Multiply(a, a);}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Square(Element a) const\n  \t\t{return Multiply(a, a);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rInv.IsZero",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "IsZero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "197-197",
          "snippet": "bool IsZero() const {return !*this;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsZero() const {return !*this;}"
        }
      },
      {
        "call_info": {
          "callee": "modn.MultiplicativeInverse",
          "args": [
            "r"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "MultiplicativeInverse",
          "container": "PolynomialOver<T>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.cpp",
          "lines": "325-328",
          "snippet": "PolynomialOver<T> PolynomialOver<T>::MultiplicativeInverse(const Ring &ring) const\n{\n\treturn Degree(ring)==0 ? ring.MultiplicativeInverse(m_coefficients[0]) : ring.Identity();\n}",
          "includes": [
            "#include <iostream>",
            "#include <sstream>",
            "#include \"secblock.h\"",
            "#include \"polynomi.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <sstream>\n#include \"secblock.h\"\n#include \"polynomi.h\"\n#include \"pch.h\"\n\nPolynomialOver<T> {\n  PolynomialOver<T> PolynomialOver<T>::MultiplicativeInverse(const Ring &ring) const\n  {\n  \treturn Degree(ring)==0 ? ring.MultiplicativeInverse(m_coefficients[0]) : ring.Identity();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r.Randomize",
          "args": [
            "rng",
            "Integer::One()",
            "m_n - Integer::One()"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "Randomize",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3210-3225",
          "snippet": "void Integer::Randomize(RandomNumberGenerator &rng, const Integer &min, const Integer &max)\n{\n\tif (min > max)\n\t\tthrow InvalidArgument(\"Integer: Min must be no greater than Max\");\n\n\tInteger range = max - min;\n\tconst unsigned int nbits = range.BitCount();\n\n\tdo\n\t{\n\t\tRandomize(rng, nbits);\n\t}\n\twhile (*this > range);\n\n\t*this += min;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  void Integer::Randomize(RandomNumberGenerator &rng, const Integer &min, const Integer &max)\n  {\n  \tif (min > max)\n  \t\tthrow InvalidArgument(\"Integer: Min must be no greater than Max\");\n  \n  \tInteger range = max - min;\n  \tconst unsigned int nbits = range.BitCount();\n  \n  \tdo\n  \t{\n  \t\tRandomize(rng, nbits);\n  \t}\n  \twhile (*this > range);\n  \n  \t*this += min;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::One",
          "args": [],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "One",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "44-45",
          "snippet": "Element One() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element One() const\n  \t\t{return 1;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoQuickSanityCheck",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nInvertibleRWFunction {\n  Integer InvertibleRWFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const\n  {\n  \tDoQuickSanityCheck();\n  \tModularArithmetic modn(m_n);\n  \tInteger r, rInv;\n  \tdo {\t// do this in a loop for people using small numbers for testing\n  \t\tr.Randomize(rng, Integer::One(), m_n - Integer::One());\n  \t\trInv = modn.MultiplicativeInverse(r);\n  \t} while (rInv.IsZero());\n  \tInteger re = modn.Square(r);\n  \tre = modn.Multiply(re, x);\t\t\t// blind\n  \n  \tInteger cp=re%m_p, cq=re%m_q;\n  \tif (Jacobi(cp, m_p) * Jacobi(cq, m_q) != 1)\n  \t{\n  \t\tcp = cp.IsOdd() ? (cp+m_p) >> 1 : cp >> 1;\n  \t\tcq = cq.IsOdd() ? (cq+m_q) >> 1 : cq >> 1;\n  \t}\n  \n  \t#pragma omp parallel\n  \t\t#pragma omp sections\n  \t\t{\n  \t\t\t#pragma omp section\n  \t\t\t\tcp = ModularSquareRoot(cp, m_p);\n  \t\t\t#pragma omp section\n  \t\t\t\tcq = ModularSquareRoot(cq, m_q);\n  \t\t}\n  \n  \tInteger y = CRT(cq, m_q, cp, m_p, m_u);\n  \ty = modn.Multiply(y, rInv);\t\t\t\t// unblind\n  \ty = STDMIN(y, m_n-y);\n  \tif (ApplyFunction(y) != x)\t\t\t\t// check\n  \t\tthrow Exception(Exception::OTHER_ERROR, \"InvertibleRWFunction: computational error during private key operation\");\n  \treturn y;\n  }\n}"
  },
  {
    "function_name": "DEREncode",
    "container": "InvertibleRWFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
    "lines": "114-122",
    "snippet": "void InvertibleRWFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\tm_n.DEREncode(seq);\n\tm_p.DEREncode(seq);\n\tm_q.DEREncode(seq);\n\tm_u.DEREncode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rw.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_u.DEREncode",
          "args": [
            "seq"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncode",
          "container": "InvertibleRWFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
          "lines": "114-122",
          "snippet": "void InvertibleRWFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\tm_n.DEREncode(seq);\n\tm_p.DEREncode(seq);\n\tm_q.DEREncode(seq);\n\tm_u.DEREncode(seq);\n\tseq.MessageEnd();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nInvertibleRWFunction {\n  void InvertibleRWFunction::DEREncode(BufferedTransformation &bt) const\n  {\n  \tDERSequenceEncoder seq(bt);\n  \tm_n.DEREncode(seq);\n  \tm_p.DEREncode(seq);\n  \tm_q.DEREncode(seq);\n  \tm_u.DEREncode(seq);\n  \tseq.MessageEnd();\n  }\n}"
  },
  {
    "function_name": "BERDecode",
    "container": "InvertibleRWFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
    "lines": "104-112",
    "snippet": "void InvertibleRWFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\tm_n.BERDecode(seq);\n\tm_p.BERDecode(seq);\n\tm_q.BERDecode(seq);\n\tm_u.BERDecode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rw.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_u.BERDecode",
          "args": [
            "seq"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecode",
          "container": "InvertibleRWFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
          "lines": "104-112",
          "snippet": "void InvertibleRWFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\tm_n.BERDecode(seq);\n\tm_p.BERDecode(seq);\n\tm_q.BERDecode(seq);\n\tm_u.BERDecode(seq);\n\tseq.MessageEnd();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nInvertibleRWFunction {\n  void InvertibleRWFunction::BERDecode(BufferedTransformation &bt)\n  {\n  \tBERSequenceDecoder seq(bt);\n  \tm_n.BERDecode(seq);\n  \tm_p.BERDecode(seq);\n  \tm_q.BERDecode(seq);\n  \tm_u.BERDecode(seq);\n  \tseq.MessageEnd();\n  }\n}"
  },
  {
    "function_name": "GenerateRandom",
    "container": "InvertibleRWFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
    "lines": "88-102",
    "snippet": "void InvertibleRWFunction::GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &alg)\n{\n\tint modulusSize = 2048;\n\talg.GetIntValue(\"ModulusSize\", modulusSize) || alg.GetIntValue(\"KeySize\", modulusSize);\n\n\tif (modulusSize < 16)\n\t\tthrow InvalidArgument(\"InvertibleRWFunction: specified modulus length is too small\");\n\n\tAlgorithmParameters primeParam = MakeParametersForTwoPrimesOfEqualSize(modulusSize);\n\tm_p.GenerateRandom(rng, CombinedNameValuePairs(primeParam, MakeParameters(\"EquivalentTo\", 3)(\"Mod\", 8)));\n\tm_q.GenerateRandom(rng, CombinedNameValuePairs(primeParam, MakeParameters(\"EquivalentTo\", 7)(\"Mod\", 8)));\n\n\tm_n = m_p * m_q;\n\tm_u = m_q.InverseMod(m_p);\n}",
    "includes": [
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rw.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_q.InverseMod",
          "args": [
            "m_p"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "InverseMod",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3983-4006",
          "snippet": "word Integer::InverseMod(word mod) const\n{\n\tword g0 = mod, g1 = *this % mod;\n\tword v0 = 0, v1 = 1;\n\tword y;\n\n\twhile (g1)\n\t{\n\t\tif (g1 == 1)\n\t\t\treturn v1;\n\t\ty = g0 / g1;\n\t\tg0 = g0 % g1;\n\t\tv0 += y * v1;\n\n\t\tif (!g0)\n\t\t\tbreak;\n\t\tif (g0 == 1)\n\t\t\treturn mod-v0;\n\t\ty = g1 / g0;\n\t\tg1 = g1 % g0;\n\t\tv1 += y * v0;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  word Integer::InverseMod(word mod) const\n  {\n  \tword g0 = mod, g1 = *this % mod;\n  \tword v0 = 0, v1 = 1;\n  \tword y;\n  \n  \twhile (g1)\n  \t{\n  \t\tif (g1 == 1)\n  \t\t\treturn v1;\n  \t\ty = g0 / g1;\n  \t\tg0 = g0 % g1;\n  \t\tv0 += y * v1;\n  \n  \t\tif (!g0)\n  \t\t\tbreak;\n  \t\tif (g0 == 1)\n  \t\t\treturn mod-v0;\n  \t\ty = g1 / g0;\n  \t\tg1 = g1 % g0;\n  \t\tv1 += y * v0;\n  \t}\n  \treturn 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_q.GenerateRandom",
          "args": [
            "rng",
            "CombinedNameValuePairs(primeParam, MakeParameters(\"EquivalentTo\", 7)(\"Mod\", 8))"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateRandom",
          "container": "InvertibleRWFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
          "lines": "88-102",
          "snippet": "void InvertibleRWFunction::GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &alg)\n{\n\tint modulusSize = 2048;\n\talg.GetIntValue(\"ModulusSize\", modulusSize) || alg.GetIntValue(\"KeySize\", modulusSize);\n\n\tif (modulusSize < 16)\n\t\tthrow InvalidArgument(\"InvertibleRWFunction: specified modulus length is too small\");\n\n\tAlgorithmParameters primeParam = MakeParametersForTwoPrimesOfEqualSize(modulusSize);\n\tm_p.GenerateRandom(rng, CombinedNameValuePairs(primeParam, MakeParameters(\"EquivalentTo\", 3)(\"Mod\", 8)));\n\tm_q.GenerateRandom(rng, CombinedNameValuePairs(primeParam, MakeParameters(\"EquivalentTo\", 7)(\"Mod\", 8)));\n\n\tm_n = m_p * m_q;\n\tm_u = m_q.InverseMod(m_p);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "CombinedNameValuePairs",
          "args": [
            "primeParam",
            "MakeParameters(\"EquivalentTo\", 7)(\"Mod\", 8)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakeParameters",
          "args": [
            "\"Mod\"",
            "8"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "MakeParameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "387-390",
          "snippet": "AlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CombinedNameValuePairs",
          "args": [
            "primeParam",
            "MakeParameters(\"EquivalentTo\", 3)(\"Mod\", 8)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakeParametersForTwoPrimesOfEqualSize",
          "args": [
            "modulusSize"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "MakeParametersForTwoPrimesOfEqualSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "265-284",
          "snippet": "AlgorithmParameters MakeParametersForTwoPrimesOfEqualSize(unsigned int productBitLength)\n{\n\tif (productBitLength < 16)\n\t\tthrow InvalidArgument(\"invalid bit length\");\n\n\tInteger minP, maxP;\n\n\tif (productBitLength%2==0)\n\t{\n\t\tminP = Integer(182) << (productBitLength/2-8);\n\t\tmaxP = Integer::Power2(productBitLength/2)-1;\n\t}\n\telse\n\t{\n\t\tminP = Integer::Power2((productBitLength-1)/2);\n\t\tmaxP = Integer(181) << ((productBitLength+1)/2-8);\n\t}\n\n\treturn MakeParameters(\"RandomNumberType\", Integer::PRIME)(\"Min\", minP)(\"Max\", maxP);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nAlgorithmParameters MakeParametersForTwoPrimesOfEqualSize(unsigned int productBitLength)\n{\n\tif (productBitLength < 16)\n\t\tthrow InvalidArgument(\"invalid bit length\");\n\n\tInteger minP, maxP;\n\n\tif (productBitLength%2==0)\n\t{\n\t\tminP = Integer(182) << (productBitLength/2-8);\n\t\tmaxP = Integer::Power2(productBitLength/2)-1;\n\t}\n\telse\n\t{\n\t\tminP = Integer::Power2((productBitLength-1)/2);\n\t\tmaxP = Integer(181) << ((productBitLength+1)/2-8);\n\t}\n\n\treturn MakeParameters(\"RandomNumberType\", Integer::PRIME)(\"Min\", minP)(\"Max\", maxP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"InvertibleRWFunction: specified modulus length is too small\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alg.GetIntValue",
          "args": [
            "\"KeySize\"",
            "modulusSize"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alg.GetIntValue",
          "args": [
            "\"ModulusSize\"",
            "modulusSize"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nInvertibleRWFunction {\n  void InvertibleRWFunction::GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &alg)\n  {\n  \tint modulusSize = 2048;\n  \talg.GetIntValue(\"ModulusSize\", modulusSize) || alg.GetIntValue(\"KeySize\", modulusSize);\n  \n  \tif (modulusSize < 16)\n  \t\tthrow InvalidArgument(\"InvertibleRWFunction: specified modulus length is too small\");\n  \n  \tAlgorithmParameters primeParam = MakeParametersForTwoPrimesOfEqualSize(modulusSize);\n  \tm_p.GenerateRandom(rng, CombinedNameValuePairs(primeParam, MakeParameters(\"EquivalentTo\", 3)(\"Mod\", 8)));\n  \tm_q.GenerateRandom(rng, CombinedNameValuePairs(primeParam, MakeParameters(\"EquivalentTo\", 7)(\"Mod\", 8)));\n  \n  \tm_n = m_p * m_q;\n  \tm_u = m_q.InverseMod(m_p);\n  }\n}"
  },
  {
    "function_name": "AssignFrom",
    "container": "RWFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
    "lines": "77-82",
    "snippet": "void RWFunction::AssignFrom(const NameValuePairs &source)\n{\n\tAssignFromHelper(this, source)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Modulus)\n\t\t;\n}",
    "includes": [
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rw.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "Modulus"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssignFromHelper",
          "args": [
            "this",
            "source"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "AssignFromHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "235-238",
          "snippet": "AssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nRWFunction {\n  void RWFunction::AssignFrom(const NameValuePairs &source)\n  {\n  \tAssignFromHelper(this, source)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(Modulus)\n  \t\t;\n  }\n}"
  },
  {
    "function_name": "GetVoidValue",
    "container": "RWFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
    "lines": "70-75",
    "snippet": "bool RWFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n{\n\treturn GetValueHelper(this, name, valueType, pValue).Assignable()\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Modulus)\n\t\t;\n}",
    "includes": [
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rw.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "Modulus"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper",
          "args": [
            "this",
            "name",
            "valueType",
            "pValue"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "GetValueHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "161-164",
          "snippet": "GetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nGetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nRWFunction {\n  bool RWFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n  {\n  \treturn GetValueHelper(this, name, valueType, pValue).Assignable()\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(Modulus)\n  \t\t;\n  }\n}"
  },
  {
    "function_name": "Validate",
    "container": "RWFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
    "lines": "63-68",
    "snippet": "bool RWFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = true;\n\tpass = pass && m_n > Integer::One() && m_n%8 == 5;\n\treturn pass;\n}",
    "includes": [
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rw.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Integer::One",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "One",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "44-45",
          "snippet": "Element One() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element One() const\n  \t\t{return 1;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nRWFunction {\n  bool RWFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n  {\n  \tbool pass = true;\n  \tpass = pass && m_n > Integer::One() && m_n%8 == 5;\n  \treturn pass;\n  }\n}"
  },
  {
    "function_name": "ApplyFunction",
    "container": "RWFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
    "lines": "26-61",
    "snippet": "Integer RWFunction::ApplyFunction(const Integer &in) const\n{\n\tDoQuickSanityCheck();\n\n\tInteger out = in.Squared()%m_n;\n\tconst word r = 12;\n\t// this code was written to handle both r = 6 and r = 12,\n\t// but now only r = 12 is used in P1363\n\tconst word r2 = r/2;\n\tconst word r3a = (16 + 5 - r) % 16;\t// n%16 could be 5 or 13\n\tconst word r3b = (16 + 13 - r) % 16;\n\tconst word r4 = (8 + 5 - r/2) % 8;\t// n%8 == 5\n\tswitch (out % 16)\n\t{\n\tcase r:\n\t\tbreak;\n\tcase r2:\n\tcase r2+8:\n\t\tout <<= 1;\n\t\tbreak;\n\tcase r3a:\n\tcase r3b:\n\t\tout.Negate();\n\t\tout += m_n;\n\t\tbreak;\n\tcase r4:\n\tcase r4+8:\n\t\tout.Negate();\n\t\tout += m_n;\n\t\tout <<= 1;\n\t\tbreak;\n\tdefault:\n\t\tout = Integer::Zero();\n\t}\n\treturn out;\n}",
    "includes": [
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rw.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Integer::Zero",
          "args": [],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "Zero",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "23-24",
          "snippet": "Element Zero() const\n\t\t{return 0;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Zero() const\n  \t\t{return 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "out.Negate",
          "args": [],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "Negate",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3874-3878",
          "snippet": "void Integer::Negate()\n{\n\tif (!!(*this))\t// don't flip sign if *this==0\n\t\tsign = Sign(1-sign);\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  void Integer::Negate()\n  {\n  \tif (!!(*this))\t// don't flip sign if *this==0\n  \t\tsign = Sign(1-sign);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "in.Squared",
          "args": [],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "Squared",
          "container": "PolynomialOverFixedRing",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "278-278",
          "snippet": "ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nPolynomialOverFixedRing {\n  ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoQuickSanityCheck",
          "args": [],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nRWFunction {\n  Integer RWFunction::ApplyFunction(const Integer &in) const\n  {\n  \tDoQuickSanityCheck();\n  \n  \tInteger out = in.Squared()%m_n;\n  \tconst word r = 12;\n  \t// this code was written to handle both r = 6 and r = 12,\n  \t// but now only r = 12 is used in P1363\n  \tconst word r2 = r/2;\n  \tconst word r3a = (16 + 5 - r) % 16;\t// n%16 could be 5 or 13\n  \tconst word r3b = (16 + 13 - r) % 16;\n  \tconst word r4 = (8 + 5 - r/2) % 8;\t// n%8 == 5\n  \tswitch (out % 16)\n  \t{\n  \tcase r:\n  \t\tbreak;\n  \tcase r2:\n  \tcase r2+8:\n  \t\tout <<= 1;\n  \t\tbreak;\n  \tcase r3a:\n  \tcase r3b:\n  \t\tout.Negate();\n  \t\tout += m_n;\n  \t\tbreak;\n  \tcase r4:\n  \tcase r4+8:\n  \t\tout.Negate();\n  \t\tout += m_n;\n  \t\tout <<= 1;\n  \t\tbreak;\n  \tdefault:\n  \t\tout = Integer::Zero();\n  \t}\n  \treturn out;\n  }\n}"
  },
  {
    "function_name": "DEREncode",
    "container": "RWFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
    "lines": "19-24",
    "snippet": "void RWFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\tm_n.DEREncode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rw.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_n.DEREncode",
          "args": [
            "seq"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncode",
          "container": "InvertibleRWFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
          "lines": "114-122",
          "snippet": "void InvertibleRWFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\tm_n.DEREncode(seq);\n\tm_p.DEREncode(seq);\n\tm_q.DEREncode(seq);\n\tm_u.DEREncode(seq);\n\tseq.MessageEnd();\n}",
          "includes": [
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"rw.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nInvertibleRWFunction {\n  void InvertibleRWFunction::DEREncode(BufferedTransformation &bt) const\n  {\n  \tDERSequenceEncoder seq(bt);\n  \tm_n.DEREncode(seq);\n  \tm_p.DEREncode(seq);\n  \tm_q.DEREncode(seq);\n  \tm_u.DEREncode(seq);\n  \tseq.MessageEnd();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nRWFunction {\n  void RWFunction::DEREncode(BufferedTransformation &bt) const\n  {\n  \tDERSequenceEncoder seq(bt);\n  \tm_n.DEREncode(seq);\n  \tseq.MessageEnd();\n  }\n}"
  },
  {
    "function_name": "BERDecode",
    "container": "RWFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
    "lines": "12-17",
    "snippet": "void RWFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\tm_n.BERDecode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rw.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 16
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_n.BERDecode",
          "args": [
            "seq"
          ],
          "line": 15
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecode",
          "container": "InvertibleRWFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
          "lines": "104-112",
          "snippet": "void InvertibleRWFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\tm_n.BERDecode(seq);\n\tm_p.BERDecode(seq);\n\tm_q.BERDecode(seq);\n\tm_u.BERDecode(seq);\n\tseq.MessageEnd();\n}",
          "includes": [
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"rw.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nInvertibleRWFunction {\n  void InvertibleRWFunction::BERDecode(BufferedTransformation &bt)\n  {\n  \tBERSequenceDecoder seq(bt);\n  \tm_n.BERDecode(seq);\n  \tm_p.BERDecode(seq);\n  \tm_q.BERDecode(seq);\n  \tm_u.BERDecode(seq);\n  \tseq.MessageEnd();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nRWFunction {\n  void RWFunction::BERDecode(BufferedTransformation &bt)\n  {\n  \tBERSequenceDecoder seq(bt);\n  \tm_n.BERDecode(seq);\n  \tseq.MessageEnd();\n  }\n}"
  }
]