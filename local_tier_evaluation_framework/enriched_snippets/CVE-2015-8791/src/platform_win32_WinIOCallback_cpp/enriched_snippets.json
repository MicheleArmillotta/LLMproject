[
  {
    "function_name": "SetEOF",
    "container": "WinIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "271-274",
    "snippet": "bool WinIOCallback::SetEOF()\n{\n  return SetEndOfFile(mFile) != 0;\n}",
    "includes": [
      "#include \"ebml/Debug.h\"",
      "#include \"WinIOCallback.h\"",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetEndOfFile",
          "args": [
            "mFile"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/Debug.h\"\n#include \"WinIOCallback.h\"\n#include <cassert>\n\nWinIOCallback {\n  bool WinIOCallback::SetEOF()\n  {\n    return SetEndOfFile(mFile) != 0;\n  }\n}"
  },
  {
    "function_name": "write",
    "container": "WinIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "261-269",
    "snippet": "size_t WinIOCallback::write(const void*Buffer,size_t Size)\n{\n  DWORD BytesWriten;\n  if (!WriteFile(mFile, Buffer, Size, &BytesWriten, NULL)) {\n    return 0;\n  }\n  mCurrentPosition += BytesWriten;\n  return BytesWriten;\n}",
    "includes": [
      "#include \"ebml/Debug.h\"",
      "#include \"WinIOCallback.h\"",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WriteFile",
          "args": [
            "mFile",
            "Buffer",
            "Size",
            "&BytesWriten",
            "NULL"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/Debug.h\"\n#include \"WinIOCallback.h\"\n#include <cassert>\n\nWinIOCallback {\n  size_t WinIOCallback::write(const void*Buffer,size_t Size)\n  {\n    DWORD BytesWriten;\n    if (!WriteFile(mFile, Buffer, Size, &BytesWriten, NULL)) {\n      return 0;\n    }\n    mCurrentPosition += BytesWriten;\n    return BytesWriten;\n  }\n}"
  },
  {
    "function_name": "read",
    "container": "WinIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "251-259",
    "snippet": "uint32 WinIOCallback::read(void*Buffer,size_t Size)\n{\n  DWORD BytesRead;\n  if (!ReadFile(mFile, Buffer, Size, &BytesRead, NULL)) {\n    return 0;\n  }\n  mCurrentPosition += BytesRead;\n  return BytesRead;\n}",
    "includes": [
      "#include \"ebml/Debug.h\"",
      "#include \"WinIOCallback.h\"",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReadFile",
          "args": [
            "mFile",
            "Buffer",
            "Size",
            "&BytesRead",
            "NULL"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/Debug.h\"\n#include \"WinIOCallback.h\"\n#include <cassert>\n\nWinIOCallback {\n  uint32 WinIOCallback::read(void*Buffer,size_t Size)\n  {\n    DWORD BytesRead;\n    if (!ReadFile(mFile, Buffer, Size, &BytesRead, NULL)) {\n      return 0;\n    }\n    mCurrentPosition += BytesRead;\n    return BytesRead;\n  }\n}"
  },
  {
    "function_name": "setFilePointer",
    "container": "WinIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "222-249",
    "snippet": "void WinIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n{\n  DWORD Method;\n  switch(Mode) {\n    case seek_beginning:\n      Method=FILE_BEGIN;\n      break;\n    case seek_current:\n      Method=FILE_CURRENT;\n      break;\n    case seek_end:\n      Method=FILE_END;\n      break;\n    default:\n      assert(false);\n      break;\n  }\n\n  LONG High = LONG(Offset>>32);\n  mCurrentPosition = SetFilePointer(mFile, LONG(Offset & 0xffffffff), &High, Method);\n  if ( mCurrentPosition == INVALID_SET_FILE_POINTER ) {\n    High = 0;\n    DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n    mCurrentPosition = ((uint64(High)<<32) | Low);\n  } else {\n    mCurrentPosition |= uint64(High)<<32;\n  }\n}",
    "includes": [
      "#include \"ebml/Debug.h\"",
      "#include \"WinIOCallback.h\"",
      "#include <cassert>"
    ],
    "macros_used": [
      "#define INVALID_SET_FILE_POINTER ((DWORD)-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uint64",
          "args": [
            "High"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint64",
          "args": [
            "High"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetFilePointer",
          "args": [
            "mFile",
            "0",
            "&High",
            "FILE_CURRENT"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetFilePointer",
          "args": [
            "mFile",
            "LONG(Offset & 0xffffffff)",
            "&High",
            "Method"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LONG",
          "args": [
            "Offset & 0xffffffff"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LONG",
          "args": [
            "Offset>>32"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/Debug.h\"\n#include \"WinIOCallback.h\"\n#include <cassert>\n\n#define INVALID_SET_FILE_POINTER ((DWORD)-1)\n\nWinIOCallback {\n  void WinIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n  {\n    DWORD Method;\n    switch(Mode) {\n      case seek_beginning:\n        Method=FILE_BEGIN;\n        break;\n      case seek_current:\n        Method=FILE_CURRENT;\n        break;\n      case seek_end:\n        Method=FILE_END;\n        break;\n      default:\n        assert(false);\n        break;\n    }\n  \n    LONG High = LONG(Offset>>32);\n    mCurrentPosition = SetFilePointer(mFile, LONG(Offset & 0xffffffff), &High, Method);\n    if ( mCurrentPosition == INVALID_SET_FILE_POINTER ) {\n      High = 0;\n      DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n      mCurrentPosition = ((uint64(High)<<32) | Low);\n    } else {\n      mCurrentPosition |= uint64(High)<<32;\n    }\n  }\n}"
  },
  {
    "function_name": "getFilePointer",
    "container": "WinIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "206-220",
    "snippet": "uint64 WinIOCallback::getFilePointer()\n{\n  if (!mFile) {\n    return 0;\n  }\n\n  return mCurrentPosition;\n#if 0\n  LONG High = 0;\n  DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n  if ( (Low==INVALID_SET_FILE_POINTER) && (GetLastError()!=NO_ERROR) )\n    return static_cast<uint64>(-1);\n  return ((uint64(High)<<32) | Low);\n#endif\n}",
    "includes": [
      "#include \"ebml/Debug.h\"",
      "#include \"WinIOCallback.h\"",
      "#include <cassert>"
    ],
    "macros_used": [
      "#define INVALID_SET_FILE_POINTER ((DWORD)-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uint64",
          "args": [
            "High"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint64>",
          "args": [
            "-1"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetFilePointer",
          "args": [
            "mFile",
            "0",
            "&High",
            "FILE_CURRENT"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/Debug.h\"\n#include \"WinIOCallback.h\"\n#include <cassert>\n\n#define INVALID_SET_FILE_POINTER ((DWORD)-1)\n\nWinIOCallback {\n  uint64 WinIOCallback::getFilePointer()\n  {\n    if (!mFile) {\n      return 0;\n    }\n  \n    return mCurrentPosition;\n  #if 0\n    LONG High = 0;\n    DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n    if ( (Low==INVALID_SET_FILE_POINTER) && (GetLastError()!=NO_ERROR) )\n      return static_cast<uint64>(-1);\n    return ((uint64(High)<<32) | Low);\n  #endif\n  }\n}"
  },
  {
    "function_name": "close",
    "container": "WinIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "198-204",
    "snippet": "void WinIOCallback::close()\n{\n  if (mFile) {\n    CloseHandle(mFile);\n    mFile = NULL;\n  }\n}",
    "includes": [
      "#include \"ebml/Debug.h\"",
      "#include \"WinIOCallback.h\"",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [
            "mFile"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/Debug.h\"\n#include \"WinIOCallback.h\"\n#include <cassert>\n\nWinIOCallback {\n  void WinIOCallback::close()\n  {\n    if (mFile) {\n      CloseHandle(mFile);\n      mFile = NULL;\n    }\n  }\n}"
  },
  {
    "function_name": "open",
    "container": "WinIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "118-196",
    "snippet": "bool WinIOCallback::open(const wchar_t* Path, const open_mode aMode, DWORD dwFlags)\n{\n  assert(Path!=0);\n\n  DWORD AccessMode, ShareMode, Disposition;\n\n  switch (aMode) {\n    case MODE_READ:\n      AccessMode = GENERIC_READ;\n      ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;\n      Disposition = OPEN_EXISTING;\n      break;\n    case MODE_WRITE:\n      AccessMode = GENERIC_WRITE;\n      ShareMode = 0;\n      Disposition = OPEN_ALWAYS;\n      break;\n    case MODE_SAFE:\n      AccessMode = GENERIC_WRITE|GENERIC_READ;\n      ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;\n      Disposition = OPEN_ALWAYS;\n      break;\n    case MODE_CREATE:\n      AccessMode = GENERIC_WRITE;\n      ShareMode = 0;\n      Disposition = CREATE_ALWAYS;\n      break;\n    default:\n      assert(false);\n  }\n\n  if ((LONG)GetVersion() >= 0) {\n    mFile = CreateFileW(Path, AccessMode, ShareMode, NULL, Disposition, dwFlags, NULL);\n  } else {\n    int errCode;\n    int pathSize = wcslen(Path);\n    unsigned int bufferSize = pathSize + sizeof(wchar_t) * 2;\n    std::string PathA;\n    PathA.resize(bufferSize);\n    errCode = WideCharToMultiByte(CP_ACP, 0, Path, pathSize, (char *)PathA.c_str(), bufferSize, NULL, NULL);\n    if (errCode == 0)\n      errCode = GetLastError();\n#ifdef _DEBUG\n    if (errCode == ERROR_INSUFFICIENT_BUFFER) OutputDebugString(TEXT(\"WinIOCallback::WideCharToMultiByte::ERROR_INSUFFICIENT_BUFFER\"));\n    if (errCode == ERROR_INVALID_FLAGS) OutputDebugString(TEXT(\"WinIOCallback::WideCharToMultiByte::ERROR_INVALID_FLAGS\"));\n    if (errCode == ERROR_INVALID_PARAMETER) OutputDebugString(TEXT(\"WinIOCallback::WideCharToMultiByte::ERROR_INVALID_PARAMETER\"));\n#endif\n    while (errCode == ERROR_INSUFFICIENT_BUFFER) {\n      // Increase the buffer size\n      bufferSize += MAX_PATH;\n      PathA.resize(bufferSize);\n      errCode = WideCharToMultiByte(CP_ACP, WC_SEPCHARS, Path, pathSize, (char *)PathA.c_str(), bufferSize, NULL, NULL);\n      if (errCode == 0)\n        errCode = GetLastError();\n    }\n    if (errCode != 0) {\n      mFile = CreateFileA(PathA.c_str(), AccessMode, ShareMode, NULL, Disposition, dwFlags, NULL);\n    } else {\n      mLastErrorStr = \"Couldn't convert Unicode filename to ANSI.\";\n      return mOk = false;\n    }\n  }\n  if ((mFile == INVALID_HANDLE_VALUE) || ((long)mFile == 0xffffffff)) {\n    //File was not opened\n    char err_msg[256];\n    DWORD error_code = GetLastError();\n    // An error message about the file already existing is not really an error message :P\n    if (error_code != ERROR_ALREADY_EXISTS) {\n      FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, 0, error_code, 0, err_msg, 255, NULL);\n      EBML_TRACE(\"Failed to open file \\\"%S\\\" in mode %d.\", Path, aMode);\n      mLastErrorStr = err_msg;\n      return mOk = false;\n    }\n  }\n  mCurrentPosition = 0;\n\n  EBML_TRACE(\"Successfully opened file \\\"%S\\\" in mode %d. The handle is %p\\n\", Path, aMode, mFile);\n  return mOk = true;\n}",
    "includes": [
      "#include \"ebml/Debug.h\"",
      "#include \"WinIOCallback.h\"",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [
      "START_LIBEBML_NAMESPACE\n\nWinIOCallback::WinIOCallback(const char* Path, const open_mode aMode, DWORD dwFlags)\n  :mFile(NULL), mOk(false)\n{\n  mOk = open(Path, aMode, dwFlags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EBML_TRACE",
          "args": [
            "\"Successfully opened file \\\"%S\\\" in mode %d. The handle is %p\\n\"",
            "Path",
            "aMode",
            "mFile"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EBML_TRACE",
          "args": [
            "\"Failed to open file \\\"%S\\\" in mode %d.\"",
            "Path",
            "aMode"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMessageA",
          "args": [
            "FORMAT_MESSAGE_FROM_SYSTEM",
            "0",
            "error_code",
            "0",
            "err_msg",
            "255",
            "NULL"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateFileA",
          "args": [
            "PathA.c_str()",
            "AccessMode",
            "ShareMode",
            "NULL",
            "Disposition",
            "dwFlags",
            "NULL"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PathA.c_str",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WideCharToMultiByte",
          "args": [
            "CP_ACP",
            "WC_SEPCHARS",
            "Path",
            "pathSize",
            "(char *)PathA.c_str()",
            "bufferSize",
            "NULL",
            "NULL"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PathA.c_str",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PathA.resize",
          "args": [
            "bufferSize"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputDebugString",
          "args": [
            "TEXT(\"WinIOCallback::WideCharToMultiByte::ERROR_INVALID_PARAMETER\")"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEXT",
          "args": [
            "\"WinIOCallback::WideCharToMultiByte::ERROR_INVALID_PARAMETER\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputDebugString",
          "args": [
            "TEXT(\"WinIOCallback::WideCharToMultiByte::ERROR_INVALID_FLAGS\")"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEXT",
          "args": [
            "\"WinIOCallback::WideCharToMultiByte::ERROR_INVALID_FLAGS\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputDebugString",
          "args": [
            "TEXT(\"WinIOCallback::WideCharToMultiByte::ERROR_INSUFFICIENT_BUFFER\")"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEXT",
          "args": [
            "\"WinIOCallback::WideCharToMultiByte::ERROR_INSUFFICIENT_BUFFER\""
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WideCharToMultiByte",
          "args": [
            "CP_ACP",
            "0",
            "Path",
            "pathSize",
            "(char *)PathA.c_str()",
            "bufferSize",
            "NULL",
            "NULL"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PathA.c_str",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PathA.resize",
          "args": [
            "bufferSize"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcslen",
          "args": [
            "Path"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateFileW",
          "args": [
            "Path",
            "AccessMode",
            "ShareMode",
            "NULL",
            "Disposition",
            "dwFlags",
            "NULL"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetVersion",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "Path!=0"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/Debug.h\"\n#include \"WinIOCallback.h\"\n#include <cassert>\n\nSTART_LIBEBML_NAMESPACE\n\nWinIOCallback::WinIOCallback(const char* Path, const open_mode aMode, DWORD dwFlags)\n  :mFile(NULL), mOk(false)\n{\n  mOk = open(Path, aMode, dwFlags);\n\nWinIOCallback {\n  bool WinIOCallback::open(const wchar_t* Path, const open_mode aMode, DWORD dwFlags)\n  {\n    assert(Path!=0);\n  \n    DWORD AccessMode, ShareMode, Disposition;\n  \n    switch (aMode) {\n      case MODE_READ:\n        AccessMode = GENERIC_READ;\n        ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;\n        Disposition = OPEN_EXISTING;\n        break;\n      case MODE_WRITE:\n        AccessMode = GENERIC_WRITE;\n        ShareMode = 0;\n        Disposition = OPEN_ALWAYS;\n        break;\n      case MODE_SAFE:\n        AccessMode = GENERIC_WRITE|GENERIC_READ;\n        ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;\n        Disposition = OPEN_ALWAYS;\n        break;\n      case MODE_CREATE:\n        AccessMode = GENERIC_WRITE;\n        ShareMode = 0;\n        Disposition = CREATE_ALWAYS;\n        break;\n      default:\n        assert(false);\n    }\n  \n    if ((LONG)GetVersion() >= 0) {\n      mFile = CreateFileW(Path, AccessMode, ShareMode, NULL, Disposition, dwFlags, NULL);\n    } else {\n      int errCode;\n      int pathSize = wcslen(Path);\n      unsigned int bufferSize = pathSize + sizeof(wchar_t) * 2;\n      std::string PathA;\n      PathA.resize(bufferSize);\n      errCode = WideCharToMultiByte(CP_ACP, 0, Path, pathSize, (char *)PathA.c_str(), bufferSize, NULL, NULL);\n      if (errCode == 0)\n        errCode = GetLastError();\n  #ifdef _DEBUG\n      if (errCode == ERROR_INSUFFICIENT_BUFFER) OutputDebugString(TEXT(\"WinIOCallback::WideCharToMultiByte::ERROR_INSUFFICIENT_BUFFER\"));\n      if (errCode == ERROR_INVALID_FLAGS) OutputDebugString(TEXT(\"WinIOCallback::WideCharToMultiByte::ERROR_INVALID_FLAGS\"));\n      if (errCode == ERROR_INVALID_PARAMETER) OutputDebugString(TEXT(\"WinIOCallback::WideCharToMultiByte::ERROR_INVALID_PARAMETER\"));\n  #endif\n      while (errCode == ERROR_INSUFFICIENT_BUFFER) {\n        // Increase the buffer size\n        bufferSize += MAX_PATH;\n        PathA.resize(bufferSize);\n        errCode = WideCharToMultiByte(CP_ACP, WC_SEPCHARS, Path, pathSize, (char *)PathA.c_str(), bufferSize, NULL, NULL);\n        if (errCode == 0)\n          errCode = GetLastError();\n      }\n      if (errCode != 0) {\n        mFile = CreateFileA(PathA.c_str(), AccessMode, ShareMode, NULL, Disposition, dwFlags, NULL);\n      } else {\n        mLastErrorStr = \"Couldn't convert Unicode filename to ANSI.\";\n        return mOk = false;\n      }\n    }\n    if ((mFile == INVALID_HANDLE_VALUE) || ((long)mFile == 0xffffffff)) {\n      //File was not opened\n      char err_msg[256];\n      DWORD error_code = GetLastError();\n      // An error message about the file already existing is not really an error message :P\n      if (error_code != ERROR_ALREADY_EXISTS) {\n        FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, 0, error_code, 0, err_msg, 255, NULL);\n        EBML_TRACE(\"Failed to open file \\\"%S\\\" in mode %d.\", Path, aMode);\n        mLastErrorStr = err_msg;\n        return mOk = false;\n      }\n    }\n    mCurrentPosition = 0;\n  \n    EBML_TRACE(\"Successfully opened file \\\"%S\\\" in mode %d. The handle is %p\\n\", Path, aMode, mFile);\n    return mOk = true;\n  }\n}"
  },
  {
    "function_name": "open",
    "container": "WinIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "66-116",
    "snippet": "bool WinIOCallback::open(const char* Path, const open_mode aMode, DWORD dwFlags)\n{\n  assert(Path!=0);\n\n  DWORD AccessMode, ShareMode, Disposition;\n\n  switch (aMode) {\n    case MODE_READ:\n      AccessMode = GENERIC_READ;\n      ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;\n      Disposition = OPEN_EXISTING;\n      break;\n    case MODE_WRITE:\n      AccessMode = GENERIC_WRITE;\n      ShareMode = 0;\n      Disposition = OPEN_ALWAYS;\n      break;\n    case MODE_SAFE:\n      AccessMode = GENERIC_WRITE|GENERIC_READ;\n      ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;\n      Disposition = OPEN_ALWAYS;\n      break;\n    case MODE_CREATE:\n      AccessMode = GENERIC_WRITE;\n      ShareMode = 0;\n      Disposition = CREATE_ALWAYS;\n      break;\n    default:\n      assert(false);\n  }\n\n  mFile = CreateFileA(Path, AccessMode, ShareMode, NULL, Disposition, dwFlags, NULL);\n  if ((mFile == INVALID_HANDLE_VALUE) || ((long)mFile == 0xffffffff)) {\n    //File was not opened\n    char err_msg[256];\n    DWORD error_code = GetLastError();\n    // An error message about the file already existing is not really an error message :P\n    if (error_code != ERROR_ALREADY_EXISTS) {\n      FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, 0, error_code, 0, err_msg, 255, NULL);\n      EBML_TRACE(\"Failed to open file \\\"%hs\\\" in mode %d.\", Path, aMode);\n\n      mLastErrorStr = err_msg;\n      return mOk = false;\n    }\n  }\n  mCurrentPosition = 0;\n\n  EBML_TRACE(\"Successfully opened file \\\"%hs\\\" in mode %d. The handle is %p\\n\", Path, aMode, mFile);\n\n  return mOk = true;\n}",
    "includes": [
      "#include \"ebml/Debug.h\"",
      "#include \"WinIOCallback.h\"",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [
      "START_LIBEBML_NAMESPACE\n\nWinIOCallback::WinIOCallback(const char* Path, const open_mode aMode, DWORD dwFlags)\n  :mFile(NULL), mOk(false)\n{\n  mOk = open(Path, aMode, dwFlags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EBML_TRACE",
          "args": [
            "\"Successfully opened file \\\"%hs\\\" in mode %d. The handle is %p\\n\"",
            "Path",
            "aMode",
            "mFile"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EBML_TRACE",
          "args": [
            "\"Failed to open file \\\"%hs\\\" in mode %d.\"",
            "Path",
            "aMode"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMessageA",
          "args": [
            "FORMAT_MESSAGE_FROM_SYSTEM",
            "0",
            "error_code",
            "0",
            "err_msg",
            "255",
            "NULL"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateFileA",
          "args": [
            "Path",
            "AccessMode",
            "ShareMode",
            "NULL",
            "Disposition",
            "dwFlags",
            "NULL"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "Path!=0"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/Debug.h\"\n#include \"WinIOCallback.h\"\n#include <cassert>\n\nSTART_LIBEBML_NAMESPACE\n\nWinIOCallback::WinIOCallback(const char* Path, const open_mode aMode, DWORD dwFlags)\n  :mFile(NULL), mOk(false)\n{\n  mOk = open(Path, aMode, dwFlags);\n\nWinIOCallback {\n  bool WinIOCallback::open(const char* Path, const open_mode aMode, DWORD dwFlags)\n  {\n    assert(Path!=0);\n  \n    DWORD AccessMode, ShareMode, Disposition;\n  \n    switch (aMode) {\n      case MODE_READ:\n        AccessMode = GENERIC_READ;\n        ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;\n        Disposition = OPEN_EXISTING;\n        break;\n      case MODE_WRITE:\n        AccessMode = GENERIC_WRITE;\n        ShareMode = 0;\n        Disposition = OPEN_ALWAYS;\n        break;\n      case MODE_SAFE:\n        AccessMode = GENERIC_WRITE|GENERIC_READ;\n        ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;\n        Disposition = OPEN_ALWAYS;\n        break;\n      case MODE_CREATE:\n        AccessMode = GENERIC_WRITE;\n        ShareMode = 0;\n        Disposition = CREATE_ALWAYS;\n        break;\n      default:\n        assert(false);\n    }\n  \n    mFile = CreateFileA(Path, AccessMode, ShareMode, NULL, Disposition, dwFlags, NULL);\n    if ((mFile == INVALID_HANDLE_VALUE) || ((long)mFile == 0xffffffff)) {\n      //File was not opened\n      char err_msg[256];\n      DWORD error_code = GetLastError();\n      // An error message about the file already existing is not really an error message :P\n      if (error_code != ERROR_ALREADY_EXISTS) {\n        FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, 0, error_code, 0, err_msg, 255, NULL);\n        EBML_TRACE(\"Failed to open file \\\"%hs\\\" in mode %d.\", Path, aMode);\n  \n        mLastErrorStr = err_msg;\n        return mOk = false;\n      }\n    }\n    mCurrentPosition = 0;\n  \n    EBML_TRACE(\"Successfully opened file \\\"%hs\\\" in mode %d. The handle is %p\\n\", Path, aMode, mFile);\n  \n    return mOk = true;\n  }\n}"
  },
  {
    "function_name": "~WinIOCallback",
    "container": "WinIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "61-64",
    "snippet": "WinIOCallback::~WinIOCallback()\n{\n  close();\n}",
    "includes": [
      "#include \"ebml/Debug.h\"",
      "#include \"WinIOCallback.h\"",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": "WinIOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/platform/win32/WinIOCallback.cpp",
          "lines": "198-204",
          "snippet": "void WinIOCallback::close()\n{\n  if (mFile) {\n    CloseHandle(mFile);\n    mFile = NULL;\n  }\n}",
          "includes": [
            "#include \"ebml/Debug.h\"",
            "#include \"WinIOCallback.h\"",
            "#include <cassert>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/Debug.h\"\n#include \"WinIOCallback.h\"\n#include <cassert>\n\nWinIOCallback {\n  void WinIOCallback::close()\n  {\n    if (mFile) {\n      CloseHandle(mFile);\n      mFile = NULL;\n    }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ebml/Debug.h\"\n#include \"WinIOCallback.h\"\n#include <cassert>\n\nWinIOCallback {\n  WinIOCallback::~WinIOCallback()\n  {\n    close();\n  }\n}"
  },
  {
    "function_name": "WinIOCallback",
    "container": "WinIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "55-59",
    "snippet": "WinIOCallback::WinIOCallback(const wchar_t* Path, const open_mode aMode, DWORD dwFlags)\n  :mFile(NULL), mOk(false)\n{\n  mOk = open(Path, aMode, dwFlags);\n}",
    "includes": [
      "#include \"ebml/Debug.h\"",
      "#include \"WinIOCallback.h\"",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [
      "START_LIBEBML_NAMESPACE\n\nWinIOCallback::WinIOCallback(const char* Path, const open_mode aMode, DWORD dwFlags)\n  :mFile(NULL), mOk(false)\n{\n  mOk = open(Path, aMode, dwFlags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "open",
          "args": [
            "Path",
            "aMode",
            "dwFlags"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "open",
          "container": "WinIOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/platform/win32/WinIOCallback.cpp",
          "lines": "118-196",
          "snippet": "bool WinIOCallback::open(const wchar_t* Path, const open_mode aMode, DWORD dwFlags)\n{\n  assert(Path!=0);\n\n  DWORD AccessMode, ShareMode, Disposition;\n\n  switch (aMode) {\n    case MODE_READ:\n      AccessMode = GENERIC_READ;\n      ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;\n      Disposition = OPEN_EXISTING;\n      break;\n    case MODE_WRITE:\n      AccessMode = GENERIC_WRITE;\n      ShareMode = 0;\n      Disposition = OPEN_ALWAYS;\n      break;\n    case MODE_SAFE:\n      AccessMode = GENERIC_WRITE|GENERIC_READ;\n      ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;\n      Disposition = OPEN_ALWAYS;\n      break;\n    case MODE_CREATE:\n      AccessMode = GENERIC_WRITE;\n      ShareMode = 0;\n      Disposition = CREATE_ALWAYS;\n      break;\n    default:\n      assert(false);\n  }\n\n  if ((LONG)GetVersion() >= 0) {\n    mFile = CreateFileW(Path, AccessMode, ShareMode, NULL, Disposition, dwFlags, NULL);\n  } else {\n    int errCode;\n    int pathSize = wcslen(Path);\n    unsigned int bufferSize = pathSize + sizeof(wchar_t) * 2;\n    std::string PathA;\n    PathA.resize(bufferSize);\n    errCode = WideCharToMultiByte(CP_ACP, 0, Path, pathSize, (char *)PathA.c_str(), bufferSize, NULL, NULL);\n    if (errCode == 0)\n      errCode = GetLastError();\n#ifdef _DEBUG\n    if (errCode == ERROR_INSUFFICIENT_BUFFER) OutputDebugString(TEXT(\"WinIOCallback::WideCharToMultiByte::ERROR_INSUFFICIENT_BUFFER\"));\n    if (errCode == ERROR_INVALID_FLAGS) OutputDebugString(TEXT(\"WinIOCallback::WideCharToMultiByte::ERROR_INVALID_FLAGS\"));\n    if (errCode == ERROR_INVALID_PARAMETER) OutputDebugString(TEXT(\"WinIOCallback::WideCharToMultiByte::ERROR_INVALID_PARAMETER\"));\n#endif\n    while (errCode == ERROR_INSUFFICIENT_BUFFER) {\n      // Increase the buffer size\n      bufferSize += MAX_PATH;\n      PathA.resize(bufferSize);\n      errCode = WideCharToMultiByte(CP_ACP, WC_SEPCHARS, Path, pathSize, (char *)PathA.c_str(), bufferSize, NULL, NULL);\n      if (errCode == 0)\n        errCode = GetLastError();\n    }\n    if (errCode != 0) {\n      mFile = CreateFileA(PathA.c_str(), AccessMode, ShareMode, NULL, Disposition, dwFlags, NULL);\n    } else {\n      mLastErrorStr = \"Couldn't convert Unicode filename to ANSI.\";\n      return mOk = false;\n    }\n  }\n  if ((mFile == INVALID_HANDLE_VALUE) || ((long)mFile == 0xffffffff)) {\n    //File was not opened\n    char err_msg[256];\n    DWORD error_code = GetLastError();\n    // An error message about the file already existing is not really an error message :P\n    if (error_code != ERROR_ALREADY_EXISTS) {\n      FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, 0, error_code, 0, err_msg, 255, NULL);\n      EBML_TRACE(\"Failed to open file \\\"%S\\\" in mode %d.\", Path, aMode);\n      mLastErrorStr = err_msg;\n      return mOk = false;\n    }\n  }\n  mCurrentPosition = 0;\n\n  EBML_TRACE(\"Successfully opened file \\\"%S\\\" in mode %d. The handle is %p\\n\", Path, aMode, mFile);\n  return mOk = true;\n}",
          "includes": [
            "#include \"ebml/Debug.h\"",
            "#include \"WinIOCallback.h\"",
            "#include <cassert>"
          ],
          "macros_used": [],
          "globals_used": [
            "START_LIBEBML_NAMESPACE\n\nWinIOCallback::WinIOCallback(const char* Path, const open_mode aMode, DWORD dwFlags)\n  :mFile(NULL), mOk(false)\n{\n  mOk = open(Path, aMode, dwFlags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/Debug.h\"\n#include \"WinIOCallback.h\"\n#include <cassert>\n\nSTART_LIBEBML_NAMESPACE\n\nWinIOCallback::WinIOCallback(const char* Path, const open_mode aMode, DWORD dwFlags)\n  :mFile(NULL), mOk(false)\n{\n  mOk = open(Path, aMode, dwFlags);\n\nWinIOCallback {\n  bool WinIOCallback::open(const wchar_t* Path, const open_mode aMode, DWORD dwFlags)\n  {\n    assert(Path!=0);\n  \n    DWORD AccessMode, ShareMode, Disposition;\n  \n    switch (aMode) {\n      case MODE_READ:\n        AccessMode = GENERIC_READ;\n        ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;\n        Disposition = OPEN_EXISTING;\n        break;\n      case MODE_WRITE:\n        AccessMode = GENERIC_WRITE;\n        ShareMode = 0;\n        Disposition = OPEN_ALWAYS;\n        break;\n      case MODE_SAFE:\n        AccessMode = GENERIC_WRITE|GENERIC_READ;\n        ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;\n        Disposition = OPEN_ALWAYS;\n        break;\n      case MODE_CREATE:\n        AccessMode = GENERIC_WRITE;\n        ShareMode = 0;\n        Disposition = CREATE_ALWAYS;\n        break;\n      default:\n        assert(false);\n    }\n  \n    if ((LONG)GetVersion() >= 0) {\n      mFile = CreateFileW(Path, AccessMode, ShareMode, NULL, Disposition, dwFlags, NULL);\n    } else {\n      int errCode;\n      int pathSize = wcslen(Path);\n      unsigned int bufferSize = pathSize + sizeof(wchar_t) * 2;\n      std::string PathA;\n      PathA.resize(bufferSize);\n      errCode = WideCharToMultiByte(CP_ACP, 0, Path, pathSize, (char *)PathA.c_str(), bufferSize, NULL, NULL);\n      if (errCode == 0)\n        errCode = GetLastError();\n  #ifdef _DEBUG\n      if (errCode == ERROR_INSUFFICIENT_BUFFER) OutputDebugString(TEXT(\"WinIOCallback::WideCharToMultiByte::ERROR_INSUFFICIENT_BUFFER\"));\n      if (errCode == ERROR_INVALID_FLAGS) OutputDebugString(TEXT(\"WinIOCallback::WideCharToMultiByte::ERROR_INVALID_FLAGS\"));\n      if (errCode == ERROR_INVALID_PARAMETER) OutputDebugString(TEXT(\"WinIOCallback::WideCharToMultiByte::ERROR_INVALID_PARAMETER\"));\n  #endif\n      while (errCode == ERROR_INSUFFICIENT_BUFFER) {\n        // Increase the buffer size\n        bufferSize += MAX_PATH;\n        PathA.resize(bufferSize);\n        errCode = WideCharToMultiByte(CP_ACP, WC_SEPCHARS, Path, pathSize, (char *)PathA.c_str(), bufferSize, NULL, NULL);\n        if (errCode == 0)\n          errCode = GetLastError();\n      }\n      if (errCode != 0) {\n        mFile = CreateFileA(PathA.c_str(), AccessMode, ShareMode, NULL, Disposition, dwFlags, NULL);\n      } else {\n        mLastErrorStr = \"Couldn't convert Unicode filename to ANSI.\";\n        return mOk = false;\n      }\n    }\n    if ((mFile == INVALID_HANDLE_VALUE) || ((long)mFile == 0xffffffff)) {\n      //File was not opened\n      char err_msg[256];\n      DWORD error_code = GetLastError();\n      // An error message about the file already existing is not really an error message :P\n      if (error_code != ERROR_ALREADY_EXISTS) {\n        FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, 0, error_code, 0, err_msg, 255, NULL);\n        EBML_TRACE(\"Failed to open file \\\"%S\\\" in mode %d.\", Path, aMode);\n        mLastErrorStr = err_msg;\n        return mOk = false;\n      }\n    }\n    mCurrentPosition = 0;\n  \n    EBML_TRACE(\"Successfully opened file \\\"%S\\\" in mode %d. The handle is %p\\n\", Path, aMode, mFile);\n    return mOk = true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ebml/Debug.h\"\n#include \"WinIOCallback.h\"\n#include <cassert>\n\nSTART_LIBEBML_NAMESPACE\n\nWinIOCallback::WinIOCallback(const char* Path, const open_mode aMode, DWORD dwFlags)\n  :mFile(NULL), mOk(false)\n{\n  mOk = open(Path, aMode, dwFlags);\n\nWinIOCallback {\n  WinIOCallback::WinIOCallback(const wchar_t* Path, const open_mode aMode, DWORD dwFlags)\n    :mFile(NULL), mOk(false)\n  {\n    mOk = open(Path, aMode, dwFlags);\n  }\n}"
  }
]