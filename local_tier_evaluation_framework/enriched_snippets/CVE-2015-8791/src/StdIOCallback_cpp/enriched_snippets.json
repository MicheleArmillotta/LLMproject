[
  {
    "function_name": "close",
    "container": "StdIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/StdIOCallback.cpp",
    "lines": "177-191",
    "snippet": "void StdIOCallback::close()\n{\n  if(File==0)\n    return;\n\n  if(fclose(File)!=0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't close file \"<<File;\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n\n  File=0;\n}",
    "includes": [
      "#include \"ebml/EbmlConfig.h\"",
      "#include \"ebml/Debug.h\"",
      "#include \"ebml/StdIOCallback.h\"",
      "#include <sstream>",
      "#include <climits>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRTError",
          "args": [
            "Msg.str()"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Msg.str",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "File"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/StdIOCallback.h\"\n#include <sstream>\n#include <climits>\n#include <cassert>\n\nStdIOCallback {\n  void StdIOCallback::close()\n  {\n    if(File==0)\n      return;\n  \n    if(fclose(File)!=0) {\n  #if !defined(__GNUC__) || (__GNUC__ > 2)\n      stringstream Msg;\n      Msg<<\"Can't close file \"<<File;\n      throw CRTError(Msg.str());\n  #endif // GCC2\n    }\n  \n    File=0;\n  }\n}"
  },
  {
    "function_name": "getFilePointer",
    "container": "StdIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/StdIOCallback.cpp",
    "lines": "159-175",
    "snippet": "uint64 StdIOCallback::getFilePointer()\n{\n  assert(File!=0);\n\n#if 0\n  long Result=ftell(File);\n  if(Result<0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't tell the current file pointer position for \"<<File;\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n#endif\n\n  return mCurrentPosition;\n}",
    "includes": [
      "#include \"ebml/EbmlConfig.h\"",
      "#include \"ebml/Debug.h\"",
      "#include \"ebml/StdIOCallback.h\"",
      "#include <sstream>",
      "#include <climits>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRTError",
          "args": [
            "Msg.str()"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Msg.str",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftell",
          "args": [
            "File"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "File!=0"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/StdIOCallback.h\"\n#include <sstream>\n#include <climits>\n#include <cassert>\n\nStdIOCallback {\n  uint64 StdIOCallback::getFilePointer()\n  {\n    assert(File!=0);\n  \n  #if 0\n    long Result=ftell(File);\n    if(Result<0) {\n  #if !defined(__GNUC__) || (__GNUC__ > 2)\n      stringstream Msg;\n      Msg<<\"Can't tell the current file pointer position for \"<<File;\n      throw CRTError(Msg.str());\n  #endif // GCC2\n    }\n  #endif\n  \n    return mCurrentPosition;\n  }\n}"
  },
  {
    "function_name": "write",
    "container": "StdIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/StdIOCallback.cpp",
    "lines": "151-157",
    "snippet": "size_t StdIOCallback::write(const void*Buffer,size_t Size)\n{\n  assert(File!=0);\n  uint32 Result = fwrite(Buffer,1,Size,File);\n  mCurrentPosition += Result;\n  return Result;\n}",
    "includes": [
      "#include \"ebml/EbmlConfig.h\"",
      "#include \"ebml/Debug.h\"",
      "#include \"ebml/StdIOCallback.h\"",
      "#include <sstream>",
      "#include <climits>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "Buffer",
            "1",
            "Size",
            "File"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "File!=0"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/StdIOCallback.h\"\n#include <sstream>\n#include <climits>\n#include <cassert>\n\nStdIOCallback {\n  size_t StdIOCallback::write(const void*Buffer,size_t Size)\n  {\n    assert(File!=0);\n    uint32 Result = fwrite(Buffer,1,Size,File);\n    mCurrentPosition += Result;\n    return Result;\n  }\n}"
  },
  {
    "function_name": "setFilePointer",
    "container": "StdIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/StdIOCallback.cpp",
    "lines": "113-149",
    "snippet": "void StdIOCallback::setFilePointer(int64 Offset,seek_mode Mode)\n{\n  assert(File!=0);\n\n  // There is a numeric cast in the boost library, which would be quite nice for this checking\n  /*\n    SL : replaced because unknown class in cygwin\n    assert(Offset <= numeric_limits<long>::max());\n    assert(Offset >= numeric_limits<long>::min());\n  */\n\n  assert(Offset <= LONG_MAX);\n  assert(Offset >= LONG_MIN);\n\n  assert(Mode==SEEK_CUR||Mode==SEEK_END||Mode==SEEK_SET);\n\n  if(fseek(File,Offset,Mode)!=0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    ostringstream Msg;\n    Msg<<\"Failed to seek file \"<<File<<\" to offset \"<<(unsigned long)Offset<<\" in mode \"<<Mode;\n    throw CRTError(Msg.str());\n#endif // GCC2\n    mCurrentPosition = ftell(File);\n  } else {\n    switch ( Mode ) {\n      case SEEK_CUR:\n        mCurrentPosition += Offset;\n        break;\n      case SEEK_END:\n        mCurrentPosition = ftell(File);\n        break;\n      case SEEK_SET:\n        mCurrentPosition = Offset;\n        break;\n    }\n  }\n}",
    "includes": [
      "#include \"ebml/EbmlConfig.h\"",
      "#include \"ebml/Debug.h\"",
      "#include \"ebml/StdIOCallback.h\"",
      "#include <sstream>",
      "#include <climits>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftell",
          "args": [
            "File"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftell",
          "args": [
            "File"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRTError",
          "args": [
            "Msg.str()"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Msg.str",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fseek",
          "args": [
            "File",
            "Offset",
            "Mode"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "Mode==SEEK_CUR||Mode==SEEK_END||Mode==SEEK_SET"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "Offset >= LONG_MIN"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "Offset <= LONG_MAX"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "File!=0"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/StdIOCallback.h\"\n#include <sstream>\n#include <climits>\n#include <cassert>\n\nStdIOCallback {\n  void StdIOCallback::setFilePointer(int64 Offset,seek_mode Mode)\n  {\n    assert(File!=0);\n  \n    // There is a numeric cast in the boost library, which would be quite nice for this checking\n    /*\n      SL : replaced because unknown class in cygwin\n      assert(Offset <= numeric_limits<long>::max());\n      assert(Offset >= numeric_limits<long>::min());\n    */\n  \n    assert(Offset <= LONG_MAX);\n    assert(Offset >= LONG_MIN);\n  \n    assert(Mode==SEEK_CUR||Mode==SEEK_END||Mode==SEEK_SET);\n  \n    if(fseek(File,Offset,Mode)!=0) {\n  #if !defined(__GNUC__) || (__GNUC__ > 2)\n      ostringstream Msg;\n      Msg<<\"Failed to seek file \"<<File<<\" to offset \"<<(unsigned long)Offset<<\" in mode \"<<Mode;\n      throw CRTError(Msg.str());\n  #endif // GCC2\n      mCurrentPosition = ftell(File);\n    } else {\n      switch ( Mode ) {\n        case SEEK_CUR:\n          mCurrentPosition += Offset;\n          break;\n        case SEEK_END:\n          mCurrentPosition = ftell(File);\n          break;\n        case SEEK_SET:\n          mCurrentPosition = Offset;\n          break;\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "read",
    "container": "StdIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/StdIOCallback.cpp",
    "lines": "104-111",
    "snippet": "uint32 StdIOCallback::read(void*Buffer,size_t Size)\n{\n  assert(File!=0);\n\n  size_t result = fread(Buffer, 1, Size, File);\n  mCurrentPosition += result;\n  return result;\n}",
    "includes": [
      "#include \"ebml/EbmlConfig.h\"",
      "#include \"ebml/Debug.h\"",
      "#include \"ebml/StdIOCallback.h\"",
      "#include <sstream>",
      "#include <climits>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "Buffer",
            "1",
            "Size",
            "File"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "File!=0"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/StdIOCallback.h\"\n#include <sstream>\n#include <climits>\n#include <cassert>\n\nStdIOCallback {\n  uint32 StdIOCallback::read(void*Buffer,size_t Size)\n  {\n    assert(File!=0);\n  \n    size_t result = fread(Buffer, 1, Size, File);\n    mCurrentPosition += result;\n    return result;\n  }\n}"
  },
  {
    "function_name": "~StdIOCallback",
    "container": "StdIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/StdIOCallback.cpp",
    "lines": "97-100",
    "snippet": "StdIOCallback::~StdIOCallback()throw()\n{\n  close();\n}",
    "includes": [
      "#include \"ebml/EbmlConfig.h\"",
      "#include \"ebml/Debug.h\"",
      "#include \"ebml/StdIOCallback.h\"",
      "#include <sstream>",
      "#include <climits>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": "StdIOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/StdIOCallback.cpp",
          "lines": "177-191",
          "snippet": "void StdIOCallback::close()\n{\n  if(File==0)\n    return;\n\n  if(fclose(File)!=0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't close file \"<<File;\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n\n  File=0;\n}",
          "includes": [
            "#include \"ebml/EbmlConfig.h\"",
            "#include \"ebml/Debug.h\"",
            "#include \"ebml/StdIOCallback.h\"",
            "#include <sstream>",
            "#include <climits>",
            "#include <cassert>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/StdIOCallback.h\"\n#include <sstream>\n#include <climits>\n#include <cassert>\n\nStdIOCallback {\n  void StdIOCallback::close()\n  {\n    if(File==0)\n      return;\n  \n    if(fclose(File)!=0) {\n  #if !defined(__GNUC__) || (__GNUC__ > 2)\n      stringstream Msg;\n      Msg<<\"Can't close file \"<<File;\n      throw CRTError(Msg.str());\n  #endif // GCC2\n    }\n  \n    File=0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/StdIOCallback.h\"\n#include <sstream>\n#include <climits>\n#include <cassert>\n\nStdIOCallback {\n  StdIOCallback::~StdIOCallback()throw()\n  {\n    close();\n  }\n}"
  },
  {
    "function_name": "StdIOCallback",
    "container": "StdIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/StdIOCallback.cpp",
    "lines": "48-94",
    "snippet": "START_LIBEBML_NAMESPACE\n\nCRTError::CRTError(int nError, const std::string & Description)\n  :std::runtime_error(Description+\": \"+strerror(nError))\n  ,Error(nError)\n{\n}\n\nCRTError::CRTError(const std::string & Description,int nError)\n  :std::runtime_error(Description+\": \"+strerror(nError))\n  ,Error(nError)\n{\n}\n\n\nStdIOCallback::StdIOCallback(const char*Path, const open_mode aMode)\n{\n  assert(Path!=0);\n\n  const char *Mode;\n  switch (aMode) {\n    case MODE_READ:\n      Mode = \"rb\";\n      break;\n    case MODE_SAFE:\n      Mode = \"rb+\";\n      break;\n    case MODE_WRITE:\n      Mode = \"wb\";\n      break;\n    case MODE_CREATE:\n      Mode = \"wb+\";\n      break;\n    default:\n      throw 0;\n  }\n\n  File=fopen(Path,Mode);\n  if(File==0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't open stdio file \\\"\"<<Path<<\"\\\" in mode \\\"\"<<Mode<<\"\\\"\";\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n  mCurrentPosition = 0;\n}",
    "includes": [
      "#include \"ebml/EbmlConfig.h\"",
      "#include \"ebml/Debug.h\"",
      "#include \"ebml/StdIOCallback.h\"",
      "#include <sstream>",
      "#include <climits>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRTError",
          "args": [
            "Msg.str()"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Msg.str",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "Path",
            "Mode"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "Path!=0"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "nError"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "nError"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/StdIOCallback.h\"\n#include <sstream>\n#include <climits>\n#include <cassert>\n\nStdIOCallback {\n  START_LIBEBML_NAMESPACE\n  \n  CRTError::CRTError(int nError, const std::string & Description)\n    :std::runtime_error(Description+\": \"+strerror(nError))\n    ,Error(nError)\n  {\n  }\n  \n  CRTError::CRTError(const std::string & Description,int nError)\n    :std::runtime_error(Description+\": \"+strerror(nError))\n    ,Error(nError)\n  {\n  }\n  \n  \n  StdIOCallback::StdIOCallback(const char*Path, const open_mode aMode)\n  {\n    assert(Path!=0);\n  \n    const char *Mode;\n    switch (aMode) {\n      case MODE_READ:\n        Mode = \"rb\";\n        break;\n      case MODE_SAFE:\n        Mode = \"rb+\";\n        break;\n      case MODE_WRITE:\n        Mode = \"wb\";\n        break;\n      case MODE_CREATE:\n        Mode = \"wb+\";\n        break;\n      default:\n        throw 0;\n    }\n  \n    File=fopen(Path,Mode);\n    if(File==0) {\n  #if !defined(__GNUC__) || (__GNUC__ > 2)\n      stringstream Msg;\n      Msg<<\"Can't open stdio file \\\"\"<<Path<<\"\\\" in mode \\\"\"<<Mode<<\"\\\"\";\n      throw CRTError(Msg.str());\n  #endif // GCC2\n    }\n    mCurrentPosition = 0;\n  }\n}"
  }
]