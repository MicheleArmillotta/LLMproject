[
  {
    "function_name": "ReadData",
    "container": "EbmlUnicodeString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "347-372",
    "snippet": "filepos_t EbmlUnicodeString::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    if (GetSize() == 0) {\n      Value = UTFstring::value_type(0);\n      SetValueIsSet();\n    } else {\n      char *Buffer = new (std::nothrow) char[GetSize()+1];\n      if (Buffer == NULL) {\n        // impossible to read, skip it\n        input.setFilePointer(GetSize(), seek_current);\n      } else {\n        input.readFully(Buffer, GetSize());\n        if (Buffer[GetSize()-1] != 0) {\n          Buffer[GetSize()] = 0;\n        }\n\n        Value.SetUTF8(Buffer); // implicit conversion to std::string\n        delete [] Buffer;\n        SetValueIsSet();\n      }\n    }\n  }\n\n  return GetSize();\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetSize",
          "args": [],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "GetSize",
          "container": "SafeReadIOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/SafeReadIOCallback.cpp",
          "lines": "88-92",
          "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
          "includes": [
            "#include \"ebml/SafeReadIOCallback.h\"",
            "#include \"ebml/MemReadIOCallback.h\"",
            "#include \"ebml/EbmlBinary.h\"",
            "#include <cstring>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/SafeReadIOCallback.h\"\n#include \"ebml/MemReadIOCallback.h\"\n#include \"ebml/EbmlBinary.h\"\n#include <cstring>\n\nSafeReadIOCallback {\n  size_t\n  SafeReadIOCallback::GetSize()\n    const {\n    return mSize;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetValueIsSet",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.SetUTF8",
          "args": [
            "Buffer"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "SetUTF8",
          "container": "UTFstring",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
          "lines": "147-151",
          "snippet": "void UTFstring::SetUTF8(const std::string & _aStr)\n{\n  UTF8string = _aStr;\n  UpdateFromUTF8();\n}",
          "includes": [
            "#include \"ebml/EbmlUnicodeString.h\"",
            "#include <wchar.h>",
            "#include <cassert>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring {\n  void UTFstring::SetUTF8(const std::string & _aStr)\n  {\n    UTF8string = _aStr;\n    UpdateFromUTF8();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.readFully",
          "args": [
            "Buffer",
            "GetSize()"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "readFully",
          "container": "IOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/IOCallback.cpp",
          "lines": "67-79",
          "snippet": "void IOCallback::readFully(void*Buffer,size_t Size)\n{\n  if(Buffer == NULL)\n    throw;\n\n  if(read(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in readFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
          "includes": [
            "#include \"ebml/IOCallback.h\"",
            "#include <stdexcept>",
            "#include <sstream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/IOCallback.h\"\n#include <stdexcept>\n#include <sstream>\n\nIOCallback {\n  void IOCallback::readFully(void*Buffer,size_t Size)\n  {\n    if(Buffer == NULL)\n      throw;\n  \n    if(read(Buffer,Size) != Size) {\n  #if !defined(__GNUC__) || (__GNUC__ > 2)\n      stringstream Msg;\n      Msg<<\"EOF in readFully(\"<<Buffer<<\",\"<<Size<<\")\";\n      throw runtime_error(Msg.str());\n  #endif // GCC2\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.setFilePointer",
          "args": [
            "GetSize()",
            "seek_current"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "setFilePointer",
          "container": "StdIOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/StdIOCallback.cpp",
          "lines": "113-149",
          "snippet": "void StdIOCallback::setFilePointer(int64 Offset,seek_mode Mode)\n{\n  assert(File!=0);\n\n  // There is a numeric cast in the boost library, which would be quite nice for this checking\n  /*\n    SL : replaced because unknown class in cygwin\n    assert(Offset <= numeric_limits<long>::max());\n    assert(Offset >= numeric_limits<long>::min());\n  */\n\n  assert(Offset <= LONG_MAX);\n  assert(Offset >= LONG_MIN);\n\n  assert(Mode==SEEK_CUR||Mode==SEEK_END||Mode==SEEK_SET);\n\n  if(fseek(File,Offset,Mode)!=0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    ostringstream Msg;\n    Msg<<\"Failed to seek file \"<<File<<\" to offset \"<<(unsigned long)Offset<<\" in mode \"<<Mode;\n    throw CRTError(Msg.str());\n#endif // GCC2\n    mCurrentPosition = ftell(File);\n  } else {\n    switch ( Mode ) {\n      case SEEK_CUR:\n        mCurrentPosition += Offset;\n        break;\n      case SEEK_END:\n        mCurrentPosition = ftell(File);\n        break;\n      case SEEK_SET:\n        mCurrentPosition = Offset;\n        break;\n    }\n  }\n}",
          "includes": [
            "#include \"ebml/EbmlConfig.h\"",
            "#include \"ebml/Debug.h\"",
            "#include \"ebml/StdIOCallback.h\"",
            "#include <sstream>",
            "#include <climits>",
            "#include <cassert>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/StdIOCallback.h\"\n#include <sstream>\n#include <climits>\n#include <cassert>\n\nStdIOCallback {\n  void StdIOCallback::setFilePointer(int64 Offset,seek_mode Mode)\n  {\n    assert(File!=0);\n  \n    // There is a numeric cast in the boost library, which would be quite nice for this checking\n    /*\n      SL : replaced because unknown class in cygwin\n      assert(Offset <= numeric_limits<long>::max());\n      assert(Offset >= numeric_limits<long>::min());\n    */\n  \n    assert(Offset <= LONG_MAX);\n    assert(Offset >= LONG_MIN);\n  \n    assert(Mode==SEEK_CUR||Mode==SEEK_END||Mode==SEEK_SET);\n  \n    if(fseek(File,Offset,Mode)!=0) {\n  #if !defined(__GNUC__) || (__GNUC__ > 2)\n      ostringstream Msg;\n      Msg<<\"Failed to seek file \"<<File<<\" to offset \"<<(unsigned long)Offset<<\" in mode \"<<Mode;\n      throw CRTError(Msg.str());\n  #endif // GCC2\n      mCurrentPosition = ftell(File);\n    } else {\n      switch ( Mode ) {\n        case SEEK_CUR:\n          mCurrentPosition += Offset;\n          break;\n        case SEEK_END:\n          mCurrentPosition = ftell(File);\n          break;\n        case SEEK_SET:\n          mCurrentPosition = Offset;\n          break;\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetValueIsSet",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UTFstring::value_type",
          "args": [
            "0"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nEbmlUnicodeString {\n  filepos_t EbmlUnicodeString::ReadData(IOCallback & input, ScopeMode ReadFully)\n  {\n    if (ReadFully != SCOPE_NO_DATA) {\n      if (GetSize() == 0) {\n        Value = UTFstring::value_type(0);\n        SetValueIsSet();\n      } else {\n        char *Buffer = new (std::nothrow) char[GetSize()+1];\n        if (Buffer == NULL) {\n          // impossible to read, skip it\n          input.setFilePointer(GetSize(), seek_current);\n        } else {\n          input.readFully(Buffer, GetSize());\n          if (Buffer[GetSize()-1] != 0) {\n            Buffer[GetSize()] = 0;\n          }\n  \n          Value.SetUTF8(Buffer); // implicit conversion to std::string\n          delete [] Buffer;\n          SetValueIsSet();\n        }\n      }\n    }\n  \n    return GetSize();\n  }\n}"
  },
  {
    "function_name": "UpdateSize",
    "container": "EbmlUnicodeString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "332-342",
    "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetSize",
          "args": [],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "GetSize",
          "container": "SafeReadIOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/SafeReadIOCallback.cpp",
          "lines": "88-92",
          "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
          "includes": [
            "#include \"ebml/SafeReadIOCallback.h\"",
            "#include \"ebml/MemReadIOCallback.h\"",
            "#include \"ebml/EbmlBinary.h\"",
            "#include <cstring>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/SafeReadIOCallback.h\"\n#include \"ebml/MemReadIOCallback.h\"\n#include \"ebml/EbmlBinary.h\"\n#include <cstring>\n\nSafeReadIOCallback {\n  size_t\n  SafeReadIOCallback::GetSize()\n    const {\n    return mSize;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetSize_",
          "args": [
            "GetDefaultSize()"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetSize_",
          "args": [
            "Value.GetUTF8().length()"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.GetUTF8",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.GetUTF8",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsDefaultValue",
          "args": [],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nEbmlUnicodeString {\n  uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n  {\n    if (!bWithDefault && IsDefaultValue())\n      return 0;\n  \n    SetSize_(Value.GetUTF8().length());\n    if (GetSize() < GetDefaultSize())\n      SetSize_(GetDefaultSize());\n  \n    return GetSize();\n  }\n}"
  },
  {
    "function_name": "GetValueUTF8",
    "container": "EbmlUnicodeString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "325-327",
    "snippet": "std::string EbmlUnicodeString::GetValueUTF8() const {\n  return Value.GetUTF8();\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Value.GetUTF8",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nEbmlUnicodeString {\n  std::string EbmlUnicodeString::GetValueUTF8() const {\n    return Value.GetUTF8();\n  }\n}"
  },
  {
    "function_name": "GetValue",
    "container": "EbmlUnicodeString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "321-323",
    "snippet": "UTFstring EbmlUnicodeString::GetValue() const {\n  return Value;\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nEbmlUnicodeString {\n  UTFstring EbmlUnicodeString::GetValue() const {\n    return Value;\n  }\n}"
  },
  {
    "function_name": "RenderData",
    "container": "EbmlUnicodeString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "279-300",
    "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.writeFully",
          "args": [
            "Pad",
            "GetDefaultSize() - Result"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "writeFully",
          "container": "IOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/IOCallback.cpp",
          "lines": "46-63",
          "snippet": "START_LIBEBML_NAMESPACE\n\nvoid IOCallback::writeFully(const void*Buffer,size_t Size)\n{\n  if (Size == 0)\n    return;\n\n  if (Buffer == NULL)\n    throw;\n\n  if(write(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in writeFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
          "includes": [
            "#include \"ebml/IOCallback.h\"",
            "#include <stdexcept>",
            "#include <sstream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/IOCallback.h\"\n#include <stdexcept>\n#include <sstream>\n\nIOCallback {\n  START_LIBEBML_NAMESPACE\n  \n  void IOCallback::writeFully(const void*Buffer,size_t Size)\n  {\n    if (Size == 0)\n      return;\n  \n    if (Buffer == NULL)\n      throw;\n  \n    if(write(Buffer,Size) != Size) {\n  #if !defined(__GNUC__) || (__GNUC__ > 2)\n      stringstream Msg;\n      Msg<<\"EOF in writeFully(\"<<Buffer<<\",\"<<Size<<\")\";\n      throw runtime_error(Msg.str());\n  #endif // GCC2\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "Pad",
            "0x00",
            "GetDefaultSize() - Result"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.GetUTF8",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.GetUTF8",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.GetUTF8",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.GetUTF8",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nEbmlUnicodeString {\n  filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n  {\n    uint32 Result = Value.GetUTF8().length();\n  \n    if (Result != 0) {\n      output.writeFully(Value.GetUTF8().c_str(), Result);\n    }\n  \n    if (Result < GetDefaultSize()) {\n      // pad the rest with 0\n      binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n      if (Pad != NULL) {\n        memset(Pad, 0x00, GetDefaultSize() - Result);\n        output.writeFully(Pad, GetDefaultSize() - Result);\n  \n        Result = GetDefaultSize();\n        delete [] Pad;\n      }\n    }\n  \n    return Result;\n  }\n}"
  },
  {
    "function_name": "SetDefaultValue",
    "container": "EbmlUnicodeString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "261-266",
    "snippet": "void EbmlUnicodeString::SetDefaultValue(UTFstring & aValue)\n{\n  assert(!DefaultISset());\n  DefaultValue = aValue;\n  SetDefaultIsSet();\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetDefaultIsSet",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!DefaultISset()"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultISset",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nEbmlUnicodeString {\n  void EbmlUnicodeString::SetDefaultValue(UTFstring & aValue)\n  {\n    assert(!DefaultISset());\n    DefaultValue = aValue;\n    SetDefaultIsSet();\n  }\n}"
  },
  {
    "function_name": "EbmlUnicodeString",
    "container": "EbmlUnicodeString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "254-259",
    "snippet": "EbmlUnicodeString::EbmlUnicodeString(const EbmlUnicodeString & ElementToClone)\n  :EbmlElement(ElementToClone)\n  ,Value(ElementToClone.Value)\n  ,DefaultValue(ElementToClone.DefaultValue)\n{\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nEbmlUnicodeString {\n  EbmlUnicodeString::EbmlUnicodeString(const EbmlUnicodeString & ElementToClone)\n    :EbmlElement(ElementToClone)\n    ,Value(ElementToClone.Value)\n    ,DefaultValue(ElementToClone.DefaultValue)\n  {\n  }\n}"
  },
  {
    "function_name": "EbmlUnicodeString",
    "container": "EbmlUnicodeString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "247-252",
    "snippet": "EbmlUnicodeString::EbmlUnicodeString(const UTFstring & aDefaultValue)\n  :EbmlElement(0, true), Value(aDefaultValue), DefaultValue(aDefaultValue)\n{\n  SetDefaultSize(0);\n  SetDefaultIsSet();\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetDefaultIsSet",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetDefaultSize",
          "args": [
            "0"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nEbmlUnicodeString {\n  EbmlUnicodeString::EbmlUnicodeString(const UTFstring & aDefaultValue)\n    :EbmlElement(0, true), Value(aDefaultValue), DefaultValue(aDefaultValue)\n  {\n    SetDefaultSize(0);\n    SetDefaultIsSet();\n  }\n}"
  },
  {
    "function_name": "EbmlUnicodeString",
    "container": "EbmlUnicodeString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "241-245",
    "snippet": "EbmlUnicodeString::EbmlUnicodeString()\n  :EbmlElement(0, false)\n{\n  SetDefaultSize(0);\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetDefaultSize",
          "args": [
            "0"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nEbmlUnicodeString {\n  EbmlUnicodeString::EbmlUnicodeString()\n    :EbmlElement(0, false)\n  {\n    SetDefaultSize(0);\n  }\n}"
  },
  {
    "function_name": "wcscmp_internal",
    "container": "UTFstring",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "230-237",
    "snippet": "bool UTFstring::wcscmp_internal(const wchar_t *str1, const wchar_t *str2)\n{\n  size_t Index=0;\n  while (str1[Index] == str2[Index] && str1[Index] != 0) {\n    Index++;\n  }\n  return (str1[Index] == str2[Index]);\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring {\n  bool UTFstring::wcscmp_internal(const wchar_t *str1, const wchar_t *str2)\n  {\n    size_t Index=0;\n    while (str1[Index] == str2[Index] && str1[Index] != 0) {\n      Index++;\n    }\n    return (str1[Index] == str2[Index]);\n  }\n}"
  },
  {
    "function_name": "UpdateFromUCS2",
    "container": "UTFstring",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "198-228",
    "snippet": "void UTFstring::UpdateFromUCS2()\n{\n  // find the size of the final UTF-8 string\n  size_t i,Size=0;\n  for (i=0; i<_Length; i++) {\n    if (_Data[i] < 0x80) {\n      Size++;\n    } else if (_Data[i] < 0x800) {\n      Size += 2;\n    } else {\n      Size += 3;\n    }\n  }\n  std::string::value_type *tmpStr = new std::string::value_type[Size+1];\n  for (i=0, Size=0; i<_Length; i++) {\n    if (_Data[i] < 0x80) {\n      tmpStr[Size++] = _Data[i];\n    } else if (_Data[i] < 0x800) {\n      tmpStr[Size++] = 0xC0 | (_Data[i] >> 6);\n      tmpStr[Size++] = 0x80 | (_Data[i] & 0x3F);\n    } else {\n      tmpStr[Size++] = 0xE0 | (_Data[i] >> 12);\n      tmpStr[Size++] = 0x80 | ((_Data[i] >> 6) & 0x3F);\n      tmpStr[Size++] = 0x80 | (_Data[i] & 0x3F);\n    }\n  }\n  tmpStr[Size] = 0;\n  UTF8string = tmpStr; // implicit conversion\n  delete [] tmpStr;\n\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring {\n  void UTFstring::UpdateFromUCS2()\n  {\n    // find the size of the final UTF-8 string\n    size_t i,Size=0;\n    for (i=0; i<_Length; i++) {\n      if (_Data[i] < 0x80) {\n        Size++;\n      } else if (_Data[i] < 0x800) {\n        Size += 2;\n      } else {\n        Size += 3;\n      }\n    }\n    std::string::value_type *tmpStr = new std::string::value_type[Size+1];\n    for (i=0, Size=0; i<_Length; i++) {\n      if (_Data[i] < 0x80) {\n        tmpStr[Size++] = _Data[i];\n      } else if (_Data[i] < 0x800) {\n        tmpStr[Size++] = 0xC0 | (_Data[i] >> 6);\n        tmpStr[Size++] = 0x80 | (_Data[i] & 0x3F);\n      } else {\n        tmpStr[Size++] = 0xE0 | (_Data[i] >> 12);\n        tmpStr[Size++] = 0x80 | ((_Data[i] >> 6) & 0x3F);\n        tmpStr[Size++] = 0x80 | (_Data[i] & 0x3F);\n      }\n    }\n    tmpStr[Size] = 0;\n    UTF8string = tmpStr; // implicit conversion\n    delete [] tmpStr;\n  \n  }\n}"
  },
  {
    "function_name": "UpdateFromUTF8",
    "container": "UTFstring",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "156-196",
    "snippet": "void UTFstring::UpdateFromUTF8()\n{\n  delete [] _Data;\n  // find the size of the final UCS-2 string\n  size_t i;\n  const size_t SrcLength = UTF8string.length();\n  for (_Length=0, i=0; i<SrcLength; _Length++) {\n    const unsigned int CharLength = UTFCharLength(static_cast<uint8>(UTF8string[i]));\n    if ((CharLength >= 1) && (CharLength <= 4))\n      i += CharLength;\n    else\n      // Invalid size?\n      break;\n  }\n  _Data = new wchar_t[_Length+1];\n  size_t j;\n  for (j=0, i=0; i<SrcLength; j++) {\n    const uint8 lead              = static_cast<uint8>(UTF8string[i]);\n    const unsigned int CharLength = UTFCharLength(lead);\n    if ((CharLength < 1) || (CharLength > 4))\n      // Invalid char?\n      break;\n\n    if ((i + CharLength) > SrcLength)\n      // Guard against invalid memory access beyond the end of the\n      // source buffer.\n      break;\n\n    if (CharLength == 1)\n      _Data[j] = lead;\n    else if (CharLength == 2)\n      _Data[j] = ((lead & 0x1F) << 6) + (UTF8string[i+1] & 0x3F);\n    else if (CharLength == 3)\n      _Data[j] = ((lead & 0x0F) << 12) + ((UTF8string[i+1] & 0x3F) << 6) + (UTF8string[i+2] & 0x3F);\n    else if (CharLength == 4)\n      _Data[j] = ((lead & 0x07) << 18) + ((UTF8string[i+1] & 0x3F) << 12) + ((UTF8string[i+2] & 0x3F) << 6) + (UTF8string[i+3] & 0x3F);\n\n    i += CharLength;\n  }\n  _Data[j] = 0;\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UTFCharLength",
          "args": [
            "lead"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "UTFCharLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
          "lines": "46-63",
          "snippet": "START_LIBEBML_NAMESPACE\n\n// ===================== UTFstring class ===================\n\nstatic unsigned int UTFCharLength(uint8 lead)\n{\n  if (lead < 0x80)\n    return 1;\n  else if ((lead >> 5) == 0x6)\n    return 2;\n  else if ((lead >> 4) == 0xe)\n    return 3;\n  else if ((lead >> 3) == 0x1e)\n    return 4;\n  else\n    // Invalid size?\n    return 0;\n}",
          "includes": [
            "#include \"ebml/EbmlUnicodeString.h\"",
            "#include <wchar.h>",
            "#include <cassert>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nSTART_LIBEBML_NAMESPACE\n\n// ===================== UTFstring class ===================\n\nstatic unsigned int UTFCharLength(uint8 lead)\n{\n  if (lead < 0x80)\n    return 1;\n  else if ((lead >> 5) == 0x6)\n    return 2;\n  else if ((lead >> 4) == 0xe)\n    return 3;\n  else if ((lead >> 3) == 0x1e)\n    return 4;\n  else\n    // Invalid size?\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<uint8>",
          "args": [
            "UTF8string[i]"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint8>",
          "args": [
            "UTF8string[i]"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UTF8string.length",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring {\n  void UTFstring::UpdateFromUTF8()\n  {\n    delete [] _Data;\n    // find the size of the final UCS-2 string\n    size_t i;\n    const size_t SrcLength = UTF8string.length();\n    for (_Length=0, i=0; i<SrcLength; _Length++) {\n      const unsigned int CharLength = UTFCharLength(static_cast<uint8>(UTF8string[i]));\n      if ((CharLength >= 1) && (CharLength <= 4))\n        i += CharLength;\n      else\n        // Invalid size?\n        break;\n    }\n    _Data = new wchar_t[_Length+1];\n    size_t j;\n    for (j=0, i=0; i<SrcLength; j++) {\n      const uint8 lead              = static_cast<uint8>(UTF8string[i]);\n      const unsigned int CharLength = UTFCharLength(lead);\n      if ((CharLength < 1) || (CharLength > 4))\n        // Invalid char?\n        break;\n  \n      if ((i + CharLength) > SrcLength)\n        // Guard against invalid memory access beyond the end of the\n        // source buffer.\n        break;\n  \n      if (CharLength == 1)\n        _Data[j] = lead;\n      else if (CharLength == 2)\n        _Data[j] = ((lead & 0x1F) << 6) + (UTF8string[i+1] & 0x3F);\n      else if (CharLength == 3)\n        _Data[j] = ((lead & 0x0F) << 12) + ((UTF8string[i+1] & 0x3F) << 6) + (UTF8string[i+2] & 0x3F);\n      else if (CharLength == 4)\n        _Data[j] = ((lead & 0x07) << 18) + ((UTF8string[i+1] & 0x3F) << 12) + ((UTF8string[i+2] & 0x3F) << 6) + (UTF8string[i+3] & 0x3F);\n  \n      i += CharLength;\n    }\n    _Data[j] = 0;\n  }\n}"
  },
  {
    "function_name": "SetUTF8",
    "container": "UTFstring",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "147-151",
    "snippet": "void UTFstring::SetUTF8(const std::string & _aStr)\n{\n  UTF8string = _aStr;\n  UpdateFromUTF8();\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpdateFromUTF8",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "UpdateFromUTF8",
          "container": "UTFstring",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
          "lines": "156-196",
          "snippet": "void UTFstring::UpdateFromUTF8()\n{\n  delete [] _Data;\n  // find the size of the final UCS-2 string\n  size_t i;\n  const size_t SrcLength = UTF8string.length();\n  for (_Length=0, i=0; i<SrcLength; _Length++) {\n    const unsigned int CharLength = UTFCharLength(static_cast<uint8>(UTF8string[i]));\n    if ((CharLength >= 1) && (CharLength <= 4))\n      i += CharLength;\n    else\n      // Invalid size?\n      break;\n  }\n  _Data = new wchar_t[_Length+1];\n  size_t j;\n  for (j=0, i=0; i<SrcLength; j++) {\n    const uint8 lead              = static_cast<uint8>(UTF8string[i]);\n    const unsigned int CharLength = UTFCharLength(lead);\n    if ((CharLength < 1) || (CharLength > 4))\n      // Invalid char?\n      break;\n\n    if ((i + CharLength) > SrcLength)\n      // Guard against invalid memory access beyond the end of the\n      // source buffer.\n      break;\n\n    if (CharLength == 1)\n      _Data[j] = lead;\n    else if (CharLength == 2)\n      _Data[j] = ((lead & 0x1F) << 6) + (UTF8string[i+1] & 0x3F);\n    else if (CharLength == 3)\n      _Data[j] = ((lead & 0x0F) << 12) + ((UTF8string[i+1] & 0x3F) << 6) + (UTF8string[i+2] & 0x3F);\n    else if (CharLength == 4)\n      _Data[j] = ((lead & 0x07) << 18) + ((UTF8string[i+1] & 0x3F) << 12) + ((UTF8string[i+2] & 0x3F) << 6) + (UTF8string[i+3] & 0x3F);\n\n    i += CharLength;\n  }\n  _Data[j] = 0;\n}",
          "includes": [
            "#include \"ebml/EbmlUnicodeString.h\"",
            "#include <wchar.h>",
            "#include <cassert>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring {\n  void UTFstring::UpdateFromUTF8()\n  {\n    delete [] _Data;\n    // find the size of the final UCS-2 string\n    size_t i;\n    const size_t SrcLength = UTF8string.length();\n    for (_Length=0, i=0; i<SrcLength; _Length++) {\n      const unsigned int CharLength = UTFCharLength(static_cast<uint8>(UTF8string[i]));\n      if ((CharLength >= 1) && (CharLength <= 4))\n        i += CharLength;\n      else\n        // Invalid size?\n        break;\n    }\n    _Data = new wchar_t[_Length+1];\n    size_t j;\n    for (j=0, i=0; i<SrcLength; j++) {\n      const uint8 lead              = static_cast<uint8>(UTF8string[i]);\n      const unsigned int CharLength = UTFCharLength(lead);\n      if ((CharLength < 1) || (CharLength > 4))\n        // Invalid char?\n        break;\n  \n      if ((i + CharLength) > SrcLength)\n        // Guard against invalid memory access beyond the end of the\n        // source buffer.\n        break;\n  \n      if (CharLength == 1)\n        _Data[j] = lead;\n      else if (CharLength == 2)\n        _Data[j] = ((lead & 0x1F) << 6) + (UTF8string[i+1] & 0x3F);\n      else if (CharLength == 3)\n        _Data[j] = ((lead & 0x0F) << 12) + ((UTF8string[i+1] & 0x3F) << 6) + (UTF8string[i+2] & 0x3F);\n      else if (CharLength == 4)\n        _Data[j] = ((lead & 0x07) << 18) + ((UTF8string[i+1] & 0x3F) << 12) + ((UTF8string[i+2] & 0x3F) << 6) + (UTF8string[i+3] & 0x3F);\n  \n      i += CharLength;\n    }\n    _Data[j] = 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring {\n  void UTFstring::SetUTF8(const std::string & _aStr)\n  {\n    UTF8string = _aStr;\n    UpdateFromUTF8();\n  }\n}"
  },
  {
    "function_name": "operator==",
    "container": "UTFstring",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "138-145",
    "snippet": "bool UTFstring::operator==(const UTFstring& _aStr) const\n{\n  if ((_Data == NULL) && (_aStr._Data == NULL))\n    return true;\n  if ((_Data == NULL) || (_aStr._Data == NULL))\n    return false;\n  return wcscmp_internal(_Data, _aStr._Data);\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wcscmp_internal",
          "args": [
            "_Data",
            "_aStr._Data"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "wcscmp_internal",
          "container": "UTFstring",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
          "lines": "230-237",
          "snippet": "bool UTFstring::wcscmp_internal(const wchar_t *str1, const wchar_t *str2)\n{\n  size_t Index=0;\n  while (str1[Index] == str2[Index] && str1[Index] != 0) {\n    Index++;\n  }\n  return (str1[Index] == str2[Index]);\n}",
          "includes": [
            "#include \"ebml/EbmlUnicodeString.h\"",
            "#include <wchar.h>",
            "#include <cassert>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring {\n  bool UTFstring::wcscmp_internal(const wchar_t *str1, const wchar_t *str2)\n  {\n    size_t Index=0;\n    while (str1[Index] == str2[Index] && str1[Index] != 0) {\n      Index++;\n    }\n    return (str1[Index] == str2[Index]);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring {\n  bool UTFstring::operator==(const UTFstring& _aStr) const\n  {\n    if ((_Data == NULL) && (_aStr._Data == NULL))\n      return true;\n    if ((_Data == NULL) || (_aStr._Data == NULL))\n      return false;\n    return wcscmp_internal(_Data, _aStr._Data);\n  }\n}"
  },
  {
    "function_name": "UTFstring",
    "container": "UTFstring",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "89-94",
    "snippet": "UTFstring::UTFstring(const UTFstring & _aBuf)\n  :_Length(0)\n  ,_Data(NULL)\n{\n  *this = _aBuf.c_str();\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_aBuf.c_str",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring {\n  UTFstring::UTFstring(const UTFstring & _aBuf)\n    :_Length(0)\n    ,_Data(NULL)\n  {\n    *this = _aBuf.c_str();\n  }\n}"
  },
  {
    "function_name": "~UTFstring",
    "container": "UTFstring",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "84-87",
    "snippet": "UTFstring::~UTFstring()\n{\n  delete [] _Data;\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring {\n  UTFstring::~UTFstring()\n  {\n    delete [] _Data;\n  }\n}"
  },
  {
    "function_name": "UTFstring",
    "container": "UTFstring",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "77-82",
    "snippet": "UTFstring::UTFstring(std::wstring const &_aBuf)\n  :_Length(0)\n  ,_Data(NULL)\n{\n  *this = _aBuf.c_str();\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_aBuf.c_str",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring {\n  UTFstring::UTFstring(std::wstring const &_aBuf)\n    :_Length(0)\n    ,_Data(NULL)\n  {\n    *this = _aBuf.c_str();\n  }\n}"
  },
  {
    "function_name": "UTFstring",
    "container": "UTFstring",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "70-75",
    "snippet": "UTFstring::UTFstring(const wchar_t * _aBuf)\n  :_Length(0)\n  ,_Data(NULL)\n{\n  *this = _aBuf;\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring {\n  UTFstring::UTFstring(const wchar_t * _aBuf)\n    :_Length(0)\n    ,_Data(NULL)\n  {\n    *this = _aBuf;\n  }\n}"
  },
  {
    "function_name": "UTFstring",
    "container": "UTFstring",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "65-68",
    "snippet": "UTFstring::UTFstring()\n  :_Length(0)\n  ,_Data(NULL)\n{}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring {\n  UTFstring::UTFstring()\n    :_Length(0)\n    ,_Data(NULL)\n  {}\n}"
  },
  {
    "function_name": "UTFCharLength",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8791/repo/src/EbmlUnicodeString.cpp",
    "lines": "46-63",
    "snippet": "START_LIBEBML_NAMESPACE\n\n// ===================== UTFstring class ===================\n\nstatic unsigned int UTFCharLength(uint8 lead)\n{\n  if (lead < 0x80)\n    return 1;\n  else if ((lead >> 5) == 0x6)\n    return 2;\n  else if ((lead >> 4) == 0xe)\n    return 3;\n  else if ((lead >> 3) == 0x1e)\n    return 4;\n  else\n    // Invalid size?\n    return 0;\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nSTART_LIBEBML_NAMESPACE\n\n// ===================== UTFstring class ===================\n\nstatic unsigned int UTFCharLength(uint8 lead)\n{\n  if (lead < 0x80)\n    return 1;\n  else if ((lead >> 5) == 0x6)\n    return 2;\n  else if ((lead >> 4) == 0xe)\n    return 3;\n  else if ((lead >> 3) == 0x1e)\n    return 4;\n  else\n    // Invalid size?\n    return 0;\n}"
  }
]