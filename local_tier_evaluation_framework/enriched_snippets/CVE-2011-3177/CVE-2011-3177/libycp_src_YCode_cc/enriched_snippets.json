[
  {
    "function_name": "type",
    "container": "YFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "858-868",
    "snippet": "constTypePtr\nYFunction::type () const\n{\n    // FIXME: return type undefined\n    FunctionTypePtr f = new FunctionType (Type::Unspec);\n    for (unsigned int p = 0; p < parameterCount(); p++)\n    {\n\tf->concat (parameter(p)->type());\n    }\n    return f;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f->concat",
          "args": [
            "parameter(p)->type()"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "concat",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1649-1661",
          "snippet": "void\nFunctionType::concat (constTypePtr t)\n{\n    if (!m_arguments)\n    {\n\tm_arguments = TupleTypePtr (new TupleType (t));\n    }\n    else\n    {\n\tm_arguments->concat (t);\n    }\n    return;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  void\n  FunctionType::concat (constTypePtr t)\n  {\n      if (!m_arguments)\n      {\n  \tm_arguments = TupleTypePtr (new TupleType (t));\n      }\n      else\n      {\n  \tm_arguments->concat (t);\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parameter",
          "args": [],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "parameters",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1686-1690",
          "snippet": "constTupleTypePtr\nFunctionType::parameters () const\n{\n    return m_arguments;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  constTupleTypePtr\n  FunctionType::parameters () const\n  {\n      return m_arguments;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parameter",
          "args": [
            "p"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "parameter",
          "container": "YFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "682-686",
          "snippet": "SymbolEntryPtr\nYFunction::parameter (unsigned int position) const\n{\n    return (m_declaration ? m_declaration->symbolEntry (position) : 0);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  SymbolEntryPtr\n  YFunction::parameter (unsigned int position) const\n  {\n      return (m_declaration ? m_declaration->symbolEntry (position) : 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parameterCount",
          "args": [],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  constTypePtr\n  YFunction::type () const\n  {\n      // FIXME: return type undefined\n      FunctionTypePtr f = new FunctionType (Type::Unspec);\n      for (unsigned int p = 0; p < parameterCount(); p++)\n      {\n  \tf->concat (parameter(p)->type());\n      }\n      return f;\n  }\n}"
  },
  {
    "function_name": "YFunction",
    "container": "YFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "736-758",
    "snippet": "YFunction::YFunction (bytecodeistream & str)\n    : YCode ()\n    , m_declaration (0)\n    , m_definition (0)\n    , m_is_global (false)\t\t// don't care about globalness any more\n{\n#if DO_DEBUG\n    y2debug (\"YFunction::YFunction (from stream)\");\n#endif\n    if (Bytecode::readBool (str))\n    {\n#if DO_DEBUG\n\ty2debug (\"YFunction::YFunction: need_declaration !\");\n#endif\n\tm_declaration = (YBlockPtr)Bytecode::readCode (str);\n\tif ((m_declaration == 0)\n\t    || (!m_declaration->isBlock()))\n\t{\n\t    y2error (\"Error reading declaration\");\n\t}\n    }\n    // read of definition block is done in YSFunction(str)\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Error reading declaration\""
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_declaration->isBlock",
          "args": [],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "isBlock",
          "container": "YCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "90-94",
          "snippet": "bool\nYCode::isBlock () const\n{\n    return false;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  bool\n  YCode::isBlock () const\n  {\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YFunction::YFunction: need_declaration !\""
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readBool",
          "args": [
            "str"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "readBool",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "158-172",
          "snippet": "bool\nBytecode::readBool (bytecodeistream & str)\n{\n    char c;\n    str.get (c);\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n#endif\n\n    if (c != 0)\n    {\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readBool (bytecodeistream & str)\n  {\n      char c;\n      str.get (c);\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n  #endif\n  \n      if (c != 0)\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YFunction::YFunction (from stream)\""
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYFunction {\n  YFunction::YFunction (bytecodeistream & str)\n      : YCode ()\n      , m_declaration (0)\n      , m_definition (0)\n      , m_is_global (false)\t\t// don't care about globalness any more\n  {\n  #if DO_DEBUG\n      y2debug (\"YFunction::YFunction (from stream)\");\n  #endif\n      if (Bytecode::readBool (str))\n      {\n  #if DO_DEBUG\n  \ty2debug (\"YFunction::YFunction: need_declaration !\");\n  #endif\n  \tm_declaration = (YBlockPtr)Bytecode::readCode (str);\n  \tif ((m_declaration == 0)\n  \t    || (!m_declaration->isBlock()))\n  \t{\n  \t    y2error (\"Error reading declaration\");\n  \t}\n      }\n      // read of definition block is done in YSFunction(str)\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "722-731",
    "snippet": "YCPValue\nYFunction::evaluate (bool /*cse*/)\n{\n#if DO_DEBUG\n    y2debug (\"YFunction::evaluate(%s)\\n\", toString().c_str());\n#endif\n    // there's nothing to evaluate for a function _definition_\n    // its all in the function call.\n    return YCPCode (YCodePtr (this));\t\t// YCPCode will take care of YCodePtr\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPCode",
          "args": [
            "YCodePtr (this)"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "YCPCode",
          "container": "YCPCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "103-107",
          "snippet": "YCPCode::YCPCode (bytecodeistream & str)\n    : YCPValue (YCPCode())\n{\n    (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPCode {\n  YCPCode::YCPCode (bytecodeistream & str)\n      : YCPValue (YCPCode())\n  {\n      (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCodePtr",
          "args": [
            "this"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YFunction::evaluate(%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "708-719",
          "snippet": "string\nYFunction::toString() const\n{\n    string  s = toStringDeclaration ();\n    if (m_definition != 0)\n    {\n\ts += \"\\n\";\n\ts += m_definition->toString();\n    }\n\n    return s;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  string\n  YFunction::toString() const\n  {\n      string  s = toStringDeclaration ();\n      if (m_definition != 0)\n      {\n  \ts += \"\\n\";\n  \ts += m_definition->toString();\n      }\n  \n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYFunction {\n  YCPValue\n  YFunction::evaluate (bool /*cse*/)\n  {\n  #if DO_DEBUG\n      y2debug (\"YFunction::evaluate(%s)\\n\", toString().c_str());\n  #endif\n      // there's nothing to evaluate for a function _definition_\n      // its all in the function call.\n      return YCPCode (YCodePtr (this));\t\t// YCPCode will take care of YCodePtr\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "708-719",
    "snippet": "string\nYFunction::toString() const\n{\n    string  s = toStringDeclaration ();\n    if (m_definition != 0)\n    {\n\ts += \"\\n\";\n\ts += m_definition->toString();\n    }\n\n    return s;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_definition->toString",
          "args": [],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "708-719",
          "snippet": "string\nYFunction::toString() const\n{\n    string  s = toStringDeclaration ();\n    if (m_definition != 0)\n    {\n\ts += \"\\n\";\n\ts += m_definition->toString();\n    }\n\n    return s;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "toStringDeclaration",
          "args": [],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "toStringDeclaration",
          "container": "YFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "689-706",
          "snippet": "string\nYFunction::toStringDeclaration () const\n{\n    string s = \" (\";\n\n    for (unsigned int p = 0; p < parameterCount(); p++)\n    {\n\tif (p > 0)\n\t{\n\t    s += \", \";\n\t}\n\ts += parameter(p)->toString();\n    }\n\n    s += \")\";\n\n    return s;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  string\n  YFunction::toStringDeclaration () const\n  {\n      string s = \" (\";\n  \n      for (unsigned int p = 0; p < parameterCount(); p++)\n      {\n  \tif (p > 0)\n  \t{\n  \t    s += \", \";\n  \t}\n  \ts += parameter(p)->toString();\n      }\n  \n      s += \")\";\n  \n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  string\n  YFunction::toString() const\n  {\n      string  s = toStringDeclaration ();\n      if (m_definition != 0)\n      {\n  \ts += \"\\n\";\n  \ts += m_definition->toString();\n      }\n  \n      return s;\n  }\n}"
  },
  {
    "function_name": "toStringDeclaration",
    "container": "YFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "689-706",
    "snippet": "string\nYFunction::toStringDeclaration () const\n{\n    string s = \" (\";\n\n    for (unsigned int p = 0; p < parameterCount(); p++)\n    {\n\tif (p > 0)\n\t{\n\t    s += \", \";\n\t}\n\ts += parameter(p)->toString();\n    }\n\n    s += \")\";\n\n    return s;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parameter",
          "args": [],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "parameters",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1686-1690",
          "snippet": "constTupleTypePtr\nFunctionType::parameters () const\n{\n    return m_arguments;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  constTupleTypePtr\n  FunctionType::parameters () const\n  {\n      return m_arguments;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parameter",
          "args": [
            "p"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "parameter",
          "container": "YFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "682-686",
          "snippet": "SymbolEntryPtr\nYFunction::parameter (unsigned int position) const\n{\n    return (m_declaration ? m_declaration->symbolEntry (position) : 0);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  SymbolEntryPtr\n  YFunction::parameter (unsigned int position) const\n  {\n      return (m_declaration ? m_declaration->symbolEntry (position) : 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parameterCount",
          "args": [],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  string\n  YFunction::toStringDeclaration () const\n  {\n      string s = \" (\";\n  \n      for (unsigned int p = 0; p < parameterCount(); p++)\n      {\n  \tif (p > 0)\n  \t{\n  \t    s += \", \";\n  \t}\n  \ts += parameter(p)->toString();\n      }\n  \n      s += \")\";\n  \n      return s;\n  }\n}"
  },
  {
    "function_name": "parameter",
    "container": "YFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "682-686",
    "snippet": "SymbolEntryPtr\nYFunction::parameter (unsigned int position) const\n{\n    return (m_declaration ? m_declaration->symbolEntry (position) : 0);\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_declaration->symbolEntry",
          "args": [
            "position"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "symbolEntry",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "118-126",
          "snippet": "SymbolEntryPtr \nY2Namespace::symbolEntry (unsigned int position) const\n{\n    if (position >= m_symbolcount)\n    {\n\treturn 0;\n    }\n    return m_symbols[position];\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  SymbolEntryPtr \n  Y2Namespace::symbolEntry (unsigned int position) const\n  {\n      if (position >= m_symbolcount)\n      {\n  \treturn 0;\n      }\n      return m_symbols[position];\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  SymbolEntryPtr\n  YFunction::parameter (unsigned int position) const\n  {\n      return (m_declaration ? m_declaration->symbolEntry (position) : 0);\n  }\n}"
  },
  {
    "function_name": "parameterCount",
    "container": "YFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "675-679",
    "snippet": "unsigned int\nYFunction::parameterCount (void) const\n{\n    return (m_declaration ? m_declaration->symbolCount() : 0);\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_declaration->symbolCount",
          "args": [],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "symbolCount",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "69-73",
          "snippet": "unsigned int\nY2Namespace::symbolCount () const\n{\n    return m_symbols.size();\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  unsigned int\n  Y2Namespace::symbolCount () const\n  {\n      return m_symbols.size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  unsigned int\n  YFunction::parameterCount (void) const\n  {\n      return (m_declaration ? m_declaration->symbolCount() : 0);\n  }\n}"
  },
  {
    "function_name": "setDefinition",
    "container": "YFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "634-672",
    "snippet": "void\nYFunction::setDefinition (bytecodeistream & str)\n{\n    if (Bytecode::readBool (str))\n    {\n#if DO_DEBUG\n\ty2debug (\"YFunction::YFunction: have definition!\");\n#endif\n\n\tif (m_declaration != 0)\n\t{\n\t    Bytecode::pushNamespace (m_declaration->nameSpace());\n\t}\n\t\n\tYBlockPtr def = (YBlockPtr)Bytecode::readCode (str);\n\tdef->setKind (YBlock::b_definition);\n\n\tm_definition = def;\n\n\tif (m_declaration != 0)\n\t{\n\t    Bytecode::popNamespace (m_declaration->nameSpace());\n\t}\n\n\tif ((m_definition == 0)\n\t    || (!m_definition->isBlock()))\n\t{\n\t    y2error (\"Error reading definition\");\n\t}\n    }\n    else\n    {\n#if DO_DEBUG\n\ty2debug (\"YFunction::setDefinition(stream): no definition!\");\n#endif\n    }\n\n    return;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YFunction::setDefinition(stream): no definition!\""
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Error reading definition\""
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_definition->isBlock",
          "args": [],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "isBlock",
          "container": "YCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "90-94",
          "snippet": "bool\nYCode::isBlock () const\n{\n    return false;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  bool\n  YCode::isBlock () const\n  {\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::popNamespace",
          "args": [
            "m_declaration->nameSpace()"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "popNamespace",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "650-679",
          "snippet": "int\nBytecode::popNamespace (const Y2Namespace *name_space)\n{\n#if DO_DEBUG\n    y2debug (\"Bytecode::popNamespace (%p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n#endif\n    if (name_space == 0)\n    {\n\ty2error (\"Bytecode::popNamespace (%p) NULL\", name_space);\n\treturn -1;\n    }\n\n    if (m_namespace_nesting_level < m_namespace_tare_level)\n    {\n\ty2error (\"Bytecode::popNamespace (%p) empty stack\", name_space);\n    }\n    else if (m_namespace_nesting_array[m_namespace_nesting_level].name_space != name_space)\n    {\n\ty2error (\"Bytecode::popNamespace (%p) not top of stack [%d]%p\", name_space, m_namespace_nesting_level, m_namespace_nesting_array[m_namespace_nesting_level].name_space);\n    }\n    else\n    {\n\tif (m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs)\n\t{\n\t    name_space->table()->closeXRefs();\n\t}\n\tm_namespace_nesting_level--;\n    }\n    return 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "int Bytecode::m_namespace_nesting_level = -1;",
            "int Bytecode::m_namespace_nesting_array_size = 0;",
            "int Bytecode::m_namespace_tare_level = 0;",
            "Bytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nint Bytecode::m_namespace_nesting_level = -1;\nint Bytecode::m_namespace_nesting_array_size = 0;\nint Bytecode::m_namespace_tare_level = 0;\nBytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;\n\nBytecode {\n  int\n  Bytecode::popNamespace (const Y2Namespace *name_space)\n  {\n  #if DO_DEBUG\n      y2debug (\"Bytecode::popNamespace (%p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n  #endif\n      if (name_space == 0)\n      {\n  \ty2error (\"Bytecode::popNamespace (%p) NULL\", name_space);\n  \treturn -1;\n      }\n  \n      if (m_namespace_nesting_level < m_namespace_tare_level)\n      {\n  \ty2error (\"Bytecode::popNamespace (%p) empty stack\", name_space);\n      }\n      else if (m_namespace_nesting_array[m_namespace_nesting_level].name_space != name_space)\n      {\n  \ty2error (\"Bytecode::popNamespace (%p) not top of stack [%d]%p\", name_space, m_namespace_nesting_level, m_namespace_nesting_array[m_namespace_nesting_level].name_space);\n      }\n      else\n      {\n  \tif (m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs)\n  \t{\n  \t    name_space->table()->closeXRefs();\n  \t}\n  \tm_namespace_nesting_level--;\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_declaration->nameSpace",
          "args": [],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "def->setKind",
          "args": [
            "YBlock::b_definition"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "setKind",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "349-357",
          "snippet": "void\nYBlock::setKind (YBlock::blockkind_t kind)\n{\n#if DO_DEBUG\n    y2debug (\"YBlock::setKind %p: %d\", this, (int)kind);\n#endif\n    m_kind = kind;\n    return;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  void\n  YBlock::setKind (YBlock::blockkind_t kind)\n  {\n  #if DO_DEBUG\n      y2debug (\"YBlock::setKind %p: %d\", this, (int)kind);\n  #endif\n      m_kind = kind;\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::pushNamespace",
          "args": [
            "m_declaration->nameSpace()"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_declaration->nameSpace",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YFunction::YFunction: have definition!\""
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readBool",
          "args": [
            "str"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "readBool",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "158-172",
          "snippet": "bool\nBytecode::readBool (bytecodeistream & str)\n{\n    char c;\n    str.get (c);\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n#endif\n\n    if (c != 0)\n    {\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readBool (bytecodeistream & str)\n  {\n      char c;\n      str.get (c);\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n  #endif\n  \n      if (c != 0)\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYFunction {\n  void\n  YFunction::setDefinition (bytecodeistream & str)\n  {\n      if (Bytecode::readBool (str))\n      {\n  #if DO_DEBUG\n  \ty2debug (\"YFunction::YFunction: have definition!\");\n  #endif\n  \n  \tif (m_declaration != 0)\n  \t{\n  \t    Bytecode::pushNamespace (m_declaration->nameSpace());\n  \t}\n  \t\n  \tYBlockPtr def = (YBlockPtr)Bytecode::readCode (str);\n  \tdef->setKind (YBlock::b_definition);\n  \n  \tm_definition = def;\n  \n  \tif (m_declaration != 0)\n  \t{\n  \t    Bytecode::popNamespace (m_declaration->nameSpace());\n  \t}\n  \n  \tif ((m_definition == 0)\n  \t    || (!m_definition->isBlock()))\n  \t{\n  \t    y2error (\"Error reading definition\");\n  \t}\n      }\n      else\n      {\n  #if DO_DEBUG\n  \ty2debug (\"YFunction::setDefinition(stream): no definition!\");\n  #endif\n      }\n  \n      return;\n  }\n}"
  },
  {
    "function_name": "setDefinition",
    "container": "YFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "625-631",
    "snippet": "void\nYFunction::setDefinition (YBreakpointPtr definition)\n{\n    m_definition = definition;\n    // skip setKind call, we are just setting a breakpoint wrapper here\n    return;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  void\n  YFunction::setDefinition (YBreakpointPtr definition)\n  {\n      m_definition = definition;\n      // skip setKind call, we are just setting a breakpoint wrapper here\n      return;\n  }\n}"
  },
  {
    "function_name": "setDefinition",
    "container": "YFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "616-622",
    "snippet": "void\nYFunction::setDefinition (YBlockPtr definition)\n{\n    m_definition = definition;\n    definition->setKind (YBlock::b_definition);\n    return;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "definition->setKind",
          "args": [
            "YBlock::b_definition"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "setKind",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "349-357",
          "snippet": "void\nYBlock::setKind (YBlock::blockkind_t kind)\n{\n#if DO_DEBUG\n    y2debug (\"YBlock::setKind %p: %d\", this, (int)kind);\n#endif\n    m_kind = kind;\n    return;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  void\n  YBlock::setKind (YBlock::blockkind_t kind)\n  {\n  #if DO_DEBUG\n      y2debug (\"YBlock::setKind %p: %d\", this, (int)kind);\n  #endif\n      m_kind = kind;\n      return;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  void\n  YFunction::setDefinition (YBlockPtr definition)\n  {\n      m_definition = definition;\n      definition->setKind (YBlock::b_definition);\n      return;\n  }\n}"
  },
  {
    "function_name": "declaration",
    "container": "YFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "609-613",
    "snippet": "YBlockPtr\nYFunction::declaration() const\n{\n    return m_declaration;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  YBlockPtr\n  YFunction::declaration() const\n  {\n      return m_declaration;\n  }\n}"
  },
  {
    "function_name": "definition",
    "container": "YFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "602-606",
    "snippet": "YCodePtr\nYFunction::definition() const\n{\n    return m_definition;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  YCodePtr\n  YFunction::definition() const\n  {\n      return m_definition;\n  }\n}"
  },
  {
    "function_name": "~YFunction",
    "container": "YFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "597-599",
    "snippet": "YFunction::~YFunction ()\n{\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  YFunction::~YFunction ()\n  {\n  }\n}"
  },
  {
    "function_name": "YFunction",
    "container": "YFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "588-594",
    "snippet": "YFunction::YFunction (YBlockPtr declaration, const SymbolEntryPtr entry)\n    : YCode ()\n    , m_declaration (declaration)\n    , m_definition (0)\n    , m_is_global (entry ? entry->isGlobal() : true)\n{\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "entry->isGlobal",
          "args": [],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "isGlobal",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "82-86",
          "snippet": "bool\nSymbolEntry::isGlobal () const\n{\n    return m_global;\n}",
          "includes": [
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  bool\n  SymbolEntry::isGlobal () const\n  {\n      return m_global;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  YFunction::YFunction (YBlockPtr declaration, const SymbolEntryPtr entry)\n      : YCode ()\n      , m_declaration (declaration)\n      , m_definition (0)\n      , m_is_global (entry ? entry->isGlobal() : true)\n  {\n  }\n}"
  },
  {
    "function_name": "bindDomainDir",
    "container": "YLocale",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "572-583",
    "snippet": "void \nYLocale::bindDomainDir (const string& domain, const string& domain_path)\n{\n\n#if DO_DEBUG\n    y2debug (\"going to bind a domain %s with path %s\", domain.c_str(),  domain_path.c_str());\n#endif\n    bindtextdomain (domain.c_str (), domain_path.c_str());\n    bind_textdomain_codeset (domain.c_str (), \"UTF-8\");\n    setDomainStatus (domain, true);\n \n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setDomainStatus",
          "args": [
            "domain",
            "true"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "setDomainStatus",
          "container": "YLocale",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "540-552",
          "snippet": "YLocale::t_uniquedomains::const_iterator\nYLocale::setDomainStatus (const string& domain, bool status)\n{\n    if (domains.find (domain.c_str ()) == domains.end ())\n    {\n\tdomains.insert (std::make_pair(strdup (domain.c_str ()),status));\n    }\n    else\n    {\n\tdomains [domain.c_str ()] = status;\n    }\n    return domains.find (domain.c_str ());\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YLocale::t_uniquedomains YLocale::domains;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYLocale::t_uniquedomains YLocale::domains;\n\nYLocale {\n  YLocale::t_uniquedomains::const_iterator\n  YLocale::setDomainStatus (const string& domain, bool status)\n  {\n      if (domains.find (domain.c_str ()) == domains.end ())\n      {\n  \tdomains.insert (std::make_pair(strdup (domain.c_str ()),status));\n      }\n      else\n      {\n  \tdomains [domain.c_str ()] = status;\n      }\n      return domains.find (domain.c_str ());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind_textdomain_codeset",
          "args": [
            "domain.c_str ()",
            "\"UTF-8\""
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain.c_str",
          "args": [],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bindtextdomain",
          "args": [
            "domain.c_str ()",
            "domain_path.c_str()"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain_path.c_str",
          "args": [],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain.c_str",
          "args": [],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"going to bind a domain %s with path %s\"",
            "domain.c_str()",
            "domain_path.c_str()"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain_path.c_str",
          "args": [],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain.c_str",
          "args": [],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYLocale {\n  void \n  YLocale::bindDomainDir (const string& domain, const string& domain_path)\n  {\n  \n  #if DO_DEBUG\n      y2debug (\"going to bind a domain %s with path %s\", domain.c_str(),  domain_path.c_str());\n  #endif\n      bindtextdomain (domain.c_str (), domain_path.c_str());\n      bind_textdomain_codeset (domain.c_str (), \"UTF-8\");\n      setDomainStatus (domain, true);\n   \n  }\n}"
  },
  {
    "function_name": "ensureBindDomain",
    "container": "YLocale",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "561-569",
    "snippet": "void \nYLocale::ensureBindDomain (const string& domain)\n{\n    if (domains.find (domain.c_str ()) == domains.end () \n\t|| ! domains[domain.c_str ()])\n    {\n\tbindDomainDir (domain, LOCALEDIR);\n    }\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "YLocale::t_uniquedomains YLocale::domains;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bindDomainDir",
          "args": [
            "domain",
            "LOCALEDIR"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "bindDomainDir",
          "container": "YLocale",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "572-583",
          "snippet": "void \nYLocale::bindDomainDir (const string& domain, const string& domain_path)\n{\n\n#if DO_DEBUG\n    y2debug (\"going to bind a domain %s with path %s\", domain.c_str(),  domain_path.c_str());\n#endif\n    bindtextdomain (domain.c_str (), domain_path.c_str());\n    bind_textdomain_codeset (domain.c_str (), \"UTF-8\");\n    setDomainStatus (domain, true);\n \n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYLocale {\n  void \n  YLocale::bindDomainDir (const string& domain, const string& domain_path)\n  {\n  \n  #if DO_DEBUG\n      y2debug (\"going to bind a domain %s with path %s\", domain.c_str(),  domain_path.c_str());\n  #endif\n      bindtextdomain (domain.c_str (), domain_path.c_str());\n      bind_textdomain_codeset (domain.c_str (), \"UTF-8\");\n      setDomainStatus (domain, true);\n   \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "domain.c_str",
          "args": [],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domains.end",
          "args": [],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "domains.find",
          "args": [
            "domain.c_str ()"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain.c_str",
          "args": [],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYLocale::t_uniquedomains YLocale::domains;\n\nYLocale {\n  void \n  YLocale::ensureBindDomain (const string& domain)\n  {\n      if (domains.find (domain.c_str ()) == domains.end () \n  \t|| ! domains[domain.c_str ()])\n      {\n  \tbindDomainDir (domain, LOCALEDIR);\n      }\n  }\n}"
  },
  {
    "function_name": "findDomain",
    "container": "YLocale",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "554-558",
    "snippet": "bool\nYLocale::findDomain(const string& domain)\n{\n    return (domains.find (domain.c_str ()) == domains.end ()) ? false : true;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "YLocale::t_uniquedomains YLocale::domains;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "domains.end",
          "args": [],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "domains.find",
          "args": [
            "domain.c_str ()"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain.c_str",
          "args": [],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYLocale::t_uniquedomains YLocale::domains;\n\nYLocale {\n  bool\n  YLocale::findDomain(const string& domain)\n  {\n      return (domains.find (domain.c_str ()) == domains.end ()) ? false : true;\n  }\n}"
  },
  {
    "function_name": "setDomainStatus",
    "container": "YLocale",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "540-552",
    "snippet": "YLocale::t_uniquedomains::const_iterator\nYLocale::setDomainStatus (const string& domain, bool status)\n{\n    if (domains.find (domain.c_str ()) == domains.end ())\n    {\n\tdomains.insert (std::make_pair(strdup (domain.c_str ()),status));\n    }\n    else\n    {\n\tdomains [domain.c_str ()] = status;\n    }\n    return domains.find (domain.c_str ());\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "YLocale::t_uniquedomains YLocale::domains;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "domains.find",
          "args": [
            "domain.c_str ()"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain.c_str",
          "args": [],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain.c_str",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domains.insert",
          "args": [
            "std::make_pair(strdup (domain.c_str ()),status)"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "strdup (domain.c_str ())",
            "status"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "domain.c_str ()"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain.c_str",
          "args": [],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domains.end",
          "args": [],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "domains.find",
          "args": [
            "domain.c_str ()"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain.c_str",
          "args": [],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYLocale::t_uniquedomains YLocale::domains;\n\nYLocale {\n  YLocale::t_uniquedomains::const_iterator\n  YLocale::setDomainStatus (const string& domain, bool status)\n  {\n      if (domains.find (domain.c_str ()) == domains.end ())\n      {\n  \tdomains.insert (std::make_pair(strdup (domain.c_str ()),status));\n      }\n      else\n      {\n  \tdomains [domain.c_str ()] = status;\n      }\n      return domains.find (domain.c_str ());\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YLocale",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "526-536",
    "snippet": "YCPValue\nYLocale::evaluate (bool cse)\n{\n    if (cse) return YCPNull();\n\n    const char *ret = dgettext (m_domain->first, m_locale);\n#if DO_DEBUG\n    y2debug (\"localize <%s> to <%s>\", m_locale, ret);\n#endif\n    return YCPString (ret);\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "ret"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "YCPString",
          "container": "YCPString",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "152-155",
          "snippet": "YCPString::YCPString (bytecodeistream & str)\n    : YCPValue (new YCPStringRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPString {\n  YCPString::YCPString (bytecodeistream & str)\n      : YCPValue (new YCPStringRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"localize <%s> to <%s>\"",
            "m_locale",
            "ret"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dgettext",
          "args": [
            "m_domain->first",
            "m_locale"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYLocale {\n  YCPValue\n  YLocale::evaluate (bool cse)\n  {\n      if (cse) return YCPNull();\n  \n      const char *ret = dgettext (m_domain->first, m_locale);\n  #if DO_DEBUG\n      y2debug (\"localize <%s> to <%s>\", m_locale, ret);\n  #endif\n      return YCPString (ret);\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YLocale",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "519-523",
    "snippet": "string\nYLocale::toString() const\n{\n    return \"_(\\\"\" + string (m_locale) + \"\\\")\";\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "string",
          "args": [
            "m_locale"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYLocale {\n  string\n  YLocale::toString() const\n  {\n      return \"_(\\\"\" + string (m_locale) + \"\\\")\";\n  }\n}"
  },
  {
    "function_name": "~YLocale",
    "container": "YLocale",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "483-486",
    "snippet": "YLocale::~YLocale ()\n{\n    delete[] m_locale;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYLocale {\n  YLocale::~YLocale ()\n  {\n      delete[] m_locale;\n  }\n}"
  },
  {
    "function_name": "YLocale",
    "container": "YLocale",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "462-480",
    "snippet": "YLocale::YLocale (bytecodeistream & str)\n    : YCode ()\n{\n    m_locale = Bytecode::readCharp (str);\t\t// the string to be translated\n\n    const char * dom = Bytecode::readCharp (str);\n\n    if (domains.find (dom) != domains.end ())\n    {\n\tm_domain = domains.find (dom);\n\t// the textdomain was already there, we can free the memory allocated in readCharp\n\tdelete[] dom;\n    }\n    else\n    {\n\tdomains.insert (std::make_pair(dom,false));\n\tm_domain = domains.find (dom);\n    }    \n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "YLocale::t_uniquedomains YLocale::domains;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "domains.find",
          "args": [
            "dom"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domains.insert",
          "args": [
            "std::make_pair(dom,false)"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "dom",
            "false"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domains.find",
          "args": [
            "dom"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domains.end",
          "args": [],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "domains.find",
          "args": [
            "dom"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readCharp",
          "args": [
            "str"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readCharp",
          "args": [
            "str"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYLocale::t_uniquedomains YLocale::domains;\n\nYLocale {\n  YLocale::YLocale (bytecodeistream & str)\n      : YCode ()\n  {\n      m_locale = Bytecode::readCharp (str);\t\t// the string to be translated\n  \n      const char * dom = Bytecode::readCharp (str);\n  \n      if (domains.find (dom) != domains.end ())\n      {\n  \tm_domain = domains.find (dom);\n  \t// the textdomain was already there, we can free the memory allocated in readCharp\n  \tdelete[] dom;\n      }\n      else\n      {\n  \tdomains.insert (std::make_pair(dom,false));\n  \tm_domain = domains.find (dom);\n      }    \n  }\n}"
  },
  {
    "function_name": "YLocale",
    "container": "YLocale",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "449-459",
    "snippet": "YLocale::YLocale (const char *locale, const char *textdomain)\n    : YCode ()\n    , m_locale (locale)\n{\n    if (domains.find (textdomain) == domains.end ())\n    {\n\tdomains.insert (std::make_pair(textdomain,false));\n    }\n\n    m_domain = domains.find (textdomain);\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "YLocale::t_uniquedomains YLocale::domains;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "domains.find",
          "args": [
            "textdomain"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domains.insert",
          "args": [
            "std::make_pair(textdomain,false)"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "textdomain",
            "false"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domains.end",
          "args": [],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "domains.find",
          "args": [
            "textdomain"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYLocale::t_uniquedomains YLocale::domains;\n\nYLocale {\n  YLocale::YLocale (const char *locale, const char *textdomain)\n      : YCode ()\n      , m_locale (locale)\n  {\n      if (domains.find (textdomain) == domains.end ())\n      {\n  \tdomains.insert (std::make_pair(textdomain,false));\n      }\n  \n      m_domain = domains.find (textdomain);\n  }\n}"
  },
  {
    "function_name": "type",
    "container": "YConst",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "419-441",
    "snippet": "constTypePtr\nYConst::type () const\n{\n    switch (m_kind)\n    {\n\tcase ycVoid:\t\treturn Type::ConstVoid; break;\n\tcase ycBoolean:\t\treturn Type::ConstBoolean; break;\n\tcase ycInteger:\t\treturn Type::ConstInteger; break;\n\tcase ycFloat:\t\treturn Type::ConstFloat; break;\n\tcase ycString:\t\treturn Type::ConstString; break;\n\tcase ycByteblock:\treturn Type::ConstByteblock; break;\n\tcase ycPath:\t\treturn Type::ConstPath; break;\n\tcase ycSymbol:\t\treturn Type::ConstSymbol; break;\n\tcase ycList:\t\treturn Type::ListUnspec; break;\n\tcase ycMap:\t\treturn Type::MapUnspec; break;\n\tcase ycTerm:\t\treturn Type::ConstTerm; break;\n\tcase yeBlock:\t\treturn Type::ConstAny; break;\n\tcase ycLocale:\t\treturn Type::ConstLocale; break;\n\tdefault:\n\t    break;\n    }\n    return Type::Unspec;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYConst {\n  constTypePtr\n  YConst::type () const\n  {\n      switch (m_kind)\n      {\n  \tcase ycVoid:\t\treturn Type::ConstVoid; break;\n  \tcase ycBoolean:\t\treturn Type::ConstBoolean; break;\n  \tcase ycInteger:\t\treturn Type::ConstInteger; break;\n  \tcase ycFloat:\t\treturn Type::ConstFloat; break;\n  \tcase ycString:\t\treturn Type::ConstString; break;\n  \tcase ycByteblock:\treturn Type::ConstByteblock; break;\n  \tcase ycPath:\t\treturn Type::ConstPath; break;\n  \tcase ycSymbol:\t\treturn Type::ConstSymbol; break;\n  \tcase ycList:\t\treturn Type::ListUnspec; break;\n  \tcase ycMap:\t\treturn Type::MapUnspec; break;\n  \tcase ycTerm:\t\treturn Type::ConstTerm; break;\n  \tcase yeBlock:\t\treturn Type::ConstAny; break;\n  \tcase ycLocale:\t\treturn Type::ConstLocale; break;\n  \tdefault:\n  \t    break;\n      }\n      return Type::Unspec;\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YConst",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "379-387",
    "snippet": "YCPValue\nYConst::evaluate (bool /*cse*/)\n{\n    YCPValue v = m_value;\n#if DO_DEBUG\n    y2debug(\"evaluate(%s) = %s\", toString().c_str(), v.isNull() ? \"NULL\" : v->toString().c_str());\n#endif\n    return v;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"evaluate(%s) = %s\"",
            "toString().c_str()",
            "v.isNull() ? \"NULL\" : v->toString().c_str()"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->toString",
          "args": [],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "708-719",
          "snippet": "string\nYFunction::toString() const\n{\n    string  s = toStringDeclaration ();\n    if (m_definition != 0)\n    {\n\ts += \"\\n\";\n\ts += m_definition->toString();\n    }\n\n    return s;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  string\n  YFunction::toString() const\n  {\n      string  s = toStringDeclaration ();\n      if (m_definition != 0)\n      {\n  \ts += \"\\n\";\n  \ts += m_definition->toString();\n      }\n  \n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYConst {\n  YCPValue\n  YConst::evaluate (bool /*cse*/)\n  {\n      YCPValue v = m_value;\n  #if DO_DEBUG\n      y2debug(\"evaluate(%s) = %s\", toString().c_str(), v.isNull() ? \"NULL\" : v->toString().c_str());\n  #endif\n      return v;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YConst",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "349-377",
    "snippet": "string\nYConst::toString() const\n{\n    if (!m_value.isNull())\n\treturn m_value->toString();\n\n    switch (m_kind)\n    {\n\tcase ycVoid:\n\tcase ycBoolean:\n\tcase ycInteger:\n\tcase ycFloat:\n\tcase ycString:\n\tcase ycByteblock:\n\tcase ycPath:\n\tcase ycSymbol:\n\tcase ycList:\n\tcase ycMap:\n\tcase ycTerm:\n\tcase yeBlock:\n\tcase ycLocale:\n\tcase yeLocale:\n\t    return \"nil\";\n\t    break;\n\tdefault:\n\t    break;\n    }\n    return \"nilWHAT?\";\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_value->toString",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "708-719",
          "snippet": "string\nYFunction::toString() const\n{\n    string  s = toStringDeclaration ();\n    if (m_definition != 0)\n    {\n\ts += \"\\n\";\n\ts += m_definition->toString();\n    }\n\n    return s;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  string\n  YFunction::toString() const\n  {\n      string  s = toStringDeclaration ();\n      if (m_definition != 0)\n      {\n  \ts += \"\\n\";\n  \ts += m_definition->toString();\n      }\n  \n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_value.isNull",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYConst {\n  string\n  YConst::toString() const\n  {\n      if (!m_value.isNull())\n  \treturn m_value->toString();\n  \n      switch (m_kind)\n      {\n  \tcase ycVoid:\n  \tcase ycBoolean:\n  \tcase ycInteger:\n  \tcase ycFloat:\n  \tcase ycString:\n  \tcase ycByteblock:\n  \tcase ycPath:\n  \tcase ycSymbol:\n  \tcase ycList:\n  \tcase ycMap:\n  \tcase ycTerm:\n  \tcase yeBlock:\n  \tcase ycLocale:\n  \tcase yeLocale:\n  \t    return \"nil\";\n  \t    break;\n  \tdefault:\n  \t    break;\n      }\n      return \"nilWHAT?\";\n  }\n}"
  },
  {
    "function_name": "value",
    "container": "YConst",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "342-346",
    "snippet": "YCPValue\nYConst::value() const\n{\n    return m_value;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYConst {\n  YCPValue\n  YConst::value() const\n  {\n      return m_value;\n  }\n}"
  },
  {
    "function_name": "kind",
    "container": "YConst",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "336-340",
    "snippet": "YCode::ykind\nYConst::kind() const\n{\n    return m_kind;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYConst {\n  YCode::ykind\n  YConst::kind() const\n  {\n      return m_kind;\n  }\n}"
  },
  {
    "function_name": "YConst",
    "container": "YConst",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "242-333",
    "snippet": "YConst::YConst (ykind kind, bytecodeistream & str)\n    : m_kind (kind)\n    , m_value (YCPNull())\n{\n    if (Bytecode::readBool (str))\t\t// not nil\n    {\n#if DO_DEBUG\n\ty2debug (\"YConst::YConst (%d:%s)\", (int)kind, YCode::toString (kind).c_str());\n#endif\n\tswitch (kind)\n\t{\n\t    case YCode::ycVoid:\n\t    {\n\t\tm_value = YCPVoid (str);\n\t    }\n\t    break;\n\t    case YCode::ycBoolean:\n\t    {\n\t\tm_value = YCPBoolean (str);\n\t    }\n\t    break;\n\t    case YCode::ycInteger:\n\t    {\n\t\tm_value = YCPInteger (str);\n\t    }\n\t    break;\n\t    case YCode::ycFloat:\n\t    {\n\t\tm_value = YCPFloat (str);\n\t    }\n\t    break;\n\t    case YCode::ycString:\n\t    {\n\t\tm_value = YCPString (str);\n\t    }\n\t    break;\n\t    case YCode::ycByteblock:\n\t    {\n\t\tm_value = YCPByteblock (str);\n\t    }\n\t    break;\n\t    case YCode::ycPath:\n\t    {\n\t\tm_value = YCPPath (str);\n\t    }\n\t    break;\n\t    case YCode::ycSymbol:\n\t    {\n\t\tm_value = YCPSymbol (str);\n\t    }\n\t    break;\n\t    case YCode::ycList:\n\t    {\n\t\tm_value = YCPList (str);\n\t    }\n\t    break;\n\t    case YCode::ycMap:\n\t    {\n\t\tm_value = YCPMap (str);\n\t    }\n\t    break;\n\t    case YCode::ycTerm:\n\t    {\n\t\tm_value = YCPTerm (str);\n\t    }\n\t    break;\n\t    case YCode::ycEntry:\n\t    {\n#if DO_DEBUG\n\t\ty2debug (\"YCode::ycEntry:\");\n#endif\n\t\tm_value = YCPEntry (Bytecode::readEntry (str));\n\t    }\n\t    break;\n\t    default:\n\t    {\n\t\ty2error (\"YConst stream kind %d\", kind);\n\t\tbreak;\n\t    }\n\t}\n\tif (!m_value.isNull())\n\t{\n#if DO_DEBUG\n\t    y2debug (\"m_value '%s'\", m_value->toString().c_str());\n#endif\n\t}\n    }\n    else\n    {\n\ty2warning (\"YConst::YConst(%d:%s) NIL\", (int)kind, YCode::toString(kind).c_str());\n    }\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"YConst::YConst(%d:%s) NIL\"",
            "(int)kind",
            "YCode::toString(kind).c_str()"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCode::toString",
          "args": [],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "182-186",
          "snippet": "string\nYCode::toString() const\n{\n    return toString (kind ());\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  string\n  YCode::toString() const\n  {\n      return toString (kind ());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"m_value '%s'\"",
            "m_value->toString().c_str()"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_value->toString",
          "args": [],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "708-719",
          "snippet": "string\nYFunction::toString() const\n{\n    string  s = toStringDeclaration ();\n    if (m_definition != 0)\n    {\n\ts += \"\\n\";\n\ts += m_definition->toString();\n    }\n\n    return s;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  string\n  YFunction::toString() const\n  {\n      string  s = toStringDeclaration ();\n      if (m_definition != 0)\n      {\n  \ts += \"\\n\";\n  \ts += m_definition->toString();\n      }\n  \n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_value.isNull",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"YConst stream kind %d\"",
            "kind"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPEntry",
          "args": [
            "Bytecode::readEntry (str)"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "YCPEntryRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "149-155",
          "snippet": "YCPValue\nYCPEntryRep::evaluate (bool /*cse*/) const\n{\n    y2debug (\"YCPEntryRep::evaluate (%s)\", this->toString().c_str());\n\n    return m_entry->value();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPEntryRep {\n  YCPValue\n  YCPEntryRep::evaluate (bool /*cse*/) const\n  {\n      y2debug (\"YCPEntryRep::evaluate (%s)\", this->toString().c_str());\n  \n      return m_entry->value();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readEntry",
          "args": [
            "str"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "readEntry",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "762-815",
          "snippet": "SymbolEntryPtr \nBytecode::readEntry (bytecodeistream & str)\n{\n    // read reference to namespaces (namespace_id) symbol table (position)\n    int namespace_id = Bytecode::readInt32 (str);\n    int position = Bytecode::readInt32 (str);\n\n    if (namespace_id == -1)\n    {\n#if DO_DEBUG\n\ty2debug( \"Special entry without namespace\" );\n#endif\n\t// FIXME: this may be wrong\n\treturn 0;\n    }\n\n    // get namespace pointer and SymbolEntry within namespace\n    const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n    if (name_space == 0)\n    {\n\ty2error (\"invalid namespace %d for entry\", namespace_id);\n\treturn 0;\n    }\n\n    SymbolEntryPtr sentry;\n    if (position < 0)\t\t\t\t// it's an Xref !\n    {\n\tSymbolTable *table = name_space->table();\n\tif (table == 0)\n\t{\n\t    ycp2error (\"No table associated to xref namespace\\n\");\n\t    exit (1);\n\t}\n\tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n#if DO_DEBUG\n\ty2debug (\"get reference %d from table %p\", position, table);\n#endif\n\tsentry = table->getXRef(position);\n    }\n    else\n    {\n\tsentry = name_space->symbolEntry (position);\n    }\n\n    if (sentry == 0)\n    {\n\ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n\treturn 0;\n    }\n#if DO_DEBUG\n    y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n#endif\n    return sentry;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  SymbolEntryPtr \n  Bytecode::readEntry (bytecodeistream & str)\n  {\n      // read reference to namespaces (namespace_id) symbol table (position)\n      int namespace_id = Bytecode::readInt32 (str);\n      int position = Bytecode::readInt32 (str);\n  \n      if (namespace_id == -1)\n      {\n  #if DO_DEBUG\n  \ty2debug( \"Special entry without namespace\" );\n  #endif\n  \t// FIXME: this may be wrong\n  \treturn 0;\n      }\n  \n      // get namespace pointer and SymbolEntry within namespace\n      const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n      if (name_space == 0)\n      {\n  \ty2error (\"invalid namespace %d for entry\", namespace_id);\n  \treturn 0;\n      }\n  \n      SymbolEntryPtr sentry;\n      if (position < 0)\t\t\t\t// it's an Xref !\n      {\n  \tSymbolTable *table = name_space->table();\n  \tif (table == 0)\n  \t{\n  \t    ycp2error (\"No table associated to xref namespace\\n\");\n  \t    exit (1);\n  \t}\n  \tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n  #if DO_DEBUG\n  \ty2debug (\"get reference %d from table %p\", position, table);\n  #endif\n  \tsentry = table->getXRef(position);\n      }\n      else\n      {\n  \tsentry = name_space->symbolEntry (position);\n      }\n  \n      if (sentry == 0)\n      {\n  \ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n  \treturn 0;\n      }\n  #if DO_DEBUG\n      y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n  #endif\n      return sentry;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YCode::ycEntry:\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPTerm",
          "args": [
            "str"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "YCPTerm",
          "container": "YCPTerm",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "178-194",
          "snippet": "YCPTerm::YCPTerm (bytecodeistream & str)\n    : YCPValue (YCPTerm(\"no-name-so-far\"))\n{\n    string s;\n    if (Bytecode::readString (str, s))\n    {\n\tYCPList list (str);\n\tif (!list.isNull())\n\t{\n\t    (const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->setName(s);\n\t    for (int i = 0 ; i < list->size () ; i++)\n\t    {\n\t\t(const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->add (list->value (i));\n\t    }\n\t}\n    }\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTerm {\n  YCPTerm::YCPTerm (bytecodeistream & str)\n      : YCPValue (YCPTerm(\"no-name-so-far\"))\n  {\n      string s;\n      if (Bytecode::readString (str, s))\n      {\n  \tYCPList list (str);\n  \tif (!list.isNull())\n  \t{\n  \t    (const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->setName(s);\n  \t    for (int i = 0 ; i < list->size () ; i++)\n  \t    {\n  \t\t(const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->add (list->value (i));\n  \t    }\n  \t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPMap",
          "args": [
            "str"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "YCPMap",
          "container": "YCPMap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "261-274",
          "snippet": "YCPMap::YCPMap(bytecodeistream & str)\n    : YCPValue (YCPMap())\n{\n    u_int32_t len = Bytecode::readInt32 (str);\n    if (str.good())\n    {\n\tfor (unsigned index=0; index < len; index++)\n\t{\n\t    YCPValue key = Bytecode::readValue (str);\n\t    YCPValue value = Bytecode::readValue (str);\n\t    (*this)->add (key, value);\n\t}\n    }\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMap {\n  YCPMap::YCPMap(bytecodeistream & str)\n      : YCPValue (YCPMap())\n  {\n      u_int32_t len = Bytecode::readInt32 (str);\n      if (str.good())\n      {\n  \tfor (unsigned index=0; index < len; index++)\n  \t{\n  \t    YCPValue key = Bytecode::readValue (str);\n  \t    YCPValue value = Bytecode::readValue (str);\n  \t    (*this)->add (key, value);\n  \t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPList",
          "args": [
            "str"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "YCPList",
          "container": "YCPList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "303-316",
          "snippet": "YCPList::YCPList(bytecodeistream & str)\n    : YCPValue (YCPList())\n{\n    u_int32_t len = Bytecode::readInt32 (str);\n    if (str.good())\n    {\n\t(const_cast<YCPListRep*>(static_cast<const YCPListRep*>(element)))->reserve (len);\n\tfor (unsigned index = 0; index < len; index++)\n\t{\n\t    YCPValue value = Bytecode::readValue (str);\n\t    (const_cast<YCPListRep*>(static_cast<const YCPListRep*>(element)))->set (index, value);\n\t}\n    }\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPList {\n  YCPList::YCPList(bytecodeistream & str)\n      : YCPValue (YCPList())\n  {\n      u_int32_t len = Bytecode::readInt32 (str);\n      if (str.good())\n      {\n  \t(const_cast<YCPListRep*>(static_cast<const YCPListRep*>(element)))->reserve (len);\n  \tfor (unsigned index = 0; index < len; index++)\n  \t{\n  \t    YCPValue value = Bytecode::readValue (str);\n  \t    (const_cast<YCPListRep*>(static_cast<const YCPListRep*>(element)))->set (index, value);\n  \t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPSymbol",
          "args": [
            "str"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "YCPSymbol",
          "container": "YCPSymbol",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "104-107",
          "snippet": "YCPSymbol::YCPSymbol (bytecodeistream & str)\n    : YCPValue (new YCPSymbolRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbol {\n  YCPSymbol::YCPSymbol (bytecodeistream & str)\n      : YCPValue (new YCPSymbolRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPPath",
          "args": [
            "str"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "YCPPath",
          "container": "YCPPath",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "402-418",
          "snippet": "YCPPath::YCPPath (bytecodeistream & str)\n    : YCPValue (new YCPPathRep (fromStream(str).c_str()))\n{\n#if 0\n    u_int32_t count = Bytecode::readInt32 (str);\n    if (str.good())\n    {\n\tYCPPathRep *p = new YCPPathRep ();\n\tfor (unsigned c = 0; c < count; c++)\n\t{\n\t    p->append (YCPPathRep::Component (str));\n\t}\n\tif (str.good())\n\t    element = p;\n    }\n#endif\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPath {\n  YCPPath::YCPPath (bytecodeistream & str)\n      : YCPValue (new YCPPathRep (fromStream(str).c_str()))\n  {\n  #if 0\n      u_int32_t count = Bytecode::readInt32 (str);\n      if (str.good())\n      {\n  \tYCPPathRep *p = new YCPPathRep ();\n  \tfor (unsigned c = 0; c < count; c++)\n  \t{\n  \t    p->append (YCPPathRep::Component (str));\n  \t}\n  \tif (str.good())\n  \t    element = p;\n      }\n  #endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPByteblock",
          "args": [
            "str"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "YCPByteblock",
          "container": "YCPByteblock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPByteblock.cc",
          "lines": "161-164",
          "snippet": "YCPByteblock::YCPByteblock (bytecodeistream & str)\n    : YCPValue (new YCPByteblockRep (str, fromStream (str)))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPByteblock.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPByteblock.h\"\n#include <ycp/y2log.h>\n\nYCPByteblock {\n  YCPByteblock::YCPByteblock (bytecodeistream & str)\n      : YCPValue (new YCPByteblockRep (str, fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "str"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "YCPString",
          "container": "YCPString",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "152-155",
          "snippet": "YCPString::YCPString (bytecodeistream & str)\n    : YCPValue (new YCPStringRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPString {\n  YCPString::YCPString (bytecodeistream & str)\n      : YCPValue (new YCPStringRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPFloat",
          "args": [
            "str"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "YCPFloat",
          "container": "YCPFloat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPFloat.cc",
          "lines": "119-122",
          "snippet": "YCPFloat::YCPFloat (bytecodeistream & str)\n    : YCPValue (new YCPFloatRep (fromStream (str).c_str()))\n{\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/y2log.h\"\n#include <ctype.h>\n\nYCPFloat {\n  YCPFloat::YCPFloat (bytecodeistream & str)\n      : YCPValue (new YCPFloatRep (fromStream (str).c_str()))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPInteger",
          "args": [
            "str"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "YCPInteger",
          "container": "YCPInteger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPInteger.cc",
          "lines": "142-145",
          "snippet": "YCPInteger::YCPInteger (bytecodeistream & str)\n    : YCPValue (new YCPIntegerRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/y2log.h\"\n\nYCPInteger {\n  YCPInteger::YCPInteger (bytecodeistream & str)\n      : YCPValue (new YCPIntegerRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "str"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [
            "str"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "77-80",
          "snippet": "YCPVoid::YCPVoid (bytecodeistream &)\n    : YCPValue ( *(nil ? nil : (nil = new YCPVoid(new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid (bytecodeistream &)\n      : YCPValue ( *(nil ? nil : (nil = new YCPVoid(new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YConst::YConst (%d:%s)\"",
            "(int)kind",
            "YCode::toString (kind).c_str()"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readBool",
          "args": [
            "str"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "readBool",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "158-172",
          "snippet": "bool\nBytecode::readBool (bytecodeistream & str)\n{\n    char c;\n    str.get (c);\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n#endif\n\n    if (c != 0)\n    {\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readBool (bytecodeistream & str)\n  {\n      char c;\n      str.get (c);\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n  #endif\n  \n      if (c != 0)\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYConst {\n  YConst::YConst (ykind kind, bytecodeistream & str)\n      : m_kind (kind)\n      , m_value (YCPNull())\n  {\n      if (Bytecode::readBool (str))\t\t// not nil\n      {\n  #if DO_DEBUG\n  \ty2debug (\"YConst::YConst (%d:%s)\", (int)kind, YCode::toString (kind).c_str());\n  #endif\n  \tswitch (kind)\n  \t{\n  \t    case YCode::ycVoid:\n  \t    {\n  \t\tm_value = YCPVoid (str);\n  \t    }\n  \t    break;\n  \t    case YCode::ycBoolean:\n  \t    {\n  \t\tm_value = YCPBoolean (str);\n  \t    }\n  \t    break;\n  \t    case YCode::ycInteger:\n  \t    {\n  \t\tm_value = YCPInteger (str);\n  \t    }\n  \t    break;\n  \t    case YCode::ycFloat:\n  \t    {\n  \t\tm_value = YCPFloat (str);\n  \t    }\n  \t    break;\n  \t    case YCode::ycString:\n  \t    {\n  \t\tm_value = YCPString (str);\n  \t    }\n  \t    break;\n  \t    case YCode::ycByteblock:\n  \t    {\n  \t\tm_value = YCPByteblock (str);\n  \t    }\n  \t    break;\n  \t    case YCode::ycPath:\n  \t    {\n  \t\tm_value = YCPPath (str);\n  \t    }\n  \t    break;\n  \t    case YCode::ycSymbol:\n  \t    {\n  \t\tm_value = YCPSymbol (str);\n  \t    }\n  \t    break;\n  \t    case YCode::ycList:\n  \t    {\n  \t\tm_value = YCPList (str);\n  \t    }\n  \t    break;\n  \t    case YCode::ycMap:\n  \t    {\n  \t\tm_value = YCPMap (str);\n  \t    }\n  \t    break;\n  \t    case YCode::ycTerm:\n  \t    {\n  \t\tm_value = YCPTerm (str);\n  \t    }\n  \t    break;\n  \t    case YCode::ycEntry:\n  \t    {\n  #if DO_DEBUG\n  \t\ty2debug (\"YCode::ycEntry:\");\n  #endif\n  \t\tm_value = YCPEntry (Bytecode::readEntry (str));\n  \t    }\n  \t    break;\n  \t    default:\n  \t    {\n  \t\ty2error (\"YConst stream kind %d\", kind);\n  \t\tbreak;\n  \t    }\n  \t}\n  \tif (!m_value.isNull())\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"m_value '%s'\", m_value->toString().c_str());\n  #endif\n  \t}\n      }\n      else\n      {\n  \ty2warning (\"YConst::YConst(%d:%s) NIL\", (int)kind, YCode::toString(kind).c_str());\n      }\n  }\n}"
  },
  {
    "function_name": "YConst",
    "container": "YConst",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "235-239",
    "snippet": "YConst::YConst (ykind kind, YCPValue value)\n    : m_kind (kind)\n    , m_value (value)\n{\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYConst {\n  YConst::YConst (ykind kind, YCPValue value)\n      : m_kind (kind)\n      , m_value (value)\n  {\n  }\n}"
  },
  {
    "function_name": "type",
    "container": "YCode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "226-230",
    "snippet": "constTypePtr\nYCode::type () const\n{\n    return Type::Unspec;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  constTypePtr\n  YCode::type () const\n  {\n      return Type::Unspec;\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YCode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "212-223",
    "snippet": "YCPValue\nYCode::evaluate (bool /*cse*/)\n{\n#if DO_DEBUG\n    y2debug (\"evaluate(%s) = nil\", toString().c_str());\n#endif\n    if (isError())\n    {\n\ty2error (\"evaluating error code\");\n    }\n    return YCPNull();\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"evaluating error code\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isError",
          "args": [],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "isError",
          "container": "YCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "76-80",
          "snippet": "bool\nYCode::isError() const\n{\n    return false; \t\t// TODO unused in practice?\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  bool\n  YCode::isError() const\n  {\n      return false; \t\t// TODO unused in practice?\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"evaluate(%s) = nil\"",
            "toString().c_str()"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "708-719",
          "snippet": "string\nYFunction::toString() const\n{\n    string  s = toStringDeclaration ();\n    if (m_definition != 0)\n    {\n\ts += \"\\n\";\n\ts += m_definition->toString();\n    }\n\n    return s;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  string\n  YFunction::toString() const\n  {\n      string  s = toStringDeclaration ();\n      if (m_definition != 0)\n      {\n  \ts += \"\\n\";\n  \ts += m_definition->toString();\n      }\n  \n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYCode {\n  YCPValue\n  YCode::evaluate (bool /*cse*/)\n  {\n  #if DO_DEBUG\n      y2debug (\"evaluate(%s) = nil\", toString().c_str());\n  #endif\n      if (isError())\n      {\n  \ty2error (\"evaluating error code\");\n      }\n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YCode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "182-186",
    "snippet": "string\nYCode::toString() const\n{\n    return toString (kind ());\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "toString",
          "args": [
            "kind ()"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "104-179",
          "snippet": "string\nYCode::toString (ykind kind)\n{\n    static const char *names[] = {\n\t\"yxError\",\n\t// [1] Constants\t(-> YCPValue, except(!) locale -> yeLocale)\n\t\"ycVoid\", \"ycBoolean\", \"ycInteger\", \"ycFloat\",\t// constants\n\t\"ycString\", \"ycByteblock\", \"ycPath\", \"ycSymbol\",\n\t\"ycList\",\t\t\t\t\t// list\n\t\"ycMap\",\t\t\t\t\t// map\n\t\"ycTerm\",\t\t\t\t\t// term\n\t\"ycEntry\",\n\n\t\"ycConstant\",\t\t// -- placeholder --\n\t\"ycLocale\",\t\t// locale constant (gettext)\n\t\"ycFunction\",\t\t// function definition (declaration and definition)\n\n\t// [16] Expressions\t(-> declaration_t + values)\n\t\"yePropagate\",\t\t// type propagation (value, type)\n\t\"yeUnary\",\t\t// unary (prefix) operator\n\t\"yeBinary\",\t\t// binary (infix) operator\n\t\"yeTriple\",\t\t// <exp> ? <exp> : <exp>\n\t\"yeCompare\",\t\t// compare\n\n\t// [21] Value expressions (-> values + internal)\n\t\"yeLocale\",\t\t// locale expression (ngettext)\n\t\"yeList\",\t\t// list expression\n\t\"yeMap\",\t\t// map expression\n\t\"yeTerm\",\t\t// <name> ( ...)\n\t\"yeIs\",\t\t\t// is()\n\t\"yeBracket\",\t\t// <name> [ <expr>, ... ] : <expr>\n\n\t// [27] Block (-> linked list of statements)\n\t\"yeBlock\",\t\t// block expression\n\t\"yeReturn\",\t\t// quoted expression\n\n\t// [29] Symbolref (-> SymbolEntry)\n\t\"yeVariable\",\t\t// variable ref\n\t\"yeBuiltin\",\t\t// builtin ref + args\n\t\"yeFunction\",\t\t// function ref + args\n\t\"yeReference\",\t\t// reference\n        // SuSE Linux v9.2\n        \"yeFunctionPointer\",      // function pointer\n\n\t\"yeExpression\",\t\t// -- placeholder --\n\n\t// [35] Statements\t(-> YCode + next)\n\t\"ysTypedef\",\t\t// typedef\n\t\"ysVariable\",\t\t// variable definition (-> YSAssign)\n\t\"ysFunction\",\t\t// function definition\n\t\"ysAssign\",\t\t// variable assignment or definition\n\t\"ysBracket\",\t\t// <name> [ <expr>, ... ] = <expr>\n\t\"ysIf\",\t\t\t// if\", then\", else\n\t\"ysWhile\",\t\t// while () do ...\n\t\"ysDo\",\t\t\t// do ... while ()\n\t\"ysRepeat\",\t\t// repeat ... until ()\n\t\"ysExpression\",\t\t// any expression (function call)\n\t\"ysReturn\",\n\t\"ysBreak\",\n\t\"ysContinue\",\n\t\"ysTextdomain\",\n\t\"ysInclude\",\n\t\"ysImport\",\n\t\"ysBlock\",\t\t// a block\n// FIXME ysSwitch is missing\n\t\"ysStatement\"\t\t// -- placeholder --\n    };\n\n    if ((int)kind < 0 || (unsigned int)kind >= (sizeof (names) / sizeof (*names)))\n    {\n\ty2error (\"Bad ykind %d\", kind);\n\treturn \"*** BAD YCode\";\n    }\n    char buf[16]; sprintf (buf, \"[%d]\", kind);\n    return string (buf) + names[kind];\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kind",
          "args": [],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": "YConst",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "336-340",
          "snippet": "YCode::ykind\nYConst::kind() const\n{\n    return m_kind;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYConst {\n  YCode::ykind\n  YConst::kind() const\n  {\n      return m_kind;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  string\n  YCode::toString() const\n  {\n      return toString (kind ());\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YCode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "104-179",
    "snippet": "string\nYCode::toString (ykind kind)\n{\n    static const char *names[] = {\n\t\"yxError\",\n\t// [1] Constants\t(-> YCPValue, except(!) locale -> yeLocale)\n\t\"ycVoid\", \"ycBoolean\", \"ycInteger\", \"ycFloat\",\t// constants\n\t\"ycString\", \"ycByteblock\", \"ycPath\", \"ycSymbol\",\n\t\"ycList\",\t\t\t\t\t// list\n\t\"ycMap\",\t\t\t\t\t// map\n\t\"ycTerm\",\t\t\t\t\t// term\n\t\"ycEntry\",\n\n\t\"ycConstant\",\t\t// -- placeholder --\n\t\"ycLocale\",\t\t// locale constant (gettext)\n\t\"ycFunction\",\t\t// function definition (declaration and definition)\n\n\t// [16] Expressions\t(-> declaration_t + values)\n\t\"yePropagate\",\t\t// type propagation (value, type)\n\t\"yeUnary\",\t\t// unary (prefix) operator\n\t\"yeBinary\",\t\t// binary (infix) operator\n\t\"yeTriple\",\t\t// <exp> ? <exp> : <exp>\n\t\"yeCompare\",\t\t// compare\n\n\t// [21] Value expressions (-> values + internal)\n\t\"yeLocale\",\t\t// locale expression (ngettext)\n\t\"yeList\",\t\t// list expression\n\t\"yeMap\",\t\t// map expression\n\t\"yeTerm\",\t\t// <name> ( ...)\n\t\"yeIs\",\t\t\t// is()\n\t\"yeBracket\",\t\t// <name> [ <expr>, ... ] : <expr>\n\n\t// [27] Block (-> linked list of statements)\n\t\"yeBlock\",\t\t// block expression\n\t\"yeReturn\",\t\t// quoted expression\n\n\t// [29] Symbolref (-> SymbolEntry)\n\t\"yeVariable\",\t\t// variable ref\n\t\"yeBuiltin\",\t\t// builtin ref + args\n\t\"yeFunction\",\t\t// function ref + args\n\t\"yeReference\",\t\t// reference\n        // SuSE Linux v9.2\n        \"yeFunctionPointer\",      // function pointer\n\n\t\"yeExpression\",\t\t// -- placeholder --\n\n\t// [35] Statements\t(-> YCode + next)\n\t\"ysTypedef\",\t\t// typedef\n\t\"ysVariable\",\t\t// variable definition (-> YSAssign)\n\t\"ysFunction\",\t\t// function definition\n\t\"ysAssign\",\t\t// variable assignment or definition\n\t\"ysBracket\",\t\t// <name> [ <expr>, ... ] = <expr>\n\t\"ysIf\",\t\t\t// if\", then\", else\n\t\"ysWhile\",\t\t// while () do ...\n\t\"ysDo\",\t\t\t// do ... while ()\n\t\"ysRepeat\",\t\t// repeat ... until ()\n\t\"ysExpression\",\t\t// any expression (function call)\n\t\"ysReturn\",\n\t\"ysBreak\",\n\t\"ysContinue\",\n\t\"ysTextdomain\",\n\t\"ysInclude\",\n\t\"ysImport\",\n\t\"ysBlock\",\t\t// a block\n// FIXME ysSwitch is missing\n\t\"ysStatement\"\t\t// -- placeholder --\n    };\n\n    if ((int)kind < 0 || (unsigned int)kind >= (sizeof (names) / sizeof (*names)))\n    {\n\ty2error (\"Bad ykind %d\", kind);\n\treturn \"*** BAD YCode\";\n    }\n    char buf[16]; sprintf (buf, \"[%d]\", kind);\n    return string (buf) + names[kind];\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "string",
          "args": [
            "buf"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"[%d]\"",
            "kind"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad ykind %d\"",
            "kind"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  string\n  YCode::toString (ykind kind)\n  {\n      static const char *names[] = {\n  \t\"yxError\",\n  \t// [1] Constants\t(-> YCPValue, except(!) locale -> yeLocale)\n  \t\"ycVoid\", \"ycBoolean\", \"ycInteger\", \"ycFloat\",\t// constants\n  \t\"ycString\", \"ycByteblock\", \"ycPath\", \"ycSymbol\",\n  \t\"ycList\",\t\t\t\t\t// list\n  \t\"ycMap\",\t\t\t\t\t// map\n  \t\"ycTerm\",\t\t\t\t\t// term\n  \t\"ycEntry\",\n  \n  \t\"ycConstant\",\t\t// -- placeholder --\n  \t\"ycLocale\",\t\t// locale constant (gettext)\n  \t\"ycFunction\",\t\t// function definition (declaration and definition)\n  \n  \t// [16] Expressions\t(-> declaration_t + values)\n  \t\"yePropagate\",\t\t// type propagation (value, type)\n  \t\"yeUnary\",\t\t// unary (prefix) operator\n  \t\"yeBinary\",\t\t// binary (infix) operator\n  \t\"yeTriple\",\t\t// <exp> ? <exp> : <exp>\n  \t\"yeCompare\",\t\t// compare\n  \n  \t// [21] Value expressions (-> values + internal)\n  \t\"yeLocale\",\t\t// locale expression (ngettext)\n  \t\"yeList\",\t\t// list expression\n  \t\"yeMap\",\t\t// map expression\n  \t\"yeTerm\",\t\t// <name> ( ...)\n  \t\"yeIs\",\t\t\t// is()\n  \t\"yeBracket\",\t\t// <name> [ <expr>, ... ] : <expr>\n  \n  \t// [27] Block (-> linked list of statements)\n  \t\"yeBlock\",\t\t// block expression\n  \t\"yeReturn\",\t\t// quoted expression\n  \n  \t// [29] Symbolref (-> SymbolEntry)\n  \t\"yeVariable\",\t\t// variable ref\n  \t\"yeBuiltin\",\t\t// builtin ref + args\n  \t\"yeFunction\",\t\t// function ref + args\n  \t\"yeReference\",\t\t// reference\n          // SuSE Linux v9.2\n          \"yeFunctionPointer\",      // function pointer\n  \n  \t\"yeExpression\",\t\t// -- placeholder --\n  \n  \t// [35] Statements\t(-> YCode + next)\n  \t\"ysTypedef\",\t\t// typedef\n  \t\"ysVariable\",\t\t// variable definition (-> YSAssign)\n  \t\"ysFunction\",\t\t// function definition\n  \t\"ysAssign\",\t\t// variable assignment or definition\n  \t\"ysBracket\",\t\t// <name> [ <expr>, ... ] = <expr>\n  \t\"ysIf\",\t\t\t// if\", then\", else\n  \t\"ysWhile\",\t\t// while () do ...\n  \t\"ysDo\",\t\t\t// do ... while ()\n  \t\"ysRepeat\",\t\t// repeat ... until ()\n  \t\"ysExpression\",\t\t// any expression (function call)\n  \t\"ysReturn\",\n  \t\"ysBreak\",\n  \t\"ysContinue\",\n  \t\"ysTextdomain\",\n  \t\"ysInclude\",\n  \t\"ysImport\",\n  \t\"ysBlock\",\t\t// a block\n  // FIXME ysSwitch is missing\n  \t\"ysStatement\"\t\t// -- placeholder --\n      };\n  \n      if ((int)kind < 0 || (unsigned int)kind >= (sizeof (names) / sizeof (*names)))\n      {\n  \ty2error (\"Bad ykind %d\", kind);\n  \treturn \"*** BAD YCode\";\n      }\n      char buf[16]; sprintf (buf, \"[%d]\", kind);\n      return string (buf) + names[kind];\n  }\n}"
  },
  {
    "function_name": "isReferenceable",
    "container": "YCode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "97-101",
    "snippet": "bool\nYCode::isReferenceable () const\n{\n    return false;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  bool\n  YCode::isReferenceable () const\n  {\n      return false;\n  }\n}"
  },
  {
    "function_name": "isBlock",
    "container": "YCode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "90-94",
    "snippet": "bool\nYCode::isBlock () const\n{\n    return false;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  bool\n  YCode::isBlock () const\n  {\n      return false;\n  }\n}"
  },
  {
    "function_name": "isStatement",
    "container": "YCode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "83-87",
    "snippet": "bool\nYCode::isStatement() const\n{\n    return false;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  bool\n  YCode::isStatement() const\n  {\n      return false;\n  }\n}"
  },
  {
    "function_name": "isError",
    "container": "YCode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "76-80",
    "snippet": "bool\nYCode::isError() const\n{\n    return false; \t\t// TODO unused in practice?\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  bool\n  YCode::isError() const\n  {\n      return false; \t\t// TODO unused in practice?\n  }\n}"
  },
  {
    "function_name": "isConstant",
    "container": "YCode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "69-73",
    "snippet": "bool\nYCode::isConstant() const\n{\n    return false;\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  bool\n  YCode::isConstant() const\n  {\n      return false;\n  }\n}"
  },
  {
    "function_name": "~YCode",
    "container": "YCode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "64-66",
    "snippet": "YCode::~YCode ()\n{\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  YCode::~YCode ()\n  {\n  }\n}"
  },
  {
    "function_name": "YCode",
    "container": "YCode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
    "lines": "59-61",
    "snippet": "YCode::YCode ()\n{\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBreakpoint.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPByteblock.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCode.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  YCode::YCode ()\n  {\n  }\n}"
  }
]