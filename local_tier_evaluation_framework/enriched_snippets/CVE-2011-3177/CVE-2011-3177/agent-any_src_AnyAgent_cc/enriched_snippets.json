[
  {
    "function_name": "findSyntax",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
    "lines": "929-1030",
    "snippet": "YCPValue\nAnyAgent::findSyntax (const YCPValue & syntax, const YCPPath & path)\n{\n    y2debug (\"findSyntax ('%s':'%s')\", syntax->toString ().c_str (),\n\t     path->toString ().c_str ());\n\n    YCPValue cur_syntax = syntax;\n\n    const int len = path->length ();\n    if (len > 0)\n    {\n\tfor (int i = 0; i < len; i++)\n\t{\n\t    const string p = path->component_str (i);\n\n\t    if (cur_syntax.isNull ())\n\t\tbreak;\n\n\t    switch (cur_syntax->valuetype ())\n\t    {\n\t\tcase YT_TERM: {\n\t\t    YCPTerm t = cur_syntax->asTerm ();\n\t\t    string s = t->name ();\n\n\t\t    // `tuple_name (<cur_syntax>)\n\n\t\t    if (s == p && t->size () > 0)\n\t\t    {\n\t\t\tcur_syntax = t->value (0);\n\t\t    }\n\n\t\t    else if (s == \"Tuple\" && t->size () > 0)\n\t\t    {\n\t\t\tif (isdigit (p[0]))\n\t\t\t{\n\t\t\t    int tnum = atoi (p.c_str ());\n\t\t\t    for (int j = 0; j < t->size (); j++)\n\t\t\t    {\n\t\t\t\tYCPValue v = t->value (j);\n\t\t\t\tif (v->isTerm ())\n\t\t\t\t{\n\t\t\t\t    YCPTerm vt = v->asTerm ();\n\t\t\t\t    if (islower (vt->name ()[0]) &&\n\t\t\t\t\t(vt->size () > 0))\n\t\t\t\t    {\n\t\t\t\t\tif (tnum == 0)\n\t\t\t\t\t{\n\t\t\t\t\t    cur_syntax = vt->value (0);\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t\ttnum--;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    for (int j = 0; j < t->size (); j++)\n\t\t\t    {\n\t\t\t\tYCPValue v = t->value (j);\n\t\t\t\tif (v->isTerm ())\n\t\t\t\t{\n\t\t\t\t    YCPTerm vt = v->asTerm ();\n\t\t\t\t    if (p == vt->name () && vt->size () > 0)\n\t\t\t\t    {\n\t\t\t\t\tcur_syntax = vt->value (0);\n\t\t\t\t\tbreak;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\n\t\t    else if (s == \"List\" && t->size () > 0 && isdigit (p[0]))\n\t\t    {\n\t\t\tcur_syntax = t->value (0);\n\t\t    }\n\n\t\t    else\n\t\t    {\n\t\t\ty2error (\"Can't find syntax for path '%s' in '%s'\",\n\t\t\t\t p.c_str (), cur_syntax->toString ().c_str ());\n\t\t\tcur_syntax = YCPNull ();\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\tcase YT_STRING:\n\t\t    break;\n\n\t\tdefault:\n\t\t    cur_syntax = YCPNull ();\n\t\t    break;\n\t    }\n\t}\n    }\n\n    y2debug (\"found syntax (%s)\", !cur_syntax.isNull () ?\n\t     cur_syntax->toString ().c_str () : \"<nil>\");\n\n    return cur_syntax;\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"found syntax (%s)\"",
            "!cur_syntax.isNull () ?\n\t     cur_syntax->toString ().c_str () : \"<nil>\""
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_syntax->toString",
          "args": [],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_syntax.isNull",
          "args": [],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Can't find syntax for path '%s' in '%s'\"",
            "p.c_str ()",
            "cur_syntax->toString ().c_str ()"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.c_str",
          "args": [],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->value",
          "args": [
            "0"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YEList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "773-783",
          "snippet": "YCodePtr\nYEList::value (int index) const\n{\n    ycodelist_t *element = m_first;\n    while (element && index)\n    {\n\telement = element->next;\n\tindex--;\n    }\n    return element != NULL ? element->code : NULL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEList {\n  YCodePtr\n  YEList::value (int index) const\n  {\n      ycodelist_t *element = m_first;\n      while (element && index)\n      {\n  \telement = element->next;\n  \tindex--;\n      }\n      return element != NULL ? element->code : NULL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "p[0]"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->size",
          "args": [],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "42-46",
          "snippet": "int\nYCPListRep::size() const\n{\n    return elements.size();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  int\n  YCPListRep::size() const\n  {\n      return elements.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vt->value",
          "args": [
            "0"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vt->size",
          "args": [],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vt->name",
          "args": [],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2AgentComp",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "44-44",
          "snippet": "string name () const { return my_name; }",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp {\n  string name () const { return my_name; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->asTerm",
          "args": [],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->isTerm",
          "args": [],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "isTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "70-70",
          "snippet": "bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "islower",
          "args": [
            "vt->name ()[0]"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p.c_str ()"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.c_str",
          "args": [],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "p[0]"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_syntax->valuetype",
          "args": [],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "YCPSymbolRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "69-73",
          "snippet": "YCPValueType\nYCPSymbolRep::valuetype() const\n{\n    return YT_SYMBOL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbolRep {\n  YCPValueType\n  YCPSymbolRep::valuetype() const\n  {\n      return YT_SYMBOL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_syntax.isNull",
          "args": [],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [
            "i"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "component_str",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "161-165",
          "snippet": "string\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  string\n  YCPPathRep::component_str(long index) const\n  {\n      return components[index].component.asString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "path->length",
          "args": [],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"findSyntax ('%s':'%s')\"",
            "syntax->toString ().c_str ()",
            "path->toString ().c_str ()"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::findSyntax (const YCPValue & syntax, const YCPPath & path)\n  {\n      y2debug (\"findSyntax ('%s':'%s')\", syntax->toString ().c_str (),\n  \t     path->toString ().c_str ());\n  \n      YCPValue cur_syntax = syntax;\n  \n      const int len = path->length ();\n      if (len > 0)\n      {\n  \tfor (int i = 0; i < len; i++)\n  \t{\n  \t    const string p = path->component_str (i);\n  \n  \t    if (cur_syntax.isNull ())\n  \t\tbreak;\n  \n  \t    switch (cur_syntax->valuetype ())\n  \t    {\n  \t\tcase YT_TERM: {\n  \t\t    YCPTerm t = cur_syntax->asTerm ();\n  \t\t    string s = t->name ();\n  \n  \t\t    // `tuple_name (<cur_syntax>)\n  \n  \t\t    if (s == p && t->size () > 0)\n  \t\t    {\n  \t\t\tcur_syntax = t->value (0);\n  \t\t    }\n  \n  \t\t    else if (s == \"Tuple\" && t->size () > 0)\n  \t\t    {\n  \t\t\tif (isdigit (p[0]))\n  \t\t\t{\n  \t\t\t    int tnum = atoi (p.c_str ());\n  \t\t\t    for (int j = 0; j < t->size (); j++)\n  \t\t\t    {\n  \t\t\t\tYCPValue v = t->value (j);\n  \t\t\t\tif (v->isTerm ())\n  \t\t\t\t{\n  \t\t\t\t    YCPTerm vt = v->asTerm ();\n  \t\t\t\t    if (islower (vt->name ()[0]) &&\n  \t\t\t\t\t(vt->size () > 0))\n  \t\t\t\t    {\n  \t\t\t\t\tif (tnum == 0)\n  \t\t\t\t\t{\n  \t\t\t\t\t    cur_syntax = vt->value (0);\n  \t\t\t\t\t    break;\n  \t\t\t\t\t}\n  \t\t\t\t\ttnum--;\n  \t\t\t\t    }\n  \t\t\t\t}\n  \t\t\t    }\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t    for (int j = 0; j < t->size (); j++)\n  \t\t\t    {\n  \t\t\t\tYCPValue v = t->value (j);\n  \t\t\t\tif (v->isTerm ())\n  \t\t\t\t{\n  \t\t\t\t    YCPTerm vt = v->asTerm ();\n  \t\t\t\t    if (p == vt->name () && vt->size () > 0)\n  \t\t\t\t    {\n  \t\t\t\t\tcur_syntax = vt->value (0);\n  \t\t\t\t\tbreak;\n  \t\t\t\t    }\n  \t\t\t\t}\n  \t\t\t    }\n  \t\t\t}\n  \t\t    }\n  \n  \t\t    else if (s == \"List\" && t->size () > 0 && isdigit (p[0]))\n  \t\t    {\n  \t\t\tcur_syntax = t->value (0);\n  \t\t    }\n  \n  \t\t    else\n  \t\t    {\n  \t\t\ty2error (\"Can't find syntax for path '%s' in '%s'\",\n  \t\t\t\t p.c_str (), cur_syntax->toString ().c_str ());\n  \t\t\tcur_syntax = YCPNull ();\n  \t\t    }\n  \t\t}\n  \t\tbreak;\n  \n  \t\tcase YT_STRING:\n  \t\t    break;\n  \n  \t\tdefault:\n  \t\t    cur_syntax = YCPNull ();\n  \t\t    break;\n  \t    }\n  \t}\n      }\n  \n      y2debug (\"found syntax (%s)\", !cur_syntax.isNull () ?\n  \t     cur_syntax->toString ().c_str () : \"<nil>\");\n  \n      return cur_syntax;\n  }\n}"
  },
  {
    "function_name": "writeValueByPath",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
    "lines": "859-919",
    "snippet": "YCPValue\nAnyAgent::writeValueByPath (const YCPValue & current, const YCPPath & path,\n\t\t\t    const YCPValue & value)\n{\n    y2debug (\"writeValueByPath ()\");\n\n    YCPValue run = current;\n    for (int i = 0; i < path->length (); i++)\n    {\n\tconst char *s = path->component_str (i).c_str ();\n\n\ty2debug (\"writeValueByPath (%s)\", s);\n\n\t// .<num> -> return entry <num> of cached list data\n\t//\n\n\tif (isdigit (s[0]))\n\t{\n\t    int num = atoi (s);\n\n\t    if (run->isList ())\n\t    {\n\t\tif ((num < 0) || (num > run->asList ()->size ()))\n\t\t{\n\t\t    y2error (\"Bad index %d for ._.<num>\", num);\n\t\t    return YCPVoid ();\n\t\t}\n\t\trun = run->asList ()->value (num);\n\t    }\n\t    else if (run->isMap ())\n\t    {\n\t\tYCPValue v = run->asMap ()->value (YCPString (s));\n\t\tif (v.isNull ())\n\t\t{\n\t\t    y2error (\"Bad index %s for ._.<num>\", s);\n\t\t    return YCPVoid ();\n\t\t}\n\t\telse\n\t\t    run = v;\n\t    }\n\t}\n\n\t// .<name> -> return entry <name> of cached map data\n\t//\n\n\telse if (run->isMap ())\n\t{\n\t    run = run->asMap ()->value (YCPString (s));\n\t}\n\n\telse\n\t{\n\t    y2error (\"Write path element '%s' does not match value %s\",\n\t\t     s, run->toString ().c_str ());\n\t    run = YCPVoid ();\n\t    break;\n\t}\n    }\n\n    return run;\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Write path element '%s' does not match value %s\"",
            "s",
            "run->toString ().c_str ()"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run->toString",
          "args": [],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "run->asMap",
          "args": [
            "YCPString (s)"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "s"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "run->asMap",
          "args": [],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "run->isMap",
          "args": [],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "71-71",
          "snippet": "bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad index %s for ._.<num>\"",
            "s"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run->asMap",
          "args": [
            "YCPString (s)"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run->asList",
          "args": [
            "num"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run->asList",
          "args": [],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad index %d for ._.<num>\"",
            "num"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run->isList",
          "args": [],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "s[0]"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"writeValueByPath (%s)\"",
            "s"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [
            "i"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "component_str",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "161-165",
          "snippet": "string\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  string\n  YCPPathRep::component_str(long index) const\n  {\n      return components[index].component.asString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "path->length",
          "args": [],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"writeValueByPath ()\""
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::writeValueByPath (const YCPValue & current, const YCPPath & path,\n  \t\t\t    const YCPValue & value)\n  {\n      y2debug (\"writeValueByPath ()\");\n  \n      YCPValue run = current;\n      for (int i = 0; i < path->length (); i++)\n      {\n  \tconst char *s = path->component_str (i).c_str ();\n  \n  \ty2debug (\"writeValueByPath (%s)\", s);\n  \n  \t// .<num> -> return entry <num> of cached list data\n  \t//\n  \n  \tif (isdigit (s[0]))\n  \t{\n  \t    int num = atoi (s);\n  \n  \t    if (run->isList ())\n  \t    {\n  \t\tif ((num < 0) || (num > run->asList ()->size ()))\n  \t\t{\n  \t\t    y2error (\"Bad index %d for ._.<num>\", num);\n  \t\t    return YCPVoid ();\n  \t\t}\n  \t\trun = run->asList ()->value (num);\n  \t    }\n  \t    else if (run->isMap ())\n  \t    {\n  \t\tYCPValue v = run->asMap ()->value (YCPString (s));\n  \t\tif (v.isNull ())\n  \t\t{\n  \t\t    y2error (\"Bad index %s for ._.<num>\", s);\n  \t\t    return YCPVoid ();\n  \t\t}\n  \t\telse\n  \t\t    run = v;\n  \t    }\n  \t}\n  \n  \t// .<name> -> return entry <name> of cached map data\n  \t//\n  \n  \telse if (run->isMap ())\n  \t{\n  \t    run = run->asMap ()->value (YCPString (s));\n  \t}\n  \n  \telse\n  \t{\n  \t    y2error (\"Write path element '%s' does not match value %s\",\n  \t\t     s, run->toString ().c_str ());\n  \t    run = YCPVoid ();\n  \t    break;\n  \t}\n      }\n  \n      return run;\n  }\n}"
  },
  {
    "function_name": "readValueByPath",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
    "lines": "788-843",
    "snippet": "YCPValue\nAnyAgent::readValueByPath (const YCPValue & value, const YCPPath & path)\n{\n    YCPValue sub_value = value;\n    for (int i = 0; i < path->length (); i++)\n    {\n\tconst char *s = path->component_str (i).c_str ();\n\n\t// .<num> -> return entry <num> of cached list data\n\t//\n\n\tif (isdigit ((unsigned char) s[0]))\n\t{\n\t    int num = atoi (s);\n\n\t    if (sub_value->isList ())\n\t    {\n\t\tif ((num < 0) || (num > sub_value->asList ()->size ()))\n\t\t{\n\t\t    y2error (\"Bad index %d for ._.<num>\", num);\n\t\t    return YCPVoid ();\n\t\t}\n\t\tsub_value = sub_value->asList ()->value (num);\n\t    }\n\t    else if (sub_value->isMap ())\n\t    {\n\t\tYCPValue v = sub_value->asMap ()->value (YCPString (s));\n\t\tif (v.isNull ())\n\t\t{\n\t\t    y2error (\"Bad index %s for ._.<num>\", s);\n\t\t    return YCPVoid ();\n\t\t}\n\t\telse\n\t\t    sub_value = v;\n\t    }\n\t}\n\n\t// .<name> -> return entry <name> of cached map data\n\t//\n\n\telse if (sub_value->isMap ())\n\t{\n\t    sub_value = sub_value->asMap ()->value (YCPString (s));\n\t}\n\n\telse\n\t{\n\t    y2error (\"Read path element '%s' does not match value %s\",\n\t\t     s, sub_value->toString ().c_str ());\n\t    sub_value = YCPVoid ();\n\t    break;\n\t}\n    }\n\n    return sub_value;\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Read path element '%s' does not match value %s\"",
            "s",
            "sub_value->toString ().c_str ()"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sub_value->toString",
          "args": [],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_value->asMap",
          "args": [
            "YCPString (s)"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "s"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_value->asMap",
          "args": [],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_value->isMap",
          "args": [],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "71-71",
          "snippet": "bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad index %s for ._.<num>\"",
            "s"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sub_value->asMap",
          "args": [
            "YCPString (s)"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sub_value->asList",
          "args": [
            "num"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sub_value->asList",
          "args": [],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad index %d for ._.<num>\"",
            "num"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sub_value->isList",
          "args": [],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) s[0]"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [
            "i"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "component_str",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "161-165",
          "snippet": "string\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  string\n  YCPPathRep::component_str(long index) const\n  {\n      return components[index].component.asString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "path->length",
          "args": [],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::readValueByPath (const YCPValue & value, const YCPPath & path)\n  {\n      YCPValue sub_value = value;\n      for (int i = 0; i < path->length (); i++)\n      {\n  \tconst char *s = path->component_str (i).c_str ();\n  \n  \t// .<num> -> return entry <num> of cached list data\n  \t//\n  \n  \tif (isdigit ((unsigned char) s[0]))\n  \t{\n  \t    int num = atoi (s);\n  \n  \t    if (sub_value->isList ())\n  \t    {\n  \t\tif ((num < 0) || (num > sub_value->asList ()->size ()))\n  \t\t{\n  \t\t    y2error (\"Bad index %d for ._.<num>\", num);\n  \t\t    return YCPVoid ();\n  \t\t}\n  \t\tsub_value = sub_value->asList ()->value (num);\n  \t    }\n  \t    else if (sub_value->isMap ())\n  \t    {\n  \t\tYCPValue v = sub_value->asMap ()->value (YCPString (s));\n  \t\tif (v.isNull ())\n  \t\t{\n  \t\t    y2error (\"Bad index %s for ._.<num>\", s);\n  \t\t    return YCPVoid ();\n  \t\t}\n  \t\telse\n  \t\t    sub_value = v;\n  \t    }\n  \t}\n  \n  \t// .<name> -> return entry <name> of cached map data\n  \t//\n  \n  \telse if (sub_value->isMap ())\n  \t{\n  \t    sub_value = sub_value->asMap ()->value (YCPString (s));\n  \t}\n  \n  \telse\n  \t{\n  \t    y2error (\"Read path element '%s' does not match value %s\",\n  \t\t     s, sub_value->toString ().c_str ());\n  \t    sub_value = YCPVoid ();\n  \t    break;\n  \t}\n      }\n  \n      return sub_value;\n  }\n}"
  },
  {
    "function_name": "writeFile",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
    "lines": "767-773",
    "snippet": "const string\nAnyAgent::writeFile (const YCPValue & arg)\n{\n    if (!mHeader.isNull ())\n\tunparseData (mHeader, YCPNull ());\n    return \"\";\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unparseData",
          "args": [
            "mHeader",
            "YCPNull ()"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "unparseData",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "713-952",
          "snippet": "const string\nAnyAgent::unparseData (const YCPValue & syntax, const YCPValue & value)\n{\n    if (syntax.isNull ())\n\treturn \"\";\n\n    y2debug (\"unparseData ('%s',%s)\", value.isNull () ? \"\" : value->toString ().c_str (),\n\t     syntax->toString ().c_str ());\n\n    switch (syntax->valuetype ())\n    {\n\tcase YT_TERM: {\n\n\t    YCPTerm term = syntax->asTerm ();\n\t    if (term.isNull ())\n\t    {\n\t\ty2error (\"YT_TERM no term\");\n\t    }\n\t    string s = term->name ();\n\t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n\n\t    // Optional\n\n\t    if (s == \"Optional\" && term->size () > 0)\n\t    {\n\t\treturn unparseData (term->value (0), value);\n\t    }\n\n\t    // Continue\n\n\t    else if (s == \"Continue\" && term->size () > 0)\n\t    {\n\t\tif (tupleContinue)\n\t\t    return unparseData (term->value (0), value);\n\t    }\n\n\t    // Choice\n\n\t    else if (s == \"Choice\" && term->size () > 0)\n\t    {\n\t\treturn unparseChoice (term->args (), value);\n\t    }\n\n\t    // Sequence\n\n\t    else if (s == \"Sequence\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tconst string s = unparseSequence (term->args (), value);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn s;\n\t    }\n\n\t    // List\n\n\t    else if (s == \"List\" && term->size () == 2)\n\t    {\n\t\treturn unparseList (term->args (), value);\n\t    }\n\n\t    // Tuple\n\n\t    else if (s == \"Tuple\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tconst string s = unparseTuple (term->args (), value);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn s;\n\t    }\n\n\t    // Var\n\n\t    else if (s == \"Var\" && term->size () > 0)\n\t    {\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    const string vdata = unparseData (term->value (i), value);\n\t\t    if (vdata.empty ())\n\t\t\tbreak;\n\t\t}\n\t\treturn \"\";\n\t    }\n\n\t    // Name\n\n\t    else if (s == \"Name\" && term->size () == 1)\n\t    {\n\t\ty2error (\"unparse Name ()\");\n\t\treturn \"\";\n\t    }\n\n\t    // Value\n\n\t    else if (s == \"Value\" && term->size () == 1)\n\t    {\n\t\tconst string s = unparseData (term->value (0), value);\n#if 0\n\t\tif (tv && tupleValue.size () > 0)\n\t\t    tupleValue.top () = tv;\n#endif\n\t\treturn s;\n\t    }\n\n\t    // Separator\n\n\t    else if (s == \"Separator\" && term->size () == 1)\n\t    {\n\t\treturn unparseSeparator (term->value (0));\n\t    }\n\n\t    // Whitespace\n\n\t    else if (s == \"Whitespace\")\n\t    {\n\t\treturn unparseSeparator (YCPString (\" \\t\"));\n\t    }\n\n\t    // Skip (is handled correctly within unparseTuple()\n\n\t    else if (s == \"Skip\")\n\t    {\n\t\treturn \"\";\n\t    }\n\n\t    // Fillup (is handled correctly within unparseTuple()\n\n\t    else if (s == \"Fillup\")\n\t    {\n\t\treturn \"\";\n\t    }\n\n\t    // String\n\n\t    else if (s == \"String\" && term->size () > 0)\n\t    {\n\t\tif (term->size () == 1)\n\t\t    return unparseString (term->value (0), YCPNull (), value);\n\t\tif (term->size () == 2)\n\t\t    return unparseString (term->value (0), term->value (1),\n\t\t\t\t\t  value);\n\t    }\n\n\t    // Or\n\n\t    else if (s == \"Or\" && term->size () == 2)\n\t    {\n#if 1\n\t\tconst YCPValue vbackup = value;\n\t\tconst string vdata = unparseData (term->value (0), value);\n\t\tif (vdata != \"\")\n\t\t    return vdata;\n\t\telse\n\t\t    return unparseData (term->value (1), vbackup);\n#endif\n\t    }\n\n\t    // Number\n\n\t    else if (s == \"Number\")\n\t    {\n\t\treturn unparseNumber (value);\n\t    }\n\n\t    // Boolean\n\n\t    else if (s == \"Boolean\")\n\t    {\n\t\treturn unparseBoolean (value);\n\t    }\n\n\t    // Float\n\n\t    else if (s == \"Float\")\n\t    {\n\t\treturn unparseFloat (value);\n\t    }\n\n\t    // Ip4Number\n\n\t    else if (s == \"Ip4Number\")\n\t    {\n\t\treturn unparseIp4Number (value);\n\t    }\n\n\t    // Hostname\n\n\t    else if (s == \"Hostname\")\n\t    {\n\t\treturn unparseHostname (value);\n\t    }\n\n\t    // Username\n\n\t    else if (s == \"Username\")\n\t    {\n\t\treturn unparseUsername (value);\n\t    }\n\n\t    // <name> (<syntax>)\n\n\t    else if (islower (s[0]) && (term->size () == 1))\n\t    {\n\t\tif (!value->isMap ())\n\t\t    y2error (\"request for element '%s' but value not map\",\n\t\t\t     s.c_str ());\n\t\telse\n\t\t{\n\t\t    YCPValue v = value->asMap ()->value (YCPString (s));\n\t\t    if (v.isNull ())\n\t\t    {\n\t\t\ty2error (\"No value for key '%s' in map\", s.c_str ());\n\t\t\treturn \"\";\n\t\t    }\n\t\t    return unparseData (term->value (0), v);\n\t\t}\n\t    }\n\n\t    else\n\t    {\n\t\ty2error (\"unparseData: unknown term '%s'\", s.c_str ());\n\t\treturn \"\";\n\t    }\n\t} break;\n\n\tcase YT_STRING:\n\t    y2debug (\"YT_STRING\");\n\t    return unparseVerbose (syntax);\n\t    break;\n\n\tdefault:\n\t    y2error (\"unparseData: unknown syntax %s\", syntax->toString ().c_str ());\n\t    break;\n    }\n\n    return \"\";\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseData (const YCPValue & syntax, const YCPValue & value)\n  {\n      if (syntax.isNull ())\n  \treturn \"\";\n  \n      y2debug (\"unparseData ('%s',%s)\", value.isNull () ? \"\" : value->toString ().c_str (),\n  \t     syntax->toString ().c_str ());\n  \n      switch (syntax->valuetype ())\n      {\n  \tcase YT_TERM: {\n  \n  \t    YCPTerm term = syntax->asTerm ();\n  \t    if (term.isNull ())\n  \t    {\n  \t\ty2error (\"YT_TERM no term\");\n  \t    }\n  \t    string s = term->name ();\n  \t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n  \n  \t    // Optional\n  \n  \t    if (s == \"Optional\" && term->size () > 0)\n  \t    {\n  \t\treturn unparseData (term->value (0), value);\n  \t    }\n  \n  \t    // Continue\n  \n  \t    else if (s == \"Continue\" && term->size () > 0)\n  \t    {\n  \t\tif (tupleContinue)\n  \t\t    return unparseData (term->value (0), value);\n  \t    }\n  \n  \t    // Choice\n  \n  \t    else if (s == \"Choice\" && term->size () > 0)\n  \t    {\n  \t\treturn unparseChoice (term->args (), value);\n  \t    }\n  \n  \t    // Sequence\n  \n  \t    else if (s == \"Sequence\" && term->size () > 0)\n  \t    {\n  \t\ttupleName.push (\"\");\n  \t\ttupleValue.push (YCPNull ());\n  \t\tconst string s = unparseSequence (term->args (), value);\n  \t\ttupleName.pop ();\n  \t\ttupleValue.pop ();\n  \t\treturn s;\n  \t    }\n  \n  \t    // List\n  \n  \t    else if (s == \"List\" && term->size () == 2)\n  \t    {\n  \t\treturn unparseList (term->args (), value);\n  \t    }\n  \n  \t    // Tuple\n  \n  \t    else if (s == \"Tuple\" && term->size () > 0)\n  \t    {\n  \t\ttupleName.push (\"\");\n  \t\ttupleValue.push (YCPNull ());\n  \t\tconst string s = unparseTuple (term->args (), value);\n  \t\ttupleName.pop ();\n  \t\ttupleValue.pop ();\n  \t\treturn s;\n  \t    }\n  \n  \t    // Var\n  \n  \t    else if (s == \"Var\" && term->size () > 0)\n  \t    {\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    const string vdata = unparseData (term->value (i), value);\n  \t\t    if (vdata.empty ())\n  \t\t\tbreak;\n  \t\t}\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // Name\n  \n  \t    else if (s == \"Name\" && term->size () == 1)\n  \t    {\n  \t\ty2error (\"unparse Name ()\");\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // Value\n  \n  \t    else if (s == \"Value\" && term->size () == 1)\n  \t    {\n  \t\tconst string s = unparseData (term->value (0), value);\n  #if 0\n  \t\tif (tv && tupleValue.size () > 0)\n  \t\t    tupleValue.top () = tv;\n  #endif\n  \t\treturn s;\n  \t    }\n  \n  \t    // Separator\n  \n  \t    else if (s == \"Separator\" && term->size () == 1)\n  \t    {\n  \t\treturn unparseSeparator (term->value (0));\n  \t    }\n  \n  \t    // Whitespace\n  \n  \t    else if (s == \"Whitespace\")\n  \t    {\n  \t\treturn unparseSeparator (YCPString (\" \\t\"));\n  \t    }\n  \n  \t    // Skip (is handled correctly within unparseTuple()\n  \n  \t    else if (s == \"Skip\")\n  \t    {\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // Fillup (is handled correctly within unparseTuple()\n  \n  \t    else if (s == \"Fillup\")\n  \t    {\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // String\n  \n  \t    else if (s == \"String\" && term->size () > 0)\n  \t    {\n  \t\tif (term->size () == 1)\n  \t\t    return unparseString (term->value (0), YCPNull (), value);\n  \t\tif (term->size () == 2)\n  \t\t    return unparseString (term->value (0), term->value (1),\n  \t\t\t\t\t  value);\n  \t    }\n  \n  \t    // Or\n  \n  \t    else if (s == \"Or\" && term->size () == 2)\n  \t    {\n  #if 1\n  \t\tconst YCPValue vbackup = value;\n  \t\tconst string vdata = unparseData (term->value (0), value);\n  \t\tif (vdata != \"\")\n  \t\t    return vdata;\n  \t\telse\n  \t\t    return unparseData (term->value (1), vbackup);\n  #endif\n  \t    }\n  \n  \t    // Number\n  \n  \t    else if (s == \"Number\")\n  \t    {\n  \t\treturn unparseNumber (value);\n  \t    }\n  \n  \t    // Boolean\n  \n  \t    else if (s == \"Boolean\")\n  \t    {\n  \t\treturn unparseBoolean (value);\n  \t    }\n  \n  \t    // Float\n  \n  \t    else if (s == \"Float\")\n  \t    {\n  \t\treturn unparseFloat (value);\n  \t    }\n  \n  \t    // Ip4Number\n  \n  \t    else if (s == \"Ip4Number\")\n  \t    {\n  \t\treturn unparseIp4Number (value);\n  \t    }\n  \n  \t    // Hostname\n  \n  \t    else if (s == \"Hostname\")\n  \t    {\n  \t\treturn unparseHostname (value);\n  \t    }\n  \n  \t    // Username\n  \n  \t    else if (s == \"Username\")\n  \t    {\n  \t\treturn unparseUsername (value);\n  \t    }\n  \n  \t    // <name> (<syntax>)\n  \n  \t    else if (islower (s[0]) && (term->size () == 1))\n  \t    {\n  \t\tif (!value->isMap ())\n  \t\t    y2error (\"request for element '%s' but value not map\",\n  \t\t\t     s.c_str ());\n  \t\telse\n  \t\t{\n  \t\t    YCPValue v = value->asMap ()->value (YCPString (s));\n  \t\t    if (v.isNull ())\n  \t\t    {\n  \t\t\ty2error (\"No value for key '%s' in map\", s.c_str ());\n  \t\t\treturn \"\";\n  \t\t    }\n  \t\t    return unparseData (term->value (0), v);\n  \t\t}\n  \t    }\n  \n  \t    else\n  \t    {\n  \t\ty2error (\"unparseData: unknown term '%s'\", s.c_str ());\n  \t\treturn \"\";\n  \t    }\n  \t} break;\n  \n  \tcase YT_STRING:\n  \t    y2debug (\"YT_STRING\");\n  \t    return unparseVerbose (syntax);\n  \t    break;\n  \n  \tdefault:\n  \t    y2error (\"unparseData: unknown syntax %s\", syntax->toString ().c_str ());\n  \t    break;\n      }\n  \n      return \"\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mHeader.isNull",
          "args": [],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::writeFile (const YCPValue & arg)\n  {\n      if (!mHeader.isNull ())\n  \tunparseData (mHeader, YCPNull ());\n      return \"\";\n  }\n}"
  },
  {
    "function_name": "readFile",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
    "lines": "652-759",
    "snippet": "YCPValue\nAnyAgent::readFile (const YCPValue & arg)\n{\n    struct stat buf;\n    FILE *fp;\n    string ss;\n\n    if (mName->isTerm ())\n    {\n\tss = evalArg (arg);\n\tif (ss.empty ())\n\t    return YCPNull ();\n    }\n    else\n    {\n\tss = mName->asString ()->value ();\n    }\n\n    if (mType == MTYPE_PROG)\n    {\n\tconst char *s = ss.c_str ();\n\ty2debug (\"readFile, run (%s)\", s);\n\n\t// always invalidate cache\n\tbuf.st_mtime = 0;\n\n\tconst char *original_locale = getenv (\"LC_ALL\");\n\tif (setenv (\"LC_ALL\", \"C\", 1) < 0)\n\t    y2error (\"Cannot reset locales;\");\n\n\tfp = popen (s, \"r\");\n\n\tif (original_locale)\n\t{\n\t    if (setenv (\"LC_ALL\", original_locale, 1) < 0)\n\t\ty2error (\"Cannot revert locales;\");\n\t}\n\telse\n\t{\n\t    unsetenv (\"LC_ALL\");\n\t}\n\n\tif (fp == 0)\n\t{\n\t    ycp2error (\"Can't run '%s': %d\", ss.c_str (), errno);\n\t    return YCPNull ();\n\t}\n    }\n    else\n    {\n\tconst char *s = ss.c_str ();\n\n\ty2debug (\"readFile, read (%s)\", s);\n\n\tif (stat (s, &buf) != 0)\n\t{\n\t    mtime = 0;\t// error case: reset mtime\n\t    if (errno == ENOENT)\n\t    {\n\t\tycp2error (\"File not found %s\", s);\n\t\treturn YCPList ();\n\t    }\n\n\t    ycp2error (\"Can't stat '%s' :%d\", s, errno);\n\t    return YCPNull ();\n\t}\n\n\tif (buf.st_mtime == mtime)\n\t    return alldata;\n\n\t// open file\n\n\tfp = fopen (s, \"r\");\n\n\tif (fp == 0)\n\t{\n\t    if (errno == EACCES)\n\t    {\n\t\tycp2error (\"Cant access %s\", s);\n\t\treturn YCPList ();\n\t    }\n\n\t    ycp2error ( \"Error opening '%s': %d\", s, errno);\n\t    return YCPNull ();\n\t}\n    }\n\n    // read complete file to alldata as YCPListRep (YCPStringRep)\n\n    YCPList data;\n\n    const char *line;\n    while ((line = get_line (fp)) != 0)\n    {\n\tdata->add (YCPString (line));\n    }\n\n    if (mType == MTYPE_PROG)\n\tpclose (fp);\n    else\n\tfclose (fp);\n\n    mtime = buf.st_mtime;\n    alldata = data;\n    achanged = false;\n\n    return alldata;\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "fp"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data->add",
          "args": [
            "YCPString (line)"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "line"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_line",
          "args": [
            "fp"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Error opening '%s': %d\"",
            "s",
            "errno"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPList",
          "args": [],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "commaList",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "254-265",
          "snippet": "string\nYCPListRep::commaList() const\n{\n    string ret;\n\n    for (unsigned index = 0; index < elements.size(); index++)\n    {\n\tif (index != 0) ret += \", \";\n\tret += elements[index].isNull() ? \"(null)\" : elements[index]->toString();\n    }\n    return ret;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  string\n  YCPListRep::commaList() const\n  {\n      string ret;\n  \n      for (unsigned index = 0; index < elements.size(); index++)\n      {\n  \tif (index != 0) ret += \", \";\n  \tret += elements[index].isNull() ? \"(null)\" : elements[index]->toString();\n      }\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Cant access %s\"",
            "s"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "s",
            "\"r\""
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Can't stat '%s' :%d\"",
            "s",
            "errno"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"File not found %s\"",
            "s"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "s",
            "&buf"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"readFile, read (%s)\"",
            "s"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss.c_str",
          "args": [],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Can't run '%s': %d\"",
            "ss.c_str ()",
            "errno"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss.c_str",
          "args": [],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsetenv",
          "args": [
            "\"LC_ALL\""
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Cannot revert locales;\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LC_ALL\"",
            "original_locale",
            "1"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "s",
            "\"r\""
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Cannot reset locales;\""
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LC_ALL\"",
            "\"C\"",
            "1"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LC_ALL\""
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"readFile, run (%s)\"",
            "s"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss.c_str",
          "args": [],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mName->asString",
          "args": [],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss.empty",
          "args": [],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "evalArg",
          "args": [
            "arg"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "evalArg",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
          "lines": "581-642",
          "snippet": "string\nAnyAgent::evalArg (const YCPValue & arg)\n{\n    if (arg.isNull () || !arg->isList ())\n    {\n\ty2error (\"bad argument for Read ()\");\n\treturn \"\";\n    }\n\n    string fullpath;\n    YCPTerm t = mName->asTerm ();\n    YCPList l = arg->asList ();\n\n    // construct filename in fullpath\n    // loop over Run() or File() argument list\n    // take `arg() from arg\n\n    for (int i = 0; i < t->size (); i++)\n    {\n\t// string constant\n\n\tif (t->value (i)->isString ())\n\t{\n\t    fullpath += t->value (i)->asString ()->value ();\n\t}\n\telse if (t->value (i)->isTerm ())\n\t{\n\t    // `arg(n), check n for correct type and match for current arg\n\n\t    YCPTerm ta = t->value (i)->asTerm ();\n\t    if (ta->name () == \"arg\"\n\t\t&& ta->size () == 1 && ta->value (0)->isInteger ())\n\t    {\n\t\tint ti = ta->value (0)->asInteger ()->value ();\n\t\tif ((ti < 0) && (ti >= l->size ()))\n\t\t{\n\t\t    y2error (\"Bad arg value %d for Read ()\", ti);\n\t\t    return \"\";\n\t\t}\n\t\tif (!l->value (ti)->isString ())\n\t\t{\n\t\t    y2error (\"Bad arg type for Read ()\");\n\t\t    return \"\";\n\t\t}\n\t\tfullpath += l->value (ti)->asString ()->value ();\n\t    }\n\t    else\n\t    {\n\t\ty2error (\"bad element in argument for Read (%s)\",\n\t\t\t t->value (i)->toString ().c_str ());\n\t\treturn \"\";\n\t    }\n\t}\n\telse\n\t{\n\t    y2error (\"bad element in argument for Read (%s)\",\n\t\t     t->value (i)->toString ().c_str ());\n\t    return \"\";\n\t}\n    }\n    return fullpath;\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  string\n  AnyAgent::evalArg (const YCPValue & arg)\n  {\n      if (arg.isNull () || !arg->isList ())\n      {\n  \ty2error (\"bad argument for Read ()\");\n  \treturn \"\";\n      }\n  \n      string fullpath;\n      YCPTerm t = mName->asTerm ();\n      YCPList l = arg->asList ();\n  \n      // construct filename in fullpath\n      // loop over Run() or File() argument list\n      // take `arg() from arg\n  \n      for (int i = 0; i < t->size (); i++)\n      {\n  \t// string constant\n  \n  \tif (t->value (i)->isString ())\n  \t{\n  \t    fullpath += t->value (i)->asString ()->value ();\n  \t}\n  \telse if (t->value (i)->isTerm ())\n  \t{\n  \t    // `arg(n), check n for correct type and match for current arg\n  \n  \t    YCPTerm ta = t->value (i)->asTerm ();\n  \t    if (ta->name () == \"arg\"\n  \t\t&& ta->size () == 1 && ta->value (0)->isInteger ())\n  \t    {\n  \t\tint ti = ta->value (0)->asInteger ()->value ();\n  \t\tif ((ti < 0) && (ti >= l->size ()))\n  \t\t{\n  \t\t    y2error (\"Bad arg value %d for Read ()\", ti);\n  \t\t    return \"\";\n  \t\t}\n  \t\tif (!l->value (ti)->isString ())\n  \t\t{\n  \t\t    y2error (\"Bad arg type for Read ()\");\n  \t\t    return \"\";\n  \t\t}\n  \t\tfullpath += l->value (ti)->asString ()->value ();\n  \t    }\n  \t    else\n  \t    {\n  \t\ty2error (\"bad element in argument for Read (%s)\",\n  \t\t\t t->value (i)->toString ().c_str ());\n  \t\treturn \"\";\n  \t    }\n  \t}\n  \telse\n  \t{\n  \t    y2error (\"bad element in argument for Read (%s)\",\n  \t\t     t->value (i)->toString ().c_str ());\n  \t    return \"\";\n  \t}\n      }\n      return fullpath;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mName->isTerm",
          "args": [],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "isTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "70-70",
          "snippet": "bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::readFile (const YCPValue & arg)\n  {\n      struct stat buf;\n      FILE *fp;\n      string ss;\n  \n      if (mName->isTerm ())\n      {\n  \tss = evalArg (arg);\n  \tif (ss.empty ())\n  \t    return YCPNull ();\n      }\n      else\n      {\n  \tss = mName->asString ()->value ();\n      }\n  \n      if (mType == MTYPE_PROG)\n      {\n  \tconst char *s = ss.c_str ();\n  \ty2debug (\"readFile, run (%s)\", s);\n  \n  \t// always invalidate cache\n  \tbuf.st_mtime = 0;\n  \n  \tconst char *original_locale = getenv (\"LC_ALL\");\n  \tif (setenv (\"LC_ALL\", \"C\", 1) < 0)\n  \t    y2error (\"Cannot reset locales;\");\n  \n  \tfp = popen (s, \"r\");\n  \n  \tif (original_locale)\n  \t{\n  \t    if (setenv (\"LC_ALL\", original_locale, 1) < 0)\n  \t\ty2error (\"Cannot revert locales;\");\n  \t}\n  \telse\n  \t{\n  \t    unsetenv (\"LC_ALL\");\n  \t}\n  \n  \tif (fp == 0)\n  \t{\n  \t    ycp2error (\"Can't run '%s': %d\", ss.c_str (), errno);\n  \t    return YCPNull ();\n  \t}\n      }\n      else\n      {\n  \tconst char *s = ss.c_str ();\n  \n  \ty2debug (\"readFile, read (%s)\", s);\n  \n  \tif (stat (s, &buf) != 0)\n  \t{\n  \t    mtime = 0;\t// error case: reset mtime\n  \t    if (errno == ENOENT)\n  \t    {\n  \t\tycp2error (\"File not found %s\", s);\n  \t\treturn YCPList ();\n  \t    }\n  \n  \t    ycp2error (\"Can't stat '%s' :%d\", s, errno);\n  \t    return YCPNull ();\n  \t}\n  \n  \tif (buf.st_mtime == mtime)\n  \t    return alldata;\n  \n  \t// open file\n  \n  \tfp = fopen (s, \"r\");\n  \n  \tif (fp == 0)\n  \t{\n  \t    if (errno == EACCES)\n  \t    {\n  \t\tycp2error (\"Cant access %s\", s);\n  \t\treturn YCPList ();\n  \t    }\n  \n  \t    ycp2error ( \"Error opening '%s': %d\", s, errno);\n  \t    return YCPNull ();\n  \t}\n      }\n  \n      // read complete file to alldata as YCPListRep (YCPStringRep)\n  \n      YCPList data;\n  \n      const char *line;\n      while ((line = get_line (fp)) != 0)\n      {\n  \tdata->add (YCPString (line));\n      }\n  \n      if (mType == MTYPE_PROG)\n  \tpclose (fp);\n      else\n  \tfclose (fp);\n  \n      mtime = buf.st_mtime;\n      alldata = data;\n      achanged = false;\n  \n      return alldata;\n  }\n}"
  },
  {
    "function_name": "evalArg",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
    "lines": "581-642",
    "snippet": "string\nAnyAgent::evalArg (const YCPValue & arg)\n{\n    if (arg.isNull () || !arg->isList ())\n    {\n\ty2error (\"bad argument for Read ()\");\n\treturn \"\";\n    }\n\n    string fullpath;\n    YCPTerm t = mName->asTerm ();\n    YCPList l = arg->asList ();\n\n    // construct filename in fullpath\n    // loop over Run() or File() argument list\n    // take `arg() from arg\n\n    for (int i = 0; i < t->size (); i++)\n    {\n\t// string constant\n\n\tif (t->value (i)->isString ())\n\t{\n\t    fullpath += t->value (i)->asString ()->value ();\n\t}\n\telse if (t->value (i)->isTerm ())\n\t{\n\t    // `arg(n), check n for correct type and match for current arg\n\n\t    YCPTerm ta = t->value (i)->asTerm ();\n\t    if (ta->name () == \"arg\"\n\t\t&& ta->size () == 1 && ta->value (0)->isInteger ())\n\t    {\n\t\tint ti = ta->value (0)->asInteger ()->value ();\n\t\tif ((ti < 0) && (ti >= l->size ()))\n\t\t{\n\t\t    y2error (\"Bad arg value %d for Read ()\", ti);\n\t\t    return \"\";\n\t\t}\n\t\tif (!l->value (ti)->isString ())\n\t\t{\n\t\t    y2error (\"Bad arg type for Read ()\");\n\t\t    return \"\";\n\t\t}\n\t\tfullpath += l->value (ti)->asString ()->value ();\n\t    }\n\t    else\n\t    {\n\t\ty2error (\"bad element in argument for Read (%s)\",\n\t\t\t t->value (i)->toString ().c_str ());\n\t\treturn \"\";\n\t    }\n\t}\n\telse\n\t{\n\t    y2error (\"bad element in argument for Read (%s)\",\n\t\t     t->value (i)->toString ().c_str ());\n\t    return \"\";\n\t}\n    }\n    return fullpath;\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"bad element in argument for Read (%s)\"",
            "t->value (i)->toString ().c_str ()"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->value",
          "args": [],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->value",
          "args": [
            "i"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YEList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "773-783",
          "snippet": "YCodePtr\nYEList::value (int index) const\n{\n    ycodelist_t *element = m_first;\n    while (element && index)\n    {\n\telement = element->next;\n\tindex--;\n    }\n    return element != NULL ? element->code : NULL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEList {\n  YCodePtr\n  YEList::value (int index) const\n  {\n      ycodelist_t *element = m_first;\n      while (element && index)\n      {\n  \telement = element->next;\n  \tindex--;\n      }\n      return element != NULL ? element->code : NULL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"bad element in argument for Read (%s)\"",
            "t->value (i)->toString ().c_str ()"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l->value",
          "args": [],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPBooleanRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "38-42",
          "snippet": "bool\nYCPBooleanRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBooleanRep {\n  bool\n  YCPBooleanRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "l->value",
          "args": [
            "ti"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad arg type for Read ()\""
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad arg value %d for Read ()\"",
            "ti"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l->size",
          "args": [],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPByteblockRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPByteblock.cc",
          "lines": "59-63",
          "snippet": "long\nYCPByteblockRep::size() const\n{\n    return len;\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPByteblock.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPByteblock.h\"\n#include <ycp/y2log.h>\n\nYCPByteblockRep {\n  long\n  YCPByteblockRep::size() const\n  {\n      return len;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ta->value",
          "args": [],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPBuiltinStatementRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinStatement.cc",
          "lines": "51-54",
          "snippet": "YCPValue YCPBuiltinStatementRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"YCPBuiltinStatement.h\"",
            "#include \"YCPBuiltin.h\"",
            "#include \"y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"YCPBuiltinStatement.h\"\n#include \"YCPBuiltin.h\"\n#include \"y2log.h\"\n\nYCPBuiltinStatementRep {\n  YCPValue YCPBuiltinStatementRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ta->size",
          "args": [],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ta->name",
          "args": [],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2AgentComp",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "44-44",
          "snippet": "string name () const { return my_name; }",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp {\n  string name () const { return my_name; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->size",
          "args": [],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "42-46",
          "snippet": "int\nYCPListRep::size() const\n{\n    return elements.size();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  int\n  YCPListRep::size() const\n  {\n      return elements.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg->asList",
          "args": [],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mName->asTerm",
          "args": [],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"bad argument for Read ()\""
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg->isList",
          "args": [],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  string\n  AnyAgent::evalArg (const YCPValue & arg)\n  {\n      if (arg.isNull () || !arg->isList ())\n      {\n  \ty2error (\"bad argument for Read ()\");\n  \treturn \"\";\n      }\n  \n      string fullpath;\n      YCPTerm t = mName->asTerm ();\n      YCPList l = arg->asList ();\n  \n      // construct filename in fullpath\n      // loop over Run() or File() argument list\n      // take `arg() from arg\n  \n      for (int i = 0; i < t->size (); i++)\n      {\n  \t// string constant\n  \n  \tif (t->value (i)->isString ())\n  \t{\n  \t    fullpath += t->value (i)->asString ()->value ();\n  \t}\n  \telse if (t->value (i)->isTerm ())\n  \t{\n  \t    // `arg(n), check n for correct type and match for current arg\n  \n  \t    YCPTerm ta = t->value (i)->asTerm ();\n  \t    if (ta->name () == \"arg\"\n  \t\t&& ta->size () == 1 && ta->value (0)->isInteger ())\n  \t    {\n  \t\tint ti = ta->value (0)->asInteger ()->value ();\n  \t\tif ((ti < 0) && (ti >= l->size ()))\n  \t\t{\n  \t\t    y2error (\"Bad arg value %d for Read ()\", ti);\n  \t\t    return \"\";\n  \t\t}\n  \t\tif (!l->value (ti)->isString ())\n  \t\t{\n  \t\t    y2error (\"Bad arg type for Read ()\");\n  \t\t    return \"\";\n  \t\t}\n  \t\tfullpath += l->value (ti)->asString ()->value ();\n  \t    }\n  \t    else\n  \t    {\n  \t\ty2error (\"bad element in argument for Read (%s)\",\n  \t\t\t t->value (i)->toString ().c_str ());\n  \t\treturn \"\";\n  \t    }\n  \t}\n  \telse\n  \t{\n  \t    y2error (\"bad element in argument for Read (%s)\",\n  \t\t     t->value (i)->toString ().c_str ());\n  \t    return \"\";\n  \t}\n      }\n      return fullpath;\n  }\n}"
  },
  {
    "function_name": "validateCache",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
    "lines": "538-578",
    "snippet": "YCPValue\nAnyAgent::validateCache (const YCPList & data, const YCPValue & arg)\n{\n    y2debug (\"validateCache (%s)\", !data.isNull () ? data->toString ().c_str () : \"<nil>\");\n\n    if (data.isNull ())\n    {\t\t\t\t// check for read\n\tYCPValue filedata = readFile (arg);\n\tif (filedata.isNull () || !filedata->isList ())\n\t    return filedata;\n\talldata = filedata->asList ();\n    }\n    else\n    {\t\t\t\t// check for write\n\tif (!cchanged)\n\t    return cache;\n\talldata = data;\n    }\n\n    if (alldata.isNull ())\n    {\n\tycp2error (\"validateCache oops alldata failed\");\n\treturn YCPBoolean (false);\n    }\n\n    cchanged = true;\n\n    // now parse file according to mComment/isFillup and mSyntax\n\n    line_number = -1;\t\t// initialize\n    const char *line = \"\";\n    YCPValue value = parseData (line, mSyntax, false);\n\n    if (!value.isNull ())\n    {\n\tcache = value;\n\tcchanged = false;\n    }\n\n    return value;\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseData",
          "args": [
            "line",
            "mSyntax",
            "false"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "parseData",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "429-705",
          "snippet": "YCPValue\nAnyAgent::parseData (char const *&line, const YCPValue & syntax, bool optional)\n{\n    if ((line == 0) || (*line == 0))\n\tline = getLine ();\n    if (line == 0)\n\treturn YCPNull ();\n    if (syntax.isNull ())\n\treturn YCPNull ();\n\n    y2debug (\"parseData %s('%s',[%s])\", (optional ? \"?\" : \"!\"), line,\n\t     syntax->toString ().c_str ());\n\n    switch (syntax->valuetype ())\n    {\n\tcase YT_TERM: {\n\n\t    YCPTerm term = syntax->asTerm ();\n\t    const string s = term->name ();\n\t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n\n\t    // Optional\n\n\t    if (s == \"Optional\" && term->size () > 0)\n\t    {\n\t\tYCPValue ov = parseData (line, term->value (0), true);\n\t\tif (ov.isNull ())\n\t\t    ov = YCPVoid ();\n\t\treturn ov;\n\t    }\n\n\t    // Continue\n\n\t    else if (s == \"Continue\" && term->size () > 0)\n\t    {\n\t\tYCPValue tv = parseData (line, term->value (0), false);\n\t\tif (!tv.isNull ())\n\t\t    tupleContinue = true;\n\t\treturn tv;\n\t    }\n\n\t    // Choice\n\n\t    else if (s == \"Choice\" && term->size () > 0)\n\t    {\n\t\treturn parseChoice (line, term->args (), optional);\n\t    }\n\n\t    // Sequence\n\n\t    else if (s == \"Sequence\" && term->size () > 0)\n\t    {\n\t\treturn parseSequence (line, term->args (), optional);\n\t    }\n\n\t    // List\n\n\t    else if (s == \"List\" && term->size () == 2)\n\t    {\n\t\treturn parseList (line, term->args (), optional);\n\t    }\n\n\t    // Tuple\n\n\t    else if (s == \"Tuple\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tYCPValue tv = parseTuple (line, term->args (), optional);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn tv;\n\t    }\n\n\t    // Var\n\n\t    else if (s == \"Var\" && term->size () > 0)\n\t    {\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    if (parseData (line, term->value (i), optional).isNull ())\n\t\t\tbreak;\n\t\t}\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Name\n\n\t    else if (s == \"Name\" && term->size () == 1)\n\t    {\n\t\tif (!mReadOnly)\n\t\t{\n\t\t    y2error (\"'Name' not allowed for writable agents\");\n\t\t    return YCPNull ();\n\t\t}\n\t\tYCPValue tn = parseData (line, term->value (0), false);\n\t\tif (!tn.isNull () && tupleName.size () > 0)\n\t\t{\n\t\t    if (tn->isString ())\n\t\t\ttupleName.top () = tn->asString ()->value ();\n\t\t    else\n\t\t\ttupleName.top () = tn->toString ();\n\t\t    y2debug (\"Name: %s\", tn->toString ().c_str ());\n\t\t}\n\t\treturn tn;\n\t    }\n\n\t    // Value\n\n\t    else if (s == \"Value\" && term->size () == 1)\n\t    {\n\t\tYCPValue tv = parseData (line, term->value (0), false);\n\t\tif (!tv.isNull () && tupleValue.size () > 0)\n\t\t    tupleValue.top () = tv;\n\t\t// y2debug (\"Value: %p\", tv);\n\t\treturn tv;\n\t    }\n\n\t    // Fillup\n\n\t    else if (isFillup && (s == \"Fillup\") &&\t// fillup allowed and Fillup () found\n\t\t     (term->size () == 0) && (tupleName.size () > 0))\n\t    {\t\t// inside Tuple ()\n\t\tstring fillup;\n\t\twhile ((line != 0)\n\t\t       && (mComment.find_first_of (line[0]) != string::npos))\n\t\t{\n\t\t    fillup = fillup + line;\n\t\t    line = getLine ();\n\t\t}\n\t\ttupleName.top () = KEY4FILLUP;\n\t\ttupleValue.top () = YCPString (fillup);\n\t\treturn tupleValue.top ();\n\t    }\n\n\t    // Skip\n\n\t    else if (s == \"Skip\")\n\t    {\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Match\n\n\t    else if (s == \"Match\")\n\t    {\n\t\treturn currentMatch;\n\t    }\n\n\t    // Separator\n\n\t    else if (s == \"Separator\" && term->size () == 1)\n\t    {\n\t\treturn parseSeparator (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t       optional);\n\t    }\n\n\t    // Whitespace\n\n\t    else if (s == \"Whitespace\")\n\t    {\n\t\treturn parseSeparator (line, \" \\t\", optional);\n\t    }\n\n\t    // String\n\n\t    else if (s == \"String\" && term->size () > 0)\n\t    {\n\t\tif (term->size () == 1)\n\t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t\t0, optional);\n\t\tif (term->size () == 2)\n\t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t\tterm->value (1)->asString ()->value ().c_str (),\n\t\t\t\t\toptional);\n\t    }\n\n\t    // Or\n\n\t    else if (s == \"Or\" && term->size () > 0)\n\t    {\n\t\tconst char *ltry = line;\n\t\tbool lopt = false;\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    if (i == term->size () - 1)\t// pass optional on last try\n\t\t\tlopt = optional;\n\t\t    YCPValue vtry = parseData (ltry, term->value (i), lopt);\n\t\t    if (!vtry.isNull ())\n\t\t    {\n\t\t\ty2debug (\"Or () success\");\n\t\t\tline = ltry;\n\t\t\treturn vtry;\n\t\t    }\n\t\t}\n\t\ty2debug (\"Or () failed\");\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Number\n\n\t    else if (s == \"Number\")\n\t    {\n\t\treturn parseNumber (line, optional);\n\t    }\n\n\t    // Hexval\n\n\t    else if (s == \"Hexval\")\n\t    {\n\t\treturn parseHexval (line, optional);\n\t    }\n\n\t    // Boolean\n\n\t    else if (s == \"Boolean\")\n\t    {\n\t\treturn parseBoolean (line, optional);\n\t    }\n\n\t    // Float\n\n\t    else if (s == \"Float\")\n\t    {\n\t\treturn parseFloat (line, optional);\n\t    }\n\n\t    // Ip4Number\n\n\t    else if (s == \"Ip4Number\")\n\t    {\n\t\treturn parseIp4Number (line, optional);\n\t    }\n\n\t    // Hostname\n\n\t    else if (s == \"Hostname\")\n\t    {\n\t\treturn parseHostname (line, optional);\n\t    }\n\n\t    // Username\n\n\t    else if (s == \"Username\")\n\t    {\n\t\treturn parseUsername (line, optional);\n\t    }\n\n\t    // <name>\n\n\t    else if (islower (s[0]) && tupleName.size () > 0 && (term->size () == 1))\n\t    {\n\t\ttupleName.top () = s;\n\t\ttupleValue.top () = parseData (line, term->value (0), optional);\n\t\treturn tupleValue.top ();\n\t    }\n\n\t    else\n\t    {\n\t\ty2error (\"parseData: unknown term '%s'\", s.c_str ());\n\t\treturn YCPVoid ();\n\t    }\n\t} break;\n\n\tcase YT_STRING:\n\t    y2debug (\"YT_STRING\");\n\t    return parseVerbose (line, syntax->asString ()->value ().c_str (),\n\t\t\t\t optional);\n\t    break;\n\n\tdefault:\n\t    y2error (\"parseData: unknown syntax %s\", syntax->toString ().c_str ());\n\t    break;\n    }\n\n    return YCPNull ();\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define KEY4FILLUP \"`FILLUP\""
          ],
          "globals_used": [
            "static YCPValue currentMatch = YCPNull ();"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define KEY4FILLUP \"`FILLUP\"\n\nstatic YCPValue currentMatch = YCPNull ();\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseData (char const *&line, const YCPValue & syntax, bool optional)\n  {\n      if ((line == 0) || (*line == 0))\n  \tline = getLine ();\n      if (line == 0)\n  \treturn YCPNull ();\n      if (syntax.isNull ())\n  \treturn YCPNull ();\n  \n      y2debug (\"parseData %s('%s',[%s])\", (optional ? \"?\" : \"!\"), line,\n  \t     syntax->toString ().c_str ());\n  \n      switch (syntax->valuetype ())\n      {\n  \tcase YT_TERM: {\n  \n  \t    YCPTerm term = syntax->asTerm ();\n  \t    const string s = term->name ();\n  \t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n  \n  \t    // Optional\n  \n  \t    if (s == \"Optional\" && term->size () > 0)\n  \t    {\n  \t\tYCPValue ov = parseData (line, term->value (0), true);\n  \t\tif (ov.isNull ())\n  \t\t    ov = YCPVoid ();\n  \t\treturn ov;\n  \t    }\n  \n  \t    // Continue\n  \n  \t    else if (s == \"Continue\" && term->size () > 0)\n  \t    {\n  \t\tYCPValue tv = parseData (line, term->value (0), false);\n  \t\tif (!tv.isNull ())\n  \t\t    tupleContinue = true;\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Choice\n  \n  \t    else if (s == \"Choice\" && term->size () > 0)\n  \t    {\n  \t\treturn parseChoice (line, term->args (), optional);\n  \t    }\n  \n  \t    // Sequence\n  \n  \t    else if (s == \"Sequence\" && term->size () > 0)\n  \t    {\n  \t\treturn parseSequence (line, term->args (), optional);\n  \t    }\n  \n  \t    // List\n  \n  \t    else if (s == \"List\" && term->size () == 2)\n  \t    {\n  \t\treturn parseList (line, term->args (), optional);\n  \t    }\n  \n  \t    // Tuple\n  \n  \t    else if (s == \"Tuple\" && term->size () > 0)\n  \t    {\n  \t\ttupleName.push (\"\");\n  \t\ttupleValue.push (YCPNull ());\n  \t\tYCPValue tv = parseTuple (line, term->args (), optional);\n  \t\ttupleName.pop ();\n  \t\ttupleValue.pop ();\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Var\n  \n  \t    else if (s == \"Var\" && term->size () > 0)\n  \t    {\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    if (parseData (line, term->value (i), optional).isNull ())\n  \t\t\tbreak;\n  \t\t}\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Name\n  \n  \t    else if (s == \"Name\" && term->size () == 1)\n  \t    {\n  \t\tif (!mReadOnly)\n  \t\t{\n  \t\t    y2error (\"'Name' not allowed for writable agents\");\n  \t\t    return YCPNull ();\n  \t\t}\n  \t\tYCPValue tn = parseData (line, term->value (0), false);\n  \t\tif (!tn.isNull () && tupleName.size () > 0)\n  \t\t{\n  \t\t    if (tn->isString ())\n  \t\t\ttupleName.top () = tn->asString ()->value ();\n  \t\t    else\n  \t\t\ttupleName.top () = tn->toString ();\n  \t\t    y2debug (\"Name: %s\", tn->toString ().c_str ());\n  \t\t}\n  \t\treturn tn;\n  \t    }\n  \n  \t    // Value\n  \n  \t    else if (s == \"Value\" && term->size () == 1)\n  \t    {\n  \t\tYCPValue tv = parseData (line, term->value (0), false);\n  \t\tif (!tv.isNull () && tupleValue.size () > 0)\n  \t\t    tupleValue.top () = tv;\n  \t\t// y2debug (\"Value: %p\", tv);\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Fillup\n  \n  \t    else if (isFillup && (s == \"Fillup\") &&\t// fillup allowed and Fillup () found\n  \t\t     (term->size () == 0) && (tupleName.size () > 0))\n  \t    {\t\t// inside Tuple ()\n  \t\tstring fillup;\n  \t\twhile ((line != 0)\n  \t\t       && (mComment.find_first_of (line[0]) != string::npos))\n  \t\t{\n  \t\t    fillup = fillup + line;\n  \t\t    line = getLine ();\n  \t\t}\n  \t\ttupleName.top () = KEY4FILLUP;\n  \t\ttupleValue.top () = YCPString (fillup);\n  \t\treturn tupleValue.top ();\n  \t    }\n  \n  \t    // Skip\n  \n  \t    else if (s == \"Skip\")\n  \t    {\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Match\n  \n  \t    else if (s == \"Match\")\n  \t    {\n  \t\treturn currentMatch;\n  \t    }\n  \n  \t    // Separator\n  \n  \t    else if (s == \"Separator\" && term->size () == 1)\n  \t    {\n  \t\treturn parseSeparator (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t       optional);\n  \t    }\n  \n  \t    // Whitespace\n  \n  \t    else if (s == \"Whitespace\")\n  \t    {\n  \t\treturn parseSeparator (line, \" \\t\", optional);\n  \t    }\n  \n  \t    // String\n  \n  \t    else if (s == \"String\" && term->size () > 0)\n  \t    {\n  \t\tif (term->size () == 1)\n  \t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t\t0, optional);\n  \t\tif (term->size () == 2)\n  \t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t\tterm->value (1)->asString ()->value ().c_str (),\n  \t\t\t\t\toptional);\n  \t    }\n  \n  \t    // Or\n  \n  \t    else if (s == \"Or\" && term->size () > 0)\n  \t    {\n  \t\tconst char *ltry = line;\n  \t\tbool lopt = false;\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    if (i == term->size () - 1)\t// pass optional on last try\n  \t\t\tlopt = optional;\n  \t\t    YCPValue vtry = parseData (ltry, term->value (i), lopt);\n  \t\t    if (!vtry.isNull ())\n  \t\t    {\n  \t\t\ty2debug (\"Or () success\");\n  \t\t\tline = ltry;\n  \t\t\treturn vtry;\n  \t\t    }\n  \t\t}\n  \t\ty2debug (\"Or () failed\");\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Number\n  \n  \t    else if (s == \"Number\")\n  \t    {\n  \t\treturn parseNumber (line, optional);\n  \t    }\n  \n  \t    // Hexval\n  \n  \t    else if (s == \"Hexval\")\n  \t    {\n  \t\treturn parseHexval (line, optional);\n  \t    }\n  \n  \t    // Boolean\n  \n  \t    else if (s == \"Boolean\")\n  \t    {\n  \t\treturn parseBoolean (line, optional);\n  \t    }\n  \n  \t    // Float\n  \n  \t    else if (s == \"Float\")\n  \t    {\n  \t\treturn parseFloat (line, optional);\n  \t    }\n  \n  \t    // Ip4Number\n  \n  \t    else if (s == \"Ip4Number\")\n  \t    {\n  \t\treturn parseIp4Number (line, optional);\n  \t    }\n  \n  \t    // Hostname\n  \n  \t    else if (s == \"Hostname\")\n  \t    {\n  \t\treturn parseHostname (line, optional);\n  \t    }\n  \n  \t    // Username\n  \n  \t    else if (s == \"Username\")\n  \t    {\n  \t\treturn parseUsername (line, optional);\n  \t    }\n  \n  \t    // <name>\n  \n  \t    else if (islower (s[0]) && tupleName.size () > 0 && (term->size () == 1))\n  \t    {\n  \t\ttupleName.top () = s;\n  \t\ttupleValue.top () = parseData (line, term->value (0), optional);\n  \t\treturn tupleValue.top ();\n  \t    }\n  \n  \t    else\n  \t    {\n  \t\ty2error (\"parseData: unknown term '%s'\", s.c_str ());\n  \t\treturn YCPVoid ();\n  \t    }\n  \t} break;\n  \n  \tcase YT_STRING:\n  \t    y2debug (\"YT_STRING\");\n  \t    return parseVerbose (line, syntax->asString ()->value ().c_str (),\n  \t\t\t\t optional);\n  \t    break;\n  \n  \tdefault:\n  \t    y2error (\"parseData: unknown syntax %s\", syntax->toString ().c_str ());\n  \t    break;\n      }\n  \n      return YCPNull ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "false"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"validateCache oops alldata failed\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alldata.isNull",
          "args": [],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filedata->asList",
          "args": [],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "filedata->isList",
          "args": [],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "filedata.isNull",
          "args": [],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readFile",
          "args": [
            "arg"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "readFile",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
          "lines": "652-759",
          "snippet": "YCPValue\nAnyAgent::readFile (const YCPValue & arg)\n{\n    struct stat buf;\n    FILE *fp;\n    string ss;\n\n    if (mName->isTerm ())\n    {\n\tss = evalArg (arg);\n\tif (ss.empty ())\n\t    return YCPNull ();\n    }\n    else\n    {\n\tss = mName->asString ()->value ();\n    }\n\n    if (mType == MTYPE_PROG)\n    {\n\tconst char *s = ss.c_str ();\n\ty2debug (\"readFile, run (%s)\", s);\n\n\t// always invalidate cache\n\tbuf.st_mtime = 0;\n\n\tconst char *original_locale = getenv (\"LC_ALL\");\n\tif (setenv (\"LC_ALL\", \"C\", 1) < 0)\n\t    y2error (\"Cannot reset locales;\");\n\n\tfp = popen (s, \"r\");\n\n\tif (original_locale)\n\t{\n\t    if (setenv (\"LC_ALL\", original_locale, 1) < 0)\n\t\ty2error (\"Cannot revert locales;\");\n\t}\n\telse\n\t{\n\t    unsetenv (\"LC_ALL\");\n\t}\n\n\tif (fp == 0)\n\t{\n\t    ycp2error (\"Can't run '%s': %d\", ss.c_str (), errno);\n\t    return YCPNull ();\n\t}\n    }\n    else\n    {\n\tconst char *s = ss.c_str ();\n\n\ty2debug (\"readFile, read (%s)\", s);\n\n\tif (stat (s, &buf) != 0)\n\t{\n\t    mtime = 0;\t// error case: reset mtime\n\t    if (errno == ENOENT)\n\t    {\n\t\tycp2error (\"File not found %s\", s);\n\t\treturn YCPList ();\n\t    }\n\n\t    ycp2error (\"Can't stat '%s' :%d\", s, errno);\n\t    return YCPNull ();\n\t}\n\n\tif (buf.st_mtime == mtime)\n\t    return alldata;\n\n\t// open file\n\n\tfp = fopen (s, \"r\");\n\n\tif (fp == 0)\n\t{\n\t    if (errno == EACCES)\n\t    {\n\t\tycp2error (\"Cant access %s\", s);\n\t\treturn YCPList ();\n\t    }\n\n\t    ycp2error ( \"Error opening '%s': %d\", s, errno);\n\t    return YCPNull ();\n\t}\n    }\n\n    // read complete file to alldata as YCPListRep (YCPStringRep)\n\n    YCPList data;\n\n    const char *line;\n    while ((line = get_line (fp)) != 0)\n    {\n\tdata->add (YCPString (line));\n    }\n\n    if (mType == MTYPE_PROG)\n\tpclose (fp);\n    else\n\tfclose (fp);\n\n    mtime = buf.st_mtime;\n    alldata = data;\n    achanged = false;\n\n    return alldata;\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::readFile (const YCPValue & arg)\n  {\n      struct stat buf;\n      FILE *fp;\n      string ss;\n  \n      if (mName->isTerm ())\n      {\n  \tss = evalArg (arg);\n  \tif (ss.empty ())\n  \t    return YCPNull ();\n      }\n      else\n      {\n  \tss = mName->asString ()->value ();\n      }\n  \n      if (mType == MTYPE_PROG)\n      {\n  \tconst char *s = ss.c_str ();\n  \ty2debug (\"readFile, run (%s)\", s);\n  \n  \t// always invalidate cache\n  \tbuf.st_mtime = 0;\n  \n  \tconst char *original_locale = getenv (\"LC_ALL\");\n  \tif (setenv (\"LC_ALL\", \"C\", 1) < 0)\n  \t    y2error (\"Cannot reset locales;\");\n  \n  \tfp = popen (s, \"r\");\n  \n  \tif (original_locale)\n  \t{\n  \t    if (setenv (\"LC_ALL\", original_locale, 1) < 0)\n  \t\ty2error (\"Cannot revert locales;\");\n  \t}\n  \telse\n  \t{\n  \t    unsetenv (\"LC_ALL\");\n  \t}\n  \n  \tif (fp == 0)\n  \t{\n  \t    ycp2error (\"Can't run '%s': %d\", ss.c_str (), errno);\n  \t    return YCPNull ();\n  \t}\n      }\n      else\n      {\n  \tconst char *s = ss.c_str ();\n  \n  \ty2debug (\"readFile, read (%s)\", s);\n  \n  \tif (stat (s, &buf) != 0)\n  \t{\n  \t    mtime = 0;\t// error case: reset mtime\n  \t    if (errno == ENOENT)\n  \t    {\n  \t\tycp2error (\"File not found %s\", s);\n  \t\treturn YCPList ();\n  \t    }\n  \n  \t    ycp2error (\"Can't stat '%s' :%d\", s, errno);\n  \t    return YCPNull ();\n  \t}\n  \n  \tif (buf.st_mtime == mtime)\n  \t    return alldata;\n  \n  \t// open file\n  \n  \tfp = fopen (s, \"r\");\n  \n  \tif (fp == 0)\n  \t{\n  \t    if (errno == EACCES)\n  \t    {\n  \t\tycp2error (\"Cant access %s\", s);\n  \t\treturn YCPList ();\n  \t    }\n  \n  \t    ycp2error ( \"Error opening '%s': %d\", s, errno);\n  \t    return YCPNull ();\n  \t}\n      }\n  \n      // read complete file to alldata as YCPListRep (YCPStringRep)\n  \n      YCPList data;\n  \n      const char *line;\n      while ((line = get_line (fp)) != 0)\n      {\n  \tdata->add (YCPString (line));\n      }\n  \n      if (mType == MTYPE_PROG)\n  \tpclose (fp);\n      else\n  \tfclose (fp);\n  \n      mtime = buf.st_mtime;\n      alldata = data;\n      achanged = false;\n  \n      return alldata;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.isNull",
          "args": [],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"validateCache (%s)\"",
            "!data.isNull () ? data->toString ().c_str () : \"<nil>\""
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data->toString",
          "args": [],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.isNull",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::validateCache (const YCPList & data, const YCPValue & arg)\n  {\n      y2debug (\"validateCache (%s)\", !data.isNull () ? data->toString ().c_str () : \"<nil>\");\n  \n      if (data.isNull ())\n      {\t\t\t\t// check for read\n  \tYCPValue filedata = readFile (arg);\n  \tif (filedata.isNull () || !filedata->isList ())\n  \t    return filedata;\n  \talldata = filedata->asList ();\n      }\n      else\n      {\t\t\t\t// check for write\n  \tif (!cchanged)\n  \t    return cache;\n  \talldata = data;\n      }\n  \n      if (alldata.isNull ())\n      {\n  \tycp2error (\"validateCache oops alldata failed\");\n  \treturn YCPBoolean (false);\n      }\n  \n      cchanged = true;\n  \n      // now parse file according to mComment/isFillup and mSyntax\n  \n      line_number = -1;\t\t// initialize\n      const char *line = \"\";\n      YCPValue value = parseData (line, mSyntax, false);\n  \n      if (!value.isNull ())\n      {\n  \tcache = value;\n  \tcchanged = false;\n      }\n  \n      return value;\n  }\n}"
  },
  {
    "function_name": "Dir",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
    "lines": "497-509",
    "snippet": "YCPList\nAnyAgent::Dir (const YCPPath & path)\n{\n    if (!description_read)\n    {\n\tycp2error (\"Can't execute Dir prior to reading Description.\");\n\treturn YCPNull ();\n    }\n\n    YCPList l;\n    l->add (mSyntax);\n    return l;\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "l->add",
          "args": [
            "mSyntax"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Can't execute Dir prior to reading Description.\""
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPList\n  AnyAgent::Dir (const YCPPath & path)\n  {\n      if (!description_read)\n      {\n  \tycp2error (\"Can't execute Dir prior to reading Description.\");\n  \treturn YCPNull ();\n      }\n  \n      YCPList l;\n      l->add (mSyntax);\n      return l;\n  }\n}"
  },
  {
    "function_name": "Write",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
    "lines": "336-487",
    "snippet": "YCPBoolean\nAnyAgent::Write (const YCPPath & path, const YCPValue & value,\n\t\t const YCPValue & arg)\n{\n    if (!description_read)\n    {\n\tycp2error(\"Can't execute Write prior to reading Description.\");\n\treturn YCPBoolean (false);\n    }\n\n    y2debug (\"Write (%s:%s)\", path->toString ().c_str (),\n\t     value->toString ().c_str ());\n\n    if (mReadOnly)\n    {\n\tycp2error (\"Write (%s) is read-only\", path->toString ().c_str ());\n\treturn YCPBoolean (false);\n    }\n\n    // fill cache, can't be program here\n\n    // check path\n\n    if (!path->isRoot ())\n    {\n\tint len = path->length ();\n\n\t// ._   -> write raw data completely\n\t//\n\n\tif (path->component_str (0) == \"_\")\n\t{\n\t    if ((len == 1) && (value->isList ()))\n\t    {\n\t\ty2debug (\"Write: replace _\");\n\t\tYCPValue vc_result = validateCache (value->asList ());\n\t\tif (vc_result.isNull ())\n\t\t    return YCPBoolean (false);\n\n\t\treturn YCPBoolean (true);\n\t    }\n\n\t    // ._.<num> -> write line <num> of raw data\n\t    //\n\n\t    if ((len == 2) && isdigit (path->component_str (1)[0]))\n\t    {\n\t\tif (!value->isString ())\n\t\t{\n\t\t    ycp2error ( \"Bad value %s for path\", path->toString ().c_str ());\n\t\t    return YCPBoolean (false);\n\t\t}\n\n\t\tYCPList newdata;\n\n\t\tint num = atoi (path->component_str (1).c_str ());\n\t\ty2debug (\"Write: write line %d\", num);\n\t\tif (num < 0)\n\t\t    return YCPBoolean (false);\n\n\t\tif (num == alldata->size ())\n\t\t{\n\t\t    y2debug (\"Write: extending data\");\n\t\t    for (int i = 0; i < alldata->size (); i++)\n\t\t\tnewdata->add (alldata->value (i));\n\t\t    newdata->add (value);\n\t\t}\n\t\telse\n\t\t{\n\t\t    y2debug (\"Write: replace line %d\", num);\n\n\t\t    // replace by copying\n\n\t\t    for (int i = 0; i < alldata->size (); i++)\n\t\t    {\n\t\t\tif (i == num)\n\t\t\t    newdata->add (value);\n\t\t\telse\n\t\t\t    newdata->add (alldata->value (i));\n\t\t    }\n\t\t}\n\n\t\tYCPValue vc_result = validateCache (newdata);\n\t\tif (vc_result.isNull ())\n\t\t    return YCPBoolean (false);\n\n\t\treturn YCPBoolean (true);\n\t    }\n\n\t    ycp2error (\"Bad write path %s\", path->toString ().c_str());\n\t    return YCPBoolean (false);\n\t}\n\n\t// path not root and not ._\n\t//\n\n    }\n\n    YCPValue syntax = findSyntax (mSyntax, path);\n\n    if (syntax.isNull ())\n    {\n\tycp2error (\"No syntax for path %s\", path->toString ().c_str ());\n\treturn YCPBoolean (false);\n    }\n\n    // convert value to string\n\n    const string s = unparseData (syntax, value);\n\n    if (s.empty ())\n    {\n\tycp2error (\"Wrong value for path %s\", path->toString ().c_str ());\n\treturn YCPBoolean (false);\n    }\n\n    // place value into cache, write string ...\n\n    y2debug (\"Write[%s]\", s.c_str ());\n    {\n\tstring sfname;\n\tconst char *fname;\n\n\tif (mName->isTerm ())\n\t{\n\t    sfname = evalArg (arg);\n\t    if (sfname.empty ())\n\t\treturn YCPBoolean (false);\n\t}\n\telse\n\t{\n\t    sfname = mName->asString ()->value ();\n\t}\n\n\tfname = sfname.c_str ();\n\n\ty2debug (\" to %s\", fname);\n\n\tstd::ofstream dummy_file (fname);\n\tif (!dummy_file)\n\t{\n\t    ycp2error (\"Can't open path %s\", sfname.c_str ());\n\t    return YCPBoolean (false);\n\t}\n\n\tdummy_file << s.c_str () << std::endl;\n\n\t// destructor closes file\n    }\n\n    return YCPBoolean (true);\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "true"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.c_str",
          "args": [],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Can't open path %s\"",
            "sfname.c_str ()"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sfname.c_str",
          "args": [],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\" to %s\"",
            "fname"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sfname.c_str",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mName->asString",
          "args": [],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sfname.empty",
          "args": [],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "evalArg",
          "args": [
            "arg"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "evalArg",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
          "lines": "581-642",
          "snippet": "string\nAnyAgent::evalArg (const YCPValue & arg)\n{\n    if (arg.isNull () || !arg->isList ())\n    {\n\ty2error (\"bad argument for Read ()\");\n\treturn \"\";\n    }\n\n    string fullpath;\n    YCPTerm t = mName->asTerm ();\n    YCPList l = arg->asList ();\n\n    // construct filename in fullpath\n    // loop over Run() or File() argument list\n    // take `arg() from arg\n\n    for (int i = 0; i < t->size (); i++)\n    {\n\t// string constant\n\n\tif (t->value (i)->isString ())\n\t{\n\t    fullpath += t->value (i)->asString ()->value ();\n\t}\n\telse if (t->value (i)->isTerm ())\n\t{\n\t    // `arg(n), check n for correct type and match for current arg\n\n\t    YCPTerm ta = t->value (i)->asTerm ();\n\t    if (ta->name () == \"arg\"\n\t\t&& ta->size () == 1 && ta->value (0)->isInteger ())\n\t    {\n\t\tint ti = ta->value (0)->asInteger ()->value ();\n\t\tif ((ti < 0) && (ti >= l->size ()))\n\t\t{\n\t\t    y2error (\"Bad arg value %d for Read ()\", ti);\n\t\t    return \"\";\n\t\t}\n\t\tif (!l->value (ti)->isString ())\n\t\t{\n\t\t    y2error (\"Bad arg type for Read ()\");\n\t\t    return \"\";\n\t\t}\n\t\tfullpath += l->value (ti)->asString ()->value ();\n\t    }\n\t    else\n\t    {\n\t\ty2error (\"bad element in argument for Read (%s)\",\n\t\t\t t->value (i)->toString ().c_str ());\n\t\treturn \"\";\n\t    }\n\t}\n\telse\n\t{\n\t    y2error (\"bad element in argument for Read (%s)\",\n\t\t     t->value (i)->toString ().c_str ());\n\t    return \"\";\n\t}\n    }\n    return fullpath;\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  string\n  AnyAgent::evalArg (const YCPValue & arg)\n  {\n      if (arg.isNull () || !arg->isList ())\n      {\n  \ty2error (\"bad argument for Read ()\");\n  \treturn \"\";\n      }\n  \n      string fullpath;\n      YCPTerm t = mName->asTerm ();\n      YCPList l = arg->asList ();\n  \n      // construct filename in fullpath\n      // loop over Run() or File() argument list\n      // take `arg() from arg\n  \n      for (int i = 0; i < t->size (); i++)\n      {\n  \t// string constant\n  \n  \tif (t->value (i)->isString ())\n  \t{\n  \t    fullpath += t->value (i)->asString ()->value ();\n  \t}\n  \telse if (t->value (i)->isTerm ())\n  \t{\n  \t    // `arg(n), check n for correct type and match for current arg\n  \n  \t    YCPTerm ta = t->value (i)->asTerm ();\n  \t    if (ta->name () == \"arg\"\n  \t\t&& ta->size () == 1 && ta->value (0)->isInteger ())\n  \t    {\n  \t\tint ti = ta->value (0)->asInteger ()->value ();\n  \t\tif ((ti < 0) && (ti >= l->size ()))\n  \t\t{\n  \t\t    y2error (\"Bad arg value %d for Read ()\", ti);\n  \t\t    return \"\";\n  \t\t}\n  \t\tif (!l->value (ti)->isString ())\n  \t\t{\n  \t\t    y2error (\"Bad arg type for Read ()\");\n  \t\t    return \"\";\n  \t\t}\n  \t\tfullpath += l->value (ti)->asString ()->value ();\n  \t    }\n  \t    else\n  \t    {\n  \t\ty2error (\"bad element in argument for Read (%s)\",\n  \t\t\t t->value (i)->toString ().c_str ());\n  \t\treturn \"\";\n  \t    }\n  \t}\n  \telse\n  \t{\n  \t    y2error (\"bad element in argument for Read (%s)\",\n  \t\t     t->value (i)->toString ().c_str ());\n  \t    return \"\";\n  \t}\n      }\n      return fullpath;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mName->isTerm",
          "args": [],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "isTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "70-70",
          "snippet": "bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Write[%s]\"",
            "s.c_str ()"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.c_str",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Wrong value for path %s\"",
            "path->toString ().c_str ()"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->toString",
          "args": [],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unparseData",
          "args": [
            "syntax",
            "value"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "unparseData",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "713-952",
          "snippet": "const string\nAnyAgent::unparseData (const YCPValue & syntax, const YCPValue & value)\n{\n    if (syntax.isNull ())\n\treturn \"\";\n\n    y2debug (\"unparseData ('%s',%s)\", value.isNull () ? \"\" : value->toString ().c_str (),\n\t     syntax->toString ().c_str ());\n\n    switch (syntax->valuetype ())\n    {\n\tcase YT_TERM: {\n\n\t    YCPTerm term = syntax->asTerm ();\n\t    if (term.isNull ())\n\t    {\n\t\ty2error (\"YT_TERM no term\");\n\t    }\n\t    string s = term->name ();\n\t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n\n\t    // Optional\n\n\t    if (s == \"Optional\" && term->size () > 0)\n\t    {\n\t\treturn unparseData (term->value (0), value);\n\t    }\n\n\t    // Continue\n\n\t    else if (s == \"Continue\" && term->size () > 0)\n\t    {\n\t\tif (tupleContinue)\n\t\t    return unparseData (term->value (0), value);\n\t    }\n\n\t    // Choice\n\n\t    else if (s == \"Choice\" && term->size () > 0)\n\t    {\n\t\treturn unparseChoice (term->args (), value);\n\t    }\n\n\t    // Sequence\n\n\t    else if (s == \"Sequence\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tconst string s = unparseSequence (term->args (), value);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn s;\n\t    }\n\n\t    // List\n\n\t    else if (s == \"List\" && term->size () == 2)\n\t    {\n\t\treturn unparseList (term->args (), value);\n\t    }\n\n\t    // Tuple\n\n\t    else if (s == \"Tuple\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tconst string s = unparseTuple (term->args (), value);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn s;\n\t    }\n\n\t    // Var\n\n\t    else if (s == \"Var\" && term->size () > 0)\n\t    {\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    const string vdata = unparseData (term->value (i), value);\n\t\t    if (vdata.empty ())\n\t\t\tbreak;\n\t\t}\n\t\treturn \"\";\n\t    }\n\n\t    // Name\n\n\t    else if (s == \"Name\" && term->size () == 1)\n\t    {\n\t\ty2error (\"unparse Name ()\");\n\t\treturn \"\";\n\t    }\n\n\t    // Value\n\n\t    else if (s == \"Value\" && term->size () == 1)\n\t    {\n\t\tconst string s = unparseData (term->value (0), value);\n#if 0\n\t\tif (tv && tupleValue.size () > 0)\n\t\t    tupleValue.top () = tv;\n#endif\n\t\treturn s;\n\t    }\n\n\t    // Separator\n\n\t    else if (s == \"Separator\" && term->size () == 1)\n\t    {\n\t\treturn unparseSeparator (term->value (0));\n\t    }\n\n\t    // Whitespace\n\n\t    else if (s == \"Whitespace\")\n\t    {\n\t\treturn unparseSeparator (YCPString (\" \\t\"));\n\t    }\n\n\t    // Skip (is handled correctly within unparseTuple()\n\n\t    else if (s == \"Skip\")\n\t    {\n\t\treturn \"\";\n\t    }\n\n\t    // Fillup (is handled correctly within unparseTuple()\n\n\t    else if (s == \"Fillup\")\n\t    {\n\t\treturn \"\";\n\t    }\n\n\t    // String\n\n\t    else if (s == \"String\" && term->size () > 0)\n\t    {\n\t\tif (term->size () == 1)\n\t\t    return unparseString (term->value (0), YCPNull (), value);\n\t\tif (term->size () == 2)\n\t\t    return unparseString (term->value (0), term->value (1),\n\t\t\t\t\t  value);\n\t    }\n\n\t    // Or\n\n\t    else if (s == \"Or\" && term->size () == 2)\n\t    {\n#if 1\n\t\tconst YCPValue vbackup = value;\n\t\tconst string vdata = unparseData (term->value (0), value);\n\t\tif (vdata != \"\")\n\t\t    return vdata;\n\t\telse\n\t\t    return unparseData (term->value (1), vbackup);\n#endif\n\t    }\n\n\t    // Number\n\n\t    else if (s == \"Number\")\n\t    {\n\t\treturn unparseNumber (value);\n\t    }\n\n\t    // Boolean\n\n\t    else if (s == \"Boolean\")\n\t    {\n\t\treturn unparseBoolean (value);\n\t    }\n\n\t    // Float\n\n\t    else if (s == \"Float\")\n\t    {\n\t\treturn unparseFloat (value);\n\t    }\n\n\t    // Ip4Number\n\n\t    else if (s == \"Ip4Number\")\n\t    {\n\t\treturn unparseIp4Number (value);\n\t    }\n\n\t    // Hostname\n\n\t    else if (s == \"Hostname\")\n\t    {\n\t\treturn unparseHostname (value);\n\t    }\n\n\t    // Username\n\n\t    else if (s == \"Username\")\n\t    {\n\t\treturn unparseUsername (value);\n\t    }\n\n\t    // <name> (<syntax>)\n\n\t    else if (islower (s[0]) && (term->size () == 1))\n\t    {\n\t\tif (!value->isMap ())\n\t\t    y2error (\"request for element '%s' but value not map\",\n\t\t\t     s.c_str ());\n\t\telse\n\t\t{\n\t\t    YCPValue v = value->asMap ()->value (YCPString (s));\n\t\t    if (v.isNull ())\n\t\t    {\n\t\t\ty2error (\"No value for key '%s' in map\", s.c_str ());\n\t\t\treturn \"\";\n\t\t    }\n\t\t    return unparseData (term->value (0), v);\n\t\t}\n\t    }\n\n\t    else\n\t    {\n\t\ty2error (\"unparseData: unknown term '%s'\", s.c_str ());\n\t\treturn \"\";\n\t    }\n\t} break;\n\n\tcase YT_STRING:\n\t    y2debug (\"YT_STRING\");\n\t    return unparseVerbose (syntax);\n\t    break;\n\n\tdefault:\n\t    y2error (\"unparseData: unknown syntax %s\", syntax->toString ().c_str ());\n\t    break;\n    }\n\n    return \"\";\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseData (const YCPValue & syntax, const YCPValue & value)\n  {\n      if (syntax.isNull ())\n  \treturn \"\";\n  \n      y2debug (\"unparseData ('%s',%s)\", value.isNull () ? \"\" : value->toString ().c_str (),\n  \t     syntax->toString ().c_str ());\n  \n      switch (syntax->valuetype ())\n      {\n  \tcase YT_TERM: {\n  \n  \t    YCPTerm term = syntax->asTerm ();\n  \t    if (term.isNull ())\n  \t    {\n  \t\ty2error (\"YT_TERM no term\");\n  \t    }\n  \t    string s = term->name ();\n  \t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n  \n  \t    // Optional\n  \n  \t    if (s == \"Optional\" && term->size () > 0)\n  \t    {\n  \t\treturn unparseData (term->value (0), value);\n  \t    }\n  \n  \t    // Continue\n  \n  \t    else if (s == \"Continue\" && term->size () > 0)\n  \t    {\n  \t\tif (tupleContinue)\n  \t\t    return unparseData (term->value (0), value);\n  \t    }\n  \n  \t    // Choice\n  \n  \t    else if (s == \"Choice\" && term->size () > 0)\n  \t    {\n  \t\treturn unparseChoice (term->args (), value);\n  \t    }\n  \n  \t    // Sequence\n  \n  \t    else if (s == \"Sequence\" && term->size () > 0)\n  \t    {\n  \t\ttupleName.push (\"\");\n  \t\ttupleValue.push (YCPNull ());\n  \t\tconst string s = unparseSequence (term->args (), value);\n  \t\ttupleName.pop ();\n  \t\ttupleValue.pop ();\n  \t\treturn s;\n  \t    }\n  \n  \t    // List\n  \n  \t    else if (s == \"List\" && term->size () == 2)\n  \t    {\n  \t\treturn unparseList (term->args (), value);\n  \t    }\n  \n  \t    // Tuple\n  \n  \t    else if (s == \"Tuple\" && term->size () > 0)\n  \t    {\n  \t\ttupleName.push (\"\");\n  \t\ttupleValue.push (YCPNull ());\n  \t\tconst string s = unparseTuple (term->args (), value);\n  \t\ttupleName.pop ();\n  \t\ttupleValue.pop ();\n  \t\treturn s;\n  \t    }\n  \n  \t    // Var\n  \n  \t    else if (s == \"Var\" && term->size () > 0)\n  \t    {\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    const string vdata = unparseData (term->value (i), value);\n  \t\t    if (vdata.empty ())\n  \t\t\tbreak;\n  \t\t}\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // Name\n  \n  \t    else if (s == \"Name\" && term->size () == 1)\n  \t    {\n  \t\ty2error (\"unparse Name ()\");\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // Value\n  \n  \t    else if (s == \"Value\" && term->size () == 1)\n  \t    {\n  \t\tconst string s = unparseData (term->value (0), value);\n  #if 0\n  \t\tif (tv && tupleValue.size () > 0)\n  \t\t    tupleValue.top () = tv;\n  #endif\n  \t\treturn s;\n  \t    }\n  \n  \t    // Separator\n  \n  \t    else if (s == \"Separator\" && term->size () == 1)\n  \t    {\n  \t\treturn unparseSeparator (term->value (0));\n  \t    }\n  \n  \t    // Whitespace\n  \n  \t    else if (s == \"Whitespace\")\n  \t    {\n  \t\treturn unparseSeparator (YCPString (\" \\t\"));\n  \t    }\n  \n  \t    // Skip (is handled correctly within unparseTuple()\n  \n  \t    else if (s == \"Skip\")\n  \t    {\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // Fillup (is handled correctly within unparseTuple()\n  \n  \t    else if (s == \"Fillup\")\n  \t    {\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // String\n  \n  \t    else if (s == \"String\" && term->size () > 0)\n  \t    {\n  \t\tif (term->size () == 1)\n  \t\t    return unparseString (term->value (0), YCPNull (), value);\n  \t\tif (term->size () == 2)\n  \t\t    return unparseString (term->value (0), term->value (1),\n  \t\t\t\t\t  value);\n  \t    }\n  \n  \t    // Or\n  \n  \t    else if (s == \"Or\" && term->size () == 2)\n  \t    {\n  #if 1\n  \t\tconst YCPValue vbackup = value;\n  \t\tconst string vdata = unparseData (term->value (0), value);\n  \t\tif (vdata != \"\")\n  \t\t    return vdata;\n  \t\telse\n  \t\t    return unparseData (term->value (1), vbackup);\n  #endif\n  \t    }\n  \n  \t    // Number\n  \n  \t    else if (s == \"Number\")\n  \t    {\n  \t\treturn unparseNumber (value);\n  \t    }\n  \n  \t    // Boolean\n  \n  \t    else if (s == \"Boolean\")\n  \t    {\n  \t\treturn unparseBoolean (value);\n  \t    }\n  \n  \t    // Float\n  \n  \t    else if (s == \"Float\")\n  \t    {\n  \t\treturn unparseFloat (value);\n  \t    }\n  \n  \t    // Ip4Number\n  \n  \t    else if (s == \"Ip4Number\")\n  \t    {\n  \t\treturn unparseIp4Number (value);\n  \t    }\n  \n  \t    // Hostname\n  \n  \t    else if (s == \"Hostname\")\n  \t    {\n  \t\treturn unparseHostname (value);\n  \t    }\n  \n  \t    // Username\n  \n  \t    else if (s == \"Username\")\n  \t    {\n  \t\treturn unparseUsername (value);\n  \t    }\n  \n  \t    // <name> (<syntax>)\n  \n  \t    else if (islower (s[0]) && (term->size () == 1))\n  \t    {\n  \t\tif (!value->isMap ())\n  \t\t    y2error (\"request for element '%s' but value not map\",\n  \t\t\t     s.c_str ());\n  \t\telse\n  \t\t{\n  \t\t    YCPValue v = value->asMap ()->value (YCPString (s));\n  \t\t    if (v.isNull ())\n  \t\t    {\n  \t\t\ty2error (\"No value for key '%s' in map\", s.c_str ());\n  \t\t\treturn \"\";\n  \t\t    }\n  \t\t    return unparseData (term->value (0), v);\n  \t\t}\n  \t    }\n  \n  \t    else\n  \t    {\n  \t\ty2error (\"unparseData: unknown term '%s'\", s.c_str ());\n  \t\treturn \"\";\n  \t    }\n  \t} break;\n  \n  \tcase YT_STRING:\n  \t    y2debug (\"YT_STRING\");\n  \t    return unparseVerbose (syntax);\n  \t    break;\n  \n  \tdefault:\n  \t    y2error (\"unparseData: unknown syntax %s\", syntax->toString ().c_str ());\n  \t    break;\n      }\n  \n      return \"\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"No syntax for path %s\"",
            "path->toString ().c_str ()"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syntax.isNull",
          "args": [],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findSyntax",
          "args": [
            "mSyntax",
            "path"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "findSyntax",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
          "lines": "929-1030",
          "snippet": "YCPValue\nAnyAgent::findSyntax (const YCPValue & syntax, const YCPPath & path)\n{\n    y2debug (\"findSyntax ('%s':'%s')\", syntax->toString ().c_str (),\n\t     path->toString ().c_str ());\n\n    YCPValue cur_syntax = syntax;\n\n    const int len = path->length ();\n    if (len > 0)\n    {\n\tfor (int i = 0; i < len; i++)\n\t{\n\t    const string p = path->component_str (i);\n\n\t    if (cur_syntax.isNull ())\n\t\tbreak;\n\n\t    switch (cur_syntax->valuetype ())\n\t    {\n\t\tcase YT_TERM: {\n\t\t    YCPTerm t = cur_syntax->asTerm ();\n\t\t    string s = t->name ();\n\n\t\t    // `tuple_name (<cur_syntax>)\n\n\t\t    if (s == p && t->size () > 0)\n\t\t    {\n\t\t\tcur_syntax = t->value (0);\n\t\t    }\n\n\t\t    else if (s == \"Tuple\" && t->size () > 0)\n\t\t    {\n\t\t\tif (isdigit (p[0]))\n\t\t\t{\n\t\t\t    int tnum = atoi (p.c_str ());\n\t\t\t    for (int j = 0; j < t->size (); j++)\n\t\t\t    {\n\t\t\t\tYCPValue v = t->value (j);\n\t\t\t\tif (v->isTerm ())\n\t\t\t\t{\n\t\t\t\t    YCPTerm vt = v->asTerm ();\n\t\t\t\t    if (islower (vt->name ()[0]) &&\n\t\t\t\t\t(vt->size () > 0))\n\t\t\t\t    {\n\t\t\t\t\tif (tnum == 0)\n\t\t\t\t\t{\n\t\t\t\t\t    cur_syntax = vt->value (0);\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t\ttnum--;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    for (int j = 0; j < t->size (); j++)\n\t\t\t    {\n\t\t\t\tYCPValue v = t->value (j);\n\t\t\t\tif (v->isTerm ())\n\t\t\t\t{\n\t\t\t\t    YCPTerm vt = v->asTerm ();\n\t\t\t\t    if (p == vt->name () && vt->size () > 0)\n\t\t\t\t    {\n\t\t\t\t\tcur_syntax = vt->value (0);\n\t\t\t\t\tbreak;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\n\t\t    else if (s == \"List\" && t->size () > 0 && isdigit (p[0]))\n\t\t    {\n\t\t\tcur_syntax = t->value (0);\n\t\t    }\n\n\t\t    else\n\t\t    {\n\t\t\ty2error (\"Can't find syntax for path '%s' in '%s'\",\n\t\t\t\t p.c_str (), cur_syntax->toString ().c_str ());\n\t\t\tcur_syntax = YCPNull ();\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\tcase YT_STRING:\n\t\t    break;\n\n\t\tdefault:\n\t\t    cur_syntax = YCPNull ();\n\t\t    break;\n\t    }\n\t}\n    }\n\n    y2debug (\"found syntax (%s)\", !cur_syntax.isNull () ?\n\t     cur_syntax->toString ().c_str () : \"<nil>\");\n\n    return cur_syntax;\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::findSyntax (const YCPValue & syntax, const YCPPath & path)\n  {\n      y2debug (\"findSyntax ('%s':'%s')\", syntax->toString ().c_str (),\n  \t     path->toString ().c_str ());\n  \n      YCPValue cur_syntax = syntax;\n  \n      const int len = path->length ();\n      if (len > 0)\n      {\n  \tfor (int i = 0; i < len; i++)\n  \t{\n  \t    const string p = path->component_str (i);\n  \n  \t    if (cur_syntax.isNull ())\n  \t\tbreak;\n  \n  \t    switch (cur_syntax->valuetype ())\n  \t    {\n  \t\tcase YT_TERM: {\n  \t\t    YCPTerm t = cur_syntax->asTerm ();\n  \t\t    string s = t->name ();\n  \n  \t\t    // `tuple_name (<cur_syntax>)\n  \n  \t\t    if (s == p && t->size () > 0)\n  \t\t    {\n  \t\t\tcur_syntax = t->value (0);\n  \t\t    }\n  \n  \t\t    else if (s == \"Tuple\" && t->size () > 0)\n  \t\t    {\n  \t\t\tif (isdigit (p[0]))\n  \t\t\t{\n  \t\t\t    int tnum = atoi (p.c_str ());\n  \t\t\t    for (int j = 0; j < t->size (); j++)\n  \t\t\t    {\n  \t\t\t\tYCPValue v = t->value (j);\n  \t\t\t\tif (v->isTerm ())\n  \t\t\t\t{\n  \t\t\t\t    YCPTerm vt = v->asTerm ();\n  \t\t\t\t    if (islower (vt->name ()[0]) &&\n  \t\t\t\t\t(vt->size () > 0))\n  \t\t\t\t    {\n  \t\t\t\t\tif (tnum == 0)\n  \t\t\t\t\t{\n  \t\t\t\t\t    cur_syntax = vt->value (0);\n  \t\t\t\t\t    break;\n  \t\t\t\t\t}\n  \t\t\t\t\ttnum--;\n  \t\t\t\t    }\n  \t\t\t\t}\n  \t\t\t    }\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t    for (int j = 0; j < t->size (); j++)\n  \t\t\t    {\n  \t\t\t\tYCPValue v = t->value (j);\n  \t\t\t\tif (v->isTerm ())\n  \t\t\t\t{\n  \t\t\t\t    YCPTerm vt = v->asTerm ();\n  \t\t\t\t    if (p == vt->name () && vt->size () > 0)\n  \t\t\t\t    {\n  \t\t\t\t\tcur_syntax = vt->value (0);\n  \t\t\t\t\tbreak;\n  \t\t\t\t    }\n  \t\t\t\t}\n  \t\t\t    }\n  \t\t\t}\n  \t\t    }\n  \n  \t\t    else if (s == \"List\" && t->size () > 0 && isdigit (p[0]))\n  \t\t    {\n  \t\t\tcur_syntax = t->value (0);\n  \t\t    }\n  \n  \t\t    else\n  \t\t    {\n  \t\t\ty2error (\"Can't find syntax for path '%s' in '%s'\",\n  \t\t\t\t p.c_str (), cur_syntax->toString ().c_str ());\n  \t\t\tcur_syntax = YCPNull ();\n  \t\t    }\n  \t\t}\n  \t\tbreak;\n  \n  \t\tcase YT_STRING:\n  \t\t    break;\n  \n  \t\tdefault:\n  \t\t    cur_syntax = YCPNull ();\n  \t\t    break;\n  \t    }\n  \t}\n      }\n  \n      y2debug (\"found syntax (%s)\", !cur_syntax.isNull () ?\n  \t     cur_syntax->toString ().c_str () : \"<nil>\");\n  \n      return cur_syntax;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad write path %s\"",
            "path->toString ().c_str()"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vc_result.isNull",
          "args": [],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validateCache",
          "args": [
            "newdata"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newdata->add",
          "args": [
            "alldata->value (i)"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "alldata->value",
          "args": [
            "i"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "alldata->size",
          "args": [],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Write: replace line %d\"",
            "num"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Write: extending data\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Write: write line %d\"",
            "num"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "path->component_str (1).c_str ()"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [
            "1"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "component_str",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "161-165",
          "snippet": "string\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  string\n  YCPPathRep::component_str(long index) const\n  {\n      return components[index].component.asString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad value %s for path\"",
            "path->toString ().c_str ()"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->isString",
          "args": [],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "path->component_str (1)[0]"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vc_result.isNull",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validateCache",
          "args": [
            "value->asList ()"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->asList",
          "args": [],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Write: replace _\""
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->isList",
          "args": [],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "path->length",
          "args": [],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "path->isRoot",
          "args": [],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "isRoot",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "83-87",
          "snippet": "bool\nYCPPathRep::isRoot() const\n{\n    return components.empty();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  bool\n  YCPPathRep::isRoot() const\n  {\n      return components.empty();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Write (%s) is read-only\"",
            "path->toString ().c_str ()"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Write (%s:%s)\"",
            "path->toString ().c_str ()",
            "value->toString ().c_str ()"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Can't execute Write prior to reading Description.\""
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPBoolean\n  AnyAgent::Write (const YCPPath & path, const YCPValue & value,\n  \t\t const YCPValue & arg)\n  {\n      if (!description_read)\n      {\n  \tycp2error(\"Can't execute Write prior to reading Description.\");\n  \treturn YCPBoolean (false);\n      }\n  \n      y2debug (\"Write (%s:%s)\", path->toString ().c_str (),\n  \t     value->toString ().c_str ());\n  \n      if (mReadOnly)\n      {\n  \tycp2error (\"Write (%s) is read-only\", path->toString ().c_str ());\n  \treturn YCPBoolean (false);\n      }\n  \n      // fill cache, can't be program here\n  \n      // check path\n  \n      if (!path->isRoot ())\n      {\n  \tint len = path->length ();\n  \n  \t// ._   -> write raw data completely\n  \t//\n  \n  \tif (path->component_str (0) == \"_\")\n  \t{\n  \t    if ((len == 1) && (value->isList ()))\n  \t    {\n  \t\ty2debug (\"Write: replace _\");\n  \t\tYCPValue vc_result = validateCache (value->asList ());\n  \t\tif (vc_result.isNull ())\n  \t\t    return YCPBoolean (false);\n  \n  \t\treturn YCPBoolean (true);\n  \t    }\n  \n  \t    // ._.<num> -> write line <num> of raw data\n  \t    //\n  \n  \t    if ((len == 2) && isdigit (path->component_str (1)[0]))\n  \t    {\n  \t\tif (!value->isString ())\n  \t\t{\n  \t\t    ycp2error ( \"Bad value %s for path\", path->toString ().c_str ());\n  \t\t    return YCPBoolean (false);\n  \t\t}\n  \n  \t\tYCPList newdata;\n  \n  \t\tint num = atoi (path->component_str (1).c_str ());\n  \t\ty2debug (\"Write: write line %d\", num);\n  \t\tif (num < 0)\n  \t\t    return YCPBoolean (false);\n  \n  \t\tif (num == alldata->size ())\n  \t\t{\n  \t\t    y2debug (\"Write: extending data\");\n  \t\t    for (int i = 0; i < alldata->size (); i++)\n  \t\t\tnewdata->add (alldata->value (i));\n  \t\t    newdata->add (value);\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t    y2debug (\"Write: replace line %d\", num);\n  \n  \t\t    // replace by copying\n  \n  \t\t    for (int i = 0; i < alldata->size (); i++)\n  \t\t    {\n  \t\t\tif (i == num)\n  \t\t\t    newdata->add (value);\n  \t\t\telse\n  \t\t\t    newdata->add (alldata->value (i));\n  \t\t    }\n  \t\t}\n  \n  \t\tYCPValue vc_result = validateCache (newdata);\n  \t\tif (vc_result.isNull ())\n  \t\t    return YCPBoolean (false);\n  \n  \t\treturn YCPBoolean (true);\n  \t    }\n  \n  \t    ycp2error (\"Bad write path %s\", path->toString ().c_str());\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \t// path not root and not ._\n  \t//\n  \n      }\n  \n      YCPValue syntax = findSyntax (mSyntax, path);\n  \n      if (syntax.isNull ())\n      {\n  \tycp2error (\"No syntax for path %s\", path->toString ().c_str ());\n  \treturn YCPBoolean (false);\n      }\n  \n      // convert value to string\n  \n      const string s = unparseData (syntax, value);\n  \n      if (s.empty ())\n      {\n  \tycp2error (\"Wrong value for path %s\", path->toString ().c_str ());\n  \treturn YCPBoolean (false);\n      }\n  \n      // place value into cache, write string ...\n  \n      y2debug (\"Write[%s]\", s.c_str ());\n      {\n  \tstring sfname;\n  \tconst char *fname;\n  \n  \tif (mName->isTerm ())\n  \t{\n  \t    sfname = evalArg (arg);\n  \t    if (sfname.empty ())\n  \t\treturn YCPBoolean (false);\n  \t}\n  \telse\n  \t{\n  \t    sfname = mName->asString ()->value ();\n  \t}\n  \n  \tfname = sfname.c_str ();\n  \n  \ty2debug (\" to %s\", fname);\n  \n  \tstd::ofstream dummy_file (fname);\n  \tif (!dummy_file)\n  \t{\n  \t    ycp2error (\"Can't open path %s\", sfname.c_str ());\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tdummy_file << s.c_str () << std::endl;\n  \n  \t// destructor closes file\n      }\n  \n      return YCPBoolean (true);\n  }\n}"
  },
  {
    "function_name": "Read",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
    "lines": "258-314",
    "snippet": "YCPValue\nAnyAgent::Read (const YCPPath & path, const YCPValue& arg, const YCPValue& optarg)\n{\n    if (!description_read)\n    {\n\tycp2error (\"Can't execute Read prior to reading Description.\");\n\treturn YCPVoid ();\n    }\n\n    y2debug (\"Read (%s: %s, %s, %s)\", path->toString ().c_str (),\n\t     mName->toString ().c_str (), mSyntax->toString ().c_str (),\n\t     isFillup ? \"Fillup\" : mComment.c_str ());\n\n    YCPValue value = validateCache (YCPNull (), arg);\n\n    if (value.isNull ())\n    {\n\tycp2error (\"Read validate failed\");\n\treturn YCPNull ();\n    }\n\n    if (!path->isRoot ())\n    {\n\tint len = path->length ();\n\tif (path->component_str (0) == \"_\")\n\t{\n\n\t    // ._ -> return raw data completely\n\t    //\n\n\t    if (len == 1)\n\t\treturn alldata;\n\n\t    // ._.<num> -> return line <num> of raw data\n\t    //\n\n\t    if ((len == 2) && isdigit (path->component_str (1)[0]))\n\t    {\n\t\tint num = atoi (path->component_str (1).c_str ());\n\t\tif ((num < 0) || (num > alldata->size ()))\n\t\t{\n\t\t    y2error (\"Bad index %d for ._.<num>\", num);\n\t\t    return YCPVoid ();\n\t\t}\n\t\treturn alldata->value (num);\n\t    }\n\t}\n\telse\n\t{\n\t    return readValueByPath (value, path);\n\t}\n\n\treturn YCPVoid ();\n    }\n\n    return value;\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readValueByPath",
          "args": [
            "value",
            "path"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "readValueByPath",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
          "lines": "788-843",
          "snippet": "YCPValue\nAnyAgent::readValueByPath (const YCPValue & value, const YCPPath & path)\n{\n    YCPValue sub_value = value;\n    for (int i = 0; i < path->length (); i++)\n    {\n\tconst char *s = path->component_str (i).c_str ();\n\n\t// .<num> -> return entry <num> of cached list data\n\t//\n\n\tif (isdigit ((unsigned char) s[0]))\n\t{\n\t    int num = atoi (s);\n\n\t    if (sub_value->isList ())\n\t    {\n\t\tif ((num < 0) || (num > sub_value->asList ()->size ()))\n\t\t{\n\t\t    y2error (\"Bad index %d for ._.<num>\", num);\n\t\t    return YCPVoid ();\n\t\t}\n\t\tsub_value = sub_value->asList ()->value (num);\n\t    }\n\t    else if (sub_value->isMap ())\n\t    {\n\t\tYCPValue v = sub_value->asMap ()->value (YCPString (s));\n\t\tif (v.isNull ())\n\t\t{\n\t\t    y2error (\"Bad index %s for ._.<num>\", s);\n\t\t    return YCPVoid ();\n\t\t}\n\t\telse\n\t\t    sub_value = v;\n\t    }\n\t}\n\n\t// .<name> -> return entry <name> of cached map data\n\t//\n\n\telse if (sub_value->isMap ())\n\t{\n\t    sub_value = sub_value->asMap ()->value (YCPString (s));\n\t}\n\n\telse\n\t{\n\t    y2error (\"Read path element '%s' does not match value %s\",\n\t\t     s, sub_value->toString ().c_str ());\n\t    sub_value = YCPVoid ();\n\t    break;\n\t}\n    }\n\n    return sub_value;\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::readValueByPath (const YCPValue & value, const YCPPath & path)\n  {\n      YCPValue sub_value = value;\n      for (int i = 0; i < path->length (); i++)\n      {\n  \tconst char *s = path->component_str (i).c_str ();\n  \n  \t// .<num> -> return entry <num> of cached list data\n  \t//\n  \n  \tif (isdigit ((unsigned char) s[0]))\n  \t{\n  \t    int num = atoi (s);\n  \n  \t    if (sub_value->isList ())\n  \t    {\n  \t\tif ((num < 0) || (num > sub_value->asList ()->size ()))\n  \t\t{\n  \t\t    y2error (\"Bad index %d for ._.<num>\", num);\n  \t\t    return YCPVoid ();\n  \t\t}\n  \t\tsub_value = sub_value->asList ()->value (num);\n  \t    }\n  \t    else if (sub_value->isMap ())\n  \t    {\n  \t\tYCPValue v = sub_value->asMap ()->value (YCPString (s));\n  \t\tif (v.isNull ())\n  \t\t{\n  \t\t    y2error (\"Bad index %s for ._.<num>\", s);\n  \t\t    return YCPVoid ();\n  \t\t}\n  \t\telse\n  \t\t    sub_value = v;\n  \t    }\n  \t}\n  \n  \t// .<name> -> return entry <name> of cached map data\n  \t//\n  \n  \telse if (sub_value->isMap ())\n  \t{\n  \t    sub_value = sub_value->asMap ()->value (YCPString (s));\n  \t}\n  \n  \telse\n  \t{\n  \t    y2error (\"Read path element '%s' does not match value %s\",\n  \t\t     s, sub_value->toString ().c_str ());\n  \t    sub_value = YCPVoid ();\n  \t    break;\n  \t}\n      }\n  \n      return sub_value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "alldata->value",
          "args": [
            "num"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad index %d for ._.<num>\"",
            "num"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alldata->size",
          "args": [],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "path->component_str (1).c_str ()"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [
            "1"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "component_str",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "161-165",
          "snippet": "string\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  string\n  YCPPathRep::component_str(long index) const\n  {\n      return components[index].component.asString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "path->component_str (1)[0]"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->length",
          "args": [],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "path->isRoot",
          "args": [],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "isRoot",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "83-87",
          "snippet": "bool\nYCPPathRep::isRoot() const\n{\n    return components.empty();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  bool\n  YCPPathRep::isRoot() const\n  {\n      return components.empty();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Read validate failed\""
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validateCache",
          "args": [
            "YCPNull ()",
            "arg"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "validateCache",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
          "lines": "538-578",
          "snippet": "YCPValue\nAnyAgent::validateCache (const YCPList & data, const YCPValue & arg)\n{\n    y2debug (\"validateCache (%s)\", !data.isNull () ? data->toString ().c_str () : \"<nil>\");\n\n    if (data.isNull ())\n    {\t\t\t\t// check for read\n\tYCPValue filedata = readFile (arg);\n\tif (filedata.isNull () || !filedata->isList ())\n\t    return filedata;\n\talldata = filedata->asList ();\n    }\n    else\n    {\t\t\t\t// check for write\n\tif (!cchanged)\n\t    return cache;\n\talldata = data;\n    }\n\n    if (alldata.isNull ())\n    {\n\tycp2error (\"validateCache oops alldata failed\");\n\treturn YCPBoolean (false);\n    }\n\n    cchanged = true;\n\n    // now parse file according to mComment/isFillup and mSyntax\n\n    line_number = -1;\t\t// initialize\n    const char *line = \"\";\n    YCPValue value = parseData (line, mSyntax, false);\n\n    if (!value.isNull ())\n    {\n\tcache = value;\n\tcchanged = false;\n    }\n\n    return value;\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::validateCache (const YCPList & data, const YCPValue & arg)\n  {\n      y2debug (\"validateCache (%s)\", !data.isNull () ? data->toString ().c_str () : \"<nil>\");\n  \n      if (data.isNull ())\n      {\t\t\t\t// check for read\n  \tYCPValue filedata = readFile (arg);\n  \tif (filedata.isNull () || !filedata->isList ())\n  \t    return filedata;\n  \talldata = filedata->asList ();\n      }\n      else\n      {\t\t\t\t// check for write\n  \tif (!cchanged)\n  \t    return cache;\n  \talldata = data;\n      }\n  \n      if (alldata.isNull ())\n      {\n  \tycp2error (\"validateCache oops alldata failed\");\n  \treturn YCPBoolean (false);\n      }\n  \n      cchanged = true;\n  \n      // now parse file according to mComment/isFillup and mSyntax\n  \n      line_number = -1;\t\t// initialize\n      const char *line = \"\";\n      YCPValue value = parseData (line, mSyntax, false);\n  \n      if (!value.isNull ())\n      {\n  \tcache = value;\n  \tcchanged = false;\n      }\n  \n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Read (%s: %s, %s, %s)\"",
            "path->toString ().c_str ()",
            "mName->toString ().c_str ()",
            "mSyntax->toString ().c_str ()",
            "isFillup ? \"Fillup\" : mComment.c_str ()"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mComment.c_str",
          "args": [],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mSyntax->toString",
          "args": [],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Can't execute Read prior to reading Description.\""
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::Read (const YCPPath & path, const YCPValue& arg, const YCPValue& optarg)\n  {\n      if (!description_read)\n      {\n  \tycp2error (\"Can't execute Read prior to reading Description.\");\n  \treturn YCPVoid ();\n      }\n  \n      y2debug (\"Read (%s: %s, %s, %s)\", path->toString ().c_str (),\n  \t     mName->toString ().c_str (), mSyntax->toString ().c_str (),\n  \t     isFillup ? \"Fillup\" : mComment.c_str ());\n  \n      YCPValue value = validateCache (YCPNull (), arg);\n  \n      if (value.isNull ())\n      {\n  \tycp2error (\"Read validate failed\");\n  \treturn YCPNull ();\n      }\n  \n      if (!path->isRoot ())\n      {\n  \tint len = path->length ();\n  \tif (path->component_str (0) == \"_\")\n  \t{\n  \n  \t    // ._ -> return raw data completely\n  \t    //\n  \n  \t    if (len == 1)\n  \t\treturn alldata;\n  \n  \t    // ._.<num> -> return line <num> of raw data\n  \t    //\n  \n  \t    if ((len == 2) && isdigit (path->component_str (1)[0]))\n  \t    {\n  \t\tint num = atoi (path->component_str (1).c_str ());\n  \t\tif ((num < 0) || (num > alldata->size ()))\n  \t\t{\n  \t\t    y2error (\"Bad index %d for ._.<num>\", num);\n  \t\t    return YCPVoid ();\n  \t\t}\n  \t\treturn alldata->value (num);\n  \t    }\n  \t}\n  \telse\n  \t{\n  \t    return readValueByPath (value, path);\n  \t}\n  \n  \treturn YCPVoid ();\n      }\n  \n      return value;\n  }\n}"
  },
  {
    "function_name": "otherCommand",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
    "lines": "123-246",
    "snippet": "YCPValue\nAnyAgent::otherCommand (const YCPTerm & term)\n{\n    const string sym = term->name ();\n    \n    y2debug( \"Received term in otherCommand: %s\", term->toString().c_str() );\n\n    if (sym == \"Description\" && term->size () >= 4)\n    {\n\tif (description_read)\n\t{\n\t    y2warning (\"Rereading Description. It's not intended this way!\");\n\t}\n\n\t// extract File () or Run () or Local ()\n\n\tmType = MTYPE_NONE;\n\tYCPValue v = term->value (0);\n\tif (v->isTerm ())\n\t{\n\t    YCPTerm t = v->asTerm ();\n\t    const string s = t->name ();\n\t    if (s == \"File\" && t->size () > 0)\n\t    {\n\t\tmType = MTYPE_FILE;\n\t\tif (t->size () == 1 && t->value (0)->isString ())\n\t\t    mName = t->value (0)->asString ();\n\t\telse\n\t\t    mName = t;\n\t    }\n\t    else if (s == \"Run\" && t->size () > 0)\n\t    {\n\t\tmType = MTYPE_PROG;\n\t\tif (t->size () == 1 && t->value (0)->isString ())\n\t\t    mName = t->value (0)->asString ();\n\t\telse\n\t\t    mName = t;\n\t    }\n\t    else if (s == \"Local\" && t->size () > 0)\n\t    {\n\t\tmType = MTYPE_LOCAL;\n\t\tif (t->size () == 1 && t->value (0)->isString ())\n\t\t    mName = t->value (0)->asString ();\n\t\telse\n\t\t    mName = t;\n\t    }\n\t    else\n\t    {\n\t\tycp2error (\"Bad first arg of Description (): %s\", s.c_str ());\n\t\treturn YCPNull ();\n\t    }\n\t}\n\n\tif (mType == MTYPE_NONE)\n\t{\n\t    ycp2error (\"First arg of Description () not recognized\");\n\t    return YCPNull ();\n\t}\n\n\t// extract comment characters\n\t// or `Fillup (\"<comment chars>\")\n\n\tif (term->value (1)->isString ())\n\t{\n\t    mComment = term->value (1)->asString ()->value ();\n\t}\n\telse if (term->value (1)->isTerm ())\n\t{\n\t    YCPTerm fillterm = term->value (1)->asTerm ();\n\t    if ((fillterm->name () == \"Fillup\") &&\n\t\t(fillterm->size () == 1) && (fillterm->value (0)->isString ()))\n\t    {\n\t\tisFillup = true;\n\t\tmComment = fillterm->value (0)->asString ()->value ();\n\t    }\n\t    else\n\t    {\n\t\tycp2error (\"Second arg of Description() not Fillup(string)\");\n\t\treturn YCPNull ();\n\t    }\n\t}\n\telse\n\t{\n\t    ycp2error (\"Second arg of Description() not string\");\n\t    return YCPNull ();\n\t}\n\n\t// extract read-only flag\n\n\tmReadOnly = true;\n\tif (term->value (2)->isBoolean ())\n\t{\n\t    mReadOnly = term->value (2)->asBoolean ()->value ();\n\t    if (!mReadOnly && (mType == MTYPE_PROG))\n\t    {\n\t\ty2warning (\"Run () must be read-only !\");\n\t\tmReadOnly = true;\n\t    }\n\t}\n\telse\n\t    y2warning (\"Third arg of Description () not boolean\");\n\n\t// extract syntax description\n\n\tmSyntax = term->value (3);\n\n\t// extract optional header description\n\n\tif (term->size () > 4)\n\t{\n\t    mHeader = term->value (4);\n\t}\n\telse\n\t{\n\t    mHeader = YCPNull ();\n\t}\n\n\tdescription_read = true;\n\n\treturn YCPVoid ();\n    }\n\n    return YCPNull ();\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term->value",
          "args": [
            "4"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->size",
          "args": [],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"Third arg of Description () not boolean\""
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"Run () must be read-only !\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term->value",
          "args": [],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Second arg of Description() not string\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Second arg of Description() not Fillup(string)\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fillterm->name",
          "args": [],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2AgentComp",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "44-44",
          "snippet": "string name () const { return my_name; }",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp {\n  string name () const { return my_name; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"First arg of Description () not recognized\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad first arg of Description (): %s\"",
            "s.c_str ()"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.c_str",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->value",
          "args": [
            "0"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YEList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "773-783",
          "snippet": "YCodePtr\nYEList::value (int index) const\n{\n    ycodelist_t *element = m_first;\n    while (element && index)\n    {\n\telement = element->next;\n\tindex--;\n    }\n    return element != NULL ? element->code : NULL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEList {\n  YCodePtr\n  YEList::value (int index) const\n  {\n      ycodelist_t *element = m_first;\n      while (element && index)\n      {\n  \telement = element->next;\n  \tindex--;\n      }\n      return element != NULL ? element->code : NULL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->size",
          "args": [],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "42-46",
          "snippet": "int\nYCPListRep::size() const\n{\n    return elements.size();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  int\n  YCPListRep::size() const\n  {\n      return elements.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->asTerm",
          "args": [],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->isTerm",
          "args": [],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "isTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "70-70",
          "snippet": "bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"Rereading Description. It's not intended this way!\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Received term in otherCommand: %s\"",
            "term->toString().c_str()"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term->toString",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::otherCommand (const YCPTerm & term)\n  {\n      const string sym = term->name ();\n      \n      y2debug( \"Received term in otherCommand: %s\", term->toString().c_str() );\n  \n      if (sym == \"Description\" && term->size () >= 4)\n      {\n  \tif (description_read)\n  \t{\n  \t    y2warning (\"Rereading Description. It's not intended this way!\");\n  \t}\n  \n  \t// extract File () or Run () or Local ()\n  \n  \tmType = MTYPE_NONE;\n  \tYCPValue v = term->value (0);\n  \tif (v->isTerm ())\n  \t{\n  \t    YCPTerm t = v->asTerm ();\n  \t    const string s = t->name ();\n  \t    if (s == \"File\" && t->size () > 0)\n  \t    {\n  \t\tmType = MTYPE_FILE;\n  \t\tif (t->size () == 1 && t->value (0)->isString ())\n  \t\t    mName = t->value (0)->asString ();\n  \t\telse\n  \t\t    mName = t;\n  \t    }\n  \t    else if (s == \"Run\" && t->size () > 0)\n  \t    {\n  \t\tmType = MTYPE_PROG;\n  \t\tif (t->size () == 1 && t->value (0)->isString ())\n  \t\t    mName = t->value (0)->asString ();\n  \t\telse\n  \t\t    mName = t;\n  \t    }\n  \t    else if (s == \"Local\" && t->size () > 0)\n  \t    {\n  \t\tmType = MTYPE_LOCAL;\n  \t\tif (t->size () == 1 && t->value (0)->isString ())\n  \t\t    mName = t->value (0)->asString ();\n  \t\telse\n  \t\t    mName = t;\n  \t    }\n  \t    else\n  \t    {\n  \t\tycp2error (\"Bad first arg of Description (): %s\", s.c_str ());\n  \t\treturn YCPNull ();\n  \t    }\n  \t}\n  \n  \tif (mType == MTYPE_NONE)\n  \t{\n  \t    ycp2error (\"First arg of Description () not recognized\");\n  \t    return YCPNull ();\n  \t}\n  \n  \t// extract comment characters\n  \t// or `Fillup (\"<comment chars>\")\n  \n  \tif (term->value (1)->isString ())\n  \t{\n  \t    mComment = term->value (1)->asString ()->value ();\n  \t}\n  \telse if (term->value (1)->isTerm ())\n  \t{\n  \t    YCPTerm fillterm = term->value (1)->asTerm ();\n  \t    if ((fillterm->name () == \"Fillup\") &&\n  \t\t(fillterm->size () == 1) && (fillterm->value (0)->isString ()))\n  \t    {\n  \t\tisFillup = true;\n  \t\tmComment = fillterm->value (0)->asString ()->value ();\n  \t    }\n  \t    else\n  \t    {\n  \t\tycp2error (\"Second arg of Description() not Fillup(string)\");\n  \t\treturn YCPNull ();\n  \t    }\n  \t}\n  \telse\n  \t{\n  \t    ycp2error (\"Second arg of Description() not string\");\n  \t    return YCPNull ();\n  \t}\n  \n  \t// extract read-only flag\n  \n  \tmReadOnly = true;\n  \tif (term->value (2)->isBoolean ())\n  \t{\n  \t    mReadOnly = term->value (2)->asBoolean ()->value ();\n  \t    if (!mReadOnly && (mType == MTYPE_PROG))\n  \t    {\n  \t\ty2warning (\"Run () must be read-only !\");\n  \t\tmReadOnly = true;\n  \t    }\n  \t}\n  \telse\n  \t    y2warning (\"Third arg of Description () not boolean\");\n  \n  \t// extract syntax description\n  \n  \tmSyntax = term->value (3);\n  \n  \t// extract optional header description\n  \n  \tif (term->size () > 4)\n  \t{\n  \t    mHeader = term->value (4);\n  \t}\n  \telse\n  \t{\n  \t    mHeader = YCPNull ();\n  \t}\n  \n  \tdescription_read = true;\n  \n  \treturn YCPVoid ();\n      }\n  \n      return YCPNull ();\n  }\n}"
  },
  {
    "function_name": "~AnyAgent",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
    "lines": "118-120",
    "snippet": "AnyAgent::~AnyAgent ()\n{\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  AnyAgent::~AnyAgent ()\n  {\n  }\n}"
  },
  {
    "function_name": "AnyAgent",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgent.cc",
    "lines": "103-115",
    "snippet": "AnyAgent::AnyAgent ()\n    : description_read (false),\n      mtime (0),\n      cache (YCPNull ()),\n      cchanged (true),\n      alldata (YCPNull ()),\n      achanged (true),\n      mName (YCPNull ()),\n      isFillup (false),\n      mSyntax (YCPNull ()),\n      mHeader (YCPNull ())\n{\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <fstream>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  AnyAgent::AnyAgent ()\n      : description_read (false),\n        mtime (0),\n        cache (YCPNull ()),\n        cchanged (true),\n        alldata (YCPNull ()),\n        achanged (true),\n        mName (YCPNull ()),\n        isFillup (false),\n        mSyntax (YCPNull ()),\n        mHeader (YCPNull ())\n  {\n  }\n}"
  }
]