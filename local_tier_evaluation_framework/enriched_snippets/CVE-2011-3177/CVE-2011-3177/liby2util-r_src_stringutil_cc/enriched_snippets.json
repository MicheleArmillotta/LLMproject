[
  {
    "function_name": "toUpper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/stringutil.cc",
    "lines": "248-259",
    "snippet": "std::string toUpper( const std::string & s )\n{\n  if ( s.empty() )\n    return s;\n\n  string ret( s );\n  for ( string::size_type i = 0; i < ret.length(); ++i ) {\n    if ( islower( ret[i] ) )\n      ret[i] = static_cast<char>(toupper( ret[i] ));\n  }\n  return ret;\n}",
    "includes": [
      "#include <y2util/stringutil.h>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<char>",
          "args": [
            "toupper( ret[i] )"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "ret[i]"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "islower",
          "args": [
            "ret[i]"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret.length",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.empty",
          "args": [],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/stringutil.h>\n#include <fstream>\n#include <iostream>\n\nstd::string toUpper( const std::string & s )\n{\n  if ( s.empty() )\n    return s;\n\n  string ret( s );\n  for ( string::size_type i = 0; i < ret.length(); ++i ) {\n    if ( islower( ret[i] ) )\n      ret[i] = static_cast<char>(toupper( ret[i] ));\n  }\n  return ret;\n}"
  },
  {
    "function_name": "toLower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/stringutil.cc",
    "lines": "227-238",
    "snippet": "std::string toLower( const std::string & s )\n{\n  if ( s.empty() )\n    return s;\n\n  string ret( s );\n  for ( string::size_type i = 0; i < ret.length(); ++i ) {\n    if ( isupper( ret[i] ) )\n      ret[i] = static_cast<char>(tolower( ret[i] ));\n  }\n  return ret;\n}",
    "includes": [
      "#include <y2util/stringutil.h>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<char>",
          "args": [
            "tolower( ret[i] )"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "ret[i]"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "s_tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "540-564",
          "snippet": "static YCPValue\ns_tolower (const YCPString &s)\n{\n    /**\n     * @builtin tolower\n     * @short Makes a string lowercase\n     * @param string s String\n     * @return string String in lower case\n     *\n     * @description\n     * Returns string with all alphabetic characters converted to lowercase.\n     * Notice: national characters are left unchanged.\n     *\n     * @usage tolower (\"aBcDeF\") -> \"abcdef\"\n     * @usage tolower (\"ABCÁÄÖČ\") -> \"abcÁÄÖČ\"\n     */\n\n    if (s.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    for (unsigned i = 0; i < ss.size (); i++)\n\tss[i] = tolower (ss[i]);\n    return YCPString (ss);\n}\n\n\nstati",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_tolower (const YCPString &s)\n{\n    /**\n     * @builtin tolower\n     * @short Makes a string lowercase\n     * @param string s String\n     * @return string String in lower case\n     *\n     * @description\n     * Returns string with all alphabetic characters converted to lowercase.\n     * Notice: national characters are left unchanged.\n     *\n     * @usage tolower (\"aBcDeF\") -> \"abcdef\"\n     * @usage tolower (\"ABCÁÄÖČ\") -> \"abcÁÄÖČ\"\n     */\n\n    if (s.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    for (unsigned i = 0; i < ss.size (); i++)\n\tss[i] = tolower (ss[i]);\n    return YCPString (ss);\n}\n\n\nstati"
        }
      },
      {
        "call_info": {
          "callee": "isupper",
          "args": [
            "ret[i]"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret.length",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.empty",
          "args": [],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/stringutil.h>\n#include <fstream>\n#include <iostream>\n\nstd::string toLower( const std::string & s )\n{\n  if ( s.empty() )\n    return s;\n\n  string ret( s );\n  for ( string::size_type i = 0; i < ret.length(); ++i ) {\n    if ( isupper( ret[i] ) )\n      ret[i] = static_cast<char>(tolower( ret[i] ));\n  }\n  return ret;\n}"
  },
  {
    "function_name": "rtrim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/stringutil.cc",
    "lines": "207-217",
    "snippet": "std::string rtrim( const std::string & s )\n{\n  if ( s.empty() )\n    return s;\n\n  string::size_type p = s.find_last_not_of( \" \\t\\n\" );\n  if ( p == string::npos )\n    return \"\";\n\n  return s.substr( 0, p+1 );\n}",
    "includes": [
      "#include <y2util/stringutil.h>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s.substr",
          "args": [
            "0",
            "p+1"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.find_last_not_of",
          "args": [
            "\" \\t\\n\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.empty",
          "args": [],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/stringutil.h>\n#include <fstream>\n#include <iostream>\n\nstd::string rtrim( const std::string & s )\n{\n  if ( s.empty() )\n    return s;\n\n  string::size_type p = s.find_last_not_of( \" \\t\\n\" );\n  if ( p == string::npos )\n    return \"\";\n\n  return s.substr( 0, p+1 );\n}"
  },
  {
    "function_name": "ltrim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/stringutil.cc",
    "lines": "187-197",
    "snippet": "std::string ltrim( const std::string & s )\n{\n  if ( s.empty() )\n    return s;\n\n  string::size_type p = s.find_first_not_of( \" \\t\\n\" );\n  if ( p == string::npos )\n    return \"\";\n\n  return s.substr( p );\n}",
    "includes": [
      "#include <y2util/stringutil.h>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s.substr",
          "args": [
            "p"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.find_first_not_of",
          "args": [
            "\" \\t\\n\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.empty",
          "args": [],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/stringutil.h>\n#include <fstream>\n#include <iostream>\n\nstd::string ltrim( const std::string & s )\n{\n  if ( s.empty() )\n    return s;\n\n  string::size_type p = s.find_first_not_of( \" \\t\\n\" );\n  if ( p == string::npos )\n    return \"\";\n\n  return s.substr( p );\n}"
  },
  {
    "function_name": "stripFirstWord",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/stringutil.cc",
    "lines": "151-177",
    "snippet": "string stripFirstWord( string & line, const bool ltrim_first )\n{\n  if ( ltrim_first )\n    line = ltrim( line );\n\n  if ( line.empty() )\n    return line;\n\n  string ret;\n  string::size_type p = line.find_first_of( \" \\t\" );\n\n  if ( p == string::npos ) {\n    // no ws on line\n    ret = line;\n    line.erase();\n  } else if ( p == 0 ) {\n    // starts with ws\n    // ret remains empty\n    line = ltrim( line );\n  }\n  else {\n    // strip word and ltim line\n    ret = line.substr( 0, p );\n    line = ltrim( line.erase( 0, p ) );\n  }\n  return ret;\n}",
    "includes": [
      "#include <y2util/stringutil.h>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ltrim",
          "args": [
            "line.erase( 0, p )"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "ltrim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/stringutil.cc",
          "lines": "187-197",
          "snippet": "std::string ltrim( const std::string & s )\n{\n  if ( s.empty() )\n    return s;\n\n  string::size_type p = s.find_first_not_of( \" \\t\\n\" );\n  if ( p == string::npos )\n    return \"\";\n\n  return s.substr( p );\n}",
          "includes": [
            "#include <y2util/stringutil.h>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/stringutil.h>\n#include <fstream>\n#include <iostream>\n\nstd::string ltrim( const std::string & s )\n{\n  if ( s.empty() )\n    return s;\n\n  string::size_type p = s.find_first_not_of( \" \\t\\n\" );\n  if ( p == string::npos )\n    return \"\";\n\n  return s.substr( p );\n}"
        }
      },
      {
        "call_info": {
          "callee": "line.erase",
          "args": [
            "0",
            "p"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.substr",
          "args": [
            "0",
            "p"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.erase",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.find_first_of",
          "args": [
            "\" \\t\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.empty",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/stringutil.h>\n#include <fstream>\n#include <iostream>\n\nstring stripFirstWord( string & line, const bool ltrim_first )\n{\n  if ( ltrim_first )\n    line = ltrim( line );\n\n  if ( line.empty() )\n    return line;\n\n  string ret;\n  string::size_type p = line.find_first_of( \" \\t\" );\n\n  if ( p == string::npos ) {\n    // no ws on line\n    ret = line;\n    line.erase();\n  } else if ( p == 0 ) {\n    // starts with ws\n    // ret remains empty\n    line = ltrim( line );\n  }\n  else {\n    // strip word and ltim line\n    ret = line.substr( 0, p );\n    line = ltrim( line.erase( 0, p ) );\n  }\n  return ret;\n}"
  },
  {
    "function_name": "join",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/stringutil.cc",
    "lines": "128-141",
    "snippet": "std::string join( const std::vector<std::string> & words_r,\n\t\t  const std::string & sep_r )\n{\n  if ( words_r.empty() )\n    return \"\";\n\n  string ret( words_r[0] );\n\n  for ( unsigned i = 1; i < words_r.size(); ++i ) {\n    ret += sep_r + words_r[i];\n  }\n\n  return ret;\n}",
    "includes": [
      "#include <y2util/stringutil.h>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "words_r.size",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "words_r.empty",
          "args": [],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/stringutil.h>\n#include <fstream>\n#include <iostream>\n\nstd::string join( const std::vector<std::string> & words_r,\n\t\t  const std::string & sep_r )\n{\n  if ( words_r.empty() )\n    return \"\";\n\n  string ret( words_r[0] );\n\n  for ( unsigned i = 1; i < words_r.size(); ++i ) {\n    ret += sep_r + words_r[i];\n  }\n\n  return ret;\n}"
  },
  {
    "function_name": "split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/stringutil.cc",
    "lines": "73-118",
    "snippet": "unsigned split( const std::string          line_tv,\n\t\tstd::vector<std::string> & words_Vtr,\n\t\tconst std::string &        sep_tv,\n\t\tconst bool                 singlesep_bv )\n{\n  words_Vtr.clear();\n  if ( line_tv.empty() )\n    return words_Vtr.size();\n\n  struct sepctrl {\n    const string & sep_t;\n    sepctrl( const string & sep_tv ) : sep_t( sep_tv ) {}\n    // Note that '\\0' ist neither Sep nor NonSep\n    inline bool isSep     ( const char c )    const { return( sep_t.find( c ) != string::npos ); }\n    inline bool isNonSep  ( const char c )    const { return( c && !isSep(c) ); }\n    inline void skipSep   ( const char *& p ) const { while ( isSep( *p ) ) ++p; }\n    inline void skipNonSep( const char *& p ) const { while ( isNonSep( *p ) ) ++p; }\n  };\n\n  sepctrl      sep_Ci( sep_tv );\n  const char * s_pci = line_tv.c_str();\n  const char * c_pci = s_pci;\n\n  // Start with c_pci at the beginning of the 1st field to add.\n  // In singlesep the beginning might be equal to the next sep,\n  // which makes an empty field before the sep.\n  if ( !singlesep_bv && sep_Ci.isSep( *c_pci ) ) {\n    sep_Ci.skipSep( c_pci );\n  }\n\n  for ( s_pci = c_pci; *s_pci; s_pci = c_pci ) {\n    sep_Ci.skipNonSep( c_pci );\n    words_Vtr.push_back( string( s_pci, c_pci - s_pci ) );\n    if ( *c_pci ) {\n      if ( singlesep_bv ) {\n        if ( !*(++c_pci) ) {\n          // line ends with a sep -> add the empty field behind\n          words_Vtr.push_back( \"\" );\n        }\n      } else\n        sep_Ci.skipSep( c_pci );\n    }\n  }\n\n  return words_Vtr.size();\n}",
    "includes": [
      "#include <y2util/stringutil.h>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "words_Vtr.size",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sep_Ci.skipSep",
          "args": [
            "c_pci"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "words_Vtr.push_back",
          "args": [
            "\"\""
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "LogTail",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "649-652",
          "snippet": "void LogTail::push_back (const Data &d)\n{\n    m_impl->push_back (d);\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nLogTail {\n  void LogTail::push_back (const Data &d)\n  {\n      m_impl->push_back (d);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "s_pci",
            "c_pci - s_pci"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "read_file_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
          "lines": "145-165",
          "snippet": "static int read_file_to_string (const char* filename, string& output)\n{\n    int fd = open (filename, O_RDONLY);\n    output = \"\";\n    if (fd < 0)\n    {\n\treturn errno;\n    }\n\n    while (true)\n    {\n\tchar buffer[4096];\n\tssize_t bytes_read = read (fd, buffer, 4095);\n\tif (bytes_read <= 0)\n\t    break;\n\tbuffer[bytes_read] = 0; // 0 terminate string\n\toutput += buffer;\n    }\n    close(fd);\n    return 0;\n}",
          "includes": [
            "#include \"ShellCommand.h\"",
            "#include \"SystemAgent.h\"",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/pathsearch.h>",
            "#include <YCP.h>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <string>",
            "#include <linux/lp.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <resolv.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int read_file_to_string (const char* filename, string& output)\n{\n    int fd = open (filename, O_RDONLY);\n    output = \"\";\n    if (fd < 0)\n    {\n\treturn errno;\n    }\n\n    while (true)\n    {\n\tchar buffer[4096];\n\tssize_t bytes_read = read (fd, buffer, 4095);\n\tif (bytes_read <= 0)\n\t    break;\n\tbuffer[bytes_read] = 0; // 0 terminate string\n\toutput += buffer;\n    }\n    close(fd);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sep_Ci.skipNonSep",
          "args": [
            "c_pci"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sep_Ci.skipSep",
          "args": [
            "c_pci"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sep_Ci.isSep",
          "args": [
            "*c_pci"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line_tv.c_str",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isNonSep",
          "args": [
            "*p"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isSep",
          "args": [
            "*p"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isSep",
          "args": [
            "c"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sep_t.find",
          "args": [
            "c"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line_tv.empty",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "words_Vtr.clear",
          "args": [],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/PathInfo.h",
          "lines": "461-461",
          "snippet": "void clear() { _devino.clear(); }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <map>",
            "#include <set>",
            "#include <list>",
            "#include <iosfwd>",
            "#include <cerrno>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <map>\n#include <set>\n#include <list>\n#include <iosfwd>\n#include <cerrno>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid clear() { _devino.clear(); }"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/stringutil.h>\n#include <fstream>\n#include <iostream>\n\nunsigned split( const std::string          line_tv,\n\t\tstd::vector<std::string> & words_Vtr,\n\t\tconst std::string &        sep_tv,\n\t\tconst bool                 singlesep_bv )\n{\n  words_Vtr.clear();\n  if ( line_tv.empty() )\n    return words_Vtr.size();\n\n  struct sepctrl {\n    const string & sep_t;\n    sepctrl( const string & sep_tv ) : sep_t( sep_tv ) {}\n    // Note that '\\0' ist neither Sep nor NonSep\n    inline bool isSep     ( const char c )    const { return( sep_t.find( c ) != string::npos ); }\n    inline bool isNonSep  ( const char c )    const { return( c && !isSep(c) ); }\n    inline void skipSep   ( const char *& p ) const { while ( isSep( *p ) ) ++p; }\n    inline void skipNonSep( const char *& p ) const { while ( isNonSep( *p ) ) ++p; }\n  };\n\n  sepctrl      sep_Ci( sep_tv );\n  const char * s_pci = line_tv.c_str();\n  const char * c_pci = s_pci;\n\n  // Start with c_pci at the beginning of the 1st field to add.\n  // In singlesep the beginning might be equal to the next sep,\n  // which makes an empty field before the sep.\n  if ( !singlesep_bv && sep_Ci.isSep( *c_pci ) ) {\n    sep_Ci.skipSep( c_pci );\n  }\n\n  for ( s_pci = c_pci; *s_pci; s_pci = c_pci ) {\n    sep_Ci.skipNonSep( c_pci );\n    words_Vtr.push_back( string( s_pci, c_pci - s_pci ) );\n    if ( *c_pci ) {\n      if ( singlesep_bv ) {\n        if ( !*(++c_pci) ) {\n          // line ends with a sep -> add the empty field behind\n          words_Vtr.push_back( \"\" );\n        }\n      } else\n        sep_Ci.skipSep( c_pci );\n    }\n  }\n\n  return words_Vtr.size();\n}"
  },
  {
    "function_name": "getline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/stringutil.cc",
    "lines": "60-63",
    "snippet": "std::string getline( std::istream & str, bool trim )\n{\n  return _getline(str, trim?TRIM:NO_TRIM);\n}",
    "includes": [
      "#include <y2util/stringutil.h>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_getline",
          "args": [
            "str",
            "trim?TRIM:NO_TRIM"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "_getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/stringutil.cc",
          "lines": "43-53",
          "snippet": "static inline std::string _getline( std::istream & str, const Trim trim_r )\n{\n  string ret;\n  do {\n    str.clear();\n    str.getline( tmpBuff, tmpBuffLen ); // always writes '\\0' terminated\n    ret += tmpBuff;\n  } while( str.rdstate() == ios::failbit );\n\n  return trim( ret, trim_r );\n}",
          "includes": [
            "#include <y2util/stringutil.h>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/stringutil.h>\n#include <fstream>\n#include <iostream>\n\nstatic inline std::string _getline( std::istream & str, const Trim trim_r )\n{\n  string ret;\n  do {\n    str.clear();\n    str.getline( tmpBuff, tmpBuffLen ); // always writes '\\0' terminated\n    ret += tmpBuff;\n  } while( str.rdstate() == ios::failbit );\n\n  return trim( ret, trim_r );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/stringutil.h>\n#include <fstream>\n#include <iostream>\n\nstd::string getline( std::istream & str, bool trim )\n{\n  return _getline(str, trim?TRIM:NO_TRIM);\n}"
  },
  {
    "function_name": "getline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/stringutil.cc",
    "lines": "55-58",
    "snippet": "std::string getline( std::istream & str, const Trim trim_r )\n{\n  return _getline(str, trim_r);\n}",
    "includes": [
      "#include <y2util/stringutil.h>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_getline",
          "args": [
            "str",
            "trim_r"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "_getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/stringutil.cc",
          "lines": "43-53",
          "snippet": "static inline std::string _getline( std::istream & str, const Trim trim_r )\n{\n  string ret;\n  do {\n    str.clear();\n    str.getline( tmpBuff, tmpBuffLen ); // always writes '\\0' terminated\n    ret += tmpBuff;\n  } while( str.rdstate() == ios::failbit );\n\n  return trim( ret, trim_r );\n}",
          "includes": [
            "#include <y2util/stringutil.h>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/stringutil.h>\n#include <fstream>\n#include <iostream>\n\nstatic inline std::string _getline( std::istream & str, const Trim trim_r )\n{\n  string ret;\n  do {\n    str.clear();\n    str.getline( tmpBuff, tmpBuffLen ); // always writes '\\0' terminated\n    ret += tmpBuff;\n  } while( str.rdstate() == ios::failbit );\n\n  return trim( ret, trim_r );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/stringutil.h>\n#include <fstream>\n#include <iostream>\n\nstd::string getline( std::istream & str, const Trim trim_r )\n{\n  return _getline(str, trim_r);\n}"
  },
  {
    "function_name": "_getline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/stringutil.cc",
    "lines": "43-53",
    "snippet": "static inline std::string _getline( std::istream & str, const Trim trim_r )\n{\n  string ret;\n  do {\n    str.clear();\n    str.getline( tmpBuff, tmpBuffLen ); // always writes '\\0' terminated\n    ret += tmpBuff;\n  } while( str.rdstate() == ios::failbit );\n\n  return trim( ret, trim_r );\n}",
    "includes": [
      "#include <y2util/stringutil.h>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trim",
          "args": [
            "ret",
            "trim_r"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str.rdstate",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str.getline",
          "args": [
            "tmpBuff",
            "tmpBuffLen"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/stringutil.cc",
          "lines": "60-63",
          "snippet": "std::string getline( std::istream & str, bool trim )\n{\n  return _getline(str, trim?TRIM:NO_TRIM);\n}",
          "includes": [
            "#include <y2util/stringutil.h>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/stringutil.h>\n#include <fstream>\n#include <iostream>\n\nstd::string getline( std::istream & str, bool trim )\n{\n  return _getline(str, trim?TRIM:NO_TRIM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.clear",
          "args": [],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/PathInfo.h",
          "lines": "461-461",
          "snippet": "void clear() { _devino.clear(); }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <map>",
            "#include <set>",
            "#include <list>",
            "#include <iosfwd>",
            "#include <cerrno>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <map>\n#include <set>\n#include <list>\n#include <iosfwd>\n#include <cerrno>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid clear() { _devino.clear(); }"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/stringutil.h>\n#include <fstream>\n#include <iostream>\n\nstatic inline std::string _getline( std::istream & str, const Trim trim_r )\n{\n  string ret;\n  do {\n    str.clear();\n    str.getline( tmpBuff, tmpBuffLen ); // always writes '\\0' terminated\n    ret += tmpBuff;\n  } while( str.rdstate() == ios::failbit );\n\n  return trim( ret, trim_r );\n}"
  }
]