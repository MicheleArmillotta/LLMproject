[
  {
    "function_name": "readconf",
    "container": "SCRAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/SCRAgent.cc",
    "lines": "73-108",
    "snippet": "YCPValue\nSCRAgent::readconf (const char *filename)\n{\n    FILE *file = fopen (filename, \"r\");\n    if (!file)\n    {\n\tycp2error (\"Can't open %s for reading.\", filename);\n\treturn YCPNull ();\n    }\n\n    // find first line starting with \".\"\n    const int size = 250;\n    char line[size];\n    char *fgets_result;\n    do\n    {\n\tfgets_result = fgets (line, size, file);\n    }\n    while ((fgets_result != 0) && (line[0] != '.'));\n\n    Parser parser (file, filename);\n    YCodePtr tmpvalue = parser.parse ();\n    fclose (file);\n\n    y2debug( \"Parsed value '%s'\", tmpvalue != 0 ? tmpvalue->toString().c_str() : \"not available\" );\n    if (tmpvalue == 0 || tmpvalue->kind () != YCode::yeTerm )\n    {\n\tycp2error (\"Not a term in scr file.\");\n\treturn YCPNull();\n    }\n\n    // it is a term, generate YCPValue through its evaluation\n    YCPValue ret = tmpvalue->evaluate();\n\n    return ret;\n}",
    "includes": [
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/Parser.h\"",
      "#include \"include/scr/SCR.h\"",
      "#include \"include/scr/SCRAgent.h\"",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tmpvalue->evaluate",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Not a term in scr file.\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmpvalue->kind",
          "args": [],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": "YConst",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "336-340",
          "snippet": "YCode::ykind\nYConst::kind() const\n{\n    return m_kind;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYConst {\n  YCode::ykind\n  YConst::kind() const\n  {\n      return m_kind;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Parsed value '%s'\"",
            "tmpvalue != 0 ? tmpvalue->toString().c_str() : \"not available\""
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmpvalue->toString",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "file"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser.parse",
          "args": [],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "484-562",
          "snippet": "int IniParser::parse()\n{\n    if (multiple_files)\n    {\n\tglob_t do_files;\n\tint len = files.size ();\n\tint flags = 0;\n\tfor (int i = 0;i<len;i++)\n\t{\n\t    glob (files[i].c_str (),flags, NULL, &do_files);\n\t    flags = GLOB_APPEND;\n\t}\n\tchar**f = do_files.gl_pathv;\n\tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n\t{\n\t    int section_index = -1;\n\t    string section_name = *f;\n\t    //FIXME: create function out of it.\n\t    // do we have name rewrite rules?\n\t    for (size_t j = 0; j < rewrites.size (); j++)\n\t\t{\n\t\t    RegexMatch m (rewrites[j].rx, section_name);\n\t\t    if (m)\n\t\t    {\n\t\t\tsection_index = j;\n\t\t\tsection_name = m[1];\n\t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    // do we know about the file?\n\t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n\t    if (ff == multi_files.end())\n\t    {\n\t\t// new file\n\t\tif (scanner_start (*f))\n\t\t    y2error (\"Cannot open %s.\", *f);\n\t\telse\n\t\t{\n\t\t    FileDescr fdsc (*f);\n\t\t    multi_files[*f] = fdsc;\n\t\t    inifile.initSection (section_name, \"\", -1, section_index);\n\t\t    parse_helper(inifile.getSection(section_name.c_str()));\n\t\t    scanner_stop();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif ((*ff).second.changed ())\n\t\t{\n\t\t    if (scanner_start (*f))\n\t\t\ty2error (\"Cannot open %s.\", *f);\n\t\t    else\n\t\t    {\n\t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n\t\t\tFileDescr fdsc (*f);\n\t\t\tmulti_files [*f] = fdsc;\n\t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n\t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n\t\t\tscanner_stop();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tif (scanner_start (file.c_str()))\n\t    {\n\t\ty2error (\"Can not open %s.\", file.c_str());\n\t\treturn -1;\n\t    }\n\tparse_helper(inifile);\n\tscanner_stop();\n\ttimestamp = getTimeStamp ();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse()\n  {\n      if (multiple_files)\n      {\n  \tglob_t do_files;\n  \tint len = files.size ();\n  \tint flags = 0;\n  \tfor (int i = 0;i<len;i++)\n  \t{\n  \t    glob (files[i].c_str (),flags, NULL, &do_files);\n  \t    flags = GLOB_APPEND;\n  \t}\n  \tchar**f = do_files.gl_pathv;\n  \tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n  \t{\n  \t    int section_index = -1;\n  \t    string section_name = *f;\n  \t    //FIXME: create function out of it.\n  \t    // do we have name rewrite rules?\n  \t    for (size_t j = 0; j < rewrites.size (); j++)\n  \t\t{\n  \t\t    RegexMatch m (rewrites[j].rx, section_name);\n  \t\t    if (m)\n  \t\t    {\n  \t\t\tsection_index = j;\n  \t\t\tsection_name = m[1];\n  \t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \n  \t    // do we know about the file?\n  \t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n  \t    if (ff == multi_files.end())\n  \t    {\n  \t\t// new file\n  \t\tif (scanner_start (*f))\n  \t\t    y2error (\"Cannot open %s.\", *f);\n  \t\telse\n  \t\t{\n  \t\t    FileDescr fdsc (*f);\n  \t\t    multi_files[*f] = fdsc;\n  \t\t    inifile.initSection (section_name, \"\", -1, section_index);\n  \t\t    parse_helper(inifile.getSection(section_name.c_str()));\n  \t\t    scanner_stop();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif ((*ff).second.changed ())\n  \t\t{\n  \t\t    if (scanner_start (*f))\n  \t\t\ty2error (\"Cannot open %s.\", *f);\n  \t\t    else\n  \t\t    {\n  \t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n  \t\t\tFileDescr fdsc (*f);\n  \t\t\tmulti_files [*f] = fdsc;\n  \t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n  \t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n  \t\t\tscanner_stop();\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n      else\n      {\n  \tif (scanner_start (file.c_str()))\n  \t    {\n  \t\ty2error (\"Can not open %s.\", file.c_str());\n  \t\treturn -1;\n  \t    }\n  \tparse_helper(inifile);\n  \tscanner_stop();\n  \ttimestamp = getTimeStamp ();\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "size",
            "file"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Can't open %s for reading.\"",
            "filename"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "filename",
            "\"r\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/YCode.h\"\n#include \"ycp/Parser.h\"\n#include \"include/scr/SCR.h\"\n#include \"include/scr/SCRAgent.h\"\n#include <ycp/y2log.h>\n\nSCRAgent {\n  YCPValue\n  SCRAgent::readconf (const char *filename)\n  {\n      FILE *file = fopen (filename, \"r\");\n      if (!file)\n      {\n  \tycp2error (\"Can't open %s for reading.\", filename);\n  \treturn YCPNull ();\n      }\n  \n      // find first line starting with \".\"\n      const int size = 250;\n      char line[size];\n      char *fgets_result;\n      do\n      {\n  \tfgets_result = fgets (line, size, file);\n      }\n      while ((fgets_result != 0) && (line[0] != '.'));\n  \n      Parser parser (file, filename);\n      YCodePtr tmpvalue = parser.parse ();\n      fclose (file);\n  \n      y2debug( \"Parsed value '%s'\", tmpvalue != 0 ? tmpvalue->toString().c_str() : \"not available\" );\n      if (tmpvalue == 0 || tmpvalue->kind () != YCode::yeTerm )\n      {\n  \tycp2error (\"Not a term in scr file.\");\n  \treturn YCPNull();\n      }\n  \n      // it is a term, generate YCPValue through its evaluation\n      YCPValue ret = tmpvalue->evaluate();\n  \n      return ret;\n  }\n}"
  },
  {
    "function_name": "otherCommand",
    "container": "SCRAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/SCRAgent.cc",
    "lines": "66-70",
    "snippet": "YCPValue\nSCRAgent::otherCommand (const YCPTerm&)\n{\n    return YCPNull();\n}",
    "includes": [
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/Parser.h\"",
      "#include \"include/scr/SCR.h\"",
      "#include \"include/scr/SCRAgent.h\"",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/YCode.h\"\n#include \"ycp/Parser.h\"\n#include \"include/scr/SCR.h\"\n#include \"include/scr/SCRAgent.h\"\n#include <ycp/y2log.h>\n\nSCRAgent {\n  YCPValue\n  SCRAgent::otherCommand (const YCPTerm&)\n  {\n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "Execute",
    "container": "SCRAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/SCRAgent.cc",
    "lines": "57-62",
    "snippet": "YCPValue\nSCRAgent::Execute (const YCPPath& path, const YCPValue& value,\n\t\t   const YCPValue& arg)\n{\n    return YCPNull();\n}",
    "includes": [
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/Parser.h\"",
      "#include \"include/scr/SCR.h\"",
      "#include \"include/scr/SCRAgent.h\"",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/YCode.h\"\n#include \"ycp/Parser.h\"\n#include \"include/scr/SCR.h\"\n#include \"include/scr/SCRAgent.h\"\n#include <ycp/y2log.h>\n\nSCRAgent {\n  YCPValue\n  SCRAgent::Execute (const YCPPath& path, const YCPValue& value,\n  \t\t   const YCPValue& arg)\n  {\n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "~SCRAgent",
    "container": "SCRAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/SCRAgent.cc",
    "lines": "46-49",
    "snippet": "SCRAgent::~SCRAgent ()\n{\n    if( current_scr == this ) current_scr = 0;\n}",
    "includes": [
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/Parser.h\"",
      "#include \"include/scr/SCR.h\"",
      "#include \"include/scr/SCRAgent.h\"",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "SCRAgent* SCRAgent::current_scr = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/YCode.h\"\n#include \"ycp/Parser.h\"\n#include \"include/scr/SCR.h\"\n#include \"include/scr/SCRAgent.h\"\n#include <ycp/y2log.h>\n\nSCRAgent* SCRAgent::current_scr = 0;\n\nSCRAgent {\n  SCRAgent::~SCRAgent ()\n  {\n      if( current_scr == this ) current_scr = 0;\n  }\n}"
  },
  {
    "function_name": "SCRAgent",
    "container": "SCRAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/SCRAgent.cc",
    "lines": "32-43",
    "snippet": "SCRAgent::SCRAgent ()\n    : mainscragent (0)\n{\n    if( current_scr == 0 ) current_scr = this;\n    if (unspecified_error.size () == 0)\n    {\n\tunspecified_error->add (YCPString (\"code\"),\n\t\t\t\tYCPString (\"UNSPEC\"));\n\tunspecified_error->add (YCPString (\"summary\"),\n\t\t\t\tYCPString (\"Unspecified error\"));\n    }\n}",
    "includes": [
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/Parser.h\"",
      "#include \"include/scr/SCR.h\"",
      "#include \"include/scr/SCRAgent.h\"",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "SCRAgent* SCRAgent::current_scr = 0;",
      "YCPMap SCRAgent::unspecified_error;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unspecified_error->add",
          "args": [
            "YCPString (\"summary\")",
            "YCPString (\"Unspecified error\")"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "50-76",
          "snippet": "void\nYCPMapRep::add (const YCPValue& key, const YCPValue& value)\n{\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn;\n    }\n\n    // Note: 'stl_map[key] = value' would create a temporary object using the\n    // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n    // 24.\n\n    YCPMap::iterator pos = stl_map.lower_bound(key);\n    if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n    {\n\tpos->second = value;\n    }\n    else\n    {\n\t// pos is just a hint but can avoid a second search through the map\n\tstl_map.insert(pos, YCPMap::value_type(key, value));\n    }\n\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void\n  YCPMapRep::add (const YCPValue& key, const YCPValue& value)\n  {\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn;\n      }\n  \n      // Note: 'stl_map[key] = value' would create a temporary object using the\n      // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n      // 24.\n  \n      YCPMap::iterator pos = stl_map.lower_bound(key);\n      if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n      {\n  \tpos->second = value;\n      }\n      else\n      {\n  \t// pos is just a hint but can avoid a second search through the map\n  \tstl_map.insert(pos, YCPMap::value_type(key, value));\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "\"Unspecified error\""
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unspecified_error.size",
          "args": [],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/YCode.h\"\n#include \"ycp/Parser.h\"\n#include \"include/scr/SCR.h\"\n#include \"include/scr/SCRAgent.h\"\n#include <ycp/y2log.h>\n\nSCRAgent* SCRAgent::current_scr = 0;\nYCPMap SCRAgent::unspecified_error;\n\nSCRAgent {\n  SCRAgent::SCRAgent ()\n      : mainscragent (0)\n  {\n      if( current_scr == 0 ) current_scr = this;\n      if (unspecified_error.size () == 0)\n      {\n  \tunspecified_error->add (YCPString (\"code\"),\n  \t\t\t\tYCPString (\"UNSPEC\"));\n  \tunspecified_error->add (YCPString (\"summary\"),\n  \t\t\t\tYCPString (\"Unspecified error\"));\n      }\n  }\n}"
  }
]