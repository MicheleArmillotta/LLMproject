[
  {
    "function_name": "YCPString",
    "container": "YCPString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
    "lines": "152-155",
    "snippet": "YCPString::YCPString (bytecodeistream & str)\n    : YCPValue (new YCPStringRep (fromStream (str)))\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2string.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fromStream",
          "args": [
            "str"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "fromStream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "143-149",
          "snippet": "static string\nfromStream (bytecodeistream & str)\n{\n    string s;\n    Bytecode::readString (str, s);\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nstatic string\nfromStream (bytecodeistream & str)\n{\n    string s;\n    Bytecode::readString (str, s);\n    return s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPString {\n  YCPString::YCPString (bytecodeistream & str)\n      : YCPValue (new YCPStringRep (fromStream (str)))\n  {\n  }\n}"
  },
  {
    "function_name": "fromStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
    "lines": "143-149",
    "snippet": "static string\nfromStream (bytecodeistream & str)\n{\n    string s;\n    Bytecode::readString (str, s);\n    return s;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2string.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readString",
          "args": [
            "str",
            "s"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "readString",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "229-247",
          "snippet": "bool\nBytecode::readString (bytecodeistream & streamref, string & stringref)\n{\n    bool ret = false;\n    stringref.erase();\n    u_int32_t len = readInt32 (streamref);\n    if (len > 0)\n    {\n\tchar *buf = new char [len+1];\n\tif (streamref.read (buf, len))\n\t{\n\t    buf[len] = 0;\n\t    stringref = string (buf);\n\t    ret = true;\n\t}\n\tdelete [] buf;\n    }\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  bool\n  Bytecode::readString (bytecodeistream & streamref, string & stringref)\n  {\n      bool ret = false;\n      stringref.erase();\n      u_int32_t len = readInt32 (streamref);\n      if (len > 0)\n      {\n  \tchar *buf = new char [len+1];\n  \tif (streamref.read (buf, len))\n  \t{\n  \t    buf[len] = 0;\n  \t    stringref = string (buf);\n  \t    ret = true;\n  \t}\n  \tdelete [] buf;\n      }\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nstatic string\nfromStream (bytecodeistream & str)\n{\n    string s;\n    Bytecode::readString (str, s);\n    return s;\n}"
  },
  {
    "function_name": "valuetype",
    "container": "YCPStringRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
    "lines": "116-120",
    "snippet": "YCPValueType\nYCPStringRep::valuetype() const\n{\n    return YT_STRING;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2string.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  YCPValueType\n  YCPStringRep::valuetype() const\n  {\n      return YT_STRING;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YCPStringRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
    "lines": "90-113",
    "snippet": "string\nYCPStringRep::toString() const\n{\n    string ret = \"\\\"\";\n    const char *r = v.c_str();\n    while (*r) {\n\tif (*r == '\\n') ret += \"\\\\n\";\n\telse if (*r == '\\t') ret += \"\\\\t\";\n\telse if (*r == '\\r') ret += \"\\\\r\";\n\telse if (*r == '\\f') ret += \"\\\\f\";\n\telse if (*r == '\\b') ret += \"\\\\b\";\n\telse if ((unsigned char)*r < 32) {\n\t    char s[8];\n\t    snprintf (s, 8, \"\\\\%03o\", (unsigned char)*r);\n\t    ret += s;\n\t}\n\telse {\n\t    if (*r == '\"' || *r == '\\\\') ret += \"\\\\\";\n\t    ret += *r;\n\t}\n\tr++;\n    }\n    return ret + \"\\\"\";\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2string.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "s",
            "8",
            "\"\\\\%03o\"",
            "(unsigned char)*r"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.c_str",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::toString() const\n  {\n      string ret = \"\\\"\";\n      const char *r = v.c_str();\n      while (*r) {\n  \tif (*r == '\\n') ret += \"\\\\n\";\n  \telse if (*r == '\\t') ret += \"\\\\t\";\n  \telse if (*r == '\\r') ret += \"\\\\r\";\n  \telse if (*r == '\\f') ret += \"\\\\f\";\n  \telse if (*r == '\\b') ret += \"\\\\b\";\n  \telse if ((unsigned char)*r < 32) {\n  \t    char s[8];\n  \t    snprintf (s, 8, \"\\\\%03o\", (unsigned char)*r);\n  \t    ret += s;\n  \t}\n  \telse {\n  \t    if (*r == '\"' || *r == '\\\\') ret += \"\\\\\";\n  \t    ret += *r;\n  \t}\n  \tr++;\n      }\n      return ret + \"\\\"\";\n  }\n}"
  },
  {
    "function_name": "compare",
    "container": "YCPStringRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
    "lines": "51-80",
    "snippet": "YCPOrder YCPStringRep::compare(const YCPString& s, bool rl) const\n{\n    // This function must not be locale aware per default otherwise\n    // extraordinary bad things happen when changing the locale at\n    // runtime.\n\n    int tmp = 0;\n\n    if (!rl)\n    {\n        tmp = v.compare (s->v);\n    }\n    else\n    {\n        const char* a = value_cstr ();\n        const char* b = s->value_cstr ();\n\n        std::wstring wa, wb;\n\n        if (utf82wchar (a, &wa) && utf82wchar (b, &wb))\n            tmp = wcscoll (wa.c_str (), wb.c_str ());\n        else\n            tmp = strcoll (a, b);\n    }\n\n    if (tmp == 0)\n        return YO_EQUAL;\n    else\n        return tmp < 0 ? YO_LESS : YO_GREATER;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2string.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcoll",
          "args": [
            "a",
            "b"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcscoll",
          "args": [
            "wa.c_str ()",
            "wb.c_str ()"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb.c_str",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wa.c_str",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utf82wchar",
          "args": [
            "b",
            "&wb"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "utf82wchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
          "lines": "89-114",
          "snippet": "bool\nutf82wchar (const std::string& in, std::wstring* out)\n{\n    static iconv_t cd = (iconv_t)(-1);\n\n    if (cd == (iconv_t)(-1))\n    {\n\tcd = iconv_open (\"WCHAR_T\", \"UTF-8\");\n\n\t// TODO: also call iconv_close somewhere, perhaps use\n\t// pthread_key_create et.al.\n\n\tif (cd == (iconv_t)(-1))\n\t{\n\t    static bool shown_once = false;\n\t    if (!shown_once) {\n\t\ty2error (\"iconv_open: %m\");\n\t\tshown_once = true;\n\t    }\n\n\t    return false;\n\t}\n    }\n\n    return recode (cd, in, out);\n}",
          "includes": [
            "#include \"y2string.h\"",
            "#include \"y2log.h\"",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nutf82wchar (const std::string& in, std::wstring* out)\n{\n    static iconv_t cd = (iconv_t)(-1);\n\n    if (cd == (iconv_t)(-1))\n    {\n\tcd = iconv_open (\"WCHAR_T\", \"UTF-8\");\n\n\t// TODO: also call iconv_close somewhere, perhaps use\n\t// pthread_key_create et.al.\n\n\tif (cd == (iconv_t)(-1))\n\t{\n\t    static bool shown_once = false;\n\t    if (!shown_once) {\n\t\ty2error (\"iconv_open: %m\");\n\t\tshown_once = true;\n\t    }\n\n\t    return false;\n\t}\n    }\n\n    return recode (cd, in, out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "s->value_cstr",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value_cstr",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.compare",
          "args": [
            "s->v"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "compare",
          "container": "YCPSymbolRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "54-59",
          "snippet": "YCPOrder\nYCPSymbolRep::compare(const YCPSymbol& s) const\n{\n    if (v == s->v) return YO_EQUAL;\n    else return v < s->v ? YO_LESS : YO_GREATER;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbolRep {\n  YCPOrder\n  YCPSymbolRep::compare(const YCPSymbol& s) const\n  {\n      if (v == s->v) return YO_EQUAL;\n      else return v < s->v ? YO_LESS : YO_GREATER;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  YCPOrder YCPStringRep::compare(const YCPString& s, bool rl) const\n  {\n      // This function must not be locale aware per default otherwise\n      // extraordinary bad things happen when changing the locale at\n      // runtime.\n  \n      int tmp = 0;\n  \n      if (!rl)\n      {\n          tmp = v.compare (s->v);\n      }\n      else\n      {\n          const char* a = value_cstr ();\n          const char* b = s->value_cstr ();\n  \n          std::wstring wa, wb;\n  \n          if (utf82wchar (a, &wa) && utf82wchar (b, &wb))\n              tmp = wcscoll (wa.c_str (), wb.c_str ());\n          else\n              tmp = strcoll (a, b);\n      }\n  \n      if (tmp == 0)\n          return YO_EQUAL;\n      else\n          return tmp < 0 ? YO_LESS : YO_GREATER;\n  }\n}"
  },
  {
    "function_name": "value",
    "container": "YCPStringRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
    "lines": "44-48",
    "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2string.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
  },
  {
    "function_name": "isEmpty",
    "container": "YCPStringRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
    "lines": "37-41",
    "snippet": "bool\nYCPStringRep::isEmpty() const\n{\n    return v.empty();\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2string.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v.empty",
          "args": [],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  bool\n  YCPStringRep::isEmpty() const\n  {\n      return v.empty();\n  }\n}"
  },
  {
    "function_name": "YCPStringRep",
    "container": "YCPStringRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
    "lines": "31-34",
    "snippet": "YCPStringRep::YCPStringRep(string s)\n    : v(s)\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2string.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  YCPStringRep::YCPStringRep(string s)\n      : v(s)\n  {\n  }\n}"
  }
]