[
  {
    "function_name": "errorNoMatch",
    "container": "StaticDeclaration",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/StaticDeclaration.cc",
    "lines": "560-578",
    "snippet": "void\nStaticDeclaration::errorNoMatch (Logger* problem_logger, constFunctionTypePtr orig, declaration_t* first_decl)\n{\n    problem_logger->error (string(\"No match for '\")+first_decl->name+\" : \"+orig->toString ()+\"'\");\n    problem_logger->error (\"Please fix parameter types to match one of:\");\n    while (first_decl)\n    {\n        problem_logger->error (string(\"'\")+StaticDeclaration::Decl2String (first_decl,true)+\"'\");\n\n        if (first_decl->tentry->next_overloaded () != 0)\n        {\n            first_decl = ((YSymbolEntryPtr)first_decl->tentry->next_overloaded ()->sentry ())->declaration ();\n        }\n        else\n        {\n\t    return;\n        }\n    }\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Import.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include <map>",
      "#include <string>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first_decl->tentry->next_overloaded",
          "args": [],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first_decl->tentry->next_overloaded",
          "args": [],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first_decl->tentry->next_overloaded",
          "args": [],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "problem_logger->error",
          "args": [
            "string(\"'\")+StaticDeclaration::Decl2String (first_decl,true)+\"'\""
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "292-296",
          "snippet": "void\nScanner::error (string error_message)\n{\n    logError (\"%s\", m_lineNumber, error_message.c_str());\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  void\n  Scanner::error (string error_message)\n  {\n      logError (\"%s\", m_lineNumber, error_message.c_str());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "StaticDeclaration::Decl2String",
          "args": [
            "first_decl",
            "true"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "Decl2String",
          "container": "StaticDeclaration",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/StaticDeclaration.cc",
          "lines": "250-272",
          "snippet": "string\nStaticDeclaration::Decl2String (const declaration_t *declaration, bool full)\n{\n    if (declaration == 0)\n    {\n\treturn \"(NULL)\";\n    }\n\n    const declaration_t *name_space = declaration->name_space;\n    const char *name = declaration->name;\n\n    if (!full)\n    {\n\treturn (name_space ? string (name_space->name) + \"::\" + string (name) : string (name));\n    }\n\n    if (name == 0)\n    {\n\treturn \"<NULL>\";\n    }\n\n    return string (name) + \" : \" + declaration->type->toString();\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Import.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include <map>",
            "#include <string>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <unistd.h>\n\nStaticDeclaration {\n  string\n  StaticDeclaration::Decl2String (const declaration_t *declaration, bool full)\n  {\n      if (declaration == 0)\n      {\n  \treturn \"(NULL)\";\n      }\n  \n      const declaration_t *name_space = declaration->name_space;\n      const char *name = declaration->name;\n  \n      if (!full)\n      {\n  \treturn (name_space ? string (name_space->name) + \"::\" + string (name) : string (name));\n      }\n  \n      if (name == 0)\n      {\n  \treturn \"<NULL>\";\n      }\n  \n      return string (name) + \" : \" + declaration->type->toString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"'\""
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "orig->toString",
          "args": [],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <unistd.h>\n\nStaticDeclaration {\n  void\n  StaticDeclaration::errorNoMatch (Logger* problem_logger, constFunctionTypePtr orig, declaration_t* first_decl)\n  {\n      problem_logger->error (string(\"No match for '\")+first_decl->name+\" : \"+orig->toString ()+\"'\");\n      problem_logger->error (\"Please fix parameter types to match one of:\");\n      while (first_decl)\n      {\n          problem_logger->error (string(\"'\")+StaticDeclaration::Decl2String (first_decl,true)+\"'\");\n  \n          if (first_decl->tentry->next_overloaded () != 0)\n          {\n              first_decl = ((YSymbolEntryPtr)first_decl->tentry->next_overloaded ()->sentry ())->declaration ();\n          }\n          else\n          {\n  \t    return;\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "Decl2String",
    "container": "StaticDeclaration",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/StaticDeclaration.cc",
    "lines": "250-272",
    "snippet": "string\nStaticDeclaration::Decl2String (const declaration_t *declaration, bool full)\n{\n    if (declaration == 0)\n    {\n\treturn \"(NULL)\";\n    }\n\n    const declaration_t *name_space = declaration->name_space;\n    const char *name = declaration->name;\n\n    if (!full)\n    {\n\treturn (name_space ? string (name_space->name) + \"::\" + string (name) : string (name));\n    }\n\n    if (name == 0)\n    {\n\treturn \"<NULL>\";\n    }\n\n    return string (name) + \" : \" + declaration->type->toString();\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Import.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include <map>",
      "#include <string>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "declaration->type->toString",
          "args": [],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "name"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <unistd.h>\n\nStaticDeclaration {\n  string\n  StaticDeclaration::Decl2String (const declaration_t *declaration, bool full)\n  {\n      if (declaration == 0)\n      {\n  \treturn \"(NULL)\";\n      }\n  \n      const declaration_t *name_space = declaration->name_space;\n      const char *name = declaration->name;\n  \n      if (!full)\n      {\n  \treturn (name_space ? string (name_space->name) + \"::\" + string (name) : string (name));\n      }\n  \n      if (name == 0)\n      {\n  \treturn \"<NULL>\";\n      }\n  \n      return string (name) + \" : \" + declaration->type->toString();\n  }\n}"
  },
  {
    "function_name": "dumpDeclarations",
    "container": "StaticDeclaration",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/StaticDeclaration.cc",
    "lines": "243-247",
    "snippet": "void\nStaticDeclaration::dumpDeclarations () const\n{\n    return;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Import.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include <map>",
      "#include <string>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <unistd.h>\n\nStaticDeclaration {\n  void\n  StaticDeclaration::dumpDeclarations () const\n  {\n      return;\n  }\n}"
  },
  {
    "function_name": "registerDeclarations",
    "container": "StaticDeclaration",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/StaticDeclaration.cc",
    "lines": "87-237",
    "snippet": "void\nStaticDeclaration::registerDeclarations (const char *filename,\n\t\t\t\t\t declaration_t *declarations)\n{\n    if (declarations == 0)\n    {\n\treturn;\n    }\n\n    SymbolTable *table = m_declTable;\n    const Y2Namespace *name_space = 0;\n    static const Point *builtin_point = new Point (\"<builtin>\");\n    const Point *namespace_point = builtin_point;\t\t// declarations default to builtin\n    declaration_t *namespace_decl = 0;\n\n    std::pair <std::string, Y2Namespace *> *track_info = 0;\n\n    while (declarations->name != 0)\n    {\n#if DO_DEBUG\n\ty2debug( \"Registering %s\", declarations->name );\n#endif\n\tconst char *name = declarations->name;\n\n\tif (*name == 0)\t\t// exit on empty name\n\t    break;\n\n\tif ((declarations->flags & (DECL_WILD|DECL_SYMBOL)) == (DECL_WILD|DECL_SYMBOL))\n\t{\n\t    y2internal (\"Declaration of %s::%s combines wildcard and symbol\\n\", filename, name);\n\t}\n\telse if ((declarations->flags & DECL_NAMESPACE) != 0)\t\t// switch namespace\n\t{\n\t    // new namespace, clear possibly old track_info\n\t    if (track_info != 0)\n\t    {\n\t\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n\t\tm_active_predefined.push_back (*track_info);\n\t\ttrack_info = 0;\n\t    }\n#if DO_DEBUG\n\t    y2debug (\"NAMESPACE (%s)\", name);\n#endif\n            declarations->name_space = namespace_decl;\n\n\t    TableEntry *tentry = table->find (name);\n\t    if (tentry != 0\t\t\t\t\t\t// name already exists\n\t\t&& tentry->sentry()->isNamespace())\t\t\t//   as namespace\n\t    {\n\t\tname_space = tentry->sentry()->nameSpace();\n\t    }\n\t    else if (*name == 0)\t\t\t\t\t// reset namespace\n\t    {\n\t\ttable = m_declTable;\n\t\tname_space = 0;\n\t\tnamespace_point = builtin_point;\n\t    }\n\t    else\t\t\t\t\t\t\t// open up new namespace\n\t    {\n\t\tbool is_predefined = false;\n\n\t\tif (tentry != 0\n\t\t    && tentry->sentry()->isPredefined())\t\t//   replace predefined\n\t\t{\n\t\t    table->remove (tentry);\n\t\t    is_predefined = true;\n\t\t}\n\n\t\t// create definition container for namespace\n\t\tYBlock *block = new YBlock (filename, YBlock::b_namespace);\n\t\tblock->setName (string (name));\n\n\t\tY2Namespace *namespaceNamespace = (Y2Namespace *)block;\n\t\tnamespaceNamespace->createTable();\n\t\tSymbolTable *namespaceTable = block->table();\n\n\t\t// create SymbolEntry::c_namespace for the namespace to be entered into the global table\n\t\tSymbolEntryPtr sentry = new YSymbolEntry (name, Type::Unspec, namespaceTable);\n\n#if DO_DEBUG\n\t\ty2debug (\"Entered Namespace '%s' (block %p) into namespaceTable %p\", name, block, namespaceTable);\n#endif\n\n\t\t// enter into global table\n\t\tnamespace_point = new Point (filename);\n\t\ttable->enter (name, sentry, namespace_point);\n\n\t\t// all further definitions go into this namespace\n\t\t//   -> make it the new global table\n\t\ttable = namespaceTable;\n\t\tnamespace_decl = declarations;\n\n\t\tif (is_predefined)\n\t\t{\n\t\t    // save tracking info, trigger 'Import' _after_ all symbols have been added\n\t\t    track_info = new std::pair<std::string, Y2Namespace *> (name, namespaceNamespace);\n\t\t}\n\t    }\n\t}\n\telse\t// normal entry, not namespace\n\t{\n\t    declarations->name_space = namespace_decl;\n\t    string signature = declarations->signature;\n\n\t    constTypePtr type = Type::fromSignature (signature);\n\t    if (type == 0\n\t\t|| type->isError()\n\t\t|| type->isUnspec()\n\t\t|| type->isWildcard())\n\t    {\n\t\ty2error (\"Invalid signature %s::%s:'%s'\\n\", filename, name, signature.c_str());\n\t\treturn;\n\t    }\n\n#if DO_DEBUG\ny2debug(\"%s sig[%s] type[%s]\", name, signature.c_str(), type->toString().c_str());\n#endif\n#if 0\n\t    if (type->hasFlex()\n\t\t&& (declarations->flags & DECL_FLEX) == 0)\n\t    {\n\t\ty2error (\"%s:'%s' without DECL_FLEX\", name, declarations->signature);\n\t\treturn;\n\t    }\n#endif\n\t    declarations->type = type;\n\n\t    SymbolEntryPtr sentry = new YSymbolEntry (name, type, declarations, name_space);\n\t    declarations->tentry = table->enter (name, sentry, new Point (sentry, 0, namespace_point));\n\n#ifdef BUILTIN_STATISTICS\n\t    FILE *fout = fopen (\"/tmp/builtin-register.txt\", \"a\");\n\t    if (fout) {\n\t\tfprintf (fout, \"%s %s\\n\", declarations->name, declarations->signature);\n\t\tfclose (fout);\n\t    }\n#endif\n\t}\n\tdeclarations++;\n    }\n\n    // clear possibly old track_info\n    if (track_info != 0)\n    {\n\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n\tm_active_predefined.push_back (*track_info);\n\ttrack_info = 0;\n    }\n\n    return;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Import.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include <map>",
      "#include <string>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "static const char *predefined[] = {\n  \"UI\", \"WFM\", \"SCR\", \"Pkg\", 0\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_active_predefined.push_back",
          "args": [
            "*track_info"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fout"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fout",
            "\"%s %s\\n\"",
            "declarations->name",
            "declarations->signature"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/tmp/builtin-register.txt\"",
            "\"a\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table->enter",
          "args": [
            "name",
            "sentry",
            "new Point (sentry, 0, namespace_point)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"%s:'%s' without DECL_FLEX\"",
            "name",
            "declarations->signature"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->hasFlex",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"%s sig[%s] type[%s]\"",
            "name",
            "signature.c_str()",
            "type->toString().c_str()"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "signature.c_str",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Invalid signature %s::%s:'%s'\\n\"",
            "filename",
            "name",
            "signature.c_str()"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signature.c_str",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->isWildcard",
          "args": [],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "isWildcard",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "294-294",
          "snippet": "bool isWildcard () const\t{ return m_kind == WildcardT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isWildcard () const\t{ return m_kind == WildcardT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isUnspec",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isError",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "isError",
          "container": "YCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "76-80",
          "snippet": "bool\nYCode::isError() const\n{\n    return false; \t\t// TODO unused in practice?\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  bool\n  YCode::isError() const\n  {\n      return false; \t\t// TODO unused in practice?\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Type::fromSignature",
          "args": [
            "signature"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "fromSignature",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/TypeStatics.cc",
          "lines": "280-512",
          "snippet": "constTypePtr\nType::fromSignature (const char ** signature)\n{\n    if ((signature == 0)\n\t|| (*signature == 0))\n    {\n\treturn 0;\n    }\n    if (**signature == 0)\n    {\n\treturn Type::Unspec;\n    }\n\n    constTypePtr t = 0;\n\n    bool as_const = false;\n\n    const char *signature_copy = *signature;\n    const char *signature_start = *signature;\n\n//    y2debug (\"Type::fromSignature (\\\"%s\\\")\\n\", *signature);\n\n    int k = nextToken (signature);\n\n    if (k == -1)\t\t// const\n    {\n//\ty2debug (\"Const !\");\n\tas_const = true;\n\tsignature_copy = *signature;\n\tk = nextToken (signature);\n    }\n\n    char next = 0;\n\n    switch (k)\n    {\n\tcase AnyT:\t\tt = (as_const) ? Type::ConstAny : Type::Any; break;\n\tcase BooleanT:\t\tt = (as_const) ? Type::ConstBoolean : Type::Boolean; break;\n\tcase ByteblockT:\tt = (as_const) ? Type::ConstByteblock : Type::Byteblock; break;\n\tcase ErrorT:\t\tt = Type::Error; break;\n\tcase FlexT:\t\tt = (as_const) ? Type::ConstFlex : Type::Flex; break;\n\tcase FloatT:\t\tt = (as_const) ? Type::ConstFloat : Type::Float; break;\n\tcase IntegerT:\t\tt = (as_const) ? Type::ConstInteger : Type::Integer; break;\n\tcase LocaleT:\t\tt = (as_const) ? Type::ConstLocale : Type::Locale; break;\n\tcase PathT:\t\tt = (as_const) ? Type::ConstPath : Type::Path; break;\n\tcase StringT:\t\tt = (as_const) ? Type::ConstString : Type::String; break;\n\tcase SymbolT:\t\tt = (as_const) ? Type::ConstSymbol : Type::Symbol; break;\n\tcase TermT:\t\tt = (as_const) ? Type::ConstTerm : Type::Term; break;\n\tcase VoidT:\t\tt = (as_const) ? Type::ConstVoid : Type::Void; break;\n\tcase WildcardT:\t\tt = Type::Wildcard; break;\n\n\t// codes\n\tcase VariableT:\t\tk = VariableT; next = '<'; break;\n\tcase '(':\t\tk = FunctionT; break;\n\n\t// constructors\n\tcase BlockT:\t\tk = BlockT; next = '<'; break;\n\tcase ListT:\t\tk = ListT; next = '<'; break;\n\tcase MapT:\t\tk = MapT; next = '<'; break;\n\tcase TupleT:\t\tk = TupleT; next = '<'; break;\n\tdefault:\n\t    if (k < -100)\n\t    {\n\t\tswitch (k)\n\t\t{\n\t\t    case -101:\tt = (as_const) ? Type::ConstNFlex1 : Type::NFlex1; break;\n\t\t    case -102:\tt = (as_const) ? Type::ConstNFlex2 : Type::NFlex2; break;\n\t\t    case -103:\tt = (as_const) ? Type::ConstNFlex3 : Type::NFlex3; break;\n\t\t    case -104:\tt = (as_const) ? Type::ConstNFlex4 : Type::NFlex4; break;\n\t\t    default:\tt = NFlexTypePtr (new NFlexType (-(k+100))); break;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ty2error (\"Builtin signature code %d [%s] not handled\\n\", **signature, signature_start);\n\t    }\n\tbreak;\n    }\n\n    signature_copy = *signature;\n\n    if (next != 0)\n    {\n\tif (nextToken (signature) != next)\n\t{\n\t    y2error (\"Expecting '%c' at '%s' [Complete signature is '%s']\\n\", next, signature_copy, signature_start);\n\t    return 0;\n\t}\n    }\n\n    if (t == 0)\t\t\t// no base type yet\n    {\n//\ty2debug (\"k %d, signature '%s'\", k, *signature);\n\tif (k == UnspecT)\t// no nothing\n\t{\n\t    y2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n\t    return 0;\n\t}\n\n\tsignature_copy = *signature;\n\tconstTypePtr t1 = fromSignature (signature);\n\n\tif (t1 == 0)\n\t{\n\t    y2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n\t    return 0;\n\t}\n//\ty2debug (\"t1 '%s', k %d, signature '%s'\", t1->toString().c_str(), k, *signature);\n\n\tswitch (k)\n\t{\n\t    case VariableT: t = VariableTypePtr (new VariableType (t1, as_const)); next = '>'; break;\n\t    case BlockT:    t = BlockTypePtr (new BlockType (t1, as_const)); next = '>'; break;\n\t    case ListT:\t    t = ListTypePtr (new ListType (t1, as_const)); next = '>'; break;\n\t    case MapT:\n\t    {\n\t\tsignature_copy = *signature;\n\n\t\tif (nextToken (signature) != ',')\n\t\t{\n\t\t    y2error (\"Expected ',' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n\t\t    return 0;\n\t\t}\n\n\t\tconstTypePtr t2 = fromSignature (signature);\n\t\tif (t2 == 0)\n\t\t{\n\t\t    y2debug (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n\t\t    return 0;\n\t\t}\n\n\t\tt = MapTypePtr (new MapType (t1, t2, as_const));\n\t\tnext = '>'; \n\t    }\n\t    break;\n\t    case TupleT:    t = TupleTypePtr (new TupleType (t1, as_const)); next = 0; break;\n\t    case FunctionT: t = FunctionTypePtr (new FunctionType (t1, as_const)); next = 0; break;\n\t    default:\n\t\ty2error (\"Post-Kind '%d'[%c] not handled\\n\", k, isprint (k) ? k : '?');\n\t\treturn 0;\n\t    break;\n\t}\n\n\tif (next != 0)\n\t{\n\t    if (nextToken (signature) != next)\n\t    {\n\t\ty2error (\"Expected '%c' at '%s' [Complete signature is '%s']\\n\", next, signature_copy, signature_start);\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n    if (t == 0)\n    {\n\treturn 0;\n    }\n\n//    y2debug (\"t '%s', signature '%s', k %d\", t->toString().c_str(), *signature, k);\n\n    signature_copy = *signature;\n    if (**signature == '&')\n    {\n\tTypePtr tr = t->clone();\n\ttr->asReference();\n\tt = tr;\n\tdo { (*signature)++; } while (isspace (**signature));\n    }\n\n    // check for function, it's postfix !\n\n    if (**signature == '(')\n    {\n//\ty2debug (\"function!\");\n\tFunctionTypePtr f (new FunctionType (t, as_const));\n\n\tdo\n\t{\n\t    do { (*signature)++; } while (isspace (**signature));\n\t    if (**signature == ')')\n\t    {\n\t\tbreak;\n\t    }\n\t    signature_copy = *signature;\n\t    constTypePtr t1 = fromSignature (signature);\n\t    if (t1 == 0)\n\t    {\n\t\t*signature = signature_copy;\n\t\tbreak;\n\t    }\n\n\t    f->concat (t1);\n\t}\n\twhile (**signature == ',');\n\n\tif (**signature != ')')\n\t{\n\t    y2error (\"Expected ')' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n\t    return 0;\n\t}\n\n\t(*signature)++;\n\tt = f;\n    }\n    else if (k == TupleT)\n    {\n\tTupleTypePtr tt = t->clone();\n//\ty2debug (\"tuple! '%s', signature '%s'\", tt->toString().c_str(), *signature);\n\twhile (**signature == ',')\n\t{\n\t    (*signature)++;\n\t    signature_copy = *signature;\n\t    constTypePtr t1 = fromSignature (signature);\n\t    if (t1 == 0)\n\t    {\n\t\ty2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n\t\treturn 0;\n\t    }\n\n\t    tt->concat (t1);\n\t}\n\tif (**signature != '>')\n\t{\n\t    y2error (\"Expected '>' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n\t    return 0;\n\t}\n\tt = tt;\n    }\n\n//    y2debug (\"Type::fromSignature Done: '%s' -> '%s' [%s]\\n\", signature_start, t->toString().c_str(), *signature);\n\n    return t;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  constTypePtr\n  Type::fromSignature (const char ** signature)\n  {\n      if ((signature == 0)\n  \t|| (*signature == 0))\n      {\n  \treturn 0;\n      }\n      if (**signature == 0)\n      {\n  \treturn Type::Unspec;\n      }\n  \n      constTypePtr t = 0;\n  \n      bool as_const = false;\n  \n      const char *signature_copy = *signature;\n      const char *signature_start = *signature;\n  \n  //    y2debug (\"Type::fromSignature (\\\"%s\\\")\\n\", *signature);\n  \n      int k = nextToken (signature);\n  \n      if (k == -1)\t\t// const\n      {\n  //\ty2debug (\"Const !\");\n  \tas_const = true;\n  \tsignature_copy = *signature;\n  \tk = nextToken (signature);\n      }\n  \n      char next = 0;\n  \n      switch (k)\n      {\n  \tcase AnyT:\t\tt = (as_const) ? Type::ConstAny : Type::Any; break;\n  \tcase BooleanT:\t\tt = (as_const) ? Type::ConstBoolean : Type::Boolean; break;\n  \tcase ByteblockT:\tt = (as_const) ? Type::ConstByteblock : Type::Byteblock; break;\n  \tcase ErrorT:\t\tt = Type::Error; break;\n  \tcase FlexT:\t\tt = (as_const) ? Type::ConstFlex : Type::Flex; break;\n  \tcase FloatT:\t\tt = (as_const) ? Type::ConstFloat : Type::Float; break;\n  \tcase IntegerT:\t\tt = (as_const) ? Type::ConstInteger : Type::Integer; break;\n  \tcase LocaleT:\t\tt = (as_const) ? Type::ConstLocale : Type::Locale; break;\n  \tcase PathT:\t\tt = (as_const) ? Type::ConstPath : Type::Path; break;\n  \tcase StringT:\t\tt = (as_const) ? Type::ConstString : Type::String; break;\n  \tcase SymbolT:\t\tt = (as_const) ? Type::ConstSymbol : Type::Symbol; break;\n  \tcase TermT:\t\tt = (as_const) ? Type::ConstTerm : Type::Term; break;\n  \tcase VoidT:\t\tt = (as_const) ? Type::ConstVoid : Type::Void; break;\n  \tcase WildcardT:\t\tt = Type::Wildcard; break;\n  \n  \t// codes\n  \tcase VariableT:\t\tk = VariableT; next = '<'; break;\n  \tcase '(':\t\tk = FunctionT; break;\n  \n  \t// constructors\n  \tcase BlockT:\t\tk = BlockT; next = '<'; break;\n  \tcase ListT:\t\tk = ListT; next = '<'; break;\n  \tcase MapT:\t\tk = MapT; next = '<'; break;\n  \tcase TupleT:\t\tk = TupleT; next = '<'; break;\n  \tdefault:\n  \t    if (k < -100)\n  \t    {\n  \t\tswitch (k)\n  \t\t{\n  \t\t    case -101:\tt = (as_const) ? Type::ConstNFlex1 : Type::NFlex1; break;\n  \t\t    case -102:\tt = (as_const) ? Type::ConstNFlex2 : Type::NFlex2; break;\n  \t\t    case -103:\tt = (as_const) ? Type::ConstNFlex3 : Type::NFlex3; break;\n  \t\t    case -104:\tt = (as_const) ? Type::ConstNFlex4 : Type::NFlex4; break;\n  \t\t    default:\tt = NFlexTypePtr (new NFlexType (-(k+100))); break;\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\ty2error (\"Builtin signature code %d [%s] not handled\\n\", **signature, signature_start);\n  \t    }\n  \tbreak;\n      }\n  \n      signature_copy = *signature;\n  \n      if (next != 0)\n      {\n  \tif (nextToken (signature) != next)\n  \t{\n  \t    y2error (\"Expecting '%c' at '%s' [Complete signature is '%s']\\n\", next, signature_copy, signature_start);\n  \t    return 0;\n  \t}\n      }\n  \n      if (t == 0)\t\t\t// no base type yet\n      {\n  //\ty2debug (\"k %d, signature '%s'\", k, *signature);\n  \tif (k == UnspecT)\t// no nothing\n  \t{\n  \t    y2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n  \t    return 0;\n  \t}\n  \n  \tsignature_copy = *signature;\n  \tconstTypePtr t1 = fromSignature (signature);\n  \n  \tif (t1 == 0)\n  \t{\n  \t    y2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n  \t    return 0;\n  \t}\n  //\ty2debug (\"t1 '%s', k %d, signature '%s'\", t1->toString().c_str(), k, *signature);\n  \n  \tswitch (k)\n  \t{\n  \t    case VariableT: t = VariableTypePtr (new VariableType (t1, as_const)); next = '>'; break;\n  \t    case BlockT:    t = BlockTypePtr (new BlockType (t1, as_const)); next = '>'; break;\n  \t    case ListT:\t    t = ListTypePtr (new ListType (t1, as_const)); next = '>'; break;\n  \t    case MapT:\n  \t    {\n  \t\tsignature_copy = *signature;\n  \n  \t\tif (nextToken (signature) != ',')\n  \t\t{\n  \t\t    y2error (\"Expected ',' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n  \t\t    return 0;\n  \t\t}\n  \n  \t\tconstTypePtr t2 = fromSignature (signature);\n  \t\tif (t2 == 0)\n  \t\t{\n  \t\t    y2debug (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n  \t\t    return 0;\n  \t\t}\n  \n  \t\tt = MapTypePtr (new MapType (t1, t2, as_const));\n  \t\tnext = '>'; \n  \t    }\n  \t    break;\n  \t    case TupleT:    t = TupleTypePtr (new TupleType (t1, as_const)); next = 0; break;\n  \t    case FunctionT: t = FunctionTypePtr (new FunctionType (t1, as_const)); next = 0; break;\n  \t    default:\n  \t\ty2error (\"Post-Kind '%d'[%c] not handled\\n\", k, isprint (k) ? k : '?');\n  \t\treturn 0;\n  \t    break;\n  \t}\n  \n  \tif (next != 0)\n  \t{\n  \t    if (nextToken (signature) != next)\n  \t    {\n  \t\ty2error (\"Expected '%c' at '%s' [Complete signature is '%s']\\n\", next, signature_copy, signature_start);\n  \t\treturn 0;\n  \t    }\n  \t}\n      }\n  \n      if (t == 0)\n      {\n  \treturn 0;\n      }\n  \n  //    y2debug (\"t '%s', signature '%s', k %d\", t->toString().c_str(), *signature, k);\n  \n      signature_copy = *signature;\n      if (**signature == '&')\n      {\n  \tTypePtr tr = t->clone();\n  \ttr->asReference();\n  \tt = tr;\n  \tdo { (*signature)++; } while (isspace (**signature));\n      }\n  \n      // check for function, it's postfix !\n  \n      if (**signature == '(')\n      {\n  //\ty2debug (\"function!\");\n  \tFunctionTypePtr f (new FunctionType (t, as_const));\n  \n  \tdo\n  \t{\n  \t    do { (*signature)++; } while (isspace (**signature));\n  \t    if (**signature == ')')\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    signature_copy = *signature;\n  \t    constTypePtr t1 = fromSignature (signature);\n  \t    if (t1 == 0)\n  \t    {\n  \t\t*signature = signature_copy;\n  \t\tbreak;\n  \t    }\n  \n  \t    f->concat (t1);\n  \t}\n  \twhile (**signature == ',');\n  \n  \tif (**signature != ')')\n  \t{\n  \t    y2error (\"Expected ')' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n  \t    return 0;\n  \t}\n  \n  \t(*signature)++;\n  \tt = f;\n      }\n      else if (k == TupleT)\n      {\n  \tTupleTypePtr tt = t->clone();\n  //\ty2debug (\"tuple! '%s', signature '%s'\", tt->toString().c_str(), *signature);\n  \twhile (**signature == ',')\n  \t{\n  \t    (*signature)++;\n  \t    signature_copy = *signature;\n  \t    constTypePtr t1 = fromSignature (signature);\n  \t    if (t1 == 0)\n  \t    {\n  \t\ty2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n  \t\treturn 0;\n  \t    }\n  \n  \t    tt->concat (t1);\n  \t}\n  \tif (**signature != '>')\n  \t{\n  \t    y2error (\"Expected '>' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n  \t    return 0;\n  \t}\n  \tt = tt;\n      }\n  \n  //    y2debug (\"Type::fromSignature Done: '%s' -> '%s' [%s]\\n\", signature_start, t->toString().c_str(), *signature);\n  \n      return t;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "table->enter",
          "args": [
            "name",
            "sentry",
            "namespace_point"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Entered Namespace '%s' (block %p) into namespaceTable %p\"",
            "name",
            "block",
            "namespaceTable"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block->table",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namespaceNamespace->createTable",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "createTable",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "286-293",
          "snippet": "void\nY2Namespace::createTable ()\n{\n    if (m_table == 0)\n    {\n\tm_table = new SymbolTable (-1);\n    }\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  void\n  Y2Namespace::createTable ()\n  {\n      if (m_table == 0)\n      {\n  \tm_table = new SymbolTable (-1);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block->setName",
          "args": [
            "string (name)"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "setName",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "50-54",
          "snippet": "void\nYCPTermRep::setName(string name)\n{\n    s = Ustring (*SymbolEntry::_nameHash, name);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::setName(string name)\n  {\n      s = Ustring (*SymbolEntry::_nameHash, name);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "name"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "table->remove",
          "args": [
            "tentry"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "remove",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "104-113",
          "snippet": "void YCPMapRep::remove(const YCPValue& key)\n{\n    if (!key->isString() && !key->isInteger() && !key->isSymbol())\n    {\n        ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n        return;\n    }\n\n    stl_map.erase (key);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void YCPMapRep::remove(const YCPValue& key)\n  {\n      if (!key->isString() && !key->isInteger() && !key->isSymbol())\n      {\n          ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n          return;\n      }\n  \n      stl_map.erase (key);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tentry->sentry",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "sentry",
          "container": "TableEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "97-101",
          "snippet": "SymbolEntryPtr \nTableEntry::sentry() const\n{\n    return m_entry;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  SymbolEntryPtr \n  TableEntry::sentry() const\n  {\n      return m_entry;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "table->find",
          "args": [
            "name"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"NAMESPACE (%s)\"",
            "name"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2internal",
          "args": [
            "\"Declaration of %s::%s combines wildcard and symbol\\n\"",
            "filename",
            "name"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Registering %s\"",
            "declarations->name"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <unistd.h>\n\n#define DO_DEBUG 0\n\nstatic const char *predefined[] = {\n  \"UI\", \"WFM\", \"SCR\", \"Pkg\", 0\n};\n\nStaticDeclaration {\n  void\n  StaticDeclaration::registerDeclarations (const char *filename,\n  \t\t\t\t\t declaration_t *declarations)\n  {\n      if (declarations == 0)\n      {\n  \treturn;\n      }\n  \n      SymbolTable *table = m_declTable;\n      const Y2Namespace *name_space = 0;\n      static const Point *builtin_point = new Point (\"<builtin>\");\n      const Point *namespace_point = builtin_point;\t\t// declarations default to builtin\n      declaration_t *namespace_decl = 0;\n  \n      std::pair <std::string, Y2Namespace *> *track_info = 0;\n  \n      while (declarations->name != 0)\n      {\n  #if DO_DEBUG\n  \ty2debug( \"Registering %s\", declarations->name );\n  #endif\n  \tconst char *name = declarations->name;\n  \n  \tif (*name == 0)\t\t// exit on empty name\n  \t    break;\n  \n  \tif ((declarations->flags & (DECL_WILD|DECL_SYMBOL)) == (DECL_WILD|DECL_SYMBOL))\n  \t{\n  \t    y2internal (\"Declaration of %s::%s combines wildcard and symbol\\n\", filename, name);\n  \t}\n  \telse if ((declarations->flags & DECL_NAMESPACE) != 0)\t\t// switch namespace\n  \t{\n  \t    // new namespace, clear possibly old track_info\n  \t    if (track_info != 0)\n  \t    {\n  \t\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n  \t\tm_active_predefined.push_back (*track_info);\n  \t\ttrack_info = 0;\n  \t    }\n  #if DO_DEBUG\n  \t    y2debug (\"NAMESPACE (%s)\", name);\n  #endif\n              declarations->name_space = namespace_decl;\n  \n  \t    TableEntry *tentry = table->find (name);\n  \t    if (tentry != 0\t\t\t\t\t\t// name already exists\n  \t\t&& tentry->sentry()->isNamespace())\t\t\t//   as namespace\n  \t    {\n  \t\tname_space = tentry->sentry()->nameSpace();\n  \t    }\n  \t    else if (*name == 0)\t\t\t\t\t// reset namespace\n  \t    {\n  \t\ttable = m_declTable;\n  \t\tname_space = 0;\n  \t\tnamespace_point = builtin_point;\n  \t    }\n  \t    else\t\t\t\t\t\t\t// open up new namespace\n  \t    {\n  \t\tbool is_predefined = false;\n  \n  \t\tif (tentry != 0\n  \t\t    && tentry->sentry()->isPredefined())\t\t//   replace predefined\n  \t\t{\n  \t\t    table->remove (tentry);\n  \t\t    is_predefined = true;\n  \t\t}\n  \n  \t\t// create definition container for namespace\n  \t\tYBlock *block = new YBlock (filename, YBlock::b_namespace);\n  \t\tblock->setName (string (name));\n  \n  \t\tY2Namespace *namespaceNamespace = (Y2Namespace *)block;\n  \t\tnamespaceNamespace->createTable();\n  \t\tSymbolTable *namespaceTable = block->table();\n  \n  \t\t// create SymbolEntry::c_namespace for the namespace to be entered into the global table\n  \t\tSymbolEntryPtr sentry = new YSymbolEntry (name, Type::Unspec, namespaceTable);\n  \n  #if DO_DEBUG\n  \t\ty2debug (\"Entered Namespace '%s' (block %p) into namespaceTable %p\", name, block, namespaceTable);\n  #endif\n  \n  \t\t// enter into global table\n  \t\tnamespace_point = new Point (filename);\n  \t\ttable->enter (name, sentry, namespace_point);\n  \n  \t\t// all further definitions go into this namespace\n  \t\t//   -> make it the new global table\n  \t\ttable = namespaceTable;\n  \t\tnamespace_decl = declarations;\n  \n  \t\tif (is_predefined)\n  \t\t{\n  \t\t    // save tracking info, trigger 'Import' _after_ all symbols have been added\n  \t\t    track_info = new std::pair<std::string, Y2Namespace *> (name, namespaceNamespace);\n  \t\t}\n  \t    }\n  \t}\n  \telse\t// normal entry, not namespace\n  \t{\n  \t    declarations->name_space = namespace_decl;\n  \t    string signature = declarations->signature;\n  \n  \t    constTypePtr type = Type::fromSignature (signature);\n  \t    if (type == 0\n  \t\t|| type->isError()\n  \t\t|| type->isUnspec()\n  \t\t|| type->isWildcard())\n  \t    {\n  \t\ty2error (\"Invalid signature %s::%s:'%s'\\n\", filename, name, signature.c_str());\n  \t\treturn;\n  \t    }\n  \n  #if DO_DEBUG\n  y2debug(\"%s sig[%s] type[%s]\", name, signature.c_str(), type->toString().c_str());\n  #endif\n  #if 0\n  \t    if (type->hasFlex()\n  \t\t&& (declarations->flags & DECL_FLEX) == 0)\n  \t    {\n  \t\ty2error (\"%s:'%s' without DECL_FLEX\", name, declarations->signature);\n  \t\treturn;\n  \t    }\n  #endif\n  \t    declarations->type = type;\n  \n  \t    SymbolEntryPtr sentry = new YSymbolEntry (name, type, declarations, name_space);\n  \t    declarations->tentry = table->enter (name, sentry, new Point (sentry, 0, namespace_point));\n  \n  #ifdef BUILTIN_STATISTICS\n  \t    FILE *fout = fopen (\"/tmp/builtin-register.txt\", \"a\");\n  \t    if (fout) {\n  \t\tfprintf (fout, \"%s %s\\n\", declarations->name, declarations->signature);\n  \t\tfclose (fout);\n  \t    }\n  #endif\n  \t}\n  \tdeclarations++;\n      }\n  \n      // clear possibly old track_info\n      if (track_info != 0)\n      {\n  \tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n  \tm_active_predefined.push_back (*track_info);\n  \ttrack_info = 0;\n      }\n  \n      return;\n  }\n}"
  },
  {
    "function_name": "~StaticDeclaration",
    "container": "StaticDeclaration",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/StaticDeclaration.cc",
    "lines": "75-78",
    "snippet": "StaticDeclaration::~StaticDeclaration ()\n{\n    delete m_declTable;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Import.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include <map>",
      "#include <string>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <unistd.h>\n\nStaticDeclaration {\n  StaticDeclaration::~StaticDeclaration ()\n  {\n      delete m_declTable;\n  }\n}"
  },
  {
    "function_name": "StaticDeclaration",
    "container": "StaticDeclaration",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/StaticDeclaration.cc",
    "lines": "57-72",
    "snippet": "StaticDeclaration::StaticDeclaration()\n{\n    m_declTable = new SymbolTable(-1);\n#if DO_DEBUG\n    y2debug (\"m_declTable %p\", m_declTable);\n#endif\n    const char **pptr = predefined;\n    SymbolEntryPtr sentry;\n    Point *point = new Point (\"<predefined>\");\n    while (*pptr != 0)\n    {\n\tsentry = new YSymbolEntry (0, 0, *pptr, SymbolEntry::c_predefined, Type::Unspec, 0);\n\tm_declTable->enter (*pptr, sentry, new Point (sentry, 0, point));\n\tpptr++;\n    }\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Import.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include <map>",
      "#include <string>",
      "#include <stdio.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "static const char *predefined[] = {\n  \"UI\", \"WFM\", \"SCR\", \"Pkg\", 0\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_declTable->enter",
          "args": [
            "*pptr",
            "sentry",
            "new Point (sentry, 0, point)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"m_declTable %p\"",
            "m_declTable"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <unistd.h>\n\n#define DO_DEBUG 0\n\nstatic const char *predefined[] = {\n  \"UI\", \"WFM\", \"SCR\", \"Pkg\", 0\n};\n\nStaticDeclaration {\n  StaticDeclaration::StaticDeclaration()\n  {\n      m_declTable = new SymbolTable(-1);\n  #if DO_DEBUG\n      y2debug (\"m_declTable %p\", m_declTable);\n  #endif\n      const char **pptr = predefined;\n      SymbolEntryPtr sentry;\n      Point *point = new Point (\"<predefined>\");\n      while (*pptr != 0)\n      {\n  \tsentry = new YSymbolEntry (0, 0, *pptr, SymbolEntry::c_predefined, Type::Unspec, 0);\n  \tm_declTable->enter (*pptr, sentry, new Point (sentry, 0, point));\n  \tpptr++;\n      }\n  }\n}"
  }
]