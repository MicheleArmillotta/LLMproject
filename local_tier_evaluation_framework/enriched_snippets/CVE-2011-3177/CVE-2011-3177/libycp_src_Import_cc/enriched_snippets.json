[
  {
    "function_name": "name",
    "container": "Import",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Import.cc",
    "lines": "189-193",
    "snippet": "string\nImport::name () const\n{\n    return m_name;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Import.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Import.h\"\n#include <libintl.h>\n\nImport {\n  string\n  Import::name () const\n  {\n      return m_name;\n  }\n}"
  },
  {
    "function_name": "enableTracking",
    "container": "Import",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Import.cc",
    "lines": "165-186",
    "snippet": "void\nImport::enableTracking ()\n{\n    m_disable_tracking--;\n#if DO_DEBUG\n    y2debug (\"Import::enableTracking (%d)\", m_disable_tracking);\n#endif\n    if (m_disable_tracking > 0)\n    {\n\treturn;\n    }\n    while (!m_table_stack.empty())\n    {\n\tSymbolTable *table = m_table_stack.top().second;\n#if DO_DEBUG\n\ty2debug (\"enableUsage (%s:%p)\", m_table_stack.top().first.c_str(), table);\n#endif\n\ttable->enableUsage();\n\tm_table_stack.pop();\n    }\n    return;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Import.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "int Import::m_disable_tracking = 0;",
      "std::stack <std::pair <string, SymbolTable *> > Import::m_table_stack;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_table_stack.pop",
          "args": [],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "pop",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "159-167",
          "snippet": "void\nSymbolEntry::pop ()\n{\n    if (! m_recurse_stack)\n\treturn;\n\n    m_value = m_recurse_stack->top ();\n    m_recurse_stack->pop ();\n}",
          "includes": [
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  void\n  SymbolEntry::pop ()\n  {\n      if (! m_recurse_stack)\n  \treturn;\n  \n      m_value = m_recurse_stack->top ();\n      m_recurse_stack->pop ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "table->enableUsage",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "enableUsage",
          "container": "SymbolTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "427-434",
          "snippet": "void\nSymbolTable::enableUsage ()\n{\n#if DO_DEBUG\n    y2debug (\"SymbolTable[%p]::enableUsage\", this);\n#endif\n    m_track_usage = true;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\n#define DO_DEBUG 0\n\nSymbolTable {\n  void\n  SymbolTable::enableUsage ()\n  {\n  #if DO_DEBUG\n      y2debug (\"SymbolTable[%p]::enableUsage\", this);\n  #endif\n      m_track_usage = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"enableUsage (%s:%p)\"",
            "m_table_stack.top().first.c_str()",
            "table"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_table_stack.top",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_table_stack.top",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_table_stack.top",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_table_stack.empty",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Import::enableTracking (%d)\"",
            "m_disable_tracking"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Import.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nint Import::m_disable_tracking = 0;\nstd::stack <std::pair <string, SymbolTable *> > Import::m_table_stack;\n\nImport {\n  void\n  Import::enableTracking ()\n  {\n      m_disable_tracking--;\n  #if DO_DEBUG\n      y2debug (\"Import::enableTracking (%d)\", m_disable_tracking);\n  #endif\n      if (m_disable_tracking > 0)\n      {\n  \treturn;\n      }\n      while (!m_table_stack.empty())\n      {\n  \tSymbolTable *table = m_table_stack.top().second;\n  #if DO_DEBUG\n  \ty2debug (\"enableUsage (%s:%p)\", m_table_stack.top().first.c_str(), table);\n  #endif\n  \ttable->enableUsage();\n  \tm_table_stack.pop();\n      }\n      return;\n  }\n}"
  },
  {
    "function_name": "disableTracking",
    "container": "Import",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Import.cc",
    "lines": "154-162",
    "snippet": "void\nImport::disableTracking ()\n{\n    m_disable_tracking++;\n#if DO_DEBUG\n    y2debug (\"Import::disableTracking (%d)\", m_disable_tracking);\n#endif\n    return;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Import.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "int Import::m_disable_tracking = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Import::disableTracking (%d)\"",
            "m_disable_tracking"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Import.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nint Import::m_disable_tracking = 0;\n\nImport {\n  void\n  Import::disableTracking ()\n  {\n      m_disable_tracking++;\n  #if DO_DEBUG\n      y2debug (\"Import::disableTracking (%d)\", m_disable_tracking);\n  #endif\n      return;\n  }\n}"
  },
  {
    "function_name": "import",
    "container": "Import",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Import.cc",
    "lines": "63-147",
    "snippet": "int\nImport::import (const string &name, Y2Namespace *preloaded_namespace)\n{\n    if (!m_name->empty())\n    {\n\tycp2error (\"Import::import(%s) called again but already initialized with '%s'\", name.c_str(), m_name->c_str());\n\treturn -1;\n    }\n\n#if DO_DEBUG\n    y2debug (\"Import::import (%s), preloaded_namespace %p\", name.c_str(), preloaded_namespace);\n#endif\n\n    m_name = Ustring (*SymbolEntry::_nameHash, name);\n\n    m_module = m_active_modules.find (m_name);\n\n    SymbolTable *table;\n\n    if (m_module == m_active_modules.end())\n    {\n\tconst char *cname = name.c_str();\n\tY2Namespace* name_space = preloaded_namespace;\n\n\tif (name_space == 0)\n\t{\n#if DO_DEBUG\n\t    y2debug (\"Loading module '%s'\", cname);\n#endif\n\t    Y2Component* comp = Y2ComponentBroker::getNamespaceComponent (cname);\t// find component for name\n\n\t    if (comp == 0)\n\t    {\n\t\tycp2error (\"Loading module '%s' failed\", cname);\n\t\ty2error (\"No matching component found\");\n\t\treturn -1;\n\t    }\n\n\t    y2debug (\"Component found: %s\", comp->name().c_str());\n\n\t    name_space = comp->import (cname);\t\t\t\t\t\t// do the bytecode import\n\t    if (name_space == NULL)\n\t    {\n\t\tycp2error (\"Loading module '%s' failed\", cname);\n\t\treturn -1;\n\t    }\n\t}\n\n\ttable = name_space->table();\n\tif (table == 0)\n\t{\n\t    ycp2error (\"No table associated to module '%s'\", cname);\n\t    return -1;\n\t}\n\n\tm_active_modules.insert (std::make_pair (m_name, name_space));\t\t\t// insert to list of known modules\n#if DO_DEBUG\n\ty2debug (\"Module '%s' loaded, name_space @%p, table @%p\", cname, name_space, table);\n#endif\n\n\tm_module = m_active_modules.find (m_name);\n\n\ttable->startUsage();\n    }\n    else\n    {\n\ttable = m_module->second->table();\n#if DO_DEBUG\n\ty2debug (\"Module '%s' already loaded, name_space %p, table %p\", m_name->c_str(), m_module->second, table);\n#endif\n\tif (table == 0)\n\t{\n\t    y2internal (\"Oops, no table for already loaded module '%s'\\n\", m_name->c_str());\n\t    exit (1);\n\t}\n    }\n\n    if (m_disable_tracking)\n    {\n\ttable->disableUsage();\n\tm_table_stack.push (std::make_pair (m_name, table));\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Import.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "Import::module_map Import::m_active_modules;",
      "int Import::m_disable_tracking = 0;",
      "std::stack <std::pair <string, SymbolTable *> > Import::m_table_stack;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_table_stack.push",
          "args": [
            "std::make_pair (m_name, table)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "m_name",
            "table"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table->disableUsage",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "disableUsage",
          "container": "SymbolTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "437-444",
          "snippet": "void\nSymbolTable::disableUsage ()\n{\n#if DO_DEBUG\n    y2debug (\"SymbolTable[%p]::disableUsage\", this);\n#endif\n    m_track_usage = false;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\n#define DO_DEBUG 0\n\nSymbolTable {\n  void\n  SymbolTable::disableUsage ()\n  {\n  #if DO_DEBUG\n      y2debug (\"SymbolTable[%p]::disableUsage\", this);\n  #endif\n      m_track_usage = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2internal",
          "args": [
            "\"Oops, no table for already loaded module '%s'\\n\"",
            "m_name->c_str()"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name->c_str",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Module '%s' already loaded, name_space %p, table %p\"",
            "m_name->c_str()",
            "m_module->second",
            "table"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name->c_str",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_module->second->table",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table->startUsage",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "startUsage",
          "container": "SymbolTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "387-398",
          "snippet": "void\nSymbolTable::startUsage ()\n{\n#if DO_DEBUG\n    y2debug (\"SymbolTable[%p]::startUsage\", this);\n#endif\n    if (m_used == 0)\n    {\n\tm_used = new (std::map<const char *, TableEntry *>);\n    }\n    return;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\n#define DO_DEBUG 0\n\nSymbolTable {\n  void\n  SymbolTable::startUsage ()\n  {\n  #if DO_DEBUG\n      y2debug (\"SymbolTable[%p]::startUsage\", this);\n  #endif\n      if (m_used == 0)\n      {\n  \tm_used = new (std::map<const char *, TableEntry *>);\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_active_modules.find",
          "args": [
            "m_name"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Module '%s' loaded, name_space @%p, table @%p\"",
            "cname",
            "name_space",
            "table"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_active_modules.insert",
          "args": [
            "std::make_pair (m_name, name_space)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "m_name",
            "name_space"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"No table associated to module '%s'\"",
            "cname"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_space->table",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Loading module '%s' failed\"",
            "cname"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comp->import",
          "args": [
            "cname"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Component found: %s\"",
            "comp->name().c_str()"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comp->name",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Import",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Import.cc",
          "lines": "189-193",
          "snippet": "string\nImport::name () const\n{\n    return m_name;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Import.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Import.h\"\n#include <libintl.h>\n\nImport {\n  string\n  Import::name () const\n  {\n      return m_name;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"No matching component found\""
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Loading module '%s' failed\"",
            "cname"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2ComponentBroker::getNamespaceComponent",
          "args": [
            "cname"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Loading module '%s'\"",
            "cname"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_active_modules.end",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_active_modules.find",
          "args": [
            "m_name"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Ustring",
          "args": [
            "*SymbolEntry::_nameHash",
            "name"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Import::import (%s), preloaded_namespace %p\"",
            "name.c_str()",
            "preloaded_namespace"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Import::import(%s) called again but already initialized with '%s'\"",
            "name.c_str()",
            "m_name->c_str()"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name->c_str",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name->empty",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Import.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nImport::module_map Import::m_active_modules;\nint Import::m_disable_tracking = 0;\nstd::stack <std::pair <string, SymbolTable *> > Import::m_table_stack;\n\nImport {\n  int\n  Import::import (const string &name, Y2Namespace *preloaded_namespace)\n  {\n      if (!m_name->empty())\n      {\n  \tycp2error (\"Import::import(%s) called again but already initialized with '%s'\", name.c_str(), m_name->c_str());\n  \treturn -1;\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"Import::import (%s), preloaded_namespace %p\", name.c_str(), preloaded_namespace);\n  #endif\n  \n      m_name = Ustring (*SymbolEntry::_nameHash, name);\n  \n      m_module = m_active_modules.find (m_name);\n  \n      SymbolTable *table;\n  \n      if (m_module == m_active_modules.end())\n      {\n  \tconst char *cname = name.c_str();\n  \tY2Namespace* name_space = preloaded_namespace;\n  \n  \tif (name_space == 0)\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"Loading module '%s'\", cname);\n  #endif\n  \t    Y2Component* comp = Y2ComponentBroker::getNamespaceComponent (cname);\t// find component for name\n  \n  \t    if (comp == 0)\n  \t    {\n  \t\tycp2error (\"Loading module '%s' failed\", cname);\n  \t\ty2error (\"No matching component found\");\n  \t\treturn -1;\n  \t    }\n  \n  \t    y2debug (\"Component found: %s\", comp->name().c_str());\n  \n  \t    name_space = comp->import (cname);\t\t\t\t\t\t// do the bytecode import\n  \t    if (name_space == NULL)\n  \t    {\n  \t\tycp2error (\"Loading module '%s' failed\", cname);\n  \t\treturn -1;\n  \t    }\n  \t}\n  \n  \ttable = name_space->table();\n  \tif (table == 0)\n  \t{\n  \t    ycp2error (\"No table associated to module '%s'\", cname);\n  \t    return -1;\n  \t}\n  \n  \tm_active_modules.insert (std::make_pair (m_name, name_space));\t\t\t// insert to list of known modules\n  #if DO_DEBUG\n  \ty2debug (\"Module '%s' loaded, name_space @%p, table @%p\", cname, name_space, table);\n  #endif\n  \n  \tm_module = m_active_modules.find (m_name);\n  \n  \ttable->startUsage();\n      }\n      else\n      {\n  \ttable = m_module->second->table();\n  #if DO_DEBUG\n  \ty2debug (\"Module '%s' already loaded, name_space %p, table %p\", m_name->c_str(), m_module->second, table);\n  #endif\n  \tif (table == 0)\n  \t{\n  \t    y2internal (\"Oops, no table for already loaded module '%s'\\n\", m_name->c_str());\n  \t    exit (1);\n  \t}\n      }\n  \n      if (m_disable_tracking)\n      {\n  \ttable->disableUsage();\n  \tm_table_stack.push (std::make_pair (m_name, table));\n      }\n  \n      return 0;\n  }\n}"
  },
  {
    "function_name": "~Import",
    "container": "Import",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Import.cc",
    "lines": "58-60",
    "snippet": "Import::~Import ()\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Import.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Import.h\"\n#include <libintl.h>\n\nImport {\n  Import::~Import ()\n  {\n  }\n}"
  },
  {
    "function_name": "Import",
    "container": "Import",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Import.cc",
    "lines": "48-55",
    "snippet": "Import::Import (const string &name, Y2Namespace *preloaded_namespace)\n    : m_name (SymbolEntry::emptyUstring)\n{\n    if (import (name, preloaded_namespace) != 0)\n    {\n\tm_name = SymbolEntry::emptyUstring;\t\t\t// mark as failed import\n    }\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Import.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "import",
          "args": [
            "name",
            "preloaded_namespace"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "import",
          "container": "Import",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Import.cc",
          "lines": "63-147",
          "snippet": "int\nImport::import (const string &name, Y2Namespace *preloaded_namespace)\n{\n    if (!m_name->empty())\n    {\n\tycp2error (\"Import::import(%s) called again but already initialized with '%s'\", name.c_str(), m_name->c_str());\n\treturn -1;\n    }\n\n#if DO_DEBUG\n    y2debug (\"Import::import (%s), preloaded_namespace %p\", name.c_str(), preloaded_namespace);\n#endif\n\n    m_name = Ustring (*SymbolEntry::_nameHash, name);\n\n    m_module = m_active_modules.find (m_name);\n\n    SymbolTable *table;\n\n    if (m_module == m_active_modules.end())\n    {\n\tconst char *cname = name.c_str();\n\tY2Namespace* name_space = preloaded_namespace;\n\n\tif (name_space == 0)\n\t{\n#if DO_DEBUG\n\t    y2debug (\"Loading module '%s'\", cname);\n#endif\n\t    Y2Component* comp = Y2ComponentBroker::getNamespaceComponent (cname);\t// find component for name\n\n\t    if (comp == 0)\n\t    {\n\t\tycp2error (\"Loading module '%s' failed\", cname);\n\t\ty2error (\"No matching component found\");\n\t\treturn -1;\n\t    }\n\n\t    y2debug (\"Component found: %s\", comp->name().c_str());\n\n\t    name_space = comp->import (cname);\t\t\t\t\t\t// do the bytecode import\n\t    if (name_space == NULL)\n\t    {\n\t\tycp2error (\"Loading module '%s' failed\", cname);\n\t\treturn -1;\n\t    }\n\t}\n\n\ttable = name_space->table();\n\tif (table == 0)\n\t{\n\t    ycp2error (\"No table associated to module '%s'\", cname);\n\t    return -1;\n\t}\n\n\tm_active_modules.insert (std::make_pair (m_name, name_space));\t\t\t// insert to list of known modules\n#if DO_DEBUG\n\ty2debug (\"Module '%s' loaded, name_space @%p, table @%p\", cname, name_space, table);\n#endif\n\n\tm_module = m_active_modules.find (m_name);\n\n\ttable->startUsage();\n    }\n    else\n    {\n\ttable = m_module->second->table();\n#if DO_DEBUG\n\ty2debug (\"Module '%s' already loaded, name_space %p, table %p\", m_name->c_str(), m_module->second, table);\n#endif\n\tif (table == 0)\n\t{\n\t    y2internal (\"Oops, no table for already loaded module '%s'\\n\", m_name->c_str());\n\t    exit (1);\n\t}\n    }\n\n    if (m_disable_tracking)\n    {\n\ttable->disableUsage();\n\tm_table_stack.push (std::make_pair (m_name, table));\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Import.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "Import::module_map Import::m_active_modules;",
            "int Import::m_disable_tracking = 0;",
            "std::stack <std::pair <string, SymbolTable *> > Import::m_table_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Import.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nImport::module_map Import::m_active_modules;\nint Import::m_disable_tracking = 0;\nstd::stack <std::pair <string, SymbolTable *> > Import::m_table_stack;\n\nImport {\n  int\n  Import::import (const string &name, Y2Namespace *preloaded_namespace)\n  {\n      if (!m_name->empty())\n      {\n  \tycp2error (\"Import::import(%s) called again but already initialized with '%s'\", name.c_str(), m_name->c_str());\n  \treturn -1;\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"Import::import (%s), preloaded_namespace %p\", name.c_str(), preloaded_namespace);\n  #endif\n  \n      m_name = Ustring (*SymbolEntry::_nameHash, name);\n  \n      m_module = m_active_modules.find (m_name);\n  \n      SymbolTable *table;\n  \n      if (m_module == m_active_modules.end())\n      {\n  \tconst char *cname = name.c_str();\n  \tY2Namespace* name_space = preloaded_namespace;\n  \n  \tif (name_space == 0)\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"Loading module '%s'\", cname);\n  #endif\n  \t    Y2Component* comp = Y2ComponentBroker::getNamespaceComponent (cname);\t// find component for name\n  \n  \t    if (comp == 0)\n  \t    {\n  \t\tycp2error (\"Loading module '%s' failed\", cname);\n  \t\ty2error (\"No matching component found\");\n  \t\treturn -1;\n  \t    }\n  \n  \t    y2debug (\"Component found: %s\", comp->name().c_str());\n  \n  \t    name_space = comp->import (cname);\t\t\t\t\t\t// do the bytecode import\n  \t    if (name_space == NULL)\n  \t    {\n  \t\tycp2error (\"Loading module '%s' failed\", cname);\n  \t\treturn -1;\n  \t    }\n  \t}\n  \n  \ttable = name_space->table();\n  \tif (table == 0)\n  \t{\n  \t    ycp2error (\"No table associated to module '%s'\", cname);\n  \t    return -1;\n  \t}\n  \n  \tm_active_modules.insert (std::make_pair (m_name, name_space));\t\t\t// insert to list of known modules\n  #if DO_DEBUG\n  \ty2debug (\"Module '%s' loaded, name_space @%p, table @%p\", cname, name_space, table);\n  #endif\n  \n  \tm_module = m_active_modules.find (m_name);\n  \n  \ttable->startUsage();\n      }\n      else\n      {\n  \ttable = m_module->second->table();\n  #if DO_DEBUG\n  \ty2debug (\"Module '%s' already loaded, name_space %p, table %p\", m_name->c_str(), m_module->second, table);\n  #endif\n  \tif (table == 0)\n  \t{\n  \t    y2internal (\"Oops, no table for already loaded module '%s'\\n\", m_name->c_str());\n  \t    exit (1);\n  \t}\n      }\n  \n      if (m_disable_tracking)\n      {\n  \ttable->disableUsage();\n  \tm_table_stack.push (std::make_pair (m_name, table));\n      }\n  \n      return 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Import.h\"\n#include <libintl.h>\n\nImport {\n  Import::Import (const string &name, Y2Namespace *preloaded_namespace)\n      : m_name (SymbolEntry::emptyUstring)\n  {\n      if (import (name, preloaded_namespace) != 0)\n      {\n  \tm_name = SymbolEntry::emptyUstring;\t\t\t// mark as failed import\n      }\n  }\n}"
  },
  {
    "function_name": "Import",
    "container": "Import",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Import.cc",
    "lines": "42-45",
    "snippet": "Import::Import ()\n    : m_name (SymbolEntry::emptyUstring)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Import.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Import.h\"\n#include <libintl.h>\n\nImport {\n  Import::Import ()\n      : m_name (SymbolEntry::emptyUstring)\n  {\n  }\n}"
  }
]