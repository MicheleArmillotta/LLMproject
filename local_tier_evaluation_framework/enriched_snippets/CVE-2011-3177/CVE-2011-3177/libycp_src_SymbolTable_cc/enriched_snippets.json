[
  {
    "function_name": "forEach",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "1024-1044",
    "snippet": "void\nSymbolTable::forEach(SymbolTable::EntryConsumer consumer) const\n{\n    for (int i=0; i < m_prime; i++)\n    {\n\tif (m_table[i] != 0)\n\t{\n\t    SymbolEntryPtr s = m_table[i]->sentry ();\n\t    if (! consumer (*s))\n\t\treturn;\n\n\t    // walk the chain of colliding entries\n\t    for (TableEntry* t_next = m_table[i]->m_next; t_next; t_next = t_next->m_next)\n\t    {\n\t\tSymbolEntryPtr s = t_next->sentry ();\n\t\tif (! consumer (*s))\n\t\t    return;\n\t    }\n\t}\n    }\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "consumer",
          "args": [
            "*s"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_next->sentry",
          "args": [],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "sentry",
          "container": "TableEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "97-101",
          "snippet": "SymbolEntryPtr \nTableEntry::sentry() const\n{\n    return m_entry;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  SymbolEntryPtr \n  TableEntry::sentry() const\n  {\n      return m_entry;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "consumer",
          "args": [
            "*s"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  void\n  SymbolTable::forEach(SymbolTable::EntryConsumer consumer) const\n  {\n      for (int i=0; i < m_prime; i++)\n      {\n  \tif (m_table[i] != 0)\n  \t{\n  \t    SymbolEntryPtr s = m_table[i]->sentry ();\n  \t    if (! consumer (*s))\n  \t\treturn;\n  \n  \t    // walk the chain of colliding entries\n  \t    for (TableEntry* t_next = m_table[i]->m_next; t_next; t_next = t_next->m_next)\n  \t    {\n  \t\tSymbolEntryPtr s = t_next->sentry ();\n  \t\tif (! consumer (*s))\n  \t\t    return;\n  \t    }\n  \t}\n      }\n  }\n}"
  },
  {
    "function_name": "tableCopy",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "995-1021",
    "snippet": "void\nSymbolTable::tableCopy(Y2Namespace* tofill) const\n{\n    for (int i=0; i < m_prime; i++)\n    {\n\tif (m_table[i] != 0)\n\t{\n\t\tSymbolEntryPtr s = m_table[i]->sentry ();\n\t\ty2milestone (\"Converting symbolentry for '%s'\", m_table[i]->key ());\n\t\ttofill->enterSymbol (new SymbolEntry (tofill, i, m_table[i]->key ()\n\t\t    , s->category (), s->type ()));\n\t\t\n\t\t// now, convert the m_next stuff, others should be fine\n\t\t// because the parser is running using the local namespace\n\t\t// FIXME: what about the overloaded ones?\n\t\tTableEntry* t_next = m_table[i]->m_next;\n\t\twhile (t_next)\n\t\t{\n\t\t    SymbolEntryPtr s = t_next->sentry ();\n\t\t    y2milestone (\"Converting symbolentry for '%s'\", t_next->key ());\n\t\t    tofill->enterSymbol (new SymbolEntry (tofill, i, t_next->key ()\n\t\t\t, s->category (), s->type ()));\n\t\t    t_next = t_next->m_next;\n\t\t}\n\t}\n    }\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tofill->enterSymbol",
          "args": [
            "new SymbolEntry (tofill, i, t_next->key ()\n\t\t\t, s->category (), s->type ())"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s->type",
          "args": [],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YEList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "811-826",
          "snippet": "constTypePtr\nYEList::type () const\n{\n    ycodelist_t *element = m_first;\n    \n    constTypePtr res = m_first->code->type ();\n    element = element->next;\n\n    while (element)\n    {\n\tres = res->commontype (element->code->type ());\n\telement = element->next;\n    }\n    \n    return new ListType (res);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEList {\n  constTypePtr\n  YEList::type () const\n  {\n      ycodelist_t *element = m_first;\n      \n      constTypePtr res = m_first->code->type ();\n      element = element->next;\n  \n      while (element)\n      {\n  \tres = res->commontype (element->code->type ());\n  \telement = element->next;\n      }\n      \n      return new ListType (res);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s->category",
          "args": [],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "category",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "176-180",
          "snippet": "SymbolEntry::category_t \nSymbolEntry::category () const\n{\n    return m_category;\n}",
          "includes": [
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  SymbolEntry::category_t \n  SymbolEntry::category () const\n  {\n      return m_category;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_next->key",
          "args": [],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "YCPMapIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YCPMap.h",
          "lines": "170-170",
          "snippet": "YCPValue key() const __attribute__ ((deprecated)) { return (*this)->first; }",
          "includes": [
            "#include \"ycpless.h\"",
            "#include \"YCPValue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycpless.h\"\n#include \"YCPValue.h\"\n\nYCPMapIterator {\n  YCPValue key() const __attribute__ ((deprecated)) { return (*this)->first; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2milestone",
          "args": [
            "\"Converting symbolentry for '%s'\"",
            "t_next->key ()"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_next->sentry",
          "args": [],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "sentry",
          "container": "TableEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "97-101",
          "snippet": "SymbolEntryPtr \nTableEntry::sentry() const\n{\n    return m_entry;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  SymbolEntryPtr \n  TableEntry::sentry() const\n  {\n      return m_entry;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tofill->enterSymbol",
          "args": [
            "new SymbolEntry (tofill, i, m_table[i]->key ()\n\t\t    , s->category (), s->type ())"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2milestone",
          "args": [
            "\"Converting symbolentry for '%s'\"",
            "m_table[i]->key ()"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  void\n  SymbolTable::tableCopy(Y2Namespace* tofill) const\n  {\n      for (int i=0; i < m_prime; i++)\n      {\n  \tif (m_table[i] != 0)\n  \t{\n  \t\tSymbolEntryPtr s = m_table[i]->sentry ();\n  \t\ty2milestone (\"Converting symbolentry for '%s'\", m_table[i]->key ());\n  \t\ttofill->enterSymbol (new SymbolEntry (tofill, i, m_table[i]->key ()\n  \t\t    , s->category (), s->type ()));\n  \t\t\n  \t\t// now, convert the m_next stuff, others should be fine\n  \t\t// because the parser is running using the local namespace\n  \t\t// FIXME: what about the overloaded ones?\n  \t\tTableEntry* t_next = m_table[i]->m_next;\n  \t\twhile (t_next)\n  \t\t{\n  \t\t    SymbolEntryPtr s = t_next->sentry ();\n  \t\t    y2milestone (\"Converting symbolentry for '%s'\", t_next->key ());\n  \t\t    tofill->enterSymbol (new SymbolEntry (tofill, i, t_next->key ()\n  \t\t\t, s->category (), s->type ()));\n  \t\t    t_next = t_next->m_next;\n  \t\t}\n  \t}\n      }\n  }\n}"
  },
  {
    "function_name": "toStringSymbols",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "924-992",
    "snippet": "string\nSymbolTable::toStringSymbols() const\n{\n    string s = \"SymbolTable\";\n    int i;\n    // for each entry in hashtable\n\n    for (i = 0; i < m_prime; i++)\n    {\n\tTableEntry *current = m_table[i];\n\tif (current != 0)\n\t{\n\t    // for each entry in bucket list\n\t    while (current)\n\t    {\n\t\tSymbolEntry::category_t cat = current->sentry()->category();\n\n\t\ts += \"->'\";\n\t\tif ((cat == SymbolEntry::c_variable)\n\t\t    || (cat == SymbolEntry::c_reference)\n\t\t    || (cat == SymbolEntry::c_builtin)\n\t\t    || (cat == SymbolEntry::c_function))\n\t\t{\n\t\t    s += current->sentry()->type()->toString();\n\t\t}\n\t\telse\n\t\t{\n\t\t    s += current->sentry()->catString();\n\t\t}\n\t\ts += \" \";\n\t\ts += current->key();\n\t\t// add also SymbolEntry::position() to catch reordering in source\n\t\tchar buf[32]; snprintf (buf, 32, \"[%d]\", current->sentry()->position()); s += buf;\n\t\ts += \"'\";\n\n\t\tTableEntry *next = current->m_next;\n\n\t\t// for each entry in scope stack\n\t\tTableEntry *outer = current->m_outer;\n\t\tif (outer)\n\t\t{\n\t\t    s += \":[\";\n\t\t    while (outer)\n\t\t    {\n\t\t\ts += \"'\";\n\t\t\ts += current->sentry()->type()->toString().c_str();\n\t\t\ts += \" \";\n\t\t\ts += current->key();\n\t\t\t// add also SymbolEntry::position() to catch reordering in source\n\t\t\tchar buf[32]; snprintf (buf, 32, \"[%d]\", current->sentry()->position()); s += buf;\n\t\t\ts += \"'\";\n\t\t\touter = outer->m_outer;\n\t\t\tif (outer == 0)\n\t\t\t{\n\t\t\t    break;\n\t\t\t}\n\t\t\ts += \",\";\n\t\t    }\n\t\t    s += \"]\";\n\t\t}\n\t\ts += \",\";\n\t\tcurrent = next;\n\t    }\n\t    s += \"\\n\";\n\t} // table entry used\n    }\n\n    return s;\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "32",
            "\"[%d]\"",
            "current->sentry()->position()"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current->sentry",
          "args": [],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "sentry",
          "container": "TableEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "97-101",
          "snippet": "SymbolEntryPtr \nTableEntry::sentry() const\n{\n    return m_entry;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  SymbolEntryPtr \n  TableEntry::sentry() const\n  {\n      return m_entry;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "current->key",
          "args": [],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "YCPMapIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YCPMap.h",
          "lines": "170-170",
          "snippet": "YCPValue key() const __attribute__ ((deprecated)) { return (*this)->first; }",
          "includes": [
            "#include \"ycpless.h\"",
            "#include \"YCPValue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycpless.h\"\n#include \"YCPValue.h\"\n\nYCPMapIterator {\n  YCPValue key() const __attribute__ ((deprecated)) { return (*this)->first; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "32",
            "\"[%d]\"",
            "current->sentry()->position()"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  string\n  SymbolTable::toStringSymbols() const\n  {\n      string s = \"SymbolTable\";\n      int i;\n      // for each entry in hashtable\n  \n      for (i = 0; i < m_prime; i++)\n      {\n  \tTableEntry *current = m_table[i];\n  \tif (current != 0)\n  \t{\n  \t    // for each entry in bucket list\n  \t    while (current)\n  \t    {\n  \t\tSymbolEntry::category_t cat = current->sentry()->category();\n  \n  \t\ts += \"->'\";\n  \t\tif ((cat == SymbolEntry::c_variable)\n  \t\t    || (cat == SymbolEntry::c_reference)\n  \t\t    || (cat == SymbolEntry::c_builtin)\n  \t\t    || (cat == SymbolEntry::c_function))\n  \t\t{\n  \t\t    s += current->sentry()->type()->toString();\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t    s += current->sentry()->catString();\n  \t\t}\n  \t\ts += \" \";\n  \t\ts += current->key();\n  \t\t// add also SymbolEntry::position() to catch reordering in source\n  \t\tchar buf[32]; snprintf (buf, 32, \"[%d]\", current->sentry()->position()); s += buf;\n  \t\ts += \"'\";\n  \n  \t\tTableEntry *next = current->m_next;\n  \n  \t\t// for each entry in scope stack\n  \t\tTableEntry *outer = current->m_outer;\n  \t\tif (outer)\n  \t\t{\n  \t\t    s += \":[\";\n  \t\t    while (outer)\n  \t\t    {\n  \t\t\ts += \"'\";\n  \t\t\ts += current->sentry()->type()->toString().c_str();\n  \t\t\ts += \" \";\n  \t\t\ts += current->key();\n  \t\t\t// add also SymbolEntry::position() to catch reordering in source\n  \t\t\tchar buf[32]; snprintf (buf, 32, \"[%d]\", current->sentry()->position()); s += buf;\n  \t\t\ts += \"'\";\n  \t\t\touter = outer->m_outer;\n  \t\t\tif (outer == 0)\n  \t\t\t{\n  \t\t\t    break;\n  \t\t\t}\n  \t\t\ts += \",\";\n  \t\t    }\n  \t\t    s += \"]\";\n  \t\t}\n  \t\ts += \",\";\n  \t\tcurrent = next;\n  \t    }\n  \t    s += \"\\n\";\n  \t} // table entry used\n      }\n  \n      return s;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "852-922",
    "snippet": "string\nSymbolTable::toString() const\n{\n    string s = \"SymbolTable(\";\n    char buf[32]; snprintf (buf, 32, \"%p\", this); s += string(buf) + \")\";\n    int i;\n    // for each entry in hashtable\n\n    for (i = 0; i < m_prime; i++)\n    {\n\tTableEntry *current = m_table[i];\n\tif (current != 0)\n\t{\n\t    char buf[32]; snprintf (buf, 32, \"[%d:%p]\", i, current); s += buf;\n\t}\n\n\tif (current != 0)\n\t{\n\t    // for each entry in bucket list\n\t    while (current)\n\t    {\n\t\tSymbolEntry::category_t cat = current->sentry()->category();\n\n\t\ts += \"->'\";\n\t\tif ((cat == SymbolEntry::c_variable)\n\t\t    || (cat == SymbolEntry::c_reference)\n\t\t    || (cat == SymbolEntry::c_builtin)\n\t\t    || (cat == SymbolEntry::c_function))\n\t\t{\n\t\t    s += current->sentry()->type()->toString();\n\t\t}\n\t\telse\n\t\t{\n\t\t    s += current->sentry()->catString();\n\t\t}\n\t\ts += \" \";\n\t\ts += current->key();\n\t\ts += \"'\";\n\n\t\tTableEntry *next = current->m_next;\n\n\t\t// for each entry in scope stack\n\t\tTableEntry *outer = current->m_outer;\n\t\tif (outer)\n\t\t{\n\t\t    s += \":[\";\n\t\t    while (outer)\n\t\t    {\n\t\t\ts += \"'\";\n\t\t\ts += current->sentry()->type()->toString().c_str();\n\t\t\ts += \" \";\n\t\t\ts += current->key();\n\t\t\ts += \"'\";\n\t\t\touter = outer->m_outer;\n\t\t\tif (outer == 0)\n\t\t\t{\n\t\t\t    break;\n\t\t\t}\n\t\t\ts += \",\";\n\t\t    }\n\t\t    s += \"]\";\n\t\t}\n\t\ts += \",\";\n\t\tcurrent = next;\n\t    }\n\t    s += \"\\n\";\n\t} // table entry used\n    }\n\n    return s;\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current->key",
          "args": [],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "YCPMapIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YCPMap.h",
          "lines": "170-170",
          "snippet": "YCPValue key() const __attribute__ ((deprecated)) { return (*this)->first; }",
          "includes": [
            "#include \"ycpless.h\"",
            "#include \"YCPValue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycpless.h\"\n#include \"YCPValue.h\"\n\nYCPMapIterator {\n  YCPValue key() const __attribute__ ((deprecated)) { return (*this)->first; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "current->sentry",
          "args": [],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "sentry",
          "container": "TableEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "97-101",
          "snippet": "SymbolEntryPtr \nTableEntry::sentry() const\n{\n    return m_entry;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  SymbolEntryPtr \n  TableEntry::sentry() const\n  {\n      return m_entry;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "32",
            "\"[%d:%p]\"",
            "i",
            "current"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "buf"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "32",
            "\"%p\"",
            "this"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  string\n  SymbolTable::toString() const\n  {\n      string s = \"SymbolTable(\";\n      char buf[32]; snprintf (buf, 32, \"%p\", this); s += string(buf) + \")\";\n      int i;\n      // for each entry in hashtable\n  \n      for (i = 0; i < m_prime; i++)\n      {\n  \tTableEntry *current = m_table[i];\n  \tif (current != 0)\n  \t{\n  \t    char buf[32]; snprintf (buf, 32, \"[%d:%p]\", i, current); s += buf;\n  \t}\n  \n  \tif (current != 0)\n  \t{\n  \t    // for each entry in bucket list\n  \t    while (current)\n  \t    {\n  \t\tSymbolEntry::category_t cat = current->sentry()->category();\n  \n  \t\ts += \"->'\";\n  \t\tif ((cat == SymbolEntry::c_variable)\n  \t\t    || (cat == SymbolEntry::c_reference)\n  \t\t    || (cat == SymbolEntry::c_builtin)\n  \t\t    || (cat == SymbolEntry::c_function))\n  \t\t{\n  \t\t    s += current->sentry()->type()->toString();\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t    s += current->sentry()->catString();\n  \t\t}\n  \t\ts += \" \";\n  \t\ts += current->key();\n  \t\ts += \"'\";\n  \n  \t\tTableEntry *next = current->m_next;\n  \n  \t\t// for each entry in scope stack\n  \t\tTableEntry *outer = current->m_outer;\n  \t\tif (outer)\n  \t\t{\n  \t\t    s += \":[\";\n  \t\t    while (outer)\n  \t\t    {\n  \t\t\ts += \"'\";\n  \t\t\ts += current->sentry()->type()->toString().c_str();\n  \t\t\ts += \" \";\n  \t\t\ts += current->key();\n  \t\t\ts += \"'\";\n  \t\t\touter = outer->m_outer;\n  \t\t\tif (outer == 0)\n  \t\t\t{\n  \t\t\t    break;\n  \t\t\t}\n  \t\t\ts += \",\";\n  \t\t    }\n  \t\t    s += \"]\";\n  \t\t}\n  \t\ts += \",\";\n  \t\tcurrent = next;\n  \t    }\n  \t    s += \"\\n\";\n  \t} // table entry used\n      }\n  \n      return s;\n  }\n}"
  },
  {
    "function_name": "remove",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "750-847",
    "snippet": "void\nSymbolTable::remove (TableEntry *entry)\n{\n//    y2debug (\"SymbolTable(%p)::remove (%p)[%s]\\n\", this, entry, entry->m_key);\n//    y2debug (\"before remove (%s)\", toString().c_str());\n\n    // unlink from bucket stack\n    // pop up bucket stack\n\n    // find new candidate for stack and hash chain\n\n    TableEntry *candidate = entry->m_outer;\n\n    if (candidate != 0)\t\t\t\t\t\t// have an outer entry with equal key\n    {\n\t//y2debug (\"SymbolTable: Pop scope\\n\");\n\n\tcandidate->m_prev = entry->m_prev;\t\t\t// link into hash chain\n\tcandidate->m_next = entry->m_next;\n\n\tif (entry->m_next != 0)\n\t    entry->m_next->m_prev = candidate;\n\n\tif (entry->m_prev != 0)\n\t{\n\t    entry->m_prev->m_next = candidate;\n\t}\n\telse\n\t{\n\t    int h = hash (entry->m_key);\n\t    \n\t    if (m_table[h] == entry)\n\t    {\n\t\tm_table[h] = candidate;\t\t// next is new first\n\t    }\n\t    else\n\t    {\n\t\t// fix the m_outer chain\n\t\tTableEntry *shadow = m_table[h];\n\t\twhile (shadow)\n\t\t{\n\t\t    if (shadow->m_outer == entry)\n\t\t    {\n\t\t\tshadow->m_outer = entry->m_outer;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t\n\t\tif (!shadow)\n\t\t{\n\t\t    y2internal (\"Could not fix the symbol table for %s\", entry->key ());\n\t\t}\n\t    }\n\t}\n\n    }\n    else if (entry->m_prev != 0)\t\t// not first in bucket list\n    {\n\tentry->m_prev->m_next = entry->m_next;\n\tif (entry->m_next)\n\t    entry->m_next->m_prev = entry->m_prev;\n    }\n    else\t\t\t\t\t// first in bucket list\n    {\n\t//y2debug (\"SymbolTable: First in bucket\\n\");\n\tint h = hash (entry->m_key);\n\t\n\tif (m_table[h] == entry)\n\t{\n\t    m_table[h] = entry->m_next;\t// next is new first\n\t    if (entry->m_next != 0)\n\t\tentry->m_next->m_prev = 0;\n\t}\n\telse\n\t{\n\t    // removing m_outer\n\t    TableEntry *shadow = m_table[h];\n\t    while (shadow)\n\t    {\n\t\tif (shadow->m_outer == entry)\n\t\t{\n\t\t    shadow->m_outer = entry->m_outer;\n\t\t    break;\n\t\t}\n\t    }\n\t\t\n\t    if (!shadow)\n\t    {\n\t\ty2internal (\"Could not fix the symbol table for %s\", entry->key ());\n\t    }    \n\t}\n    }\n\n    delete entry;\n\n//    y2debug (\"after remove (%s)\", toString().c_str());\n    return;\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2internal",
          "args": [
            "\"Could not fix the symbol table for %s\"",
            "entry->key ()"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry->key",
          "args": [],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "YCPMapIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YCPMap.h",
          "lines": "170-170",
          "snippet": "YCPValue key() const __attribute__ ((deprecated)) { return (*this)->first; }",
          "includes": [
            "#include \"ycpless.h\"",
            "#include \"YCPValue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycpless.h\"\n#include \"YCPValue.h\"\n\nYCPMapIterator {\n  YCPValue key() const __attribute__ ((deprecated)) { return (*this)->first; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "entry->m_key"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "hash",
          "container": "SymbolTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "219-236",
          "snippet": "int\nSymbolTable::hash (const char *s)\n{\n//    y2debug( \"hash called for %p\", this );\n    const char *p;\n    unsigned int h = 0, g;\n\n    for (p = s; *p != 0; p++)\n    {\n\th = (h << 4) + *p;\n\tif ((g = (h & 0xff000000)) != 0)\n\t{\n\t    h = h ^ (g >> 24);\n\t    h = h ^ g;\n\t}\n    }\n    return h % m_prime;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  int\n  SymbolTable::hash (const char *s)\n  {\n  //    y2debug( \"hash called for %p\", this );\n      const char *p;\n      unsigned int h = 0, g;\n  \n      for (p = s; *p != 0; p++)\n      {\n  \th = (h << 4) + *p;\n  \tif ((g = (h & 0xff000000)) != 0)\n  \t{\n  \t    h = h ^ (g >> 24);\n  \t    h = h ^ g;\n  \t}\n      }\n      return h % m_prime;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2internal",
          "args": [
            "\"Could not fix the symbol table for %s\"",
            "entry->key ()"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  void\n  SymbolTable::remove (TableEntry *entry)\n  {\n  //    y2debug (\"SymbolTable(%p)::remove (%p)[%s]\\n\", this, entry, entry->m_key);\n  //    y2debug (\"before remove (%s)\", toString().c_str());\n  \n      // unlink from bucket stack\n      // pop up bucket stack\n  \n      // find new candidate for stack and hash chain\n  \n      TableEntry *candidate = entry->m_outer;\n  \n      if (candidate != 0)\t\t\t\t\t\t// have an outer entry with equal key\n      {\n  \t//y2debug (\"SymbolTable: Pop scope\\n\");\n  \n  \tcandidate->m_prev = entry->m_prev;\t\t\t// link into hash chain\n  \tcandidate->m_next = entry->m_next;\n  \n  \tif (entry->m_next != 0)\n  \t    entry->m_next->m_prev = candidate;\n  \n  \tif (entry->m_prev != 0)\n  \t{\n  \t    entry->m_prev->m_next = candidate;\n  \t}\n  \telse\n  \t{\n  \t    int h = hash (entry->m_key);\n  \t    \n  \t    if (m_table[h] == entry)\n  \t    {\n  \t\tm_table[h] = candidate;\t\t// next is new first\n  \t    }\n  \t    else\n  \t    {\n  \t\t// fix the m_outer chain\n  \t\tTableEntry *shadow = m_table[h];\n  \t\twhile (shadow)\n  \t\t{\n  \t\t    if (shadow->m_outer == entry)\n  \t\t    {\n  \t\t\tshadow->m_outer = entry->m_outer;\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \t\t\n  \t\tif (!shadow)\n  \t\t{\n  \t\t    y2internal (\"Could not fix the symbol table for %s\", entry->key ());\n  \t\t}\n  \t    }\n  \t}\n  \n      }\n      else if (entry->m_prev != 0)\t\t// not first in bucket list\n      {\n  \tentry->m_prev->m_next = entry->m_next;\n  \tif (entry->m_next)\n  \t    entry->m_next->m_prev = entry->m_prev;\n      }\n      else\t\t\t\t\t// first in bucket list\n      {\n  \t//y2debug (\"SymbolTable: First in bucket\\n\");\n  \tint h = hash (entry->m_key);\n  \t\n  \tif (m_table[h] == entry)\n  \t{\n  \t    m_table[h] = entry->m_next;\t// next is new first\n  \t    if (entry->m_next != 0)\n  \t\tentry->m_next->m_prev = 0;\n  \t}\n  \telse\n  \t{\n  \t    // removing m_outer\n  \t    TableEntry *shadow = m_table[h];\n  \t    while (shadow)\n  \t    {\n  \t\tif (shadow->m_outer == entry)\n  \t\t{\n  \t\t    shadow->m_outer = entry->m_outer;\n  \t\t    break;\n  \t\t}\n  \t    }\n  \t\t\n  \t    if (!shadow)\n  \t    {\n  \t\ty2internal (\"Could not fix the symbol table for %s\", entry->key ());\n  \t    }    \n  \t}\n      }\n  \n      delete entry;\n  \n  //    y2debug (\"after remove (%s)\", toString().c_str());\n      return;\n  }\n}"
  },
  {
    "function_name": "size",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "558-562",
    "snippet": "int\nSymbolTable::size() const\n{\n    return m_prime;\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  int\n  SymbolTable::size() const\n  {\n      return m_prime;\n  }\n}"
  },
  {
    "function_name": "disableUsage",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "437-444",
    "snippet": "void\nSymbolTable::disableUsage ()\n{\n#if DO_DEBUG\n    y2debug (\"SymbolTable[%p]::disableUsage\", this);\n#endif\n    m_track_usage = false;\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"SymbolTable[%p]::disableUsage\"",
            "this"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\n#define DO_DEBUG 0\n\nSymbolTable {\n  void\n  SymbolTable::disableUsage ()\n  {\n  #if DO_DEBUG\n      y2debug (\"SymbolTable[%p]::disableUsage\", this);\n  #endif\n      m_track_usage = false;\n  }\n}"
  },
  {
    "function_name": "enableUsage",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "427-434",
    "snippet": "void\nSymbolTable::enableUsage ()\n{\n#if DO_DEBUG\n    y2debug (\"SymbolTable[%p]::enableUsage\", this);\n#endif\n    m_track_usage = true;\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"SymbolTable[%p]::enableUsage\"",
            "this"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\n#define DO_DEBUG 0\n\nSymbolTable {\n  void\n  SymbolTable::enableUsage ()\n  {\n  #if DO_DEBUG\n      y2debug (\"SymbolTable[%p]::enableUsage\", this);\n  #endif\n      m_track_usage = true;\n  }\n}"
  },
  {
    "function_name": "endUsage",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "412-424",
    "snippet": "void\nSymbolTable::endUsage ()\n{\n#if DO_DEBUG\n    y2debug (\"SymbolTable[%p]::endUsage\", this);\n#endif\n    if (m_used)\n    {\n\tdelete m_used;\n\tm_used = 0;\n    }\n    return;\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"SymbolTable[%p]::endUsage\"",
            "this"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\n#define DO_DEBUG 0\n\nSymbolTable {\n  void\n  SymbolTable::endUsage ()\n  {\n  #if DO_DEBUG\n      y2debug (\"SymbolTable[%p]::endUsage\", this);\n  #endif\n      if (m_used)\n      {\n  \tdelete m_used;\n  \tm_used = 0;\n      }\n      return;\n  }\n}"
  },
  {
    "function_name": "countUsage",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "401-409",
    "snippet": "int\nSymbolTable::countUsage ()\n{\n    if (m_used != 0)\n    {\n\treturn m_used->size();\n    }\n    return 0;\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_used->size",
          "args": [],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "SymbolTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "558-562",
          "snippet": "int\nSymbolTable::size() const\n{\n    return m_prime;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  int\n  SymbolTable::size() const\n  {\n      return m_prime;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  int\n  SymbolTable::countUsage ()\n  {\n      if (m_used != 0)\n      {\n  \treturn m_used->size();\n      }\n      return 0;\n  }\n}"
  },
  {
    "function_name": "startUsage",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "387-398",
    "snippet": "void\nSymbolTable::startUsage ()\n{\n#if DO_DEBUG\n    y2debug (\"SymbolTable[%p]::startUsage\", this);\n#endif\n    if (m_used == 0)\n    {\n\tm_used = new (std::map<const char *, TableEntry *>);\n    }\n    return;\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"SymbolTable[%p]::startUsage\"",
            "this"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\n#define DO_DEBUG 0\n\nSymbolTable {\n  void\n  SymbolTable::startUsage ()\n  {\n  #if DO_DEBUG\n      y2debug (\"SymbolTable[%p]::startUsage\", this);\n  #endif\n      if (m_used == 0)\n      {\n  \tm_used = new (std::map<const char *, TableEntry *>);\n      }\n      return;\n  }\n}"
  },
  {
    "function_name": "getXRef",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "368-383",
    "snippet": "SymbolEntryPtr \nSymbolTable::getXRef (unsigned int position) const\n{\n    if (!m_xrefs || m_xrefs->empty())\n    {\n\ty2error (\"SymbolTable[%p]::getXRefs empty !\", this);\n\treturn 0;\n    }\n    std::vector<TableEntry *> *refs = m_xrefs->top();\n    if (position >= refs->size())\n    {\n\ty2error (\"SymbolTable[%p]::getXRefs position %u >= size %zu !\", this, position, refs->size());\n\treturn 0;\n    }\n    return (*refs)[position]->sentry();\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"SymbolTable[%p]::getXRefs position %u >= size %zu !\"",
            "this",
            "position",
            "refs->size()"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refs->size",
          "args": [],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "SymbolTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "558-562",
          "snippet": "int\nSymbolTable::size() const\n{\n    return m_prime;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  int\n  SymbolTable::size() const\n  {\n      return m_prime;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_xrefs->top",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"SymbolTable[%p]::getXRefs empty !\"",
            "this"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_xrefs->empty",
          "args": [],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  SymbolEntryPtr \n  SymbolTable::getXRef (unsigned int position) const\n  {\n      if (!m_xrefs || m_xrefs->empty())\n      {\n  \ty2error (\"SymbolTable[%p]::getXRefs empty !\", this);\n  \treturn 0;\n      }\n      std::vector<TableEntry *> *refs = m_xrefs->top();\n      if (position >= refs->size())\n      {\n  \ty2error (\"SymbolTable[%p]::getXRefs position %u >= size %zu !\", this, position, refs->size());\n  \treturn 0;\n      }\n      return (*refs)[position]->sentry();\n  }\n}"
  },
  {
    "function_name": "closeXRefs",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "350-365",
    "snippet": "void\nSymbolTable::closeXRefs ()\n{\n#if DO_DEBUG\n    y2debug (\"SymbolTable[%p]::closeXRefs()\", this);\n#endif\n    if (!m_xrefs || m_xrefs->empty ())\n    {\n\ty2error (\"SymbolTable[%p]::closeXRefs without openXRefs\", this);\n\treturn;\n    }\n    delete m_xrefs->top();\n    m_xrefs->pop();\n\n    return;\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_xrefs->pop",
          "args": [],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "pop",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "159-167",
          "snippet": "void\nSymbolEntry::pop ()\n{\n    if (! m_recurse_stack)\n\treturn;\n\n    m_value = m_recurse_stack->top ();\n    m_recurse_stack->pop ();\n}",
          "includes": [
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  void\n  SymbolEntry::pop ()\n  {\n      if (! m_recurse_stack)\n  \treturn;\n  \n      m_value = m_recurse_stack->top ();\n      m_recurse_stack->pop ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_xrefs->top",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"SymbolTable[%p]::closeXRefs without openXRefs\"",
            "this"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_xrefs->empty",
          "args": [],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"SymbolTable[%p]::closeXRefs()\"",
            "this"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\n#define DO_DEBUG 0\n\nSymbolTable {\n  void\n  SymbolTable::closeXRefs ()\n  {\n  #if DO_DEBUG\n      y2debug (\"SymbolTable[%p]::closeXRefs()\", this);\n  #endif\n      if (!m_xrefs || m_xrefs->empty ())\n      {\n  \ty2error (\"SymbolTable[%p]::closeXRefs without openXRefs\", this);\n  \treturn;\n      }\n      delete m_xrefs->top();\n      m_xrefs->pop();\n  \n      return;\n  }\n}"
  },
  {
    "function_name": "openXRefs",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "333-347",
    "snippet": "void\nSymbolTable::openXRefs ()\n{\n#if DO_DEBUG\n    y2debug (\"SymbolTable[%p]::openXRefs()\", this);\n#endif\n    if (! m_xrefs)\n    {\n\tm_xrefs = new xrefs_t;\n    }\n\n    m_xrefs->push (new (std::vector<TableEntry *>));\n\n    return;\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_xrefs->push",
          "args": [
            "new (std::vector<TableEntry *>)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"SymbolTable[%p]::openXRefs()\"",
            "this"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\n#define DO_DEBUG 0\n\nSymbolTable {\n  void\n  SymbolTable::openXRefs ()\n  {\n  #if DO_DEBUG\n      y2debug (\"SymbolTable[%p]::openXRefs()\", this);\n  #endif\n      if (! m_xrefs)\n      {\n  \tm_xrefs = new xrefs_t;\n      }\n  \n      m_xrefs->push (new (std::vector<TableEntry *>));\n  \n      return;\n  }\n}"
  },
  {
    "function_name": "~SymbolTable",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "255-328",
    "snippet": "SymbolTable::~SymbolTable()\n{\n//    y2debug (\"SymbolTable::~SymbolTable %p\", this);\n\n    if (m_xrefs)\n    {\n\twhile (!m_xrefs->empty())\n\t{\n\t    delete m_xrefs->top();\n\t    m_xrefs->pop();\n\t}\n\t\n\tdelete m_xrefs;\n    }\n\n    endUsage ();\n\n    int i;\n    int count = 0;\n    int used = 0;\n    int maxlen = 0;\n    int bucketlen;\n    const TableEntry *current;\n\n    // for each entry in hashtable\n\n    for (i = 0; i < m_prime; i++)\n    {\n\tcurrent = m_table[i];\n\tif (current != 0)\n\t{\n\t    bucketlen = 0;\n\t    used++;\n\n\t    // for each entry in bucket list\n\t    while (current)\n\t    {\n\t\tTableEntry *next;\n\n\t\tcount++;\n\t\tbucketlen++;\n\n\t\t// for each entry in scope stack\n\t\t//   delete outermost entries first\n\n\t\tTableEntry *outer = current->m_outer;\n\t\twhile (outer)\n\t\t{\n\t\t    TableEntry *next_outer = outer->m_outer;\n\t\t    delete outer;\n\t\t    outer = next_outer;\n\t\t}\n\n\t\t// next in bucket chain\n\t\tnext = current->m_next;\n\n\t\t// delete innermost entry\n\t\tdelete current;\n\n\t\tcurrent = next;\n\t    }\n\t    if (bucketlen > maxlen)\n\t    {\n\t\tmaxlen = bucketlen;\n\t    }\n\t}\n    }\n#if DO_DEBUG\n    y2debug (\"%d of %d buckets used\\n\", used, m_prime);\n    y2debug (\"%d elements, %d bucketuse\\n\", count, count / m_prime);\n    y2debug (\"bucket size max %d, average %d\\n\", maxlen, (maxlen / m_prime) + 1);\n#endif\n    free (m_table);\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "m_table"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"bucket size max %d, average %d\\n\"",
            "maxlen",
            "(maxlen / m_prime) + 1"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"%d elements, %d bucketuse\\n\"",
            "count",
            "count / m_prime"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"%d of %d buckets used\\n\"",
            "used",
            "m_prime"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "endUsage",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "endUsage",
          "container": "SymbolTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "412-424",
          "snippet": "void\nSymbolTable::endUsage ()\n{\n#if DO_DEBUG\n    y2debug (\"SymbolTable[%p]::endUsage\", this);\n#endif\n    if (m_used)\n    {\n\tdelete m_used;\n\tm_used = 0;\n    }\n    return;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\n#define DO_DEBUG 0\n\nSymbolTable {\n  void\n  SymbolTable::endUsage ()\n  {\n  #if DO_DEBUG\n      y2debug (\"SymbolTable[%p]::endUsage\", this);\n  #endif\n      if (m_used)\n      {\n  \tdelete m_used;\n  \tm_used = 0;\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_xrefs->pop",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "pop",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "159-167",
          "snippet": "void\nSymbolEntry::pop ()\n{\n    if (! m_recurse_stack)\n\treturn;\n\n    m_value = m_recurse_stack->top ();\n    m_recurse_stack->pop ();\n}",
          "includes": [
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  void\n  SymbolEntry::pop ()\n  {\n      if (! m_recurse_stack)\n  \treturn;\n  \n      m_value = m_recurse_stack->top ();\n      m_recurse_stack->pop ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_xrefs->top",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_xrefs->empty",
          "args": [],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\n#define DO_DEBUG 0\n\nSymbolTable {\n  SymbolTable::~SymbolTable()\n  {\n  //    y2debug (\"SymbolTable::~SymbolTable %p\", this);\n  \n      if (m_xrefs)\n      {\n  \twhile (!m_xrefs->empty())\n  \t{\n  \t    delete m_xrefs->top();\n  \t    m_xrefs->pop();\n  \t}\n  \t\n  \tdelete m_xrefs;\n      }\n  \n      endUsage ();\n  \n      int i;\n      int count = 0;\n      int used = 0;\n      int maxlen = 0;\n      int bucketlen;\n      const TableEntry *current;\n  \n      // for each entry in hashtable\n  \n      for (i = 0; i < m_prime; i++)\n      {\n  \tcurrent = m_table[i];\n  \tif (current != 0)\n  \t{\n  \t    bucketlen = 0;\n  \t    used++;\n  \n  \t    // for each entry in bucket list\n  \t    while (current)\n  \t    {\n  \t\tTableEntry *next;\n  \n  \t\tcount++;\n  \t\tbucketlen++;\n  \n  \t\t// for each entry in scope stack\n  \t\t//   delete outermost entries first\n  \n  \t\tTableEntry *outer = current->m_outer;\n  \t\twhile (outer)\n  \t\t{\n  \t\t    TableEntry *next_outer = outer->m_outer;\n  \t\t    delete outer;\n  \t\t    outer = next_outer;\n  \t\t}\n  \n  \t\t// next in bucket chain\n  \t\tnext = current->m_next;\n  \n  \t\t// delete innermost entry\n  \t\tdelete current;\n  \n  \t\tcurrent = next;\n  \t    }\n  \t    if (bucketlen > maxlen)\n  \t    {\n  \t\tmaxlen = bucketlen;\n  \t    }\n  \t}\n      }\n  #if DO_DEBUG\n      y2debug (\"%d of %d buckets used\\n\", used, m_prime);\n      y2debug (\"%d elements, %d bucketuse\\n\", count, count / m_prime);\n      y2debug (\"bucket size max %d, average %d\\n\", maxlen, (maxlen / m_prime) + 1);\n  #endif\n      free (m_table);\n  }\n}"
  },
  {
    "function_name": "SymbolTable",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "239-252",
    "snippet": "SymbolTable::SymbolTable (int prime)\n    // The 31 used to be 211, but that is too much.\n    // because eg. in runlevel there's 1200 blocks\n    // and each has its symbol table.\n    // Better yet use rehashing - TODO\n    : m_prime ((prime <= 0) ? 31 : prime)\n    , m_track_usage (true)\n    , m_used (0)\n    , m_xrefs (0)\n{\n    m_table = (TableEntry **)calloc (m_prime, sizeof (TableEntry *));\n\n//    y2debug (\"New table @ %p\", this);\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "m_prime",
            "sizeof (TableEntry *)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  SymbolTable::SymbolTable (int prime)\n      // The 31 used to be 211, but that is too much.\n      // because eg. in runlevel there's 1200 blocks\n      // and each has its symbol table.\n      // Better yet use rehashing - TODO\n      : m_prime ((prime <= 0) ? 31 : prime)\n      , m_track_usage (true)\n      , m_used (0)\n      , m_xrefs (0)\n  {\n      m_table = (TableEntry **)calloc (m_prime, sizeof (TableEntry *));\n  \n  //    y2debug (\"New table @ %p\", this);\n  }\n}"
  },
  {
    "function_name": "hash",
    "container": "SymbolTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "219-236",
    "snippet": "int\nSymbolTable::hash (const char *s)\n{\n//    y2debug( \"hash called for %p\", this );\n    const char *p;\n    unsigned int h = 0, g;\n\n    for (p = s; *p != 0; p++)\n    {\n\th = (h << 4) + *p;\n\tif ((g = (h & 0xff000000)) != 0)\n\t{\n\t    h = h ^ (g >> 24);\n\t    h = h ^ g;\n\t}\n    }\n    return h % m_prime;\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  int\n  SymbolTable::hash (const char *s)\n  {\n  //    y2debug( \"hash called for %p\", this );\n      const char *p;\n      unsigned int h = 0, g;\n  \n      for (p = s; *p != 0; p++)\n      {\n  \th = (h << 4) + *p;\n  \tif ((g = (h & 0xff000000)) != 0)\n  \t{\n  \t    h = h ^ (g >> 24);\n  \t    h = h ^ g;\n  \t}\n      }\n      return h % m_prime;\n  }\n}"
  },
  {
    "function_name": "remove",
    "container": "TableEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "203-211",
    "snippet": "void\nTableEntry::remove ()\n{\n    if (m_table)\n    {\n\tm_table->remove (this);\n\tm_table = 0;\n    }\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_table->remove",
          "args": [
            "this"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "remove",
          "container": "SymbolTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "750-847",
          "snippet": "void\nSymbolTable::remove (TableEntry *entry)\n{\n//    y2debug (\"SymbolTable(%p)::remove (%p)[%s]\\n\", this, entry, entry->m_key);\n//    y2debug (\"before remove (%s)\", toString().c_str());\n\n    // unlink from bucket stack\n    // pop up bucket stack\n\n    // find new candidate for stack and hash chain\n\n    TableEntry *candidate = entry->m_outer;\n\n    if (candidate != 0)\t\t\t\t\t\t// have an outer entry with equal key\n    {\n\t//y2debug (\"SymbolTable: Pop scope\\n\");\n\n\tcandidate->m_prev = entry->m_prev;\t\t\t// link into hash chain\n\tcandidate->m_next = entry->m_next;\n\n\tif (entry->m_next != 0)\n\t    entry->m_next->m_prev = candidate;\n\n\tif (entry->m_prev != 0)\n\t{\n\t    entry->m_prev->m_next = candidate;\n\t}\n\telse\n\t{\n\t    int h = hash (entry->m_key);\n\t    \n\t    if (m_table[h] == entry)\n\t    {\n\t\tm_table[h] = candidate;\t\t// next is new first\n\t    }\n\t    else\n\t    {\n\t\t// fix the m_outer chain\n\t\tTableEntry *shadow = m_table[h];\n\t\twhile (shadow)\n\t\t{\n\t\t    if (shadow->m_outer == entry)\n\t\t    {\n\t\t\tshadow->m_outer = entry->m_outer;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t\n\t\tif (!shadow)\n\t\t{\n\t\t    y2internal (\"Could not fix the symbol table for %s\", entry->key ());\n\t\t}\n\t    }\n\t}\n\n    }\n    else if (entry->m_prev != 0)\t\t// not first in bucket list\n    {\n\tentry->m_prev->m_next = entry->m_next;\n\tif (entry->m_next)\n\t    entry->m_next->m_prev = entry->m_prev;\n    }\n    else\t\t\t\t\t// first in bucket list\n    {\n\t//y2debug (\"SymbolTable: First in bucket\\n\");\n\tint h = hash (entry->m_key);\n\t\n\tif (m_table[h] == entry)\n\t{\n\t    m_table[h] = entry->m_next;\t// next is new first\n\t    if (entry->m_next != 0)\n\t\tentry->m_next->m_prev = 0;\n\t}\n\telse\n\t{\n\t    // removing m_outer\n\t    TableEntry *shadow = m_table[h];\n\t    while (shadow)\n\t    {\n\t\tif (shadow->m_outer == entry)\n\t\t{\n\t\t    shadow->m_outer = entry->m_outer;\n\t\t    break;\n\t\t}\n\t    }\n\t\t\n\t    if (!shadow)\n\t    {\n\t\ty2internal (\"Could not fix the symbol table for %s\", entry->key ());\n\t    }    \n\t}\n    }\n\n    delete entry;\n\n//    y2debug (\"after remove (%s)\", toString().c_str());\n    return;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  void\n  SymbolTable::remove (TableEntry *entry)\n  {\n  //    y2debug (\"SymbolTable(%p)::remove (%p)[%s]\\n\", this, entry, entry->m_key);\n  //    y2debug (\"before remove (%s)\", toString().c_str());\n  \n      // unlink from bucket stack\n      // pop up bucket stack\n  \n      // find new candidate for stack and hash chain\n  \n      TableEntry *candidate = entry->m_outer;\n  \n      if (candidate != 0)\t\t\t\t\t\t// have an outer entry with equal key\n      {\n  \t//y2debug (\"SymbolTable: Pop scope\\n\");\n  \n  \tcandidate->m_prev = entry->m_prev;\t\t\t// link into hash chain\n  \tcandidate->m_next = entry->m_next;\n  \n  \tif (entry->m_next != 0)\n  \t    entry->m_next->m_prev = candidate;\n  \n  \tif (entry->m_prev != 0)\n  \t{\n  \t    entry->m_prev->m_next = candidate;\n  \t}\n  \telse\n  \t{\n  \t    int h = hash (entry->m_key);\n  \t    \n  \t    if (m_table[h] == entry)\n  \t    {\n  \t\tm_table[h] = candidate;\t\t// next is new first\n  \t    }\n  \t    else\n  \t    {\n  \t\t// fix the m_outer chain\n  \t\tTableEntry *shadow = m_table[h];\n  \t\twhile (shadow)\n  \t\t{\n  \t\t    if (shadow->m_outer == entry)\n  \t\t    {\n  \t\t\tshadow->m_outer = entry->m_outer;\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \t\t\n  \t\tif (!shadow)\n  \t\t{\n  \t\t    y2internal (\"Could not fix the symbol table for %s\", entry->key ());\n  \t\t}\n  \t    }\n  \t}\n  \n      }\n      else if (entry->m_prev != 0)\t\t// not first in bucket list\n      {\n  \tentry->m_prev->m_next = entry->m_next;\n  \tif (entry->m_next)\n  \t    entry->m_next->m_prev = entry->m_prev;\n      }\n      else\t\t\t\t\t// first in bucket list\n      {\n  \t//y2debug (\"SymbolTable: First in bucket\\n\");\n  \tint h = hash (entry->m_key);\n  \t\n  \tif (m_table[h] == entry)\n  \t{\n  \t    m_table[h] = entry->m_next;\t// next is new first\n  \t    if (entry->m_next != 0)\n  \t\tentry->m_next->m_prev = 0;\n  \t}\n  \telse\n  \t{\n  \t    // removing m_outer\n  \t    TableEntry *shadow = m_table[h];\n  \t    while (shadow)\n  \t    {\n  \t\tif (shadow->m_outer == entry)\n  \t\t{\n  \t\t    shadow->m_outer = entry->m_outer;\n  \t\t    break;\n  \t\t}\n  \t    }\n  \t\t\n  \t    if (!shadow)\n  \t    {\n  \t\ty2internal (\"Could not fix the symbol table for %s\", entry->key ());\n  \t    }    \n  \t}\n      }\n  \n      delete entry;\n  \n  //    y2debug (\"after remove (%s)\", toString().c_str());\n      return;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  void\n  TableEntry::remove ()\n  {\n      if (m_table)\n      {\n  \tm_table->remove (this);\n  \tm_table = 0;\n      }\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "TableEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "151-162",
    "snippet": "string\nTableEntry::toString() const\n{\n    static char lbuf[16];\n    if (m_point) snprintf (lbuf, 16, \"%d\", m_point->line());\n    else strcpy (lbuf, \"<nil>\");\n    string s = string (\"TEntry (\") + m_key\n\t+ \"@\" + lbuf\n\t+ \":\" + m_entry->toString()\n\t+ \")\";\n    return s;\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_entry->toString",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "SymbolTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "852-922",
          "snippet": "string\nSymbolTable::toString() const\n{\n    string s = \"SymbolTable(\";\n    char buf[32]; snprintf (buf, 32, \"%p\", this); s += string(buf) + \")\";\n    int i;\n    // for each entry in hashtable\n\n    for (i = 0; i < m_prime; i++)\n    {\n\tTableEntry *current = m_table[i];\n\tif (current != 0)\n\t{\n\t    char buf[32]; snprintf (buf, 32, \"[%d:%p]\", i, current); s += buf;\n\t}\n\n\tif (current != 0)\n\t{\n\t    // for each entry in bucket list\n\t    while (current)\n\t    {\n\t\tSymbolEntry::category_t cat = current->sentry()->category();\n\n\t\ts += \"->'\";\n\t\tif ((cat == SymbolEntry::c_variable)\n\t\t    || (cat == SymbolEntry::c_reference)\n\t\t    || (cat == SymbolEntry::c_builtin)\n\t\t    || (cat == SymbolEntry::c_function))\n\t\t{\n\t\t    s += current->sentry()->type()->toString();\n\t\t}\n\t\telse\n\t\t{\n\t\t    s += current->sentry()->catString();\n\t\t}\n\t\ts += \" \";\n\t\ts += current->key();\n\t\ts += \"'\";\n\n\t\tTableEntry *next = current->m_next;\n\n\t\t// for each entry in scope stack\n\t\tTableEntry *outer = current->m_outer;\n\t\tif (outer)\n\t\t{\n\t\t    s += \":[\";\n\t\t    while (outer)\n\t\t    {\n\t\t\ts += \"'\";\n\t\t\ts += current->sentry()->type()->toString().c_str();\n\t\t\ts += \" \";\n\t\t\ts += current->key();\n\t\t\ts += \"'\";\n\t\t\touter = outer->m_outer;\n\t\t\tif (outer == 0)\n\t\t\t{\n\t\t\t    break;\n\t\t\t}\n\t\t\ts += \",\";\n\t\t    }\n\t\t    s += \"]\";\n\t\t}\n\t\ts += \",\";\n\t\tcurrent = next;\n\t    }\n\t    s += \"\\n\";\n\t} // table entry used\n    }\n\n    return s;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  string\n  SymbolTable::toString() const\n  {\n      string s = \"SymbolTable(\";\n      char buf[32]; snprintf (buf, 32, \"%p\", this); s += string(buf) + \")\";\n      int i;\n      // for each entry in hashtable\n  \n      for (i = 0; i < m_prime; i++)\n      {\n  \tTableEntry *current = m_table[i];\n  \tif (current != 0)\n  \t{\n  \t    char buf[32]; snprintf (buf, 32, \"[%d:%p]\", i, current); s += buf;\n  \t}\n  \n  \tif (current != 0)\n  \t{\n  \t    // for each entry in bucket list\n  \t    while (current)\n  \t    {\n  \t\tSymbolEntry::category_t cat = current->sentry()->category();\n  \n  \t\ts += \"->'\";\n  \t\tif ((cat == SymbolEntry::c_variable)\n  \t\t    || (cat == SymbolEntry::c_reference)\n  \t\t    || (cat == SymbolEntry::c_builtin)\n  \t\t    || (cat == SymbolEntry::c_function))\n  \t\t{\n  \t\t    s += current->sentry()->type()->toString();\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t    s += current->sentry()->catString();\n  \t\t}\n  \t\ts += \" \";\n  \t\ts += current->key();\n  \t\ts += \"'\";\n  \n  \t\tTableEntry *next = current->m_next;\n  \n  \t\t// for each entry in scope stack\n  \t\tTableEntry *outer = current->m_outer;\n  \t\tif (outer)\n  \t\t{\n  \t\t    s += \":[\";\n  \t\t    while (outer)\n  \t\t    {\n  \t\t\ts += \"'\";\n  \t\t\ts += current->sentry()->type()->toString().c_str();\n  \t\t\ts += \" \";\n  \t\t\ts += current->key();\n  \t\t\ts += \"'\";\n  \t\t\touter = outer->m_outer;\n  \t\t\tif (outer == 0)\n  \t\t\t{\n  \t\t\t    break;\n  \t\t\t}\n  \t\t\ts += \",\";\n  \t\t    }\n  \t\t    s += \"]\";\n  \t\t}\n  \t\ts += \",\";\n  \t\tcurrent = next;\n  \t    }\n  \t    s += \"\\n\";\n  \t} // table entry used\n      }\n  \n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"TEntry (\""
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "lbuf",
            "\"<nil>\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "lbuf",
            "16",
            "\"%d\"",
            "m_point->line()"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_point->line",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "line",
          "container": "YStatement",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YStatement.h",
          "lines": "78-78",
          "snippet": "int line () const { return m_line; }",
          "includes": [
            "#include \"ycp/ycpless.h\"",
            "#include \"ycp/Import.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ycpless.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YCode.h\"\n#include <string>\n\nYStatement {\n  int line () const { return m_line; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  string\n  TableEntry::toString() const\n  {\n      static char lbuf[16];\n      if (m_point) snprintf (lbuf, 16, \"%d\", m_point->line());\n      else strcpy (lbuf, \"<nil>\");\n      string s = string (\"TEntry (\") + m_key\n  \t+ \"@\" + lbuf\n  \t+ \":\" + m_entry->toString()\n  \t+ \")\";\n      return s;\n  }\n}"
  },
  {
    "function_name": "makeDefinition",
    "container": "TableEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "139-148",
    "snippet": "void\nTableEntry::makeDefinition (int line)\n{\n    Point *point = new Point (m_point->sentry(), line, m_point->point());\t// duplicate current m_point, replacing line\n#if DO_DEBUG\n    y2debug (\"TableEntry::makeDefinition (%s -> %s)\", m_point->toString().c_str(), point->toString().c_str());\n#endif\n    delete m_point;\n    m_point = point;\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"TableEntry::makeDefinition (%s -> %s)\"",
            "m_point->toString().c_str()",
            "point->toString().c_str()"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "point->toString",
          "args": [],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "SymbolTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "852-922",
          "snippet": "string\nSymbolTable::toString() const\n{\n    string s = \"SymbolTable(\";\n    char buf[32]; snprintf (buf, 32, \"%p\", this); s += string(buf) + \")\";\n    int i;\n    // for each entry in hashtable\n\n    for (i = 0; i < m_prime; i++)\n    {\n\tTableEntry *current = m_table[i];\n\tif (current != 0)\n\t{\n\t    char buf[32]; snprintf (buf, 32, \"[%d:%p]\", i, current); s += buf;\n\t}\n\n\tif (current != 0)\n\t{\n\t    // for each entry in bucket list\n\t    while (current)\n\t    {\n\t\tSymbolEntry::category_t cat = current->sentry()->category();\n\n\t\ts += \"->'\";\n\t\tif ((cat == SymbolEntry::c_variable)\n\t\t    || (cat == SymbolEntry::c_reference)\n\t\t    || (cat == SymbolEntry::c_builtin)\n\t\t    || (cat == SymbolEntry::c_function))\n\t\t{\n\t\t    s += current->sentry()->type()->toString();\n\t\t}\n\t\telse\n\t\t{\n\t\t    s += current->sentry()->catString();\n\t\t}\n\t\ts += \" \";\n\t\ts += current->key();\n\t\ts += \"'\";\n\n\t\tTableEntry *next = current->m_next;\n\n\t\t// for each entry in scope stack\n\t\tTableEntry *outer = current->m_outer;\n\t\tif (outer)\n\t\t{\n\t\t    s += \":[\";\n\t\t    while (outer)\n\t\t    {\n\t\t\ts += \"'\";\n\t\t\ts += current->sentry()->type()->toString().c_str();\n\t\t\ts += \" \";\n\t\t\ts += current->key();\n\t\t\ts += \"'\";\n\t\t\touter = outer->m_outer;\n\t\t\tif (outer == 0)\n\t\t\t{\n\t\t\t    break;\n\t\t\t}\n\t\t\ts += \",\";\n\t\t    }\n\t\t    s += \"]\";\n\t\t}\n\t\ts += \",\";\n\t\tcurrent = next;\n\t    }\n\t    s += \"\\n\";\n\t} // table entry used\n    }\n\n    return s;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  string\n  SymbolTable::toString() const\n  {\n      string s = \"SymbolTable(\";\n      char buf[32]; snprintf (buf, 32, \"%p\", this); s += string(buf) + \")\";\n      int i;\n      // for each entry in hashtable\n  \n      for (i = 0; i < m_prime; i++)\n      {\n  \tTableEntry *current = m_table[i];\n  \tif (current != 0)\n  \t{\n  \t    char buf[32]; snprintf (buf, 32, \"[%d:%p]\", i, current); s += buf;\n  \t}\n  \n  \tif (current != 0)\n  \t{\n  \t    // for each entry in bucket list\n  \t    while (current)\n  \t    {\n  \t\tSymbolEntry::category_t cat = current->sentry()->category();\n  \n  \t\ts += \"->'\";\n  \t\tif ((cat == SymbolEntry::c_variable)\n  \t\t    || (cat == SymbolEntry::c_reference)\n  \t\t    || (cat == SymbolEntry::c_builtin)\n  \t\t    || (cat == SymbolEntry::c_function))\n  \t\t{\n  \t\t    s += current->sentry()->type()->toString();\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t    s += current->sentry()->catString();\n  \t\t}\n  \t\ts += \" \";\n  \t\ts += current->key();\n  \t\ts += \"'\";\n  \n  \t\tTableEntry *next = current->m_next;\n  \n  \t\t// for each entry in scope stack\n  \t\tTableEntry *outer = current->m_outer;\n  \t\tif (outer)\n  \t\t{\n  \t\t    s += \":[\";\n  \t\t    while (outer)\n  \t\t    {\n  \t\t\ts += \"'\";\n  \t\t\ts += current->sentry()->type()->toString().c_str();\n  \t\t\ts += \" \";\n  \t\t\ts += current->key();\n  \t\t\ts += \"'\";\n  \t\t\touter = outer->m_outer;\n  \t\t\tif (outer == 0)\n  \t\t\t{\n  \t\t\t    break;\n  \t\t\t}\n  \t\t\ts += \",\";\n  \t\t    }\n  \t\t    s += \"]\";\n  \t\t}\n  \t\ts += \",\";\n  \t\tcurrent = next;\n  \t    }\n  \t    s += \"\\n\";\n  \t} // table entry used\n      }\n  \n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_point->point",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_point->sentry",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "sentry",
          "container": "TableEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "97-101",
          "snippet": "SymbolEntryPtr \nTableEntry::sentry() const\n{\n    return m_entry;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  SymbolEntryPtr \n  TableEntry::sentry() const\n  {\n      return m_entry;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\n#define DO_DEBUG 0\n\nTableEntry {\n  void\n  TableEntry::makeDefinition (int line)\n  {\n      Point *point = new Point (m_point->sentry(), line, m_point->point());\t// duplicate current m_point, replacing line\n  #if DO_DEBUG\n      y2debug (\"TableEntry::makeDefinition (%s -> %s)\", m_point->toString().c_str(), point->toString().c_str());\n  #endif\n      delete m_point;\n      m_point = point;\n  }\n}"
  },
  {
    "function_name": "isOverloaded",
    "container": "TableEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "130-134",
    "snippet": "bool\nTableEntry::isOverloaded () const\n{\n    return m_overloaded_next != 0 || m_overloaded_prev != 0;\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  bool\n  TableEntry::isOverloaded () const\n  {\n      return m_overloaded_next != 0 || m_overloaded_prev != 0;\n  }\n}"
  },
  {
    "function_name": "sentry",
    "container": "TableEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "97-101",
    "snippet": "SymbolEntryPtr \nTableEntry::sentry() const\n{\n    return m_entry;\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  SymbolEntryPtr \n  TableEntry::sentry() const\n  {\n      return m_entry;\n  }\n}"
  },
  {
    "function_name": "~TableEntry",
    "container": "TableEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "82-85",
    "snippet": "TableEntry::~TableEntry ()\n{\n    delete m_point;    \n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  TableEntry::~TableEntry ()\n  {\n      delete m_point;    \n  }\n}"
  },
  {
    "function_name": "TableEntry",
    "container": "TableEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "56-79",
    "snippet": "TableEntry::TableEntry (bytecodeistream & str)\n    : m_prev (0)\n    , m_next (0)\n    , m_overloaded_prev (0)\n    , m_overloaded_next (0)\n    , m_outer (0)\n    , m_key (0)\n    , m_entry (0)\n    , m_point (0)\n    , m_table (0)\n{\n    m_entry = Bytecode::readEntry (str);\n    m_key = m_entry->name();\n    m_point = new Point (str);\n    if (m_entry->category() == SymbolEntry::c_function)\t\t// read function prototype\n    {\n\t// FIXME: this is weird, why do we do this here???\n\t((YSymbolEntryPtr)m_entry)->setCode(Bytecode::readCode (str));\n\tif (((YSymbolEntryPtr)m_entry)->code()->kind() != YCode::ycFunction)\n\t{\n\t    y2error (\"TableEntry::fromStream: bad prototype for global function %s\", m_entry->toString().c_str());\n\t}\n    }\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"TableEntry::fromStream: bad prototype for global function %s\"",
            "m_entry->toString().c_str()"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_entry->toString",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "SymbolTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "852-922",
          "snippet": "string\nSymbolTable::toString() const\n{\n    string s = \"SymbolTable(\";\n    char buf[32]; snprintf (buf, 32, \"%p\", this); s += string(buf) + \")\";\n    int i;\n    // for each entry in hashtable\n\n    for (i = 0; i < m_prime; i++)\n    {\n\tTableEntry *current = m_table[i];\n\tif (current != 0)\n\t{\n\t    char buf[32]; snprintf (buf, 32, \"[%d:%p]\", i, current); s += buf;\n\t}\n\n\tif (current != 0)\n\t{\n\t    // for each entry in bucket list\n\t    while (current)\n\t    {\n\t\tSymbolEntry::category_t cat = current->sentry()->category();\n\n\t\ts += \"->'\";\n\t\tif ((cat == SymbolEntry::c_variable)\n\t\t    || (cat == SymbolEntry::c_reference)\n\t\t    || (cat == SymbolEntry::c_builtin)\n\t\t    || (cat == SymbolEntry::c_function))\n\t\t{\n\t\t    s += current->sentry()->type()->toString();\n\t\t}\n\t\telse\n\t\t{\n\t\t    s += current->sentry()->catString();\n\t\t}\n\t\ts += \" \";\n\t\ts += current->key();\n\t\ts += \"'\";\n\n\t\tTableEntry *next = current->m_next;\n\n\t\t// for each entry in scope stack\n\t\tTableEntry *outer = current->m_outer;\n\t\tif (outer)\n\t\t{\n\t\t    s += \":[\";\n\t\t    while (outer)\n\t\t    {\n\t\t\ts += \"'\";\n\t\t\ts += current->sentry()->type()->toString().c_str();\n\t\t\ts += \" \";\n\t\t\ts += current->key();\n\t\t\ts += \"'\";\n\t\t\touter = outer->m_outer;\n\t\t\tif (outer == 0)\n\t\t\t{\n\t\t\t    break;\n\t\t\t}\n\t\t\ts += \",\";\n\t\t    }\n\t\t    s += \"]\";\n\t\t}\n\t\ts += \",\";\n\t\tcurrent = next;\n\t    }\n\t    s += \"\\n\";\n\t} // table entry used\n    }\n\n    return s;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  string\n  SymbolTable::toString() const\n  {\n      string s = \"SymbolTable(\";\n      char buf[32]; snprintf (buf, 32, \"%p\", this); s += string(buf) + \")\";\n      int i;\n      // for each entry in hashtable\n  \n      for (i = 0; i < m_prime; i++)\n      {\n  \tTableEntry *current = m_table[i];\n  \tif (current != 0)\n  \t{\n  \t    char buf[32]; snprintf (buf, 32, \"[%d:%p]\", i, current); s += buf;\n  \t}\n  \n  \tif (current != 0)\n  \t{\n  \t    // for each entry in bucket list\n  \t    while (current)\n  \t    {\n  \t\tSymbolEntry::category_t cat = current->sentry()->category();\n  \n  \t\ts += \"->'\";\n  \t\tif ((cat == SymbolEntry::c_variable)\n  \t\t    || (cat == SymbolEntry::c_reference)\n  \t\t    || (cat == SymbolEntry::c_builtin)\n  \t\t    || (cat == SymbolEntry::c_function))\n  \t\t{\n  \t\t    s += current->sentry()->type()->toString();\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t    s += current->sentry()->catString();\n  \t\t}\n  \t\ts += \" \";\n  \t\ts += current->key();\n  \t\ts += \"'\";\n  \n  \t\tTableEntry *next = current->m_next;\n  \n  \t\t// for each entry in scope stack\n  \t\tTableEntry *outer = current->m_outer;\n  \t\tif (outer)\n  \t\t{\n  \t\t    s += \":[\";\n  \t\t    while (outer)\n  \t\t    {\n  \t\t\ts += \"'\";\n  \t\t\ts += current->sentry()->type()->toString().c_str();\n  \t\t\ts += \" \";\n  \t\t\ts += current->key();\n  \t\t\ts += \"'\";\n  \t\t\touter = outer->m_outer;\n  \t\t\tif (outer == 0)\n  \t\t\t{\n  \t\t\t    break;\n  \t\t\t}\n  \t\t\ts += \",\";\n  \t\t    }\n  \t\t    s += \"]\";\n  \t\t}\n  \t\ts += \",\";\n  \t\tcurrent = next;\n  \t    }\n  \t    s += \"\\n\";\n  \t} // table entry used\n      }\n  \n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "Bytecode::readCode (str)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_entry->category",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "category",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "176-180",
          "snippet": "SymbolEntry::category_t \nSymbolEntry::category () const\n{\n    return m_category;\n}",
          "includes": [
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  SymbolEntry::category_t \n  SymbolEntry::category () const\n  {\n      return m_category;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_entry->name",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Import",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Import.cc",
          "lines": "189-193",
          "snippet": "string\nImport::name () const\n{\n    return m_name;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Import.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Import.h\"\n#include <libintl.h>\n\nImport {\n  string\n  Import::name () const\n  {\n      return m_name;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readEntry",
          "args": [
            "str"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "readEntry",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "762-815",
          "snippet": "SymbolEntryPtr \nBytecode::readEntry (bytecodeistream & str)\n{\n    // read reference to namespaces (namespace_id) symbol table (position)\n    int namespace_id = Bytecode::readInt32 (str);\n    int position = Bytecode::readInt32 (str);\n\n    if (namespace_id == -1)\n    {\n#if DO_DEBUG\n\ty2debug( \"Special entry without namespace\" );\n#endif\n\t// FIXME: this may be wrong\n\treturn 0;\n    }\n\n    // get namespace pointer and SymbolEntry within namespace\n    const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n    if (name_space == 0)\n    {\n\ty2error (\"invalid namespace %d for entry\", namespace_id);\n\treturn 0;\n    }\n\n    SymbolEntryPtr sentry;\n    if (position < 0)\t\t\t\t// it's an Xref !\n    {\n\tSymbolTable *table = name_space->table();\n\tif (table == 0)\n\t{\n\t    ycp2error (\"No table associated to xref namespace\\n\");\n\t    exit (1);\n\t}\n\tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n#if DO_DEBUG\n\ty2debug (\"get reference %d from table %p\", position, table);\n#endif\n\tsentry = table->getXRef(position);\n    }\n    else\n    {\n\tsentry = name_space->symbolEntry (position);\n    }\n\n    if (sentry == 0)\n    {\n\ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n\treturn 0;\n    }\n#if DO_DEBUG\n    y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n#endif\n    return sentry;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  SymbolEntryPtr \n  Bytecode::readEntry (bytecodeistream & str)\n  {\n      // read reference to namespaces (namespace_id) symbol table (position)\n      int namespace_id = Bytecode::readInt32 (str);\n      int position = Bytecode::readInt32 (str);\n  \n      if (namespace_id == -1)\n      {\n  #if DO_DEBUG\n  \ty2debug( \"Special entry without namespace\" );\n  #endif\n  \t// FIXME: this may be wrong\n  \treturn 0;\n      }\n  \n      // get namespace pointer and SymbolEntry within namespace\n      const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n      if (name_space == 0)\n      {\n  \ty2error (\"invalid namespace %d for entry\", namespace_id);\n  \treturn 0;\n      }\n  \n      SymbolEntryPtr sentry;\n      if (position < 0)\t\t\t\t// it's an Xref !\n      {\n  \tSymbolTable *table = name_space->table();\n  \tif (table == 0)\n  \t{\n  \t    ycp2error (\"No table associated to xref namespace\\n\");\n  \t    exit (1);\n  \t}\n  \tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n  #if DO_DEBUG\n  \ty2debug (\"get reference %d from table %p\", position, table);\n  #endif\n  \tsentry = table->getXRef(position);\n      }\n      else\n      {\n  \tsentry = name_space->symbolEntry (position);\n      }\n  \n      if (sentry == 0)\n      {\n  \ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n  \treturn 0;\n      }\n  #if DO_DEBUG\n      y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n  #endif\n      return sentry;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  TableEntry::TableEntry (bytecodeistream & str)\n      : m_prev (0)\n      , m_next (0)\n      , m_overloaded_prev (0)\n      , m_overloaded_next (0)\n      , m_outer (0)\n      , m_key (0)\n      , m_entry (0)\n      , m_point (0)\n      , m_table (0)\n  {\n      m_entry = Bytecode::readEntry (str);\n      m_key = m_entry->name();\n      m_point = new Point (str);\n      if (m_entry->category() == SymbolEntry::c_function)\t\t// read function prototype\n      {\n  \t// FIXME: this is weird, why do we do this here???\n  \t((YSymbolEntryPtr)m_entry)->setCode(Bytecode::readCode (str));\n  \tif (((YSymbolEntryPtr)m_entry)->code()->kind() != YCode::ycFunction)\n  \t{\n  \t    y2error (\"TableEntry::fromStream: bad prototype for global function %s\", m_entry->toString().c_str());\n  \t}\n      }\n  }\n}"
  },
  {
    "function_name": "TableEntry",
    "container": "TableEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
    "lines": "42-53",
    "snippet": "TableEntry::TableEntry (const char *key, SymbolEntryPtr entry, const Point *point, SymbolTable *table)\n    : m_prev (0)\n    , m_next (0)\n    , m_overloaded_prev (0)\n    , m_overloaded_next (0)\n    , m_outer (0)\n    , m_key (key)\n    , m_entry (entry)\n    , m_point (point)\n    , m_table (table)\n{\n}",
    "includes": [
      "#include \"ycp/Point.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  TableEntry::TableEntry (const char *key, SymbolEntryPtr entry, const Point *point, SymbolTable *table)\n      : m_prev (0)\n      , m_next (0)\n      , m_overloaded_prev (0)\n      , m_overloaded_next (0)\n      , m_outer (0)\n      , m_key (key)\n      , m_entry (entry)\n      , m_point (point)\n      , m_table (table)\n  {\n  }\n}"
  }
]