[
  {
    "function_name": "otherCommand",
    "container": "ResolverAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
    "lines": "584-600",
    "snippet": "YCPValue ResolverAgent::otherCommand (const YCPTerm& term)\n{\n    string fname = \"/etc/resolv.conf\";\n\n    string symbol = term->name ();\n    if (symbol == \"ResolverAgent\" && term->size () == 1)\n    {\n\tif (term->value(0)->isString())\n\t{\n    \t    fname = term->value (0)->asString ()->value ();\n            y2debug (\"resolving file now: %s\", fname.c_str ());\n\t    cacheValid = false;\n\t    file_name = fname;\n        }\n    }\n    return term;\n}",
    "includes": [
      "#include \"ResolverAgent.h\"",
      "#include <ycp/YCPMap.h>",
      "#include <ycp/y2log.h>",
      "#include <YCP.h>",
      "#include <string>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool cacheValid = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"resolving file now: %s\"",
            "fname.c_str ()"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fname.c_str",
          "args": [],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term->value",
          "args": [],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->value",
          "args": [
            "0"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->size",
          "args": [],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->name",
          "args": [],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2AgentComp",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "44-44",
          "snippet": "string name () const { return my_name; }",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp {\n  string name () const { return my_name; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool cacheValid = false;\n\nResolverAgent {\n  YCPValue ResolverAgent::otherCommand (const YCPTerm& term)\n  {\n      string fname = \"/etc/resolv.conf\";\n  \n      string symbol = term->name ();\n      if (symbol == \"ResolverAgent\" && term->size () == 1)\n      {\n  \tif (term->value(0)->isString())\n  \t{\n      \t    fname = term->value (0)->asString ()->value ();\n              y2debug (\"resolving file now: %s\", fname.c_str ());\n  \t    cacheValid = false;\n  \t    file_name = fname;\n          }\n      }\n      return term;\n  }\n}"
  },
  {
    "function_name": "Dir",
    "container": "ResolverAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
    "lines": "568-582",
    "snippet": "YCPList ResolverAgent::Dir (const YCPPath& path)\n{\n    YCPList retval;\n\n    if (path->isRoot())\n    {\n\tint i = 0;\n\twhile (resolver_keys[i] != 0)\n\t{\n\t    retval->add (YCPString (resolver_keys[i]));\n\t    i = i + 1;\n\t}\n    }\n    return retval;\n}",
    "includes": [
      "#include \"ResolverAgent.h\"",
      "#include <ycp/YCPMap.h>",
      "#include <ycp/y2log.h>",
      "#include <YCP.h>",
      "#include <string>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *resolver_keys[] = {\n  \"search\",\n  \"nameserver\",\n  \"domain\",\n  \"sortlist\",\n  \"options\",\n  0\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "retval->add",
          "args": [
            "YCPString (resolver_keys[i])"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "resolver_keys[i]"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "path->isRoot",
          "args": [],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "isRoot",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "83-87",
          "snippet": "bool\nYCPPathRep::isRoot() const\n{\n    return components.empty();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  bool\n  YCPPathRep::isRoot() const\n  {\n      return components.empty();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic const char *resolver_keys[] = {\n  \"search\",\n  \"nameserver\",\n  \"domain\",\n  \"sortlist\",\n  \"options\",\n  0\n};\n\nResolverAgent {\n  YCPList ResolverAgent::Dir (const YCPPath& path)\n  {\n      YCPList retval;\n  \n      if (path->isRoot())\n      {\n  \tint i = 0;\n  \twhile (resolver_keys[i] != 0)\n  \t{\n  \t    retval->add (YCPString (resolver_keys[i]));\n  \t    i = i + 1;\n  \t}\n      }\n      return retval;\n  }\n}"
  },
  {
    "function_name": "Write",
    "container": "ResolverAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
    "lines": "510-561",
    "snippet": "YCPBoolean\nResolverAgent::Write (const YCPPath& path, const YCPValue& value,\n\t\t      const YCPValue& arg)\n{\n    y2debug (\"Write (.resolver%s, %s)\", path->toString().c_str(),\n\t    value->toString().c_str());\n\n    fillCache (file_name.c_str ());\n\n    if (path->isRoot())\n    {\n\tif (value.isNull() || value->isVoid())\n\t{\n\t    return YCPBoolean (flushCache (file_name.c_str ()) == 0);\n\t}\n\tif (!value->isMap())\n\t{\n\t    ycp2error (\"Bad value to Write (.resolver)\");\n\t    return YCPBoolean (false);\n\t}\n\tlocalCache = value->asMap();\n    }\n    else\n    {\n\tconst char *key = path->component_str(0).c_str();\n\tif ((allowedKey (key) == 0) || allowedInfoKey (key))\n\t{\n\t    localCache->add (YCPString (key), value);\n\t}\n        else if (strcmp (key, \"write_header\") == 0)\n\t{\n            if (value->isBoolean ())\n\t    {\n                writeHeader = value->asBoolean ()->value ();\n            }\n            else\n\t    {\n                ycp2error (\"Bad value to Write (.resolver.write_header)\");\n\t\treturn YCPBoolean (false);\n\t    }\n        }\n\telse\n\t{\n\t    ycp2error (\"Bad key %s for Write(.resolver...)\",\n\t\t       path->component_str(0).c_str ());\n\t    return YCPBoolean (false);\n\t}\n    }\n\n    cacheDirty = true;\n    return YCPBoolean (true);\n}",
    "includes": [
      "#include \"ResolverAgent.h\"",
      "#include <ycp/YCPMap.h>",
      "#include <ycp/y2log.h>",
      "#include <YCP.h>",
      "#include <string>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static YCPMap localCache;",
      "static bool cacheDirty = false;",
      "static bool writeHeader  = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "true"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad key %s for Write(.resolver...)\"",
            "path->component_str(0).c_str ()"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [
            "0"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "component_str",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "161-165",
          "snippet": "string\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  string\n  YCPPathRep::component_str(long index) const\n  {\n      return components[index].component.asString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad value to Write (.resolver.write_header)\""
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->asBoolean",
          "args": [],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "asBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "94-104",
          "snippet": "YCPBoolean\nYCPValueRep::asBoolean() const\n{\n    if (!isBoolean())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPBoolean\n  YCPValueRep::asBoolean() const\n  {\n      if (!isBoolean())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->isBoolean",
          "args": [],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "isBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "62-62",
          "snippet": "bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "key",
            "\"write_header\""
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localCache->add",
          "args": [
            "YCPString (key)",
            "value"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "50-76",
          "snippet": "void\nYCPMapRep::add (const YCPValue& key, const YCPValue& value)\n{\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn;\n    }\n\n    // Note: 'stl_map[key] = value' would create a temporary object using the\n    // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n    // 24.\n\n    YCPMap::iterator pos = stl_map.lower_bound(key);\n    if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n    {\n\tpos->second = value;\n    }\n    else\n    {\n\t// pos is just a hint but can avoid a second search through the map\n\tstl_map.insert(pos, YCPMap::value_type(key, value));\n    }\n\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void\n  YCPMapRep::add (const YCPValue& key, const YCPValue& value)\n  {\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn;\n      }\n  \n      // Note: 'stl_map[key] = value' would create a temporary object using the\n      // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n      // 24.\n  \n      YCPMap::iterator pos = stl_map.lower_bound(key);\n      if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n      {\n  \tpos->second = value;\n      }\n      else\n      {\n  \t// pos is just a hint but can avoid a second search through the map\n  \tstl_map.insert(pos, YCPMap::value_type(key, value));\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "key"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "allowedInfoKey",
          "args": [
            "key"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "allowedInfoKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
          "lines": "85-98",
          "snippet": "bool allowedInfoKey (const char *key)\n{\n    int i = 0;\n    while (headers[i].key != 0)\n    {\n        if (key && (strcmp (key, headers[i].key) == 0))\n\t{\n            return true;\n\t}\n        i = i + 1;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"ResolverAgent.h\"",
            "#include <ycp/YCPMap.h>",
            "#include <ycp/y2log.h>",
            "#include <YCP.h>",
            "#include <string>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const info_entry headers[] = {\n    {\"modified\",    \"# Modified_by:\"},\n    {\"backup\",      \"# Backup:\"},\n    {\"process\",     \"# Process: \"},\n    {\"process_id\",  \"# Process_id: \"},\n    {\"script\",      \"# Script:\"},\n    {\"saveto\",      \"# Saveto:\"},\n    {\"info\",        \"# Info:\"},\n    {0, 0}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic const info_entry headers[] = {\n    {\"modified\",    \"# Modified_by:\"},\n    {\"backup\",      \"# Backup:\"},\n    {\"process\",     \"# Process: \"},\n    {\"process_id\",  \"# Process_id: \"},\n    {\"script\",      \"# Script:\"},\n    {\"saveto\",      \"# Saveto:\"},\n    {\"info\",        \"# Info:\"},\n    {0, 0}\n};\n\nbool allowedInfoKey (const char *key)\n{\n    int i = 0;\n    while (headers[i].key != 0)\n    {\n        if (key && (strcmp (key, headers[i].key) == 0))\n\t{\n            return true;\n\t}\n        i = i + 1;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "allowedKey",
          "args": [
            "key"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "allowedKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
          "lines": "458-470",
          "snippet": "static int allowedKey (const char *key)\n{\n    int i = 0;\n    while (resolver_keys[i] != 0)\n    {\n\tif (strcmp (key, resolver_keys[i]) == 0)\n\t{\n\t    return 0;\n\t}\n\ti = i + 1;\n    }\n    return -1;\n}",
          "includes": [
            "#include \"ResolverAgent.h\"",
            "#include <ycp/YCPMap.h>",
            "#include <ycp/y2log.h>",
            "#include <YCP.h>",
            "#include <string>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *resolver_keys[] = {\n  \"search\",\n  \"nameserver\",\n  \"domain\",\n  \"sortlist\",\n  \"options\",\n  0\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic const char *resolver_keys[] = {\n  \"search\",\n  \"nameserver\",\n  \"domain\",\n  \"sortlist\",\n  \"options\",\n  0\n};\n\nstatic int allowedKey (const char *key)\n{\n    int i = 0;\n    while (resolver_keys[i] != 0)\n    {\n\tif (strcmp (key, resolver_keys[i]) == 0)\n\t{\n\t    return 0;\n\t}\n\ti = i + 1;\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->asMap",
          "args": [],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad value to Write (.resolver)\""
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->isMap",
          "args": [],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "71-71",
          "snippet": "bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "flushCache",
          "args": [
            "file_name.c_str ()"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "flushCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
          "lines": "306-454",
          "snippet": "static int flushCache (const char *filename)\n{\n    if (!cacheValid)\n    {\n\treturn 0;\n    }\n    if (!cacheDirty)\n    {\n\treturn 0;\n    }\n\n    FILE* f = fopen (filename, \"w+\");\n    if (f == 0)\n    {\n\ty2error (\"Can't open %s for writing\", filename);\n\treturn -1;\n    }\n\n    fchmod (fileno (f), 0644);\n\n    // first fill the info header, if needed\n    if (writeHeader)\n    {\n        int i = 0;\n        YCPValue info = YCPNull ();\n        fprintf (f, \"### BEGIN INFO\\n#\\n\");\n        while (headers[i].key != 0)\n\t{\n\t    info = localCache->value (YCPString (headers[i].key));\n\t    if (info.isNull () || info->isVoid ())\n\t    {\n\t\ty2warning (\"Info key %s not found!\", headers[i].key);\n\t    }\n\t    else\n\t    {\n\t\tif (info->isString ())\n\t\t{\n\t\t    fprintf (f, \"%s %s\\n\", headers[i].tag, info->asString ()->value_cstr ());\n\t\t}\n\t\telse\n\t\t{\n\t\t    y2error (\"Wrong type for info key %s!\", headers[i].tag);\n\t\t}\n\t    }\n\t    i = i + 1;\n\t}\n        fprintf (f, \"#\\n### END INFO\\n#\\n\");\n    }\n\n    int retval = 0;\n    YCPMap::const_iterator mptr = localCache->begin();\n\n    while (mptr != localCache->end())\n    {\n\tYCPValue key = mptr->first;\n\tif (key.isNull() || !key->isString())\n\t{\n\t    y2error (\"Bad key in localCache\");\n\t    retval = -1;\n\t    break;\n\t}\n\tstring skey = key->asString()->value();\n\tYCPValue value = mptr->second;\n\n\tif ((skey == \"search\")\n\t    || (skey == \"sortlist\")\n\t    || (skey == \"options\"))\n\t{\n\n\t    if (value.isNull() || !value->isList())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    YCPList list = value->asList();\n\t    if (list->size() < 0)\n\t    {\n\t\ty2error (\"Bad list size for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    if (list->size() == 0)\n\t    {\n\t\tbreak;\n\t    }\n\t    fprintf (f, \"%s\", skey.c_str());\n\t    int i = 0;\n\t    for (i = 0; i < list->size(); i++)\n\t    {\n\t\tif (list->value(i).isNull()\n\t\t    || !list->value(i)->isString())\n\t\t{\n\t\t    y2error (\"Skipping bad list element for key '%s'\", skey.c_str());\n\t\t}\n\t\telse\n\t\t{\n\t\t    fprintf (f, \" %s\", list->value(i)->asString()->value().c_str());\n\t\t}\n\t    }\n\t    fprintf (f, \"\\n\");\n\t}\n\telse if (skey == \"nameserver\")\n\t{\n\t    if (value.isNull() || !value->isList())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    YCPList list = value->asList();\n\t    if (list->size () > 0)\n\t    {\n\t\tint i;\n\t\tfor (i = 0; i < list->size(); i++)\n\t\t{\n\t\t    if (list->value(i).isNull()\n\t\t\t|| !list->value(i)->isString())\n\t\t    {\n\t\t\ty2error (\"Skipping bad list element for key '%s'\", skey.c_str());\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfprintf (f, \"%s %s\\n\", skey.c_str(), list->value(i)->asString()->value().c_str());\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse if (skey == \"domain\")\n\t{\n\t    if (value.isNull() || !value->isString())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n            if (value->asString ()->value ().size () > 0)\n                fprintf (f, \"%s %s\\n\", skey.c_str(), value->asString()->value().c_str());\n\t}\n        else if (allowedInfoKey (skey.c_str ()))\n\t{\n            y2debug (\"Skipping info key '%s'\", skey.c_str());\n        }\n\telse\n\t{\n\t    y2error (\"Skipping invalid key '%s'\", skey.c_str());\n\t}\n\tmptr++;\n    }\n    fclose (f);\n    cacheDirty = false;\n    return retval;\n}",
          "includes": [
            "#include \"ResolverAgent.h\"",
            "#include <ycp/YCPMap.h>",
            "#include <ycp/y2log.h>",
            "#include <YCP.h>",
            "#include <string>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static YCPMap localCache;",
            "static bool cacheDirty = false;",
            "static bool cacheValid = false;",
            "static bool writeHeader  = false;",
            "static const info_entry headers[] = {\n    {\"modified\",    \"# Modified_by:\"},\n    {\"backup\",      \"# Backup:\"},\n    {\"process\",     \"# Process: \"},\n    {\"process_id\",  \"# Process_id: \"},\n    {\"script\",      \"# Script:\"},\n    {\"saveto\",      \"# Saveto:\"},\n    {\"info\",        \"# Info:\"},\n    {0, 0}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic YCPMap localCache;\nstatic bool cacheDirty = false;\nstatic bool cacheValid = false;\nstatic bool writeHeader  = false;\nstatic const info_entry headers[] = {\n    {\"modified\",    \"# Modified_by:\"},\n    {\"backup\",      \"# Backup:\"},\n    {\"process\",     \"# Process: \"},\n    {\"process_id\",  \"# Process_id: \"},\n    {\"script\",      \"# Script:\"},\n    {\"saveto\",      \"# Saveto:\"},\n    {\"info\",        \"# Info:\"},\n    {0, 0}\n};\n\nstatic int flushCache (const char *filename)\n{\n    if (!cacheValid)\n    {\n\treturn 0;\n    }\n    if (!cacheDirty)\n    {\n\treturn 0;\n    }\n\n    FILE* f = fopen (filename, \"w+\");\n    if (f == 0)\n    {\n\ty2error (\"Can't open %s for writing\", filename);\n\treturn -1;\n    }\n\n    fchmod (fileno (f), 0644);\n\n    // first fill the info header, if needed\n    if (writeHeader)\n    {\n        int i = 0;\n        YCPValue info = YCPNull ();\n        fprintf (f, \"### BEGIN INFO\\n#\\n\");\n        while (headers[i].key != 0)\n\t{\n\t    info = localCache->value (YCPString (headers[i].key));\n\t    if (info.isNull () || info->isVoid ())\n\t    {\n\t\ty2warning (\"Info key %s not found!\", headers[i].key);\n\t    }\n\t    else\n\t    {\n\t\tif (info->isString ())\n\t\t{\n\t\t    fprintf (f, \"%s %s\\n\", headers[i].tag, info->asString ()->value_cstr ());\n\t\t}\n\t\telse\n\t\t{\n\t\t    y2error (\"Wrong type for info key %s!\", headers[i].tag);\n\t\t}\n\t    }\n\t    i = i + 1;\n\t}\n        fprintf (f, \"#\\n### END INFO\\n#\\n\");\n    }\n\n    int retval = 0;\n    YCPMap::const_iterator mptr = localCache->begin();\n\n    while (mptr != localCache->end())\n    {\n\tYCPValue key = mptr->first;\n\tif (key.isNull() || !key->isString())\n\t{\n\t    y2error (\"Bad key in localCache\");\n\t    retval = -1;\n\t    break;\n\t}\n\tstring skey = key->asString()->value();\n\tYCPValue value = mptr->second;\n\n\tif ((skey == \"search\")\n\t    || (skey == \"sortlist\")\n\t    || (skey == \"options\"))\n\t{\n\n\t    if (value.isNull() || !value->isList())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    YCPList list = value->asList();\n\t    if (list->size() < 0)\n\t    {\n\t\ty2error (\"Bad list size for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    if (list->size() == 0)\n\t    {\n\t\tbreak;\n\t    }\n\t    fprintf (f, \"%s\", skey.c_str());\n\t    int i = 0;\n\t    for (i = 0; i < list->size(); i++)\n\t    {\n\t\tif (list->value(i).isNull()\n\t\t    || !list->value(i)->isString())\n\t\t{\n\t\t    y2error (\"Skipping bad list element for key '%s'\", skey.c_str());\n\t\t}\n\t\telse\n\t\t{\n\t\t    fprintf (f, \" %s\", list->value(i)->asString()->value().c_str());\n\t\t}\n\t    }\n\t    fprintf (f, \"\\n\");\n\t}\n\telse if (skey == \"nameserver\")\n\t{\n\t    if (value.isNull() || !value->isList())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    YCPList list = value->asList();\n\t    if (list->size () > 0)\n\t    {\n\t\tint i;\n\t\tfor (i = 0; i < list->size(); i++)\n\t\t{\n\t\t    if (list->value(i).isNull()\n\t\t\t|| !list->value(i)->isString())\n\t\t    {\n\t\t\ty2error (\"Skipping bad list element for key '%s'\", skey.c_str());\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfprintf (f, \"%s %s\\n\", skey.c_str(), list->value(i)->asString()->value().c_str());\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse if (skey == \"domain\")\n\t{\n\t    if (value.isNull() || !value->isString())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n            if (value->asString ()->value ().size () > 0)\n                fprintf (f, \"%s %s\\n\", skey.c_str(), value->asString()->value().c_str());\n\t}\n        else if (allowedInfoKey (skey.c_str ()))\n\t{\n            y2debug (\"Skipping info key '%s'\", skey.c_str());\n        }\n\telse\n\t{\n\t    y2error (\"Skipping invalid key '%s'\", skey.c_str());\n\t}\n\tmptr++;\n    }\n    fclose (f);\n    cacheDirty = false;\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_name.c_str",
          "args": [],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->isVoid",
          "args": [],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->isRoot",
          "args": [],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "isRoot",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "83-87",
          "snippet": "bool\nYCPPathRep::isRoot() const\n{\n    return components.empty();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  bool\n  YCPPathRep::isRoot() const\n  {\n      return components.empty();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fillCache",
          "args": [
            "file_name.c_str ()"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "fillCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
          "lines": "135-301",
          "snippet": "static int fillCache (const char *filename)\n{\n    if (cacheValid)\n\treturn 0;\n\n    y2debug (\"fillCache\");\n\n    FILE *f;\n\n    f = fopen (filename, \"r\");\n    if (f == 0) {\n\ty2error (\"Can't access %s: %s\", filename, strerror(errno));\n\treturn -1;\n    }\n\n    const int lbufsize = 1024;\n    char lbuf[lbufsize+2];\t// add \\n\\0\n    int retval = 0;\n    char *lptr;\n    bool processing_info = false;\n    string info_buf = \"\";\n    const char *last_key = 0;\n    YCPMap info_map;\n\n    localCache = YCPMap();\t// initialize with empty map\n\n    while (fgets (lbuf, lbufsize, f) != 0)\n    {\n\ty2debug (\"fread(%s)\", lbuf);\n\n\tlptr = strchr (lbuf, '#');\t// process comment\n\tif (lptr != 0)\n        {\n            if (strncmp (lbuf, \"### BEGIN INFO\", 14) == 0)\n            {\n                processing_info = true;\n                continue;\n            }\n            if (strncmp (lbuf, \"### END INFO\", 12) == 0)\n            {\n                if (last_key)   // one more key to process\n\t\t{  \n                    localCache->add (YCPString (last_key), YCPString ((info_buf.substr (0, info_buf.length () - 1)).c_str ()));\n\t\t}\n                if (!processing_info) y2warning (\"End of info without beggining!\");\n                processing_info = false;\n                continue;\n            }\n            if (const char *key = findKey (lbuf))\n            {\n                if (last_key)\n\t\t{\n                    localCache->add (YCPString (last_key), YCPString ((info_buf.substr (0, info_buf.length () - 1)).c_str ()));\n\t\t}\n\n                if (char *info = strchr (lbuf, ':'))\n\t\t{\n                    info_buf = eatWhitespaces (strlen (info) > 0 ? info + 1 : info);\n\t\t}\n                last_key = key;\n                continue;\n            }\n            else if (processing_info)\n\t    {\n                info_buf = info_buf + lbuf; // keep the other lines with '#' at the begging and '\\n' in the end\n\t    }\n\t    *lptr = 0;          // don't care about other comments\n        }\n\n\tif (lbuf[0] == '\\0'\t\t// skip other comment lines\n\t    || lbuf[0] == '\\n')\n\t{\n\t    continue;\n\t}\n\tlptr = nextWhitespace (lbuf);\t// break line at first whitespace\n\ty2debug (\"next(%s)\", lptr);\n\n\tif (lptr == 0\n\t    || *lptr == '\\n'\n\t    || *lptr == 0)\t\t\t// skip lines without <key><ws><value> syntax\n\t{\n\t    continue;\n\t}\n\t*lptr++ = 0;\n\n\tYCPValue value = YCPNull();\n\tchar *vptr = eatWhitespaces (lptr);\n\n\ty2debug (\"key(%s)\", lbuf);\n\n\tconst YCPString key (lbuf);\n\n\t// list of strings as value\n\n\tif ((strcmp  (lbuf, \"search\") == 0)\n\t   || (strcmp  (lbuf, \"sortlist\") == 0)\n\t   || (strcmp  (lbuf, \"options\") == 0))\n\t{\n\n\t    y2debug (\"list of strings '%s'\", lbuf);\n\n\t    YCPList ret;\n\n\t    for (;;)\n\t    {\n\t\tlptr = nextWhitespace (vptr);\n\t\tif ((lptr == 0)\n\t\t    || (lptr == vptr))\n\t\t{\n\t\t    break;\n\t\t}\n\t\t*lptr++ = 0;\n\t\tret->add (YCPString (vptr));\n\t\tvptr = eatWhitespaces (lptr);\n\t    }\n\n\t    value = ret;\n\t}\n\n\t// single value, but multiple lines allowed\n\n\telse if (strcmp (lbuf, \"nameserver\") == 0)\n\t{\n\n\t    y2debug (\"multiple lines '%s':'%s'\", lbuf, vptr);\n\n\t    value = localCache->value (key);\n\t    if (value.isNull())\n\t    {\n\t\tvalue = YCPList();\n\t    }\n\t    lptr = nextWhitespace (vptr);\n\t    *lptr = 0;\n\t    value = value->asList()->functionalAdd (YCPString (vptr));\n\t}\n\n\t// single value\n\n\telse if (strcmp (lbuf, \"domain\") == 0)\n\t{\n\n\t    y2debug (\"single value '%s'\", lbuf);\n\n\t    lptr = nextWhitespace (vptr);\n\t    *lptr = 0;\n\t    value = YCPString (vptr);\n\t}\n\telse\n\t{\n\t    y2warning (\"key '%s' not recognized\", lbuf);\n\t}\n\n\tlocalCache->add (key, value);\n    }\n\n    if (!feof (f))\n    {\n\ty2error (\"Can't completely read %s\", filename);\n\tretval = -1;\n    }\n\n    fclose (f);\n\n    cacheValid = true;\n\n    return retval;\n}",
          "includes": [
            "#include \"ResolverAgent.h\"",
            "#include <ycp/YCPMap.h>",
            "#include <ycp/y2log.h>",
            "#include <YCP.h>",
            "#include <string>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static YCPMap localCache;",
            "static bool cacheValid = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic YCPMap localCache;\nstatic bool cacheValid = false;\n\nstatic int fillCache (const char *filename)\n{\n    if (cacheValid)\n\treturn 0;\n\n    y2debug (\"fillCache\");\n\n    FILE *f;\n\n    f = fopen (filename, \"r\");\n    if (f == 0) {\n\ty2error (\"Can't access %s: %s\", filename, strerror(errno));\n\treturn -1;\n    }\n\n    const int lbufsize = 1024;\n    char lbuf[lbufsize+2];\t// add \\n\\0\n    int retval = 0;\n    char *lptr;\n    bool processing_info = false;\n    string info_buf = \"\";\n    const char *last_key = 0;\n    YCPMap info_map;\n\n    localCache = YCPMap();\t// initialize with empty map\n\n    while (fgets (lbuf, lbufsize, f) != 0)\n    {\n\ty2debug (\"fread(%s)\", lbuf);\n\n\tlptr = strchr (lbuf, '#');\t// process comment\n\tif (lptr != 0)\n        {\n            if (strncmp (lbuf, \"### BEGIN INFO\", 14) == 0)\n            {\n                processing_info = true;\n                continue;\n            }\n            if (strncmp (lbuf, \"### END INFO\", 12) == 0)\n            {\n                if (last_key)   // one more key to process\n\t\t{  \n                    localCache->add (YCPString (last_key), YCPString ((info_buf.substr (0, info_buf.length () - 1)).c_str ()));\n\t\t}\n                if (!processing_info) y2warning (\"End of info without beggining!\");\n                processing_info = false;\n                continue;\n            }\n            if (const char *key = findKey (lbuf))\n            {\n                if (last_key)\n\t\t{\n                    localCache->add (YCPString (last_key), YCPString ((info_buf.substr (0, info_buf.length () - 1)).c_str ()));\n\t\t}\n\n                if (char *info = strchr (lbuf, ':'))\n\t\t{\n                    info_buf = eatWhitespaces (strlen (info) > 0 ? info + 1 : info);\n\t\t}\n                last_key = key;\n                continue;\n            }\n            else if (processing_info)\n\t    {\n                info_buf = info_buf + lbuf; // keep the other lines with '#' at the begging and '\\n' in the end\n\t    }\n\t    *lptr = 0;          // don't care about other comments\n        }\n\n\tif (lbuf[0] == '\\0'\t\t// skip other comment lines\n\t    || lbuf[0] == '\\n')\n\t{\n\t    continue;\n\t}\n\tlptr = nextWhitespace (lbuf);\t// break line at first whitespace\n\ty2debug (\"next(%s)\", lptr);\n\n\tif (lptr == 0\n\t    || *lptr == '\\n'\n\t    || *lptr == 0)\t\t\t// skip lines without <key><ws><value> syntax\n\t{\n\t    continue;\n\t}\n\t*lptr++ = 0;\n\n\tYCPValue value = YCPNull();\n\tchar *vptr = eatWhitespaces (lptr);\n\n\ty2debug (\"key(%s)\", lbuf);\n\n\tconst YCPString key (lbuf);\n\n\t// list of strings as value\n\n\tif ((strcmp  (lbuf, \"search\") == 0)\n\t   || (strcmp  (lbuf, \"sortlist\") == 0)\n\t   || (strcmp  (lbuf, \"options\") == 0))\n\t{\n\n\t    y2debug (\"list of strings '%s'\", lbuf);\n\n\t    YCPList ret;\n\n\t    for (;;)\n\t    {\n\t\tlptr = nextWhitespace (vptr);\n\t\tif ((lptr == 0)\n\t\t    || (lptr == vptr))\n\t\t{\n\t\t    break;\n\t\t}\n\t\t*lptr++ = 0;\n\t\tret->add (YCPString (vptr));\n\t\tvptr = eatWhitespaces (lptr);\n\t    }\n\n\t    value = ret;\n\t}\n\n\t// single value, but multiple lines allowed\n\n\telse if (strcmp (lbuf, \"nameserver\") == 0)\n\t{\n\n\t    y2debug (\"multiple lines '%s':'%s'\", lbuf, vptr);\n\n\t    value = localCache->value (key);\n\t    if (value.isNull())\n\t    {\n\t\tvalue = YCPList();\n\t    }\n\t    lptr = nextWhitespace (vptr);\n\t    *lptr = 0;\n\t    value = value->asList()->functionalAdd (YCPString (vptr));\n\t}\n\n\t// single value\n\n\telse if (strcmp (lbuf, \"domain\") == 0)\n\t{\n\n\t    y2debug (\"single value '%s'\", lbuf);\n\n\t    lptr = nextWhitespace (vptr);\n\t    *lptr = 0;\n\t    value = YCPString (vptr);\n\t}\n\telse\n\t{\n\t    y2warning (\"key '%s' not recognized\", lbuf);\n\t}\n\n\tlocalCache->add (key, value);\n    }\n\n    if (!feof (f))\n    {\n\ty2error (\"Can't completely read %s\", filename);\n\tretval = -1;\n    }\n\n    fclose (f);\n\n    cacheValid = true;\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_name.c_str",
          "args": [],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Write (.resolver%s, %s)\"",
            "path->toString().c_str()",
            "value->toString().c_str()"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic YCPMap localCache;\nstatic bool cacheDirty = false;\nstatic bool writeHeader  = false;\n\nResolverAgent {\n  YCPBoolean\n  ResolverAgent::Write (const YCPPath& path, const YCPValue& value,\n  \t\t      const YCPValue& arg)\n  {\n      y2debug (\"Write (.resolver%s, %s)\", path->toString().c_str(),\n  \t    value->toString().c_str());\n  \n      fillCache (file_name.c_str ());\n  \n      if (path->isRoot())\n      {\n  \tif (value.isNull() || value->isVoid())\n  \t{\n  \t    return YCPBoolean (flushCache (file_name.c_str ()) == 0);\n  \t}\n  \tif (!value->isMap())\n  \t{\n  \t    ycp2error (\"Bad value to Write (.resolver)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \tlocalCache = value->asMap();\n      }\n      else\n      {\n  \tconst char *key = path->component_str(0).c_str();\n  \tif ((allowedKey (key) == 0) || allowedInfoKey (key))\n  \t{\n  \t    localCache->add (YCPString (key), value);\n  \t}\n          else if (strcmp (key, \"write_header\") == 0)\n  \t{\n              if (value->isBoolean ())\n  \t    {\n                  writeHeader = value->asBoolean ()->value ();\n              }\n              else\n  \t    {\n                  ycp2error (\"Bad value to Write (.resolver.write_header)\");\n  \t\treturn YCPBoolean (false);\n  \t    }\n          }\n  \telse\n  \t{\n  \t    ycp2error (\"Bad key %s for Write(.resolver...)\",\n  \t\t       path->component_str(0).c_str ());\n  \t    return YCPBoolean (false);\n  \t}\n      }\n  \n      cacheDirty = true;\n      return YCPBoolean (true);\n  }\n}"
  },
  {
    "function_name": "Read",
    "container": "ResolverAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
    "lines": "489-507",
    "snippet": "YCPValue\nResolverAgent::Read (const YCPPath& path, const YCPValue& arg, const YCPValue& optarg)\n{\n    y2debug (\"Read(.resolver%s)\", path->toString().c_str());\n\n    fillCache (file_name.c_str ());\n\n    if (path->isRoot())\n    {\n\treturn localCache;\n    }\n\n    YCPValue ret = localCache->value (YCPString (path->component_str(0)));\n    if (ret.isNull ())\n    {\n\treturn YCPVoid ();\n    }\n    return ret;\n}",
    "includes": [
      "#include \"ResolverAgent.h\"",
      "#include <ycp/YCPMap.h>",
      "#include <ycp/y2log.h>",
      "#include <YCP.h>",
      "#include <string>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static YCPMap localCache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ret.isNull",
          "args": [],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localCache->value",
          "args": [
            "YCPString (path->component_str(0))"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "path->component_str(0)"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [
            "0"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "component_str",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "161-165",
          "snippet": "string\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  string\n  YCPPathRep::component_str(long index) const\n  {\n      return components[index].component.asString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "path->isRoot",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "isRoot",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "83-87",
          "snippet": "bool\nYCPPathRep::isRoot() const\n{\n    return components.empty();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  bool\n  YCPPathRep::isRoot() const\n  {\n      return components.empty();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fillCache",
          "args": [
            "file_name.c_str ()"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "fillCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
          "lines": "135-301",
          "snippet": "static int fillCache (const char *filename)\n{\n    if (cacheValid)\n\treturn 0;\n\n    y2debug (\"fillCache\");\n\n    FILE *f;\n\n    f = fopen (filename, \"r\");\n    if (f == 0) {\n\ty2error (\"Can't access %s: %s\", filename, strerror(errno));\n\treturn -1;\n    }\n\n    const int lbufsize = 1024;\n    char lbuf[lbufsize+2];\t// add \\n\\0\n    int retval = 0;\n    char *lptr;\n    bool processing_info = false;\n    string info_buf = \"\";\n    const char *last_key = 0;\n    YCPMap info_map;\n\n    localCache = YCPMap();\t// initialize with empty map\n\n    while (fgets (lbuf, lbufsize, f) != 0)\n    {\n\ty2debug (\"fread(%s)\", lbuf);\n\n\tlptr = strchr (lbuf, '#');\t// process comment\n\tif (lptr != 0)\n        {\n            if (strncmp (lbuf, \"### BEGIN INFO\", 14) == 0)\n            {\n                processing_info = true;\n                continue;\n            }\n            if (strncmp (lbuf, \"### END INFO\", 12) == 0)\n            {\n                if (last_key)   // one more key to process\n\t\t{  \n                    localCache->add (YCPString (last_key), YCPString ((info_buf.substr (0, info_buf.length () - 1)).c_str ()));\n\t\t}\n                if (!processing_info) y2warning (\"End of info without beggining!\");\n                processing_info = false;\n                continue;\n            }\n            if (const char *key = findKey (lbuf))\n            {\n                if (last_key)\n\t\t{\n                    localCache->add (YCPString (last_key), YCPString ((info_buf.substr (0, info_buf.length () - 1)).c_str ()));\n\t\t}\n\n                if (char *info = strchr (lbuf, ':'))\n\t\t{\n                    info_buf = eatWhitespaces (strlen (info) > 0 ? info + 1 : info);\n\t\t}\n                last_key = key;\n                continue;\n            }\n            else if (processing_info)\n\t    {\n                info_buf = info_buf + lbuf; // keep the other lines with '#' at the begging and '\\n' in the end\n\t    }\n\t    *lptr = 0;          // don't care about other comments\n        }\n\n\tif (lbuf[0] == '\\0'\t\t// skip other comment lines\n\t    || lbuf[0] == '\\n')\n\t{\n\t    continue;\n\t}\n\tlptr = nextWhitespace (lbuf);\t// break line at first whitespace\n\ty2debug (\"next(%s)\", lptr);\n\n\tif (lptr == 0\n\t    || *lptr == '\\n'\n\t    || *lptr == 0)\t\t\t// skip lines without <key><ws><value> syntax\n\t{\n\t    continue;\n\t}\n\t*lptr++ = 0;\n\n\tYCPValue value = YCPNull();\n\tchar *vptr = eatWhitespaces (lptr);\n\n\ty2debug (\"key(%s)\", lbuf);\n\n\tconst YCPString key (lbuf);\n\n\t// list of strings as value\n\n\tif ((strcmp  (lbuf, \"search\") == 0)\n\t   || (strcmp  (lbuf, \"sortlist\") == 0)\n\t   || (strcmp  (lbuf, \"options\") == 0))\n\t{\n\n\t    y2debug (\"list of strings '%s'\", lbuf);\n\n\t    YCPList ret;\n\n\t    for (;;)\n\t    {\n\t\tlptr = nextWhitespace (vptr);\n\t\tif ((lptr == 0)\n\t\t    || (lptr == vptr))\n\t\t{\n\t\t    break;\n\t\t}\n\t\t*lptr++ = 0;\n\t\tret->add (YCPString (vptr));\n\t\tvptr = eatWhitespaces (lptr);\n\t    }\n\n\t    value = ret;\n\t}\n\n\t// single value, but multiple lines allowed\n\n\telse if (strcmp (lbuf, \"nameserver\") == 0)\n\t{\n\n\t    y2debug (\"multiple lines '%s':'%s'\", lbuf, vptr);\n\n\t    value = localCache->value (key);\n\t    if (value.isNull())\n\t    {\n\t\tvalue = YCPList();\n\t    }\n\t    lptr = nextWhitespace (vptr);\n\t    *lptr = 0;\n\t    value = value->asList()->functionalAdd (YCPString (vptr));\n\t}\n\n\t// single value\n\n\telse if (strcmp (lbuf, \"domain\") == 0)\n\t{\n\n\t    y2debug (\"single value '%s'\", lbuf);\n\n\t    lptr = nextWhitespace (vptr);\n\t    *lptr = 0;\n\t    value = YCPString (vptr);\n\t}\n\telse\n\t{\n\t    y2warning (\"key '%s' not recognized\", lbuf);\n\t}\n\n\tlocalCache->add (key, value);\n    }\n\n    if (!feof (f))\n    {\n\ty2error (\"Can't completely read %s\", filename);\n\tretval = -1;\n    }\n\n    fclose (f);\n\n    cacheValid = true;\n\n    return retval;\n}",
          "includes": [
            "#include \"ResolverAgent.h\"",
            "#include <ycp/YCPMap.h>",
            "#include <ycp/y2log.h>",
            "#include <YCP.h>",
            "#include <string>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static YCPMap localCache;",
            "static bool cacheValid = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic YCPMap localCache;\nstatic bool cacheValid = false;\n\nstatic int fillCache (const char *filename)\n{\n    if (cacheValid)\n\treturn 0;\n\n    y2debug (\"fillCache\");\n\n    FILE *f;\n\n    f = fopen (filename, \"r\");\n    if (f == 0) {\n\ty2error (\"Can't access %s: %s\", filename, strerror(errno));\n\treturn -1;\n    }\n\n    const int lbufsize = 1024;\n    char lbuf[lbufsize+2];\t// add \\n\\0\n    int retval = 0;\n    char *lptr;\n    bool processing_info = false;\n    string info_buf = \"\";\n    const char *last_key = 0;\n    YCPMap info_map;\n\n    localCache = YCPMap();\t// initialize with empty map\n\n    while (fgets (lbuf, lbufsize, f) != 0)\n    {\n\ty2debug (\"fread(%s)\", lbuf);\n\n\tlptr = strchr (lbuf, '#');\t// process comment\n\tif (lptr != 0)\n        {\n            if (strncmp (lbuf, \"### BEGIN INFO\", 14) == 0)\n            {\n                processing_info = true;\n                continue;\n            }\n            if (strncmp (lbuf, \"### END INFO\", 12) == 0)\n            {\n                if (last_key)   // one more key to process\n\t\t{  \n                    localCache->add (YCPString (last_key), YCPString ((info_buf.substr (0, info_buf.length () - 1)).c_str ()));\n\t\t}\n                if (!processing_info) y2warning (\"End of info without beggining!\");\n                processing_info = false;\n                continue;\n            }\n            if (const char *key = findKey (lbuf))\n            {\n                if (last_key)\n\t\t{\n                    localCache->add (YCPString (last_key), YCPString ((info_buf.substr (0, info_buf.length () - 1)).c_str ()));\n\t\t}\n\n                if (char *info = strchr (lbuf, ':'))\n\t\t{\n                    info_buf = eatWhitespaces (strlen (info) > 0 ? info + 1 : info);\n\t\t}\n                last_key = key;\n                continue;\n            }\n            else if (processing_info)\n\t    {\n                info_buf = info_buf + lbuf; // keep the other lines with '#' at the begging and '\\n' in the end\n\t    }\n\t    *lptr = 0;          // don't care about other comments\n        }\n\n\tif (lbuf[0] == '\\0'\t\t// skip other comment lines\n\t    || lbuf[0] == '\\n')\n\t{\n\t    continue;\n\t}\n\tlptr = nextWhitespace (lbuf);\t// break line at first whitespace\n\ty2debug (\"next(%s)\", lptr);\n\n\tif (lptr == 0\n\t    || *lptr == '\\n'\n\t    || *lptr == 0)\t\t\t// skip lines without <key><ws><value> syntax\n\t{\n\t    continue;\n\t}\n\t*lptr++ = 0;\n\n\tYCPValue value = YCPNull();\n\tchar *vptr = eatWhitespaces (lptr);\n\n\ty2debug (\"key(%s)\", lbuf);\n\n\tconst YCPString key (lbuf);\n\n\t// list of strings as value\n\n\tif ((strcmp  (lbuf, \"search\") == 0)\n\t   || (strcmp  (lbuf, \"sortlist\") == 0)\n\t   || (strcmp  (lbuf, \"options\") == 0))\n\t{\n\n\t    y2debug (\"list of strings '%s'\", lbuf);\n\n\t    YCPList ret;\n\n\t    for (;;)\n\t    {\n\t\tlptr = nextWhitespace (vptr);\n\t\tif ((lptr == 0)\n\t\t    || (lptr == vptr))\n\t\t{\n\t\t    break;\n\t\t}\n\t\t*lptr++ = 0;\n\t\tret->add (YCPString (vptr));\n\t\tvptr = eatWhitespaces (lptr);\n\t    }\n\n\t    value = ret;\n\t}\n\n\t// single value, but multiple lines allowed\n\n\telse if (strcmp (lbuf, \"nameserver\") == 0)\n\t{\n\n\t    y2debug (\"multiple lines '%s':'%s'\", lbuf, vptr);\n\n\t    value = localCache->value (key);\n\t    if (value.isNull())\n\t    {\n\t\tvalue = YCPList();\n\t    }\n\t    lptr = nextWhitespace (vptr);\n\t    *lptr = 0;\n\t    value = value->asList()->functionalAdd (YCPString (vptr));\n\t}\n\n\t// single value\n\n\telse if (strcmp (lbuf, \"domain\") == 0)\n\t{\n\n\t    y2debug (\"single value '%s'\", lbuf);\n\n\t    lptr = nextWhitespace (vptr);\n\t    *lptr = 0;\n\t    value = YCPString (vptr);\n\t}\n\telse\n\t{\n\t    y2warning (\"key '%s' not recognized\", lbuf);\n\t}\n\n\tlocalCache->add (key, value);\n    }\n\n    if (!feof (f))\n    {\n\ty2error (\"Can't completely read %s\", filename);\n\tretval = -1;\n    }\n\n    fclose (f);\n\n    cacheValid = true;\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_name.c_str",
          "args": [],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Read(.resolver%s)\"",
            "path->toString().c_str()"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->toString",
          "args": [],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic YCPMap localCache;\n\nResolverAgent {\n  YCPValue\n  ResolverAgent::Read (const YCPPath& path, const YCPValue& arg, const YCPValue& optarg)\n  {\n      y2debug (\"Read(.resolver%s)\", path->toString().c_str());\n  \n      fillCache (file_name.c_str ());\n  \n      if (path->isRoot())\n      {\n  \treturn localCache;\n      }\n  \n      YCPValue ret = localCache->value (YCPString (path->component_str(0)));\n      if (ret.isNull ())\n      {\n  \treturn YCPVoid ();\n      }\n      return ret;\n  }\n}"
  },
  {
    "function_name": "~ResolverAgent",
    "container": "ResolverAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
    "lines": "480-486",
    "snippet": "ResolverAgent::~ResolverAgent ()\n{\n    if (cacheValid && cacheDirty)\n    {\n\tflushCache(file_name.c_str ());\n    }\n}",
    "includes": [
      "#include \"ResolverAgent.h\"",
      "#include <ycp/YCPMap.h>",
      "#include <ycp/y2log.h>",
      "#include <YCP.h>",
      "#include <string>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool cacheDirty = false;",
      "static bool cacheValid = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flushCache",
          "args": [
            "file_name.c_str ()"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "flushCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
          "lines": "306-454",
          "snippet": "static int flushCache (const char *filename)\n{\n    if (!cacheValid)\n    {\n\treturn 0;\n    }\n    if (!cacheDirty)\n    {\n\treturn 0;\n    }\n\n    FILE* f = fopen (filename, \"w+\");\n    if (f == 0)\n    {\n\ty2error (\"Can't open %s for writing\", filename);\n\treturn -1;\n    }\n\n    fchmod (fileno (f), 0644);\n\n    // first fill the info header, if needed\n    if (writeHeader)\n    {\n        int i = 0;\n        YCPValue info = YCPNull ();\n        fprintf (f, \"### BEGIN INFO\\n#\\n\");\n        while (headers[i].key != 0)\n\t{\n\t    info = localCache->value (YCPString (headers[i].key));\n\t    if (info.isNull () || info->isVoid ())\n\t    {\n\t\ty2warning (\"Info key %s not found!\", headers[i].key);\n\t    }\n\t    else\n\t    {\n\t\tif (info->isString ())\n\t\t{\n\t\t    fprintf (f, \"%s %s\\n\", headers[i].tag, info->asString ()->value_cstr ());\n\t\t}\n\t\telse\n\t\t{\n\t\t    y2error (\"Wrong type for info key %s!\", headers[i].tag);\n\t\t}\n\t    }\n\t    i = i + 1;\n\t}\n        fprintf (f, \"#\\n### END INFO\\n#\\n\");\n    }\n\n    int retval = 0;\n    YCPMap::const_iterator mptr = localCache->begin();\n\n    while (mptr != localCache->end())\n    {\n\tYCPValue key = mptr->first;\n\tif (key.isNull() || !key->isString())\n\t{\n\t    y2error (\"Bad key in localCache\");\n\t    retval = -1;\n\t    break;\n\t}\n\tstring skey = key->asString()->value();\n\tYCPValue value = mptr->second;\n\n\tif ((skey == \"search\")\n\t    || (skey == \"sortlist\")\n\t    || (skey == \"options\"))\n\t{\n\n\t    if (value.isNull() || !value->isList())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    YCPList list = value->asList();\n\t    if (list->size() < 0)\n\t    {\n\t\ty2error (\"Bad list size for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    if (list->size() == 0)\n\t    {\n\t\tbreak;\n\t    }\n\t    fprintf (f, \"%s\", skey.c_str());\n\t    int i = 0;\n\t    for (i = 0; i < list->size(); i++)\n\t    {\n\t\tif (list->value(i).isNull()\n\t\t    || !list->value(i)->isString())\n\t\t{\n\t\t    y2error (\"Skipping bad list element for key '%s'\", skey.c_str());\n\t\t}\n\t\telse\n\t\t{\n\t\t    fprintf (f, \" %s\", list->value(i)->asString()->value().c_str());\n\t\t}\n\t    }\n\t    fprintf (f, \"\\n\");\n\t}\n\telse if (skey == \"nameserver\")\n\t{\n\t    if (value.isNull() || !value->isList())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    YCPList list = value->asList();\n\t    if (list->size () > 0)\n\t    {\n\t\tint i;\n\t\tfor (i = 0; i < list->size(); i++)\n\t\t{\n\t\t    if (list->value(i).isNull()\n\t\t\t|| !list->value(i)->isString())\n\t\t    {\n\t\t\ty2error (\"Skipping bad list element for key '%s'\", skey.c_str());\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfprintf (f, \"%s %s\\n\", skey.c_str(), list->value(i)->asString()->value().c_str());\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse if (skey == \"domain\")\n\t{\n\t    if (value.isNull() || !value->isString())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n            if (value->asString ()->value ().size () > 0)\n                fprintf (f, \"%s %s\\n\", skey.c_str(), value->asString()->value().c_str());\n\t}\n        else if (allowedInfoKey (skey.c_str ()))\n\t{\n            y2debug (\"Skipping info key '%s'\", skey.c_str());\n        }\n\telse\n\t{\n\t    y2error (\"Skipping invalid key '%s'\", skey.c_str());\n\t}\n\tmptr++;\n    }\n    fclose (f);\n    cacheDirty = false;\n    return retval;\n}",
          "includes": [
            "#include \"ResolverAgent.h\"",
            "#include <ycp/YCPMap.h>",
            "#include <ycp/y2log.h>",
            "#include <YCP.h>",
            "#include <string>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static YCPMap localCache;",
            "static bool cacheDirty = false;",
            "static bool cacheValid = false;",
            "static bool writeHeader  = false;",
            "static const info_entry headers[] = {\n    {\"modified\",    \"# Modified_by:\"},\n    {\"backup\",      \"# Backup:\"},\n    {\"process\",     \"# Process: \"},\n    {\"process_id\",  \"# Process_id: \"},\n    {\"script\",      \"# Script:\"},\n    {\"saveto\",      \"# Saveto:\"},\n    {\"info\",        \"# Info:\"},\n    {0, 0}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic YCPMap localCache;\nstatic bool cacheDirty = false;\nstatic bool cacheValid = false;\nstatic bool writeHeader  = false;\nstatic const info_entry headers[] = {\n    {\"modified\",    \"# Modified_by:\"},\n    {\"backup\",      \"# Backup:\"},\n    {\"process\",     \"# Process: \"},\n    {\"process_id\",  \"# Process_id: \"},\n    {\"script\",      \"# Script:\"},\n    {\"saveto\",      \"# Saveto:\"},\n    {\"info\",        \"# Info:\"},\n    {0, 0}\n};\n\nstatic int flushCache (const char *filename)\n{\n    if (!cacheValid)\n    {\n\treturn 0;\n    }\n    if (!cacheDirty)\n    {\n\treturn 0;\n    }\n\n    FILE* f = fopen (filename, \"w+\");\n    if (f == 0)\n    {\n\ty2error (\"Can't open %s for writing\", filename);\n\treturn -1;\n    }\n\n    fchmod (fileno (f), 0644);\n\n    // first fill the info header, if needed\n    if (writeHeader)\n    {\n        int i = 0;\n        YCPValue info = YCPNull ();\n        fprintf (f, \"### BEGIN INFO\\n#\\n\");\n        while (headers[i].key != 0)\n\t{\n\t    info = localCache->value (YCPString (headers[i].key));\n\t    if (info.isNull () || info->isVoid ())\n\t    {\n\t\ty2warning (\"Info key %s not found!\", headers[i].key);\n\t    }\n\t    else\n\t    {\n\t\tif (info->isString ())\n\t\t{\n\t\t    fprintf (f, \"%s %s\\n\", headers[i].tag, info->asString ()->value_cstr ());\n\t\t}\n\t\telse\n\t\t{\n\t\t    y2error (\"Wrong type for info key %s!\", headers[i].tag);\n\t\t}\n\t    }\n\t    i = i + 1;\n\t}\n        fprintf (f, \"#\\n### END INFO\\n#\\n\");\n    }\n\n    int retval = 0;\n    YCPMap::const_iterator mptr = localCache->begin();\n\n    while (mptr != localCache->end())\n    {\n\tYCPValue key = mptr->first;\n\tif (key.isNull() || !key->isString())\n\t{\n\t    y2error (\"Bad key in localCache\");\n\t    retval = -1;\n\t    break;\n\t}\n\tstring skey = key->asString()->value();\n\tYCPValue value = mptr->second;\n\n\tif ((skey == \"search\")\n\t    || (skey == \"sortlist\")\n\t    || (skey == \"options\"))\n\t{\n\n\t    if (value.isNull() || !value->isList())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    YCPList list = value->asList();\n\t    if (list->size() < 0)\n\t    {\n\t\ty2error (\"Bad list size for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    if (list->size() == 0)\n\t    {\n\t\tbreak;\n\t    }\n\t    fprintf (f, \"%s\", skey.c_str());\n\t    int i = 0;\n\t    for (i = 0; i < list->size(); i++)\n\t    {\n\t\tif (list->value(i).isNull()\n\t\t    || !list->value(i)->isString())\n\t\t{\n\t\t    y2error (\"Skipping bad list element for key '%s'\", skey.c_str());\n\t\t}\n\t\telse\n\t\t{\n\t\t    fprintf (f, \" %s\", list->value(i)->asString()->value().c_str());\n\t\t}\n\t    }\n\t    fprintf (f, \"\\n\");\n\t}\n\telse if (skey == \"nameserver\")\n\t{\n\t    if (value.isNull() || !value->isList())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    YCPList list = value->asList();\n\t    if (list->size () > 0)\n\t    {\n\t\tint i;\n\t\tfor (i = 0; i < list->size(); i++)\n\t\t{\n\t\t    if (list->value(i).isNull()\n\t\t\t|| !list->value(i)->isString())\n\t\t    {\n\t\t\ty2error (\"Skipping bad list element for key '%s'\", skey.c_str());\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfprintf (f, \"%s %s\\n\", skey.c_str(), list->value(i)->asString()->value().c_str());\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse if (skey == \"domain\")\n\t{\n\t    if (value.isNull() || !value->isString())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n            if (value->asString ()->value ().size () > 0)\n                fprintf (f, \"%s %s\\n\", skey.c_str(), value->asString()->value().c_str());\n\t}\n        else if (allowedInfoKey (skey.c_str ()))\n\t{\n            y2debug (\"Skipping info key '%s'\", skey.c_str());\n        }\n\telse\n\t{\n\t    y2error (\"Skipping invalid key '%s'\", skey.c_str());\n\t}\n\tmptr++;\n    }\n    fclose (f);\n    cacheDirty = false;\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_name.c_str",
          "args": [],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool cacheDirty = false;\nstatic bool cacheValid = false;\n\nResolverAgent {\n  ResolverAgent::~ResolverAgent ()\n  {\n      if (cacheValid && cacheDirty)\n      {\n  \tflushCache(file_name.c_str ());\n      }\n  }\n}"
  },
  {
    "function_name": "ResolverAgent",
    "container": "ResolverAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
    "lines": "475-477",
    "snippet": "ResolverAgent::ResolverAgent () : file_name (\"/etc/resolv.conf\")\n{\n}",
    "includes": [
      "#include \"ResolverAgent.h\"",
      "#include <ycp/YCPMap.h>",
      "#include <ycp/y2log.h>",
      "#include <YCP.h>",
      "#include <string>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nResolverAgent {\n  ResolverAgent::ResolverAgent () : file_name (\"/etc/resolv.conf\")\n  {\n  }\n}"
  },
  {
    "function_name": "allowedKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
    "lines": "458-470",
    "snippet": "static int allowedKey (const char *key)\n{\n    int i = 0;\n    while (resolver_keys[i] != 0)\n    {\n\tif (strcmp (key, resolver_keys[i]) == 0)\n\t{\n\t    return 0;\n\t}\n\ti = i + 1;\n    }\n    return -1;\n}",
    "includes": [
      "#include \"ResolverAgent.h\"",
      "#include <ycp/YCPMap.h>",
      "#include <ycp/y2log.h>",
      "#include <YCP.h>",
      "#include <string>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *resolver_keys[] = {\n  \"search\",\n  \"nameserver\",\n  \"domain\",\n  \"sortlist\",\n  \"options\",\n  0\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "key",
            "resolver_keys[i]"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic const char *resolver_keys[] = {\n  \"search\",\n  \"nameserver\",\n  \"domain\",\n  \"sortlist\",\n  \"options\",\n  0\n};\n\nstatic int allowedKey (const char *key)\n{\n    int i = 0;\n    while (resolver_keys[i] != 0)\n    {\n\tif (strcmp (key, resolver_keys[i]) == 0)\n\t{\n\t    return 0;\n\t}\n\ti = i + 1;\n    }\n    return -1;\n}"
  },
  {
    "function_name": "flushCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
    "lines": "306-454",
    "snippet": "static int flushCache (const char *filename)\n{\n    if (!cacheValid)\n    {\n\treturn 0;\n    }\n    if (!cacheDirty)\n    {\n\treturn 0;\n    }\n\n    FILE* f = fopen (filename, \"w+\");\n    if (f == 0)\n    {\n\ty2error (\"Can't open %s for writing\", filename);\n\treturn -1;\n    }\n\n    fchmod (fileno (f), 0644);\n\n    // first fill the info header, if needed\n    if (writeHeader)\n    {\n        int i = 0;\n        YCPValue info = YCPNull ();\n        fprintf (f, \"### BEGIN INFO\\n#\\n\");\n        while (headers[i].key != 0)\n\t{\n\t    info = localCache->value (YCPString (headers[i].key));\n\t    if (info.isNull () || info->isVoid ())\n\t    {\n\t\ty2warning (\"Info key %s not found!\", headers[i].key);\n\t    }\n\t    else\n\t    {\n\t\tif (info->isString ())\n\t\t{\n\t\t    fprintf (f, \"%s %s\\n\", headers[i].tag, info->asString ()->value_cstr ());\n\t\t}\n\t\telse\n\t\t{\n\t\t    y2error (\"Wrong type for info key %s!\", headers[i].tag);\n\t\t}\n\t    }\n\t    i = i + 1;\n\t}\n        fprintf (f, \"#\\n### END INFO\\n#\\n\");\n    }\n\n    int retval = 0;\n    YCPMap::const_iterator mptr = localCache->begin();\n\n    while (mptr != localCache->end())\n    {\n\tYCPValue key = mptr->first;\n\tif (key.isNull() || !key->isString())\n\t{\n\t    y2error (\"Bad key in localCache\");\n\t    retval = -1;\n\t    break;\n\t}\n\tstring skey = key->asString()->value();\n\tYCPValue value = mptr->second;\n\n\tif ((skey == \"search\")\n\t    || (skey == \"sortlist\")\n\t    || (skey == \"options\"))\n\t{\n\n\t    if (value.isNull() || !value->isList())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    YCPList list = value->asList();\n\t    if (list->size() < 0)\n\t    {\n\t\ty2error (\"Bad list size for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    if (list->size() == 0)\n\t    {\n\t\tbreak;\n\t    }\n\t    fprintf (f, \"%s\", skey.c_str());\n\t    int i = 0;\n\t    for (i = 0; i < list->size(); i++)\n\t    {\n\t\tif (list->value(i).isNull()\n\t\t    || !list->value(i)->isString())\n\t\t{\n\t\t    y2error (\"Skipping bad list element for key '%s'\", skey.c_str());\n\t\t}\n\t\telse\n\t\t{\n\t\t    fprintf (f, \" %s\", list->value(i)->asString()->value().c_str());\n\t\t}\n\t    }\n\t    fprintf (f, \"\\n\");\n\t}\n\telse if (skey == \"nameserver\")\n\t{\n\t    if (value.isNull() || !value->isList())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    YCPList list = value->asList();\n\t    if (list->size () > 0)\n\t    {\n\t\tint i;\n\t\tfor (i = 0; i < list->size(); i++)\n\t\t{\n\t\t    if (list->value(i).isNull()\n\t\t\t|| !list->value(i)->isString())\n\t\t    {\n\t\t\ty2error (\"Skipping bad list element for key '%s'\", skey.c_str());\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfprintf (f, \"%s %s\\n\", skey.c_str(), list->value(i)->asString()->value().c_str());\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse if (skey == \"domain\")\n\t{\n\t    if (value.isNull() || !value->isString())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n            if (value->asString ()->value ().size () > 0)\n                fprintf (f, \"%s %s\\n\", skey.c_str(), value->asString()->value().c_str());\n\t}\n        else if (allowedInfoKey (skey.c_str ()))\n\t{\n            y2debug (\"Skipping info key '%s'\", skey.c_str());\n        }\n\telse\n\t{\n\t    y2error (\"Skipping invalid key '%s'\", skey.c_str());\n\t}\n\tmptr++;\n    }\n    fclose (f);\n    cacheDirty = false;\n    return retval;\n}",
    "includes": [
      "#include \"ResolverAgent.h\"",
      "#include <ycp/YCPMap.h>",
      "#include <ycp/y2log.h>",
      "#include <YCP.h>",
      "#include <string>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static YCPMap localCache;",
      "static bool cacheDirty = false;",
      "static bool cacheValid = false;",
      "static bool writeHeader  = false;",
      "static const info_entry headers[] = {\n    {\"modified\",    \"# Modified_by:\"},\n    {\"backup\",      \"# Backup:\"},\n    {\"process\",     \"# Process: \"},\n    {\"process_id\",  \"# Process_id: \"},\n    {\"script\",      \"# Script:\"},\n    {\"saveto\",      \"# Saveto:\"},\n    {\"info\",        \"# Info:\"},\n    {0, 0}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Skipping invalid key '%s'\"",
            "skey.c_str()"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skey.c_str",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Skipping info key '%s'\"",
            "skey.c_str()"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skey.c_str",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allowedInfoKey",
          "args": [
            "skey.c_str ()"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "allowedInfoKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
          "lines": "85-98",
          "snippet": "bool allowedInfoKey (const char *key)\n{\n    int i = 0;\n    while (headers[i].key != 0)\n    {\n        if (key && (strcmp (key, headers[i].key) == 0))\n\t{\n            return true;\n\t}\n        i = i + 1;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"ResolverAgent.h\"",
            "#include <ycp/YCPMap.h>",
            "#include <ycp/y2log.h>",
            "#include <YCP.h>",
            "#include <string>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const info_entry headers[] = {\n    {\"modified\",    \"# Modified_by:\"},\n    {\"backup\",      \"# Backup:\"},\n    {\"process\",     \"# Process: \"},\n    {\"process_id\",  \"# Process_id: \"},\n    {\"script\",      \"# Script:\"},\n    {\"saveto\",      \"# Saveto:\"},\n    {\"info\",        \"# Info:\"},\n    {0, 0}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic const info_entry headers[] = {\n    {\"modified\",    \"# Modified_by:\"},\n    {\"backup\",      \"# Backup:\"},\n    {\"process\",     \"# Process: \"},\n    {\"process_id\",  \"# Process_id: \"},\n    {\"script\",      \"# Script:\"},\n    {\"saveto\",      \"# Saveto:\"},\n    {\"info\",        \"# Info:\"},\n    {0, 0}\n};\n\nbool allowedInfoKey (const char *key)\n{\n    int i = 0;\n    while (headers[i].key != 0)\n    {\n        if (key && (strcmp (key, headers[i].key) == 0))\n\t{\n            return true;\n\t}\n        i = i + 1;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skey.c_str",
          "args": [],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%s %s\\n\"",
            "skey.c_str()",
            "value->asString()->value().c_str()"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->asString",
          "args": [],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "skey.c_str",
          "args": [],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad value for key '%s'\"",
            "skey.c_str()"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skey.c_str",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->isString",
          "args": [],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%s %s\\n\"",
            "skey.c_str()",
            "list->value(i)->asString()->value().c_str()"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list->value",
          "args": [],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->value",
          "args": [
            "i"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "skey.c_str",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Skipping bad list element for key '%s'\"",
            "skey.c_str()"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skey.c_str",
          "args": [],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list->size",
          "args": [],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asList",
          "args": [],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad value for key '%s'\"",
            "skey.c_str()"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skey.c_str",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->isList",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"\\n\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\" %s\"",
            "list->value(i)->asString()->value().c_str()"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Skipping bad list element for key '%s'\"",
            "skey.c_str()"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skey.c_str",
          "args": [],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%s\"",
            "skey.c_str()"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skey.c_str",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad list size for key '%s'\"",
            "skey.c_str()"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skey.c_str",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad value for key '%s'\"",
            "skey.c_str()"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skey.c_str",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad key in localCache\""
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.isNull",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localCache->end",
          "args": [],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "localCache->begin",
          "args": [],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"#\\n### END INFO\\n#\\n\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Wrong type for info key %s!\"",
            "headers[i].tag"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%s %s\\n\"",
            "headers[i].tag",
            "info->asString ()->value_cstr ()"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"Info key %s not found!\"",
            "headers[i].key"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info->isVoid",
          "args": [],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "info.isNull",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "headers[i].key"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"### BEGIN INFO\\n#\\n\""
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchmod",
          "args": [
            "fileno (f)",
            "0644"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "f"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Can't open %s for writing\"",
            "filename"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "filename",
            "\"w+\""
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic YCPMap localCache;\nstatic bool cacheDirty = false;\nstatic bool cacheValid = false;\nstatic bool writeHeader  = false;\nstatic const info_entry headers[] = {\n    {\"modified\",    \"# Modified_by:\"},\n    {\"backup\",      \"# Backup:\"},\n    {\"process\",     \"# Process: \"},\n    {\"process_id\",  \"# Process_id: \"},\n    {\"script\",      \"# Script:\"},\n    {\"saveto\",      \"# Saveto:\"},\n    {\"info\",        \"# Info:\"},\n    {0, 0}\n};\n\nstatic int flushCache (const char *filename)\n{\n    if (!cacheValid)\n    {\n\treturn 0;\n    }\n    if (!cacheDirty)\n    {\n\treturn 0;\n    }\n\n    FILE* f = fopen (filename, \"w+\");\n    if (f == 0)\n    {\n\ty2error (\"Can't open %s for writing\", filename);\n\treturn -1;\n    }\n\n    fchmod (fileno (f), 0644);\n\n    // first fill the info header, if needed\n    if (writeHeader)\n    {\n        int i = 0;\n        YCPValue info = YCPNull ();\n        fprintf (f, \"### BEGIN INFO\\n#\\n\");\n        while (headers[i].key != 0)\n\t{\n\t    info = localCache->value (YCPString (headers[i].key));\n\t    if (info.isNull () || info->isVoid ())\n\t    {\n\t\ty2warning (\"Info key %s not found!\", headers[i].key);\n\t    }\n\t    else\n\t    {\n\t\tif (info->isString ())\n\t\t{\n\t\t    fprintf (f, \"%s %s\\n\", headers[i].tag, info->asString ()->value_cstr ());\n\t\t}\n\t\telse\n\t\t{\n\t\t    y2error (\"Wrong type for info key %s!\", headers[i].tag);\n\t\t}\n\t    }\n\t    i = i + 1;\n\t}\n        fprintf (f, \"#\\n### END INFO\\n#\\n\");\n    }\n\n    int retval = 0;\n    YCPMap::const_iterator mptr = localCache->begin();\n\n    while (mptr != localCache->end())\n    {\n\tYCPValue key = mptr->first;\n\tif (key.isNull() || !key->isString())\n\t{\n\t    y2error (\"Bad key in localCache\");\n\t    retval = -1;\n\t    break;\n\t}\n\tstring skey = key->asString()->value();\n\tYCPValue value = mptr->second;\n\n\tif ((skey == \"search\")\n\t    || (skey == \"sortlist\")\n\t    || (skey == \"options\"))\n\t{\n\n\t    if (value.isNull() || !value->isList())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    YCPList list = value->asList();\n\t    if (list->size() < 0)\n\t    {\n\t\ty2error (\"Bad list size for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    if (list->size() == 0)\n\t    {\n\t\tbreak;\n\t    }\n\t    fprintf (f, \"%s\", skey.c_str());\n\t    int i = 0;\n\t    for (i = 0; i < list->size(); i++)\n\t    {\n\t\tif (list->value(i).isNull()\n\t\t    || !list->value(i)->isString())\n\t\t{\n\t\t    y2error (\"Skipping bad list element for key '%s'\", skey.c_str());\n\t\t}\n\t\telse\n\t\t{\n\t\t    fprintf (f, \" %s\", list->value(i)->asString()->value().c_str());\n\t\t}\n\t    }\n\t    fprintf (f, \"\\n\");\n\t}\n\telse if (skey == \"nameserver\")\n\t{\n\t    if (value.isNull() || !value->isList())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n\t    YCPList list = value->asList();\n\t    if (list->size () > 0)\n\t    {\n\t\tint i;\n\t\tfor (i = 0; i < list->size(); i++)\n\t\t{\n\t\t    if (list->value(i).isNull()\n\t\t\t|| !list->value(i)->isString())\n\t\t    {\n\t\t\ty2error (\"Skipping bad list element for key '%s'\", skey.c_str());\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfprintf (f, \"%s %s\\n\", skey.c_str(), list->value(i)->asString()->value().c_str());\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse if (skey == \"domain\")\n\t{\n\t    if (value.isNull() || !value->isString())\n\t    {\n\t\ty2error (\"Bad value for key '%s'\", skey.c_str());\n\t\tbreak;\n\t    }\n            if (value->asString ()->value ().size () > 0)\n                fprintf (f, \"%s %s\\n\", skey.c_str(), value->asString()->value().c_str());\n\t}\n        else if (allowedInfoKey (skey.c_str ()))\n\t{\n            y2debug (\"Skipping info key '%s'\", skey.c_str());\n        }\n\telse\n\t{\n\t    y2error (\"Skipping invalid key '%s'\", skey.c_str());\n\t}\n\tmptr++;\n    }\n    fclose (f);\n    cacheDirty = false;\n    return retval;\n}"
  },
  {
    "function_name": "fillCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
    "lines": "135-301",
    "snippet": "static int fillCache (const char *filename)\n{\n    if (cacheValid)\n\treturn 0;\n\n    y2debug (\"fillCache\");\n\n    FILE *f;\n\n    f = fopen (filename, \"r\");\n    if (f == 0) {\n\ty2error (\"Can't access %s: %s\", filename, strerror(errno));\n\treturn -1;\n    }\n\n    const int lbufsize = 1024;\n    char lbuf[lbufsize+2];\t// add \\n\\0\n    int retval = 0;\n    char *lptr;\n    bool processing_info = false;\n    string info_buf = \"\";\n    const char *last_key = 0;\n    YCPMap info_map;\n\n    localCache = YCPMap();\t// initialize with empty map\n\n    while (fgets (lbuf, lbufsize, f) != 0)\n    {\n\ty2debug (\"fread(%s)\", lbuf);\n\n\tlptr = strchr (lbuf, '#');\t// process comment\n\tif (lptr != 0)\n        {\n            if (strncmp (lbuf, \"### BEGIN INFO\", 14) == 0)\n            {\n                processing_info = true;\n                continue;\n            }\n            if (strncmp (lbuf, \"### END INFO\", 12) == 0)\n            {\n                if (last_key)   // one more key to process\n\t\t{  \n                    localCache->add (YCPString (last_key), YCPString ((info_buf.substr (0, info_buf.length () - 1)).c_str ()));\n\t\t}\n                if (!processing_info) y2warning (\"End of info without beggining!\");\n                processing_info = false;\n                continue;\n            }\n            if (const char *key = findKey (lbuf))\n            {\n                if (last_key)\n\t\t{\n                    localCache->add (YCPString (last_key), YCPString ((info_buf.substr (0, info_buf.length () - 1)).c_str ()));\n\t\t}\n\n                if (char *info = strchr (lbuf, ':'))\n\t\t{\n                    info_buf = eatWhitespaces (strlen (info) > 0 ? info + 1 : info);\n\t\t}\n                last_key = key;\n                continue;\n            }\n            else if (processing_info)\n\t    {\n                info_buf = info_buf + lbuf; // keep the other lines with '#' at the begging and '\\n' in the end\n\t    }\n\t    *lptr = 0;          // don't care about other comments\n        }\n\n\tif (lbuf[0] == '\\0'\t\t// skip other comment lines\n\t    || lbuf[0] == '\\n')\n\t{\n\t    continue;\n\t}\n\tlptr = nextWhitespace (lbuf);\t// break line at first whitespace\n\ty2debug (\"next(%s)\", lptr);\n\n\tif (lptr == 0\n\t    || *lptr == '\\n'\n\t    || *lptr == 0)\t\t\t// skip lines without <key><ws><value> syntax\n\t{\n\t    continue;\n\t}\n\t*lptr++ = 0;\n\n\tYCPValue value = YCPNull();\n\tchar *vptr = eatWhitespaces (lptr);\n\n\ty2debug (\"key(%s)\", lbuf);\n\n\tconst YCPString key (lbuf);\n\n\t// list of strings as value\n\n\tif ((strcmp  (lbuf, \"search\") == 0)\n\t   || (strcmp  (lbuf, \"sortlist\") == 0)\n\t   || (strcmp  (lbuf, \"options\") == 0))\n\t{\n\n\t    y2debug (\"list of strings '%s'\", lbuf);\n\n\t    YCPList ret;\n\n\t    for (;;)\n\t    {\n\t\tlptr = nextWhitespace (vptr);\n\t\tif ((lptr == 0)\n\t\t    || (lptr == vptr))\n\t\t{\n\t\t    break;\n\t\t}\n\t\t*lptr++ = 0;\n\t\tret->add (YCPString (vptr));\n\t\tvptr = eatWhitespaces (lptr);\n\t    }\n\n\t    value = ret;\n\t}\n\n\t// single value, but multiple lines allowed\n\n\telse if (strcmp (lbuf, \"nameserver\") == 0)\n\t{\n\n\t    y2debug (\"multiple lines '%s':'%s'\", lbuf, vptr);\n\n\t    value = localCache->value (key);\n\t    if (value.isNull())\n\t    {\n\t\tvalue = YCPList();\n\t    }\n\t    lptr = nextWhitespace (vptr);\n\t    *lptr = 0;\n\t    value = value->asList()->functionalAdd (YCPString (vptr));\n\t}\n\n\t// single value\n\n\telse if (strcmp (lbuf, \"domain\") == 0)\n\t{\n\n\t    y2debug (\"single value '%s'\", lbuf);\n\n\t    lptr = nextWhitespace (vptr);\n\t    *lptr = 0;\n\t    value = YCPString (vptr);\n\t}\n\telse\n\t{\n\t    y2warning (\"key '%s' not recognized\", lbuf);\n\t}\n\n\tlocalCache->add (key, value);\n    }\n\n    if (!feof (f))\n    {\n\ty2error (\"Can't completely read %s\", filename);\n\tretval = -1;\n    }\n\n    fclose (f);\n\n    cacheValid = true;\n\n    return retval;\n}",
    "includes": [
      "#include \"ResolverAgent.h\"",
      "#include <ycp/YCPMap.h>",
      "#include <ycp/y2log.h>",
      "#include <YCP.h>",
      "#include <string>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static YCPMap localCache;",
      "static bool cacheValid = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Can't completely read %s\"",
            "filename"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "feof",
          "args": [
            "f"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localCache->add",
          "args": [
            "key",
            "value"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "50-76",
          "snippet": "void\nYCPMapRep::add (const YCPValue& key, const YCPValue& value)\n{\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn;\n    }\n\n    // Note: 'stl_map[key] = value' would create a temporary object using the\n    // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n    // 24.\n\n    YCPMap::iterator pos = stl_map.lower_bound(key);\n    if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n    {\n\tpos->second = value;\n    }\n    else\n    {\n\t// pos is just a hint but can avoid a second search through the map\n\tstl_map.insert(pos, YCPMap::value_type(key, value));\n    }\n\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void\n  YCPMapRep::add (const YCPValue& key, const YCPValue& value)\n  {\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn;\n      }\n  \n      // Note: 'stl_map[key] = value' would create a temporary object using the\n      // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n      // 24.\n  \n      YCPMap::iterator pos = stl_map.lower_bound(key);\n      if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n      {\n  \tpos->second = value;\n      }\n      else\n      {\n  \t// pos is just a hint but can avoid a second search through the map\n  \tstl_map.insert(pos, YCPMap::value_type(key, value));\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"key '%s' not recognized\"",
            "lbuf"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "vptr"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "nextWhitespace",
          "args": [
            "vptr"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"single value '%s'\"",
            "lbuf"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lbuf",
            "\"domain\""
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->asList",
          "args": [
            "YCPString (vptr)"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->asList",
          "args": [],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nextWhitespace",
          "args": [
            "vptr"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPList",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "commaList",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "254-265",
          "snippet": "string\nYCPListRep::commaList() const\n{\n    string ret;\n\n    for (unsigned index = 0; index < elements.size(); index++)\n    {\n\tif (index != 0) ret += \", \";\n\tret += elements[index].isNull() ? \"(null)\" : elements[index]->toString();\n    }\n    return ret;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  string\n  YCPListRep::commaList() const\n  {\n      string ret;\n  \n      for (unsigned index = 0; index < elements.size(); index++)\n      {\n  \tif (index != 0) ret += \", \";\n  \tret += elements[index].isNull() ? \"(null)\" : elements[index]->toString();\n      }\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localCache->value",
          "args": [
            "key"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"multiple lines '%s':'%s'\"",
            "lbuf",
            "vptr"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lbuf",
            "\"nameserver\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eatWhitespaces",
          "args": [
            "lptr"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret->add",
          "args": [
            "YCPString (vptr)"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nextWhitespace",
          "args": [
            "vptr"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"list of strings '%s'\"",
            "lbuf"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lbuf",
            "\"options\""
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lbuf",
            "\"sortlist\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lbuf",
            "\"search\""
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"key(%s)\"",
            "lbuf"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eatWhitespaces",
          "args": [
            "lptr"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"next(%s)\"",
            "lptr"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nextWhitespace",
          "args": [
            "lbuf"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eatWhitespaces",
          "args": [
            "strlen (info) > 0 ? info + 1 : info"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "info"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "lbuf",
            "':'"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info_buf.substr",
          "args": [
            "0",
            "info_buf.length () - 1"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info_buf.length",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "findKey",
          "args": [
            "lbuf"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"End of info without beggining!\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info_buf.substr",
          "args": [
            "0",
            "info_buf.length () - 1"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "lbuf",
            "\"### END INFO\"",
            "12"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "lbuf",
            "\"### BEGIN INFO\"",
            "14"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "lbuf",
            "'#'"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"fread(%s)\"",
            "lbuf"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "lbuf",
            "lbufsize",
            "f"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPMap",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "219-223",
          "snippet": "YCPValueType\nYCPMapRep::valuetype() const\n{\n    return YT_MAP;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPValueType\n  YCPMapRep::valuetype() const\n  {\n      return YT_MAP;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Can't access %s: %s\"",
            "filename",
            "strerror(errno)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "filename",
            "\"r\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"fillCache\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic YCPMap localCache;\nstatic bool cacheValid = false;\n\nstatic int fillCache (const char *filename)\n{\n    if (cacheValid)\n\treturn 0;\n\n    y2debug (\"fillCache\");\n\n    FILE *f;\n\n    f = fopen (filename, \"r\");\n    if (f == 0) {\n\ty2error (\"Can't access %s: %s\", filename, strerror(errno));\n\treturn -1;\n    }\n\n    const int lbufsize = 1024;\n    char lbuf[lbufsize+2];\t// add \\n\\0\n    int retval = 0;\n    char *lptr;\n    bool processing_info = false;\n    string info_buf = \"\";\n    const char *last_key = 0;\n    YCPMap info_map;\n\n    localCache = YCPMap();\t// initialize with empty map\n\n    while (fgets (lbuf, lbufsize, f) != 0)\n    {\n\ty2debug (\"fread(%s)\", lbuf);\n\n\tlptr = strchr (lbuf, '#');\t// process comment\n\tif (lptr != 0)\n        {\n            if (strncmp (lbuf, \"### BEGIN INFO\", 14) == 0)\n            {\n                processing_info = true;\n                continue;\n            }\n            if (strncmp (lbuf, \"### END INFO\", 12) == 0)\n            {\n                if (last_key)   // one more key to process\n\t\t{  \n                    localCache->add (YCPString (last_key), YCPString ((info_buf.substr (0, info_buf.length () - 1)).c_str ()));\n\t\t}\n                if (!processing_info) y2warning (\"End of info without beggining!\");\n                processing_info = false;\n                continue;\n            }\n            if (const char *key = findKey (lbuf))\n            {\n                if (last_key)\n\t\t{\n                    localCache->add (YCPString (last_key), YCPString ((info_buf.substr (0, info_buf.length () - 1)).c_str ()));\n\t\t}\n\n                if (char *info = strchr (lbuf, ':'))\n\t\t{\n                    info_buf = eatWhitespaces (strlen (info) > 0 ? info + 1 : info);\n\t\t}\n                last_key = key;\n                continue;\n            }\n            else if (processing_info)\n\t    {\n                info_buf = info_buf + lbuf; // keep the other lines with '#' at the begging and '\\n' in the end\n\t    }\n\t    *lptr = 0;          // don't care about other comments\n        }\n\n\tif (lbuf[0] == '\\0'\t\t// skip other comment lines\n\t    || lbuf[0] == '\\n')\n\t{\n\t    continue;\n\t}\n\tlptr = nextWhitespace (lbuf);\t// break line at first whitespace\n\ty2debug (\"next(%s)\", lptr);\n\n\tif (lptr == 0\n\t    || *lptr == '\\n'\n\t    || *lptr == 0)\t\t\t// skip lines without <key><ws><value> syntax\n\t{\n\t    continue;\n\t}\n\t*lptr++ = 0;\n\n\tYCPValue value = YCPNull();\n\tchar *vptr = eatWhitespaces (lptr);\n\n\ty2debug (\"key(%s)\", lbuf);\n\n\tconst YCPString key (lbuf);\n\n\t// list of strings as value\n\n\tif ((strcmp  (lbuf, \"search\") == 0)\n\t   || (strcmp  (lbuf, \"sortlist\") == 0)\n\t   || (strcmp  (lbuf, \"options\") == 0))\n\t{\n\n\t    y2debug (\"list of strings '%s'\", lbuf);\n\n\t    YCPList ret;\n\n\t    for (;;)\n\t    {\n\t\tlptr = nextWhitespace (vptr);\n\t\tif ((lptr == 0)\n\t\t    || (lptr == vptr))\n\t\t{\n\t\t    break;\n\t\t}\n\t\t*lptr++ = 0;\n\t\tret->add (YCPString (vptr));\n\t\tvptr = eatWhitespaces (lptr);\n\t    }\n\n\t    value = ret;\n\t}\n\n\t// single value, but multiple lines allowed\n\n\telse if (strcmp (lbuf, \"nameserver\") == 0)\n\t{\n\n\t    y2debug (\"multiple lines '%s':'%s'\", lbuf, vptr);\n\n\t    value = localCache->value (key);\n\t    if (value.isNull())\n\t    {\n\t\tvalue = YCPList();\n\t    }\n\t    lptr = nextWhitespace (vptr);\n\t    *lptr = 0;\n\t    value = value->asList()->functionalAdd (YCPString (vptr));\n\t}\n\n\t// single value\n\n\telse if (strcmp (lbuf, \"domain\") == 0)\n\t{\n\n\t    y2debug (\"single value '%s'\", lbuf);\n\n\t    lptr = nextWhitespace (vptr);\n\t    *lptr = 0;\n\t    value = YCPString (vptr);\n\t}\n\telse\n\t{\n\t    y2warning (\"key '%s' not recognized\", lbuf);\n\t}\n\n\tlocalCache->add (key, value);\n    }\n\n    if (!feof (f))\n    {\n\ty2error (\"Can't completely read %s\", filename);\n\tretval = -1;\n    }\n\n    fclose (f);\n\n    cacheValid = true;\n\n    return retval;\n}"
  },
  {
    "function_name": "allowedInfoKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-resolver/src/ResolverAgent.cc",
    "lines": "85-98",
    "snippet": "bool allowedInfoKey (const char *key)\n{\n    int i = 0;\n    while (headers[i].key != 0)\n    {\n        if (key && (strcmp (key, headers[i].key) == 0))\n\t{\n            return true;\n\t}\n        i = i + 1;\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"ResolverAgent.h\"",
      "#include <ycp/YCPMap.h>",
      "#include <ycp/y2log.h>",
      "#include <YCP.h>",
      "#include <string>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const info_entry headers[] = {\n    {\"modified\",    \"# Modified_by:\"},\n    {\"backup\",      \"# Backup:\"},\n    {\"process\",     \"# Process: \"},\n    {\"process_id\",  \"# Process_id: \"},\n    {\"script\",      \"# Script:\"},\n    {\"saveto\",      \"# Saveto:\"},\n    {\"info\",        \"# Info:\"},\n    {0, 0}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "key",
            "headers[i].key"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ResolverAgent.h\"\n#include <ycp/YCPMap.h>\n#include <ycp/y2log.h>\n#include <YCP.h>\n#include <string>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic const info_entry headers[] = {\n    {\"modified\",    \"# Modified_by:\"},\n    {\"backup\",      \"# Backup:\"},\n    {\"process\",     \"# Process: \"},\n    {\"process_id\",  \"# Process_id: \"},\n    {\"script\",      \"# Script:\"},\n    {\"saveto\",      \"# Saveto:\"},\n    {\"info\",        \"# Info:\"},\n    {0, 0}\n};\n\nbool allowedInfoKey (const char *key)\n{\n    int i = 0;\n    while (headers[i].key != 0)\n    {\n        if (key && (strcmp (key, headers[i].key) == 0))\n\t{\n            return true;\n\t}\n        i = i + 1;\n    }\n\n    return false;\n}"
  }
]