[
  {
    "function_name": "xmlify",
    "container": "Xmlcode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "862-883",
    "snippet": "string\nXmlcode::xmlify( const string & s )\n{\n    string result;\n\n    const char *cptr = s.c_str();\n    const char *next;\n    while( (next = strpbrk( cptr, \"&<>'\\\"\" )) ) {\n\tresult += string( cptr, next - cptr );\n\tswitch (*next) {\n\t  case '&': result += \"&amp;\"; break;\n\t  case '<': result += \"&lt;\"; break;\n\t  case '>': result += \"&gt;\"; break;\n\t  case '\"': result += \"&quot;\"; break;\n\t  case '\\'': result += \"&apos;\"; break;\n\t}\n\tcptr = next + 1;\n    }\n    result += string( cptr );\n    return result;\n\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "string",
          "args": [
            "cptr"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "cptr",
            "next - cptr"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "litstring (co",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
          "lines": "722-794",
          "snippet": "ic YCPValue\nl_splitstring (const YCPString &s, const YCPString &c)\n{\n    /**\n     * @builtin splitstring\n     * @short Split a string by delimiter\n     * @param string STR\n     * @param string DELIM\n     * @return list<string>\n     *\n     * @description\n     * Splits <tt>STR</tt> into sub-strings at delimiter chars <tt>DELIM</tt>.\n     * the resulting pieces do not contain <tt>DELIM</tt>\n     *\n     * If <tt>STR</tt> starts with <tt>DELIM</tt>, the first string in the result list is empty\n     * If <tt>STR</tt> ends with <tt>DELIM</tt>, the last string in the result list is empty.\n     * If <tt>STR</tt> does not contain <tt>DELIM</tt>, the result is a singleton list with <tt>STR</tt>.\n     *\n     * @see mergestring\n     * @usage splitstring (\"/abc/dev/ghi\", \"/\") -> [\"\", \"abc\", \"dev\", \"ghi\" ]\n     * @usage splitstring (\"abc/dev/ghi/\", \"/\") -> [\"abc\", \"dev\", \"ghi\", \"\" ]\n     * @usage splitstring (\"abc/dev/ghi/\", \".\") -> [\"abc/dev/ghi/\" ]\n     * @usage splitstring (\"text/with:different/separators\", \"/:\") -> [\"text\", \"with\", \"different\", \"separators\"]\n     */\n\n    if (s.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    if (c.isNull ())\n    {\n\tycp2error (\"Cannot split string using 'nil'\");\n\treturn YCPNull ();\n    }\n\n    YCPList ret;\n\n    string ss = s->value ();\n    string sc = c->value ();\n\n    if (ss.empty () || sc.empty ())\n\treturn ret;\n\n    string::size_type spos = 0;\t\t\t// start pos\n    string::size_type epos = 0;\t\t\t// end pos\n\n    while (true)\n    {\n\tepos = ss.find_first_of (sc, spos);\n\n\tif (epos == string::npos)\t// break if not found\n\t{\n\t    ret->add (YCPString (string (ss, spos)));\n\t    break;\n\t}\n\n\tif (spos == epos)\n\t    ret->add (YCPString (\"\"));\n\telse\n\t    ret->add (YCPString (string (ss, spos, epos - spos)));\t// string piece w/o delimiter\n\n\tspos = epos + 1;\t// skip c in s\n\n\tif (spos == ss.size ())\t// c was last char\n\t{\n\t    ret->add (YCPString (\"\"));\t// add \"\" and break\n\t    break;\n\t}\n    }\n\n    return ret;\n}\n\n\ns",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPBuiltinList.h\"",
            "#include <algorithm>\t\t// sort",
            "#include <set>\t\t\t// for toset"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nic YCPValue\nl_splitstring (const YCPString &s, const YCPString &c)\n{\n    /**\n     * @builtin splitstring\n     * @short Split a string by delimiter\n     * @param string STR\n     * @param string DELIM\n     * @return list<string>\n     *\n     * @description\n     * Splits <tt>STR</tt> into sub-strings at delimiter chars <tt>DELIM</tt>.\n     * the resulting pieces do not contain <tt>DELIM</tt>\n     *\n     * If <tt>STR</tt> starts with <tt>DELIM</tt>, the first string in the result list is empty\n     * If <tt>STR</tt> ends with <tt>DELIM</tt>, the last string in the result list is empty.\n     * If <tt>STR</tt> does not contain <tt>DELIM</tt>, the result is a singleton list with <tt>STR</tt>.\n     *\n     * @see mergestring\n     * @usage splitstring (\"/abc/dev/ghi\", \"/\") -> [\"\", \"abc\", \"dev\", \"ghi\" ]\n     * @usage splitstring (\"abc/dev/ghi/\", \"/\") -> [\"abc\", \"dev\", \"ghi\", \"\" ]\n     * @usage splitstring (\"abc/dev/ghi/\", \".\") -> [\"abc/dev/ghi/\" ]\n     * @usage splitstring (\"text/with:different/separators\", \"/:\") -> [\"text\", \"with\", \"different\", \"separators\"]\n     */\n\n    if (s.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    if (c.isNull ())\n    {\n\tycp2error (\"Cannot split string using 'nil'\");\n\treturn YCPNull ();\n    }\n\n    YCPList ret;\n\n    string ss = s->value ();\n    string sc = c->value ();\n\n    if (ss.empty () || sc.empty ())\n\treturn ret;\n\n    string::size_type spos = 0;\t\t\t// start pos\n    string::size_type epos = 0;\t\t\t// end pos\n\n    while (true)\n    {\n\tepos = ss.find_first_of (sc, spos);\n\n\tif (epos == string::npos)\t// break if not found\n\t{\n\t    ret->add (YCPString (string (ss, spos)));\n\t    break;\n\t}\n\n\tif (spos == epos)\n\t    ret->add (YCPString (\"\"));\n\telse\n\t    ret->add (YCPString (string (ss, spos, epos - spos)));\t// string piece w/o delimiter\n\n\tspos = epos + 1;\t// skip c in s\n\n\tif (spos == ss.size ())\t// c was last char\n\t{\n\t    ret->add (YCPString (\"\"));\t// add \"\" and break\n\t    break;\n\t}\n    }\n\n    return ret;\n}\n\n\ns"
        }
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "cptr",
            "\"&<>'\\\"\""
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.c_str",
          "args": [],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\nXmlcode {\n  string\n  Xmlcode::xmlify( const string & s )\n  {\n      string result;\n  \n      const char *cptr = s.c_str();\n      const char *next;\n      while( (next = strpbrk( cptr, \"&<>'\\\"\" )) ) {\n  \tresult += string( cptr, next - cptr );\n  \tswitch (*next) {\n  \t  case '&': result += \"&amp;\"; break;\n  \t  case '<': result += \"&lt;\"; break;\n  \t  case '>': result += \"&gt;\"; break;\n  \t  case '\"': result += \"&quot;\"; break;\n  \t  case '\\'': result += \"&apos;\"; break;\n  \t}\n  \tcptr = next + 1;\n      }\n      result += string( cptr );\n      return result;\n  \n  }\n}"
  },
  {
    "function_name": "spaces",
    "container": "Xmlcode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "847-860",
    "snippet": "string\nXmlcode::spaces( int count )\n{\n    count >>= 1;\n    if (count <= 0) return \"\";\n\n    //                      2     4       6         8     10      12        14          16      18        20\n    static string s[10] = { \"  \", \"    \", \"      \", \"\\t\", \"\\t  \", \"\\t    \", \"\\t      \", \"\\t\\t\", \"\\t\\t  \", \"\\t\\t    \" };\n\n    if( count > 10 ) {\n\treturn s[9] + spaces( count*2 - 20 );\n    }\n    return s[count - 1];\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spaces",
          "args": [
            "count*2 - 20"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "spaces",
          "container": "Xmlcode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
          "lines": "847-860",
          "snippet": "string\nXmlcode::spaces( int count )\n{\n    count >>= 1;\n    if (count <= 0) return \"\";\n\n    //                      2     4       6         8     10      12        14          16      18        20\n    static string s[10] = { \"  \", \"    \", \"      \", \"\\t\", \"\\t  \", \"\\t    \", \"\\t      \", \"\\t\\t\", \"\\t\\t  \", \"\\t\\t    \" };\n\n    if( count > 10 ) {\n\treturn s[9] + spaces( count*2 - 20 );\n    }\n    return s[count - 1];\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\nXmlcode {\n  string\n  Xmlcode::spaces( int count )\n  {\n      count >>= 1;\n      if (count <= 0) return \"\";\n  \n      //                      2     4       6         8     10      12        14          16      18        20\n      static string s[10] = { \"  \", \"    \", \"      \", \"\\t\", \"\\t  \", \"\\t    \", \"\\t      \", \"\\t\\t\", \"\\t\\t  \", \"\\t\\t    \" };\n  \n      if( count > 10 ) {\n  \treturn s[9] + spaces( count*2 - 20 );\n      }\n      return s[count - 1];\n  }\n}"
  },
  {
    "function_name": "writeFile",
    "container": "Xmlcode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "824-842",
    "snippet": "bool\nXmlcode::writeFile( const YCodePtr code, const string & filename)\n{\n    // clear errno first\n    errno = 0;\n\n    std::ofstream outstream( filename.c_str());\n    if( !outstream.is_open( ))\n    {\n\ty2error( \"Failed to write '%s': %s\", filename.c_str(), strerror( errno));\n\treturn false;\n    }\n\n    outstream << \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\";\n    outstream << \"<ycp version=\\\"2.15.8.39280\\\">\\n\";\n    code->toXml( outstream, 2 );\n    outstream << \"</ycp>\\n\";\n    return ! outstream.fail( );\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "outstream.fail",
          "args": [],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "code->toXml",
          "args": [
            "outstream",
            "2"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Failed to write '%s': %s\"",
            "filename.c_str()",
            "strerror( errno)"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outstream.is_open",
          "args": [],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\nXmlcode {\n  bool\n  Xmlcode::writeFile( const YCodePtr code, const string & filename)\n  {\n      // clear errno first\n      errno = 0;\n  \n      std::ofstream outstream( filename.c_str());\n      if( !outstream.is_open( ))\n      {\n  \ty2error( \"Failed to write '%s': %s\", filename.c_str(), strerror( errno));\n  \treturn false;\n      }\n  \n      outstream << \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\";\n      outstream << \"<ycp version=\\\"2.15.8.39280\\\">\\n\";\n      code->toXml( outstream, 2 );\n      outstream << \"</ycp>\\n\";\n      return ! outstream.fail( );\n  }\n}"
  },
  {
    "function_name": "readFile",
    "container": "Xmlcode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "787-820",
    "snippet": "YCodePtr\nXmlcode::readFile( const string & filename)\n{\n#if DO_DEBUG\n//    y2debug( \"Xmlcode::readFile( %s)\", filename.c_str());\n#endif\n    xmlcodeistream instream( filename);\n    if( !instream.is_open( ))\n    {\n\ty2error( \"Failed to open '%s': %s\", filename.c_str(), strerror( errno));\n\treturn 0;\n    }\n    // check YaST_BYTECODE_HEADER\n    if(  \n\tinstream.isVersion( \n\t    atoi( YaST_BYTECODE_MAJOR)\n\t    , atoi( YaST_BYTECODE_MINOR)\n\t    , atoi( YaST_BYTECODE_RELEASE))\n\t||\n\tinstream.isVersion( 1,3,2) )\t// 9.1/SLES9\n    {\n#if DO_DEBUG\n//\ty2debug( \"Header accepted\");\n#endif\n\t\n\treturn readCode( instream);\n    }\n\n    y2error( \"Unsupported version %d.%d.%d\"\n\t, instream.major( )\n\t, instream.minor( )\n\t, instream.release( ));\n    return 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [
      "#define YaST_BYTECODE_RELEASE \"0\"",
      "#define YaST_BYTECODE_MINOR \"4\"",
      "#define YaST_BYTECODE_MAJOR \"1\"",
      "#define YaST_BYTECODE_HEADER \"YaST xmlcode \"",
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unsupported version %d.%d.%d\"",
            "instream.major( )",
            "instream.minor( )",
            "instream.release( )"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instream.release",
          "args": [],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "release",
          "container": "xmlcodeistream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Xmlcode.h",
          "lines": "52-52",
          "snippet": "int release () const { return m_release; }",
          "includes": [
            "#include <fstream>",
            "#include <map>",
            "#include <string>",
            "#include <iosfwd>",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPValue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <map>\n#include <string>\n#include <iosfwd>\n#include \"ycp/Type.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPValue.h\"\n\nxmlcodeistream {\n  int release () const { return m_release; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "instream.minor",
          "args": [],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "minor",
          "container": "xmlcodeistream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Xmlcode.h",
          "lines": "51-51",
          "snippet": "int minor () const { return m_minor; }",
          "includes": [
            "#include <fstream>",
            "#include <map>",
            "#include <string>",
            "#include <iosfwd>",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPValue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <map>\n#include <string>\n#include <iosfwd>\n#include \"ycp/Type.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPValue.h\"\n\nxmlcodeistream {\n  int minor () const { return m_minor; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "instream.major",
          "args": [],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "major",
          "container": "xmlcodeistream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Xmlcode.h",
          "lines": "50-50",
          "snippet": "int major () const { return m_major; }",
          "includes": [
            "#include <fstream>",
            "#include <map>",
            "#include <string>",
            "#include <iosfwd>",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPValue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <map>\n#include <string>\n#include <iosfwd>\n#include \"ycp/Type.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPValue.h\"\n\nxmlcodeistream {\n  int major () const { return m_major; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readCode",
          "args": [
            "instream"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Xmlcode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
          "lines": "471-720",
          "snippet": "YCodePtr\nXmlcode::readCode( xmlcodeistream & str)\n{\n    char code;\n    if( !str.get( code))\n    {\n\ty2error( \"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug( \"Xmlcode::readCode( %d:%s)\", code, YCode::toString( (YCode::ykind)code).c_str());\n#endif\n    YCodePtr res = 0;\n\n#if XMLCODE_INPUT_SUPPORTED\n    if( code < YCode::ycConstant)\n    {\n\treturn new YConst( (YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if( str.isVersion( 1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    try\n    {\n\n    switch( code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error( \"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale( str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction( str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate( str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary( str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary( str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple( str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare( str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale( str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList( str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap( str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm( str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs( str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket( str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock( str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn( str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable( str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference( str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin( str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall( str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer( str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef( str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable( str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction( str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign( str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket( str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf( str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile( str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo( str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat( str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression( str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn( str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak( str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue( str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain( str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude( str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename( str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport( str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock( str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch( str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error( \"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    }\n    catch( const Xmlcode::Invalid&)\n    {\n\t// there are memory leaks all over the place now\n\ty2error( \"Caught invalid xmlcode\");\n    }\n#endif\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Xmlcode.h\""
          ],
          "macros_used": [
            "#define XMLCODE_INPUT_SUPPORTED 0",
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\n#define XMLCODE_INPUT_SUPPORTED 0\n#define DO_DEBUG 0\n\nXmlcode {\n  YCodePtr\n  Xmlcode::readCode( xmlcodeistream & str)\n  {\n      char code;\n      if( !str.get( code))\n      {\n  \ty2error( \"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug( \"Xmlcode::readCode( %d:%s)\", code, YCode::toString( (YCode::ykind)code).c_str());\n  #endif\n      YCodePtr res = 0;\n  \n  #if XMLCODE_INPUT_SUPPORTED\n      if( code < YCode::ycConstant)\n      {\n  \treturn new YConst( (YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if( str.isVersion( 1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      try\n      {\n  \n      switch( code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error( \"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch( str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error( \"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      }\n      catch( const Xmlcode::Invalid&)\n      {\n  \t// there are memory leaks all over the place now\n  \ty2error( \"Caught invalid xmlcode\");\n      }\n  #endif\n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "instream.isVersion",
          "args": [
            "1",
            "3",
            "2"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "isVersion",
          "container": "xmlcodeistream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
          "lines": "115-120",
          "snippet": "bool xmlcodeistream::isVersion( int major, int minor, int release)\n{\n    return( major == m_major) \n\t&&( minor == m_minor) \n\t&&( release == m_release);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Xmlcode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\nxmlcodeistream {\n  bool xmlcodeistream::isVersion( int major, int minor, int release)\n  {\n      return( major == m_major) \n  \t&&( minor == m_minor) \n  \t&&( release == m_release);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "YaST_BYTECODE_RELEASE"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "YaST_BYTECODE_MINOR"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "YaST_BYTECODE_MAJOR"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Failed to open '%s': %s\"",
            "filename.c_str()",
            "strerror( errno)"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instream.is_open",
          "args": [],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\n#define YaST_BYTECODE_RELEASE \"0\"\n#define YaST_BYTECODE_MINOR \"4\"\n#define YaST_BYTECODE_MAJOR \"1\"\n#define YaST_BYTECODE_HEADER \"YaST xmlcode \"\n#define DO_DEBUG 0\n\nXmlcode {\n  YCodePtr\n  Xmlcode::readFile( const string & filename)\n  {\n  #if DO_DEBUG\n  //    y2debug( \"Xmlcode::readFile( %s)\", filename.c_str());\n  #endif\n      xmlcodeistream instream( filename);\n      if( !instream.is_open( ))\n      {\n  \ty2error( \"Failed to open '%s': %s\", filename.c_str(), strerror( errno));\n  \treturn 0;\n      }\n      // check YaST_BYTECODE_HEADER\n      if(  \n  \tinstream.isVersion( \n  \t    atoi( YaST_BYTECODE_MAJOR)\n  \t    , atoi( YaST_BYTECODE_MINOR)\n  \t    , atoi( YaST_BYTECODE_RELEASE))\n  \t||\n  \tinstream.isVersion( 1,3,2) )\t// 9.1/SLES9\n      {\n  #if DO_DEBUG\n  //\ty2debug( \"Header accepted\");\n  #endif\n  \t\n  \treturn readCode( instream);\n      }\n  \n      y2error( \"Unsupported version %d.%d.%d\"\n  \t, instream.major( )\n  \t, instream.minor( )\n  \t, instream.release( ));\n      return 0;\n  }\n}"
  },
  {
    "function_name": "readModule",
    "container": "Xmlcode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "731-783",
    "snippet": "YBlockPtr \nXmlcode::readModule( const string & mname)\n{\n#if DO_DEBUG\n//    y2debug( \"Xmlcode::readModule( %s) \", mname.c_str( ));\n#endif\n\n    // TODO better error reporting?\n    // like: could not find foo.ycp in /modules, /a/modules.\n    // It will return an empty string on failure\n\n    string filename = YCPPathSearch::findModule( mname);\n    if( filename.empty())\n    {\n\tycperror( \"Module '%s' not found\", mname.c_str());\n\treturn 0;\n    }\n    \n    if( ! m_xmlcodeCache)\n    {\n\tm_xmlcodeCache = new map <string, YBlockPtr>;\n    }\n\n    // check the cache\n    if( m_xmlcodeCache->find( mname) != m_xmlcodeCache->end( ))\n    {\n#if DO_DEBUG\n//\ty2debug( \"Xmlcode cache hit: %s\", mname.c_str( ));\n#endif\n\n\treturn m_xmlcodeCache->find( mname)->second;\n    }\n    \n    int tare_id = Xmlcode::tareStack( );\t\t\t// current nesting level is 0 for this module\n    YBlockPtr block =( YBlockPtr)Xmlcode::readFile( filename);\n\n    if( block == NULL)\n    {\n\treturn NULL;\n    }\n\n    Xmlcode::untareStack( tare_id);\n\n    if( !block->isModule())\n    {\n\ty2error( \"'%s' is no module\", filename.c_str());\n\treturn NULL;\n    }\n\n    m_xmlcodeCache->insert( std::make_pair( mname, block));\n\n    return block;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "map <string, YBlockPtr>* Xmlcode::m_xmlcodeCache = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_xmlcodeCache->insert",
          "args": [
            "std::make_pair( mname, block)"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "mname",
            "block"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"'%s' is no module\"",
            "filename.c_str()"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block->isModule",
          "args": [],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "isModule",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YBlock.h",
          "lines": "205-205",
          "snippet": "bool isModule () const\t{ return (m_kind == b_module); }",
          "includes": [
            "#include \"ycp/YStatement.h\"",
            "#include <y2/Y2Namespace.h>",
            "#include <y2util/Ustring.h>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YStatement.h\"\n#include <y2/Y2Namespace.h>\n#include <y2util/Ustring.h>\n#include <list>\n#include <string>\n\nYBlock {\n  bool isModule () const\t{ return (m_kind == b_module); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Xmlcode::untareStack",
          "args": [
            "tare_id"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "untareStack",
          "container": "Xmlcode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
          "lines": "428-436",
          "snippet": "void\nXmlcode::untareStack( int tare_id)\n{\n#if DO_DEBUG\n//    y2debug( \"Xmlcode::untareStack() level %d, size %d, current tare %d, tare_id %d\", m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level, tare_id);\n#endif\n    m_namespace_tare_level -= tare_id;\n    return;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Xmlcode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "int Xmlcode::m_namespace_nesting_level = -1;",
            "int Xmlcode::m_namespace_nesting_array_size = 0;",
            "int Xmlcode::m_namespace_tare_level = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\n#define DO_DEBUG 0\n\nint Xmlcode::m_namespace_nesting_level = -1;\nint Xmlcode::m_namespace_nesting_array_size = 0;\nint Xmlcode::m_namespace_tare_level = 0;\n\nXmlcode {\n  void\n  Xmlcode::untareStack( int tare_id)\n  {\n  #if DO_DEBUG\n  //    y2debug( \"Xmlcode::untareStack() level %d, size %d, current tare %d, tare_id %d\", m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level, tare_id);\n  #endif\n      m_namespace_tare_level -= tare_id;\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Xmlcode::readFile",
          "args": [
            "filename"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "readFile",
          "container": "Xmlcode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
          "lines": "787-820",
          "snippet": "YCodePtr\nXmlcode::readFile( const string & filename)\n{\n#if DO_DEBUG\n//    y2debug( \"Xmlcode::readFile( %s)\", filename.c_str());\n#endif\n    xmlcodeistream instream( filename);\n    if( !instream.is_open( ))\n    {\n\ty2error( \"Failed to open '%s': %s\", filename.c_str(), strerror( errno));\n\treturn 0;\n    }\n    // check YaST_BYTECODE_HEADER\n    if(  \n\tinstream.isVersion( \n\t    atoi( YaST_BYTECODE_MAJOR)\n\t    , atoi( YaST_BYTECODE_MINOR)\n\t    , atoi( YaST_BYTECODE_RELEASE))\n\t||\n\tinstream.isVersion( 1,3,2) )\t// 9.1/SLES9\n    {\n#if DO_DEBUG\n//\ty2debug( \"Header accepted\");\n#endif\n\t\n\treturn readCode( instream);\n    }\n\n    y2error( \"Unsupported version %d.%d.%d\"\n\t, instream.major( )\n\t, instream.minor( )\n\t, instream.release( ));\n    return 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Xmlcode.h\""
          ],
          "macros_used": [
            "#define YaST_BYTECODE_RELEASE \"0\"",
            "#define YaST_BYTECODE_MINOR \"4\"",
            "#define YaST_BYTECODE_MAJOR \"1\"",
            "#define YaST_BYTECODE_HEADER \"YaST xmlcode \"",
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\n#define YaST_BYTECODE_RELEASE \"0\"\n#define YaST_BYTECODE_MINOR \"4\"\n#define YaST_BYTECODE_MAJOR \"1\"\n#define YaST_BYTECODE_HEADER \"YaST xmlcode \"\n#define DO_DEBUG 0\n\nXmlcode {\n  YCodePtr\n  Xmlcode::readFile( const string & filename)\n  {\n  #if DO_DEBUG\n  //    y2debug( \"Xmlcode::readFile( %s)\", filename.c_str());\n  #endif\n      xmlcodeistream instream( filename);\n      if( !instream.is_open( ))\n      {\n  \ty2error( \"Failed to open '%s': %s\", filename.c_str(), strerror( errno));\n  \treturn 0;\n      }\n      // check YaST_BYTECODE_HEADER\n      if(  \n  \tinstream.isVersion( \n  \t    atoi( YaST_BYTECODE_MAJOR)\n  \t    , atoi( YaST_BYTECODE_MINOR)\n  \t    , atoi( YaST_BYTECODE_RELEASE))\n  \t||\n  \tinstream.isVersion( 1,3,2) )\t// 9.1/SLES9\n      {\n  #if DO_DEBUG\n  //\ty2debug( \"Header accepted\");\n  #endif\n  \t\n  \treturn readCode( instream);\n      }\n  \n      y2error( \"Unsupported version %d.%d.%d\"\n  \t, instream.major( )\n  \t, instream.minor( )\n  \t, instream.release( ));\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Xmlcode::tareStack",
          "args": [],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "tareStack",
          "container": "Xmlcode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
          "lines": "416-425",
          "snippet": "int\nXmlcode::tareStack( )\n{\n    int tare = m_namespace_nesting_level - m_namespace_tare_level + 1;\n#if DO_DEBUG\n//    y2debug( \"Xmlcode::tareStack() level %d, size %d, current tare %d, tare_id %d\", m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level, tare);\n#endif\n    m_namespace_tare_level = m_namespace_nesting_level + 1;\n    return tare;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Xmlcode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "int Xmlcode::m_namespace_nesting_level = -1;",
            "int Xmlcode::m_namespace_nesting_array_size = 0;",
            "int Xmlcode::m_namespace_tare_level = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\n#define DO_DEBUG 0\n\nint Xmlcode::m_namespace_nesting_level = -1;\nint Xmlcode::m_namespace_nesting_array_size = 0;\nint Xmlcode::m_namespace_tare_level = 0;\n\nXmlcode {\n  int\n  Xmlcode::tareStack( )\n  {\n      int tare = m_namespace_nesting_level - m_namespace_tare_level + 1;\n  #if DO_DEBUG\n  //    y2debug( \"Xmlcode::tareStack() level %d, size %d, current tare %d, tare_id %d\", m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level, tare);\n  #endif\n      m_namespace_tare_level = m_namespace_nesting_level + 1;\n      return tare;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_xmlcodeCache->find",
          "args": [
            "mname"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_xmlcodeCache->end",
          "args": [],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_xmlcodeCache->find",
          "args": [
            "mname"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycperror",
          "args": [
            "\"Module '%s' not found\"",
            "mname.c_str()"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mname.c_str",
          "args": [],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.empty",
          "args": [],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPPathSearch::findModule",
          "args": [
            "mname"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\n#define DO_DEBUG 0\n\nmap <string, YBlockPtr>* Xmlcode::m_xmlcodeCache = NULL;\n\nXmlcode {\n  YBlockPtr \n  Xmlcode::readModule( const string & mname)\n  {\n  #if DO_DEBUG\n  //    y2debug( \"Xmlcode::readModule( %s) \", mname.c_str( ));\n  #endif\n  \n      // TODO better error reporting?\n      // like: could not find foo.ycp in /modules, /a/modules.\n      // It will return an empty string on failure\n  \n      string filename = YCPPathSearch::findModule( mname);\n      if( filename.empty())\n      {\n  \tycperror( \"Module '%s' not found\", mname.c_str());\n  \treturn 0;\n      }\n      \n      if( ! m_xmlcodeCache)\n      {\n  \tm_xmlcodeCache = new map <string, YBlockPtr>;\n      }\n  \n      // check the cache\n      if( m_xmlcodeCache->find( mname) != m_xmlcodeCache->end( ))\n      {\n  #if DO_DEBUG\n  //\ty2debug( \"Xmlcode cache hit: %s\", mname.c_str( ));\n  #endif\n  \n  \treturn m_xmlcodeCache->find( mname)->second;\n      }\n      \n      int tare_id = Xmlcode::tareStack( );\t\t\t// current nesting level is 0 for this module\n      YBlockPtr block =( YBlockPtr)Xmlcode::readFile( filename);\n  \n      if( block == NULL)\n      {\n  \treturn NULL;\n      }\n  \n      Xmlcode::untareStack( tare_id);\n  \n      if( !block->isModule())\n      {\n  \ty2error( \"'%s' is no module\", filename.c_str());\n  \treturn NULL;\n      }\n  \n      m_xmlcodeCache->insert( std::make_pair( mname, block));\n  \n      return block;\n  }\n}"
  },
  {
    "function_name": "readCode",
    "container": "Xmlcode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "471-720",
    "snippet": "YCodePtr\nXmlcode::readCode( xmlcodeistream & str)\n{\n    char code;\n    if( !str.get( code))\n    {\n\ty2error( \"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug( \"Xmlcode::readCode( %d:%s)\", code, YCode::toString( (YCode::ykind)code).c_str());\n#endif\n    YCodePtr res = 0;\n\n#if XMLCODE_INPUT_SUPPORTED\n    if( code < YCode::ycConstant)\n    {\n\treturn new YConst( (YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if( str.isVersion( 1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    try\n    {\n\n    switch( code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error( \"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale( str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction( str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate( str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary( str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary( str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple( str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare( str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale( str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList( str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap( str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm( str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs( str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket( str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock( str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn( str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable( str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference( str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin( str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall( str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer( str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef( str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable( str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction( str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign( str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket( str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf( str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile( str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo( str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat( str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression( str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn( str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak( str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue( str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain( str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude( str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename( str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport( str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock( str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch( str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error( \"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    }\n    catch( const Xmlcode::Invalid&)\n    {\n\t// there are memory leaks all over the place now\n\ty2error( \"Caught invalid xmlcode\");\n    }\n#endif\n    return res;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [
      "#define XMLCODE_INPUT_SUPPORTED 0",
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Caught invalid xmlcode\""
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unknown code %d\"",
            "code"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YECall::readCall",
          "args": [
            "str"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "readCall",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2700-2745",
          "snippet": "YECallPtr YECall::readCall (bytecodeistream & str)\n{\n    YECallPtr res = 0;\n\n    SymbolEntryPtr sentry = Bytecode::readEntry (str);\n    \n    if (!sentry)\n    {\n\treturn 0;\n    }\n    \n    if (str.isVersion (1,3,2) && sentry->isVariable ())\n    {\n\t// it is a function pointer from SLES9/9.1\n\tres = new YEFunctionPointer (0);\n    }\n    else\n    {\n\t// it is direct function call\n\tres = new YEFunction (0);\n    }\n    \n    res->m_sentry = sentry;\n    \n    // read the parameters\n    u_int32_t count = Bytecode::readInt32 (str);\n    \n    if (count>0)\n    {\n\tres->m_parameters = new YCodePtr[count];\n\n\tfor (uint i = 0 ; i < count; i++)\n\t{\n\t    res->m_parameters[i] = Bytecode::readCode (str);\n\t    if (res->m_parameters[i] == 0)\n\t    {\n\t\ty2error (\"parameter code read failed for %d\", i);\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n    res->m_next_param_id = count;\n\n    return res;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  YECallPtr YECall::readCall (bytecodeistream & str)\n  {\n      YECallPtr res = 0;\n  \n      SymbolEntryPtr sentry = Bytecode::readEntry (str);\n      \n      if (!sentry)\n      {\n  \treturn 0;\n      }\n      \n      if (str.isVersion (1,3,2) && sentry->isVariable ())\n      {\n  \t// it is a function pointer from SLES9/9.1\n  \tres = new YEFunctionPointer (0);\n      }\n      else\n      {\n  \t// it is direct function call\n  \tres = new YEFunction (0);\n      }\n      \n      res->m_sentry = sentry;\n      \n      // read the parameters\n      u_int32_t count = Bytecode::readInt32 (str);\n      \n      if (count>0)\n      {\n  \tres->m_parameters = new YCodePtr[count];\n  \n  \tfor (uint i = 0 ; i < count; i++)\n  \t{\n  \t    res->m_parameters[i] = Bytecode::readCode (str);\n  \t    if (res->m_parameters[i] == 0)\n  \t    {\n  \t\ty2error (\"parameter code read failed for %d\", i);\n  \t\treturn 0;\n  \t    }\n  \t}\n      }\n  \n      res->m_next_param_id = count;\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unable to read constant, check the compilation of the module\""
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str.isVersion",
          "args": [
            "1",
            "3",
            "2"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "isVersion",
          "container": "xmlcodeistream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
          "lines": "115-120",
          "snippet": "bool xmlcodeistream::isVersion( int major, int minor, int release)\n{\n    return( major == m_major) \n\t&&( minor == m_minor) \n\t&&( release == m_release);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Xmlcode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\nxmlcodeistream {\n  bool xmlcodeistream::isVersion( int major, int minor, int release)\n  {\n      return( major == m_major) \n  \t&&( minor == m_minor) \n  \t&&( release == m_release);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Can't read from stream\""
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str.get",
          "args": [
            "code"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\n#define XMLCODE_INPUT_SUPPORTED 0\n#define DO_DEBUG 0\n\nXmlcode {\n  YCodePtr\n  Xmlcode::readCode( xmlcodeistream & str)\n  {\n      char code;\n      if( !str.get( code))\n      {\n  \ty2error( \"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug( \"Xmlcode::readCode( %d:%s)\", code, YCode::toString( (YCode::ykind)code).c_str());\n  #endif\n      YCodePtr res = 0;\n  \n  #if XMLCODE_INPUT_SUPPORTED\n      if( code < YCode::ycConstant)\n      {\n  \treturn new YConst( (YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if( str.isVersion( 1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      try\n      {\n  \n      switch( code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error( \"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall( str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock( str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch( str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error( \"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      }\n      catch( const Xmlcode::Invalid&)\n      {\n  \t// there are memory leaks all over the place now\n  \ty2error( \"Caught invalid xmlcode\");\n      }\n  #endif\n      return res;\n  }\n}"
  },
  {
    "function_name": "readEntry",
    "container": "Xmlcode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "460-464",
    "snippet": "SymbolEntryPtr \nXmlcode::readEntry( xmlcodeistream & str)\n{\n    return 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\nXmlcode {\n  SymbolEntryPtr \n  Xmlcode::readEntry( xmlcodeistream & str)\n  {\n      return 0;\n  }\n}"
  },
  {
    "function_name": "untareStack",
    "container": "Xmlcode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "428-436",
    "snippet": "void\nXmlcode::untareStack( int tare_id)\n{\n#if DO_DEBUG\n//    y2debug( \"Xmlcode::untareStack() level %d, size %d, current tare %d, tare_id %d\", m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level, tare_id);\n#endif\n    m_namespace_tare_level -= tare_id;\n    return;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "int Xmlcode::m_namespace_nesting_level = -1;",
      "int Xmlcode::m_namespace_nesting_array_size = 0;",
      "int Xmlcode::m_namespace_tare_level = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\n#define DO_DEBUG 0\n\nint Xmlcode::m_namespace_nesting_level = -1;\nint Xmlcode::m_namespace_nesting_array_size = 0;\nint Xmlcode::m_namespace_tare_level = 0;\n\nXmlcode {\n  void\n  Xmlcode::untareStack( int tare_id)\n  {\n  #if DO_DEBUG\n  //    y2debug( \"Xmlcode::untareStack() level %d, size %d, current tare %d, tare_id %d\", m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level, tare_id);\n  #endif\n      m_namespace_tare_level -= tare_id;\n      return;\n  }\n}"
  },
  {
    "function_name": "tareStack",
    "container": "Xmlcode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "416-425",
    "snippet": "int\nXmlcode::tareStack( )\n{\n    int tare = m_namespace_nesting_level - m_namespace_tare_level + 1;\n#if DO_DEBUG\n//    y2debug( \"Xmlcode::tareStack() level %d, size %d, current tare %d, tare_id %d\", m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level, tare);\n#endif\n    m_namespace_tare_level = m_namespace_nesting_level + 1;\n    return tare;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "int Xmlcode::m_namespace_nesting_level = -1;",
      "int Xmlcode::m_namespace_nesting_array_size = 0;",
      "int Xmlcode::m_namespace_tare_level = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\n#define DO_DEBUG 0\n\nint Xmlcode::m_namespace_nesting_level = -1;\nint Xmlcode::m_namespace_nesting_array_size = 0;\nint Xmlcode::m_namespace_tare_level = 0;\n\nXmlcode {\n  int\n  Xmlcode::tareStack( )\n  {\n      int tare = m_namespace_nesting_level - m_namespace_tare_level + 1;\n  #if DO_DEBUG\n  //    y2debug( \"Xmlcode::tareStack() level %d, size %d, current tare %d, tare_id %d\", m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level, tare);\n  #endif\n      m_namespace_tare_level = m_namespace_nesting_level + 1;\n      return tare;\n  }\n}"
  },
  {
    "function_name": "popUptoNamespace",
    "container": "Xmlcode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "384-411",
    "snippet": "void\nXmlcode::popUptoNamespace( const Y2Namespace *name_space)\n{\n#if DO_DEBUG\n    y2debug( \"Xmlcode::popUptoNamespace( %p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n#endif\n    if( name_space == 0)\n    {\n\ty2error( \"Xmlcode::popUptoNamespace( %p) NULL\", name_space);\n\treturn;\n    }\n\n    while( m_namespace_nesting_level >= m_namespace_tare_level)\n    {\n\tconst Y2Namespace *top_space = m_namespace_nesting_array[m_namespace_nesting_level].name_space;\n\tif( m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs)\n\t{\n\t    top_space->table()->closeXRefs();\n\t}\n\tm_namespace_nesting_level--;\n\tif( top_space == name_space)\n\t{\n\t    return;\n\t}\n    }\n    y2error( \"Xmlcode::popUptoNamespace( %p) empty stack\", name_space);\n    return;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "int Xmlcode::m_namespace_nesting_level = -1;",
      "int Xmlcode::m_namespace_nesting_array_size = 0;",
      "int Xmlcode::m_namespace_tare_level = 0;",
      "Xmlcode::namespaceentry_t *Xmlcode::m_namespace_nesting_array = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Xmlcode::popUptoNamespace( %p) empty stack\"",
            "name_space"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "top_space->table",
          "args": [],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "top_space->table",
          "args": [],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Xmlcode::popUptoNamespace( %p) NULL\"",
            "name_space"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Xmlcode::popUptoNamespace( %p), level %d, size %d, tare %d\"",
            "name_space",
            "m_namespace_nesting_level",
            "m_namespace_nesting_array_size",
            "m_namespace_tare_level"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\n#define DO_DEBUG 0\n\nint Xmlcode::m_namespace_nesting_level = -1;\nint Xmlcode::m_namespace_nesting_array_size = 0;\nint Xmlcode::m_namespace_tare_level = 0;\nXmlcode::namespaceentry_t *Xmlcode::m_namespace_nesting_array = 0;\n\nXmlcode {\n  void\n  Xmlcode::popUptoNamespace( const Y2Namespace *name_space)\n  {\n  #if DO_DEBUG\n      y2debug( \"Xmlcode::popUptoNamespace( %p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n  #endif\n      if( name_space == 0)\n      {\n  \ty2error( \"Xmlcode::popUptoNamespace( %p) NULL\", name_space);\n  \treturn;\n      }\n  \n      while( m_namespace_nesting_level >= m_namespace_tare_level)\n      {\n  \tconst Y2Namespace *top_space = m_namespace_nesting_array[m_namespace_nesting_level].name_space;\n  \tif( m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs)\n  \t{\n  \t    top_space->table()->closeXRefs();\n  \t}\n  \tm_namespace_nesting_level--;\n  \tif( top_space == name_space)\n  \t{\n  \t    return;\n  \t}\n      }\n      y2error( \"Xmlcode::popUptoNamespace( %p) empty stack\", name_space);\n      return;\n  }\n}"
  },
  {
    "function_name": "popNamespace",
    "container": "Xmlcode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "351-380",
    "snippet": "int\nXmlcode::popNamespace( const Y2Namespace *name_space)\n{\n#if DO_DEBUG\n    y2debug( \"Xmlcode::popNamespace( %p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n#endif\n    if( name_space == 0)\n    {\n\ty2error( \"Xmlcode::popNamespace( %p) NULL\", name_space);\n\treturn -1;\n    }\n\n    if( m_namespace_nesting_level < m_namespace_tare_level)\n    {\n\ty2error( \"Xmlcode::popNamespace( %p) empty stack\", name_space);\n    }\n    else if( m_namespace_nesting_array[m_namespace_nesting_level].name_space != name_space)\n    {\n\ty2error( \"Xmlcode::popNamespace( %p) not top of stack [%d]%p\", name_space, m_namespace_nesting_level, m_namespace_nesting_array[m_namespace_nesting_level].name_space);\n    }\n    else\n    {\n\tif( m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs)\n\t{\n\t    name_space->table()->closeXRefs();\n\t}\n\tm_namespace_nesting_level--;\n    }\n    return 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "int Xmlcode::m_namespace_nesting_level = -1;",
      "int Xmlcode::m_namespace_nesting_array_size = 0;",
      "int Xmlcode::m_namespace_tare_level = 0;",
      "Xmlcode::namespaceentry_t *Xmlcode::m_namespace_nesting_array = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "name_space->table",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_space->table",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Xmlcode::popNamespace( %p) not top of stack [%d]%p\"",
            "name_space",
            "m_namespace_nesting_level",
            "m_namespace_nesting_array[m_namespace_nesting_level].name_space"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Xmlcode::popNamespace( %p) empty stack\"",
            "name_space"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Xmlcode::popNamespace( %p) NULL\"",
            "name_space"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Xmlcode::popNamespace( %p), level %d, size %d, tare %d\"",
            "name_space",
            "m_namespace_nesting_level",
            "m_namespace_nesting_array_size",
            "m_namespace_tare_level"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\n#define DO_DEBUG 0\n\nint Xmlcode::m_namespace_nesting_level = -1;\nint Xmlcode::m_namespace_nesting_array_size = 0;\nint Xmlcode::m_namespace_tare_level = 0;\nXmlcode::namespaceentry_t *Xmlcode::m_namespace_nesting_array = 0;\n\nXmlcode {\n  int\n  Xmlcode::popNamespace( const Y2Namespace *name_space)\n  {\n  #if DO_DEBUG\n      y2debug( \"Xmlcode::popNamespace( %p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n  #endif\n      if( name_space == 0)\n      {\n  \ty2error( \"Xmlcode::popNamespace( %p) NULL\", name_space);\n  \treturn -1;\n      }\n  \n      if( m_namespace_nesting_level < m_namespace_tare_level)\n      {\n  \ty2error( \"Xmlcode::popNamespace( %p) empty stack\", name_space);\n      }\n      else if( m_namespace_nesting_array[m_namespace_nesting_level].name_space != name_space)\n      {\n  \ty2error( \"Xmlcode::popNamespace( %p) not top of stack [%d]%p\", name_space, m_namespace_nesting_level, m_namespace_nesting_array[m_namespace_nesting_level].name_space);\n      }\n      else\n      {\n  \tif( m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs)\n  \t{\n  \t    name_space->table()->closeXRefs();\n  \t}\n  \tm_namespace_nesting_level--;\n      }\n      return 0;\n  }\n}"
  },
  {
    "function_name": "pushNamespace",
    "container": "Xmlcode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "320-346",
    "snippet": "int\nXmlcode::pushNamespace( const Y2Namespace *name_space, bool with_xrefs)\n{\n    if( name_space == 0)\n    {\n\ty2error( \"Xmlcode::pushNamespace( %p) NULL\", name_space);\n\treturn -1;\n    }\n\n    m_namespace_nesting_level++;\n    if( m_namespace_nesting_array_size <= m_namespace_nesting_level)\n    {\n\tm_namespace_nesting_array_size += 16;\n\tm_namespace_nesting_array =( namespaceentry_t *)realloc( m_namespace_nesting_array, sizeof( namespaceentry_t) * m_namespace_nesting_array_size);\n    }\n#if DO_DEBUG\n    y2debug( \"Xmlcode::pushNamespace( %p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n#endif\n    m_namespace_nesting_array[m_namespace_nesting_level].name_space = name_space;\n    m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs = with_xrefs;\n    if( with_xrefs)\n    {\n\tname_space->table()->openXRefs();\n    }\n\n    return m_namespace_nesting_level-m_namespace_tare_level;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "int Xmlcode::m_namespace_nesting_level = -1;",
      "int Xmlcode::m_namespace_nesting_array_size = 0;",
      "int Xmlcode::m_namespace_tare_level = 0;",
      "Xmlcode::namespaceentry_t *Xmlcode::m_namespace_nesting_array = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "name_space->table",
          "args": [],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_space->table",
          "args": [],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Xmlcode::pushNamespace( %p), level %d, size %d, tare %d\"",
            "name_space",
            "m_namespace_nesting_level",
            "m_namespace_nesting_array_size",
            "m_namespace_tare_level"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "m_namespace_nesting_array",
            "sizeof( namespaceentry_t) * m_namespace_nesting_array_size"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Xmlcode::pushNamespace( %p) NULL\"",
            "name_space"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\n#define DO_DEBUG 0\n\nint Xmlcode::m_namespace_nesting_level = -1;\nint Xmlcode::m_namespace_nesting_array_size = 0;\nint Xmlcode::m_namespace_tare_level = 0;\nXmlcode::namespaceentry_t *Xmlcode::m_namespace_nesting_array = 0;\n\nXmlcode {\n  int\n  Xmlcode::pushNamespace( const Y2Namespace *name_space, bool with_xrefs)\n  {\n      if( name_space == 0)\n      {\n  \ty2error( \"Xmlcode::pushNamespace( %p) NULL\", name_space);\n  \treturn -1;\n      }\n  \n      m_namespace_nesting_level++;\n      if( m_namespace_nesting_array_size <= m_namespace_nesting_level)\n      {\n  \tm_namespace_nesting_array_size += 16;\n  \tm_namespace_nesting_array =( namespaceentry_t *)realloc( m_namespace_nesting_array, sizeof( namespaceentry_t) * m_namespace_nesting_array_size);\n      }\n  #if DO_DEBUG\n      y2debug( \"Xmlcode::pushNamespace( %p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n  #endif\n      m_namespace_nesting_array[m_namespace_nesting_level].name_space = name_space;\n      m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs = with_xrefs;\n      if( with_xrefs)\n      {\n  \tname_space->table()->openXRefs();\n      }\n  \n      return m_namespace_nesting_level-m_namespace_tare_level;\n  }\n}"
  },
  {
    "function_name": "namespaceId",
    "container": "Xmlcode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "286-298",
    "snippet": "int\nXmlcode::namespaceId( const Y2Namespace *name_space)\n{\n    for( int i = m_namespace_tare_level; i <= m_namespace_nesting_level; i++)\n    {\n\tif( m_namespace_nesting_array[i].name_space == name_space)\n\t{\n\t    return i - m_namespace_tare_level;\n\t}\n    }\n    y2error( \"No ID for %p, level %d\", name_space, m_namespace_nesting_level);\n    return -1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int Xmlcode::m_namespace_nesting_level = -1;",
      "int Xmlcode::m_namespace_tare_level = 0;",
      "Xmlcode::namespaceentry_t *Xmlcode::m_namespace_nesting_array = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"No ID for %p, level %d\"",
            "name_space",
            "m_namespace_nesting_level"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\nint Xmlcode::m_namespace_nesting_level = -1;\nint Xmlcode::m_namespace_tare_level = 0;\nXmlcode::namespaceentry_t *Xmlcode::m_namespace_nesting_array = 0;\n\nXmlcode {\n  int\n  Xmlcode::namespaceId( const Y2Namespace *name_space)\n  {\n      for( int i = m_namespace_tare_level; i <= m_namespace_nesting_level; i++)\n      {\n  \tif( m_namespace_nesting_array[i].name_space == name_space)\n  \t{\n  \t    return i - m_namespace_tare_level;\n  \t}\n      }\n      y2error( \"No ID for %p, level %d\", name_space, m_namespace_nesting_level);\n      return -1;\n  }\n}"
  },
  {
    "function_name": "readYCodelist",
    "container": "Xmlcode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "274-279",
    "snippet": "bool\nXmlcode::readYCodelist( xmlcodeistream & str, ycodelist_t **anchor)\n{\n\n    return str.good();\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "str.good",
          "args": [],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\nXmlcode {\n  bool\n  Xmlcode::readYCodelist( xmlcodeistream & str, ycodelist_t **anchor)\n  {\n  \n      return str.good();\n  }\n}"
  },
  {
    "function_name": "readType",
    "container": "Xmlcode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "208-248",
    "snippet": "TypePtr\nXmlcode::readType( xmlcodeistream & str)\n{\n#if DO_DEBUG\ny2debug( \"Xmlcode::readType(%d)\", kind);\n#endif\n#if XMLCODE_INPUT_SUPPORTED\n    int kind = readInt32( str);\n    switch( (Type::tkind)kind)\n    {\n\tcase Type::UnspecT:\n\tcase Type::ErrorT:\n\tcase Type::AnyT:\n\tcase Type::BooleanT:\n\tcase Type::ByteblockT:\n\tcase Type::FloatT:\n\tcase Type::IntegerT:\n\tcase Type::LocaleT:\n\tcase Type::PathT:\n\tcase Type::StringT:\n\tcase Type::SymbolT:\n\tcase Type::TermT:\n\tcase Type::VoidT:\n\tcase Type::WildcardT:\n\tcase Type::FlexT:\n\tcase Type::NilT:\n\t    return TypePtr(  new Type( (Type::tkind)kind, str) );\n\tbreak;\n\n\tcase Type::NFlexT:\treturn TypePtr(  new NFlexType( str) ); break;\n\tcase Type::VariableT:\treturn TypePtr(  new VariableType( str) ); break;\n\tcase Type::BlockT:\treturn TypePtr(  new BlockType( str) ); break;\n\tcase Type::ListT:\treturn TypePtr(  new ListType( str) ); break;\n\tcase Type::MapT:\treturn TypePtr(  new MapType( str) ); break;\n\tcase Type::TupleT:\treturn TypePtr(  new TupleType( str) ); break;\n\tcase Type::FunctionT:\treturn TypePtr(  new FunctionType( str) ); break;\n    }\n    y2error( \"Unhandled type kind %d\", kind);\n#endif\n    return Type::Error->clone();\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [
      "#define XMLCODE_INPUT_SUPPORTED 0",
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Type::Error->clone",
          "args": [],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "clone",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1842-1854",
          "snippet": "TypePtr\nFunctionType::clone () const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType (index));\n\t}\n    }\n    return tp;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  TypePtr\n  FunctionType::clone () const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType (index));\n  \t}\n      }\n      return tp;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unhandled type kind %d\"",
            "kind"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new FunctionType( str)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new TupleType( str)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new MapType( str)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new ListType( str)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new BlockType( str)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new VariableType( str)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new NFlexType( str)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new Type( (Type::tkind)kind, str)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readInt32",
          "args": [
            "str"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Xmlcode::readType(%d)\"",
            "kind"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\n#define XMLCODE_INPUT_SUPPORTED 0\n#define DO_DEBUG 0\n\nXmlcode {\n  TypePtr\n  Xmlcode::readType( xmlcodeistream & str)\n  {\n  #if DO_DEBUG\n  y2debug( \"Xmlcode::readType(%d)\", kind);\n  #endif\n  #if XMLCODE_INPUT_SUPPORTED\n      int kind = readInt32( str);\n      switch( (Type::tkind)kind)\n      {\n  \tcase Type::UnspecT:\n  \tcase Type::ErrorT:\n  \tcase Type::AnyT:\n  \tcase Type::BooleanT:\n  \tcase Type::ByteblockT:\n  \tcase Type::FloatT:\n  \tcase Type::IntegerT:\n  \tcase Type::LocaleT:\n  \tcase Type::PathT:\n  \tcase Type::StringT:\n  \tcase Type::SymbolT:\n  \tcase Type::TermT:\n  \tcase Type::VoidT:\n  \tcase Type::WildcardT:\n  \tcase Type::FlexT:\n  \tcase Type::NilT:\n  \t    return TypePtr(  new Type( (Type::tkind)kind, str) );\n  \tbreak;\n  \n  \tcase Type::NFlexT:\treturn TypePtr(  new NFlexType( str) ); break;\n  \tcase Type::VariableT:\treturn TypePtr(  new VariableType( str) ); break;\n  \tcase Type::BlockT:\treturn TypePtr(  new BlockType( str) ); break;\n  \tcase Type::ListT:\treturn TypePtr(  new ListType( str) ); break;\n  \tcase Type::MapT:\treturn TypePtr(  new MapType( str) ); break;\n  \tcase Type::TupleT:\treturn TypePtr(  new TupleType( str) ); break;\n  \tcase Type::FunctionT:\treturn TypePtr(  new FunctionType( str) ); break;\n      }\n      y2error( \"Unhandled type kind %d\", kind);\n  #endif\n      return Type::Error->clone();\n  }\n}"
  },
  {
    "function_name": "to_hexc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "170-176",
    "snippet": "static int\nto_hexc( unsigned char v )\n{\n    if( v < 10 ) return '0' + v;\n    if( v < 16 ) return 'A' + v - 10;\n    return -1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\nstatic int\nto_hexc( unsigned char v )\n{\n    if( v < 10 ) return '0' + v;\n    if( v < 16 ) return 'A' + v - 10;\n    return -1;\n}"
  },
  {
    "function_name": "namespaceInit",
    "container": "Xmlcode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "150-165",
    "snippet": "void\nXmlcode::namespaceInit( )\n{\n#if DO_DEBUG\n    y2debug( \"Reinitialize namespaces\");\n#endif\n    if( Xmlcode::m_namespace_nesting_array)\n    {\n\tfree( Xmlcode::m_namespace_nesting_array);\n    }\n    \n    Xmlcode::m_namespace_nesting_array = 0;\n    Xmlcode::m_namespace_nesting_level = -1;\n    Xmlcode::m_namespace_nesting_array_size = 0;\n    Xmlcode::m_namespace_tare_level = 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "int Xmlcode::m_namespace_nesting_level = -1;",
      "int Xmlcode::m_namespace_nesting_array_size = 0;",
      "int Xmlcode::m_namespace_tare_level = 0;",
      "Xmlcode::namespaceentry_t *Xmlcode::m_namespace_nesting_array = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "Xmlcode::m_namespace_nesting_array"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Reinitialize namespaces\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\n#define DO_DEBUG 0\n\nint Xmlcode::m_namespace_nesting_level = -1;\nint Xmlcode::m_namespace_nesting_array_size = 0;\nint Xmlcode::m_namespace_tare_level = 0;\nXmlcode::namespaceentry_t *Xmlcode::m_namespace_nesting_array = 0;\n\nXmlcode {\n  void\n  Xmlcode::namespaceInit( )\n  {\n  #if DO_DEBUG\n      y2debug( \"Reinitialize namespaces\");\n  #endif\n      if( Xmlcode::m_namespace_nesting_array)\n      {\n  \tfree( Xmlcode::m_namespace_nesting_array);\n      }\n      \n      Xmlcode::m_namespace_nesting_array = 0;\n      Xmlcode::m_namespace_nesting_level = -1;\n      Xmlcode::m_namespace_nesting_array_size = 0;\n      Xmlcode::m_namespace_tare_level = 0;\n  }\n}"
  },
  {
    "function_name": "isVersionAtMost",
    "container": "xmlcodeistream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "122-143",
    "snippet": "bool xmlcodeistream::isVersionAtMost( int major, int minor, int release)\n{\n    if( m_major > major)\n    {\n\treturn false;\n    }\n    \n    if( m_major == major)\n    {\n\tif( m_minor > minor)\n\t{\n\t    return false;\n\t}\n\t\n\tif( ( m_minor == minor) &&( m_release > release))\n\t{\n\t    return false;\n\t}\n    }\n\n    return true;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\nxmlcodeistream {\n  bool xmlcodeistream::isVersionAtMost( int major, int minor, int release)\n  {\n      if( m_major > major)\n      {\n  \treturn false;\n      }\n      \n      if( m_major == major)\n      {\n  \tif( m_minor > minor)\n  \t{\n  \t    return false;\n  \t}\n  \t\n  \tif( ( m_minor == minor) &&( m_release > release))\n  \t{\n  \t    return false;\n  \t}\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "isVersion",
    "container": "xmlcodeistream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "115-120",
    "snippet": "bool xmlcodeistream::isVersion( int major, int minor, int release)\n{\n    return( major == m_major) \n\t&&( minor == m_minor) \n\t&&( release == m_release);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\nxmlcodeistream {\n  bool xmlcodeistream::isVersion( int major, int minor, int release)\n  {\n      return( major == m_major) \n  \t&&( minor == m_minor) \n  \t&&( release == m_release);\n  }\n}"
  },
  {
    "function_name": "xmlcodeistream",
    "container": "xmlcodeistream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "87-113",
    "snippet": "xmlcodeistream::xmlcodeistream( string filename)\n    : std::ifstream( filename.c_str( ))\n    , m_major( -1)\n    , m_minor( -1)\n    , m_release( -1)\n{\n    if( !is_open( ))\n    {\n\ty2error( \"Failed to open '%s': %s\", filename.c_str(), strerror( errno));\n\treturn;\n    }\n    // read YaST_BYTECODE_HEADER\n\n    char header[sizeof(YaST_BYTECODE_HEADER)+1];\n    int headerlen = strlen( YaST_BYTECODE_HEADER);\n    read( header, headerlen);\n    header[headerlen] = 0;\n    if( strcmp( header, YaST_BYTECODE_HEADER) != 0)\n    {\n\ty2error( \"Not a xmlcode file '%s'[%s]\", filename.c_str(), header);\n\treturn;\n    }\n\n    m_major = readInt( *this);\n    m_minor = readInt( *this);\n    m_release = readInt( *this);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [
      "#define YaST_BYTECODE_HEADER \"YaST xmlcode \""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readInt",
          "args": [
            "*this"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "readInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
          "lines": "67-84",
          "snippet": "static int\nreadInt( xmlcodeistream & str)\n{\n    int i = 0;\n\n    char c;\n\n    for( ;;)\n    {\n\tstr.get( c);\n\tif( !isdigit( c))\n\t    break;\n\ti *= 10;\n\ti +=( c - '0');\n    }\n\n    return i;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Xmlcode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\nstatic int\nreadInt( xmlcodeistream & str)\n{\n    int i = 0;\n\n    char c;\n\n    for( ;;)\n    {\n\tstr.get( c);\n\tif( !isdigit( c))\n\t    break;\n\ti *= 10;\n\ti +=( c - '0');\n    }\n\n    return i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Not a xmlcode file '%s'[%s]\"",
            "filename.c_str()",
            "header"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "header",
            "YaST_BYTECODE_HEADER"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "header",
            "headerlen"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "readYCodelist",
          "container": "Xmlcode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
          "lines": "274-279",
          "snippet": "bool\nXmlcode::readYCodelist( xmlcodeistream & str, ycodelist_t **anchor)\n{\n\n    return str.good();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Xmlcode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\nXmlcode {\n  bool\n  Xmlcode::readYCodelist( xmlcodeistream & str, ycodelist_t **anchor)\n  {\n  \n      return str.good();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "YaST_BYTECODE_HEADER"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Failed to open '%s': %s\"",
            "filename.c_str()",
            "strerror( errno)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_open",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\n#define YaST_BYTECODE_HEADER \"YaST xmlcode \"\n\nxmlcodeistream {\n  xmlcodeistream::xmlcodeistream( string filename)\n      : std::ifstream( filename.c_str( ))\n      , m_major( -1)\n      , m_minor( -1)\n      , m_release( -1)\n  {\n      if( !is_open( ))\n      {\n  \ty2error( \"Failed to open '%s': %s\", filename.c_str(), strerror( errno));\n  \treturn;\n      }\n      // read YaST_BYTECODE_HEADER\n  \n      char header[sizeof(YaST_BYTECODE_HEADER)+1];\n      int headerlen = strlen( YaST_BYTECODE_HEADER);\n      read( header, headerlen);\n      header[headerlen] = 0;\n      if( strcmp( header, YaST_BYTECODE_HEADER) != 0)\n      {\n  \ty2error( \"Not a xmlcode file '%s'[%s]\", filename.c_str(), header);\n  \treturn;\n      }\n  \n      m_major = readInt( *this);\n      m_minor = readInt( *this);\n      m_release = readInt( *this);\n  }\n}"
  },
  {
    "function_name": "readInt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
    "lines": "67-84",
    "snippet": "static int\nreadInt( xmlcodeistream & str)\n{\n    int i = 0;\n\n    char c;\n\n    for( ;;)\n    {\n\tstr.get( c);\n\tif( !isdigit( c))\n\t    break;\n\ti *= 10;\n\ti +=( c - '0');\n    }\n\n    return i;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Xmlcode.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "c"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str.get",
          "args": [
            "c"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\nstatic int\nreadInt( xmlcodeistream & str)\n{\n    int i = 0;\n\n    char c;\n\n    for( ;;)\n    {\n\tstr.get( c);\n\tif( !isdigit( c))\n\t    break;\n\ti *= 10;\n\ti +=( c - '0');\n    }\n\n    return i;\n}"
  }
]