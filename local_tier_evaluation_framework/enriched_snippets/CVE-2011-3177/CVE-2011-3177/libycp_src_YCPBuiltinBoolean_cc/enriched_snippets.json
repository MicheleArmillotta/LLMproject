[
  {
    "function_name": "YCPBuiltinBoolean",
    "container": "YCPBuiltinBoolean",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinBoolean.cc",
    "lines": "119-130",
    "snippet": "YCPBuiltinBoolean::YCPBuiltinBoolean ()\n{\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n\t{ \"!\",  \"boolean (boolean)\",          (void *)b_lnot,   0,           0, 0, 0 },\n\t{ \"||\", \"boolean (boolean, boolean)\", (void *)b_or, \tDECL_NOEVAL, 0, 0, 0 },\n\t{ \"&&\", \"boolean (boolean, boolean)\", (void *)b_and, \tDECL_NOEVAL, 0, 0, 0 },\n\t{ 0,    0,                            0,                0,           0, 0, 0 },\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinBoolean\", declarations);\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinBoolean.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern StaticDeclaration static_declarations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_declarations.registerDeclarations",
          "args": [
            "\"YCPBuiltinBoolean\"",
            "declarations"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "registerDeclarations",
          "container": "StaticDeclaration",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/StaticDeclaration.cc",
          "lines": "87-237",
          "snippet": "void\nStaticDeclaration::registerDeclarations (const char *filename,\n\t\t\t\t\t declaration_t *declarations)\n{\n    if (declarations == 0)\n    {\n\treturn;\n    }\n\n    SymbolTable *table = m_declTable;\n    const Y2Namespace *name_space = 0;\n    static const Point *builtin_point = new Point (\"<builtin>\");\n    const Point *namespace_point = builtin_point;\t\t// declarations default to builtin\n    declaration_t *namespace_decl = 0;\n\n    std::pair <std::string, Y2Namespace *> *track_info = 0;\n\n    while (declarations->name != 0)\n    {\n#if DO_DEBUG\n\ty2debug( \"Registering %s\", declarations->name );\n#endif\n\tconst char *name = declarations->name;\n\n\tif (*name == 0)\t\t// exit on empty name\n\t    break;\n\n\tif ((declarations->flags & (DECL_WILD|DECL_SYMBOL)) == (DECL_WILD|DECL_SYMBOL))\n\t{\n\t    y2internal (\"Declaration of %s::%s combines wildcard and symbol\\n\", filename, name);\n\t}\n\telse if ((declarations->flags & DECL_NAMESPACE) != 0)\t\t// switch namespace\n\t{\n\t    // new namespace, clear possibly old track_info\n\t    if (track_info != 0)\n\t    {\n\t\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n\t\tm_active_predefined.push_back (*track_info);\n\t\ttrack_info = 0;\n\t    }\n#if DO_DEBUG\n\t    y2debug (\"NAMESPACE (%s)\", name);\n#endif\n            declarations->name_space = namespace_decl;\n\n\t    TableEntry *tentry = table->find (name);\n\t    if (tentry != 0\t\t\t\t\t\t// name already exists\n\t\t&& tentry->sentry()->isNamespace())\t\t\t//   as namespace\n\t    {\n\t\tname_space = tentry->sentry()->nameSpace();\n\t    }\n\t    else if (*name == 0)\t\t\t\t\t// reset namespace\n\t    {\n\t\ttable = m_declTable;\n\t\tname_space = 0;\n\t\tnamespace_point = builtin_point;\n\t    }\n\t    else\t\t\t\t\t\t\t// open up new namespace\n\t    {\n\t\tbool is_predefined = false;\n\n\t\tif (tentry != 0\n\t\t    && tentry->sentry()->isPredefined())\t\t//   replace predefined\n\t\t{\n\t\t    table->remove (tentry);\n\t\t    is_predefined = true;\n\t\t}\n\n\t\t// create definition container for namespace\n\t\tYBlock *block = new YBlock (filename, YBlock::b_namespace);\n\t\tblock->setName (string (name));\n\n\t\tY2Namespace *namespaceNamespace = (Y2Namespace *)block;\n\t\tnamespaceNamespace->createTable();\n\t\tSymbolTable *namespaceTable = block->table();\n\n\t\t// create SymbolEntry::c_namespace for the namespace to be entered into the global table\n\t\tSymbolEntryPtr sentry = new YSymbolEntry (name, Type::Unspec, namespaceTable);\n\n#if DO_DEBUG\n\t\ty2debug (\"Entered Namespace '%s' (block %p) into namespaceTable %p\", name, block, namespaceTable);\n#endif\n\n\t\t// enter into global table\n\t\tnamespace_point = new Point (filename);\n\t\ttable->enter (name, sentry, namespace_point);\n\n\t\t// all further definitions go into this namespace\n\t\t//   -> make it the new global table\n\t\ttable = namespaceTable;\n\t\tnamespace_decl = declarations;\n\n\t\tif (is_predefined)\n\t\t{\n\t\t    // save tracking info, trigger 'Import' _after_ all symbols have been added\n\t\t    track_info = new std::pair<std::string, Y2Namespace *> (name, namespaceNamespace);\n\t\t}\n\t    }\n\t}\n\telse\t// normal entry, not namespace\n\t{\n\t    declarations->name_space = namespace_decl;\n\t    string signature = declarations->signature;\n\n\t    constTypePtr type = Type::fromSignature (signature);\n\t    if (type == 0\n\t\t|| type->isError()\n\t\t|| type->isUnspec()\n\t\t|| type->isWildcard())\n\t    {\n\t\ty2error (\"Invalid signature %s::%s:'%s'\\n\", filename, name, signature.c_str());\n\t\treturn;\n\t    }\n\n#if DO_DEBUG\ny2debug(\"%s sig[%s] type[%s]\", name, signature.c_str(), type->toString().c_str());\n#endif\n#if 0\n\t    if (type->hasFlex()\n\t\t&& (declarations->flags & DECL_FLEX) == 0)\n\t    {\n\t\ty2error (\"%s:'%s' without DECL_FLEX\", name, declarations->signature);\n\t\treturn;\n\t    }\n#endif\n\t    declarations->type = type;\n\n\t    SymbolEntryPtr sentry = new YSymbolEntry (name, type, declarations, name_space);\n\t    declarations->tentry = table->enter (name, sentry, new Point (sentry, 0, namespace_point));\n\n#ifdef BUILTIN_STATISTICS\n\t    FILE *fout = fopen (\"/tmp/builtin-register.txt\", \"a\");\n\t    if (fout) {\n\t\tfprintf (fout, \"%s %s\\n\", declarations->name, declarations->signature);\n\t\tfclose (fout);\n\t    }\n#endif\n\t}\n\tdeclarations++;\n    }\n\n    // clear possibly old track_info\n    if (track_info != 0)\n    {\n\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n\tm_active_predefined.push_back (*track_info);\n\ttrack_info = 0;\n    }\n\n    return;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Import.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include <map>",
            "#include <string>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "static const char *predefined[] = {\n  \"UI\", \"WFM\", \"SCR\", \"Pkg\", 0\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <unistd.h>\n\n#define DO_DEBUG 0\n\nstatic const char *predefined[] = {\n  \"UI\", \"WFM\", \"SCR\", \"Pkg\", 0\n};\n\nStaticDeclaration {\n  void\n  StaticDeclaration::registerDeclarations (const char *filename,\n  \t\t\t\t\t declaration_t *declarations)\n  {\n      if (declarations == 0)\n      {\n  \treturn;\n      }\n  \n      SymbolTable *table = m_declTable;\n      const Y2Namespace *name_space = 0;\n      static const Point *builtin_point = new Point (\"<builtin>\");\n      const Point *namespace_point = builtin_point;\t\t// declarations default to builtin\n      declaration_t *namespace_decl = 0;\n  \n      std::pair <std::string, Y2Namespace *> *track_info = 0;\n  \n      while (declarations->name != 0)\n      {\n  #if DO_DEBUG\n  \ty2debug( \"Registering %s\", declarations->name );\n  #endif\n  \tconst char *name = declarations->name;\n  \n  \tif (*name == 0)\t\t// exit on empty name\n  \t    break;\n  \n  \tif ((declarations->flags & (DECL_WILD|DECL_SYMBOL)) == (DECL_WILD|DECL_SYMBOL))\n  \t{\n  \t    y2internal (\"Declaration of %s::%s combines wildcard and symbol\\n\", filename, name);\n  \t}\n  \telse if ((declarations->flags & DECL_NAMESPACE) != 0)\t\t// switch namespace\n  \t{\n  \t    // new namespace, clear possibly old track_info\n  \t    if (track_info != 0)\n  \t    {\n  \t\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n  \t\tm_active_predefined.push_back (*track_info);\n  \t\ttrack_info = 0;\n  \t    }\n  #if DO_DEBUG\n  \t    y2debug (\"NAMESPACE (%s)\", name);\n  #endif\n              declarations->name_space = namespace_decl;\n  \n  \t    TableEntry *tentry = table->find (name);\n  \t    if (tentry != 0\t\t\t\t\t\t// name already exists\n  \t\t&& tentry->sentry()->isNamespace())\t\t\t//   as namespace\n  \t    {\n  \t\tname_space = tentry->sentry()->nameSpace();\n  \t    }\n  \t    else if (*name == 0)\t\t\t\t\t// reset namespace\n  \t    {\n  \t\ttable = m_declTable;\n  \t\tname_space = 0;\n  \t\tnamespace_point = builtin_point;\n  \t    }\n  \t    else\t\t\t\t\t\t\t// open up new namespace\n  \t    {\n  \t\tbool is_predefined = false;\n  \n  \t\tif (tentry != 0\n  \t\t    && tentry->sentry()->isPredefined())\t\t//   replace predefined\n  \t\t{\n  \t\t    table->remove (tentry);\n  \t\t    is_predefined = true;\n  \t\t}\n  \n  \t\t// create definition container for namespace\n  \t\tYBlock *block = new YBlock (filename, YBlock::b_namespace);\n  \t\tblock->setName (string (name));\n  \n  \t\tY2Namespace *namespaceNamespace = (Y2Namespace *)block;\n  \t\tnamespaceNamespace->createTable();\n  \t\tSymbolTable *namespaceTable = block->table();\n  \n  \t\t// create SymbolEntry::c_namespace for the namespace to be entered into the global table\n  \t\tSymbolEntryPtr sentry = new YSymbolEntry (name, Type::Unspec, namespaceTable);\n  \n  #if DO_DEBUG\n  \t\ty2debug (\"Entered Namespace '%s' (block %p) into namespaceTable %p\", name, block, namespaceTable);\n  #endif\n  \n  \t\t// enter into global table\n  \t\tnamespace_point = new Point (filename);\n  \t\ttable->enter (name, sentry, namespace_point);\n  \n  \t\t// all further definitions go into this namespace\n  \t\t//   -> make it the new global table\n  \t\ttable = namespaceTable;\n  \t\tnamespace_decl = declarations;\n  \n  \t\tif (is_predefined)\n  \t\t{\n  \t\t    // save tracking info, trigger 'Import' _after_ all symbols have been added\n  \t\t    track_info = new std::pair<std::string, Y2Namespace *> (name, namespaceNamespace);\n  \t\t}\n  \t    }\n  \t}\n  \telse\t// normal entry, not namespace\n  \t{\n  \t    declarations->name_space = namespace_decl;\n  \t    string signature = declarations->signature;\n  \n  \t    constTypePtr type = Type::fromSignature (signature);\n  \t    if (type == 0\n  \t\t|| type->isError()\n  \t\t|| type->isUnspec()\n  \t\t|| type->isWildcard())\n  \t    {\n  \t\ty2error (\"Invalid signature %s::%s:'%s'\\n\", filename, name, signature.c_str());\n  \t\treturn;\n  \t    }\n  \n  #if DO_DEBUG\n  y2debug(\"%s sig[%s] type[%s]\", name, signature.c_str(), type->toString().c_str());\n  #endif\n  #if 0\n  \t    if (type->hasFlex()\n  \t\t&& (declarations->flags & DECL_FLEX) == 0)\n  \t    {\n  \t\ty2error (\"%s:'%s' without DECL_FLEX\", name, declarations->signature);\n  \t\treturn;\n  \t    }\n  #endif\n  \t    declarations->type = type;\n  \n  \t    SymbolEntryPtr sentry = new YSymbolEntry (name, type, declarations, name_space);\n  \t    declarations->tentry = table->enter (name, sentry, new Point (sentry, 0, namespace_point));\n  \n  #ifdef BUILTIN_STATISTICS\n  \t    FILE *fout = fopen (\"/tmp/builtin-register.txt\", \"a\");\n  \t    if (fout) {\n  \t\tfprintf (fout, \"%s %s\\n\", declarations->name, declarations->signature);\n  \t\tfclose (fout);\n  \t    }\n  #endif\n  \t}\n  \tdeclarations++;\n      }\n  \n      // clear possibly old track_info\n      if (track_info != 0)\n      {\n  \tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n  \tm_active_predefined.push_back (*track_info);\n  \ttrack_info = 0;\n      }\n  \n      return;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinBoolean.h\"\n\nextern StaticDeclaration static_declarations;\n\nYCPBuiltinBoolean {\n  YCPBuiltinBoolean::YCPBuiltinBoolean ()\n  {\n      // must be static, registerDeclarations saves a pointer to it!\n      static declaration_t declarations[] = {\n  \t{ \"!\",  \"boolean (boolean)\",          (void *)b_lnot,   0,           0, 0, 0 },\n  \t{ \"||\", \"boolean (boolean, boolean)\", (void *)b_or, \tDECL_NOEVAL, 0, 0, 0 },\n  \t{ \"&&\", \"boolean (boolean, boolean)\", (void *)b_and, \tDECL_NOEVAL, 0, 0, 0 },\n  \t{ 0,    0,                            0,                0,           0, 0, 0 },\n      };\n  \n      static_declarations.registerDeclarations (\"YCPBuiltinBoolean\", declarations);\n  }\n}"
  },
  {
    "function_name": "b_and",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinBoolean.cc",
    "lines": "85-116",
    "snippet": "static YCPValue\nb_and (const YCPCode &b1, const YCPCode &b2)\n{\n    /**\n     * @operator boolean b1 && boolean b2 -> boolean\n     * Logical and for booleans.\n     *\n     * Example: <pre>\n     * false && true -> false\n     * </pre>\n     */\n     \n    YCPValue b1_v = b1->code ()->evaluate ();\n    \n    if (b1_v.isNull () || b1_v->isVoid ())\n    {\n\tycp2warning (ee.filename().c_str(), ee.linenumber(), \"First operand of '&&' evaluates to nil, using 'false' instead.\");\n\treturn YCPBoolean (false);\n    }\n\n    if (! b1_v->asBoolean ()->value ()) \n\treturn YCPBoolean (false);\n\n    YCPValue b2_v = b2->code ()->evaluate ();\n    if (b2_v.isNull () || b2_v->isVoid ())\n    {\n\tycp2warning (ee.filename().c_str(), ee.linenumber(), \"Second operand of '&&' evaluates to nil, using 'false' instead.\");\n\treturn YCPBoolean (false);\n    }\n    \n    return YCPBoolean (b2_v->asBoolean ()->value ());\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinBoolean.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ExecutionEnvironment ee;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "b2_v->asBoolean ()->value ()"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "b2_v->asBoolean",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "asBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "94-104",
          "snippet": "YCPBoolean\nYCPValueRep::asBoolean() const\n{\n    if (!isBoolean())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPBoolean\n  YCPValueRep::asBoolean() const\n  {\n      if (!isBoolean())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2warning",
          "args": [
            "ee.filename().c_str()",
            "ee.linenumber()",
            "\"Second operand of '&&' evaluates to nil, using 'false' instead.\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee.linenumber",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "linenumber",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "41-45",
          "snippet": "int\nExecutionEnvironment::linenumber () const\n{\n    return m_linenumber;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  int\n  ExecutionEnvironment::linenumber () const\n  {\n      return m_linenumber;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.filename",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "filename",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "335-339",
          "snippet": "string\nScanner::filename () const\n{\n    return m_filename;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  string\n  Scanner::filename () const\n  {\n      return m_filename;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "b2_v->isVoid",
          "args": [],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "b2_v.isNull",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b2->code",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "code",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "139-147",
          "snippet": "YCodePtr\nYSymbolEntry::code () const\n{\n    if (m_category == c_builtin || m_category == c_module)\n    {\n\treturn 0;\n    }\n    return m_code;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nYSymbolEntry {\n  YCodePtr\n  YSymbolEntry::code () const\n  {\n      if (m_category == c_builtin || m_category == c_module)\n      {\n  \treturn 0;\n      }\n      return m_code;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2warning",
          "args": [
            "ee.filename().c_str()",
            "ee.linenumber()",
            "\"First operand of '&&' evaluates to nil, using 'false' instead.\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b1_v.isNull",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinBoolean.h\"\n\nextern ExecutionEnvironment ee;\n\nstatic YCPValue\nb_and (const YCPCode &b1, const YCPCode &b2)\n{\n    /**\n     * @operator boolean b1 && boolean b2 -> boolean\n     * Logical and for booleans.\n     *\n     * Example: <pre>\n     * false && true -> false\n     * </pre>\n     */\n     \n    YCPValue b1_v = b1->code ()->evaluate ();\n    \n    if (b1_v.isNull () || b1_v->isVoid ())\n    {\n\tycp2warning (ee.filename().c_str(), ee.linenumber(), \"First operand of '&&' evaluates to nil, using 'false' instead.\");\n\treturn YCPBoolean (false);\n    }\n\n    if (! b1_v->asBoolean ()->value ()) \n\treturn YCPBoolean (false);\n\n    YCPValue b2_v = b2->code ()->evaluate ();\n    if (b2_v.isNull () || b2_v->isVoid ())\n    {\n\tycp2warning (ee.filename().c_str(), ee.linenumber(), \"Second operand of '&&' evaluates to nil, using 'false' instead.\");\n\treturn YCPBoolean (false);\n    }\n    \n    return YCPBoolean (b2_v->asBoolean ()->value ());\n}"
  },
  {
    "function_name": "b_or",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinBoolean.cc",
    "lines": "51-82",
    "snippet": "static YCPValue\nb_or (const YCPCode &b1, const YCPCode &b2)\n{\n    /**\n     * @operator boolean b1 || boolean b2 -> boolean\n     * Logical or for booleans.\n     *\n     * Example: <pre>\n     * false || true -> true\n     * </pre>\n     */\n     \n    YCPValue b1_v = b1->code ()->evaluate ();\n    \n    if (b1_v.isNull () || b1_v->isVoid ())\n    {\n\tycp2warning (ee.filename().c_str(), ee.linenumber(), \"First operand of '||' evaluates to nil, using 'false' instead.\");\n    }\n    else if (b1_v->asBoolean ()->value ())\n    {\n\treturn YCPBoolean (true);\n    }\n\n    YCPValue b2_v = b2->code ()->evaluate ();\n    if (b2_v.isNull () || b2_v->isVoid ())\n    {\n\tycp2warning (ee.filename().c_str(), ee.linenumber(), \"Second operand of '||' evaluates to nil, using 'false' instead.\");\n\treturn YCPBoolean (false);\n    }\n    \n    return YCPBoolean (b2_v->asBoolean ()->value ());\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinBoolean.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ExecutionEnvironment ee;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "b2_v->asBoolean ()->value ()"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "b2_v->asBoolean",
          "args": [],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "asBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "94-104",
          "snippet": "YCPBoolean\nYCPValueRep::asBoolean() const\n{\n    if (!isBoolean())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPBoolean\n  YCPValueRep::asBoolean() const\n  {\n      if (!isBoolean())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2warning",
          "args": [
            "ee.filename().c_str()",
            "ee.linenumber()",
            "\"Second operand of '||' evaluates to nil, using 'false' instead.\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee.linenumber",
          "args": [],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "linenumber",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "41-45",
          "snippet": "int\nExecutionEnvironment::linenumber () const\n{\n    return m_linenumber;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  int\n  ExecutionEnvironment::linenumber () const\n  {\n      return m_linenumber;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.filename",
          "args": [],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "filename",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "335-339",
          "snippet": "string\nScanner::filename () const\n{\n    return m_filename;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  string\n  Scanner::filename () const\n  {\n      return m_filename;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "b2_v->isVoid",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "b2_v.isNull",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b2->code",
          "args": [],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "code",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "139-147",
          "snippet": "YCodePtr\nYSymbolEntry::code () const\n{\n    if (m_category == c_builtin || m_category == c_module)\n    {\n\treturn 0;\n    }\n    return m_code;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nYSymbolEntry {\n  YCodePtr\n  YSymbolEntry::code () const\n  {\n      if (m_category == c_builtin || m_category == c_module)\n      {\n  \treturn 0;\n      }\n      return m_code;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2warning",
          "args": [
            "ee.filename().c_str()",
            "ee.linenumber()",
            "\"First operand of '||' evaluates to nil, using 'false' instead.\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b1_v.isNull",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinBoolean.h\"\n\nextern ExecutionEnvironment ee;\n\nstatic YCPValue\nb_or (const YCPCode &b1, const YCPCode &b2)\n{\n    /**\n     * @operator boolean b1 || boolean b2 -> boolean\n     * Logical or for booleans.\n     *\n     * Example: <pre>\n     * false || true -> true\n     * </pre>\n     */\n     \n    YCPValue b1_v = b1->code ()->evaluate ();\n    \n    if (b1_v.isNull () || b1_v->isVoid ())\n    {\n\tycp2warning (ee.filename().c_str(), ee.linenumber(), \"First operand of '||' evaluates to nil, using 'false' instead.\");\n    }\n    else if (b1_v->asBoolean ()->value ())\n    {\n\treturn YCPBoolean (true);\n    }\n\n    YCPValue b2_v = b2->code ()->evaluate ();\n    if (b2_v.isNull () || b2_v->isVoid ())\n    {\n\tycp2warning (ee.filename().c_str(), ee.linenumber(), \"Second operand of '||' evaluates to nil, using 'false' instead.\");\n\treturn YCPBoolean (false);\n    }\n    \n    return YCPBoolean (b2_v->asBoolean ()->value ());\n}"
  },
  {
    "function_name": "b_lnot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinBoolean.cc",
    "lines": "32-48",
    "snippet": "static YCPValue\nb_lnot (const YCPBoolean &b)\n{\n    /**\n     * @operator ! boolean b -> boolean\n     * Logical not for booleans.\n     *\n     * Example: <pre>\n     * !false -> true\n     * </pre>\n     */\n     \n    if (b.isNull ()) \n\treturn YCPNull ();\n\n    return YCPBoolean (!(b->value ()));\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinBoolean.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "!(b->value ())"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "b->value",
          "args": [],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "136-147",
          "snippet": "YCPValue\nSymbolEntry::value () const\n{\n    if ((m_category == c_reference)\n\t&& !m_value.isNull()\n\t&& m_value->isReference())\n    {\n\ty2debug (\"DE-REFERENCE\");\n\treturn m_value->asReference()->entry()->value();\n    }\n    return m_value;\n}",
          "includes": [
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  YCPValue\n  SymbolEntry::value () const\n  {\n      if ((m_category == c_reference)\n  \t&& !m_value.isNull()\n  \t&& m_value->isReference())\n      {\n  \ty2debug (\"DE-REFERENCE\");\n  \treturn m_value->asReference()->entry()->value();\n      }\n      return m_value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b.isNull",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinBoolean.h\"\n\nstatic YCPValue\nb_lnot (const YCPBoolean &b)\n{\n    /**\n     * @operator ! boolean b -> boolean\n     * Logical not for booleans.\n     *\n     * Example: <pre>\n     * !false -> true\n     * </pre>\n     */\n     \n    if (b.isNull ()) \n\treturn YCPNull ();\n\n    return YCPBoolean (!(b->value ()));\n}"
  }
]