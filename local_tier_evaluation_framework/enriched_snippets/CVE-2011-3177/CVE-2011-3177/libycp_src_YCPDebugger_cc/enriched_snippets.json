[
  {
    "function_name": "reset",
    "container": "YCPDebugger::Settings",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "806-811",
    "snippet": "void\nYCPDebugger::Settings::reset ()\n{\n    ignorescr = true;\n    printtoken = false;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  Settings {\n    void\n    YCPDebugger::Settings::reset ()\n    {\n        ignorescr = true;\n        printtoken = false;\n    }\n  }\n}"
  },
  {
    "function_name": "setpos",
    "container": "YCPDebugger::Position",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "798-803",
    "snippet": "void\nYCPDebugger::Position::setpos (const string &set_file, int set_line)\n{\n    file = set_file;\n    line = set_line;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  Position {\n    void\n    YCPDebugger::Position::setpos (const string &set_file, int set_line)\n    {\n        file = set_file;\n        line = set_line;\n    }\n  }\n}"
  },
  {
    "function_name": "write_prompt",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "782-795",
    "snippet": "void\nYCPDebugger::write_prompt () const\n{\n#if 0\n    char *tmp = \"y2d: \";\n    const int size = strlen (tmp);\n\n    // don't write the trailing '\\0'\n    if (write (fd, tmp, size) != size) {\n\ty2error (\"fatal error: write failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n#endif\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"fatal error: write failed: %m\""
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "tmp",
            "size"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "write_helper",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "1018-1077",
          "snippet": "int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n{\n    char * out_buffer;\n    string indent;\n    string indent2;\n    int readby = ini.getReadBy ();\n    if (!subindent.empty ())\n    {\n\tfor (int ii = 0; ii<depth - 1;ii++)\n\t    indent = indent + subindent;\n\tif (depth)\n\t    indent2 = indent + subindent;\n    }\n\n    if (ini.getComment ()[0])\n        of << ini.getComment();\n    if (readby>=0 && readby < (int)sections.size ())\n\t{\n\t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free (out_buffer);\n\t}\n    \n    IniIterator\n\tci = ini.getContainerBegin (),\n\tce = ini.getContainerEnd ();\n\n    for (;ci != ce; ++ci)\n\t{\n\t    if (ci->t () == SECTION)\n\t\t{\n\t\t    write_helper (ci->s (), of, depth + 1);\n\t\t    ci->s ().clean();\n\t\t}\n\t    else\n\t\t{\n\t\t    IniEntry&e = ci->e ();\n\t\t    if (e.getComment ()[0])\n\t\t\tof << e.getComment();\n\t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n\t\t\t// bnc#492859, a fixed buffer is too small\n\t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n\t\t\tof << indent2 << out_buffer << \"\\n\";\n\t\t\tfree(out_buffer);\n\t\t    }\n\t\t    e.clean();\n\t\t}\n\t}\n\n    if (ini.getEndComment ()[0])\n        of << indent << ini.getEndComment();\n    if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n\t{\n\t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free(out_buffer);\n\t}\n    ini.clean();\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n  {\n      char * out_buffer;\n      string indent;\n      string indent2;\n      int readby = ini.getReadBy ();\n      if (!subindent.empty ())\n      {\n  \tfor (int ii = 0; ii<depth - 1;ii++)\n  \t    indent = indent + subindent;\n  \tif (depth)\n  \t    indent2 = indent + subindent;\n      }\n  \n      if (ini.getComment ()[0])\n          of << ini.getComment();\n      if (readby>=0 && readby < (int)sections.size ())\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free (out_buffer);\n  \t}\n      \n      IniIterator\n  \tci = ini.getContainerBegin (),\n  \tce = ini.getContainerEnd ();\n  \n      for (;ci != ce; ++ci)\n  \t{\n  \t    if (ci->t () == SECTION)\n  \t\t{\n  \t\t    write_helper (ci->s (), of, depth + 1);\n  \t\t    ci->s ().clean();\n  \t\t}\n  \t    else\n  \t\t{\n  \t\t    IniEntry&e = ci->e ();\n  \t\t    if (e.getComment ()[0])\n  \t\t\tof << e.getComment();\n  \t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n  \t\t\t// bnc#492859, a fixed buffer is too small\n  \t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n  \t\t\tof << indent2 << out_buffer << \"\\n\";\n  \t\t\tfree(out_buffer);\n  \t\t    }\n  \t\t    e.clean();\n  \t\t}\n  \t}\n  \n      if (ini.getEndComment ()[0])\n          of << indent << ini.getEndComment();\n      if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free(out_buffer);\n  \t}\n      ini.clean();\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::write_prompt () const\n  {\n  #if 0\n      char *tmp = \"y2d: \";\n      const int size = strlen (tmp);\n  \n      // don't write the trailing '\\0'\n      if (write (fd, tmp, size) != size) {\n  \ty2error (\"fatal error: write failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  #endif\n  }\n}"
  },
  {
    "function_name": "write_line",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "753-779",
    "snippet": "void\nYCPDebugger::write_line (const char *format, ...) const\n{\n    char *ptr;\n\n    va_list ap;\n    va_start (ap, format);\n    const int size = vasprintf (&ptr, format, ap) + 3;\n    va_end (ap);\n\n    // replace all newlines by blanks\n    for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n\tif (*tmp == '\\n')\n\t    *tmp = ' ';\n\n    // append line ending \"\\r\\n\"\n    ptr = (char *) realloc (ptr, size);\n    strcat (ptr, \"\\r\\n\");\n\n    // don't write the trailing '\\0'\n    if (write (fd, ptr, size - 1) != size - 1) {\n\ty2error (\"fatal error: write failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n\n    free (ptr);\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ptr"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"fatal error: write failed: %m\""
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "ptr",
            "size - 1"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "write_helper",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "1018-1077",
          "snippet": "int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n{\n    char * out_buffer;\n    string indent;\n    string indent2;\n    int readby = ini.getReadBy ();\n    if (!subindent.empty ())\n    {\n\tfor (int ii = 0; ii<depth - 1;ii++)\n\t    indent = indent + subindent;\n\tif (depth)\n\t    indent2 = indent + subindent;\n    }\n\n    if (ini.getComment ()[0])\n        of << ini.getComment();\n    if (readby>=0 && readby < (int)sections.size ())\n\t{\n\t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free (out_buffer);\n\t}\n    \n    IniIterator\n\tci = ini.getContainerBegin (),\n\tce = ini.getContainerEnd ();\n\n    for (;ci != ce; ++ci)\n\t{\n\t    if (ci->t () == SECTION)\n\t\t{\n\t\t    write_helper (ci->s (), of, depth + 1);\n\t\t    ci->s ().clean();\n\t\t}\n\t    else\n\t\t{\n\t\t    IniEntry&e = ci->e ();\n\t\t    if (e.getComment ()[0])\n\t\t\tof << e.getComment();\n\t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n\t\t\t// bnc#492859, a fixed buffer is too small\n\t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n\t\t\tof << indent2 << out_buffer << \"\\n\";\n\t\t\tfree(out_buffer);\n\t\t    }\n\t\t    e.clean();\n\t\t}\n\t}\n\n    if (ini.getEndComment ()[0])\n        of << indent << ini.getEndComment();\n    if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n\t{\n\t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free(out_buffer);\n\t}\n    ini.clean();\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n  {\n      char * out_buffer;\n      string indent;\n      string indent2;\n      int readby = ini.getReadBy ();\n      if (!subindent.empty ())\n      {\n  \tfor (int ii = 0; ii<depth - 1;ii++)\n  \t    indent = indent + subindent;\n  \tif (depth)\n  \t    indent2 = indent + subindent;\n      }\n  \n      if (ini.getComment ()[0])\n          of << ini.getComment();\n      if (readby>=0 && readby < (int)sections.size ())\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free (out_buffer);\n  \t}\n      \n      IniIterator\n  \tci = ini.getContainerBegin (),\n  \tce = ini.getContainerEnd ();\n  \n      for (;ci != ce; ++ci)\n  \t{\n  \t    if (ci->t () == SECTION)\n  \t\t{\n  \t\t    write_helper (ci->s (), of, depth + 1);\n  \t\t    ci->s ().clean();\n  \t\t}\n  \t    else\n  \t\t{\n  \t\t    IniEntry&e = ci->e ();\n  \t\t    if (e.getComment ()[0])\n  \t\t\tof << e.getComment();\n  \t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n  \t\t\t// bnc#492859, a fixed buffer is too small\n  \t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n  \t\t\tof << indent2 << out_buffer << \"\\n\";\n  \t\t\tfree(out_buffer);\n  \t\t    }\n  \t\t    e.clean();\n  \t\t}\n  \t}\n  \n      if (ini.getEndComment ()[0])\n          of << indent << ini.getEndComment();\n      if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free(out_buffer);\n  \t}\n      ini.clean();\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "ptr",
            "\"\\r\\n\""
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "ptr",
            "size"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vasprintf",
          "args": [
            "&ptr",
            "format",
            "ap"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "format"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::write_line (const char *format, ...) const\n  {\n      char *ptr;\n  \n      va_list ap;\n      va_start (ap, format);\n      const int size = vasprintf (&ptr, format, ap) + 3;\n      va_end (ap);\n  \n      // replace all newlines by blanks\n      for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n  \tif (*tmp == '\\n')\n  \t    *tmp = ' ';\n  \n      // append line ending \"\\r\\n\"\n      ptr = (char *) realloc (ptr, size);\n      strcat (ptr, \"\\r\\n\");\n  \n      // don't write the trailing '\\0'\n      if (write (fd, ptr, size - 1) != size - 1) {\n  \ty2error (\"fatal error: write failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      free (ptr);\n  }\n}"
  },
  {
    "function_name": "read_line",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "707-750",
    "snippet": "string\nYCPDebugger::read_line (bool block) const\n{\n    const int maxmsg = 512;\n    char buffer[maxmsg + 1];\n\n    fd_set read_fd_set;\n    FD_ZERO (&read_fd_set);\n    FD_SET (fd, &read_fd_set);\n\n    struct timeval timeout;\n    timeout.tv_sec = block ? 604800 : 0;\n    timeout.tv_usec = 0;\n\n    int res;\n    do {\n\tres = select (FD_SETSIZE, &read_fd_set, NULL, NULL, &timeout);\n    } while (res == -1 && errno == EINTR);\n\n    // Test for timeout.\n    if (res == 0)\n\treturn \"\";\n\n    int nbytes = read (fd, buffer, maxmsg);\n\n    // Read error.\n    if (nbytes < 0) {\n\ty2error (\"error: read failed: %m\");\n\treturn \"\";\n    }\n\n    // End of file.\n    if (nbytes == 0) {\n\treturn \"\"; // ???\n    }\n\n    // append '\\0'\n    buffer[nbytes] = '\\0';\n\n    while (buffer[nbytes - 1] == '\\n' || buffer[nbytes - 1] == '\\r')\n\tbuffer[--nbytes] = '\\0';\n\n    return buffer;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"error: read failed: %m\""
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buffer",
            "maxmsg"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "read_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2crypt.cc",
          "lines": "25-50",
          "snippet": "static int\nread_loop (int fd, char* buffer, int count)\n{\n    int offset, block;\n\n    offset = 0;\n    while (count > 0)\n    {\n\tblock = read (fd, &buffer[offset], count);\n\n\tif (block < 0)\n\t{\n\t    if (errno == EINTR)\n\t\tcontinue;\n\t    return block;\n\t}\n\n\tif (!block)\n\t    return offset;\n\n\toffset += block;\n\tcount -= block;\n    }\n\n    return offset;\n}",
          "includes": [
            "#include \"y2crypt.h\"",
            "#include \"y2log.h\"",
            "#include <xcrypt.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2crypt.h\"\n#include \"y2log.h\"\n#include <xcrypt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int\nread_loop (int fd, char* buffer, int count)\n{\n    int offset, block;\n\n    offset = 0;\n    while (count > 0)\n    {\n\tblock = read (fd, &buffer[offset], count);\n\n\tif (block < 0)\n\t{\n\t    if (errno == EINTR)\n\t\tcontinue;\n\t    return block;\n\t}\n\n\tif (!block)\n\t    return offset;\n\n\toffset += block;\n\tcount -= block;\n    }\n\n    return offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "FD_SETSIZE",
            "&read_fd_set",
            "NULL",
            "NULL",
            "&timeout"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "fd",
            "&read_fd_set"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&read_fd_set"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  string\n  YCPDebugger::read_line (bool block) const\n  {\n      const int maxmsg = 512;\n      char buffer[maxmsg + 1];\n  \n      fd_set read_fd_set;\n      FD_ZERO (&read_fd_set);\n      FD_SET (fd, &read_fd_set);\n  \n      struct timeval timeout;\n      timeout.tv_sec = block ? 604800 : 0;\n      timeout.tv_usec = 0;\n  \n      int res;\n      do {\n  \tres = select (FD_SETSIZE, &read_fd_set, NULL, NULL, &timeout);\n      } while (res == -1 && errno == EINTR);\n  \n      // Test for timeout.\n      if (res == 0)\n  \treturn \"\";\n  \n      int nbytes = read (fd, buffer, maxmsg);\n  \n      // Read error.\n      if (nbytes < 0) {\n  \ty2error (\"error: read failed: %m\");\n  \treturn \"\";\n      }\n  \n      // End of file.\n      if (nbytes == 0) {\n  \treturn \"\"; // ???\n      }\n  \n      // append '\\0'\n      buffer[nbytes] = '\\0';\n  \n      while (buffer[nbytes - 1] == '\\n' || buffer[nbytes - 1] == '\\r')\n  \tbuffer[--nbytes] = '\\0';\n  \n      return buffer;\n  }\n}"
  },
  {
    "function_name": "check_socket",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "659-704",
    "snippet": "void\nYCPDebugger::check_socket (bool block)\n{\n    fd_set read_fd_set;\n    FD_ZERO (&read_fd_set);\n    FD_SET (sock, &read_fd_set);\n\n    struct timeval timeout;\n    timeout.tv_sec = block ? 604800 : 0;\n    timeout.tv_usec = 0;\n\n    int res;\n    do {\n\tres = select (FD_SETSIZE, &read_fd_set, NULL, NULL, &timeout);\n    } while (res == -1 && errno == EINTR);\n\n    if (res < 0) {\n\ty2error (\"fatal error: select failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n\n    // Test for timeout.\n    if (res == 0)\n\treturn;\n\n    // Connection request on original socket.\n    struct sockaddr_in clientname;\n    socklen_t size = sizeof (sockaddr_in);\n    int status = accept (sock, (struct sockaddr *) &clientname, &size);\n    if (status < 0) {\n\ty2error (\"fatal error: accept failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n\n    y2debug (\"connect from host %s\", inet_ntoa (clientname.sin_addr));\n\n    if (fd != -1) {\n\tclose (status);\n\ty2debug (\"but we already have a dubugger attached\");\n\treturn;\n    }\n\n    fd = status;\n\n    write_line (\"Welcome to the YCP debugger.\");\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"Welcome to the YCP debugger.\""
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "write_line",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "753-779",
          "snippet": "void\nYCPDebugger::write_line (const char *format, ...) const\n{\n    char *ptr;\n\n    va_list ap;\n    va_start (ap, format);\n    const int size = vasprintf (&ptr, format, ap) + 3;\n    va_end (ap);\n\n    // replace all newlines by blanks\n    for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n\tif (*tmp == '\\n')\n\t    *tmp = ' ';\n\n    // append line ending \"\\r\\n\"\n    ptr = (char *) realloc (ptr, size);\n    strcat (ptr, \"\\r\\n\");\n\n    // don't write the trailing '\\0'\n    if (write (fd, ptr, size - 1) != size - 1) {\n\ty2error (\"fatal error: write failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n\n    free (ptr);\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::write_line (const char *format, ...) const\n  {\n      char *ptr;\n  \n      va_list ap;\n      va_start (ap, format);\n      const int size = vasprintf (&ptr, format, ap) + 3;\n      va_end (ap);\n  \n      // replace all newlines by blanks\n      for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n  \tif (*tmp == '\\n')\n  \t    *tmp = ' ';\n  \n      // append line ending \"\\r\\n\"\n      ptr = (char *) realloc (ptr, size);\n      strcat (ptr, \"\\r\\n\");\n  \n      // don't write the trailing '\\0'\n      if (write (fd, ptr, size - 1) != size - 1) {\n  \ty2error (\"fatal error: write failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      free (ptr);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"but we already have a dubugger attached\""
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "status"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"connect from host %s\"",
            "inet_ntoa (clientname.sin_addr)"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntoa",
          "args": [
            "clientname.sin_addr"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"fatal error: accept failed: %m\""
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "sock",
            "(struct sockaddr *) &clientname",
            "&size"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"fatal error: select failed: %m\""
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "FD_SETSIZE",
            "&read_fd_set",
            "NULL",
            "NULL",
            "&timeout"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "sock",
            "&read_fd_set"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&read_fd_set"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::check_socket (bool block)\n  {\n      fd_set read_fd_set;\n      FD_ZERO (&read_fd_set);\n      FD_SET (sock, &read_fd_set);\n  \n      struct timeval timeout;\n      timeout.tv_sec = block ? 604800 : 0;\n      timeout.tv_usec = 0;\n  \n      int res;\n      do {\n  \tres = select (FD_SETSIZE, &read_fd_set, NULL, NULL, &timeout);\n      } while (res == -1 && errno == EINTR);\n  \n      if (res < 0) {\n  \ty2error (\"fatal error: select failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      // Test for timeout.\n      if (res == 0)\n  \treturn;\n  \n      // Connection request on original socket.\n      struct sockaddr_in clientname;\n      socklen_t size = sizeof (sockaddr_in);\n      int status = accept (sock, (struct sockaddr *) &clientname, &size);\n      if (status < 0) {\n  \ty2error (\"fatal error: accept failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      y2debug (\"connect from host %s\", inet_ntoa (clientname.sin_addr));\n  \n      if (fd != -1) {\n  \tclose (status);\n  \ty2debug (\"but we already have a dubugger attached\");\n  \treturn;\n      }\n  \n      fd = status;\n  \n      write_line (\"Welcome to the YCP debugger.\");\n  }\n}"
  },
  {
    "function_name": "create_socket",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "629-656",
    "snippet": "void\nYCPDebugger::create_socket ()\n{\n    // Create the socket.\n    sock = socket (PF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n\ty2error (\"fatal error: socket failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n\n    // Give the socket a name.\n    struct sockaddr_in name;\n    name.sin_family = AF_INET;\n    name.sin_port = htons (19473);\n    name.sin_addr.s_addr = htonl (INADDR_ANY);\n    if (bind (sock, (struct sockaddr *) &name,\n\t      sizeof (struct sockaddr_in)) < 0) {\n\ty2error (\"fatal error: bind failed: %m\");\n\tfprintf (stderr, \"fatal error: bind failed: %m\\n\");\n\texit (EXIT_FAILURE);\n    }\n\n    // Listen on socket.\n    if (listen (sock, 1) < 0) {\n\ty2error (\"fatal error: listen failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"fatal error: listen failed: %m\""
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "sock",
            "1"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"fatal error: bind failed: %m\\n\""
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"fatal error: bind failed: %m\""
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "sock",
            "(struct sockaddr *) &name",
            "sizeof (struct sockaddr_in)"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_ANY"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "19473"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"fatal error: socket failed: %m\""
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_INET",
            "SOCK_STREAM",
            "0"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::create_socket ()\n  {\n      // Create the socket.\n      sock = socket (PF_INET, SOCK_STREAM, 0);\n      if (sock < 0) {\n  \ty2error (\"fatal error: socket failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      // Give the socket a name.\n      struct sockaddr_in name;\n      name.sin_family = AF_INET;\n      name.sin_port = htons (19473);\n      name.sin_addr.s_addr = htonl (INADDR_ANY);\n      if (bind (sock, (struct sockaddr *) &name,\n  \t      sizeof (struct sockaddr_in)) < 0) {\n  \ty2error (\"fatal error: bind failed: %m\");\n  \tfprintf (stderr, \"fatal error: bind failed: %m\\n\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      // Listen on socket.\n      if (listen (sock, 1) < 0) {\n  \ty2error (\"fatal error: listen failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  }\n}"
  },
  {
    "function_name": "list_source",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "607-626",
    "snippet": "void\nYCPDebugger::list_source (const char * filename)\n{\n    const int size = 250;\n    char buffer[size];\n\n    FILE * fin = fopen (filename, \"r\");\n    if (!fin) {\n\ty2debug (\"can't open %s\", filename);\n\twrite_line (\"error reading source file\");\n\treturn;\n    }\n\n    write_line (\"BEGIN SOURCE\");\n    while (fgets (buffer, size, fin)) {\n\tbuffer[strlen (buffer) - 1] = '\\0';\n\twrite_line (\"%s\", buffer);\n    }\n    write_line (\"END SOURCE\");\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"END SOURCE\""
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "write_line",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "753-779",
          "snippet": "void\nYCPDebugger::write_line (const char *format, ...) const\n{\n    char *ptr;\n\n    va_list ap;\n    va_start (ap, format);\n    const int size = vasprintf (&ptr, format, ap) + 3;\n    va_end (ap);\n\n    // replace all newlines by blanks\n    for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n\tif (*tmp == '\\n')\n\t    *tmp = ' ';\n\n    // append line ending \"\\r\\n\"\n    ptr = (char *) realloc (ptr, size);\n    strcat (ptr, \"\\r\\n\");\n\n    // don't write the trailing '\\0'\n    if (write (fd, ptr, size - 1) != size - 1) {\n\ty2error (\"fatal error: write failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n\n    free (ptr);\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::write_line (const char *format, ...) const\n  {\n      char *ptr;\n  \n      va_list ap;\n      va_start (ap, format);\n      const int size = vasprintf (&ptr, format, ap) + 3;\n      va_end (ap);\n  \n      // replace all newlines by blanks\n      for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n  \tif (*tmp == '\\n')\n  \t    *tmp = ' ';\n  \n      // append line ending \"\\r\\n\"\n      ptr = (char *) realloc (ptr, size);\n      strcat (ptr, \"\\r\\n\");\n  \n      // don't write the trailing '\\0'\n      if (write (fd, ptr, size - 1) != size - 1) {\n  \ty2error (\"fatal error: write failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      free (ptr);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"%s\"",
            "buffer"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buffer",
            "size",
            "fin"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"can't open %s\"",
            "filename"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "filename",
            "\"r\""
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::list_source (const char * filename)\n  {\n      const int size = 250;\n      char buffer[size];\n  \n      FILE * fin = fopen (filename, \"r\");\n      if (!fin) {\n  \ty2debug (\"can't open %s\", filename);\n  \twrite_line (\"error reading source file\");\n  \treturn;\n      }\n  \n      write_line (\"BEGIN SOURCE\");\n      while (fgets (buffer, size, fin)) {\n  \tbuffer[strlen (buffer) - 1] = '\\0';\n  \twrite_line (\"%s\", buffer);\n      }\n      write_line (\"END SOURCE\");\n  }\n}"
  },
  {
    "function_name": "list_breakpoints",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "595-604",
    "snippet": "void\nYCPDebugger::list_breakpoints ()\n{\n    write_line (\"BEGIN BREAKPOINTS\");\n    for (vector <Breakpoint>::iterator cur = breakpoints.begin ();\n\t cur != breakpoints.end (); cur++)\n\twrite_line (\"%s %d\", (*cur).file.c_str (),\n\t\t    (*cur).line);\n    write_line (\"END BREAKPOINTS\");\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"END BREAKPOINTS\""
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "write_line",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "753-779",
          "snippet": "void\nYCPDebugger::write_line (const char *format, ...) const\n{\n    char *ptr;\n\n    va_list ap;\n    va_start (ap, format);\n    const int size = vasprintf (&ptr, format, ap) + 3;\n    va_end (ap);\n\n    // replace all newlines by blanks\n    for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n\tif (*tmp == '\\n')\n\t    *tmp = ' ';\n\n    // append line ending \"\\r\\n\"\n    ptr = (char *) realloc (ptr, size);\n    strcat (ptr, \"\\r\\n\");\n\n    // don't write the trailing '\\0'\n    if (write (fd, ptr, size - 1) != size - 1) {\n\ty2error (\"fatal error: write failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n\n    free (ptr);\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::write_line (const char *format, ...) const\n  {\n      char *ptr;\n  \n      va_list ap;\n      va_start (ap, format);\n      const int size = vasprintf (&ptr, format, ap) + 3;\n      va_end (ap);\n  \n      // replace all newlines by blanks\n      for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n  \tif (*tmp == '\\n')\n  \t    *tmp = ' ';\n  \n      // append line ending \"\\r\\n\"\n      ptr = (char *) realloc (ptr, size);\n      strcat (ptr, \"\\r\\n\");\n  \n      // don't write the trailing '\\0'\n      if (write (fd, ptr, size - 1) != size - 1) {\n  \ty2error (\"fatal error: write failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      free (ptr);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"%s %d\"",
            "(*cur).file.c_str ()",
            "(*cur).line"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "breakpoints.end",
          "args": [],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "breakpoints.begin",
          "args": [],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::list_breakpoints ()\n  {\n      write_line (\"BEGIN BREAKPOINTS\");\n      for (vector <Breakpoint>::iterator cur = breakpoints.begin ();\n  \t cur != breakpoints.end (); cur++)\n  \twrite_line (\"%s %d\", (*cur).file.c_str (),\n  \t\t    (*cur).line);\n      write_line (\"END BREAKPOINTS\");\n  }\n}"
  },
  {
    "function_name": "check_breakpoints",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "582-592",
    "snippet": "bool\nYCPDebugger::check_breakpoints (const string &check_file, int check_line)\n{\n    for (vector <Breakpoint>::iterator cur = breakpoints.begin ();\n\t cur != breakpoints.end (); cur++)\n\tif (!(*cur).tmpinactive && (check_line == (*cur).line) &&\n\t    (check_file == (*cur).file))\n\t    return true;\n\n    return false;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "breakpoints.end",
          "args": [],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "breakpoints.begin",
          "args": [],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  bool\n  YCPDebugger::check_breakpoints (const string &check_file, int check_line)\n  {\n      for (vector <Breakpoint>::iterator cur = breakpoints.begin ();\n  \t cur != breakpoints.end (); cur++)\n  \tif (!(*cur).tmpinactive && (check_line == (*cur).line) &&\n  \t    (check_file == (*cur).file))\n  \t    return true;\n  \n      return false;\n  }\n}"
  },
  {
    "function_name": "delete_breakpoint",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "568-579",
    "snippet": "bool\nYCPDebugger::delete_breakpoint (const string &delete_file, int delete_line)\n{\n    for (vector <Breakpoint>::iterator cur = breakpoints.begin ();\n\t cur != breakpoints.end (); cur++)\n\tif ((delete_line == (*cur).line) && (delete_file == (*cur).file)) {\n\t    breakpoints.erase (cur);\n\t    return true;\n\t}\n\n    return false;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "breakpoints.erase",
          "args": [
            "cur"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "683-695",
          "snippet": "int PathInfo::erase( const Pathname & path )\n{\n  int res = 0;\n  PathInfo p( path, LSTAT );\n  if ( p.isExist() )\n    {\n      if ( p.isDir() )\n        res = PathInfo::recursive_rmdir( path );\n      else\n        res = PathInfo::unlink( path );\n    }\n  return res;\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::erase( const Pathname & path )\n  {\n    int res = 0;\n    PathInfo p( path, LSTAT );\n    if ( p.isExist() )\n      {\n        if ( p.isDir() )\n          res = PathInfo::recursive_rmdir( path );\n        else\n          res = PathInfo::unlink( path );\n      }\n    return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "breakpoints.end",
          "args": [],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "breakpoints.begin",
          "args": [],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  bool\n  YCPDebugger::delete_breakpoint (const string &delete_file, int delete_line)\n  {\n      for (vector <Breakpoint>::iterator cur = breakpoints.begin ();\n  \t cur != breakpoints.end (); cur++)\n  \tif ((delete_line == (*cur).line) && (delete_file == (*cur).file)) {\n  \t    breakpoints.erase (cur);\n  \t    return true;\n  \t}\n  \n      return false;\n  }\n}"
  },
  {
    "function_name": "add_breakpoint",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "558-565",
    "snippet": "void\nYCPDebugger::add_breakpoint (const string &add_file, int add_line)\n{\n    Breakpoint tmp;\n    tmp.setpos (add_file, add_line);\n    tmp.tmpinactive = false;\n    breakpoints.push_back (tmp);\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "breakpoints.push_back",
          "args": [
            "tmp"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmp.setpos",
          "args": [
            "add_file",
            "add_line"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "setpos",
          "container": "YCPDebugger::Position",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "798-803",
          "snippet": "void\nYCPDebugger::Position::setpos (const string &set_file, int set_line)\n{\n    file = set_file;\n    line = set_line;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  Position {\n    void\n    YCPDebugger::Position::setpos (const string &set_file, int set_line)\n    {\n        file = set_file;\n        line = set_line;\n    }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::add_breakpoint (const string &add_file, int add_line)\n  {\n      Breakpoint tmp;\n      tmp.setpos (add_file, add_line);\n      tmp.tmpinactive = false;\n      breakpoints.push_back (tmp);\n  }\n}"
  },
  {
    "function_name": "list_interpreters",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "521-530",
    "snippet": "void\nYCPDebugger::list_interpreters ()\n{\n    write_line (\"BEGIN INTERPRETERS\");\n    for (vector <Interpreter>::iterator cur = interpreters.begin ();\n\t cur != interpreters.end (); cur++)\n\twrite_line (\"#%d %s\", (*cur).unique_id,\n\t\t    (*cur).interpreter->interpreter_name ().c_str ());\n    write_line (\"END INTERPRETERS\");\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"END INTERPRETERS\""
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "write_line",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "753-779",
          "snippet": "void\nYCPDebugger::write_line (const char *format, ...) const\n{\n    char *ptr;\n\n    va_list ap;\n    va_start (ap, format);\n    const int size = vasprintf (&ptr, format, ap) + 3;\n    va_end (ap);\n\n    // replace all newlines by blanks\n    for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n\tif (*tmp == '\\n')\n\t    *tmp = ' ';\n\n    // append line ending \"\\r\\n\"\n    ptr = (char *) realloc (ptr, size);\n    strcat (ptr, \"\\r\\n\");\n\n    // don't write the trailing '\\0'\n    if (write (fd, ptr, size - 1) != size - 1) {\n\ty2error (\"fatal error: write failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n\n    free (ptr);\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::write_line (const char *format, ...) const\n  {\n      char *ptr;\n  \n      va_list ap;\n      va_start (ap, format);\n      const int size = vasprintf (&ptr, format, ap) + 3;\n      va_end (ap);\n  \n      // replace all newlines by blanks\n      for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n  \tif (*tmp == '\\n')\n  \t    *tmp = ' ';\n  \n      // append line ending \"\\r\\n\"\n      ptr = (char *) realloc (ptr, size);\n      strcat (ptr, \"\\r\\n\");\n  \n      // don't write the trailing '\\0'\n      if (write (fd, ptr, size - 1) != size - 1) {\n  \ty2error (\"fatal error: write failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      free (ptr);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"#%d %s\"",
            "(*cur).unique_id",
            "(*cur).interpreter->interpreter_name ().c_str ()"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interpreters.end",
          "args": [],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "interpreters.begin",
          "args": [],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::list_interpreters ()\n  {\n      write_line (\"BEGIN INTERPRETERS\");\n      for (vector <Interpreter>::iterator cur = interpreters.begin ();\n  \t cur != interpreters.end (); cur++)\n  \twrite_line (\"#%d %s\", (*cur).unique_id,\n  \t\t    (*cur).interpreter->interpreter_name ().c_str ());\n      write_line (\"END INTERPRETERS\");\n  }\n}"
  },
  {
    "function_name": "number_of_interpreters",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "514-518",
    "snippet": "int\nYCPDebugger::number_of_interpreters () const\n{\n    return interpreters.size ();\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "interpreters.size",
          "args": [],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  int\n  YCPDebugger::number_of_interpreters () const\n  {\n      return interpreters.size ();\n  }\n}"
  },
  {
    "function_name": "delete_interpreter",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "499-511",
    "snippet": "void\nYCPDebugger::delete_interpreter (YCPInterpreter *inter)\n{\n    for (vector <Interpreter>::iterator cur = interpreters.begin ();\n\t cur != interpreters.end (); cur++)\n\tif ((*cur).interpreter == inter) {\n\t    interpreters.erase (cur);\n\t    return;\n\t}\n\n    y2error (\"fatal error: unknown interpreter\");\n    abort ();\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"fatal error: unknown interpreter\""
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interpreters.erase",
          "args": [
            "cur"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "683-695",
          "snippet": "int PathInfo::erase( const Pathname & path )\n{\n  int res = 0;\n  PathInfo p( path, LSTAT );\n  if ( p.isExist() )\n    {\n      if ( p.isDir() )\n        res = PathInfo::recursive_rmdir( path );\n      else\n        res = PathInfo::unlink( path );\n    }\n  return res;\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::erase( const Pathname & path )\n  {\n    int res = 0;\n    PathInfo p( path, LSTAT );\n    if ( p.isExist() )\n      {\n        if ( p.isDir() )\n          res = PathInfo::recursive_rmdir( path );\n        else\n          res = PathInfo::unlink( path );\n      }\n    return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "interpreters.end",
          "args": [],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "interpreters.begin",
          "args": [],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::delete_interpreter (YCPInterpreter *inter)\n  {\n      for (vector <Interpreter>::iterator cur = interpreters.begin ();\n  \t cur != interpreters.end (); cur++)\n  \tif ((*cur).interpreter == inter) {\n  \t    interpreters.erase (cur);\n  \t    return;\n  \t}\n  \n      y2error (\"fatal error: unknown interpreter\");\n      abort ();\n  }\n}"
  },
  {
    "function_name": "add_interpreter",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "489-496",
    "snippet": "void\nYCPDebugger::add_interpreter (YCPInterpreter *inter)\n{\n    Interpreter tmp;\n    tmp.interpreter = inter;\n    tmp.unique_id = unique_id_cnt++;\n    interpreters.push_back (tmp);\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "interpreters.push_back",
          "args": [
            "tmp"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::add_interpreter (YCPInterpreter *inter)\n  {\n      Interpreter tmp;\n      tmp.interpreter = inter;\n      tmp.unique_id = unique_id_cnt++;\n      interpreters.push_back (tmp);\n  }\n}"
  },
  {
    "function_name": "print_scope",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "453-486",
    "snippet": "void\nYCPDebugger::print_scope (Interpreter *inter)\n{\n    YCPScopeInstance::YCPScopeInstance *instance = inter->interpreter->scopeTop;\n\n    write_line (\"BEGIN SCOPE\");\n\n    while (instance && instance->container)\n    {\n\tYCPScopeInstance::YCPScopeContainer::const_iterator var;\n\n\tfor (var = instance->container->begin ();\n\t     var != instance->container->end (); var++)\n\t{\n\t    YCPDeclaration decl = var->second->get_type ();\n\n\t    // truncate length of variable\n\t    const int size = 60;\n\t    char buffer[size];\n\t    snprintf (buffer, size, \"%s\", var->second->get_value ()->\n\t\t      toString ().c_str ());\n\n\t    write_line (\"%d %s %s = %s\", instance->level,\n\t\t\tdecl->toString ().c_str (),\n\t\t\tdecl->isDeclTerm () ? \"\" : var->first.c_str (),\n\t\t\tbuffer);\n\n\t}\n\n\tinstance = instance->outer;\n    }\n\n    write_line (\"END SCOPE\");\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"END SCOPE\""
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "write_line",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "753-779",
          "snippet": "void\nYCPDebugger::write_line (const char *format, ...) const\n{\n    char *ptr;\n\n    va_list ap;\n    va_start (ap, format);\n    const int size = vasprintf (&ptr, format, ap) + 3;\n    va_end (ap);\n\n    // replace all newlines by blanks\n    for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n\tif (*tmp == '\\n')\n\t    *tmp = ' ';\n\n    // append line ending \"\\r\\n\"\n    ptr = (char *) realloc (ptr, size);\n    strcat (ptr, \"\\r\\n\");\n\n    // don't write the trailing '\\0'\n    if (write (fd, ptr, size - 1) != size - 1) {\n\ty2error (\"fatal error: write failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n\n    free (ptr);\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::write_line (const char *format, ...) const\n  {\n      char *ptr;\n  \n      va_list ap;\n      va_start (ap, format);\n      const int size = vasprintf (&ptr, format, ap) + 3;\n      va_end (ap);\n  \n      // replace all newlines by blanks\n      for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n  \tif (*tmp == '\\n')\n  \t    *tmp = ' ';\n  \n      // append line ending \"\\r\\n\"\n      ptr = (char *) realloc (ptr, size);\n      strcat (ptr, \"\\r\\n\");\n  \n      // don't write the trailing '\\0'\n      if (write (fd, ptr, size - 1) != size - 1) {\n  \ty2error (\"fatal error: write failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      free (ptr);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"%d %s %s = %s\"",
            "instance->level",
            "decl->toString ().c_str ()",
            "decl->isDeclTerm () ? \"\" : var->first.c_str ()",
            "buffer"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "var->first.c_str",
          "args": [],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl->isDeclTerm",
          "args": [],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl->toString",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "size",
            "\"%s\"",
            "var->second->get_value ()->\n\t\t      toString ().c_str ()"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "var->second->get_value",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "var->second->get_value",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "var->second->get_value",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "var->second->get_type",
          "args": [],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instance->container->end",
          "args": [],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "instance->container->begin",
          "args": [],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::print_scope (Interpreter *inter)\n  {\n      YCPScopeInstance::YCPScopeInstance *instance = inter->interpreter->scopeTop;\n  \n      write_line (\"BEGIN SCOPE\");\n  \n      while (instance && instance->container)\n      {\n  \tYCPScopeInstance::YCPScopeContainer::const_iterator var;\n  \n  \tfor (var = instance->container->begin ();\n  \t     var != instance->container->end (); var++)\n  \t{\n  \t    YCPDeclaration decl = var->second->get_type ();\n  \n  \t    // truncate length of variable\n  \t    const int size = 60;\n  \t    char buffer[size];\n  \t    snprintf (buffer, size, \"%s\", var->second->get_value ()->\n  \t\t      toString ().c_str ());\n  \n  \t    write_line (\"%d %s %s = %s\", instance->level,\n  \t\t\tdecl->toString ().c_str (),\n  \t\t\tdecl->isDeclTerm () ? \"\" : var->first.c_str (),\n  \t\t\tbuffer);\n  \n  \t}\n  \n  \tinstance = instance->outer;\n      }\n  \n      write_line (\"END SCOPE\");\n  }\n}"
  },
  {
    "function_name": "print_variable",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "430-450",
    "snippet": "bool\nYCPDebugger::print_variable (Interpreter *inter, const string &name)\n{\n    YCPScopeInstance::YCPScopeInstance *instance = inter->interpreter->scopeTop;\n\n    if (!instance) {\n\twrite_line (\"variable not found\");\n\treturn false;\n    }\n\n    YCPValue value = instance->lookupValue (name);\n    if (value.isNull ()) {\n\twrite_line (\"variable not found\");\n\treturn false;\n    }\n\n    write_line (\"BEGIN VARIABLE\");\n    write_line (\"%s\", value->toString ().c_str ());\n    write_line (\"END VARIABLE\");\n    return true;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"END VARIABLE\""
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "write_line",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "753-779",
          "snippet": "void\nYCPDebugger::write_line (const char *format, ...) const\n{\n    char *ptr;\n\n    va_list ap;\n    va_start (ap, format);\n    const int size = vasprintf (&ptr, format, ap) + 3;\n    va_end (ap);\n\n    // replace all newlines by blanks\n    for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n\tif (*tmp == '\\n')\n\t    *tmp = ' ';\n\n    // append line ending \"\\r\\n\"\n    ptr = (char *) realloc (ptr, size);\n    strcat (ptr, \"\\r\\n\");\n\n    // don't write the trailing '\\0'\n    if (write (fd, ptr, size - 1) != size - 1) {\n\ty2error (\"fatal error: write failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n\n    free (ptr);\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::write_line (const char *format, ...) const\n  {\n      char *ptr;\n  \n      va_list ap;\n      va_start (ap, format);\n      const int size = vasprintf (&ptr, format, ap) + 3;\n      va_end (ap);\n  \n      // replace all newlines by blanks\n      for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n  \tif (*tmp == '\\n')\n  \t    *tmp = ' ';\n  \n      // append line ending \"\\r\\n\"\n      ptr = (char *) realloc (ptr, size);\n      strcat (ptr, \"\\r\\n\");\n  \n      // don't write the trailing '\\0'\n      if (write (fd, ptr, size - 1) != size - 1) {\n  \ty2error (\"fatal error: write failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      free (ptr);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"%s\"",
            "value->toString ().c_str ()"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instance->lookupValue",
          "args": [
            "name"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  bool\n  YCPDebugger::print_variable (Interpreter *inter, const string &name)\n  {\n      YCPScopeInstance::YCPScopeInstance *instance = inter->interpreter->scopeTop;\n  \n      if (!instance) {\n  \twrite_line (\"variable not found\");\n  \treturn false;\n      }\n  \n      YCPValue value = instance->lookupValue (name);\n      if (value.isNull ()) {\n  \twrite_line (\"variable not found\");\n  \treturn false;\n      }\n  \n      write_line (\"BEGIN VARIABLE\");\n      write_line (\"%s\", value->toString ().c_str ());\n      write_line (\"END VARIABLE\");\n      return true;\n  }\n}"
  },
  {
    "function_name": "handle_command",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "305-427",
    "snippet": "bool\nYCPDebugger::handle_command (Interpreter *inter, const string &command,\n\t\t\t     const YCPElement &element)\n{\n    string args[5];\n    int nargs = split (command, 5, args, \" \\t\");\n\n    if (nargs == 1 && args[0] == \"interrupt\") {\n\treturn false;\n    }\n\n    if (nargs == 1 && args[0] == \"continue\") {\n\treturn true;\n    }\n\n    if (nargs == 1 && args[0] == \"single\") {\n\tsingle_mode = true;\n\treturn true;\n    }\n\n    if (nargs == 1 && args[0] == \"step\") {\n\tleave_position.setpos (inter->interpreter->current_file,\n\t\t\t       inter->interpreter->current_line);\n\treturn true;\n    }\n\n    if (nargs == 1 && args[0] == \"next\") {\n\thold_level = inter->interpreter->scopeLevel;\n\treturn true;\n    }\n\n    if (nargs == 1 && args[0] == \"up\") {\n\thold_level = inter->interpreter->scopeLevel - 1;\n\treturn true;\n    }\n\n    if (nargs == 1 && args[0] == \"detach\") {\n\tclose_request = true;\n\treturn true;\n    }\n\n    if (nargs == 2 && (args[0] == \"set\" || args[0] == \"unset\")) {\n\tbool tmp = args[0] == \"set\";\n\tif (args[1] == \"ignorescr\") {\n\t    settings.ignorescr = tmp;\n\t    return false;\n\t}\n\tif (args[1] == \"printtoken\") {\n\t    settings.printtoken = tmp;\n\t    return false;\n\t}\n    }\n\n    if (nargs == 1 && args[0] == \"token\") {\n\twrite_line (\"BEGIN TOKEN\");\n\twrite_line (\"%s\", element->toString ().c_str ());\n\twrite_line (\"END TOKEN\");\n\treturn false;\n    }\n\n    if (nargs == 1 && args[0] == \"scope\") {\n\tprint_scope (inter);\n\treturn false;\n    }\n\n    if (nargs == 2 && args[0] == \"scope\" && args[1][0] == '#') {\n\tint unique_id = atoi (args[1].substr (1).c_str ());\n\tInterpreter * tmp = find_inter (unique_id);\n\tif (tmp)\n\t    print_scope (tmp);\n\telse\n\t    write_line (\"unknown interpreter\");\n\treturn false;\n    }\n\n    if (nargs == 2 && args[0] == \"print\") {\n\tprint_variable (inter, args[1]);\n\treturn false;\n    }\n\n    if (nargs == 3 && args[0] == \"print\" && args[1][0] == '#') {\n\tint unique_id = atoi (args[1].substr (1).c_str ());\n\tInterpreter * tmp = find_inter (unique_id);\n\tif (tmp)\n\t    print_variable (tmp, args[2]);\n\telse\n\t    write_line (\"unknown interpreter\");\n\treturn false;\n    }\n\n    if (nargs == 2 && args[0] == \"list\") {\n\tif (args[1] == \"breakpoints\") {\n\t    list_breakpoints ();\n\t    return false;\n\t}\n\tif (args[1] == \"interpreters\") {\n\t    list_interpreters ();\n\t    return false;\n\t}\n\tif (args[1] == \"source\") {\n\t    list_source (inter->interpreter->current_file.c_str ());\n\t    return false;\n\t}\n    }\n\n    if (nargs == 3 && args[0] == \"break\") {\n\tadd_breakpoint (args[1], strtol (args[2].c_str (), NULL, 10));\n\tlist_breakpoints ();\n\treturn false;\n    }\n\n    if (nargs == 3 && args[0] == \"clear\") {\n\tif (delete_breakpoint (args[1], strtol (args[2].c_str (), NULL, 10))) {\n\t    list_breakpoints ();\n\t    return false;\n\t}\n\twrite_line (\"breakpoint not found\");\n\treturn false;\n    }\n\n    write_line (\"wrong command \\\"%s\\\"\", command.c_str ());\n    return false;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"wrong command \\\"%s\\\"\"",
            "command.c_str ()"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command.c_str",
          "args": [],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"breakpoint not found\""
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "write_line",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "753-779",
          "snippet": "void\nYCPDebugger::write_line (const char *format, ...) const\n{\n    char *ptr;\n\n    va_list ap;\n    va_start (ap, format);\n    const int size = vasprintf (&ptr, format, ap) + 3;\n    va_end (ap);\n\n    // replace all newlines by blanks\n    for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n\tif (*tmp == '\\n')\n\t    *tmp = ' ';\n\n    // append line ending \"\\r\\n\"\n    ptr = (char *) realloc (ptr, size);\n    strcat (ptr, \"\\r\\n\");\n\n    // don't write the trailing '\\0'\n    if (write (fd, ptr, size - 1) != size - 1) {\n\ty2error (\"fatal error: write failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n\n    free (ptr);\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::write_line (const char *format, ...) const\n  {\n      char *ptr;\n  \n      va_list ap;\n      va_start (ap, format);\n      const int size = vasprintf (&ptr, format, ap) + 3;\n      va_end (ap);\n  \n      // replace all newlines by blanks\n      for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n  \tif (*tmp == '\\n')\n  \t    *tmp = ' ';\n  \n      // append line ending \"\\r\\n\"\n      ptr = (char *) realloc (ptr, size);\n      strcat (ptr, \"\\r\\n\");\n  \n      // don't write the trailing '\\0'\n      if (write (fd, ptr, size - 1) != size - 1) {\n  \ty2error (\"fatal error: write failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      free (ptr);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_breakpoints",
          "args": [],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "list_breakpoints",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "595-604",
          "snippet": "void\nYCPDebugger::list_breakpoints ()\n{\n    write_line (\"BEGIN BREAKPOINTS\");\n    for (vector <Breakpoint>::iterator cur = breakpoints.begin ();\n\t cur != breakpoints.end (); cur++)\n\twrite_line (\"%s %d\", (*cur).file.c_str (),\n\t\t    (*cur).line);\n    write_line (\"END BREAKPOINTS\");\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::list_breakpoints ()\n  {\n      write_line (\"BEGIN BREAKPOINTS\");\n      for (vector <Breakpoint>::iterator cur = breakpoints.begin ();\n  \t cur != breakpoints.end (); cur++)\n  \twrite_line (\"%s %d\", (*cur).file.c_str (),\n  \t\t    (*cur).line);\n      write_line (\"END BREAKPOINTS\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "delete_breakpoint",
          "args": [
            "args[1]",
            "strtol (args[2].c_str (), NULL, 10)"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "delete_breakpoint",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "568-579",
          "snippet": "bool\nYCPDebugger::delete_breakpoint (const string &delete_file, int delete_line)\n{\n    for (vector <Breakpoint>::iterator cur = breakpoints.begin ();\n\t cur != breakpoints.end (); cur++)\n\tif ((delete_line == (*cur).line) && (delete_file == (*cur).file)) {\n\t    breakpoints.erase (cur);\n\t    return true;\n\t}\n\n    return false;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  bool\n  YCPDebugger::delete_breakpoint (const string &delete_file, int delete_line)\n  {\n      for (vector <Breakpoint>::iterator cur = breakpoints.begin ();\n  \t cur != breakpoints.end (); cur++)\n  \tif ((delete_line == (*cur).line) && (delete_file == (*cur).file)) {\n  \t    breakpoints.erase (cur);\n  \t    return true;\n  \t}\n  \n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "args[2].c_str ()",
            "NULL",
            "10"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args[2].c_str",
          "args": [],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_breakpoint",
          "args": [
            "args[1]",
            "strtol (args[2].c_str (), NULL, 10)"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "add_breakpoint",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "558-565",
          "snippet": "void\nYCPDebugger::add_breakpoint (const string &add_file, int add_line)\n{\n    Breakpoint tmp;\n    tmp.setpos (add_file, add_line);\n    tmp.tmpinactive = false;\n    breakpoints.push_back (tmp);\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::add_breakpoint (const string &add_file, int add_line)\n  {\n      Breakpoint tmp;\n      tmp.setpos (add_file, add_line);\n      tmp.tmpinactive = false;\n      breakpoints.push_back (tmp);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "args[2].c_str ()",
            "NULL",
            "10"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args[2].c_str",
          "args": [],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_source",
          "args": [
            "inter->interpreter->current_file.c_str ()"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "list_source",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "607-626",
          "snippet": "void\nYCPDebugger::list_source (const char * filename)\n{\n    const int size = 250;\n    char buffer[size];\n\n    FILE * fin = fopen (filename, \"r\");\n    if (!fin) {\n\ty2debug (\"can't open %s\", filename);\n\twrite_line (\"error reading source file\");\n\treturn;\n    }\n\n    write_line (\"BEGIN SOURCE\");\n    while (fgets (buffer, size, fin)) {\n\tbuffer[strlen (buffer) - 1] = '\\0';\n\twrite_line (\"%s\", buffer);\n    }\n    write_line (\"END SOURCE\");\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::list_source (const char * filename)\n  {\n      const int size = 250;\n      char buffer[size];\n  \n      FILE * fin = fopen (filename, \"r\");\n      if (!fin) {\n  \ty2debug (\"can't open %s\", filename);\n  \twrite_line (\"error reading source file\");\n  \treturn;\n      }\n  \n      write_line (\"BEGIN SOURCE\");\n      while (fgets (buffer, size, fin)) {\n  \tbuffer[strlen (buffer) - 1] = '\\0';\n  \twrite_line (\"%s\", buffer);\n      }\n      write_line (\"END SOURCE\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inter->interpreter->current_file.c_str",
          "args": [],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_interpreters",
          "args": [],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "list_interpreters",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "521-530",
          "snippet": "void\nYCPDebugger::list_interpreters ()\n{\n    write_line (\"BEGIN INTERPRETERS\");\n    for (vector <Interpreter>::iterator cur = interpreters.begin ();\n\t cur != interpreters.end (); cur++)\n\twrite_line (\"#%d %s\", (*cur).unique_id,\n\t\t    (*cur).interpreter->interpreter_name ().c_str ());\n    write_line (\"END INTERPRETERS\");\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::list_interpreters ()\n  {\n      write_line (\"BEGIN INTERPRETERS\");\n      for (vector <Interpreter>::iterator cur = interpreters.begin ();\n  \t cur != interpreters.end (); cur++)\n  \twrite_line (\"#%d %s\", (*cur).unique_id,\n  \t\t    (*cur).interpreter->interpreter_name ().c_str ());\n      write_line (\"END INTERPRETERS\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_variable",
          "args": [
            "tmp",
            "args[2]"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "print_variable",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "430-450",
          "snippet": "bool\nYCPDebugger::print_variable (Interpreter *inter, const string &name)\n{\n    YCPScopeInstance::YCPScopeInstance *instance = inter->interpreter->scopeTop;\n\n    if (!instance) {\n\twrite_line (\"variable not found\");\n\treturn false;\n    }\n\n    YCPValue value = instance->lookupValue (name);\n    if (value.isNull ()) {\n\twrite_line (\"variable not found\");\n\treturn false;\n    }\n\n    write_line (\"BEGIN VARIABLE\");\n    write_line (\"%s\", value->toString ().c_str ());\n    write_line (\"END VARIABLE\");\n    return true;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  bool\n  YCPDebugger::print_variable (Interpreter *inter, const string &name)\n  {\n      YCPScopeInstance::YCPScopeInstance *instance = inter->interpreter->scopeTop;\n  \n      if (!instance) {\n  \twrite_line (\"variable not found\");\n  \treturn false;\n      }\n  \n      YCPValue value = instance->lookupValue (name);\n      if (value.isNull ()) {\n  \twrite_line (\"variable not found\");\n  \treturn false;\n      }\n  \n      write_line (\"BEGIN VARIABLE\");\n      write_line (\"%s\", value->toString ().c_str ());\n      write_line (\"END VARIABLE\");\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_inter",
          "args": [
            "unique_id"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "args[1].substr (1).c_str ()"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args[1].substr",
          "args": [],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args[1].substr",
          "args": [
            "1"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_scope",
          "args": [
            "tmp"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "print_scope",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "453-486",
          "snippet": "void\nYCPDebugger::print_scope (Interpreter *inter)\n{\n    YCPScopeInstance::YCPScopeInstance *instance = inter->interpreter->scopeTop;\n\n    write_line (\"BEGIN SCOPE\");\n\n    while (instance && instance->container)\n    {\n\tYCPScopeInstance::YCPScopeContainer::const_iterator var;\n\n\tfor (var = instance->container->begin ();\n\t     var != instance->container->end (); var++)\n\t{\n\t    YCPDeclaration decl = var->second->get_type ();\n\n\t    // truncate length of variable\n\t    const int size = 60;\n\t    char buffer[size];\n\t    snprintf (buffer, size, \"%s\", var->second->get_value ()->\n\t\t      toString ().c_str ());\n\n\t    write_line (\"%d %s %s = %s\", instance->level,\n\t\t\tdecl->toString ().c_str (),\n\t\t\tdecl->isDeclTerm () ? \"\" : var->first.c_str (),\n\t\t\tbuffer);\n\n\t}\n\n\tinstance = instance->outer;\n    }\n\n    write_line (\"END SCOPE\");\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::print_scope (Interpreter *inter)\n  {\n      YCPScopeInstance::YCPScopeInstance *instance = inter->interpreter->scopeTop;\n  \n      write_line (\"BEGIN SCOPE\");\n  \n      while (instance && instance->container)\n      {\n  \tYCPScopeInstance::YCPScopeContainer::const_iterator var;\n  \n  \tfor (var = instance->container->begin ();\n  \t     var != instance->container->end (); var++)\n  \t{\n  \t    YCPDeclaration decl = var->second->get_type ();\n  \n  \t    // truncate length of variable\n  \t    const int size = 60;\n  \t    char buffer[size];\n  \t    snprintf (buffer, size, \"%s\", var->second->get_value ()->\n  \t\t      toString ().c_str ());\n  \n  \t    write_line (\"%d %s %s = %s\", instance->level,\n  \t\t\tdecl->toString ().c_str (),\n  \t\t\tdecl->isDeclTerm () ? \"\" : var->first.c_str (),\n  \t\t\tbuffer);\n  \n  \t}\n  \n  \tinstance = instance->outer;\n      }\n  \n      write_line (\"END SCOPE\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_inter",
          "args": [
            "unique_id"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "args[1].substr (1).c_str ()"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args[1].substr",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args[1].substr",
          "args": [
            "1"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"%s\"",
            "element->toString ().c_str ()"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "element->toString",
          "args": [],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "leave_position.setpos",
          "args": [
            "inter->interpreter->current_file",
            "inter->interpreter->current_line"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "setpos",
          "container": "YCPDebugger::Position",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "798-803",
          "snippet": "void\nYCPDebugger::Position::setpos (const string &set_file, int set_line)\n{\n    file = set_file;\n    line = set_line;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  Position {\n    void\n    YCPDebugger::Position::setpos (const string &set_file, int set_line)\n    {\n        file = set_file;\n        line = set_line;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "split",
          "args": [
            "command",
            "5",
            "args",
            "\" \\t\""
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "279-302",
          "snippet": "static int\nsplit (const string &in, int n, string *out, const char *delim)\n{\n    char buffer [in.length () + 1];\n    strcpy (buffer, in.c_str ());\n    char *tmp = buffer;\n\n    int i = 0;\n\n    while (true) {\n\n\tchar *t = strsep (&tmp, delim);\n\n\tif (t == NULL)\n\t    return i;\n\n\tif (*t != '\\0') {\n\t    out[i++] = t;\n\t    if (i == n)\n\t\treturn i;\n\t}\n\n    }\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nstatic int\nsplit (const string &in, int n, string *out, const char *delim)\n{\n    char buffer [in.length () + 1];\n    strcpy (buffer, in.c_str ());\n    char *tmp = buffer;\n\n    int i = 0;\n\n    while (true) {\n\n\tchar *t = strsep (&tmp, delim);\n\n\tif (t == NULL)\n\t    return i;\n\n\tif (*t != '\\0') {\n\t    out[i++] = t;\n\t    if (i == n)\n\t\treturn i;\n\t}\n\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  bool\n  YCPDebugger::handle_command (Interpreter *inter, const string &command,\n  \t\t\t     const YCPElement &element)\n  {\n      string args[5];\n      int nargs = split (command, 5, args, \" \\t\");\n  \n      if (nargs == 1 && args[0] == \"interrupt\") {\n  \treturn false;\n      }\n  \n      if (nargs == 1 && args[0] == \"continue\") {\n  \treturn true;\n      }\n  \n      if (nargs == 1 && args[0] == \"single\") {\n  \tsingle_mode = true;\n  \treturn true;\n      }\n  \n      if (nargs == 1 && args[0] == \"step\") {\n  \tleave_position.setpos (inter->interpreter->current_file,\n  \t\t\t       inter->interpreter->current_line);\n  \treturn true;\n      }\n  \n      if (nargs == 1 && args[0] == \"next\") {\n  \thold_level = inter->interpreter->scopeLevel;\n  \treturn true;\n      }\n  \n      if (nargs == 1 && args[0] == \"up\") {\n  \thold_level = inter->interpreter->scopeLevel - 1;\n  \treturn true;\n      }\n  \n      if (nargs == 1 && args[0] == \"detach\") {\n  \tclose_request = true;\n  \treturn true;\n      }\n  \n      if (nargs == 2 && (args[0] == \"set\" || args[0] == \"unset\")) {\n  \tbool tmp = args[0] == \"set\";\n  \tif (args[1] == \"ignorescr\") {\n  \t    settings.ignorescr = tmp;\n  \t    return false;\n  \t}\n  \tif (args[1] == \"printtoken\") {\n  \t    settings.printtoken = tmp;\n  \t    return false;\n  \t}\n      }\n  \n      if (nargs == 1 && args[0] == \"token\") {\n  \twrite_line (\"BEGIN TOKEN\");\n  \twrite_line (\"%s\", element->toString ().c_str ());\n  \twrite_line (\"END TOKEN\");\n  \treturn false;\n      }\n  \n      if (nargs == 1 && args[0] == \"scope\") {\n  \tprint_scope (inter);\n  \treturn false;\n      }\n  \n      if (nargs == 2 && args[0] == \"scope\" && args[1][0] == '#') {\n  \tint unique_id = atoi (args[1].substr (1).c_str ());\n  \tInterpreter * tmp = find_inter (unique_id);\n  \tif (tmp)\n  \t    print_scope (tmp);\n  \telse\n  \t    write_line (\"unknown interpreter\");\n  \treturn false;\n      }\n  \n      if (nargs == 2 && args[0] == \"print\") {\n  \tprint_variable (inter, args[1]);\n  \treturn false;\n      }\n  \n      if (nargs == 3 && args[0] == \"print\" && args[1][0] == '#') {\n  \tint unique_id = atoi (args[1].substr (1).c_str ());\n  \tInterpreter * tmp = find_inter (unique_id);\n  \tif (tmp)\n  \t    print_variable (tmp, args[2]);\n  \telse\n  \t    write_line (\"unknown interpreter\");\n  \treturn false;\n      }\n  \n      if (nargs == 2 && args[0] == \"list\") {\n  \tif (args[1] == \"breakpoints\") {\n  \t    list_breakpoints ();\n  \t    return false;\n  \t}\n  \tif (args[1] == \"interpreters\") {\n  \t    list_interpreters ();\n  \t    return false;\n  \t}\n  \tif (args[1] == \"source\") {\n  \t    list_source (inter->interpreter->current_file.c_str ());\n  \t    return false;\n  \t}\n      }\n  \n      if (nargs == 3 && args[0] == \"break\") {\n  \tadd_breakpoint (args[1], strtol (args[2].c_str (), NULL, 10));\n  \tlist_breakpoints ();\n  \treturn false;\n      }\n  \n      if (nargs == 3 && args[0] == \"clear\") {\n  \tif (delete_breakpoint (args[1], strtol (args[2].c_str (), NULL, 10))) {\n  \t    list_breakpoints ();\n  \t    return false;\n  \t}\n  \twrite_line (\"breakpoint not found\");\n  \treturn false;\n      }\n  \n      write_line (\"wrong command \\\"%s\\\"\", command.c_str ());\n      return false;\n  }\n}"
  },
  {
    "function_name": "split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "279-302",
    "snippet": "static int\nsplit (const string &in, int n, string *out, const char *delim)\n{\n    char buffer [in.length () + 1];\n    strcpy (buffer, in.c_str ());\n    char *tmp = buffer;\n\n    int i = 0;\n\n    while (true) {\n\n\tchar *t = strsep (&tmp, delim);\n\n\tif (t == NULL)\n\t    return i;\n\n\tif (*t != '\\0') {\n\t    out[i++] = t;\n\t    if (i == n)\n\t\treturn i;\n\t}\n\n    }\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&tmp",
            "delim"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "in.c_str ()"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.c_str",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.length",
          "args": [],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nstatic int\nsplit (const string &in, int n, string *out, const char *delim)\n{\n    char buffer [in.length () + 1];\n    strcpy (buffer, in.c_str ());\n    char *tmp = buffer;\n\n    int i = 0;\n\n    while (true) {\n\n\tchar *t = strsep (&tmp, delim);\n\n\tif (t == NULL)\n\t    return i;\n\n\tif (*t != '\\0') {\n\t    out[i++] = t;\n\t    if (i == n)\n\t\treturn i;\n\t}\n\n    }\n}"
  },
  {
    "function_name": "debug",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "146-276",
    "snippet": "void\nYCPDebugger::debug (YCPInterpreter *inter, EntryPoint entrypoint,\n\t\t    const YCPElement &element)\n{\n    Interpreter *act = find_inter (inter);\n\n    if (settings.ignorescr && act->interpreter->interpreter_name () == \"SCR\")\n\treturn;\n\n    if (ignore (entrypoint, element))\n\treturn;\n\n    if (fd == -1) {\n\tif (wait_for_frontend) {\n\t    const char msg[] = \"waiting for debugger frontend to connect\";\n\t    y2debug (msg);\n\t    fprintf (stdout, \"%s\\n\", msg);\n\t}\n\tcheck_socket (wait_for_frontend);\n\tif (wait_for_frontend) {\n\t    const char msg[] = \"debugger frontend has connected\";\n\t    y2debug (msg);\n\t    fprintf (stdout, \"%s\\n\", msg);\n\t}\n\twait_for_frontend = false;\n\n\t// Set default values.\n\tif (fd != -1) {\n\t    single_mode = true;\n\t    hold_level = -1;\n\t    leave_position.setpos (\"\", -1);\n\t    close_request = false;\n\t    last_command = \"\";\n\t    settings.reset ();\n\t}\n    }\n\n    if (fd == -1)\n\treturn;\n\n    bool goon = !single_mode;\n\n    if (goon && leave_position.line != -1)\n\tif (act->interpreter->current_line != leave_position.line ||\n\t    act->interpreter->current_file != leave_position.file)\n\t    goon = false;\n\n    if (goon && hold_level != -1)\n\tif (hold_level <= inter->scopeLevel) {\n\t    goon = false;\n\t    write_line (\"hold level reached\");\n\t}\n\n    if (goon)\n\tif (check_breakpoints (act->interpreter->current_file,\n\t\t\t       act->interpreter->current_line)) {\n\t    goon = false;\n\t    write_line (\"breakpoint reached\");\n\t}\n\n    // Check for \"interrupt\" command. Note: All other commands are\n    // discarded, thus this must be the last check. Kind of ugly!\n    if (goon) {\n\tstring cmd = read_line (false);\n\tif (cmd == \"interrupt\")\n\t    goon = false;\n    }\n\n    /*\n     * Avoid getting stuck in breakpoints: Normally, when we reach a\n     * breakpoint and say continue, it is very likely we immediately get\n     * to the same breakpoint again without leaving the source line. So\n     * the user has to say continue several times which is cumbersome.\n     *\n     * To solve this problem, we temporarily deactivate the breakpoint\n     * we reached. We reactivate it when we leave the source line.\n     */\n\n    // Reactivate breakpoints.\n    for (vector <Breakpoint>::iterator cur = breakpoints.begin ();\n\t cur != breakpoints.end (); cur++)\n\tif ((act->interpreter->current_line != (*cur).line) ||\n\t    (act->interpreter->current_file != (*cur).file))\n\t    (*cur).tmpinactive = false;\n\n    if (goon)\n\treturn;\n\n    // Somehow we stopped.\n\n    write_line (\"interpreter: #%d %s %d\", act->unique_id,\n\t\tact->interpreter->interpreter_name ().c_str (),\n\t\tentrypoint);\n\n    write_line (\"position: %s %d\",\n\t\tact->interpreter->current_file.c_str (),\n\t\tact->interpreter->current_line);\n\n    if (settings.printtoken) {\n\twrite_line (\"BEGIN TOKEN\");\n\twrite_line (\"%s\", element->toString ().c_str ());\n\twrite_line (\"END TOKEN\");\n    }\n\n    // Reset some stop conditions.\n    single_mode = false;\n    hold_level = -1;\n    leave_position.setpos (\"\", -1);\n\n    // Deactivate breakpoint.\n    for (vector <Breakpoint>::iterator cur = breakpoints.begin ();\n\t cur != breakpoints.end (); cur++)\n\tif ((act->interpreter->current_line == (*cur).line) &&\n\t    (act->interpreter->current_file == (*cur).file))\n\t    (*cur).tmpinactive = true;\n\n    // Loop over user input.\n    do {\n\twrite_prompt ();\n\tstring command = read_line (true);\n\tif (command.empty () && !last_command.empty ())\n\t    command = last_command;\n\tgoon = handle_command (act, command, element);\n\tlast_command = command;\n    } while (!goon);\n\n    if (close_request) {\n\tclose (fd);\n\tfd = -1;\n    }\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_command",
          "args": [
            "act",
            "command",
            "element"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "handle_command",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "305-427",
          "snippet": "bool\nYCPDebugger::handle_command (Interpreter *inter, const string &command,\n\t\t\t     const YCPElement &element)\n{\n    string args[5];\n    int nargs = split (command, 5, args, \" \\t\");\n\n    if (nargs == 1 && args[0] == \"interrupt\") {\n\treturn false;\n    }\n\n    if (nargs == 1 && args[0] == \"continue\") {\n\treturn true;\n    }\n\n    if (nargs == 1 && args[0] == \"single\") {\n\tsingle_mode = true;\n\treturn true;\n    }\n\n    if (nargs == 1 && args[0] == \"step\") {\n\tleave_position.setpos (inter->interpreter->current_file,\n\t\t\t       inter->interpreter->current_line);\n\treturn true;\n    }\n\n    if (nargs == 1 && args[0] == \"next\") {\n\thold_level = inter->interpreter->scopeLevel;\n\treturn true;\n    }\n\n    if (nargs == 1 && args[0] == \"up\") {\n\thold_level = inter->interpreter->scopeLevel - 1;\n\treturn true;\n    }\n\n    if (nargs == 1 && args[0] == \"detach\") {\n\tclose_request = true;\n\treturn true;\n    }\n\n    if (nargs == 2 && (args[0] == \"set\" || args[0] == \"unset\")) {\n\tbool tmp = args[0] == \"set\";\n\tif (args[1] == \"ignorescr\") {\n\t    settings.ignorescr = tmp;\n\t    return false;\n\t}\n\tif (args[1] == \"printtoken\") {\n\t    settings.printtoken = tmp;\n\t    return false;\n\t}\n    }\n\n    if (nargs == 1 && args[0] == \"token\") {\n\twrite_line (\"BEGIN TOKEN\");\n\twrite_line (\"%s\", element->toString ().c_str ());\n\twrite_line (\"END TOKEN\");\n\treturn false;\n    }\n\n    if (nargs == 1 && args[0] == \"scope\") {\n\tprint_scope (inter);\n\treturn false;\n    }\n\n    if (nargs == 2 && args[0] == \"scope\" && args[1][0] == '#') {\n\tint unique_id = atoi (args[1].substr (1).c_str ());\n\tInterpreter * tmp = find_inter (unique_id);\n\tif (tmp)\n\t    print_scope (tmp);\n\telse\n\t    write_line (\"unknown interpreter\");\n\treturn false;\n    }\n\n    if (nargs == 2 && args[0] == \"print\") {\n\tprint_variable (inter, args[1]);\n\treturn false;\n    }\n\n    if (nargs == 3 && args[0] == \"print\" && args[1][0] == '#') {\n\tint unique_id = atoi (args[1].substr (1).c_str ());\n\tInterpreter * tmp = find_inter (unique_id);\n\tif (tmp)\n\t    print_variable (tmp, args[2]);\n\telse\n\t    write_line (\"unknown interpreter\");\n\treturn false;\n    }\n\n    if (nargs == 2 && args[0] == \"list\") {\n\tif (args[1] == \"breakpoints\") {\n\t    list_breakpoints ();\n\t    return false;\n\t}\n\tif (args[1] == \"interpreters\") {\n\t    list_interpreters ();\n\t    return false;\n\t}\n\tif (args[1] == \"source\") {\n\t    list_source (inter->interpreter->current_file.c_str ());\n\t    return false;\n\t}\n    }\n\n    if (nargs == 3 && args[0] == \"break\") {\n\tadd_breakpoint (args[1], strtol (args[2].c_str (), NULL, 10));\n\tlist_breakpoints ();\n\treturn false;\n    }\n\n    if (nargs == 3 && args[0] == \"clear\") {\n\tif (delete_breakpoint (args[1], strtol (args[2].c_str (), NULL, 10))) {\n\t    list_breakpoints ();\n\t    return false;\n\t}\n\twrite_line (\"breakpoint not found\");\n\treturn false;\n    }\n\n    write_line (\"wrong command \\\"%s\\\"\", command.c_str ());\n    return false;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  bool\n  YCPDebugger::handle_command (Interpreter *inter, const string &command,\n  \t\t\t     const YCPElement &element)\n  {\n      string args[5];\n      int nargs = split (command, 5, args, \" \\t\");\n  \n      if (nargs == 1 && args[0] == \"interrupt\") {\n  \treturn false;\n      }\n  \n      if (nargs == 1 && args[0] == \"continue\") {\n  \treturn true;\n      }\n  \n      if (nargs == 1 && args[0] == \"single\") {\n  \tsingle_mode = true;\n  \treturn true;\n      }\n  \n      if (nargs == 1 && args[0] == \"step\") {\n  \tleave_position.setpos (inter->interpreter->current_file,\n  \t\t\t       inter->interpreter->current_line);\n  \treturn true;\n      }\n  \n      if (nargs == 1 && args[0] == \"next\") {\n  \thold_level = inter->interpreter->scopeLevel;\n  \treturn true;\n      }\n  \n      if (nargs == 1 && args[0] == \"up\") {\n  \thold_level = inter->interpreter->scopeLevel - 1;\n  \treturn true;\n      }\n  \n      if (nargs == 1 && args[0] == \"detach\") {\n  \tclose_request = true;\n  \treturn true;\n      }\n  \n      if (nargs == 2 && (args[0] == \"set\" || args[0] == \"unset\")) {\n  \tbool tmp = args[0] == \"set\";\n  \tif (args[1] == \"ignorescr\") {\n  \t    settings.ignorescr = tmp;\n  \t    return false;\n  \t}\n  \tif (args[1] == \"printtoken\") {\n  \t    settings.printtoken = tmp;\n  \t    return false;\n  \t}\n      }\n  \n      if (nargs == 1 && args[0] == \"token\") {\n  \twrite_line (\"BEGIN TOKEN\");\n  \twrite_line (\"%s\", element->toString ().c_str ());\n  \twrite_line (\"END TOKEN\");\n  \treturn false;\n      }\n  \n      if (nargs == 1 && args[0] == \"scope\") {\n  \tprint_scope (inter);\n  \treturn false;\n      }\n  \n      if (nargs == 2 && args[0] == \"scope\" && args[1][0] == '#') {\n  \tint unique_id = atoi (args[1].substr (1).c_str ());\n  \tInterpreter * tmp = find_inter (unique_id);\n  \tif (tmp)\n  \t    print_scope (tmp);\n  \telse\n  \t    write_line (\"unknown interpreter\");\n  \treturn false;\n      }\n  \n      if (nargs == 2 && args[0] == \"print\") {\n  \tprint_variable (inter, args[1]);\n  \treturn false;\n      }\n  \n      if (nargs == 3 && args[0] == \"print\" && args[1][0] == '#') {\n  \tint unique_id = atoi (args[1].substr (1).c_str ());\n  \tInterpreter * tmp = find_inter (unique_id);\n  \tif (tmp)\n  \t    print_variable (tmp, args[2]);\n  \telse\n  \t    write_line (\"unknown interpreter\");\n  \treturn false;\n      }\n  \n      if (nargs == 2 && args[0] == \"list\") {\n  \tif (args[1] == \"breakpoints\") {\n  \t    list_breakpoints ();\n  \t    return false;\n  \t}\n  \tif (args[1] == \"interpreters\") {\n  \t    list_interpreters ();\n  \t    return false;\n  \t}\n  \tif (args[1] == \"source\") {\n  \t    list_source (inter->interpreter->current_file.c_str ());\n  \t    return false;\n  \t}\n      }\n  \n      if (nargs == 3 && args[0] == \"break\") {\n  \tadd_breakpoint (args[1], strtol (args[2].c_str (), NULL, 10));\n  \tlist_breakpoints ();\n  \treturn false;\n      }\n  \n      if (nargs == 3 && args[0] == \"clear\") {\n  \tif (delete_breakpoint (args[1], strtol (args[2].c_str (), NULL, 10))) {\n  \t    list_breakpoints ();\n  \t    return false;\n  \t}\n  \twrite_line (\"breakpoint not found\");\n  \treturn false;\n      }\n  \n      write_line (\"wrong command \\\"%s\\\"\", command.c_str ());\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "last_command.empty",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_line",
          "args": [
            "true"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "read_line",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "707-750",
          "snippet": "string\nYCPDebugger::read_line (bool block) const\n{\n    const int maxmsg = 512;\n    char buffer[maxmsg + 1];\n\n    fd_set read_fd_set;\n    FD_ZERO (&read_fd_set);\n    FD_SET (fd, &read_fd_set);\n\n    struct timeval timeout;\n    timeout.tv_sec = block ? 604800 : 0;\n    timeout.tv_usec = 0;\n\n    int res;\n    do {\n\tres = select (FD_SETSIZE, &read_fd_set, NULL, NULL, &timeout);\n    } while (res == -1 && errno == EINTR);\n\n    // Test for timeout.\n    if (res == 0)\n\treturn \"\";\n\n    int nbytes = read (fd, buffer, maxmsg);\n\n    // Read error.\n    if (nbytes < 0) {\n\ty2error (\"error: read failed: %m\");\n\treturn \"\";\n    }\n\n    // End of file.\n    if (nbytes == 0) {\n\treturn \"\"; // ???\n    }\n\n    // append '\\0'\n    buffer[nbytes] = '\\0';\n\n    while (buffer[nbytes - 1] == '\\n' || buffer[nbytes - 1] == '\\r')\n\tbuffer[--nbytes] = '\\0';\n\n    return buffer;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  string\n  YCPDebugger::read_line (bool block) const\n  {\n      const int maxmsg = 512;\n      char buffer[maxmsg + 1];\n  \n      fd_set read_fd_set;\n      FD_ZERO (&read_fd_set);\n      FD_SET (fd, &read_fd_set);\n  \n      struct timeval timeout;\n      timeout.tv_sec = block ? 604800 : 0;\n      timeout.tv_usec = 0;\n  \n      int res;\n      do {\n  \tres = select (FD_SETSIZE, &read_fd_set, NULL, NULL, &timeout);\n      } while (res == -1 && errno == EINTR);\n  \n      // Test for timeout.\n      if (res == 0)\n  \treturn \"\";\n  \n      int nbytes = read (fd, buffer, maxmsg);\n  \n      // Read error.\n      if (nbytes < 0) {\n  \ty2error (\"error: read failed: %m\");\n  \treturn \"\";\n      }\n  \n      // End of file.\n      if (nbytes == 0) {\n  \treturn \"\"; // ???\n      }\n  \n      // append '\\0'\n      buffer[nbytes] = '\\0';\n  \n      while (buffer[nbytes - 1] == '\\n' || buffer[nbytes - 1] == '\\r')\n  \tbuffer[--nbytes] = '\\0';\n  \n      return buffer;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_prompt",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "write_prompt",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "782-795",
          "snippet": "void\nYCPDebugger::write_prompt () const\n{\n#if 0\n    char *tmp = \"y2d: \";\n    const int size = strlen (tmp);\n\n    // don't write the trailing '\\0'\n    if (write (fd, tmp, size) != size) {\n\ty2error (\"fatal error: write failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n#endif\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::write_prompt () const\n  {\n  #if 0\n      char *tmp = \"y2d: \";\n      const int size = strlen (tmp);\n  \n      // don't write the trailing '\\0'\n      if (write (fd, tmp, size) != size) {\n  \ty2error (\"fatal error: write failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  #endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "breakpoints.end",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "breakpoints.begin",
          "args": [],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "leave_position.setpos",
          "args": [
            "\"\"",
            "-1"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "setpos",
          "container": "YCPDebugger::Position",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "798-803",
          "snippet": "void\nYCPDebugger::Position::setpos (const string &set_file, int set_line)\n{\n    file = set_file;\n    line = set_line;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  Position {\n    void\n    YCPDebugger::Position::setpos (const string &set_file, int set_line)\n    {\n        file = set_file;\n        line = set_line;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"END TOKEN\""
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "write_line",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "753-779",
          "snippet": "void\nYCPDebugger::write_line (const char *format, ...) const\n{\n    char *ptr;\n\n    va_list ap;\n    va_start (ap, format);\n    const int size = vasprintf (&ptr, format, ap) + 3;\n    va_end (ap);\n\n    // replace all newlines by blanks\n    for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n\tif (*tmp == '\\n')\n\t    *tmp = ' ';\n\n    // append line ending \"\\r\\n\"\n    ptr = (char *) realloc (ptr, size);\n    strcat (ptr, \"\\r\\n\");\n\n    // don't write the trailing '\\0'\n    if (write (fd, ptr, size - 1) != size - 1) {\n\ty2error (\"fatal error: write failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n\n    free (ptr);\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::write_line (const char *format, ...) const\n  {\n      char *ptr;\n  \n      va_list ap;\n      va_start (ap, format);\n      const int size = vasprintf (&ptr, format, ap) + 3;\n      va_end (ap);\n  \n      // replace all newlines by blanks\n      for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n  \tif (*tmp == '\\n')\n  \t    *tmp = ' ';\n  \n      // append line ending \"\\r\\n\"\n      ptr = (char *) realloc (ptr, size);\n      strcat (ptr, \"\\r\\n\");\n  \n      // don't write the trailing '\\0'\n      if (write (fd, ptr, size - 1) != size - 1) {\n  \ty2error (\"fatal error: write failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      free (ptr);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"%s\"",
            "element->toString ().c_str ()"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "element->toString",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"position: %s %d\"",
            "act->interpreter->current_file.c_str ()",
            "act->interpreter->current_line"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "act->interpreter->current_file.c_str",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"interpreter: #%d %s %d\"",
            "act->unique_id",
            "act->interpreter->interpreter_name ().c_str ()",
            "entrypoint"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "act->interpreter->interpreter_name",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "act->interpreter->interpreter_name",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_breakpoints",
          "args": [
            "act->interpreter->current_file",
            "act->interpreter->current_line"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "check_breakpoints",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "582-592",
          "snippet": "bool\nYCPDebugger::check_breakpoints (const string &check_file, int check_line)\n{\n    for (vector <Breakpoint>::iterator cur = breakpoints.begin ();\n\t cur != breakpoints.end (); cur++)\n\tif (!(*cur).tmpinactive && (check_line == (*cur).line) &&\n\t    (check_file == (*cur).file))\n\t    return true;\n\n    return false;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  bool\n  YCPDebugger::check_breakpoints (const string &check_file, int check_line)\n  {\n      for (vector <Breakpoint>::iterator cur = breakpoints.begin ();\n  \t cur != breakpoints.end (); cur++)\n  \tif (!(*cur).tmpinactive && (check_line == (*cur).line) &&\n  \t    (check_file == (*cur).file))\n  \t    return true;\n  \n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "settings.reset",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "reset",
          "container": "YCPDebugger::Settings",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "806-811",
          "snippet": "void\nYCPDebugger::Settings::reset ()\n{\n    ignorescr = true;\n    printtoken = false;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  Settings {\n    void\n    YCPDebugger::Settings::reset ()\n    {\n        ignorescr = true;\n        printtoken = false;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\\n\"",
            "msg"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "msg"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_socket",
          "args": [
            "wait_for_frontend"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "check_socket",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "659-704",
          "snippet": "void\nYCPDebugger::check_socket (bool block)\n{\n    fd_set read_fd_set;\n    FD_ZERO (&read_fd_set);\n    FD_SET (sock, &read_fd_set);\n\n    struct timeval timeout;\n    timeout.tv_sec = block ? 604800 : 0;\n    timeout.tv_usec = 0;\n\n    int res;\n    do {\n\tres = select (FD_SETSIZE, &read_fd_set, NULL, NULL, &timeout);\n    } while (res == -1 && errno == EINTR);\n\n    if (res < 0) {\n\ty2error (\"fatal error: select failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n\n    // Test for timeout.\n    if (res == 0)\n\treturn;\n\n    // Connection request on original socket.\n    struct sockaddr_in clientname;\n    socklen_t size = sizeof (sockaddr_in);\n    int status = accept (sock, (struct sockaddr *) &clientname, &size);\n    if (status < 0) {\n\ty2error (\"fatal error: accept failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n\n    y2debug (\"connect from host %s\", inet_ntoa (clientname.sin_addr));\n\n    if (fd != -1) {\n\tclose (status);\n\ty2debug (\"but we already have a dubugger attached\");\n\treturn;\n    }\n\n    fd = status;\n\n    write_line (\"Welcome to the YCP debugger.\");\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::check_socket (bool block)\n  {\n      fd_set read_fd_set;\n      FD_ZERO (&read_fd_set);\n      FD_SET (sock, &read_fd_set);\n  \n      struct timeval timeout;\n      timeout.tv_sec = block ? 604800 : 0;\n      timeout.tv_usec = 0;\n  \n      int res;\n      do {\n  \tres = select (FD_SETSIZE, &read_fd_set, NULL, NULL, &timeout);\n      } while (res == -1 && errno == EINTR);\n  \n      if (res < 0) {\n  \ty2error (\"fatal error: select failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      // Test for timeout.\n      if (res == 0)\n  \treturn;\n  \n      // Connection request on original socket.\n      struct sockaddr_in clientname;\n      socklen_t size = sizeof (sockaddr_in);\n      int status = accept (sock, (struct sockaddr *) &clientname, &size);\n      if (status < 0) {\n  \ty2error (\"fatal error: accept failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      y2debug (\"connect from host %s\", inet_ntoa (clientname.sin_addr));\n  \n      if (fd != -1) {\n  \tclose (status);\n  \ty2debug (\"but we already have a dubugger attached\");\n  \treturn;\n      }\n  \n      fd = status;\n  \n      write_line (\"Welcome to the YCP debugger.\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\\n\"",
            "msg"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "msg"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore",
          "args": [
            "entrypoint",
            "element"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "ignore",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "99-143",
          "snippet": "bool\nYCPDebugger::ignore (EntryPoint entrypoint, const YCPElement &element)\n{\n    switch (entrypoint) {\n\n    case Interpreter: {\n\n\tconst YCPValue value = element->asValue ();\n\tif (!value->isBlock ())\n\t    return false;\n\n\tconst YCPBlock block = value->asBlock ();\n\tif (block->size () != 1)\n\t    return false;\n\n\tconst YCPStatement statement = block->statement (0);\n\tif (!statement->isBuiltinStatement ())\n\t    return false;\n\n\tconst YCPBuiltinStatement builtinstatement = statement->asBuiltinStatement ();\n\tif (builtinstatement->code () != YCPB_FULLNAME)\n\t    return false;\n\n\treturn true;\n\n    } break;\n\n    case Block: {\n\n\tconst YCPStatement statement = element->asStatement ();\n\tif (!statement->isBuiltinStatement ())\n\t    return false;\n\n\tconst YCPBuiltinStatement builtinstatement = statement->asBuiltinStatement ();\n\tif (builtinstatement->code () != YCPB_FULLNAME)\n\t    return false;\n\n\treturn true;\n\n    } break;\n\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  bool\n  YCPDebugger::ignore (EntryPoint entrypoint, const YCPElement &element)\n  {\n      switch (entrypoint) {\n  \n      case Interpreter: {\n  \n  \tconst YCPValue value = element->asValue ();\n  \tif (!value->isBlock ())\n  \t    return false;\n  \n  \tconst YCPBlock block = value->asBlock ();\n  \tif (block->size () != 1)\n  \t    return false;\n  \n  \tconst YCPStatement statement = block->statement (0);\n  \tif (!statement->isBuiltinStatement ())\n  \t    return false;\n  \n  \tconst YCPBuiltinStatement builtinstatement = statement->asBuiltinStatement ();\n  \tif (builtinstatement->code () != YCPB_FULLNAME)\n  \t    return false;\n  \n  \treturn true;\n  \n      } break;\n  \n      case Block: {\n  \n  \tconst YCPStatement statement = element->asStatement ();\n  \tif (!statement->isBuiltinStatement ())\n  \t    return false;\n  \n  \tconst YCPBuiltinStatement builtinstatement = statement->asBuiltinStatement ();\n  \tif (builtinstatement->code () != YCPB_FULLNAME)\n  \t    return false;\n  \n  \treturn true;\n  \n      } break;\n  \n      }\n  \n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "act->interpreter->interpreter_name",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_inter",
          "args": [
            "inter"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::debug (YCPInterpreter *inter, EntryPoint entrypoint,\n  \t\t    const YCPElement &element)\n  {\n      Interpreter *act = find_inter (inter);\n  \n      if (settings.ignorescr && act->interpreter->interpreter_name () == \"SCR\")\n  \treturn;\n  \n      if (ignore (entrypoint, element))\n  \treturn;\n  \n      if (fd == -1) {\n  \tif (wait_for_frontend) {\n  \t    const char msg[] = \"waiting for debugger frontend to connect\";\n  \t    y2debug (msg);\n  \t    fprintf (stdout, \"%s\\n\", msg);\n  \t}\n  \tcheck_socket (wait_for_frontend);\n  \tif (wait_for_frontend) {\n  \t    const char msg[] = \"debugger frontend has connected\";\n  \t    y2debug (msg);\n  \t    fprintf (stdout, \"%s\\n\", msg);\n  \t}\n  \twait_for_frontend = false;\n  \n  \t// Set default values.\n  \tif (fd != -1) {\n  \t    single_mode = true;\n  \t    hold_level = -1;\n  \t    leave_position.setpos (\"\", -1);\n  \t    close_request = false;\n  \t    last_command = \"\";\n  \t    settings.reset ();\n  \t}\n      }\n  \n      if (fd == -1)\n  \treturn;\n  \n      bool goon = !single_mode;\n  \n      if (goon && leave_position.line != -1)\n  \tif (act->interpreter->current_line != leave_position.line ||\n  \t    act->interpreter->current_file != leave_position.file)\n  \t    goon = false;\n  \n      if (goon && hold_level != -1)\n  \tif (hold_level <= inter->scopeLevel) {\n  \t    goon = false;\n  \t    write_line (\"hold level reached\");\n  \t}\n  \n      if (goon)\n  \tif (check_breakpoints (act->interpreter->current_file,\n  \t\t\t       act->interpreter->current_line)) {\n  \t    goon = false;\n  \t    write_line (\"breakpoint reached\");\n  \t}\n  \n      // Check for \"interrupt\" command. Note: All other commands are\n      // discarded, thus this must be the last check. Kind of ugly!\n      if (goon) {\n  \tstring cmd = read_line (false);\n  \tif (cmd == \"interrupt\")\n  \t    goon = false;\n      }\n  \n      /*\n       * Avoid getting stuck in breakpoints: Normally, when we reach a\n       * breakpoint and say continue, it is very likely we immediately get\n       * to the same breakpoint again without leaving the source line. So\n       * the user has to say continue several times which is cumbersome.\n       *\n       * To solve this problem, we temporarily deactivate the breakpoint\n       * we reached. We reactivate it when we leave the source line.\n       */\n  \n      // Reactivate breakpoints.\n      for (vector <Breakpoint>::iterator cur = breakpoints.begin ();\n  \t cur != breakpoints.end (); cur++)\n  \tif ((act->interpreter->current_line != (*cur).line) ||\n  \t    (act->interpreter->current_file != (*cur).file))\n  \t    (*cur).tmpinactive = false;\n  \n      if (goon)\n  \treturn;\n  \n      // Somehow we stopped.\n  \n      write_line (\"interpreter: #%d %s %d\", act->unique_id,\n  \t\tact->interpreter->interpreter_name ().c_str (),\n  \t\tentrypoint);\n  \n      write_line (\"position: %s %d\",\n  \t\tact->interpreter->current_file.c_str (),\n  \t\tact->interpreter->current_line);\n  \n      if (settings.printtoken) {\n  \twrite_line (\"BEGIN TOKEN\");\n  \twrite_line (\"%s\", element->toString ().c_str ());\n  \twrite_line (\"END TOKEN\");\n      }\n  \n      // Reset some stop conditions.\n      single_mode = false;\n      hold_level = -1;\n      leave_position.setpos (\"\", -1);\n  \n      // Deactivate breakpoint.\n      for (vector <Breakpoint>::iterator cur = breakpoints.begin ();\n  \t cur != breakpoints.end (); cur++)\n  \tif ((act->interpreter->current_line == (*cur).line) &&\n  \t    (act->interpreter->current_file == (*cur).file))\n  \t    (*cur).tmpinactive = true;\n  \n      // Loop over user input.\n      do {\n  \twrite_prompt ();\n  \tstring command = read_line (true);\n  \tif (command.empty () && !last_command.empty ())\n  \t    command = last_command;\n  \tgoon = handle_command (act, command, element);\n  \tlast_command = command;\n      } while (!goon);\n  \n      if (close_request) {\n  \tclose (fd);\n  \tfd = -1;\n      }\n  }\n}"
  },
  {
    "function_name": "ignore",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "99-143",
    "snippet": "bool\nYCPDebugger::ignore (EntryPoint entrypoint, const YCPElement &element)\n{\n    switch (entrypoint) {\n\n    case Interpreter: {\n\n\tconst YCPValue value = element->asValue ();\n\tif (!value->isBlock ())\n\t    return false;\n\n\tconst YCPBlock block = value->asBlock ();\n\tif (block->size () != 1)\n\t    return false;\n\n\tconst YCPStatement statement = block->statement (0);\n\tif (!statement->isBuiltinStatement ())\n\t    return false;\n\n\tconst YCPBuiltinStatement builtinstatement = statement->asBuiltinStatement ();\n\tif (builtinstatement->code () != YCPB_FULLNAME)\n\t    return false;\n\n\treturn true;\n\n    } break;\n\n    case Block: {\n\n\tconst YCPStatement statement = element->asStatement ();\n\tif (!statement->isBuiltinStatement ())\n\t    return false;\n\n\tconst YCPBuiltinStatement builtinstatement = statement->asBuiltinStatement ();\n\tif (builtinstatement->code () != YCPB_FULLNAME)\n\t    return false;\n\n\treturn true;\n\n    } break;\n\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builtinstatement->code",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "code",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "139-147",
          "snippet": "YCodePtr\nYSymbolEntry::code () const\n{\n    if (m_category == c_builtin || m_category == c_module)\n    {\n\treturn 0;\n    }\n    return m_code;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nYSymbolEntry {\n  YCodePtr\n  YSymbolEntry::code () const\n  {\n      if (m_category == c_builtin || m_category == c_module)\n      {\n  \treturn 0;\n      }\n      return m_code;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "statement->asBuiltinStatement",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement->isBuiltinStatement",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "element->asStatement",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement->asBuiltinStatement",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement->isBuiltinStatement",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block->statement",
          "args": [
            "0"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block->size",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPByteblockRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPByteblock.cc",
          "lines": "59-63",
          "snippet": "long\nYCPByteblockRep::size() const\n{\n    return len;\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPByteblock.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPByteblock.h\"\n#include <ycp/y2log.h>\n\nYCPByteblockRep {\n  long\n  YCPByteblockRep::size() const\n  {\n      return len;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asBlock",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->isBlock",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "isBlock",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "73-77",
          "snippet": "bool\nYBreakpoint::isBlock () const\n{\n    return m_code->isBlock();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  bool\n  YBreakpoint::isBlock () const\n  {\n      return m_code->isBlock();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "element->asValue",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "asValue",
          "container": "YCPElementRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPElement.cc",
          "lines": "54-58",
          "snippet": "YCPValue\nYCPElementRep::asValue() const\n{\n    return YCPValue(static_cast<const YCPValueRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPValue.h\"",
            "#include \"ycp/YCPElement.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPValue.h\"\n#include \"ycp/YCPElement.h\"\n#include \"ycp/y2log.h\"\n\nYCPElementRep {\n  YCPValue\n  YCPElementRep::asValue() const\n  {\n      return YCPValue(static_cast<const YCPValueRep *>(this));\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  bool\n  YCPDebugger::ignore (EntryPoint entrypoint, const YCPElement &element)\n  {\n      switch (entrypoint) {\n  \n      case Interpreter: {\n  \n  \tconst YCPValue value = element->asValue ();\n  \tif (!value->isBlock ())\n  \t    return false;\n  \n  \tconst YCPBlock block = value->asBlock ();\n  \tif (block->size () != 1)\n  \t    return false;\n  \n  \tconst YCPStatement statement = block->statement (0);\n  \tif (!statement->isBuiltinStatement ())\n  \t    return false;\n  \n  \tconst YCPBuiltinStatement builtinstatement = statement->asBuiltinStatement ();\n  \tif (builtinstatement->code () != YCPB_FULLNAME)\n  \t    return false;\n  \n  \treturn true;\n  \n      } break;\n  \n      case Block: {\n  \n  \tconst YCPStatement statement = element->asStatement ();\n  \tif (!statement->isBuiltinStatement ())\n  \t    return false;\n  \n  \tconst YCPBuiltinStatement builtinstatement = statement->asBuiltinStatement ();\n  \tif (builtinstatement->code () != YCPB_FULLNAME)\n  \t    return false;\n  \n  \treturn true;\n  \n      } break;\n  \n      }\n  \n      return false;\n  }\n}"
  },
  {
    "function_name": "setFilename",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "87-96",
    "snippet": "void\nYCPDebugger::setFilename (const char *filename)\n{\n    y2debug (\"setFilename (%s)\\n\", filename);\n    if (filename)\n    {\n\tm_filename = filename;\n    }\n    return;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"setFilename (%s)\\n\"",
            "filename"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::setFilename (const char *filename)\n  {\n      y2debug (\"setFilename (%s)\\n\", filename);\n      if (filename)\n      {\n  \tm_filename = filename;\n      }\n      return;\n  }\n}"
  },
  {
    "function_name": "setLineNumber",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "72-77",
    "snippet": "void\nYCPDebugger::setLineNumber (int line)\n{\n    m_line = line;\n    return;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::setLineNumber (int line)\n  {\n      m_line = line;\n      return;\n  }\n}"
  },
  {
    "function_name": "lineNumber",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "65-69",
    "snippet": "int\nYCPDebugger::lineNumber () const\n{\n    return m_line;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  int\n  YCPDebugger::lineNumber () const\n  {\n      return m_line;\n  }\n}"
  },
  {
    "function_name": "~YCPDebugger",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "52-62",
    "snippet": "YCPDebugger::~YCPDebugger ()\n{\n    y2debug (\"destructor\");\n\n    if (fd != -1) {\n\twrite_line (\"All interpreters finished, bye.\");\n\tclose (fd);\n    }\n\n    shutdown (sock, 2);\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "sock",
            "2"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_line",
          "args": [
            "\"All interpreters finished, bye.\""
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "write_line",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "753-779",
          "snippet": "void\nYCPDebugger::write_line (const char *format, ...) const\n{\n    char *ptr;\n\n    va_list ap;\n    va_start (ap, format);\n    const int size = vasprintf (&ptr, format, ap) + 3;\n    va_end (ap);\n\n    // replace all newlines by blanks\n    for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n\tif (*tmp == '\\n')\n\t    *tmp = ' ';\n\n    // append line ending \"\\r\\n\"\n    ptr = (char *) realloc (ptr, size);\n    strcat (ptr, \"\\r\\n\");\n\n    // don't write the trailing '\\0'\n    if (write (fd, ptr, size - 1) != size - 1) {\n\ty2error (\"fatal error: write failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n\n    free (ptr);\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::write_line (const char *format, ...) const\n  {\n      char *ptr;\n  \n      va_list ap;\n      va_start (ap, format);\n      const int size = vasprintf (&ptr, format, ap) + 3;\n      va_end (ap);\n  \n      // replace all newlines by blanks\n      for (char *tmp = ptr; *tmp != '\\0'; tmp++)\n  \tif (*tmp == '\\n')\n  \t    *tmp = ' ';\n  \n      // append line ending \"\\r\\n\"\n      ptr = (char *) realloc (ptr, size);\n      strcat (ptr, \"\\r\\n\");\n  \n      // don't write the trailing '\\0'\n      if (write (fd, ptr, size - 1) != size - 1) {\n  \ty2error (\"fatal error: write failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      free (ptr);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"destructor\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  YCPDebugger::~YCPDebugger ()\n  {\n      y2debug (\"destructor\");\n  \n      if (fd != -1) {\n  \twrite_line (\"All interpreters finished, bye.\");\n  \tclose (fd);\n      }\n  \n      shutdown (sock, 2);\n  }\n}"
  },
  {
    "function_name": "YCPDebugger",
    "container": "YCPDebugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
    "lines": "40-49",
    "snippet": "YCPDebugger::YCPDebugger (bool wait_for_frontend)\n    : wait_for_frontend (wait_for_frontend)\n{\n    y2debug (\"constructor\");\n\n    unique_id_cnt = 0;\n    sock = fd = -1;\n\n    create_socket ();\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"ycp/YCPDebugger.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_socket",
          "args": [],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "create_socket",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "629-656",
          "snippet": "void\nYCPDebugger::create_socket ()\n{\n    // Create the socket.\n    sock = socket (PF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n\ty2error (\"fatal error: socket failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n\n    // Give the socket a name.\n    struct sockaddr_in name;\n    name.sin_family = AF_INET;\n    name.sin_port = htons (19473);\n    name.sin_addr.s_addr = htonl (INADDR_ANY);\n    if (bind (sock, (struct sockaddr *) &name,\n\t      sizeof (struct sockaddr_in)) < 0) {\n\ty2error (\"fatal error: bind failed: %m\");\n\tfprintf (stderr, \"fatal error: bind failed: %m\\n\");\n\texit (EXIT_FAILURE);\n    }\n\n    // Listen on socket.\n    if (listen (sock, 1) < 0) {\n\ty2error (\"fatal error: listen failed: %m\");\n\texit (EXIT_FAILURE);\n    }\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::create_socket ()\n  {\n      // Create the socket.\n      sock = socket (PF_INET, SOCK_STREAM, 0);\n      if (sock < 0) {\n  \ty2error (\"fatal error: socket failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      // Give the socket a name.\n      struct sockaddr_in name;\n      name.sin_family = AF_INET;\n      name.sin_port = htons (19473);\n      name.sin_addr.s_addr = htonl (INADDR_ANY);\n      if (bind (sock, (struct sockaddr *) &name,\n  \t      sizeof (struct sockaddr_in)) < 0) {\n  \ty2error (\"fatal error: bind failed: %m\");\n  \tfprintf (stderr, \"fatal error: bind failed: %m\\n\");\n  \texit (EXIT_FAILURE);\n      }\n  \n      // Listen on socket.\n      if (listen (sock, 1) < 0) {\n  \ty2error (\"fatal error: listen failed: %m\");\n  \texit (EXIT_FAILURE);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"constructor\""
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  YCPDebugger::YCPDebugger (bool wait_for_frontend)\n      : wait_for_frontend (wait_for_frontend)\n  {\n      y2debug (\"constructor\");\n  \n      unique_id_cnt = 0;\n      sock = fd = -1;\n  \n      create_socket ();\n  }\n}"
  }
]