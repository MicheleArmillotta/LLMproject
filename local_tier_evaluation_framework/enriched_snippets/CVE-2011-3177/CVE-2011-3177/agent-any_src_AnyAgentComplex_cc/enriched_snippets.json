[
  {
    "function_name": "unparseData",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
    "lines": "713-952",
    "snippet": "const string\nAnyAgent::unparseData (const YCPValue & syntax, const YCPValue & value)\n{\n    if (syntax.isNull ())\n\treturn \"\";\n\n    y2debug (\"unparseData ('%s',%s)\", value.isNull () ? \"\" : value->toString ().c_str (),\n\t     syntax->toString ().c_str ());\n\n    switch (syntax->valuetype ())\n    {\n\tcase YT_TERM: {\n\n\t    YCPTerm term = syntax->asTerm ();\n\t    if (term.isNull ())\n\t    {\n\t\ty2error (\"YT_TERM no term\");\n\t    }\n\t    string s = term->name ();\n\t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n\n\t    // Optional\n\n\t    if (s == \"Optional\" && term->size () > 0)\n\t    {\n\t\treturn unparseData (term->value (0), value);\n\t    }\n\n\t    // Continue\n\n\t    else if (s == \"Continue\" && term->size () > 0)\n\t    {\n\t\tif (tupleContinue)\n\t\t    return unparseData (term->value (0), value);\n\t    }\n\n\t    // Choice\n\n\t    else if (s == \"Choice\" && term->size () > 0)\n\t    {\n\t\treturn unparseChoice (term->args (), value);\n\t    }\n\n\t    // Sequence\n\n\t    else if (s == \"Sequence\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tconst string s = unparseSequence (term->args (), value);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn s;\n\t    }\n\n\t    // List\n\n\t    else if (s == \"List\" && term->size () == 2)\n\t    {\n\t\treturn unparseList (term->args (), value);\n\t    }\n\n\t    // Tuple\n\n\t    else if (s == \"Tuple\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tconst string s = unparseTuple (term->args (), value);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn s;\n\t    }\n\n\t    // Var\n\n\t    else if (s == \"Var\" && term->size () > 0)\n\t    {\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    const string vdata = unparseData (term->value (i), value);\n\t\t    if (vdata.empty ())\n\t\t\tbreak;\n\t\t}\n\t\treturn \"\";\n\t    }\n\n\t    // Name\n\n\t    else if (s == \"Name\" && term->size () == 1)\n\t    {\n\t\ty2error (\"unparse Name ()\");\n\t\treturn \"\";\n\t    }\n\n\t    // Value\n\n\t    else if (s == \"Value\" && term->size () == 1)\n\t    {\n\t\tconst string s = unparseData (term->value (0), value);\n#if 0\n\t\tif (tv && tupleValue.size () > 0)\n\t\t    tupleValue.top () = tv;\n#endif\n\t\treturn s;\n\t    }\n\n\t    // Separator\n\n\t    else if (s == \"Separator\" && term->size () == 1)\n\t    {\n\t\treturn unparseSeparator (term->value (0));\n\t    }\n\n\t    // Whitespace\n\n\t    else if (s == \"Whitespace\")\n\t    {\n\t\treturn unparseSeparator (YCPString (\" \\t\"));\n\t    }\n\n\t    // Skip (is handled correctly within unparseTuple()\n\n\t    else if (s == \"Skip\")\n\t    {\n\t\treturn \"\";\n\t    }\n\n\t    // Fillup (is handled correctly within unparseTuple()\n\n\t    else if (s == \"Fillup\")\n\t    {\n\t\treturn \"\";\n\t    }\n\n\t    // String\n\n\t    else if (s == \"String\" && term->size () > 0)\n\t    {\n\t\tif (term->size () == 1)\n\t\t    return unparseString (term->value (0), YCPNull (), value);\n\t\tif (term->size () == 2)\n\t\t    return unparseString (term->value (0), term->value (1),\n\t\t\t\t\t  value);\n\t    }\n\n\t    // Or\n\n\t    else if (s == \"Or\" && term->size () == 2)\n\t    {\n#if 1\n\t\tconst YCPValue vbackup = value;\n\t\tconst string vdata = unparseData (term->value (0), value);\n\t\tif (vdata != \"\")\n\t\t    return vdata;\n\t\telse\n\t\t    return unparseData (term->value (1), vbackup);\n#endif\n\t    }\n\n\t    // Number\n\n\t    else if (s == \"Number\")\n\t    {\n\t\treturn unparseNumber (value);\n\t    }\n\n\t    // Boolean\n\n\t    else if (s == \"Boolean\")\n\t    {\n\t\treturn unparseBoolean (value);\n\t    }\n\n\t    // Float\n\n\t    else if (s == \"Float\")\n\t    {\n\t\treturn unparseFloat (value);\n\t    }\n\n\t    // Ip4Number\n\n\t    else if (s == \"Ip4Number\")\n\t    {\n\t\treturn unparseIp4Number (value);\n\t    }\n\n\t    // Hostname\n\n\t    else if (s == \"Hostname\")\n\t    {\n\t\treturn unparseHostname (value);\n\t    }\n\n\t    // Username\n\n\t    else if (s == \"Username\")\n\t    {\n\t\treturn unparseUsername (value);\n\t    }\n\n\t    // <name> (<syntax>)\n\n\t    else if (islower (s[0]) && (term->size () == 1))\n\t    {\n\t\tif (!value->isMap ())\n\t\t    y2error (\"request for element '%s' but value not map\",\n\t\t\t     s.c_str ());\n\t\telse\n\t\t{\n\t\t    YCPValue v = value->asMap ()->value (YCPString (s));\n\t\t    if (v.isNull ())\n\t\t    {\n\t\t\ty2error (\"No value for key '%s' in map\", s.c_str ());\n\t\t\treturn \"\";\n\t\t    }\n\t\t    return unparseData (term->value (0), v);\n\t\t}\n\t    }\n\n\t    else\n\t    {\n\t\ty2error (\"unparseData: unknown term '%s'\", s.c_str ());\n\t\treturn \"\";\n\t    }\n\t} break;\n\n\tcase YT_STRING:\n\t    y2debug (\"YT_STRING\");\n\t    return unparseVerbose (syntax);\n\t    break;\n\n\tdefault:\n\t    y2error (\"unparseData: unknown syntax %s\", syntax->toString ().c_str ());\n\t    break;\n    }\n\n    return \"\";\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"unparseData: unknown syntax %s\"",
            "syntax->toString ().c_str ()"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syntax->toString",
          "args": [],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unparseVerbose",
          "args": [
            "syntax"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "unparseVerbose",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "488-499",
          "snippet": "const string\nAnyAgent::unparseVerbose (const YCPValue & value)\n{\n    if ((value.isNull ()) || (!value->isString ()))\n\treturn \"\";\n\n    const char *v = value->asString ()->value ().c_str ();\n    string s = string (v);\n\n    y2debug (\"unparseVerbose (%s,%s)\", value->toString ().c_str (), s.c_str ());\n    return s;\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseVerbose (const YCPValue & value)\n  {\n      if ((value.isNull ()) || (!value->isString ()))\n  \treturn \"\";\n  \n      const char *v = value->asString ()->value ().c_str ();\n      string s = string (v);\n  \n      y2debug (\"unparseVerbose (%s,%s)\", value->toString ().c_str (), s.c_str ());\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YT_STRING\""
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"unparseData: unknown term '%s'\"",
            "s.c_str ()"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.c_str",
          "args": [],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparseData",
          "args": [
            "term->value (0)",
            "v"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "unparseData",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "713-952",
          "snippet": "const string\nAnyAgent::unparseData (const YCPValue & syntax, const YCPValue & value)\n{\n    if (syntax.isNull ())\n\treturn \"\";\n\n    y2debug (\"unparseData ('%s',%s)\", value.isNull () ? \"\" : value->toString ().c_str (),\n\t     syntax->toString ().c_str ());\n\n    switch (syntax->valuetype ())\n    {\n\tcase YT_TERM: {\n\n\t    YCPTerm term = syntax->asTerm ();\n\t    if (term.isNull ())\n\t    {\n\t\ty2error (\"YT_TERM no term\");\n\t    }\n\t    string s = term->name ();\n\t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n\n\t    // Optional\n\n\t    if (s == \"Optional\" && term->size () > 0)\n\t    {\n\t\treturn unparseData (term->value (0), value);\n\t    }\n\n\t    // Continue\n\n\t    else if (s == \"Continue\" && term->size () > 0)\n\t    {\n\t\tif (tupleContinue)\n\t\t    return unparseData (term->value (0), value);\n\t    }\n\n\t    // Choice\n\n\t    else if (s == \"Choice\" && term->size () > 0)\n\t    {\n\t\treturn unparseChoice (term->args (), value);\n\t    }\n\n\t    // Sequence\n\n\t    else if (s == \"Sequence\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tconst string s = unparseSequence (term->args (), value);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn s;\n\t    }\n\n\t    // List\n\n\t    else if (s == \"List\" && term->size () == 2)\n\t    {\n\t\treturn unparseList (term->args (), value);\n\t    }\n\n\t    // Tuple\n\n\t    else if (s == \"Tuple\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tconst string s = unparseTuple (term->args (), value);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn s;\n\t    }\n\n\t    // Var\n\n\t    else if (s == \"Var\" && term->size () > 0)\n\t    {\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    const string vdata = unparseData (term->value (i), value);\n\t\t    if (vdata.empty ())\n\t\t\tbreak;\n\t\t}\n\t\treturn \"\";\n\t    }\n\n\t    // Name\n\n\t    else if (s == \"Name\" && term->size () == 1)\n\t    {\n\t\ty2error (\"unparse Name ()\");\n\t\treturn \"\";\n\t    }\n\n\t    // Value\n\n\t    else if (s == \"Value\" && term->size () == 1)\n\t    {\n\t\tconst string s = unparseData (term->value (0), value);\n#if 0\n\t\tif (tv && tupleValue.size () > 0)\n\t\t    tupleValue.top () = tv;\n#endif\n\t\treturn s;\n\t    }\n\n\t    // Separator\n\n\t    else if (s == \"Separator\" && term->size () == 1)\n\t    {\n\t\treturn unparseSeparator (term->value (0));\n\t    }\n\n\t    // Whitespace\n\n\t    else if (s == \"Whitespace\")\n\t    {\n\t\treturn unparseSeparator (YCPString (\" \\t\"));\n\t    }\n\n\t    // Skip (is handled correctly within unparseTuple()\n\n\t    else if (s == \"Skip\")\n\t    {\n\t\treturn \"\";\n\t    }\n\n\t    // Fillup (is handled correctly within unparseTuple()\n\n\t    else if (s == \"Fillup\")\n\t    {\n\t\treturn \"\";\n\t    }\n\n\t    // String\n\n\t    else if (s == \"String\" && term->size () > 0)\n\t    {\n\t\tif (term->size () == 1)\n\t\t    return unparseString (term->value (0), YCPNull (), value);\n\t\tif (term->size () == 2)\n\t\t    return unparseString (term->value (0), term->value (1),\n\t\t\t\t\t  value);\n\t    }\n\n\t    // Or\n\n\t    else if (s == \"Or\" && term->size () == 2)\n\t    {\n#if 1\n\t\tconst YCPValue vbackup = value;\n\t\tconst string vdata = unparseData (term->value (0), value);\n\t\tif (vdata != \"\")\n\t\t    return vdata;\n\t\telse\n\t\t    return unparseData (term->value (1), vbackup);\n#endif\n\t    }\n\n\t    // Number\n\n\t    else if (s == \"Number\")\n\t    {\n\t\treturn unparseNumber (value);\n\t    }\n\n\t    // Boolean\n\n\t    else if (s == \"Boolean\")\n\t    {\n\t\treturn unparseBoolean (value);\n\t    }\n\n\t    // Float\n\n\t    else if (s == \"Float\")\n\t    {\n\t\treturn unparseFloat (value);\n\t    }\n\n\t    // Ip4Number\n\n\t    else if (s == \"Ip4Number\")\n\t    {\n\t\treturn unparseIp4Number (value);\n\t    }\n\n\t    // Hostname\n\n\t    else if (s == \"Hostname\")\n\t    {\n\t\treturn unparseHostname (value);\n\t    }\n\n\t    // Username\n\n\t    else if (s == \"Username\")\n\t    {\n\t\treturn unparseUsername (value);\n\t    }\n\n\t    // <name> (<syntax>)\n\n\t    else if (islower (s[0]) && (term->size () == 1))\n\t    {\n\t\tif (!value->isMap ())\n\t\t    y2error (\"request for element '%s' but value not map\",\n\t\t\t     s.c_str ());\n\t\telse\n\t\t{\n\t\t    YCPValue v = value->asMap ()->value (YCPString (s));\n\t\t    if (v.isNull ())\n\t\t    {\n\t\t\ty2error (\"No value for key '%s' in map\", s.c_str ());\n\t\t\treturn \"\";\n\t\t    }\n\t\t    return unparseData (term->value (0), v);\n\t\t}\n\t    }\n\n\t    else\n\t    {\n\t\ty2error (\"unparseData: unknown term '%s'\", s.c_str ());\n\t\treturn \"\";\n\t    }\n\t} break;\n\n\tcase YT_STRING:\n\t    y2debug (\"YT_STRING\");\n\t    return unparseVerbose (syntax);\n\t    break;\n\n\tdefault:\n\t    y2error (\"unparseData: unknown syntax %s\", syntax->toString ().c_str ());\n\t    break;\n    }\n\n    return \"\";\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "term->value",
          "args": [
            "0"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"No value for key '%s' in map\"",
            "s.c_str ()"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.c_str",
          "args": [],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->asMap",
          "args": [
            "YCPString (s)"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "s"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asMap",
          "args": [],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"request for element '%s' but value not map\"",
            "s.c_str ()"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.c_str",
          "args": [],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->isMap",
          "args": [],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "71-71",
          "snippet": "bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->size",
          "args": [],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "islower",
          "args": [
            "s[0]"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparseUsername",
          "args": [
            "value"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "unparseUsername",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "445-463",
          "snippet": "const string\nAnyAgent::unparseUsername (const YCPValue & value)\n{\n    if ((value.isNull ()) || (!value->isString ()))\n\treturn \"\";\n\n    const char *v = value->asString ()->value ().c_str ();\n    string s;\n\n    if (isalpha (*v))\n    {\n\ts.reserve (strlen (v));\n\twhile (isalnum (*v))\n\t    s += *v++;\n    }\n\n    y2debug (\"unparseUsername (%s,%s)\", value->toString ().c_str (), s.c_str ());\n    return s;\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseUsername (const YCPValue & value)\n  {\n      if ((value.isNull ()) || (!value->isString ()))\n  \treturn \"\";\n  \n      const char *v = value->asString ()->value ().c_str ();\n      string s;\n  \n      if (isalpha (*v))\n      {\n  \ts.reserve (strlen (v));\n  \twhile (isalnum (*v))\n  \t    s += *v++;\n      }\n  \n      y2debug (\"unparseUsername (%s,%s)\", value->toString ().c_str (), s.c_str ());\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unparseHostname",
          "args": [
            "value"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "unparseHostname",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "393-412",
          "snippet": "const string\nAnyAgent::unparseHostname (const YCPValue & value)\n{\n    if ((value.isNull ()) || (!value->isString ()))\n\treturn \"\";\n\n    const char *v = value->asString ()->value ().c_str ();\n    string s;\n\n    if (isalpha (*v))\n    {\n\ts.reserve (strlen (v));\n\twhile (isalnum (*v) || (*v == '_') ||\n\t       ((*v == '.') && (isalpha (*(v + 1)))))\n\t    s.append (1, *v++);\n    }\n\n    y2debug (\"unparseHostname (%s,%s)\", value->toString ().c_str (), s.c_str ());\n    return s;\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseHostname (const YCPValue & value)\n  {\n      if ((value.isNull ()) || (!value->isString ()))\n  \treturn \"\";\n  \n      const char *v = value->asString ()->value ().c_str ();\n      string s;\n  \n      if (isalpha (*v))\n      {\n  \ts.reserve (strlen (v));\n  \twhile (isalnum (*v) || (*v == '_') ||\n  \t       ((*v == '.') && (isalpha (*(v + 1)))))\n  \t    s.append (1, *v++);\n      }\n  \n      y2debug (\"unparseHostname (%s,%s)\", value->toString ().c_str (), s.c_str ());\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unparseIp4Number",
          "args": [
            "value"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "unparseIp4Number",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "73-86",
          "snippet": "const string\nAnyAgent::unparseIp4Number (const YCPValue & value)\n{\n    if ((value.isNull ()) || (!value->isInteger ()))\n\treturn \"\";\n\n    char s[61];\t\t\t// nnn.nnn.nnn.nnn\\0\n    long i = value->asInteger ()->value () & 0xffffffffL;\n    snprintf (s, 61, \"%ld.%ld.%ld.%ld\", (i >> 24) & 0xff, (i >> 16) & 0xff,\n\t      (i >> 8) & 0xff, i & 0xff);\n\n    y2debug (\"unparseIp4Number (%s,%s)\", value->toString ().c_str (), s);\n    return string (s);\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseIp4Number (const YCPValue & value)\n  {\n      if ((value.isNull ()) || (!value->isInteger ()))\n  \treturn \"\";\n  \n      char s[61];\t\t\t// nnn.nnn.nnn.nnn\\0\n      long i = value->asInteger ()->value () & 0xffffffffL;\n      snprintf (s, 61, \"%ld.%ld.%ld.%ld\", (i >> 24) & 0xff, (i >> 16) & 0xff,\n  \t      (i >> 8) & 0xff, i & 0xff);\n  \n      y2debug (\"unparseIp4Number (%s,%s)\", value->toString ().c_str (), s);\n      return string (s);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unparseFloat",
          "args": [
            "value"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "unparseFloat",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "333-344",
          "snippet": "const string\nAnyAgent::unparseFloat (const YCPValue & value)\n{\n    if ((value.isNull ()) || (!value->isFloat ()))\n\treturn \"\";\n\n    char s[64];\n    snprintf (s, 64, \"%f\", value->asFloat ()->value ());\n\n    y2debug (\"unparseFloat (%s,%s)\", value->toString ().c_str (), s);\n    return string (s);\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseFloat (const YCPValue & value)\n  {\n      if ((value.isNull ()) || (!value->isFloat ()))\n  \treturn \"\";\n  \n      char s[64];\n      snprintf (s, 64, \"%f\", value->asFloat ()->value ());\n  \n      y2debug (\"unparseFloat (%s,%s)\", value->toString ().c_str (), s);\n      return string (s);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unparseBoolean",
          "args": [
            "value"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "unparseBoolean",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "114-122",
          "snippet": "const string\nAnyAgent::unparseBoolean (const YCPValue & value)\n{\n    if ((value.isNull ()) || (!value->isBoolean ()))\n\treturn \"\";\n\n    y2debug (\"unparseBoolean (%s)\", value->toString ().c_str ());\n    return value->asBoolean ()->value () ? \"yes\" : \"no\";\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseBoolean (const YCPValue & value)\n  {\n      if ((value.isNull ()) || (!value->isBoolean ()))\n  \treturn \"\";\n  \n      y2debug (\"unparseBoolean (%s)\", value->toString ().c_str ());\n      return value->asBoolean ()->value () ? \"yes\" : \"no\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unparseNumber",
          "args": [
            "value"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "unparseNumber",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "150-162",
          "snippet": "const string\nAnyAgent::unparseNumber (const YCPValue & value)\n{\n    if ((value.isNull ()) || (!value->isInteger ()))\n\treturn \"\";\n\n    // (64bit signed max) -> 9223372036854775807L\n    char s[32];\n    sprintf (s, \"%Ld\", value->asInteger ()->value ());\n\n    y2debug (\"unparseNumber (%s, %s)\", value->toString ().c_str (), s);\n    return string (s);\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseNumber (const YCPValue & value)\n  {\n      if ((value.isNull ()) || (!value->isInteger ()))\n  \treturn \"\";\n  \n      // (64bit signed max) -> 9223372036854775807L\n      char s[32];\n      sprintf (s, \"%Ld\", value->asInteger ()->value ());\n  \n      y2debug (\"unparseNumber (%s, %s)\", value->toString ().c_str (), s);\n      return string (s);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unparseString",
          "args": [
            "term->value (0)",
            "term->value (1)",
            "value"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "unparseString",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "270-302",
          "snippet": "const string\nAnyAgent::unparseString (const YCPValue & syntax, const YCPValue & stripped,\n\t\t\t const YCPValue & value)\n{\n    if ((value.isNull ()) || (!value->isString ()) ||\n\t(syntax.isNull ()) || (!syntax->isString ()))\n\treturn \"\";\n\n    const char *v = value->asString ()->value ().c_str ();\n    const char *set = syntax->asString ()->value ().c_str ();\n\n    string s;\n\n    if (*v != 0)\n    {\n\ts.reserve (strlen (v));\n\tif (*set == '^')\n\t{\n\t    set++;\n\t    while (*v != 0 && strchr (set, *v) == 0)\n\t\ts += *v++;\n\t}\n\telse\n\t{\n\t    while (*v != 0 && strchr (set, *v) != 0)\n\t\ts += *v++;\n\t}\n    }\n\n    y2debug (\"unparseString (%s[%s],%s)\", value->toString ().c_str (), set,\n\t     s.c_str ());\n    return s;\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseString (const YCPValue & syntax, const YCPValue & stripped,\n  \t\t\t const YCPValue & value)\n  {\n      if ((value.isNull ()) || (!value->isString ()) ||\n  \t(syntax.isNull ()) || (!syntax->isString ()))\n  \treturn \"\";\n  \n      const char *v = value->asString ()->value ().c_str ();\n      const char *set = syntax->asString ()->value ().c_str ();\n  \n      string s;\n  \n      if (*v != 0)\n      {\n  \ts.reserve (strlen (v));\n  \tif (*set == '^')\n  \t{\n  \t    set++;\n  \t    while (*v != 0 && strchr (set, *v) == 0)\n  \t\ts += *v++;\n  \t}\n  \telse\n  \t{\n  \t    while (*v != 0 && strchr (set, *v) != 0)\n  \t\ts += *v++;\n  \t}\n      }\n  \n      y2debug (\"unparseString (%s[%s],%s)\", value->toString ().c_str (), set,\n  \t     s.c_str ());\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparseSeparator",
          "args": [
            "YCPString (\" \\t\")"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "unparseSeparator",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "521-534",
          "snippet": "const string\nAnyAgent::unparseSeparator (const YCPValue & value)\n{\n    if ((value.isNull ()) || (!value->isString ()))\n\treturn \"\";\n\n    const char *v = value->asString ()->value ().c_str ();\n\n    if (*v == 0)\n\treturn \"\";\n\n    y2debug (\"unparseSeparator (%c)\", *v);\n    return string (1, *v);\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseSeparator (const YCPValue & value)\n  {\n      if ((value.isNull ()) || (!value->isString ()))\n  \treturn \"\";\n  \n      const char *v = value->asString ()->value ().c_str ();\n  \n      if (*v == 0)\n  \treturn \"\";\n  \n      y2debug (\"unparseSeparator (%c)\", *v);\n      return string (1, *v);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tupleValue.top",
          "args": [],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"unparse Name ()\""
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vdata.empty",
          "args": [],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tupleValue.pop",
          "args": [],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "pop",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "159-167",
          "snippet": "void\nSymbolEntry::pop ()\n{\n    if (! m_recurse_stack)\n\treturn;\n\n    m_value = m_recurse_stack->top ();\n    m_recurse_stack->pop ();\n}",
          "includes": [
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  void\n  SymbolEntry::pop ()\n  {\n      if (! m_recurse_stack)\n  \treturn;\n  \n      m_value = m_recurse_stack->top ();\n      m_recurse_stack->pop ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unparseTuple",
          "args": [
            "term->args ()",
            "value"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "unparseTuple",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "374-423",
          "snippet": "const string\nAnyAgent::unparseTuple (const YCPList & syntax, const YCPValue & value)\n{\n    if (syntax.isNull () || value.isNull ())\n\treturn \"\";\n\n    y2debug (\"unparseTuple ('%s',%s)\", syntax->toString ().c_str (),\n\t     value->toString ().c_str ());\n    if (!value->isMap ())\n    {\n\ty2error (\"unparseTuple: value has wrong type\");\n\treturn \"\";\n    }\n\n    int ssize = syntax->size ();\n    string s;\n\n    // if Fillup allowed and defined, initialize s with it\n\n    if (isFillup)\n    {\n\tYCPMap map = value->asMap ();\n\tYCPValue fillup = map->value (YCPString (KEY4FILLUP));\n\tif ((!fillup.isNull ()) && fillup->isString ())\n\t    s += fillup->asString ()->value ();\n    }\n\n    for (int i = 0; i < ssize; i++)\n    {\n\tconst YCPValue & element = syntax->value (i);\n\tconst string data = unparseData (element, value);\n\tif (data.empty ())\n\t{\n\t    y2debug (\"unparseTuple fail ? ('%s',%s)\",\n\t\t     element->toString ().c_str (), value->toString ().c_str ());\n\t    if (element->valuetype () == YT_TERM)\n\t    {\n\t\tYCPTerm term = element->asTerm ();\n\t\tif (!(term.isNull ()) && \n\t\t    ((term->name () == \"Skip\") ||\n\t\t     (term->name () == \"Fillup\")))\n\t\t    continue;\n\t    }\n\t    break;\n\t}\n\ts += data;\n    }\n\n    return s;\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define KEY4FILLUP \"`FILLUP\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define KEY4FILLUP \"`FILLUP\"\n\nAnyAgent {\n  const string\n  AnyAgent::unparseTuple (const YCPList & syntax, const YCPValue & value)\n  {\n      if (syntax.isNull () || value.isNull ())\n  \treturn \"\";\n  \n      y2debug (\"unparseTuple ('%s',%s)\", syntax->toString ().c_str (),\n  \t     value->toString ().c_str ());\n      if (!value->isMap ())\n      {\n  \ty2error (\"unparseTuple: value has wrong type\");\n  \treturn \"\";\n      }\n  \n      int ssize = syntax->size ();\n      string s;\n  \n      // if Fillup allowed and defined, initialize s with it\n  \n      if (isFillup)\n      {\n  \tYCPMap map = value->asMap ();\n  \tYCPValue fillup = map->value (YCPString (KEY4FILLUP));\n  \tif ((!fillup.isNull ()) && fillup->isString ())\n  \t    s += fillup->asString ()->value ();\n      }\n  \n      for (int i = 0; i < ssize; i++)\n      {\n  \tconst YCPValue & element = syntax->value (i);\n  \tconst string data = unparseData (element, value);\n  \tif (data.empty ())\n  \t{\n  \t    y2debug (\"unparseTuple fail ? ('%s',%s)\",\n  \t\t     element->toString ().c_str (), value->toString ().c_str ());\n  \t    if (element->valuetype () == YT_TERM)\n  \t    {\n  \t\tYCPTerm term = element->asTerm ();\n  \t\tif (!(term.isNull ()) && \n  \t\t    ((term->name () == \"Skip\") ||\n  \t\t     (term->name () == \"Fillup\")))\n  \t\t    continue;\n  \t    }\n  \t    break;\n  \t}\n  \ts += data;\n      }\n  \n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->args",
          "args": [],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "args",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "58-62",
          "snippet": "YCPList\nYCPTermRep::args() const\n{\n    return l;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPList\n  YCPTermRep::args() const\n  {\n      return l;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tupleValue.push",
          "args": [
            "YCPNull ()"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleName.push",
          "args": [
            "\"\""
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparseList",
          "args": [
            "term->args ()",
            "value"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "unparseList",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "253-312",
          "snippet": "const string\nAnyAgent::unparseList (const YCPList & syntax, const YCPValue & value)\n{\n    if (syntax.isNull () || value.isNull ())\n\treturn \"\";\n\n    y2debug (\"unparseList ('%s',%s)\", syntax->toString ().c_str (),\n\t     value->toString ().c_str ());\n\n    if (!value->isList ())\n    {\n\ty2error (\"unparseList: value has wrong type\");\n\treturn \"\";\n    }\n    YCPList list = value->asList ();\n\n    string s;\n    int lsize = list->size ();\n\n    y2debug (\"unparseList (%d: '%s')\", lsize, list->toString ().c_str ());\n\n    if (lsize > 0)\n    {\n\tfor (int i = 0; i < lsize; i++)\n\t{\n\t    const string data = unparseData (syntax->value (0), list->value (i));\n\t    if (data.empty ())\n\t\tbreak;\n\t    string cont;\n\t    if (i < lsize - 1)\n\t    {\n\t\tconst YCPValue & element = syntax->value (1);\n\t\tcont = unparseData (element, YCPNull ());\n\t\tif (cont.empty ())\n\t\t{\n\t\t    if (element->valuetype () != YT_TERM)\n\t\t\tbreak;\n\t\t    else\n\t\t    {\n\t\t\tYCPTerm term = element->asTerm ();\n\t\t\tif ((term.isNull ())\n\t\t\t    || ((term->name () != \"Skip\")\n\t\t\t\t&& (term->name () !=\n\t\t\t\t    \"Fillup\")))\n\t\t\t{\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    else\t\t// no continuation after last list element\n\t\tcont = \"\";\n\n\t    s += data;\n\t    s += cont;\n\t}\n    }\n\n    return s;\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseList (const YCPList & syntax, const YCPValue & value)\n  {\n      if (syntax.isNull () || value.isNull ())\n  \treturn \"\";\n  \n      y2debug (\"unparseList ('%s',%s)\", syntax->toString ().c_str (),\n  \t     value->toString ().c_str ());\n  \n      if (!value->isList ())\n      {\n  \ty2error (\"unparseList: value has wrong type\");\n  \treturn \"\";\n      }\n      YCPList list = value->asList ();\n  \n      string s;\n      int lsize = list->size ();\n  \n      y2debug (\"unparseList (%d: '%s')\", lsize, list->toString ().c_str ());\n  \n      if (lsize > 0)\n      {\n  \tfor (int i = 0; i < lsize; i++)\n  \t{\n  \t    const string data = unparseData (syntax->value (0), list->value (i));\n  \t    if (data.empty ())\n  \t\tbreak;\n  \t    string cont;\n  \t    if (i < lsize - 1)\n  \t    {\n  \t\tconst YCPValue & element = syntax->value (1);\n  \t\tcont = unparseData (element, YCPNull ());\n  \t\tif (cont.empty ())\n  \t\t{\n  \t\t    if (element->valuetype () != YT_TERM)\n  \t\t\tbreak;\n  \t\t    else\n  \t\t    {\n  \t\t\tYCPTerm term = element->asTerm ();\n  \t\t\tif ((term.isNull ())\n  \t\t\t    || ((term->name () != \"Skip\")\n  \t\t\t\t&& (term->name () !=\n  \t\t\t\t    \"Fillup\")))\n  \t\t\t{\n  \t\t\t    break;\n  \t\t\t}\n  \t\t    }\n  \t\t}\n  \t    }\n  \t    else\t\t// no continuation after last list element\n  \t\tcont = \"\";\n  \n  \t    s += data;\n  \t    s += cont;\n  \t}\n      }\n  \n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unparseSequence",
          "args": [
            "term->args ()",
            "value"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "unparseSequence",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "209-213",
          "snippet": "const string\nAnyAgent::unparseSequence (const YCPList & syntax, const YCPValue & value)\n{\n    return \"\";\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseSequence (const YCPList & syntax, const YCPValue & value)\n  {\n      return \"\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tupleValue.push",
          "args": [
            "YCPNull ()"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleName.push",
          "args": [
            "\"\""
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparseChoice",
          "args": [
            "term->args ()",
            "value"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "unparseChoice",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "166-170",
          "snippet": "const string\nAnyAgent::unparseChoice (const YCPList & syntax, const YCPValue & value)\n{\n    return \"\";\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseChoice (const YCPList & syntax, const YCPValue & value)\n  {\n      return \"\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YT_TERM (%s)\"",
            "s.c_str ()"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.c_str",
          "args": [],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term->name",
          "args": [],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2AgentComp",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "44-44",
          "snippet": "string name () const { return my_name; }",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp {\n  string name () const { return my_name; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"YT_TERM no term\""
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term.isNull",
          "args": [],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syntax->asTerm",
          "args": [],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "syntax->valuetype",
          "args": [],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "YCPSymbolRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "69-73",
          "snippet": "YCPValueType\nYCPSymbolRep::valuetype() const\n{\n    return YT_SYMBOL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbolRep {\n  YCPValueType\n  YCPSymbolRep::valuetype() const\n  {\n      return YT_SYMBOL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"unparseData ('%s',%s)\"",
            "value.isNull () ? \"\" : value->toString ().c_str ()",
            "syntax->toString ().c_str ()"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syntax.isNull",
          "args": [],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseData (const YCPValue & syntax, const YCPValue & value)\n  {\n      if (syntax.isNull ())\n  \treturn \"\";\n  \n      y2debug (\"unparseData ('%s',%s)\", value.isNull () ? \"\" : value->toString ().c_str (),\n  \t     syntax->toString ().c_str ());\n  \n      switch (syntax->valuetype ())\n      {\n  \tcase YT_TERM: {\n  \n  \t    YCPTerm term = syntax->asTerm ();\n  \t    if (term.isNull ())\n  \t    {\n  \t\ty2error (\"YT_TERM no term\");\n  \t    }\n  \t    string s = term->name ();\n  \t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n  \n  \t    // Optional\n  \n  \t    if (s == \"Optional\" && term->size () > 0)\n  \t    {\n  \t\treturn unparseData (term->value (0), value);\n  \t    }\n  \n  \t    // Continue\n  \n  \t    else if (s == \"Continue\" && term->size () > 0)\n  \t    {\n  \t\tif (tupleContinue)\n  \t\t    return unparseData (term->value (0), value);\n  \t    }\n  \n  \t    // Choice\n  \n  \t    else if (s == \"Choice\" && term->size () > 0)\n  \t    {\n  \t\treturn unparseChoice (term->args (), value);\n  \t    }\n  \n  \t    // Sequence\n  \n  \t    else if (s == \"Sequence\" && term->size () > 0)\n  \t    {\n  \t\ttupleName.push (\"\");\n  \t\ttupleValue.push (YCPNull ());\n  \t\tconst string s = unparseSequence (term->args (), value);\n  \t\ttupleName.pop ();\n  \t\ttupleValue.pop ();\n  \t\treturn s;\n  \t    }\n  \n  \t    // List\n  \n  \t    else if (s == \"List\" && term->size () == 2)\n  \t    {\n  \t\treturn unparseList (term->args (), value);\n  \t    }\n  \n  \t    // Tuple\n  \n  \t    else if (s == \"Tuple\" && term->size () > 0)\n  \t    {\n  \t\ttupleName.push (\"\");\n  \t\ttupleValue.push (YCPNull ());\n  \t\tconst string s = unparseTuple (term->args (), value);\n  \t\ttupleName.pop ();\n  \t\ttupleValue.pop ();\n  \t\treturn s;\n  \t    }\n  \n  \t    // Var\n  \n  \t    else if (s == \"Var\" && term->size () > 0)\n  \t    {\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    const string vdata = unparseData (term->value (i), value);\n  \t\t    if (vdata.empty ())\n  \t\t\tbreak;\n  \t\t}\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // Name\n  \n  \t    else if (s == \"Name\" && term->size () == 1)\n  \t    {\n  \t\ty2error (\"unparse Name ()\");\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // Value\n  \n  \t    else if (s == \"Value\" && term->size () == 1)\n  \t    {\n  \t\tconst string s = unparseData (term->value (0), value);\n  #if 0\n  \t\tif (tv && tupleValue.size () > 0)\n  \t\t    tupleValue.top () = tv;\n  #endif\n  \t\treturn s;\n  \t    }\n  \n  \t    // Separator\n  \n  \t    else if (s == \"Separator\" && term->size () == 1)\n  \t    {\n  \t\treturn unparseSeparator (term->value (0));\n  \t    }\n  \n  \t    // Whitespace\n  \n  \t    else if (s == \"Whitespace\")\n  \t    {\n  \t\treturn unparseSeparator (YCPString (\" \\t\"));\n  \t    }\n  \n  \t    // Skip (is handled correctly within unparseTuple()\n  \n  \t    else if (s == \"Skip\")\n  \t    {\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // Fillup (is handled correctly within unparseTuple()\n  \n  \t    else if (s == \"Fillup\")\n  \t    {\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // String\n  \n  \t    else if (s == \"String\" && term->size () > 0)\n  \t    {\n  \t\tif (term->size () == 1)\n  \t\t    return unparseString (term->value (0), YCPNull (), value);\n  \t\tif (term->size () == 2)\n  \t\t    return unparseString (term->value (0), term->value (1),\n  \t\t\t\t\t  value);\n  \t    }\n  \n  \t    // Or\n  \n  \t    else if (s == \"Or\" && term->size () == 2)\n  \t    {\n  #if 1\n  \t\tconst YCPValue vbackup = value;\n  \t\tconst string vdata = unparseData (term->value (0), value);\n  \t\tif (vdata != \"\")\n  \t\t    return vdata;\n  \t\telse\n  \t\t    return unparseData (term->value (1), vbackup);\n  #endif\n  \t    }\n  \n  \t    // Number\n  \n  \t    else if (s == \"Number\")\n  \t    {\n  \t\treturn unparseNumber (value);\n  \t    }\n  \n  \t    // Boolean\n  \n  \t    else if (s == \"Boolean\")\n  \t    {\n  \t\treturn unparseBoolean (value);\n  \t    }\n  \n  \t    // Float\n  \n  \t    else if (s == \"Float\")\n  \t    {\n  \t\treturn unparseFloat (value);\n  \t    }\n  \n  \t    // Ip4Number\n  \n  \t    else if (s == \"Ip4Number\")\n  \t    {\n  \t\treturn unparseIp4Number (value);\n  \t    }\n  \n  \t    // Hostname\n  \n  \t    else if (s == \"Hostname\")\n  \t    {\n  \t\treturn unparseHostname (value);\n  \t    }\n  \n  \t    // Username\n  \n  \t    else if (s == \"Username\")\n  \t    {\n  \t\treturn unparseUsername (value);\n  \t    }\n  \n  \t    // <name> (<syntax>)\n  \n  \t    else if (islower (s[0]) && (term->size () == 1))\n  \t    {\n  \t\tif (!value->isMap ())\n  \t\t    y2error (\"request for element '%s' but value not map\",\n  \t\t\t     s.c_str ());\n  \t\telse\n  \t\t{\n  \t\t    YCPValue v = value->asMap ()->value (YCPString (s));\n  \t\t    if (v.isNull ())\n  \t\t    {\n  \t\t\ty2error (\"No value for key '%s' in map\", s.c_str ());\n  \t\t\treturn \"\";\n  \t\t    }\n  \t\t    return unparseData (term->value (0), v);\n  \t\t}\n  \t    }\n  \n  \t    else\n  \t    {\n  \t\ty2error (\"unparseData: unknown term '%s'\", s.c_str ());\n  \t\treturn \"\";\n  \t    }\n  \t} break;\n  \n  \tcase YT_STRING:\n  \t    y2debug (\"YT_STRING\");\n  \t    return unparseVerbose (syntax);\n  \t    break;\n  \n  \tdefault:\n  \t    y2error (\"unparseData: unknown syntax %s\", syntax->toString ().c_str ());\n  \t    break;\n      }\n  \n      return \"\";\n  }\n}"
  },
  {
    "function_name": "parseData",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
    "lines": "429-705",
    "snippet": "YCPValue\nAnyAgent::parseData (char const *&line, const YCPValue & syntax, bool optional)\n{\n    if ((line == 0) || (*line == 0))\n\tline = getLine ();\n    if (line == 0)\n\treturn YCPNull ();\n    if (syntax.isNull ())\n\treturn YCPNull ();\n\n    y2debug (\"parseData %s('%s',[%s])\", (optional ? \"?\" : \"!\"), line,\n\t     syntax->toString ().c_str ());\n\n    switch (syntax->valuetype ())\n    {\n\tcase YT_TERM: {\n\n\t    YCPTerm term = syntax->asTerm ();\n\t    const string s = term->name ();\n\t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n\n\t    // Optional\n\n\t    if (s == \"Optional\" && term->size () > 0)\n\t    {\n\t\tYCPValue ov = parseData (line, term->value (0), true);\n\t\tif (ov.isNull ())\n\t\t    ov = YCPVoid ();\n\t\treturn ov;\n\t    }\n\n\t    // Continue\n\n\t    else if (s == \"Continue\" && term->size () > 0)\n\t    {\n\t\tYCPValue tv = parseData (line, term->value (0), false);\n\t\tif (!tv.isNull ())\n\t\t    tupleContinue = true;\n\t\treturn tv;\n\t    }\n\n\t    // Choice\n\n\t    else if (s == \"Choice\" && term->size () > 0)\n\t    {\n\t\treturn parseChoice (line, term->args (), optional);\n\t    }\n\n\t    // Sequence\n\n\t    else if (s == \"Sequence\" && term->size () > 0)\n\t    {\n\t\treturn parseSequence (line, term->args (), optional);\n\t    }\n\n\t    // List\n\n\t    else if (s == \"List\" && term->size () == 2)\n\t    {\n\t\treturn parseList (line, term->args (), optional);\n\t    }\n\n\t    // Tuple\n\n\t    else if (s == \"Tuple\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tYCPValue tv = parseTuple (line, term->args (), optional);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn tv;\n\t    }\n\n\t    // Var\n\n\t    else if (s == \"Var\" && term->size () > 0)\n\t    {\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    if (parseData (line, term->value (i), optional).isNull ())\n\t\t\tbreak;\n\t\t}\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Name\n\n\t    else if (s == \"Name\" && term->size () == 1)\n\t    {\n\t\tif (!mReadOnly)\n\t\t{\n\t\t    y2error (\"'Name' not allowed for writable agents\");\n\t\t    return YCPNull ();\n\t\t}\n\t\tYCPValue tn = parseData (line, term->value (0), false);\n\t\tif (!tn.isNull () && tupleName.size () > 0)\n\t\t{\n\t\t    if (tn->isString ())\n\t\t\ttupleName.top () = tn->asString ()->value ();\n\t\t    else\n\t\t\ttupleName.top () = tn->toString ();\n\t\t    y2debug (\"Name: %s\", tn->toString ().c_str ());\n\t\t}\n\t\treturn tn;\n\t    }\n\n\t    // Value\n\n\t    else if (s == \"Value\" && term->size () == 1)\n\t    {\n\t\tYCPValue tv = parseData (line, term->value (0), false);\n\t\tif (!tv.isNull () && tupleValue.size () > 0)\n\t\t    tupleValue.top () = tv;\n\t\t// y2debug (\"Value: %p\", tv);\n\t\treturn tv;\n\t    }\n\n\t    // Fillup\n\n\t    else if (isFillup && (s == \"Fillup\") &&\t// fillup allowed and Fillup () found\n\t\t     (term->size () == 0) && (tupleName.size () > 0))\n\t    {\t\t// inside Tuple ()\n\t\tstring fillup;\n\t\twhile ((line != 0)\n\t\t       && (mComment.find_first_of (line[0]) != string::npos))\n\t\t{\n\t\t    fillup = fillup + line;\n\t\t    line = getLine ();\n\t\t}\n\t\ttupleName.top () = KEY4FILLUP;\n\t\ttupleValue.top () = YCPString (fillup);\n\t\treturn tupleValue.top ();\n\t    }\n\n\t    // Skip\n\n\t    else if (s == \"Skip\")\n\t    {\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Match\n\n\t    else if (s == \"Match\")\n\t    {\n\t\treturn currentMatch;\n\t    }\n\n\t    // Separator\n\n\t    else if (s == \"Separator\" && term->size () == 1)\n\t    {\n\t\treturn parseSeparator (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t       optional);\n\t    }\n\n\t    // Whitespace\n\n\t    else if (s == \"Whitespace\")\n\t    {\n\t\treturn parseSeparator (line, \" \\t\", optional);\n\t    }\n\n\t    // String\n\n\t    else if (s == \"String\" && term->size () > 0)\n\t    {\n\t\tif (term->size () == 1)\n\t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t\t0, optional);\n\t\tif (term->size () == 2)\n\t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t\tterm->value (1)->asString ()->value ().c_str (),\n\t\t\t\t\toptional);\n\t    }\n\n\t    // Or\n\n\t    else if (s == \"Or\" && term->size () > 0)\n\t    {\n\t\tconst char *ltry = line;\n\t\tbool lopt = false;\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    if (i == term->size () - 1)\t// pass optional on last try\n\t\t\tlopt = optional;\n\t\t    YCPValue vtry = parseData (ltry, term->value (i), lopt);\n\t\t    if (!vtry.isNull ())\n\t\t    {\n\t\t\ty2debug (\"Or () success\");\n\t\t\tline = ltry;\n\t\t\treturn vtry;\n\t\t    }\n\t\t}\n\t\ty2debug (\"Or () failed\");\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Number\n\n\t    else if (s == \"Number\")\n\t    {\n\t\treturn parseNumber (line, optional);\n\t    }\n\n\t    // Hexval\n\n\t    else if (s == \"Hexval\")\n\t    {\n\t\treturn parseHexval (line, optional);\n\t    }\n\n\t    // Boolean\n\n\t    else if (s == \"Boolean\")\n\t    {\n\t\treturn parseBoolean (line, optional);\n\t    }\n\n\t    // Float\n\n\t    else if (s == \"Float\")\n\t    {\n\t\treturn parseFloat (line, optional);\n\t    }\n\n\t    // Ip4Number\n\n\t    else if (s == \"Ip4Number\")\n\t    {\n\t\treturn parseIp4Number (line, optional);\n\t    }\n\n\t    // Hostname\n\n\t    else if (s == \"Hostname\")\n\t    {\n\t\treturn parseHostname (line, optional);\n\t    }\n\n\t    // Username\n\n\t    else if (s == \"Username\")\n\t    {\n\t\treturn parseUsername (line, optional);\n\t    }\n\n\t    // <name>\n\n\t    else if (islower (s[0]) && tupleName.size () > 0 && (term->size () == 1))\n\t    {\n\t\ttupleName.top () = s;\n\t\ttupleValue.top () = parseData (line, term->value (0), optional);\n\t\treturn tupleValue.top ();\n\t    }\n\n\t    else\n\t    {\n\t\ty2error (\"parseData: unknown term '%s'\", s.c_str ());\n\t\treturn YCPVoid ();\n\t    }\n\t} break;\n\n\tcase YT_STRING:\n\t    y2debug (\"YT_STRING\");\n\t    return parseVerbose (line, syntax->asString ()->value ().c_str (),\n\t\t\t\t optional);\n\t    break;\n\n\tdefault:\n\t    y2error (\"parseData: unknown syntax %s\", syntax->toString ().c_str ());\n\t    break;\n    }\n\n    return YCPNull ();\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define KEY4FILLUP \"`FILLUP\""
    ],
    "globals_used": [
      "static YCPValue currentMatch = YCPNull ();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"parseData: unknown syntax %s\"",
            "syntax->toString ().c_str ()"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syntax->toString",
          "args": [],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseVerbose",
          "args": [
            "line",
            "syntax->asString ()->value ().c_str ()",
            "optional"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "parseVerbose",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "466-482",
          "snippet": "YCPValue\nAnyAgent::parseVerbose (char const *&lptr, const char *match, bool optional)\n{\n    const int n = strlen (match);\n\n    if (strncmp (lptr, match, n) == 0)\n    {\n\tconst char * start = lptr;\n\tlptr += n;\n\treturn YCPString (string (start, n));\n    }\n\n    if (optional)\n\treturn YCPVoid ();\n\n    return YCPNull ();\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseVerbose (char const *&lptr, const char *match, bool optional)\n  {\n      const int n = strlen (match);\n  \n      if (strncmp (lptr, match, n) == 0)\n      {\n  \tconst char * start = lptr;\n  \tlptr += n;\n  \treturn YCPString (string (start, n));\n      }\n  \n      if (optional)\n  \treturn YCPVoid ();\n  \n      return YCPNull ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "syntax->asString",
          "args": [],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YT_STRING\""
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"parseData: unknown term '%s'\"",
            "s.c_str ()"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.c_str",
          "args": [],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleValue.top",
          "args": [],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseData",
          "args": [
            "line",
            "term->value (0)",
            "optional"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "parseData",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "429-705",
          "snippet": "YCPValue\nAnyAgent::parseData (char const *&line, const YCPValue & syntax, bool optional)\n{\n    if ((line == 0) || (*line == 0))\n\tline = getLine ();\n    if (line == 0)\n\treturn YCPNull ();\n    if (syntax.isNull ())\n\treturn YCPNull ();\n\n    y2debug (\"parseData %s('%s',[%s])\", (optional ? \"?\" : \"!\"), line,\n\t     syntax->toString ().c_str ());\n\n    switch (syntax->valuetype ())\n    {\n\tcase YT_TERM: {\n\n\t    YCPTerm term = syntax->asTerm ();\n\t    const string s = term->name ();\n\t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n\n\t    // Optional\n\n\t    if (s == \"Optional\" && term->size () > 0)\n\t    {\n\t\tYCPValue ov = parseData (line, term->value (0), true);\n\t\tif (ov.isNull ())\n\t\t    ov = YCPVoid ();\n\t\treturn ov;\n\t    }\n\n\t    // Continue\n\n\t    else if (s == \"Continue\" && term->size () > 0)\n\t    {\n\t\tYCPValue tv = parseData (line, term->value (0), false);\n\t\tif (!tv.isNull ())\n\t\t    tupleContinue = true;\n\t\treturn tv;\n\t    }\n\n\t    // Choice\n\n\t    else if (s == \"Choice\" && term->size () > 0)\n\t    {\n\t\treturn parseChoice (line, term->args (), optional);\n\t    }\n\n\t    // Sequence\n\n\t    else if (s == \"Sequence\" && term->size () > 0)\n\t    {\n\t\treturn parseSequence (line, term->args (), optional);\n\t    }\n\n\t    // List\n\n\t    else if (s == \"List\" && term->size () == 2)\n\t    {\n\t\treturn parseList (line, term->args (), optional);\n\t    }\n\n\t    // Tuple\n\n\t    else if (s == \"Tuple\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tYCPValue tv = parseTuple (line, term->args (), optional);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn tv;\n\t    }\n\n\t    // Var\n\n\t    else if (s == \"Var\" && term->size () > 0)\n\t    {\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    if (parseData (line, term->value (i), optional).isNull ())\n\t\t\tbreak;\n\t\t}\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Name\n\n\t    else if (s == \"Name\" && term->size () == 1)\n\t    {\n\t\tif (!mReadOnly)\n\t\t{\n\t\t    y2error (\"'Name' not allowed for writable agents\");\n\t\t    return YCPNull ();\n\t\t}\n\t\tYCPValue tn = parseData (line, term->value (0), false);\n\t\tif (!tn.isNull () && tupleName.size () > 0)\n\t\t{\n\t\t    if (tn->isString ())\n\t\t\ttupleName.top () = tn->asString ()->value ();\n\t\t    else\n\t\t\ttupleName.top () = tn->toString ();\n\t\t    y2debug (\"Name: %s\", tn->toString ().c_str ());\n\t\t}\n\t\treturn tn;\n\t    }\n\n\t    // Value\n\n\t    else if (s == \"Value\" && term->size () == 1)\n\t    {\n\t\tYCPValue tv = parseData (line, term->value (0), false);\n\t\tif (!tv.isNull () && tupleValue.size () > 0)\n\t\t    tupleValue.top () = tv;\n\t\t// y2debug (\"Value: %p\", tv);\n\t\treturn tv;\n\t    }\n\n\t    // Fillup\n\n\t    else if (isFillup && (s == \"Fillup\") &&\t// fillup allowed and Fillup () found\n\t\t     (term->size () == 0) && (tupleName.size () > 0))\n\t    {\t\t// inside Tuple ()\n\t\tstring fillup;\n\t\twhile ((line != 0)\n\t\t       && (mComment.find_first_of (line[0]) != string::npos))\n\t\t{\n\t\t    fillup = fillup + line;\n\t\t    line = getLine ();\n\t\t}\n\t\ttupleName.top () = KEY4FILLUP;\n\t\ttupleValue.top () = YCPString (fillup);\n\t\treturn tupleValue.top ();\n\t    }\n\n\t    // Skip\n\n\t    else if (s == \"Skip\")\n\t    {\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Match\n\n\t    else if (s == \"Match\")\n\t    {\n\t\treturn currentMatch;\n\t    }\n\n\t    // Separator\n\n\t    else if (s == \"Separator\" && term->size () == 1)\n\t    {\n\t\treturn parseSeparator (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t       optional);\n\t    }\n\n\t    // Whitespace\n\n\t    else if (s == \"Whitespace\")\n\t    {\n\t\treturn parseSeparator (line, \" \\t\", optional);\n\t    }\n\n\t    // String\n\n\t    else if (s == \"String\" && term->size () > 0)\n\t    {\n\t\tif (term->size () == 1)\n\t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t\t0, optional);\n\t\tif (term->size () == 2)\n\t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t\tterm->value (1)->asString ()->value ().c_str (),\n\t\t\t\t\toptional);\n\t    }\n\n\t    // Or\n\n\t    else if (s == \"Or\" && term->size () > 0)\n\t    {\n\t\tconst char *ltry = line;\n\t\tbool lopt = false;\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    if (i == term->size () - 1)\t// pass optional on last try\n\t\t\tlopt = optional;\n\t\t    YCPValue vtry = parseData (ltry, term->value (i), lopt);\n\t\t    if (!vtry.isNull ())\n\t\t    {\n\t\t\ty2debug (\"Or () success\");\n\t\t\tline = ltry;\n\t\t\treturn vtry;\n\t\t    }\n\t\t}\n\t\ty2debug (\"Or () failed\");\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Number\n\n\t    else if (s == \"Number\")\n\t    {\n\t\treturn parseNumber (line, optional);\n\t    }\n\n\t    // Hexval\n\n\t    else if (s == \"Hexval\")\n\t    {\n\t\treturn parseHexval (line, optional);\n\t    }\n\n\t    // Boolean\n\n\t    else if (s == \"Boolean\")\n\t    {\n\t\treturn parseBoolean (line, optional);\n\t    }\n\n\t    // Float\n\n\t    else if (s == \"Float\")\n\t    {\n\t\treturn parseFloat (line, optional);\n\t    }\n\n\t    // Ip4Number\n\n\t    else if (s == \"Ip4Number\")\n\t    {\n\t\treturn parseIp4Number (line, optional);\n\t    }\n\n\t    // Hostname\n\n\t    else if (s == \"Hostname\")\n\t    {\n\t\treturn parseHostname (line, optional);\n\t    }\n\n\t    // Username\n\n\t    else if (s == \"Username\")\n\t    {\n\t\treturn parseUsername (line, optional);\n\t    }\n\n\t    // <name>\n\n\t    else if (islower (s[0]) && tupleName.size () > 0 && (term->size () == 1))\n\t    {\n\t\ttupleName.top () = s;\n\t\ttupleValue.top () = parseData (line, term->value (0), optional);\n\t\treturn tupleValue.top ();\n\t    }\n\n\t    else\n\t    {\n\t\ty2error (\"parseData: unknown term '%s'\", s.c_str ());\n\t\treturn YCPVoid ();\n\t    }\n\t} break;\n\n\tcase YT_STRING:\n\t    y2debug (\"YT_STRING\");\n\t    return parseVerbose (line, syntax->asString ()->value ().c_str (),\n\t\t\t\t optional);\n\t    break;\n\n\tdefault:\n\t    y2error (\"parseData: unknown syntax %s\", syntax->toString ().c_str ());\n\t    break;\n    }\n\n    return YCPNull ();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "term->value",
          "args": [
            "0"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tupleValue.top",
          "args": [],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleName.top",
          "args": [],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term->size",
          "args": [],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "islower",
          "args": [
            "s[0]"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseUsername",
          "args": [
            "line",
            "optional"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "parseUsername",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "418-439",
          "snippet": "YCPValue\nAnyAgent::parseUsername (char const *&lptr, bool optional)\n{\n    const char * start = lptr;\n\n    if (!isalpha (*lptr))\n    {\n\tif (!optional)\n\t    y2error (\"*** bad username\");\n\treturn YCPNull ();\n    }\n\n    while (*lptr)\n    {\n\tif (!isalnum (*lptr))\n\t    break;\n\tlptr++;\n    }\n\n    string s (start, lptr - start);\n    return YCPString (s);\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseUsername (char const *&lptr, bool optional)\n  {\n      const char * start = lptr;\n  \n      if (!isalpha (*lptr))\n      {\n  \tif (!optional)\n  \t    y2error (\"*** bad username\");\n  \treturn YCPNull ();\n      }\n  \n      while (*lptr)\n      {\n  \tif (!isalnum (*lptr))\n  \t    break;\n  \tlptr++;\n      }\n  \n      string s (start, lptr - start);\n      return YCPString (s);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseHostname",
          "args": [
            "line",
            "optional"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "parseHostname",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "350-387",
          "snippet": "YCPValue\nAnyAgent::parseHostname (char const *&lptr, bool optional)\n{\n    const char * start = lptr;\n\n    if (!isalpha (*lptr))\n    {\n\tif (!optional)\n\t    y2error (\"*** bad hostname\");\n\treturn YCPNull ();\n    }\n\n    while (*lptr)\n    {\n\tif (!isalnum (*lptr))\n\t{\n\t    int stop = 0;\n\t    switch (*lptr)\n\t    {\n\t\tcase '_':\n\t\t    break;\n\t\tcase '.':\n\t\t    if (!isalpha (*(lptr + 1)))\n\t\t\tstop = 1;\n\t\t    break;\n\t\tdefault:\n\t\t    stop = 1;\n\t\t    break;\n\t    }\n\t    if (stop)\n\t\tbreak;\n\t}\n\tlptr++;\n    }\n\n    string s (start, lptr - start);\n    return YCPString (s);\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseHostname (char const *&lptr, bool optional)\n  {\n      const char * start = lptr;\n  \n      if (!isalpha (*lptr))\n      {\n  \tif (!optional)\n  \t    y2error (\"*** bad hostname\");\n  \treturn YCPNull ();\n      }\n  \n      while (*lptr)\n      {\n  \tif (!isalnum (*lptr))\n  \t{\n  \t    int stop = 0;\n  \t    switch (*lptr)\n  \t    {\n  \t\tcase '_':\n  \t\t    break;\n  \t\tcase '.':\n  \t\t    if (!isalpha (*(lptr + 1)))\n  \t\t\tstop = 1;\n  \t\t    break;\n  \t\tdefault:\n  \t\t    stop = 1;\n  \t\t    break;\n  \t    }\n  \t    if (stop)\n  \t\tbreak;\n  \t}\n  \tlptr++;\n      }\n  \n      string s (start, lptr - start);\n      return YCPString (s);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseIp4Number",
          "args": [
            "line",
            "optional"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "parseIp4Number",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "31-67",
          "snippet": "YCPValue\nAnyAgent::parseIp4Number (char const *&lptr, bool optional)\n{\n    long long num = 0LL;\n    int dotcount = 0;\n\n    while (dotcount < 4)\n    {\n\tif (!isdigit (lptr[0]))\n\t{\n\t    y2error (\"parseIp4Number not starting with digit\");\n\t    return YCPVoid ();\n\t}\n\tnum <<= 8;\n\tint i = atoi (lptr);\n\tif ((i < 0) || (i > 255))\n\t{\n\t    y2error (\"parseIp4Number bad value %d\", i);\n\t    return YCPVoid ();\n\t}\n\tnum += i;\n\twhile (isdigit (lptr[0]))\n\t    lptr++;\n\tif (dotcount < 3)\n\t{\n\t    if (lptr[0] != '.')\n\t    {\n\t\ty2error (\"parseIp4Number no dot, %d\", dotcount);\n\t\treturn YCPVoid ();\n\t    }\n\t    lptr++;\n\t}\n\tdotcount++;\n    }\n\n    return YCPInteger (num);\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseIp4Number (char const *&lptr, bool optional)\n  {\n      long long num = 0LL;\n      int dotcount = 0;\n  \n      while (dotcount < 4)\n      {\n  \tif (!isdigit (lptr[0]))\n  \t{\n  \t    y2error (\"parseIp4Number not starting with digit\");\n  \t    return YCPVoid ();\n  \t}\n  \tnum <<= 8;\n  \tint i = atoi (lptr);\n  \tif ((i < 0) || (i > 255))\n  \t{\n  \t    y2error (\"parseIp4Number bad value %d\", i);\n  \t    return YCPVoid ();\n  \t}\n  \tnum += i;\n  \twhile (isdigit (lptr[0]))\n  \t    lptr++;\n  \tif (dotcount < 3)\n  \t{\n  \t    if (lptr[0] != '.')\n  \t    {\n  \t\ty2error (\"parseIp4Number no dot, %d\", dotcount);\n  \t\treturn YCPVoid ();\n  \t    }\n  \t    lptr++;\n  \t}\n  \tdotcount++;\n      }\n  \n      return YCPInteger (num);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseFloat",
          "args": [
            "line",
            "optional"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "parseFloat",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "308-327",
          "snippet": "YCPValue\nAnyAgent::parseFloat (char const *&lptr, bool optional)\n{\n    const char * start = lptr;\n    y2debug (\"parseFloat (%s)\", lptr);\n\n    if (!isdigit (*lptr) && (*lptr != '.'))\n\treturn YCPNull ();\n\n    while (isdigit (*lptr))\n\tlptr++;\n    if (*lptr == '.')\n\tlptr++;\n    while (isdigit (*lptr))\n\tlptr++;\n\n    float value;\n    sscanf (start, \"%f\", &value);\n    return YCPFloat ((double) value);\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseFloat (char const *&lptr, bool optional)\n  {\n      const char * start = lptr;\n      y2debug (\"parseFloat (%s)\", lptr);\n  \n      if (!isdigit (*lptr) && (*lptr != '.'))\n  \treturn YCPNull ();\n  \n      while (isdigit (*lptr))\n  \tlptr++;\n      if (*lptr == '.')\n  \tlptr++;\n      while (isdigit (*lptr))\n  \tlptr++;\n  \n      float value;\n      sscanf (start, \"%f\", &value);\n      return YCPFloat ((double) value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseBoolean",
          "args": [
            "line",
            "optional"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "parseBoolean",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "92-108",
          "snippet": "YCPValue\nAnyAgent::parseBoolean (char const *&lptr, bool optional)\n{\n    if (strncmp (lptr, \"yes\", 3) == 0)\n    {\n\tlptr += 3;\n\treturn YCPBoolean (true);\n    }\n    else if (strncmp (lptr, \"no\", 2) == 0)\n    {\n\tlptr += 2;\n\treturn YCPBoolean (false);\n    }\n    if (!optional)\n\ty2error (\"*** not a bool\");\n    return YCPNull ();\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseBoolean (char const *&lptr, bool optional)\n  {\n      if (strncmp (lptr, \"yes\", 3) == 0)\n      {\n  \tlptr += 3;\n  \treturn YCPBoolean (true);\n      }\n      else if (strncmp (lptr, \"no\", 2) == 0)\n      {\n  \tlptr += 2;\n  \treturn YCPBoolean (false);\n      }\n      if (!optional)\n  \ty2error (\"*** not a bool\");\n      return YCPNull ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseHexval",
          "args": [
            "line",
            "optional"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "parseHexval",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "168-204",
          "snippet": "YCPValue\nAnyAgent::parseHexval (char const *&lptr, bool optional)\n{\n    long long num = 0LL;\n\n    if (!isxdigit (lptr[0]))\n    {\n\tif (!optional)\n\t    y2error (\"*** not a hex value\");\n\treturn YCPNull ();\n    }\n    // allow 0x as start\n    if ((lptr[0] == '0') && ((lptr[1] == 'x') || (lptr[1] == 'X')))\n\tlptr += 2;\n\n    while (isxdigit (lptr[0]))\n    {\n\tchar x = lptr[0];\n\tx -= '0';\n\tif (x > 10)\n\t{\n\t    x -= 'A' - '0' - 10;\n\t    if (x > 16)\n\t    {\n\t\tx -= ('a' - 'A');\n\t\tif (x > 16)\n\t\t    break;\n\t    }\n\t}\n\n\tnum <<= 4;\n\tnum += x;\n\tlptr++;\n    }\n\n    return YCPInteger (num);\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseHexval (char const *&lptr, bool optional)\n  {\n      long long num = 0LL;\n  \n      if (!isxdigit (lptr[0]))\n      {\n  \tif (!optional)\n  \t    y2error (\"*** not a hex value\");\n  \treturn YCPNull ();\n      }\n      // allow 0x as start\n      if ((lptr[0] == '0') && ((lptr[1] == 'x') || (lptr[1] == 'X')))\n  \tlptr += 2;\n  \n      while (isxdigit (lptr[0]))\n      {\n  \tchar x = lptr[0];\n  \tx -= '0';\n  \tif (x > 10)\n  \t{\n  \t    x -= 'A' - '0' - 10;\n  \t    if (x > 16)\n  \t    {\n  \t\tx -= ('a' - 'A');\n  \t\tif (x > 16)\n  \t\t    break;\n  \t    }\n  \t}\n  \n  \tnum <<= 4;\n  \tnum += x;\n  \tlptr++;\n      }\n  \n      return YCPInteger (num);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseNumber",
          "args": [
            "line",
            "optional"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "parseNumber",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "128-144",
          "snippet": "YCPValue\nAnyAgent::parseNumber (char const *&lptr, bool optional)\n{\n    long long num = 0LL;\n\n    if (!isdigit (lptr[0]))\n    {\n\tif (!optional)\n\t    y2error (\"*** not a number\");\n\treturn YCPNull ();\n    }\n    num = atoll (lptr);\n    while (isdigit (lptr[0]))\n\tlptr++;\n\n    return YCPInteger (num);\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseNumber (char const *&lptr, bool optional)\n  {\n      long long num = 0LL;\n  \n      if (!isdigit (lptr[0]))\n      {\n  \tif (!optional)\n  \t    y2error (\"*** not a number\");\n  \treturn YCPNull ();\n      }\n      num = atoll (lptr);\n      while (isdigit (lptr[0]))\n  \tlptr++;\n  \n      return YCPInteger (num);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Or () failed\""
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Or () success\""
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtry.isNull",
          "args": [],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseString",
          "args": [
            "line",
            "term->value (0)->asString ()->value ().c_str ()",
            "term->value (1)->asString ()->value ().c_str ()",
            "optional"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "parseString",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "228-264",
          "snippet": "YCPValue\nAnyAgent::parseString (char const *&lptr, const char *set, const char *stripped,\n\t\t       bool optional)\n{\n    char const *start = lptr;\n\n    // increment lptr according to match\n\n    if (*set == '^')\n    {\n\tset++;\n\twhile ((*lptr != 0) && (strchr (set, *lptr) == 0))\n\t    lptr++;\n    }\n    else\n    {\n\twhile ((*lptr != 0) && (strchr (set, *lptr) != 0))\n\t    lptr++;\n    }\n    if ((start == lptr) && (*set != 0))\n\treturn YCPNull ();\n\n    // adjust start and end for stripping\n\n    char const *end = lptr;\n\n    if (stripped != 0)\n    {\n\twhile ((start < end) && (strchr (stripped, *start) != 0))\n\t    start++;\n\twhile ((start < end) && (strchr (stripped, *(end - 1)) != 0))\n\t    end--;\n    }\n\n    string s (start, end - start);\n    return YCPString (s);\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseString (char const *&lptr, const char *set, const char *stripped,\n  \t\t       bool optional)\n  {\n      char const *start = lptr;\n  \n      // increment lptr according to match\n  \n      if (*set == '^')\n      {\n  \tset++;\n  \twhile ((*lptr != 0) && (strchr (set, *lptr) == 0))\n  \t    lptr++;\n      }\n      else\n      {\n  \twhile ((*lptr != 0) && (strchr (set, *lptr) != 0))\n  \t    lptr++;\n      }\n      if ((start == lptr) && (*set != 0))\n  \treturn YCPNull ();\n  \n      // adjust start and end for stripping\n  \n      char const *end = lptr;\n  \n      if (stripped != 0)\n      {\n  \twhile ((start < end) && (strchr (stripped, *start) != 0))\n  \t    start++;\n  \twhile ((start < end) && (strchr (stripped, *(end - 1)) != 0))\n  \t    end--;\n      }\n  \n      string s (start, end - start);\n      return YCPString (s);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->value",
          "args": [],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseSeparator",
          "args": [
            "line",
            "\" \\t\"",
            "optional"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "parseSeparator",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentBasic.cc",
          "lines": "505-515",
          "snippet": "YCPValue\nAnyAgent::parseSeparator (char const *&lptr, const char *match, bool optional)\n{\n    char const *start = lptr;\n\n    while ((*lptr != 0) && (strchr (match, *lptr) != 0))\n\tlptr++;\n\n    return (optional || (lptr > start)) ?\n\tYCPString (string (start, lptr - start)) : YCPNull ();\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseSeparator (char const *&lptr, const char *match, bool optional)\n  {\n      char const *start = lptr;\n  \n      while ((*lptr != 0) && (strchr (match, *lptr) != 0))\n  \tlptr++;\n  \n      return (optional || (lptr > start)) ?\n  \tYCPString (string (start, lptr - start)) : YCPNull ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tupleValue.top",
          "args": [],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "fillup"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tupleValue.top",
          "args": [],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleName.top",
          "args": [],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getLine",
          "args": [],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mComment.find_first_of",
          "args": [
            "line[0]"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleValue.top",
          "args": [],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tv.isNull",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Name: %s\"",
            "tn->toString ().c_str ()"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleName.top",
          "args": [],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleName.top",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tn->isString",
          "args": [],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tn.isNull",
          "args": [],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"'Name' not allowed for writable agents\""
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseData",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleValue.pop",
          "args": [],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "pop",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "159-167",
          "snippet": "void\nSymbolEntry::pop ()\n{\n    if (! m_recurse_stack)\n\treturn;\n\n    m_value = m_recurse_stack->top ();\n    m_recurse_stack->pop ();\n}",
          "includes": [
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  void\n  SymbolEntry::pop ()\n  {\n      if (! m_recurse_stack)\n  \treturn;\n  \n      m_value = m_recurse_stack->top ();\n      m_recurse_stack->pop ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseTuple",
          "args": [
            "line",
            "term->args ()",
            "optional"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "parseTuple",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "318-368",
          "snippet": "YCPValue\nAnyAgent::parseTuple (char const *&line, const YCPList & syntax, bool optional)\n{\n    if (syntax.isNull ())\n\treturn YCPNull ();\n\n    if (line == 0)\n\treturn YCPNull ();\n\n    y2debug (\"parseTuple (%s,%s)\", line, syntax->toString ().c_str ());\n    YCPMap map;\n\n    tupleContinue = false;\n\n    for (int i = 0; i < syntax->size (); i++)\n    {\n\tYCPValue element_syntax = syntax->value (i);\n\n\tif (parseData (line, element_syntax, optional).isNull ())\n\t{\n\t    if (!optional)\n\t\treturn YCPNull ();\n\t    break;\n\t}\n\n\ty2debug (\"tuple name %ld, value %ld\", (long) tupleName.size (),\n\t\t (long) tupleValue.size ());\n\n\tif (tupleName.size () > 0 && tupleName.top () != \"\" &&\n\t    tupleValue.size () > 0 && !tupleValue.top ().isNull () &&\n\t    (!tupleValue.top ()->isVoid ()))\n\t{\n\t    y2debug (\"map add %s:%s\", tupleName.top ().c_str (),\n\t\t     tupleValue.top ()->toString ().c_str ());\n\t    map->add (YCPString (tupleName.top ()), tupleValue.top ());\n\t    tupleName.top () = \"\";\n\t    tupleValue.top () = YCPNull ();\n\t}\n\n\tif (tupleContinue && (i == (syntax->size () - 1)))\n\t{\n\t    tupleContinue = false;\n\t    i = -1;\t\t// restart at 0\n\t    optional = true;\t// it's optional from now on\n\t}\n\n    }\n\n    y2debug (\"tuple (%s)\", map->toString ().c_str ());\n    return map;\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseTuple (char const *&line, const YCPList & syntax, bool optional)\n  {\n      if (syntax.isNull ())\n  \treturn YCPNull ();\n  \n      if (line == 0)\n  \treturn YCPNull ();\n  \n      y2debug (\"parseTuple (%s,%s)\", line, syntax->toString ().c_str ());\n      YCPMap map;\n  \n      tupleContinue = false;\n  \n      for (int i = 0; i < syntax->size (); i++)\n      {\n  \tYCPValue element_syntax = syntax->value (i);\n  \n  \tif (parseData (line, element_syntax, optional).isNull ())\n  \t{\n  \t    if (!optional)\n  \t\treturn YCPNull ();\n  \t    break;\n  \t}\n  \n  \ty2debug (\"tuple name %ld, value %ld\", (long) tupleName.size (),\n  \t\t (long) tupleValue.size ());\n  \n  \tif (tupleName.size () > 0 && tupleName.top () != \"\" &&\n  \t    tupleValue.size () > 0 && !tupleValue.top ().isNull () &&\n  \t    (!tupleValue.top ()->isVoid ()))\n  \t{\n  \t    y2debug (\"map add %s:%s\", tupleName.top ().c_str (),\n  \t\t     tupleValue.top ()->toString ().c_str ());\n  \t    map->add (YCPString (tupleName.top ()), tupleValue.top ());\n  \t    tupleName.top () = \"\";\n  \t    tupleValue.top () = YCPNull ();\n  \t}\n  \n  \tif (tupleContinue && (i == (syntax->size () - 1)))\n  \t{\n  \t    tupleContinue = false;\n  \t    i = -1;\t\t// restart at 0\n  \t    optional = true;\t// it's optional from now on\n  \t}\n  \n      }\n  \n      y2debug (\"tuple (%s)\", map->toString ().c_str ());\n      return map;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->args",
          "args": [],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "args",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "58-62",
          "snippet": "YCPList\nYCPTermRep::args() const\n{\n    return l;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPList\n  YCPTermRep::args() const\n  {\n      return l;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tupleValue.push",
          "args": [
            "YCPNull ()"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleName.push",
          "args": [
            "\"\""
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseList",
          "args": [
            "line",
            "term->args ()",
            "optional"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "parseList",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "219-247",
          "snippet": "YCPValue\nAnyAgent::parseList (char const *&line, const YCPList & syntax, bool optional)\n{\n    if (syntax.isNull ())\n\treturn YCPNull ();\n\n    y2debug (\"parseList ('%s',[%s])\", line, syntax->toString ().c_str ());\n\n    YCPList list;\n\n    for (;;)\n    {\n\t// value of line\n\tYCPValue vl = parseData (line, syntax->value (0), optional);\n\toptional = false;\n\tif (vl.isNull ())\n\t    break;\n\tif (!vl->isVoid ())\n\t    list->add (vl);\n\ty2debug (\"vl (%s)\", vl->toString ().c_str ());\n\t// value of separator/string\n\tYCPValue vs = parseData (line, syntax->value (1), false);\n\tif (vs.isNull ())\n\t    break;\n    }\n\n    y2debug (\"list (%s)\", list->toString ().c_str ());\n    return list;\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseList (char const *&line, const YCPList & syntax, bool optional)\n  {\n      if (syntax.isNull ())\n  \treturn YCPNull ();\n  \n      y2debug (\"parseList ('%s',[%s])\", line, syntax->toString ().c_str ());\n  \n      YCPList list;\n  \n      for (;;)\n      {\n  \t// value of line\n  \tYCPValue vl = parseData (line, syntax->value (0), optional);\n  \toptional = false;\n  \tif (vl.isNull ())\n  \t    break;\n  \tif (!vl->isVoid ())\n  \t    list->add (vl);\n  \ty2debug (\"vl (%s)\", vl->toString ().c_str ());\n  \t// value of separator/string\n  \tYCPValue vs = parseData (line, syntax->value (1), false);\n  \tif (vs.isNull ())\n  \t    break;\n      }\n  \n      y2debug (\"list (%s)\", list->toString ().c_str ());\n      return list;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseSequence",
          "args": [
            "line",
            "term->args ()",
            "optional"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "parseSequence",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "176-203",
          "snippet": "YCPValue\nAnyAgent::parseSequence (char const *&line, const YCPList & syntax,\n\t\t\t bool optional)\n{\n    YCPValue element = YCPNull ();\n    if (syntax.isNull ())\n\treturn element;\n\n    y2debug (\"parseSequence ('%s',[%s])\", line, syntax->toString ().c_str ());\n\n    char const *lstart = line;\n\n    for (int i = 0; i < syntax->size (); i++)\n    {\n\telement = syntax->value (i);\n\n\telement = parseData (line, element, optional);\n\n\tif (element.isNull ())\n\t{\n\t    lstart = 0;\n\t    break;\n\t}\n    }\n    if (lstart != 0)\n\treturn YCPString (string (lstart, line - lstart));\n    return element;\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseSequence (char const *&line, const YCPList & syntax,\n  \t\t\t bool optional)\n  {\n      YCPValue element = YCPNull ();\n      if (syntax.isNull ())\n  \treturn element;\n  \n      y2debug (\"parseSequence ('%s',[%s])\", line, syntax->toString ().c_str ());\n  \n      char const *lstart = line;\n  \n      for (int i = 0; i < syntax->size (); i++)\n      {\n  \telement = syntax->value (i);\n  \n  \telement = parseData (line, element, optional);\n  \n  \tif (element.isNull ())\n  \t{\n  \t    lstart = 0;\n  \t    break;\n  \t}\n      }\n      if (lstart != 0)\n  \treturn YCPString (string (lstart, line - lstart));\n      return element;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseChoice",
          "args": [
            "line",
            "term->args ()",
            "optional"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "parseChoice",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "105-160",
          "snippet": "YCPValue\nAnyAgent::parseChoice (char const *&line, const YCPList & syntax, bool optional)\n{\n    if ((line == 0) || syntax.isNull ())\n\treturn YCPNull ();\n\n    y2debug (\"parseChoice ('%s',[%s])\", line, syntax->toString ().c_str ());\n\n    for (int i = 0; i < syntax->size (); i++)\n    {\n\tYCPValue v = syntax->value (i);\n\tif (v.isNull ())\n\t{\n\t    y2error (\"Bad element in Choice()\");\n\t    return YCPNull ();\n\t}\n\tif (!v->isList ())\n\t{\n\t    y2error (\"Choice element must be list\");\n\t    return YCPNull ();\n\t}\n\n\tYCPList element = v->asList ();\n\tif ((element->size () <= 0) || (element->size () > 2))\n\t{\n\t    y2error (\"Choice element list must have 1 or 2 entries\");\n\t    return YCPNull ();\n\t}\n\n\tYCPValue match = element->value (0);\n\n\t// get optional action\n\n\tYCPValue action = (element->size () > 1) ? element->value (1) : YCPNull ();\n\n\t// force match\n\ty2debug (\"choice (%d)\", i);\n\n\tchar const *try_line = line;\n\n\tcurrentMatch = parseData (try_line, match, false);\n\n\t// have match\n\tif (!currentMatch.isNull ())\n\t{\n\t    line = try_line;\n\t    y2debug (\"choice (%d) match\", i);\n\t    if (!action.isNull ())\n\t\treturn parseData (line, action, optional);\n\t    else\n\t\treturn currentMatch;\n\t}\n    }\n\n    return YCPNull ();\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static YCPValue currentMatch = YCPNull ();"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic YCPValue currentMatch = YCPNull ();\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseChoice (char const *&line, const YCPList & syntax, bool optional)\n  {\n      if ((line == 0) || syntax.isNull ())\n  \treturn YCPNull ();\n  \n      y2debug (\"parseChoice ('%s',[%s])\", line, syntax->toString ().c_str ());\n  \n      for (int i = 0; i < syntax->size (); i++)\n      {\n  \tYCPValue v = syntax->value (i);\n  \tif (v.isNull ())\n  \t{\n  \t    y2error (\"Bad element in Choice()\");\n  \t    return YCPNull ();\n  \t}\n  \tif (!v->isList ())\n  \t{\n  \t    y2error (\"Choice element must be list\");\n  \t    return YCPNull ();\n  \t}\n  \n  \tYCPList element = v->asList ();\n  \tif ((element->size () <= 0) || (element->size () > 2))\n  \t{\n  \t    y2error (\"Choice element list must have 1 or 2 entries\");\n  \t    return YCPNull ();\n  \t}\n  \n  \tYCPValue match = element->value (0);\n  \n  \t// get optional action\n  \n  \tYCPValue action = (element->size () > 1) ? element->value (1) : YCPNull ();\n  \n  \t// force match\n  \ty2debug (\"choice (%d)\", i);\n  \n  \tchar const *try_line = line;\n  \n  \tcurrentMatch = parseData (try_line, match, false);\n  \n  \t// have match\n  \tif (!currentMatch.isNull ())\n  \t{\n  \t    line = try_line;\n  \t    y2debug (\"choice (%d) match\", i);\n  \t    if (!action.isNull ())\n  \t\treturn parseData (line, action, optional);\n  \t    else\n  \t\treturn currentMatch;\n  \t}\n      }\n  \n      return YCPNull ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tv.isNull",
          "args": [],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ov.isNull",
          "args": [],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YT_TERM (%s)\"",
            "s.c_str ()"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.c_str",
          "args": [],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term->name",
          "args": [],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2AgentComp",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "44-44",
          "snippet": "string name () const { return my_name; }",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp {\n  string name () const { return my_name; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "syntax->asTerm",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "syntax->valuetype",
          "args": [],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "YCPSymbolRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "69-73",
          "snippet": "YCPValueType\nYCPSymbolRep::valuetype() const\n{\n    return YT_SYMBOL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbolRep {\n  YCPValueType\n  YCPSymbolRep::valuetype() const\n  {\n      return YT_SYMBOL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"parseData %s('%s',[%s])\"",
            "(optional ? \"?\" : \"!\")",
            "line",
            "syntax->toString ().c_str ()"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syntax.isNull",
          "args": [],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getLine",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define KEY4FILLUP \"`FILLUP\"\n\nstatic YCPValue currentMatch = YCPNull ();\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseData (char const *&line, const YCPValue & syntax, bool optional)\n  {\n      if ((line == 0) || (*line == 0))\n  \tline = getLine ();\n      if (line == 0)\n  \treturn YCPNull ();\n      if (syntax.isNull ())\n  \treturn YCPNull ();\n  \n      y2debug (\"parseData %s('%s',[%s])\", (optional ? \"?\" : \"!\"), line,\n  \t     syntax->toString ().c_str ());\n  \n      switch (syntax->valuetype ())\n      {\n  \tcase YT_TERM: {\n  \n  \t    YCPTerm term = syntax->asTerm ();\n  \t    const string s = term->name ();\n  \t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n  \n  \t    // Optional\n  \n  \t    if (s == \"Optional\" && term->size () > 0)\n  \t    {\n  \t\tYCPValue ov = parseData (line, term->value (0), true);\n  \t\tif (ov.isNull ())\n  \t\t    ov = YCPVoid ();\n  \t\treturn ov;\n  \t    }\n  \n  \t    // Continue\n  \n  \t    else if (s == \"Continue\" && term->size () > 0)\n  \t    {\n  \t\tYCPValue tv = parseData (line, term->value (0), false);\n  \t\tif (!tv.isNull ())\n  \t\t    tupleContinue = true;\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Choice\n  \n  \t    else if (s == \"Choice\" && term->size () > 0)\n  \t    {\n  \t\treturn parseChoice (line, term->args (), optional);\n  \t    }\n  \n  \t    // Sequence\n  \n  \t    else if (s == \"Sequence\" && term->size () > 0)\n  \t    {\n  \t\treturn parseSequence (line, term->args (), optional);\n  \t    }\n  \n  \t    // List\n  \n  \t    else if (s == \"List\" && term->size () == 2)\n  \t    {\n  \t\treturn parseList (line, term->args (), optional);\n  \t    }\n  \n  \t    // Tuple\n  \n  \t    else if (s == \"Tuple\" && term->size () > 0)\n  \t    {\n  \t\ttupleName.push (\"\");\n  \t\ttupleValue.push (YCPNull ());\n  \t\tYCPValue tv = parseTuple (line, term->args (), optional);\n  \t\ttupleName.pop ();\n  \t\ttupleValue.pop ();\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Var\n  \n  \t    else if (s == \"Var\" && term->size () > 0)\n  \t    {\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    if (parseData (line, term->value (i), optional).isNull ())\n  \t\t\tbreak;\n  \t\t}\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Name\n  \n  \t    else if (s == \"Name\" && term->size () == 1)\n  \t    {\n  \t\tif (!mReadOnly)\n  \t\t{\n  \t\t    y2error (\"'Name' not allowed for writable agents\");\n  \t\t    return YCPNull ();\n  \t\t}\n  \t\tYCPValue tn = parseData (line, term->value (0), false);\n  \t\tif (!tn.isNull () && tupleName.size () > 0)\n  \t\t{\n  \t\t    if (tn->isString ())\n  \t\t\ttupleName.top () = tn->asString ()->value ();\n  \t\t    else\n  \t\t\ttupleName.top () = tn->toString ();\n  \t\t    y2debug (\"Name: %s\", tn->toString ().c_str ());\n  \t\t}\n  \t\treturn tn;\n  \t    }\n  \n  \t    // Value\n  \n  \t    else if (s == \"Value\" && term->size () == 1)\n  \t    {\n  \t\tYCPValue tv = parseData (line, term->value (0), false);\n  \t\tif (!tv.isNull () && tupleValue.size () > 0)\n  \t\t    tupleValue.top () = tv;\n  \t\t// y2debug (\"Value: %p\", tv);\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Fillup\n  \n  \t    else if (isFillup && (s == \"Fillup\") &&\t// fillup allowed and Fillup () found\n  \t\t     (term->size () == 0) && (tupleName.size () > 0))\n  \t    {\t\t// inside Tuple ()\n  \t\tstring fillup;\n  \t\twhile ((line != 0)\n  \t\t       && (mComment.find_first_of (line[0]) != string::npos))\n  \t\t{\n  \t\t    fillup = fillup + line;\n  \t\t    line = getLine ();\n  \t\t}\n  \t\ttupleName.top () = KEY4FILLUP;\n  \t\ttupleValue.top () = YCPString (fillup);\n  \t\treturn tupleValue.top ();\n  \t    }\n  \n  \t    // Skip\n  \n  \t    else if (s == \"Skip\")\n  \t    {\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Match\n  \n  \t    else if (s == \"Match\")\n  \t    {\n  \t\treturn currentMatch;\n  \t    }\n  \n  \t    // Separator\n  \n  \t    else if (s == \"Separator\" && term->size () == 1)\n  \t    {\n  \t\treturn parseSeparator (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t       optional);\n  \t    }\n  \n  \t    // Whitespace\n  \n  \t    else if (s == \"Whitespace\")\n  \t    {\n  \t\treturn parseSeparator (line, \" \\t\", optional);\n  \t    }\n  \n  \t    // String\n  \n  \t    else if (s == \"String\" && term->size () > 0)\n  \t    {\n  \t\tif (term->size () == 1)\n  \t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t\t0, optional);\n  \t\tif (term->size () == 2)\n  \t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t\tterm->value (1)->asString ()->value ().c_str (),\n  \t\t\t\t\toptional);\n  \t    }\n  \n  \t    // Or\n  \n  \t    else if (s == \"Or\" && term->size () > 0)\n  \t    {\n  \t\tconst char *ltry = line;\n  \t\tbool lopt = false;\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    if (i == term->size () - 1)\t// pass optional on last try\n  \t\t\tlopt = optional;\n  \t\t    YCPValue vtry = parseData (ltry, term->value (i), lopt);\n  \t\t    if (!vtry.isNull ())\n  \t\t    {\n  \t\t\ty2debug (\"Or () success\");\n  \t\t\tline = ltry;\n  \t\t\treturn vtry;\n  \t\t    }\n  \t\t}\n  \t\ty2debug (\"Or () failed\");\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Number\n  \n  \t    else if (s == \"Number\")\n  \t    {\n  \t\treturn parseNumber (line, optional);\n  \t    }\n  \n  \t    // Hexval\n  \n  \t    else if (s == \"Hexval\")\n  \t    {\n  \t\treturn parseHexval (line, optional);\n  \t    }\n  \n  \t    // Boolean\n  \n  \t    else if (s == \"Boolean\")\n  \t    {\n  \t\treturn parseBoolean (line, optional);\n  \t    }\n  \n  \t    // Float\n  \n  \t    else if (s == \"Float\")\n  \t    {\n  \t\treturn parseFloat (line, optional);\n  \t    }\n  \n  \t    // Ip4Number\n  \n  \t    else if (s == \"Ip4Number\")\n  \t    {\n  \t\treturn parseIp4Number (line, optional);\n  \t    }\n  \n  \t    // Hostname\n  \n  \t    else if (s == \"Hostname\")\n  \t    {\n  \t\treturn parseHostname (line, optional);\n  \t    }\n  \n  \t    // Username\n  \n  \t    else if (s == \"Username\")\n  \t    {\n  \t\treturn parseUsername (line, optional);\n  \t    }\n  \n  \t    // <name>\n  \n  \t    else if (islower (s[0]) && tupleName.size () > 0 && (term->size () == 1))\n  \t    {\n  \t\ttupleName.top () = s;\n  \t\ttupleValue.top () = parseData (line, term->value (0), optional);\n  \t\treturn tupleValue.top ();\n  \t    }\n  \n  \t    else\n  \t    {\n  \t\ty2error (\"parseData: unknown term '%s'\", s.c_str ());\n  \t\treturn YCPVoid ();\n  \t    }\n  \t} break;\n  \n  \tcase YT_STRING:\n  \t    y2debug (\"YT_STRING\");\n  \t    return parseVerbose (line, syntax->asString ()->value ().c_str (),\n  \t\t\t\t optional);\n  \t    break;\n  \n  \tdefault:\n  \t    y2error (\"parseData: unknown syntax %s\", syntax->toString ().c_str ());\n  \t    break;\n      }\n  \n      return YCPNull ();\n  }\n}"
  },
  {
    "function_name": "unparseTuple",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
    "lines": "374-423",
    "snippet": "const string\nAnyAgent::unparseTuple (const YCPList & syntax, const YCPValue & value)\n{\n    if (syntax.isNull () || value.isNull ())\n\treturn \"\";\n\n    y2debug (\"unparseTuple ('%s',%s)\", syntax->toString ().c_str (),\n\t     value->toString ().c_str ());\n    if (!value->isMap ())\n    {\n\ty2error (\"unparseTuple: value has wrong type\");\n\treturn \"\";\n    }\n\n    int ssize = syntax->size ();\n    string s;\n\n    // if Fillup allowed and defined, initialize s with it\n\n    if (isFillup)\n    {\n\tYCPMap map = value->asMap ();\n\tYCPValue fillup = map->value (YCPString (KEY4FILLUP));\n\tif ((!fillup.isNull ()) && fillup->isString ())\n\t    s += fillup->asString ()->value ();\n    }\n\n    for (int i = 0; i < ssize; i++)\n    {\n\tconst YCPValue & element = syntax->value (i);\n\tconst string data = unparseData (element, value);\n\tif (data.empty ())\n\t{\n\t    y2debug (\"unparseTuple fail ? ('%s',%s)\",\n\t\t     element->toString ().c_str (), value->toString ().c_str ());\n\t    if (element->valuetype () == YT_TERM)\n\t    {\n\t\tYCPTerm term = element->asTerm ();\n\t\tif (!(term.isNull ()) && \n\t\t    ((term->name () == \"Skip\") ||\n\t\t     (term->name () == \"Fillup\")))\n\t\t    continue;\n\t    }\n\t    break;\n\t}\n\ts += data;\n    }\n\n    return s;\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define KEY4FILLUP \"`FILLUP\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "term->name",
          "args": [],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2AgentComp",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "44-44",
          "snippet": "string name () const { return my_name; }",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp {\n  string name () const { return my_name; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term.isNull",
          "args": [],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "element->asTerm",
          "args": [],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "element->valuetype",
          "args": [],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "YCPSymbolRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "69-73",
          "snippet": "YCPValueType\nYCPSymbolRep::valuetype() const\n{\n    return YT_SYMBOL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbolRep {\n  YCPValueType\n  YCPSymbolRep::valuetype() const\n  {\n      return YT_SYMBOL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"unparseTuple fail ? ('%s',%s)\"",
            "element->toString ().c_str ()",
            "value->toString ().c_str ()"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.empty",
          "args": [],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unparseData",
          "args": [
            "element",
            "value"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "unparseData",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "713-952",
          "snippet": "const string\nAnyAgent::unparseData (const YCPValue & syntax, const YCPValue & value)\n{\n    if (syntax.isNull ())\n\treturn \"\";\n\n    y2debug (\"unparseData ('%s',%s)\", value.isNull () ? \"\" : value->toString ().c_str (),\n\t     syntax->toString ().c_str ());\n\n    switch (syntax->valuetype ())\n    {\n\tcase YT_TERM: {\n\n\t    YCPTerm term = syntax->asTerm ();\n\t    if (term.isNull ())\n\t    {\n\t\ty2error (\"YT_TERM no term\");\n\t    }\n\t    string s = term->name ();\n\t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n\n\t    // Optional\n\n\t    if (s == \"Optional\" && term->size () > 0)\n\t    {\n\t\treturn unparseData (term->value (0), value);\n\t    }\n\n\t    // Continue\n\n\t    else if (s == \"Continue\" && term->size () > 0)\n\t    {\n\t\tif (tupleContinue)\n\t\t    return unparseData (term->value (0), value);\n\t    }\n\n\t    // Choice\n\n\t    else if (s == \"Choice\" && term->size () > 0)\n\t    {\n\t\treturn unparseChoice (term->args (), value);\n\t    }\n\n\t    // Sequence\n\n\t    else if (s == \"Sequence\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tconst string s = unparseSequence (term->args (), value);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn s;\n\t    }\n\n\t    // List\n\n\t    else if (s == \"List\" && term->size () == 2)\n\t    {\n\t\treturn unparseList (term->args (), value);\n\t    }\n\n\t    // Tuple\n\n\t    else if (s == \"Tuple\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tconst string s = unparseTuple (term->args (), value);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn s;\n\t    }\n\n\t    // Var\n\n\t    else if (s == \"Var\" && term->size () > 0)\n\t    {\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    const string vdata = unparseData (term->value (i), value);\n\t\t    if (vdata.empty ())\n\t\t\tbreak;\n\t\t}\n\t\treturn \"\";\n\t    }\n\n\t    // Name\n\n\t    else if (s == \"Name\" && term->size () == 1)\n\t    {\n\t\ty2error (\"unparse Name ()\");\n\t\treturn \"\";\n\t    }\n\n\t    // Value\n\n\t    else if (s == \"Value\" && term->size () == 1)\n\t    {\n\t\tconst string s = unparseData (term->value (0), value);\n#if 0\n\t\tif (tv && tupleValue.size () > 0)\n\t\t    tupleValue.top () = tv;\n#endif\n\t\treturn s;\n\t    }\n\n\t    // Separator\n\n\t    else if (s == \"Separator\" && term->size () == 1)\n\t    {\n\t\treturn unparseSeparator (term->value (0));\n\t    }\n\n\t    // Whitespace\n\n\t    else if (s == \"Whitespace\")\n\t    {\n\t\treturn unparseSeparator (YCPString (\" \\t\"));\n\t    }\n\n\t    // Skip (is handled correctly within unparseTuple()\n\n\t    else if (s == \"Skip\")\n\t    {\n\t\treturn \"\";\n\t    }\n\n\t    // Fillup (is handled correctly within unparseTuple()\n\n\t    else if (s == \"Fillup\")\n\t    {\n\t\treturn \"\";\n\t    }\n\n\t    // String\n\n\t    else if (s == \"String\" && term->size () > 0)\n\t    {\n\t\tif (term->size () == 1)\n\t\t    return unparseString (term->value (0), YCPNull (), value);\n\t\tif (term->size () == 2)\n\t\t    return unparseString (term->value (0), term->value (1),\n\t\t\t\t\t  value);\n\t    }\n\n\t    // Or\n\n\t    else if (s == \"Or\" && term->size () == 2)\n\t    {\n#if 1\n\t\tconst YCPValue vbackup = value;\n\t\tconst string vdata = unparseData (term->value (0), value);\n\t\tif (vdata != \"\")\n\t\t    return vdata;\n\t\telse\n\t\t    return unparseData (term->value (1), vbackup);\n#endif\n\t    }\n\n\t    // Number\n\n\t    else if (s == \"Number\")\n\t    {\n\t\treturn unparseNumber (value);\n\t    }\n\n\t    // Boolean\n\n\t    else if (s == \"Boolean\")\n\t    {\n\t\treturn unparseBoolean (value);\n\t    }\n\n\t    // Float\n\n\t    else if (s == \"Float\")\n\t    {\n\t\treturn unparseFloat (value);\n\t    }\n\n\t    // Ip4Number\n\n\t    else if (s == \"Ip4Number\")\n\t    {\n\t\treturn unparseIp4Number (value);\n\t    }\n\n\t    // Hostname\n\n\t    else if (s == \"Hostname\")\n\t    {\n\t\treturn unparseHostname (value);\n\t    }\n\n\t    // Username\n\n\t    else if (s == \"Username\")\n\t    {\n\t\treturn unparseUsername (value);\n\t    }\n\n\t    // <name> (<syntax>)\n\n\t    else if (islower (s[0]) && (term->size () == 1))\n\t    {\n\t\tif (!value->isMap ())\n\t\t    y2error (\"request for element '%s' but value not map\",\n\t\t\t     s.c_str ());\n\t\telse\n\t\t{\n\t\t    YCPValue v = value->asMap ()->value (YCPString (s));\n\t\t    if (v.isNull ())\n\t\t    {\n\t\t\ty2error (\"No value for key '%s' in map\", s.c_str ());\n\t\t\treturn \"\";\n\t\t    }\n\t\t    return unparseData (term->value (0), v);\n\t\t}\n\t    }\n\n\t    else\n\t    {\n\t\ty2error (\"unparseData: unknown term '%s'\", s.c_str ());\n\t\treturn \"\";\n\t    }\n\t} break;\n\n\tcase YT_STRING:\n\t    y2debug (\"YT_STRING\");\n\t    return unparseVerbose (syntax);\n\t    break;\n\n\tdefault:\n\t    y2error (\"unparseData: unknown syntax %s\", syntax->toString ().c_str ());\n\t    break;\n    }\n\n    return \"\";\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseData (const YCPValue & syntax, const YCPValue & value)\n  {\n      if (syntax.isNull ())\n  \treturn \"\";\n  \n      y2debug (\"unparseData ('%s',%s)\", value.isNull () ? \"\" : value->toString ().c_str (),\n  \t     syntax->toString ().c_str ());\n  \n      switch (syntax->valuetype ())\n      {\n  \tcase YT_TERM: {\n  \n  \t    YCPTerm term = syntax->asTerm ();\n  \t    if (term.isNull ())\n  \t    {\n  \t\ty2error (\"YT_TERM no term\");\n  \t    }\n  \t    string s = term->name ();\n  \t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n  \n  \t    // Optional\n  \n  \t    if (s == \"Optional\" && term->size () > 0)\n  \t    {\n  \t\treturn unparseData (term->value (0), value);\n  \t    }\n  \n  \t    // Continue\n  \n  \t    else if (s == \"Continue\" && term->size () > 0)\n  \t    {\n  \t\tif (tupleContinue)\n  \t\t    return unparseData (term->value (0), value);\n  \t    }\n  \n  \t    // Choice\n  \n  \t    else if (s == \"Choice\" && term->size () > 0)\n  \t    {\n  \t\treturn unparseChoice (term->args (), value);\n  \t    }\n  \n  \t    // Sequence\n  \n  \t    else if (s == \"Sequence\" && term->size () > 0)\n  \t    {\n  \t\ttupleName.push (\"\");\n  \t\ttupleValue.push (YCPNull ());\n  \t\tconst string s = unparseSequence (term->args (), value);\n  \t\ttupleName.pop ();\n  \t\ttupleValue.pop ();\n  \t\treturn s;\n  \t    }\n  \n  \t    // List\n  \n  \t    else if (s == \"List\" && term->size () == 2)\n  \t    {\n  \t\treturn unparseList (term->args (), value);\n  \t    }\n  \n  \t    // Tuple\n  \n  \t    else if (s == \"Tuple\" && term->size () > 0)\n  \t    {\n  \t\ttupleName.push (\"\");\n  \t\ttupleValue.push (YCPNull ());\n  \t\tconst string s = unparseTuple (term->args (), value);\n  \t\ttupleName.pop ();\n  \t\ttupleValue.pop ();\n  \t\treturn s;\n  \t    }\n  \n  \t    // Var\n  \n  \t    else if (s == \"Var\" && term->size () > 0)\n  \t    {\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    const string vdata = unparseData (term->value (i), value);\n  \t\t    if (vdata.empty ())\n  \t\t\tbreak;\n  \t\t}\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // Name\n  \n  \t    else if (s == \"Name\" && term->size () == 1)\n  \t    {\n  \t\ty2error (\"unparse Name ()\");\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // Value\n  \n  \t    else if (s == \"Value\" && term->size () == 1)\n  \t    {\n  \t\tconst string s = unparseData (term->value (0), value);\n  #if 0\n  \t\tif (tv && tupleValue.size () > 0)\n  \t\t    tupleValue.top () = tv;\n  #endif\n  \t\treturn s;\n  \t    }\n  \n  \t    // Separator\n  \n  \t    else if (s == \"Separator\" && term->size () == 1)\n  \t    {\n  \t\treturn unparseSeparator (term->value (0));\n  \t    }\n  \n  \t    // Whitespace\n  \n  \t    else if (s == \"Whitespace\")\n  \t    {\n  \t\treturn unparseSeparator (YCPString (\" \\t\"));\n  \t    }\n  \n  \t    // Skip (is handled correctly within unparseTuple()\n  \n  \t    else if (s == \"Skip\")\n  \t    {\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // Fillup (is handled correctly within unparseTuple()\n  \n  \t    else if (s == \"Fillup\")\n  \t    {\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // String\n  \n  \t    else if (s == \"String\" && term->size () > 0)\n  \t    {\n  \t\tif (term->size () == 1)\n  \t\t    return unparseString (term->value (0), YCPNull (), value);\n  \t\tif (term->size () == 2)\n  \t\t    return unparseString (term->value (0), term->value (1),\n  \t\t\t\t\t  value);\n  \t    }\n  \n  \t    // Or\n  \n  \t    else if (s == \"Or\" && term->size () == 2)\n  \t    {\n  #if 1\n  \t\tconst YCPValue vbackup = value;\n  \t\tconst string vdata = unparseData (term->value (0), value);\n  \t\tif (vdata != \"\")\n  \t\t    return vdata;\n  \t\telse\n  \t\t    return unparseData (term->value (1), vbackup);\n  #endif\n  \t    }\n  \n  \t    // Number\n  \n  \t    else if (s == \"Number\")\n  \t    {\n  \t\treturn unparseNumber (value);\n  \t    }\n  \n  \t    // Boolean\n  \n  \t    else if (s == \"Boolean\")\n  \t    {\n  \t\treturn unparseBoolean (value);\n  \t    }\n  \n  \t    // Float\n  \n  \t    else if (s == \"Float\")\n  \t    {\n  \t\treturn unparseFloat (value);\n  \t    }\n  \n  \t    // Ip4Number\n  \n  \t    else if (s == \"Ip4Number\")\n  \t    {\n  \t\treturn unparseIp4Number (value);\n  \t    }\n  \n  \t    // Hostname\n  \n  \t    else if (s == \"Hostname\")\n  \t    {\n  \t\treturn unparseHostname (value);\n  \t    }\n  \n  \t    // Username\n  \n  \t    else if (s == \"Username\")\n  \t    {\n  \t\treturn unparseUsername (value);\n  \t    }\n  \n  \t    // <name> (<syntax>)\n  \n  \t    else if (islower (s[0]) && (term->size () == 1))\n  \t    {\n  \t\tif (!value->isMap ())\n  \t\t    y2error (\"request for element '%s' but value not map\",\n  \t\t\t     s.c_str ());\n  \t\telse\n  \t\t{\n  \t\t    YCPValue v = value->asMap ()->value (YCPString (s));\n  \t\t    if (v.isNull ())\n  \t\t    {\n  \t\t\ty2error (\"No value for key '%s' in map\", s.c_str ());\n  \t\t\treturn \"\";\n  \t\t    }\n  \t\t    return unparseData (term->value (0), v);\n  \t\t}\n  \t    }\n  \n  \t    else\n  \t    {\n  \t\ty2error (\"unparseData: unknown term '%s'\", s.c_str ());\n  \t\treturn \"\";\n  \t    }\n  \t} break;\n  \n  \tcase YT_STRING:\n  \t    y2debug (\"YT_STRING\");\n  \t    return unparseVerbose (syntax);\n  \t    break;\n  \n  \tdefault:\n  \t    y2error (\"unparseData: unknown syntax %s\", syntax->toString ().c_str ());\n  \t    break;\n      }\n  \n      return \"\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "syntax->value",
          "args": [
            "i"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fillup->asString",
          "args": [],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fillup->isString",
          "args": [],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fillup.isNull",
          "args": [],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "KEY4FILLUP"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asMap",
          "args": [],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "syntax->size",
          "args": [],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"unparseTuple: value has wrong type\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->isMap",
          "args": [],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "71-71",
          "snippet": "bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"unparseTuple ('%s',%s)\"",
            "syntax->toString ().c_str ()",
            "value->toString ().c_str ()"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syntax.isNull",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define KEY4FILLUP \"`FILLUP\"\n\nAnyAgent {\n  const string\n  AnyAgent::unparseTuple (const YCPList & syntax, const YCPValue & value)\n  {\n      if (syntax.isNull () || value.isNull ())\n  \treturn \"\";\n  \n      y2debug (\"unparseTuple ('%s',%s)\", syntax->toString ().c_str (),\n  \t     value->toString ().c_str ());\n      if (!value->isMap ())\n      {\n  \ty2error (\"unparseTuple: value has wrong type\");\n  \treturn \"\";\n      }\n  \n      int ssize = syntax->size ();\n      string s;\n  \n      // if Fillup allowed and defined, initialize s with it\n  \n      if (isFillup)\n      {\n  \tYCPMap map = value->asMap ();\n  \tYCPValue fillup = map->value (YCPString (KEY4FILLUP));\n  \tif ((!fillup.isNull ()) && fillup->isString ())\n  \t    s += fillup->asString ()->value ();\n      }\n  \n      for (int i = 0; i < ssize; i++)\n      {\n  \tconst YCPValue & element = syntax->value (i);\n  \tconst string data = unparseData (element, value);\n  \tif (data.empty ())\n  \t{\n  \t    y2debug (\"unparseTuple fail ? ('%s',%s)\",\n  \t\t     element->toString ().c_str (), value->toString ().c_str ());\n  \t    if (element->valuetype () == YT_TERM)\n  \t    {\n  \t\tYCPTerm term = element->asTerm ();\n  \t\tif (!(term.isNull ()) && \n  \t\t    ((term->name () == \"Skip\") ||\n  \t\t     (term->name () == \"Fillup\")))\n  \t\t    continue;\n  \t    }\n  \t    break;\n  \t}\n  \ts += data;\n      }\n  \n      return s;\n  }\n}"
  },
  {
    "function_name": "parseTuple",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
    "lines": "318-368",
    "snippet": "YCPValue\nAnyAgent::parseTuple (char const *&line, const YCPList & syntax, bool optional)\n{\n    if (syntax.isNull ())\n\treturn YCPNull ();\n\n    if (line == 0)\n\treturn YCPNull ();\n\n    y2debug (\"parseTuple (%s,%s)\", line, syntax->toString ().c_str ());\n    YCPMap map;\n\n    tupleContinue = false;\n\n    for (int i = 0; i < syntax->size (); i++)\n    {\n\tYCPValue element_syntax = syntax->value (i);\n\n\tif (parseData (line, element_syntax, optional).isNull ())\n\t{\n\t    if (!optional)\n\t\treturn YCPNull ();\n\t    break;\n\t}\n\n\ty2debug (\"tuple name %ld, value %ld\", (long) tupleName.size (),\n\t\t (long) tupleValue.size ());\n\n\tif (tupleName.size () > 0 && tupleName.top () != \"\" &&\n\t    tupleValue.size () > 0 && !tupleValue.top ().isNull () &&\n\t    (!tupleValue.top ()->isVoid ()))\n\t{\n\t    y2debug (\"map add %s:%s\", tupleName.top ().c_str (),\n\t\t     tupleValue.top ()->toString ().c_str ());\n\t    map->add (YCPString (tupleName.top ()), tupleValue.top ());\n\t    tupleName.top () = \"\";\n\t    tupleValue.top () = YCPNull ();\n\t}\n\n\tif (tupleContinue && (i == (syntax->size () - 1)))\n\t{\n\t    tupleContinue = false;\n\t    i = -1;\t\t// restart at 0\n\t    optional = true;\t// it's optional from now on\n\t}\n\n    }\n\n    y2debug (\"tuple (%s)\", map->toString ().c_str ());\n    return map;\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"tuple (%s)\"",
            "map->toString ().c_str ()"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map->toString",
          "args": [],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "syntax->size",
          "args": [],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleValue.top",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleName.top",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map->add",
          "args": [
            "YCPString (tupleName.top ())",
            "tupleValue.top ()"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "50-76",
          "snippet": "void\nYCPMapRep::add (const YCPValue& key, const YCPValue& value)\n{\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn;\n    }\n\n    // Note: 'stl_map[key] = value' would create a temporary object using the\n    // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n    // 24.\n\n    YCPMap::iterator pos = stl_map.lower_bound(key);\n    if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n    {\n\tpos->second = value;\n    }\n    else\n    {\n\t// pos is just a hint but can avoid a second search through the map\n\tstl_map.insert(pos, YCPMap::value_type(key, value));\n    }\n\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void\n  YCPMapRep::add (const YCPValue& key, const YCPValue& value)\n  {\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn;\n      }\n  \n      // Note: 'stl_map[key] = value' would create a temporary object using the\n      // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n      // 24.\n  \n      YCPMap::iterator pos = stl_map.lower_bound(key);\n      if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n      {\n  \tpos->second = value;\n      }\n      else\n      {\n  \t// pos is just a hint but can avoid a second search through the map\n  \tstl_map.insert(pos, YCPMap::value_type(key, value));\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tupleValue.top",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "tupleName.top ()"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tupleName.top",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"map add %s:%s\"",
            "tupleName.top ().c_str ()",
            "tupleValue.top ()->toString ().c_str ()"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleValue.top",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleValue.top",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleValue.top",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleName.top",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleName.top",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleValue.top",
          "args": [],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleValue.top",
          "args": [],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleValue.top",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleValue.top",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleName.top",
          "args": [],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"tuple name %ld, value %ld\"",
            "(long) tupleName.size ()",
            "(long) tupleValue.size ()"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseData",
          "args": [],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseData",
          "args": [
            "line",
            "element_syntax",
            "optional"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "parseData",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "429-705",
          "snippet": "YCPValue\nAnyAgent::parseData (char const *&line, const YCPValue & syntax, bool optional)\n{\n    if ((line == 0) || (*line == 0))\n\tline = getLine ();\n    if (line == 0)\n\treturn YCPNull ();\n    if (syntax.isNull ())\n\treturn YCPNull ();\n\n    y2debug (\"parseData %s('%s',[%s])\", (optional ? \"?\" : \"!\"), line,\n\t     syntax->toString ().c_str ());\n\n    switch (syntax->valuetype ())\n    {\n\tcase YT_TERM: {\n\n\t    YCPTerm term = syntax->asTerm ();\n\t    const string s = term->name ();\n\t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n\n\t    // Optional\n\n\t    if (s == \"Optional\" && term->size () > 0)\n\t    {\n\t\tYCPValue ov = parseData (line, term->value (0), true);\n\t\tif (ov.isNull ())\n\t\t    ov = YCPVoid ();\n\t\treturn ov;\n\t    }\n\n\t    // Continue\n\n\t    else if (s == \"Continue\" && term->size () > 0)\n\t    {\n\t\tYCPValue tv = parseData (line, term->value (0), false);\n\t\tif (!tv.isNull ())\n\t\t    tupleContinue = true;\n\t\treturn tv;\n\t    }\n\n\t    // Choice\n\n\t    else if (s == \"Choice\" && term->size () > 0)\n\t    {\n\t\treturn parseChoice (line, term->args (), optional);\n\t    }\n\n\t    // Sequence\n\n\t    else if (s == \"Sequence\" && term->size () > 0)\n\t    {\n\t\treturn parseSequence (line, term->args (), optional);\n\t    }\n\n\t    // List\n\n\t    else if (s == \"List\" && term->size () == 2)\n\t    {\n\t\treturn parseList (line, term->args (), optional);\n\t    }\n\n\t    // Tuple\n\n\t    else if (s == \"Tuple\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tYCPValue tv = parseTuple (line, term->args (), optional);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn tv;\n\t    }\n\n\t    // Var\n\n\t    else if (s == \"Var\" && term->size () > 0)\n\t    {\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    if (parseData (line, term->value (i), optional).isNull ())\n\t\t\tbreak;\n\t\t}\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Name\n\n\t    else if (s == \"Name\" && term->size () == 1)\n\t    {\n\t\tif (!mReadOnly)\n\t\t{\n\t\t    y2error (\"'Name' not allowed for writable agents\");\n\t\t    return YCPNull ();\n\t\t}\n\t\tYCPValue tn = parseData (line, term->value (0), false);\n\t\tif (!tn.isNull () && tupleName.size () > 0)\n\t\t{\n\t\t    if (tn->isString ())\n\t\t\ttupleName.top () = tn->asString ()->value ();\n\t\t    else\n\t\t\ttupleName.top () = tn->toString ();\n\t\t    y2debug (\"Name: %s\", tn->toString ().c_str ());\n\t\t}\n\t\treturn tn;\n\t    }\n\n\t    // Value\n\n\t    else if (s == \"Value\" && term->size () == 1)\n\t    {\n\t\tYCPValue tv = parseData (line, term->value (0), false);\n\t\tif (!tv.isNull () && tupleValue.size () > 0)\n\t\t    tupleValue.top () = tv;\n\t\t// y2debug (\"Value: %p\", tv);\n\t\treturn tv;\n\t    }\n\n\t    // Fillup\n\n\t    else if (isFillup && (s == \"Fillup\") &&\t// fillup allowed and Fillup () found\n\t\t     (term->size () == 0) && (tupleName.size () > 0))\n\t    {\t\t// inside Tuple ()\n\t\tstring fillup;\n\t\twhile ((line != 0)\n\t\t       && (mComment.find_first_of (line[0]) != string::npos))\n\t\t{\n\t\t    fillup = fillup + line;\n\t\t    line = getLine ();\n\t\t}\n\t\ttupleName.top () = KEY4FILLUP;\n\t\ttupleValue.top () = YCPString (fillup);\n\t\treturn tupleValue.top ();\n\t    }\n\n\t    // Skip\n\n\t    else if (s == \"Skip\")\n\t    {\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Match\n\n\t    else if (s == \"Match\")\n\t    {\n\t\treturn currentMatch;\n\t    }\n\n\t    // Separator\n\n\t    else if (s == \"Separator\" && term->size () == 1)\n\t    {\n\t\treturn parseSeparator (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t       optional);\n\t    }\n\n\t    // Whitespace\n\n\t    else if (s == \"Whitespace\")\n\t    {\n\t\treturn parseSeparator (line, \" \\t\", optional);\n\t    }\n\n\t    // String\n\n\t    else if (s == \"String\" && term->size () > 0)\n\t    {\n\t\tif (term->size () == 1)\n\t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t\t0, optional);\n\t\tif (term->size () == 2)\n\t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t\tterm->value (1)->asString ()->value ().c_str (),\n\t\t\t\t\toptional);\n\t    }\n\n\t    // Or\n\n\t    else if (s == \"Or\" && term->size () > 0)\n\t    {\n\t\tconst char *ltry = line;\n\t\tbool lopt = false;\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    if (i == term->size () - 1)\t// pass optional on last try\n\t\t\tlopt = optional;\n\t\t    YCPValue vtry = parseData (ltry, term->value (i), lopt);\n\t\t    if (!vtry.isNull ())\n\t\t    {\n\t\t\ty2debug (\"Or () success\");\n\t\t\tline = ltry;\n\t\t\treturn vtry;\n\t\t    }\n\t\t}\n\t\ty2debug (\"Or () failed\");\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Number\n\n\t    else if (s == \"Number\")\n\t    {\n\t\treturn parseNumber (line, optional);\n\t    }\n\n\t    // Hexval\n\n\t    else if (s == \"Hexval\")\n\t    {\n\t\treturn parseHexval (line, optional);\n\t    }\n\n\t    // Boolean\n\n\t    else if (s == \"Boolean\")\n\t    {\n\t\treturn parseBoolean (line, optional);\n\t    }\n\n\t    // Float\n\n\t    else if (s == \"Float\")\n\t    {\n\t\treturn parseFloat (line, optional);\n\t    }\n\n\t    // Ip4Number\n\n\t    else if (s == \"Ip4Number\")\n\t    {\n\t\treturn parseIp4Number (line, optional);\n\t    }\n\n\t    // Hostname\n\n\t    else if (s == \"Hostname\")\n\t    {\n\t\treturn parseHostname (line, optional);\n\t    }\n\n\t    // Username\n\n\t    else if (s == \"Username\")\n\t    {\n\t\treturn parseUsername (line, optional);\n\t    }\n\n\t    // <name>\n\n\t    else if (islower (s[0]) && tupleName.size () > 0 && (term->size () == 1))\n\t    {\n\t\ttupleName.top () = s;\n\t\ttupleValue.top () = parseData (line, term->value (0), optional);\n\t\treturn tupleValue.top ();\n\t    }\n\n\t    else\n\t    {\n\t\ty2error (\"parseData: unknown term '%s'\", s.c_str ());\n\t\treturn YCPVoid ();\n\t    }\n\t} break;\n\n\tcase YT_STRING:\n\t    y2debug (\"YT_STRING\");\n\t    return parseVerbose (line, syntax->asString ()->value ().c_str (),\n\t\t\t\t optional);\n\t    break;\n\n\tdefault:\n\t    y2error (\"parseData: unknown syntax %s\", syntax->toString ().c_str ());\n\t    break;\n    }\n\n    return YCPNull ();\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define KEY4FILLUP \"`FILLUP\""
          ],
          "globals_used": [
            "static YCPValue currentMatch = YCPNull ();"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define KEY4FILLUP \"`FILLUP\"\n\nstatic YCPValue currentMatch = YCPNull ();\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseData (char const *&line, const YCPValue & syntax, bool optional)\n  {\n      if ((line == 0) || (*line == 0))\n  \tline = getLine ();\n      if (line == 0)\n  \treturn YCPNull ();\n      if (syntax.isNull ())\n  \treturn YCPNull ();\n  \n      y2debug (\"parseData %s('%s',[%s])\", (optional ? \"?\" : \"!\"), line,\n  \t     syntax->toString ().c_str ());\n  \n      switch (syntax->valuetype ())\n      {\n  \tcase YT_TERM: {\n  \n  \t    YCPTerm term = syntax->asTerm ();\n  \t    const string s = term->name ();\n  \t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n  \n  \t    // Optional\n  \n  \t    if (s == \"Optional\" && term->size () > 0)\n  \t    {\n  \t\tYCPValue ov = parseData (line, term->value (0), true);\n  \t\tif (ov.isNull ())\n  \t\t    ov = YCPVoid ();\n  \t\treturn ov;\n  \t    }\n  \n  \t    // Continue\n  \n  \t    else if (s == \"Continue\" && term->size () > 0)\n  \t    {\n  \t\tYCPValue tv = parseData (line, term->value (0), false);\n  \t\tif (!tv.isNull ())\n  \t\t    tupleContinue = true;\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Choice\n  \n  \t    else if (s == \"Choice\" && term->size () > 0)\n  \t    {\n  \t\treturn parseChoice (line, term->args (), optional);\n  \t    }\n  \n  \t    // Sequence\n  \n  \t    else if (s == \"Sequence\" && term->size () > 0)\n  \t    {\n  \t\treturn parseSequence (line, term->args (), optional);\n  \t    }\n  \n  \t    // List\n  \n  \t    else if (s == \"List\" && term->size () == 2)\n  \t    {\n  \t\treturn parseList (line, term->args (), optional);\n  \t    }\n  \n  \t    // Tuple\n  \n  \t    else if (s == \"Tuple\" && term->size () > 0)\n  \t    {\n  \t\ttupleName.push (\"\");\n  \t\ttupleValue.push (YCPNull ());\n  \t\tYCPValue tv = parseTuple (line, term->args (), optional);\n  \t\ttupleName.pop ();\n  \t\ttupleValue.pop ();\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Var\n  \n  \t    else if (s == \"Var\" && term->size () > 0)\n  \t    {\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    if (parseData (line, term->value (i), optional).isNull ())\n  \t\t\tbreak;\n  \t\t}\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Name\n  \n  \t    else if (s == \"Name\" && term->size () == 1)\n  \t    {\n  \t\tif (!mReadOnly)\n  \t\t{\n  \t\t    y2error (\"'Name' not allowed for writable agents\");\n  \t\t    return YCPNull ();\n  \t\t}\n  \t\tYCPValue tn = parseData (line, term->value (0), false);\n  \t\tif (!tn.isNull () && tupleName.size () > 0)\n  \t\t{\n  \t\t    if (tn->isString ())\n  \t\t\ttupleName.top () = tn->asString ()->value ();\n  \t\t    else\n  \t\t\ttupleName.top () = tn->toString ();\n  \t\t    y2debug (\"Name: %s\", tn->toString ().c_str ());\n  \t\t}\n  \t\treturn tn;\n  \t    }\n  \n  \t    // Value\n  \n  \t    else if (s == \"Value\" && term->size () == 1)\n  \t    {\n  \t\tYCPValue tv = parseData (line, term->value (0), false);\n  \t\tif (!tv.isNull () && tupleValue.size () > 0)\n  \t\t    tupleValue.top () = tv;\n  \t\t// y2debug (\"Value: %p\", tv);\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Fillup\n  \n  \t    else if (isFillup && (s == \"Fillup\") &&\t// fillup allowed and Fillup () found\n  \t\t     (term->size () == 0) && (tupleName.size () > 0))\n  \t    {\t\t// inside Tuple ()\n  \t\tstring fillup;\n  \t\twhile ((line != 0)\n  \t\t       && (mComment.find_first_of (line[0]) != string::npos))\n  \t\t{\n  \t\t    fillup = fillup + line;\n  \t\t    line = getLine ();\n  \t\t}\n  \t\ttupleName.top () = KEY4FILLUP;\n  \t\ttupleValue.top () = YCPString (fillup);\n  \t\treturn tupleValue.top ();\n  \t    }\n  \n  \t    // Skip\n  \n  \t    else if (s == \"Skip\")\n  \t    {\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Match\n  \n  \t    else if (s == \"Match\")\n  \t    {\n  \t\treturn currentMatch;\n  \t    }\n  \n  \t    // Separator\n  \n  \t    else if (s == \"Separator\" && term->size () == 1)\n  \t    {\n  \t\treturn parseSeparator (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t       optional);\n  \t    }\n  \n  \t    // Whitespace\n  \n  \t    else if (s == \"Whitespace\")\n  \t    {\n  \t\treturn parseSeparator (line, \" \\t\", optional);\n  \t    }\n  \n  \t    // String\n  \n  \t    else if (s == \"String\" && term->size () > 0)\n  \t    {\n  \t\tif (term->size () == 1)\n  \t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t\t0, optional);\n  \t\tif (term->size () == 2)\n  \t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t\tterm->value (1)->asString ()->value ().c_str (),\n  \t\t\t\t\toptional);\n  \t    }\n  \n  \t    // Or\n  \n  \t    else if (s == \"Or\" && term->size () > 0)\n  \t    {\n  \t\tconst char *ltry = line;\n  \t\tbool lopt = false;\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    if (i == term->size () - 1)\t// pass optional on last try\n  \t\t\tlopt = optional;\n  \t\t    YCPValue vtry = parseData (ltry, term->value (i), lopt);\n  \t\t    if (!vtry.isNull ())\n  \t\t    {\n  \t\t\ty2debug (\"Or () success\");\n  \t\t\tline = ltry;\n  \t\t\treturn vtry;\n  \t\t    }\n  \t\t}\n  \t\ty2debug (\"Or () failed\");\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Number\n  \n  \t    else if (s == \"Number\")\n  \t    {\n  \t\treturn parseNumber (line, optional);\n  \t    }\n  \n  \t    // Hexval\n  \n  \t    else if (s == \"Hexval\")\n  \t    {\n  \t\treturn parseHexval (line, optional);\n  \t    }\n  \n  \t    // Boolean\n  \n  \t    else if (s == \"Boolean\")\n  \t    {\n  \t\treturn parseBoolean (line, optional);\n  \t    }\n  \n  \t    // Float\n  \n  \t    else if (s == \"Float\")\n  \t    {\n  \t\treturn parseFloat (line, optional);\n  \t    }\n  \n  \t    // Ip4Number\n  \n  \t    else if (s == \"Ip4Number\")\n  \t    {\n  \t\treturn parseIp4Number (line, optional);\n  \t    }\n  \n  \t    // Hostname\n  \n  \t    else if (s == \"Hostname\")\n  \t    {\n  \t\treturn parseHostname (line, optional);\n  \t    }\n  \n  \t    // Username\n  \n  \t    else if (s == \"Username\")\n  \t    {\n  \t\treturn parseUsername (line, optional);\n  \t    }\n  \n  \t    // <name>\n  \n  \t    else if (islower (s[0]) && tupleName.size () > 0 && (term->size () == 1))\n  \t    {\n  \t\ttupleName.top () = s;\n  \t\ttupleValue.top () = parseData (line, term->value (0), optional);\n  \t\treturn tupleValue.top ();\n  \t    }\n  \n  \t    else\n  \t    {\n  \t\ty2error (\"parseData: unknown term '%s'\", s.c_str ());\n  \t\treturn YCPVoid ();\n  \t    }\n  \t} break;\n  \n  \tcase YT_STRING:\n  \t    y2debug (\"YT_STRING\");\n  \t    return parseVerbose (line, syntax->asString ()->value ().c_str (),\n  \t\t\t\t optional);\n  \t    break;\n  \n  \tdefault:\n  \t    y2error (\"parseData: unknown syntax %s\", syntax->toString ().c_str ());\n  \t    break;\n      }\n  \n      return YCPNull ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "syntax->value",
          "args": [
            "i"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"parseTuple (%s,%s)\"",
            "line",
            "syntax->toString ().c_str ()"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syntax.isNull",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseTuple (char const *&line, const YCPList & syntax, bool optional)\n  {\n      if (syntax.isNull ())\n  \treturn YCPNull ();\n  \n      if (line == 0)\n  \treturn YCPNull ();\n  \n      y2debug (\"parseTuple (%s,%s)\", line, syntax->toString ().c_str ());\n      YCPMap map;\n  \n      tupleContinue = false;\n  \n      for (int i = 0; i < syntax->size (); i++)\n      {\n  \tYCPValue element_syntax = syntax->value (i);\n  \n  \tif (parseData (line, element_syntax, optional).isNull ())\n  \t{\n  \t    if (!optional)\n  \t\treturn YCPNull ();\n  \t    break;\n  \t}\n  \n  \ty2debug (\"tuple name %ld, value %ld\", (long) tupleName.size (),\n  \t\t (long) tupleValue.size ());\n  \n  \tif (tupleName.size () > 0 && tupleName.top () != \"\" &&\n  \t    tupleValue.size () > 0 && !tupleValue.top ().isNull () &&\n  \t    (!tupleValue.top ()->isVoid ()))\n  \t{\n  \t    y2debug (\"map add %s:%s\", tupleName.top ().c_str (),\n  \t\t     tupleValue.top ()->toString ().c_str ());\n  \t    map->add (YCPString (tupleName.top ()), tupleValue.top ());\n  \t    tupleName.top () = \"\";\n  \t    tupleValue.top () = YCPNull ();\n  \t}\n  \n  \tif (tupleContinue && (i == (syntax->size () - 1)))\n  \t{\n  \t    tupleContinue = false;\n  \t    i = -1;\t\t// restart at 0\n  \t    optional = true;\t// it's optional from now on\n  \t}\n  \n      }\n  \n      y2debug (\"tuple (%s)\", map->toString ().c_str ());\n      return map;\n  }\n}"
  },
  {
    "function_name": "unparseList",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
    "lines": "253-312",
    "snippet": "const string\nAnyAgent::unparseList (const YCPList & syntax, const YCPValue & value)\n{\n    if (syntax.isNull () || value.isNull ())\n\treturn \"\";\n\n    y2debug (\"unparseList ('%s',%s)\", syntax->toString ().c_str (),\n\t     value->toString ().c_str ());\n\n    if (!value->isList ())\n    {\n\ty2error (\"unparseList: value has wrong type\");\n\treturn \"\";\n    }\n    YCPList list = value->asList ();\n\n    string s;\n    int lsize = list->size ();\n\n    y2debug (\"unparseList (%d: '%s')\", lsize, list->toString ().c_str ());\n\n    if (lsize > 0)\n    {\n\tfor (int i = 0; i < lsize; i++)\n\t{\n\t    const string data = unparseData (syntax->value (0), list->value (i));\n\t    if (data.empty ())\n\t\tbreak;\n\t    string cont;\n\t    if (i < lsize - 1)\n\t    {\n\t\tconst YCPValue & element = syntax->value (1);\n\t\tcont = unparseData (element, YCPNull ());\n\t\tif (cont.empty ())\n\t\t{\n\t\t    if (element->valuetype () != YT_TERM)\n\t\t\tbreak;\n\t\t    else\n\t\t    {\n\t\t\tYCPTerm term = element->asTerm ();\n\t\t\tif ((term.isNull ())\n\t\t\t    || ((term->name () != \"Skip\")\n\t\t\t\t&& (term->name () !=\n\t\t\t\t    \"Fillup\")))\n\t\t\t{\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    else\t\t// no continuation after last list element\n\t\tcont = \"\";\n\n\t    s += data;\n\t    s += cont;\n\t}\n    }\n\n    return s;\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "term->name",
          "args": [],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2AgentComp",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "44-44",
          "snippet": "string name () const { return my_name; }",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp {\n  string name () const { return my_name; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term.isNull",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "element->asTerm",
          "args": [],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "element->valuetype",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "YCPSymbolRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "69-73",
          "snippet": "YCPValueType\nYCPSymbolRep::valuetype() const\n{\n    return YT_SYMBOL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbolRep {\n  YCPValueType\n  YCPSymbolRep::valuetype() const\n  {\n      return YT_SYMBOL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cont.empty",
          "args": [],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unparseData",
          "args": [
            "element",
            "YCPNull ()"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "unparseData",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "713-952",
          "snippet": "const string\nAnyAgent::unparseData (const YCPValue & syntax, const YCPValue & value)\n{\n    if (syntax.isNull ())\n\treturn \"\";\n\n    y2debug (\"unparseData ('%s',%s)\", value.isNull () ? \"\" : value->toString ().c_str (),\n\t     syntax->toString ().c_str ());\n\n    switch (syntax->valuetype ())\n    {\n\tcase YT_TERM: {\n\n\t    YCPTerm term = syntax->asTerm ();\n\t    if (term.isNull ())\n\t    {\n\t\ty2error (\"YT_TERM no term\");\n\t    }\n\t    string s = term->name ();\n\t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n\n\t    // Optional\n\n\t    if (s == \"Optional\" && term->size () > 0)\n\t    {\n\t\treturn unparseData (term->value (0), value);\n\t    }\n\n\t    // Continue\n\n\t    else if (s == \"Continue\" && term->size () > 0)\n\t    {\n\t\tif (tupleContinue)\n\t\t    return unparseData (term->value (0), value);\n\t    }\n\n\t    // Choice\n\n\t    else if (s == \"Choice\" && term->size () > 0)\n\t    {\n\t\treturn unparseChoice (term->args (), value);\n\t    }\n\n\t    // Sequence\n\n\t    else if (s == \"Sequence\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tconst string s = unparseSequence (term->args (), value);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn s;\n\t    }\n\n\t    // List\n\n\t    else if (s == \"List\" && term->size () == 2)\n\t    {\n\t\treturn unparseList (term->args (), value);\n\t    }\n\n\t    // Tuple\n\n\t    else if (s == \"Tuple\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tconst string s = unparseTuple (term->args (), value);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn s;\n\t    }\n\n\t    // Var\n\n\t    else if (s == \"Var\" && term->size () > 0)\n\t    {\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    const string vdata = unparseData (term->value (i), value);\n\t\t    if (vdata.empty ())\n\t\t\tbreak;\n\t\t}\n\t\treturn \"\";\n\t    }\n\n\t    // Name\n\n\t    else if (s == \"Name\" && term->size () == 1)\n\t    {\n\t\ty2error (\"unparse Name ()\");\n\t\treturn \"\";\n\t    }\n\n\t    // Value\n\n\t    else if (s == \"Value\" && term->size () == 1)\n\t    {\n\t\tconst string s = unparseData (term->value (0), value);\n#if 0\n\t\tif (tv && tupleValue.size () > 0)\n\t\t    tupleValue.top () = tv;\n#endif\n\t\treturn s;\n\t    }\n\n\t    // Separator\n\n\t    else if (s == \"Separator\" && term->size () == 1)\n\t    {\n\t\treturn unparseSeparator (term->value (0));\n\t    }\n\n\t    // Whitespace\n\n\t    else if (s == \"Whitespace\")\n\t    {\n\t\treturn unparseSeparator (YCPString (\" \\t\"));\n\t    }\n\n\t    // Skip (is handled correctly within unparseTuple()\n\n\t    else if (s == \"Skip\")\n\t    {\n\t\treturn \"\";\n\t    }\n\n\t    // Fillup (is handled correctly within unparseTuple()\n\n\t    else if (s == \"Fillup\")\n\t    {\n\t\treturn \"\";\n\t    }\n\n\t    // String\n\n\t    else if (s == \"String\" && term->size () > 0)\n\t    {\n\t\tif (term->size () == 1)\n\t\t    return unparseString (term->value (0), YCPNull (), value);\n\t\tif (term->size () == 2)\n\t\t    return unparseString (term->value (0), term->value (1),\n\t\t\t\t\t  value);\n\t    }\n\n\t    // Or\n\n\t    else if (s == \"Or\" && term->size () == 2)\n\t    {\n#if 1\n\t\tconst YCPValue vbackup = value;\n\t\tconst string vdata = unparseData (term->value (0), value);\n\t\tif (vdata != \"\")\n\t\t    return vdata;\n\t\telse\n\t\t    return unparseData (term->value (1), vbackup);\n#endif\n\t    }\n\n\t    // Number\n\n\t    else if (s == \"Number\")\n\t    {\n\t\treturn unparseNumber (value);\n\t    }\n\n\t    // Boolean\n\n\t    else if (s == \"Boolean\")\n\t    {\n\t\treturn unparseBoolean (value);\n\t    }\n\n\t    // Float\n\n\t    else if (s == \"Float\")\n\t    {\n\t\treturn unparseFloat (value);\n\t    }\n\n\t    // Ip4Number\n\n\t    else if (s == \"Ip4Number\")\n\t    {\n\t\treturn unparseIp4Number (value);\n\t    }\n\n\t    // Hostname\n\n\t    else if (s == \"Hostname\")\n\t    {\n\t\treturn unparseHostname (value);\n\t    }\n\n\t    // Username\n\n\t    else if (s == \"Username\")\n\t    {\n\t\treturn unparseUsername (value);\n\t    }\n\n\t    // <name> (<syntax>)\n\n\t    else if (islower (s[0]) && (term->size () == 1))\n\t    {\n\t\tif (!value->isMap ())\n\t\t    y2error (\"request for element '%s' but value not map\",\n\t\t\t     s.c_str ());\n\t\telse\n\t\t{\n\t\t    YCPValue v = value->asMap ()->value (YCPString (s));\n\t\t    if (v.isNull ())\n\t\t    {\n\t\t\ty2error (\"No value for key '%s' in map\", s.c_str ());\n\t\t\treturn \"\";\n\t\t    }\n\t\t    return unparseData (term->value (0), v);\n\t\t}\n\t    }\n\n\t    else\n\t    {\n\t\ty2error (\"unparseData: unknown term '%s'\", s.c_str ());\n\t\treturn \"\";\n\t    }\n\t} break;\n\n\tcase YT_STRING:\n\t    y2debug (\"YT_STRING\");\n\t    return unparseVerbose (syntax);\n\t    break;\n\n\tdefault:\n\t    y2error (\"unparseData: unknown syntax %s\", syntax->toString ().c_str ());\n\t    break;\n    }\n\n    return \"\";\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseData (const YCPValue & syntax, const YCPValue & value)\n  {\n      if (syntax.isNull ())\n  \treturn \"\";\n  \n      y2debug (\"unparseData ('%s',%s)\", value.isNull () ? \"\" : value->toString ().c_str (),\n  \t     syntax->toString ().c_str ());\n  \n      switch (syntax->valuetype ())\n      {\n  \tcase YT_TERM: {\n  \n  \t    YCPTerm term = syntax->asTerm ();\n  \t    if (term.isNull ())\n  \t    {\n  \t\ty2error (\"YT_TERM no term\");\n  \t    }\n  \t    string s = term->name ();\n  \t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n  \n  \t    // Optional\n  \n  \t    if (s == \"Optional\" && term->size () > 0)\n  \t    {\n  \t\treturn unparseData (term->value (0), value);\n  \t    }\n  \n  \t    // Continue\n  \n  \t    else if (s == \"Continue\" && term->size () > 0)\n  \t    {\n  \t\tif (tupleContinue)\n  \t\t    return unparseData (term->value (0), value);\n  \t    }\n  \n  \t    // Choice\n  \n  \t    else if (s == \"Choice\" && term->size () > 0)\n  \t    {\n  \t\treturn unparseChoice (term->args (), value);\n  \t    }\n  \n  \t    // Sequence\n  \n  \t    else if (s == \"Sequence\" && term->size () > 0)\n  \t    {\n  \t\ttupleName.push (\"\");\n  \t\ttupleValue.push (YCPNull ());\n  \t\tconst string s = unparseSequence (term->args (), value);\n  \t\ttupleName.pop ();\n  \t\ttupleValue.pop ();\n  \t\treturn s;\n  \t    }\n  \n  \t    // List\n  \n  \t    else if (s == \"List\" && term->size () == 2)\n  \t    {\n  \t\treturn unparseList (term->args (), value);\n  \t    }\n  \n  \t    // Tuple\n  \n  \t    else if (s == \"Tuple\" && term->size () > 0)\n  \t    {\n  \t\ttupleName.push (\"\");\n  \t\ttupleValue.push (YCPNull ());\n  \t\tconst string s = unparseTuple (term->args (), value);\n  \t\ttupleName.pop ();\n  \t\ttupleValue.pop ();\n  \t\treturn s;\n  \t    }\n  \n  \t    // Var\n  \n  \t    else if (s == \"Var\" && term->size () > 0)\n  \t    {\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    const string vdata = unparseData (term->value (i), value);\n  \t\t    if (vdata.empty ())\n  \t\t\tbreak;\n  \t\t}\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // Name\n  \n  \t    else if (s == \"Name\" && term->size () == 1)\n  \t    {\n  \t\ty2error (\"unparse Name ()\");\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // Value\n  \n  \t    else if (s == \"Value\" && term->size () == 1)\n  \t    {\n  \t\tconst string s = unparseData (term->value (0), value);\n  #if 0\n  \t\tif (tv && tupleValue.size () > 0)\n  \t\t    tupleValue.top () = tv;\n  #endif\n  \t\treturn s;\n  \t    }\n  \n  \t    // Separator\n  \n  \t    else if (s == \"Separator\" && term->size () == 1)\n  \t    {\n  \t\treturn unparseSeparator (term->value (0));\n  \t    }\n  \n  \t    // Whitespace\n  \n  \t    else if (s == \"Whitespace\")\n  \t    {\n  \t\treturn unparseSeparator (YCPString (\" \\t\"));\n  \t    }\n  \n  \t    // Skip (is handled correctly within unparseTuple()\n  \n  \t    else if (s == \"Skip\")\n  \t    {\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // Fillup (is handled correctly within unparseTuple()\n  \n  \t    else if (s == \"Fillup\")\n  \t    {\n  \t\treturn \"\";\n  \t    }\n  \n  \t    // String\n  \n  \t    else if (s == \"String\" && term->size () > 0)\n  \t    {\n  \t\tif (term->size () == 1)\n  \t\t    return unparseString (term->value (0), YCPNull (), value);\n  \t\tif (term->size () == 2)\n  \t\t    return unparseString (term->value (0), term->value (1),\n  \t\t\t\t\t  value);\n  \t    }\n  \n  \t    // Or\n  \n  \t    else if (s == \"Or\" && term->size () == 2)\n  \t    {\n  #if 1\n  \t\tconst YCPValue vbackup = value;\n  \t\tconst string vdata = unparseData (term->value (0), value);\n  \t\tif (vdata != \"\")\n  \t\t    return vdata;\n  \t\telse\n  \t\t    return unparseData (term->value (1), vbackup);\n  #endif\n  \t    }\n  \n  \t    // Number\n  \n  \t    else if (s == \"Number\")\n  \t    {\n  \t\treturn unparseNumber (value);\n  \t    }\n  \n  \t    // Boolean\n  \n  \t    else if (s == \"Boolean\")\n  \t    {\n  \t\treturn unparseBoolean (value);\n  \t    }\n  \n  \t    // Float\n  \n  \t    else if (s == \"Float\")\n  \t    {\n  \t\treturn unparseFloat (value);\n  \t    }\n  \n  \t    // Ip4Number\n  \n  \t    else if (s == \"Ip4Number\")\n  \t    {\n  \t\treturn unparseIp4Number (value);\n  \t    }\n  \n  \t    // Hostname\n  \n  \t    else if (s == \"Hostname\")\n  \t    {\n  \t\treturn unparseHostname (value);\n  \t    }\n  \n  \t    // Username\n  \n  \t    else if (s == \"Username\")\n  \t    {\n  \t\treturn unparseUsername (value);\n  \t    }\n  \n  \t    // <name> (<syntax>)\n  \n  \t    else if (islower (s[0]) && (term->size () == 1))\n  \t    {\n  \t\tif (!value->isMap ())\n  \t\t    y2error (\"request for element '%s' but value not map\",\n  \t\t\t     s.c_str ());\n  \t\telse\n  \t\t{\n  \t\t    YCPValue v = value->asMap ()->value (YCPString (s));\n  \t\t    if (v.isNull ())\n  \t\t    {\n  \t\t\ty2error (\"No value for key '%s' in map\", s.c_str ());\n  \t\t\treturn \"\";\n  \t\t    }\n  \t\t    return unparseData (term->value (0), v);\n  \t\t}\n  \t    }\n  \n  \t    else\n  \t    {\n  \t\ty2error (\"unparseData: unknown term '%s'\", s.c_str ());\n  \t\treturn \"\";\n  \t    }\n  \t} break;\n  \n  \tcase YT_STRING:\n  \t    y2debug (\"YT_STRING\");\n  \t    return unparseVerbose (syntax);\n  \t    break;\n  \n  \tdefault:\n  \t    y2error (\"unparseData: unknown syntax %s\", syntax->toString ().c_str ());\n  \t    break;\n      }\n  \n      return \"\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syntax->value",
          "args": [
            "1"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"unparseList (%d: '%s')\"",
            "lsize",
            "list->toString ().c_str ()"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list->toString",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->size",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asList",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"unparseList: value has wrong type\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->isList",
          "args": [],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"unparseList ('%s',%s)\"",
            "syntax->toString ().c_str ()",
            "value->toString ().c_str ()"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syntax.isNull",
          "args": [],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseList (const YCPList & syntax, const YCPValue & value)\n  {\n      if (syntax.isNull () || value.isNull ())\n  \treturn \"\";\n  \n      y2debug (\"unparseList ('%s',%s)\", syntax->toString ().c_str (),\n  \t     value->toString ().c_str ());\n  \n      if (!value->isList ())\n      {\n  \ty2error (\"unparseList: value has wrong type\");\n  \treturn \"\";\n      }\n      YCPList list = value->asList ();\n  \n      string s;\n      int lsize = list->size ();\n  \n      y2debug (\"unparseList (%d: '%s')\", lsize, list->toString ().c_str ());\n  \n      if (lsize > 0)\n      {\n  \tfor (int i = 0; i < lsize; i++)\n  \t{\n  \t    const string data = unparseData (syntax->value (0), list->value (i));\n  \t    if (data.empty ())\n  \t\tbreak;\n  \t    string cont;\n  \t    if (i < lsize - 1)\n  \t    {\n  \t\tconst YCPValue & element = syntax->value (1);\n  \t\tcont = unparseData (element, YCPNull ());\n  \t\tif (cont.empty ())\n  \t\t{\n  \t\t    if (element->valuetype () != YT_TERM)\n  \t\t\tbreak;\n  \t\t    else\n  \t\t    {\n  \t\t\tYCPTerm term = element->asTerm ();\n  \t\t\tif ((term.isNull ())\n  \t\t\t    || ((term->name () != \"Skip\")\n  \t\t\t\t&& (term->name () !=\n  \t\t\t\t    \"Fillup\")))\n  \t\t\t{\n  \t\t\t    break;\n  \t\t\t}\n  \t\t    }\n  \t\t}\n  \t    }\n  \t    else\t\t// no continuation after last list element\n  \t\tcont = \"\";\n  \n  \t    s += data;\n  \t    s += cont;\n  \t}\n      }\n  \n      return s;\n  }\n}"
  },
  {
    "function_name": "parseList",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
    "lines": "219-247",
    "snippet": "YCPValue\nAnyAgent::parseList (char const *&line, const YCPList & syntax, bool optional)\n{\n    if (syntax.isNull ())\n\treturn YCPNull ();\n\n    y2debug (\"parseList ('%s',[%s])\", line, syntax->toString ().c_str ());\n\n    YCPList list;\n\n    for (;;)\n    {\n\t// value of line\n\tYCPValue vl = parseData (line, syntax->value (0), optional);\n\toptional = false;\n\tif (vl.isNull ())\n\t    break;\n\tif (!vl->isVoid ())\n\t    list->add (vl);\n\ty2debug (\"vl (%s)\", vl->toString ().c_str ());\n\t// value of separator/string\n\tYCPValue vs = parseData (line, syntax->value (1), false);\n\tif (vs.isNull ())\n\t    break;\n    }\n\n    y2debug (\"list (%s)\", list->toString ().c_str ());\n    return list;\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"list (%s)\"",
            "list->toString ().c_str ()"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list->toString",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vs.isNull",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseData",
          "args": [
            "line",
            "syntax->value (1)",
            "false"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "parseData",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "429-705",
          "snippet": "YCPValue\nAnyAgent::parseData (char const *&line, const YCPValue & syntax, bool optional)\n{\n    if ((line == 0) || (*line == 0))\n\tline = getLine ();\n    if (line == 0)\n\treturn YCPNull ();\n    if (syntax.isNull ())\n\treturn YCPNull ();\n\n    y2debug (\"parseData %s('%s',[%s])\", (optional ? \"?\" : \"!\"), line,\n\t     syntax->toString ().c_str ());\n\n    switch (syntax->valuetype ())\n    {\n\tcase YT_TERM: {\n\n\t    YCPTerm term = syntax->asTerm ();\n\t    const string s = term->name ();\n\t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n\n\t    // Optional\n\n\t    if (s == \"Optional\" && term->size () > 0)\n\t    {\n\t\tYCPValue ov = parseData (line, term->value (0), true);\n\t\tif (ov.isNull ())\n\t\t    ov = YCPVoid ();\n\t\treturn ov;\n\t    }\n\n\t    // Continue\n\n\t    else if (s == \"Continue\" && term->size () > 0)\n\t    {\n\t\tYCPValue tv = parseData (line, term->value (0), false);\n\t\tif (!tv.isNull ())\n\t\t    tupleContinue = true;\n\t\treturn tv;\n\t    }\n\n\t    // Choice\n\n\t    else if (s == \"Choice\" && term->size () > 0)\n\t    {\n\t\treturn parseChoice (line, term->args (), optional);\n\t    }\n\n\t    // Sequence\n\n\t    else if (s == \"Sequence\" && term->size () > 0)\n\t    {\n\t\treturn parseSequence (line, term->args (), optional);\n\t    }\n\n\t    // List\n\n\t    else if (s == \"List\" && term->size () == 2)\n\t    {\n\t\treturn parseList (line, term->args (), optional);\n\t    }\n\n\t    // Tuple\n\n\t    else if (s == \"Tuple\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tYCPValue tv = parseTuple (line, term->args (), optional);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn tv;\n\t    }\n\n\t    // Var\n\n\t    else if (s == \"Var\" && term->size () > 0)\n\t    {\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    if (parseData (line, term->value (i), optional).isNull ())\n\t\t\tbreak;\n\t\t}\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Name\n\n\t    else if (s == \"Name\" && term->size () == 1)\n\t    {\n\t\tif (!mReadOnly)\n\t\t{\n\t\t    y2error (\"'Name' not allowed for writable agents\");\n\t\t    return YCPNull ();\n\t\t}\n\t\tYCPValue tn = parseData (line, term->value (0), false);\n\t\tif (!tn.isNull () && tupleName.size () > 0)\n\t\t{\n\t\t    if (tn->isString ())\n\t\t\ttupleName.top () = tn->asString ()->value ();\n\t\t    else\n\t\t\ttupleName.top () = tn->toString ();\n\t\t    y2debug (\"Name: %s\", tn->toString ().c_str ());\n\t\t}\n\t\treturn tn;\n\t    }\n\n\t    // Value\n\n\t    else if (s == \"Value\" && term->size () == 1)\n\t    {\n\t\tYCPValue tv = parseData (line, term->value (0), false);\n\t\tif (!tv.isNull () && tupleValue.size () > 0)\n\t\t    tupleValue.top () = tv;\n\t\t// y2debug (\"Value: %p\", tv);\n\t\treturn tv;\n\t    }\n\n\t    // Fillup\n\n\t    else if (isFillup && (s == \"Fillup\") &&\t// fillup allowed and Fillup () found\n\t\t     (term->size () == 0) && (tupleName.size () > 0))\n\t    {\t\t// inside Tuple ()\n\t\tstring fillup;\n\t\twhile ((line != 0)\n\t\t       && (mComment.find_first_of (line[0]) != string::npos))\n\t\t{\n\t\t    fillup = fillup + line;\n\t\t    line = getLine ();\n\t\t}\n\t\ttupleName.top () = KEY4FILLUP;\n\t\ttupleValue.top () = YCPString (fillup);\n\t\treturn tupleValue.top ();\n\t    }\n\n\t    // Skip\n\n\t    else if (s == \"Skip\")\n\t    {\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Match\n\n\t    else if (s == \"Match\")\n\t    {\n\t\treturn currentMatch;\n\t    }\n\n\t    // Separator\n\n\t    else if (s == \"Separator\" && term->size () == 1)\n\t    {\n\t\treturn parseSeparator (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t       optional);\n\t    }\n\n\t    // Whitespace\n\n\t    else if (s == \"Whitespace\")\n\t    {\n\t\treturn parseSeparator (line, \" \\t\", optional);\n\t    }\n\n\t    // String\n\n\t    else if (s == \"String\" && term->size () > 0)\n\t    {\n\t\tif (term->size () == 1)\n\t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t\t0, optional);\n\t\tif (term->size () == 2)\n\t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t\tterm->value (1)->asString ()->value ().c_str (),\n\t\t\t\t\toptional);\n\t    }\n\n\t    // Or\n\n\t    else if (s == \"Or\" && term->size () > 0)\n\t    {\n\t\tconst char *ltry = line;\n\t\tbool lopt = false;\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    if (i == term->size () - 1)\t// pass optional on last try\n\t\t\tlopt = optional;\n\t\t    YCPValue vtry = parseData (ltry, term->value (i), lopt);\n\t\t    if (!vtry.isNull ())\n\t\t    {\n\t\t\ty2debug (\"Or () success\");\n\t\t\tline = ltry;\n\t\t\treturn vtry;\n\t\t    }\n\t\t}\n\t\ty2debug (\"Or () failed\");\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Number\n\n\t    else if (s == \"Number\")\n\t    {\n\t\treturn parseNumber (line, optional);\n\t    }\n\n\t    // Hexval\n\n\t    else if (s == \"Hexval\")\n\t    {\n\t\treturn parseHexval (line, optional);\n\t    }\n\n\t    // Boolean\n\n\t    else if (s == \"Boolean\")\n\t    {\n\t\treturn parseBoolean (line, optional);\n\t    }\n\n\t    // Float\n\n\t    else if (s == \"Float\")\n\t    {\n\t\treturn parseFloat (line, optional);\n\t    }\n\n\t    // Ip4Number\n\n\t    else if (s == \"Ip4Number\")\n\t    {\n\t\treturn parseIp4Number (line, optional);\n\t    }\n\n\t    // Hostname\n\n\t    else if (s == \"Hostname\")\n\t    {\n\t\treturn parseHostname (line, optional);\n\t    }\n\n\t    // Username\n\n\t    else if (s == \"Username\")\n\t    {\n\t\treturn parseUsername (line, optional);\n\t    }\n\n\t    // <name>\n\n\t    else if (islower (s[0]) && tupleName.size () > 0 && (term->size () == 1))\n\t    {\n\t\ttupleName.top () = s;\n\t\ttupleValue.top () = parseData (line, term->value (0), optional);\n\t\treturn tupleValue.top ();\n\t    }\n\n\t    else\n\t    {\n\t\ty2error (\"parseData: unknown term '%s'\", s.c_str ());\n\t\treturn YCPVoid ();\n\t    }\n\t} break;\n\n\tcase YT_STRING:\n\t    y2debug (\"YT_STRING\");\n\t    return parseVerbose (line, syntax->asString ()->value ().c_str (),\n\t\t\t\t optional);\n\t    break;\n\n\tdefault:\n\t    y2error (\"parseData: unknown syntax %s\", syntax->toString ().c_str ());\n\t    break;\n    }\n\n    return YCPNull ();\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define KEY4FILLUP \"`FILLUP\""
          ],
          "globals_used": [
            "static YCPValue currentMatch = YCPNull ();"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define KEY4FILLUP \"`FILLUP\"\n\nstatic YCPValue currentMatch = YCPNull ();\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseData (char const *&line, const YCPValue & syntax, bool optional)\n  {\n      if ((line == 0) || (*line == 0))\n  \tline = getLine ();\n      if (line == 0)\n  \treturn YCPNull ();\n      if (syntax.isNull ())\n  \treturn YCPNull ();\n  \n      y2debug (\"parseData %s('%s',[%s])\", (optional ? \"?\" : \"!\"), line,\n  \t     syntax->toString ().c_str ());\n  \n      switch (syntax->valuetype ())\n      {\n  \tcase YT_TERM: {\n  \n  \t    YCPTerm term = syntax->asTerm ();\n  \t    const string s = term->name ();\n  \t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n  \n  \t    // Optional\n  \n  \t    if (s == \"Optional\" && term->size () > 0)\n  \t    {\n  \t\tYCPValue ov = parseData (line, term->value (0), true);\n  \t\tif (ov.isNull ())\n  \t\t    ov = YCPVoid ();\n  \t\treturn ov;\n  \t    }\n  \n  \t    // Continue\n  \n  \t    else if (s == \"Continue\" && term->size () > 0)\n  \t    {\n  \t\tYCPValue tv = parseData (line, term->value (0), false);\n  \t\tif (!tv.isNull ())\n  \t\t    tupleContinue = true;\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Choice\n  \n  \t    else if (s == \"Choice\" && term->size () > 0)\n  \t    {\n  \t\treturn parseChoice (line, term->args (), optional);\n  \t    }\n  \n  \t    // Sequence\n  \n  \t    else if (s == \"Sequence\" && term->size () > 0)\n  \t    {\n  \t\treturn parseSequence (line, term->args (), optional);\n  \t    }\n  \n  \t    // List\n  \n  \t    else if (s == \"List\" && term->size () == 2)\n  \t    {\n  \t\treturn parseList (line, term->args (), optional);\n  \t    }\n  \n  \t    // Tuple\n  \n  \t    else if (s == \"Tuple\" && term->size () > 0)\n  \t    {\n  \t\ttupleName.push (\"\");\n  \t\ttupleValue.push (YCPNull ());\n  \t\tYCPValue tv = parseTuple (line, term->args (), optional);\n  \t\ttupleName.pop ();\n  \t\ttupleValue.pop ();\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Var\n  \n  \t    else if (s == \"Var\" && term->size () > 0)\n  \t    {\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    if (parseData (line, term->value (i), optional).isNull ())\n  \t\t\tbreak;\n  \t\t}\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Name\n  \n  \t    else if (s == \"Name\" && term->size () == 1)\n  \t    {\n  \t\tif (!mReadOnly)\n  \t\t{\n  \t\t    y2error (\"'Name' not allowed for writable agents\");\n  \t\t    return YCPNull ();\n  \t\t}\n  \t\tYCPValue tn = parseData (line, term->value (0), false);\n  \t\tif (!tn.isNull () && tupleName.size () > 0)\n  \t\t{\n  \t\t    if (tn->isString ())\n  \t\t\ttupleName.top () = tn->asString ()->value ();\n  \t\t    else\n  \t\t\ttupleName.top () = tn->toString ();\n  \t\t    y2debug (\"Name: %s\", tn->toString ().c_str ());\n  \t\t}\n  \t\treturn tn;\n  \t    }\n  \n  \t    // Value\n  \n  \t    else if (s == \"Value\" && term->size () == 1)\n  \t    {\n  \t\tYCPValue tv = parseData (line, term->value (0), false);\n  \t\tif (!tv.isNull () && tupleValue.size () > 0)\n  \t\t    tupleValue.top () = tv;\n  \t\t// y2debug (\"Value: %p\", tv);\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Fillup\n  \n  \t    else if (isFillup && (s == \"Fillup\") &&\t// fillup allowed and Fillup () found\n  \t\t     (term->size () == 0) && (tupleName.size () > 0))\n  \t    {\t\t// inside Tuple ()\n  \t\tstring fillup;\n  \t\twhile ((line != 0)\n  \t\t       && (mComment.find_first_of (line[0]) != string::npos))\n  \t\t{\n  \t\t    fillup = fillup + line;\n  \t\t    line = getLine ();\n  \t\t}\n  \t\ttupleName.top () = KEY4FILLUP;\n  \t\ttupleValue.top () = YCPString (fillup);\n  \t\treturn tupleValue.top ();\n  \t    }\n  \n  \t    // Skip\n  \n  \t    else if (s == \"Skip\")\n  \t    {\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Match\n  \n  \t    else if (s == \"Match\")\n  \t    {\n  \t\treturn currentMatch;\n  \t    }\n  \n  \t    // Separator\n  \n  \t    else if (s == \"Separator\" && term->size () == 1)\n  \t    {\n  \t\treturn parseSeparator (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t       optional);\n  \t    }\n  \n  \t    // Whitespace\n  \n  \t    else if (s == \"Whitespace\")\n  \t    {\n  \t\treturn parseSeparator (line, \" \\t\", optional);\n  \t    }\n  \n  \t    // String\n  \n  \t    else if (s == \"String\" && term->size () > 0)\n  \t    {\n  \t\tif (term->size () == 1)\n  \t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t\t0, optional);\n  \t\tif (term->size () == 2)\n  \t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t\tterm->value (1)->asString ()->value ().c_str (),\n  \t\t\t\t\toptional);\n  \t    }\n  \n  \t    // Or\n  \n  \t    else if (s == \"Or\" && term->size () > 0)\n  \t    {\n  \t\tconst char *ltry = line;\n  \t\tbool lopt = false;\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    if (i == term->size () - 1)\t// pass optional on last try\n  \t\t\tlopt = optional;\n  \t\t    YCPValue vtry = parseData (ltry, term->value (i), lopt);\n  \t\t    if (!vtry.isNull ())\n  \t\t    {\n  \t\t\ty2debug (\"Or () success\");\n  \t\t\tline = ltry;\n  \t\t\treturn vtry;\n  \t\t    }\n  \t\t}\n  \t\ty2debug (\"Or () failed\");\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Number\n  \n  \t    else if (s == \"Number\")\n  \t    {\n  \t\treturn parseNumber (line, optional);\n  \t    }\n  \n  \t    // Hexval\n  \n  \t    else if (s == \"Hexval\")\n  \t    {\n  \t\treturn parseHexval (line, optional);\n  \t    }\n  \n  \t    // Boolean\n  \n  \t    else if (s == \"Boolean\")\n  \t    {\n  \t\treturn parseBoolean (line, optional);\n  \t    }\n  \n  \t    // Float\n  \n  \t    else if (s == \"Float\")\n  \t    {\n  \t\treturn parseFloat (line, optional);\n  \t    }\n  \n  \t    // Ip4Number\n  \n  \t    else if (s == \"Ip4Number\")\n  \t    {\n  \t\treturn parseIp4Number (line, optional);\n  \t    }\n  \n  \t    // Hostname\n  \n  \t    else if (s == \"Hostname\")\n  \t    {\n  \t\treturn parseHostname (line, optional);\n  \t    }\n  \n  \t    // Username\n  \n  \t    else if (s == \"Username\")\n  \t    {\n  \t\treturn parseUsername (line, optional);\n  \t    }\n  \n  \t    // <name>\n  \n  \t    else if (islower (s[0]) && tupleName.size () > 0 && (term->size () == 1))\n  \t    {\n  \t\ttupleName.top () = s;\n  \t\ttupleValue.top () = parseData (line, term->value (0), optional);\n  \t\treturn tupleValue.top ();\n  \t    }\n  \n  \t    else\n  \t    {\n  \t\ty2error (\"parseData: unknown term '%s'\", s.c_str ());\n  \t\treturn YCPVoid ();\n  \t    }\n  \t} break;\n  \n  \tcase YT_STRING:\n  \t    y2debug (\"YT_STRING\");\n  \t    return parseVerbose (line, syntax->asString ()->value ().c_str (),\n  \t\t\t\t optional);\n  \t    break;\n  \n  \tdefault:\n  \t    y2error (\"parseData: unknown syntax %s\", syntax->toString ().c_str ());\n  \t    break;\n      }\n  \n      return YCPNull ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "syntax->value",
          "args": [
            "1"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"vl (%s)\"",
            "vl->toString ().c_str ()"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list->add",
          "args": [
            "vl"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vl->isVoid",
          "args": [],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vl.isNull",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"parseList ('%s',[%s])\"",
            "line",
            "syntax->toString ().c_str ()"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syntax.isNull",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseList (char const *&line, const YCPList & syntax, bool optional)\n  {\n      if (syntax.isNull ())\n  \treturn YCPNull ();\n  \n      y2debug (\"parseList ('%s',[%s])\", line, syntax->toString ().c_str ());\n  \n      YCPList list;\n  \n      for (;;)\n      {\n  \t// value of line\n  \tYCPValue vl = parseData (line, syntax->value (0), optional);\n  \toptional = false;\n  \tif (vl.isNull ())\n  \t    break;\n  \tif (!vl->isVoid ())\n  \t    list->add (vl);\n  \ty2debug (\"vl (%s)\", vl->toString ().c_str ());\n  \t// value of separator/string\n  \tYCPValue vs = parseData (line, syntax->value (1), false);\n  \tif (vs.isNull ())\n  \t    break;\n      }\n  \n      y2debug (\"list (%s)\", list->toString ().c_str ());\n      return list;\n  }\n}"
  },
  {
    "function_name": "unparseSequence",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
    "lines": "209-213",
    "snippet": "const string\nAnyAgent::unparseSequence (const YCPList & syntax, const YCPValue & value)\n{\n    return \"\";\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseSequence (const YCPList & syntax, const YCPValue & value)\n  {\n      return \"\";\n  }\n}"
  },
  {
    "function_name": "parseSequence",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
    "lines": "176-203",
    "snippet": "YCPValue\nAnyAgent::parseSequence (char const *&line, const YCPList & syntax,\n\t\t\t bool optional)\n{\n    YCPValue element = YCPNull ();\n    if (syntax.isNull ())\n\treturn element;\n\n    y2debug (\"parseSequence ('%s',[%s])\", line, syntax->toString ().c_str ());\n\n    char const *lstart = line;\n\n    for (int i = 0; i < syntax->size (); i++)\n    {\n\telement = syntax->value (i);\n\n\telement = parseData (line, element, optional);\n\n\tif (element.isNull ())\n\t{\n\t    lstart = 0;\n\t    break;\n\t}\n    }\n    if (lstart != 0)\n\treturn YCPString (string (lstart, line - lstart));\n    return element;\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "string (lstart, line - lstart)"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "lstart",
            "line - lstart"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "read_file_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
          "lines": "145-165",
          "snippet": "static int read_file_to_string (const char* filename, string& output)\n{\n    int fd = open (filename, O_RDONLY);\n    output = \"\";\n    if (fd < 0)\n    {\n\treturn errno;\n    }\n\n    while (true)\n    {\n\tchar buffer[4096];\n\tssize_t bytes_read = read (fd, buffer, 4095);\n\tif (bytes_read <= 0)\n\t    break;\n\tbuffer[bytes_read] = 0; // 0 terminate string\n\toutput += buffer;\n    }\n    close(fd);\n    return 0;\n}",
          "includes": [
            "#include \"ShellCommand.h\"",
            "#include \"SystemAgent.h\"",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/pathsearch.h>",
            "#include <YCP.h>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <string>",
            "#include <linux/lp.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <resolv.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int read_file_to_string (const char* filename, string& output)\n{\n    int fd = open (filename, O_RDONLY);\n    output = \"\";\n    if (fd < 0)\n    {\n\treturn errno;\n    }\n\n    while (true)\n    {\n\tchar buffer[4096];\n\tssize_t bytes_read = read (fd, buffer, 4095);\n\tif (bytes_read <= 0)\n\t    break;\n\tbuffer[bytes_read] = 0; // 0 terminate string\n\toutput += buffer;\n    }\n    close(fd);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "element.isNull",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseData",
          "args": [
            "line",
            "element",
            "optional"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "parseData",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "429-705",
          "snippet": "YCPValue\nAnyAgent::parseData (char const *&line, const YCPValue & syntax, bool optional)\n{\n    if ((line == 0) || (*line == 0))\n\tline = getLine ();\n    if (line == 0)\n\treturn YCPNull ();\n    if (syntax.isNull ())\n\treturn YCPNull ();\n\n    y2debug (\"parseData %s('%s',[%s])\", (optional ? \"?\" : \"!\"), line,\n\t     syntax->toString ().c_str ());\n\n    switch (syntax->valuetype ())\n    {\n\tcase YT_TERM: {\n\n\t    YCPTerm term = syntax->asTerm ();\n\t    const string s = term->name ();\n\t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n\n\t    // Optional\n\n\t    if (s == \"Optional\" && term->size () > 0)\n\t    {\n\t\tYCPValue ov = parseData (line, term->value (0), true);\n\t\tif (ov.isNull ())\n\t\t    ov = YCPVoid ();\n\t\treturn ov;\n\t    }\n\n\t    // Continue\n\n\t    else if (s == \"Continue\" && term->size () > 0)\n\t    {\n\t\tYCPValue tv = parseData (line, term->value (0), false);\n\t\tif (!tv.isNull ())\n\t\t    tupleContinue = true;\n\t\treturn tv;\n\t    }\n\n\t    // Choice\n\n\t    else if (s == \"Choice\" && term->size () > 0)\n\t    {\n\t\treturn parseChoice (line, term->args (), optional);\n\t    }\n\n\t    // Sequence\n\n\t    else if (s == \"Sequence\" && term->size () > 0)\n\t    {\n\t\treturn parseSequence (line, term->args (), optional);\n\t    }\n\n\t    // List\n\n\t    else if (s == \"List\" && term->size () == 2)\n\t    {\n\t\treturn parseList (line, term->args (), optional);\n\t    }\n\n\t    // Tuple\n\n\t    else if (s == \"Tuple\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tYCPValue tv = parseTuple (line, term->args (), optional);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn tv;\n\t    }\n\n\t    // Var\n\n\t    else if (s == \"Var\" && term->size () > 0)\n\t    {\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    if (parseData (line, term->value (i), optional).isNull ())\n\t\t\tbreak;\n\t\t}\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Name\n\n\t    else if (s == \"Name\" && term->size () == 1)\n\t    {\n\t\tif (!mReadOnly)\n\t\t{\n\t\t    y2error (\"'Name' not allowed for writable agents\");\n\t\t    return YCPNull ();\n\t\t}\n\t\tYCPValue tn = parseData (line, term->value (0), false);\n\t\tif (!tn.isNull () && tupleName.size () > 0)\n\t\t{\n\t\t    if (tn->isString ())\n\t\t\ttupleName.top () = tn->asString ()->value ();\n\t\t    else\n\t\t\ttupleName.top () = tn->toString ();\n\t\t    y2debug (\"Name: %s\", tn->toString ().c_str ());\n\t\t}\n\t\treturn tn;\n\t    }\n\n\t    // Value\n\n\t    else if (s == \"Value\" && term->size () == 1)\n\t    {\n\t\tYCPValue tv = parseData (line, term->value (0), false);\n\t\tif (!tv.isNull () && tupleValue.size () > 0)\n\t\t    tupleValue.top () = tv;\n\t\t// y2debug (\"Value: %p\", tv);\n\t\treturn tv;\n\t    }\n\n\t    // Fillup\n\n\t    else if (isFillup && (s == \"Fillup\") &&\t// fillup allowed and Fillup () found\n\t\t     (term->size () == 0) && (tupleName.size () > 0))\n\t    {\t\t// inside Tuple ()\n\t\tstring fillup;\n\t\twhile ((line != 0)\n\t\t       && (mComment.find_first_of (line[0]) != string::npos))\n\t\t{\n\t\t    fillup = fillup + line;\n\t\t    line = getLine ();\n\t\t}\n\t\ttupleName.top () = KEY4FILLUP;\n\t\ttupleValue.top () = YCPString (fillup);\n\t\treturn tupleValue.top ();\n\t    }\n\n\t    // Skip\n\n\t    else if (s == \"Skip\")\n\t    {\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Match\n\n\t    else if (s == \"Match\")\n\t    {\n\t\treturn currentMatch;\n\t    }\n\n\t    // Separator\n\n\t    else if (s == \"Separator\" && term->size () == 1)\n\t    {\n\t\treturn parseSeparator (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t       optional);\n\t    }\n\n\t    // Whitespace\n\n\t    else if (s == \"Whitespace\")\n\t    {\n\t\treturn parseSeparator (line, \" \\t\", optional);\n\t    }\n\n\t    // String\n\n\t    else if (s == \"String\" && term->size () > 0)\n\t    {\n\t\tif (term->size () == 1)\n\t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t\t0, optional);\n\t\tif (term->size () == 2)\n\t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t\tterm->value (1)->asString ()->value ().c_str (),\n\t\t\t\t\toptional);\n\t    }\n\n\t    // Or\n\n\t    else if (s == \"Or\" && term->size () > 0)\n\t    {\n\t\tconst char *ltry = line;\n\t\tbool lopt = false;\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    if (i == term->size () - 1)\t// pass optional on last try\n\t\t\tlopt = optional;\n\t\t    YCPValue vtry = parseData (ltry, term->value (i), lopt);\n\t\t    if (!vtry.isNull ())\n\t\t    {\n\t\t\ty2debug (\"Or () success\");\n\t\t\tline = ltry;\n\t\t\treturn vtry;\n\t\t    }\n\t\t}\n\t\ty2debug (\"Or () failed\");\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Number\n\n\t    else if (s == \"Number\")\n\t    {\n\t\treturn parseNumber (line, optional);\n\t    }\n\n\t    // Hexval\n\n\t    else if (s == \"Hexval\")\n\t    {\n\t\treturn parseHexval (line, optional);\n\t    }\n\n\t    // Boolean\n\n\t    else if (s == \"Boolean\")\n\t    {\n\t\treturn parseBoolean (line, optional);\n\t    }\n\n\t    // Float\n\n\t    else if (s == \"Float\")\n\t    {\n\t\treturn parseFloat (line, optional);\n\t    }\n\n\t    // Ip4Number\n\n\t    else if (s == \"Ip4Number\")\n\t    {\n\t\treturn parseIp4Number (line, optional);\n\t    }\n\n\t    // Hostname\n\n\t    else if (s == \"Hostname\")\n\t    {\n\t\treturn parseHostname (line, optional);\n\t    }\n\n\t    // Username\n\n\t    else if (s == \"Username\")\n\t    {\n\t\treturn parseUsername (line, optional);\n\t    }\n\n\t    // <name>\n\n\t    else if (islower (s[0]) && tupleName.size () > 0 && (term->size () == 1))\n\t    {\n\t\ttupleName.top () = s;\n\t\ttupleValue.top () = parseData (line, term->value (0), optional);\n\t\treturn tupleValue.top ();\n\t    }\n\n\t    else\n\t    {\n\t\ty2error (\"parseData: unknown term '%s'\", s.c_str ());\n\t\treturn YCPVoid ();\n\t    }\n\t} break;\n\n\tcase YT_STRING:\n\t    y2debug (\"YT_STRING\");\n\t    return parseVerbose (line, syntax->asString ()->value ().c_str (),\n\t\t\t\t optional);\n\t    break;\n\n\tdefault:\n\t    y2error (\"parseData: unknown syntax %s\", syntax->toString ().c_str ());\n\t    break;\n    }\n\n    return YCPNull ();\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define KEY4FILLUP \"`FILLUP\""
          ],
          "globals_used": [
            "static YCPValue currentMatch = YCPNull ();"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define KEY4FILLUP \"`FILLUP\"\n\nstatic YCPValue currentMatch = YCPNull ();\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseData (char const *&line, const YCPValue & syntax, bool optional)\n  {\n      if ((line == 0) || (*line == 0))\n  \tline = getLine ();\n      if (line == 0)\n  \treturn YCPNull ();\n      if (syntax.isNull ())\n  \treturn YCPNull ();\n  \n      y2debug (\"parseData %s('%s',[%s])\", (optional ? \"?\" : \"!\"), line,\n  \t     syntax->toString ().c_str ());\n  \n      switch (syntax->valuetype ())\n      {\n  \tcase YT_TERM: {\n  \n  \t    YCPTerm term = syntax->asTerm ();\n  \t    const string s = term->name ();\n  \t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n  \n  \t    // Optional\n  \n  \t    if (s == \"Optional\" && term->size () > 0)\n  \t    {\n  \t\tYCPValue ov = parseData (line, term->value (0), true);\n  \t\tif (ov.isNull ())\n  \t\t    ov = YCPVoid ();\n  \t\treturn ov;\n  \t    }\n  \n  \t    // Continue\n  \n  \t    else if (s == \"Continue\" && term->size () > 0)\n  \t    {\n  \t\tYCPValue tv = parseData (line, term->value (0), false);\n  \t\tif (!tv.isNull ())\n  \t\t    tupleContinue = true;\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Choice\n  \n  \t    else if (s == \"Choice\" && term->size () > 0)\n  \t    {\n  \t\treturn parseChoice (line, term->args (), optional);\n  \t    }\n  \n  \t    // Sequence\n  \n  \t    else if (s == \"Sequence\" && term->size () > 0)\n  \t    {\n  \t\treturn parseSequence (line, term->args (), optional);\n  \t    }\n  \n  \t    // List\n  \n  \t    else if (s == \"List\" && term->size () == 2)\n  \t    {\n  \t\treturn parseList (line, term->args (), optional);\n  \t    }\n  \n  \t    // Tuple\n  \n  \t    else if (s == \"Tuple\" && term->size () > 0)\n  \t    {\n  \t\ttupleName.push (\"\");\n  \t\ttupleValue.push (YCPNull ());\n  \t\tYCPValue tv = parseTuple (line, term->args (), optional);\n  \t\ttupleName.pop ();\n  \t\ttupleValue.pop ();\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Var\n  \n  \t    else if (s == \"Var\" && term->size () > 0)\n  \t    {\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    if (parseData (line, term->value (i), optional).isNull ())\n  \t\t\tbreak;\n  \t\t}\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Name\n  \n  \t    else if (s == \"Name\" && term->size () == 1)\n  \t    {\n  \t\tif (!mReadOnly)\n  \t\t{\n  \t\t    y2error (\"'Name' not allowed for writable agents\");\n  \t\t    return YCPNull ();\n  \t\t}\n  \t\tYCPValue tn = parseData (line, term->value (0), false);\n  \t\tif (!tn.isNull () && tupleName.size () > 0)\n  \t\t{\n  \t\t    if (tn->isString ())\n  \t\t\ttupleName.top () = tn->asString ()->value ();\n  \t\t    else\n  \t\t\ttupleName.top () = tn->toString ();\n  \t\t    y2debug (\"Name: %s\", tn->toString ().c_str ());\n  \t\t}\n  \t\treturn tn;\n  \t    }\n  \n  \t    // Value\n  \n  \t    else if (s == \"Value\" && term->size () == 1)\n  \t    {\n  \t\tYCPValue tv = parseData (line, term->value (0), false);\n  \t\tif (!tv.isNull () && tupleValue.size () > 0)\n  \t\t    tupleValue.top () = tv;\n  \t\t// y2debug (\"Value: %p\", tv);\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Fillup\n  \n  \t    else if (isFillup && (s == \"Fillup\") &&\t// fillup allowed and Fillup () found\n  \t\t     (term->size () == 0) && (tupleName.size () > 0))\n  \t    {\t\t// inside Tuple ()\n  \t\tstring fillup;\n  \t\twhile ((line != 0)\n  \t\t       && (mComment.find_first_of (line[0]) != string::npos))\n  \t\t{\n  \t\t    fillup = fillup + line;\n  \t\t    line = getLine ();\n  \t\t}\n  \t\ttupleName.top () = KEY4FILLUP;\n  \t\ttupleValue.top () = YCPString (fillup);\n  \t\treturn tupleValue.top ();\n  \t    }\n  \n  \t    // Skip\n  \n  \t    else if (s == \"Skip\")\n  \t    {\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Match\n  \n  \t    else if (s == \"Match\")\n  \t    {\n  \t\treturn currentMatch;\n  \t    }\n  \n  \t    // Separator\n  \n  \t    else if (s == \"Separator\" && term->size () == 1)\n  \t    {\n  \t\treturn parseSeparator (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t       optional);\n  \t    }\n  \n  \t    // Whitespace\n  \n  \t    else if (s == \"Whitespace\")\n  \t    {\n  \t\treturn parseSeparator (line, \" \\t\", optional);\n  \t    }\n  \n  \t    // String\n  \n  \t    else if (s == \"String\" && term->size () > 0)\n  \t    {\n  \t\tif (term->size () == 1)\n  \t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t\t0, optional);\n  \t\tif (term->size () == 2)\n  \t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t\tterm->value (1)->asString ()->value ().c_str (),\n  \t\t\t\t\toptional);\n  \t    }\n  \n  \t    // Or\n  \n  \t    else if (s == \"Or\" && term->size () > 0)\n  \t    {\n  \t\tconst char *ltry = line;\n  \t\tbool lopt = false;\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    if (i == term->size () - 1)\t// pass optional on last try\n  \t\t\tlopt = optional;\n  \t\t    YCPValue vtry = parseData (ltry, term->value (i), lopt);\n  \t\t    if (!vtry.isNull ())\n  \t\t    {\n  \t\t\ty2debug (\"Or () success\");\n  \t\t\tline = ltry;\n  \t\t\treturn vtry;\n  \t\t    }\n  \t\t}\n  \t\ty2debug (\"Or () failed\");\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Number\n  \n  \t    else if (s == \"Number\")\n  \t    {\n  \t\treturn parseNumber (line, optional);\n  \t    }\n  \n  \t    // Hexval\n  \n  \t    else if (s == \"Hexval\")\n  \t    {\n  \t\treturn parseHexval (line, optional);\n  \t    }\n  \n  \t    // Boolean\n  \n  \t    else if (s == \"Boolean\")\n  \t    {\n  \t\treturn parseBoolean (line, optional);\n  \t    }\n  \n  \t    // Float\n  \n  \t    else if (s == \"Float\")\n  \t    {\n  \t\treturn parseFloat (line, optional);\n  \t    }\n  \n  \t    // Ip4Number\n  \n  \t    else if (s == \"Ip4Number\")\n  \t    {\n  \t\treturn parseIp4Number (line, optional);\n  \t    }\n  \n  \t    // Hostname\n  \n  \t    else if (s == \"Hostname\")\n  \t    {\n  \t\treturn parseHostname (line, optional);\n  \t    }\n  \n  \t    // Username\n  \n  \t    else if (s == \"Username\")\n  \t    {\n  \t\treturn parseUsername (line, optional);\n  \t    }\n  \n  \t    // <name>\n  \n  \t    else if (islower (s[0]) && tupleName.size () > 0 && (term->size () == 1))\n  \t    {\n  \t\ttupleName.top () = s;\n  \t\ttupleValue.top () = parseData (line, term->value (0), optional);\n  \t\treturn tupleValue.top ();\n  \t    }\n  \n  \t    else\n  \t    {\n  \t\ty2error (\"parseData: unknown term '%s'\", s.c_str ());\n  \t\treturn YCPVoid ();\n  \t    }\n  \t} break;\n  \n  \tcase YT_STRING:\n  \t    y2debug (\"YT_STRING\");\n  \t    return parseVerbose (line, syntax->asString ()->value ().c_str (),\n  \t\t\t\t optional);\n  \t    break;\n  \n  \tdefault:\n  \t    y2error (\"parseData: unknown syntax %s\", syntax->toString ().c_str ());\n  \t    break;\n      }\n  \n      return YCPNull ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "syntax->value",
          "args": [
            "i"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "syntax->size",
          "args": [],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"parseSequence ('%s',[%s])\"",
            "line",
            "syntax->toString ().c_str ()"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syntax->toString",
          "args": [],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "syntax.isNull",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseSequence (char const *&line, const YCPList & syntax,\n  \t\t\t bool optional)\n  {\n      YCPValue element = YCPNull ();\n      if (syntax.isNull ())\n  \treturn element;\n  \n      y2debug (\"parseSequence ('%s',[%s])\", line, syntax->toString ().c_str ());\n  \n      char const *lstart = line;\n  \n      for (int i = 0; i < syntax->size (); i++)\n      {\n  \telement = syntax->value (i);\n  \n  \telement = parseData (line, element, optional);\n  \n  \tif (element.isNull ())\n  \t{\n  \t    lstart = 0;\n  \t    break;\n  \t}\n      }\n      if (lstart != 0)\n  \treturn YCPString (string (lstart, line - lstart));\n      return element;\n  }\n}"
  },
  {
    "function_name": "unparseChoice",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
    "lines": "166-170",
    "snippet": "const string\nAnyAgent::unparseChoice (const YCPList & syntax, const YCPValue & value)\n{\n    return \"\";\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::unparseChoice (const YCPList & syntax, const YCPValue & value)\n  {\n      return \"\";\n  }\n}"
  },
  {
    "function_name": "parseChoice",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
    "lines": "105-160",
    "snippet": "YCPValue\nAnyAgent::parseChoice (char const *&line, const YCPList & syntax, bool optional)\n{\n    if ((line == 0) || syntax.isNull ())\n\treturn YCPNull ();\n\n    y2debug (\"parseChoice ('%s',[%s])\", line, syntax->toString ().c_str ());\n\n    for (int i = 0; i < syntax->size (); i++)\n    {\n\tYCPValue v = syntax->value (i);\n\tif (v.isNull ())\n\t{\n\t    y2error (\"Bad element in Choice()\");\n\t    return YCPNull ();\n\t}\n\tif (!v->isList ())\n\t{\n\t    y2error (\"Choice element must be list\");\n\t    return YCPNull ();\n\t}\n\n\tYCPList element = v->asList ();\n\tif ((element->size () <= 0) || (element->size () > 2))\n\t{\n\t    y2error (\"Choice element list must have 1 or 2 entries\");\n\t    return YCPNull ();\n\t}\n\n\tYCPValue match = element->value (0);\n\n\t// get optional action\n\n\tYCPValue action = (element->size () > 1) ? element->value (1) : YCPNull ();\n\n\t// force match\n\ty2debug (\"choice (%d)\", i);\n\n\tchar const *try_line = line;\n\n\tcurrentMatch = parseData (try_line, match, false);\n\n\t// have match\n\tif (!currentMatch.isNull ())\n\t{\n\t    line = try_line;\n\t    y2debug (\"choice (%d) match\", i);\n\t    if (!action.isNull ())\n\t\treturn parseData (line, action, optional);\n\t    else\n\t\treturn currentMatch;\n\t}\n    }\n\n    return YCPNull ();\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static YCPValue currentMatch = YCPNull ();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseData",
          "args": [
            "line",
            "action",
            "optional"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "parseData",
          "container": "AnyAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
          "lines": "429-705",
          "snippet": "YCPValue\nAnyAgent::parseData (char const *&line, const YCPValue & syntax, bool optional)\n{\n    if ((line == 0) || (*line == 0))\n\tline = getLine ();\n    if (line == 0)\n\treturn YCPNull ();\n    if (syntax.isNull ())\n\treturn YCPNull ();\n\n    y2debug (\"parseData %s('%s',[%s])\", (optional ? \"?\" : \"!\"), line,\n\t     syntax->toString ().c_str ());\n\n    switch (syntax->valuetype ())\n    {\n\tcase YT_TERM: {\n\n\t    YCPTerm term = syntax->asTerm ();\n\t    const string s = term->name ();\n\t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n\n\t    // Optional\n\n\t    if (s == \"Optional\" && term->size () > 0)\n\t    {\n\t\tYCPValue ov = parseData (line, term->value (0), true);\n\t\tif (ov.isNull ())\n\t\t    ov = YCPVoid ();\n\t\treturn ov;\n\t    }\n\n\t    // Continue\n\n\t    else if (s == \"Continue\" && term->size () > 0)\n\t    {\n\t\tYCPValue tv = parseData (line, term->value (0), false);\n\t\tif (!tv.isNull ())\n\t\t    tupleContinue = true;\n\t\treturn tv;\n\t    }\n\n\t    // Choice\n\n\t    else if (s == \"Choice\" && term->size () > 0)\n\t    {\n\t\treturn parseChoice (line, term->args (), optional);\n\t    }\n\n\t    // Sequence\n\n\t    else if (s == \"Sequence\" && term->size () > 0)\n\t    {\n\t\treturn parseSequence (line, term->args (), optional);\n\t    }\n\n\t    // List\n\n\t    else if (s == \"List\" && term->size () == 2)\n\t    {\n\t\treturn parseList (line, term->args (), optional);\n\t    }\n\n\t    // Tuple\n\n\t    else if (s == \"Tuple\" && term->size () > 0)\n\t    {\n\t\ttupleName.push (\"\");\n\t\ttupleValue.push (YCPNull ());\n\t\tYCPValue tv = parseTuple (line, term->args (), optional);\n\t\ttupleName.pop ();\n\t\ttupleValue.pop ();\n\t\treturn tv;\n\t    }\n\n\t    // Var\n\n\t    else if (s == \"Var\" && term->size () > 0)\n\t    {\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    if (parseData (line, term->value (i), optional).isNull ())\n\t\t\tbreak;\n\t\t}\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Name\n\n\t    else if (s == \"Name\" && term->size () == 1)\n\t    {\n\t\tif (!mReadOnly)\n\t\t{\n\t\t    y2error (\"'Name' not allowed for writable agents\");\n\t\t    return YCPNull ();\n\t\t}\n\t\tYCPValue tn = parseData (line, term->value (0), false);\n\t\tif (!tn.isNull () && tupleName.size () > 0)\n\t\t{\n\t\t    if (tn->isString ())\n\t\t\ttupleName.top () = tn->asString ()->value ();\n\t\t    else\n\t\t\ttupleName.top () = tn->toString ();\n\t\t    y2debug (\"Name: %s\", tn->toString ().c_str ());\n\t\t}\n\t\treturn tn;\n\t    }\n\n\t    // Value\n\n\t    else if (s == \"Value\" && term->size () == 1)\n\t    {\n\t\tYCPValue tv = parseData (line, term->value (0), false);\n\t\tif (!tv.isNull () && tupleValue.size () > 0)\n\t\t    tupleValue.top () = tv;\n\t\t// y2debug (\"Value: %p\", tv);\n\t\treturn tv;\n\t    }\n\n\t    // Fillup\n\n\t    else if (isFillup && (s == \"Fillup\") &&\t// fillup allowed and Fillup () found\n\t\t     (term->size () == 0) && (tupleName.size () > 0))\n\t    {\t\t// inside Tuple ()\n\t\tstring fillup;\n\t\twhile ((line != 0)\n\t\t       && (mComment.find_first_of (line[0]) != string::npos))\n\t\t{\n\t\t    fillup = fillup + line;\n\t\t    line = getLine ();\n\t\t}\n\t\ttupleName.top () = KEY4FILLUP;\n\t\ttupleValue.top () = YCPString (fillup);\n\t\treturn tupleValue.top ();\n\t    }\n\n\t    // Skip\n\n\t    else if (s == \"Skip\")\n\t    {\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Match\n\n\t    else if (s == \"Match\")\n\t    {\n\t\treturn currentMatch;\n\t    }\n\n\t    // Separator\n\n\t    else if (s == \"Separator\" && term->size () == 1)\n\t    {\n\t\treturn parseSeparator (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t       optional);\n\t    }\n\n\t    // Whitespace\n\n\t    else if (s == \"Whitespace\")\n\t    {\n\t\treturn parseSeparator (line, \" \\t\", optional);\n\t    }\n\n\t    // String\n\n\t    else if (s == \"String\" && term->size () > 0)\n\t    {\n\t\tif (term->size () == 1)\n\t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t\t0, optional);\n\t\tif (term->size () == 2)\n\t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n\t\t\t\t\tterm->value (1)->asString ()->value ().c_str (),\n\t\t\t\t\toptional);\n\t    }\n\n\t    // Or\n\n\t    else if (s == \"Or\" && term->size () > 0)\n\t    {\n\t\tconst char *ltry = line;\n\t\tbool lopt = false;\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    if (i == term->size () - 1)\t// pass optional on last try\n\t\t\tlopt = optional;\n\t\t    YCPValue vtry = parseData (ltry, term->value (i), lopt);\n\t\t    if (!vtry.isNull ())\n\t\t    {\n\t\t\ty2debug (\"Or () success\");\n\t\t\tline = ltry;\n\t\t\treturn vtry;\n\t\t    }\n\t\t}\n\t\ty2debug (\"Or () failed\");\n\t\treturn YCPVoid ();\n\t    }\n\n\t    // Number\n\n\t    else if (s == \"Number\")\n\t    {\n\t\treturn parseNumber (line, optional);\n\t    }\n\n\t    // Hexval\n\n\t    else if (s == \"Hexval\")\n\t    {\n\t\treturn parseHexval (line, optional);\n\t    }\n\n\t    // Boolean\n\n\t    else if (s == \"Boolean\")\n\t    {\n\t\treturn parseBoolean (line, optional);\n\t    }\n\n\t    // Float\n\n\t    else if (s == \"Float\")\n\t    {\n\t\treturn parseFloat (line, optional);\n\t    }\n\n\t    // Ip4Number\n\n\t    else if (s == \"Ip4Number\")\n\t    {\n\t\treturn parseIp4Number (line, optional);\n\t    }\n\n\t    // Hostname\n\n\t    else if (s == \"Hostname\")\n\t    {\n\t\treturn parseHostname (line, optional);\n\t    }\n\n\t    // Username\n\n\t    else if (s == \"Username\")\n\t    {\n\t\treturn parseUsername (line, optional);\n\t    }\n\n\t    // <name>\n\n\t    else if (islower (s[0]) && tupleName.size () > 0 && (term->size () == 1))\n\t    {\n\t\ttupleName.top () = s;\n\t\ttupleValue.top () = parseData (line, term->value (0), optional);\n\t\treturn tupleValue.top ();\n\t    }\n\n\t    else\n\t    {\n\t\ty2error (\"parseData: unknown term '%s'\", s.c_str ());\n\t\treturn YCPVoid ();\n\t    }\n\t} break;\n\n\tcase YT_STRING:\n\t    y2debug (\"YT_STRING\");\n\t    return parseVerbose (line, syntax->asString ()->value ().c_str (),\n\t\t\t\t optional);\n\t    break;\n\n\tdefault:\n\t    y2error (\"parseData: unknown syntax %s\", syntax->toString ().c_str ());\n\t    break;\n    }\n\n    return YCPNull ();\n}",
          "includes": [
            "#include <ycp/y2log.h>",
            "#include \"AnyAgent.h\"",
            "#include <stack>",
            "#include <string>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define KEY4FILLUP \"`FILLUP\""
          ],
          "globals_used": [
            "static YCPValue currentMatch = YCPNull ();"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define KEY4FILLUP \"`FILLUP\"\n\nstatic YCPValue currentMatch = YCPNull ();\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseData (char const *&line, const YCPValue & syntax, bool optional)\n  {\n      if ((line == 0) || (*line == 0))\n  \tline = getLine ();\n      if (line == 0)\n  \treturn YCPNull ();\n      if (syntax.isNull ())\n  \treturn YCPNull ();\n  \n      y2debug (\"parseData %s('%s',[%s])\", (optional ? \"?\" : \"!\"), line,\n  \t     syntax->toString ().c_str ());\n  \n      switch (syntax->valuetype ())\n      {\n  \tcase YT_TERM: {\n  \n  \t    YCPTerm term = syntax->asTerm ();\n  \t    const string s = term->name ();\n  \t    y2debug (\"YT_TERM (%s)\", s.c_str ());\n  \n  \t    // Optional\n  \n  \t    if (s == \"Optional\" && term->size () > 0)\n  \t    {\n  \t\tYCPValue ov = parseData (line, term->value (0), true);\n  \t\tif (ov.isNull ())\n  \t\t    ov = YCPVoid ();\n  \t\treturn ov;\n  \t    }\n  \n  \t    // Continue\n  \n  \t    else if (s == \"Continue\" && term->size () > 0)\n  \t    {\n  \t\tYCPValue tv = parseData (line, term->value (0), false);\n  \t\tif (!tv.isNull ())\n  \t\t    tupleContinue = true;\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Choice\n  \n  \t    else if (s == \"Choice\" && term->size () > 0)\n  \t    {\n  \t\treturn parseChoice (line, term->args (), optional);\n  \t    }\n  \n  \t    // Sequence\n  \n  \t    else if (s == \"Sequence\" && term->size () > 0)\n  \t    {\n  \t\treturn parseSequence (line, term->args (), optional);\n  \t    }\n  \n  \t    // List\n  \n  \t    else if (s == \"List\" && term->size () == 2)\n  \t    {\n  \t\treturn parseList (line, term->args (), optional);\n  \t    }\n  \n  \t    // Tuple\n  \n  \t    else if (s == \"Tuple\" && term->size () > 0)\n  \t    {\n  \t\ttupleName.push (\"\");\n  \t\ttupleValue.push (YCPNull ());\n  \t\tYCPValue tv = parseTuple (line, term->args (), optional);\n  \t\ttupleName.pop ();\n  \t\ttupleValue.pop ();\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Var\n  \n  \t    else if (s == \"Var\" && term->size () > 0)\n  \t    {\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    if (parseData (line, term->value (i), optional).isNull ())\n  \t\t\tbreak;\n  \t\t}\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Name\n  \n  \t    else if (s == \"Name\" && term->size () == 1)\n  \t    {\n  \t\tif (!mReadOnly)\n  \t\t{\n  \t\t    y2error (\"'Name' not allowed for writable agents\");\n  \t\t    return YCPNull ();\n  \t\t}\n  \t\tYCPValue tn = parseData (line, term->value (0), false);\n  \t\tif (!tn.isNull () && tupleName.size () > 0)\n  \t\t{\n  \t\t    if (tn->isString ())\n  \t\t\ttupleName.top () = tn->asString ()->value ();\n  \t\t    else\n  \t\t\ttupleName.top () = tn->toString ();\n  \t\t    y2debug (\"Name: %s\", tn->toString ().c_str ());\n  \t\t}\n  \t\treturn tn;\n  \t    }\n  \n  \t    // Value\n  \n  \t    else if (s == \"Value\" && term->size () == 1)\n  \t    {\n  \t\tYCPValue tv = parseData (line, term->value (0), false);\n  \t\tif (!tv.isNull () && tupleValue.size () > 0)\n  \t\t    tupleValue.top () = tv;\n  \t\t// y2debug (\"Value: %p\", tv);\n  \t\treturn tv;\n  \t    }\n  \n  \t    // Fillup\n  \n  \t    else if (isFillup && (s == \"Fillup\") &&\t// fillup allowed and Fillup () found\n  \t\t     (term->size () == 0) && (tupleName.size () > 0))\n  \t    {\t\t// inside Tuple ()\n  \t\tstring fillup;\n  \t\twhile ((line != 0)\n  \t\t       && (mComment.find_first_of (line[0]) != string::npos))\n  \t\t{\n  \t\t    fillup = fillup + line;\n  \t\t    line = getLine ();\n  \t\t}\n  \t\ttupleName.top () = KEY4FILLUP;\n  \t\ttupleValue.top () = YCPString (fillup);\n  \t\treturn tupleValue.top ();\n  \t    }\n  \n  \t    // Skip\n  \n  \t    else if (s == \"Skip\")\n  \t    {\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Match\n  \n  \t    else if (s == \"Match\")\n  \t    {\n  \t\treturn currentMatch;\n  \t    }\n  \n  \t    // Separator\n  \n  \t    else if (s == \"Separator\" && term->size () == 1)\n  \t    {\n  \t\treturn parseSeparator (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t       optional);\n  \t    }\n  \n  \t    // Whitespace\n  \n  \t    else if (s == \"Whitespace\")\n  \t    {\n  \t\treturn parseSeparator (line, \" \\t\", optional);\n  \t    }\n  \n  \t    // String\n  \n  \t    else if (s == \"String\" && term->size () > 0)\n  \t    {\n  \t\tif (term->size () == 1)\n  \t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t\t0, optional);\n  \t\tif (term->size () == 2)\n  \t\t    return parseString (line, term->value (0)->asString ()->value ().c_str (),\n  \t\t\t\t\tterm->value (1)->asString ()->value ().c_str (),\n  \t\t\t\t\toptional);\n  \t    }\n  \n  \t    // Or\n  \n  \t    else if (s == \"Or\" && term->size () > 0)\n  \t    {\n  \t\tconst char *ltry = line;\n  \t\tbool lopt = false;\n  \t\tfor (int i = 0; i < term->size (); i++)\n  \t\t{\n  \t\t    if (i == term->size () - 1)\t// pass optional on last try\n  \t\t\tlopt = optional;\n  \t\t    YCPValue vtry = parseData (ltry, term->value (i), lopt);\n  \t\t    if (!vtry.isNull ())\n  \t\t    {\n  \t\t\ty2debug (\"Or () success\");\n  \t\t\tline = ltry;\n  \t\t\treturn vtry;\n  \t\t    }\n  \t\t}\n  \t\ty2debug (\"Or () failed\");\n  \t\treturn YCPVoid ();\n  \t    }\n  \n  \t    // Number\n  \n  \t    else if (s == \"Number\")\n  \t    {\n  \t\treturn parseNumber (line, optional);\n  \t    }\n  \n  \t    // Hexval\n  \n  \t    else if (s == \"Hexval\")\n  \t    {\n  \t\treturn parseHexval (line, optional);\n  \t    }\n  \n  \t    // Boolean\n  \n  \t    else if (s == \"Boolean\")\n  \t    {\n  \t\treturn parseBoolean (line, optional);\n  \t    }\n  \n  \t    // Float\n  \n  \t    else if (s == \"Float\")\n  \t    {\n  \t\treturn parseFloat (line, optional);\n  \t    }\n  \n  \t    // Ip4Number\n  \n  \t    else if (s == \"Ip4Number\")\n  \t    {\n  \t\treturn parseIp4Number (line, optional);\n  \t    }\n  \n  \t    // Hostname\n  \n  \t    else if (s == \"Hostname\")\n  \t    {\n  \t\treturn parseHostname (line, optional);\n  \t    }\n  \n  \t    // Username\n  \n  \t    else if (s == \"Username\")\n  \t    {\n  \t\treturn parseUsername (line, optional);\n  \t    }\n  \n  \t    // <name>\n  \n  \t    else if (islower (s[0]) && tupleName.size () > 0 && (term->size () == 1))\n  \t    {\n  \t\ttupleName.top () = s;\n  \t\ttupleValue.top () = parseData (line, term->value (0), optional);\n  \t\treturn tupleValue.top ();\n  \t    }\n  \n  \t    else\n  \t    {\n  \t\ty2error (\"parseData: unknown term '%s'\", s.c_str ());\n  \t\treturn YCPVoid ();\n  \t    }\n  \t} break;\n  \n  \tcase YT_STRING:\n  \t    y2debug (\"YT_STRING\");\n  \t    return parseVerbose (line, syntax->asString ()->value ().c_str (),\n  \t\t\t\t optional);\n  \t    break;\n  \n  \tdefault:\n  \t    y2error (\"parseData: unknown syntax %s\", syntax->toString ().c_str ());\n  \t    break;\n      }\n  \n      return YCPNull ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "action.isNull",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"choice (%d) match\"",
            "i"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "currentMatch.isNull",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"choice (%d)\"",
            "i"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "element->value",
          "args": [
            "1"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "element->size",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Choice element list must have 1 or 2 entries\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->asList",
          "args": [],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Choice element must be list\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->isList",
          "args": [],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad element in Choice()\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"parseChoice ('%s',[%s])\"",
            "line",
            "syntax->toString ().c_str ()"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syntax->toString",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syntax.isNull",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic YCPValue currentMatch = YCPNull ();\n\nAnyAgent {\n  YCPValue\n  AnyAgent::parseChoice (char const *&line, const YCPList & syntax, bool optional)\n  {\n      if ((line == 0) || syntax.isNull ())\n  \treturn YCPNull ();\n  \n      y2debug (\"parseChoice ('%s',[%s])\", line, syntax->toString ().c_str ());\n  \n      for (int i = 0; i < syntax->size (); i++)\n      {\n  \tYCPValue v = syntax->value (i);\n  \tif (v.isNull ())\n  \t{\n  \t    y2error (\"Bad element in Choice()\");\n  \t    return YCPNull ();\n  \t}\n  \tif (!v->isList ())\n  \t{\n  \t    y2error (\"Choice element must be list\");\n  \t    return YCPNull ();\n  \t}\n  \n  \tYCPList element = v->asList ();\n  \tif ((element->size () <= 0) || (element->size () > 2))\n  \t{\n  \t    y2error (\"Choice element list must have 1 or 2 entries\");\n  \t    return YCPNull ();\n  \t}\n  \n  \tYCPValue match = element->value (0);\n  \n  \t// get optional action\n  \n  \tYCPValue action = (element->size () > 1) ? element->value (1) : YCPNull ();\n  \n  \t// force match\n  \ty2debug (\"choice (%d)\", i);\n  \n  \tchar const *try_line = line;\n  \n  \tcurrentMatch = parseData (try_line, match, false);\n  \n  \t// have match\n  \tif (!currentMatch.isNull ())\n  \t{\n  \t    line = try_line;\n  \t    y2debug (\"choice (%d) match\", i);\n  \t    if (!action.isNull ())\n  \t\treturn parseData (line, action, optional);\n  \t    else\n  \t\treturn currentMatch;\n  \t}\n      }\n  \n      return YCPNull ();\n  }\n}"
  },
  {
    "function_name": "putLine",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
    "lines": "95-99",
    "snippet": "const string\nAnyAgent::putLine (const string s)\n{\n    return \"\";\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  const string\n  AnyAgent::putLine (const string s)\n  {\n      return \"\";\n  }\n}"
  },
  {
    "function_name": "lineNumber",
    "container": "AnyAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-any/src/AnyAgentComplex.cc",
    "lines": "38-42",
    "snippet": "int\nAnyAgent::lineNumber () const\n{\n    return line_number;\n}",
    "includes": [
      "#include <ycp/y2log.h>",
      "#include \"AnyAgent.h\"",
      "#include <stack>",
      "#include <string>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ycp/y2log.h>\n#include \"AnyAgent.h\"\n#include <stack>\n#include <string>\n#include <unistd.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nAnyAgent {\n  int\n  AnyAgent::lineNumber () const\n  {\n      return line_number;\n  }\n}"
  }
]