[
  {
    "function_name": "YCPBuiltinTerm",
    "container": "YCPBuiltinTerm",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinTerm.cc",
    "lines": "286-306",
    "snippet": "YCPBuiltinTerm::YCPBuiltinTerm ()\n{\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n#define ETC 0, NULL, constTypePtr(), NULL\n#define ETCf   NULL, constTypePtr(), NULL\n\t{ \"add\",\t\"term (term, const any)\",\t\t(void *)t_add,      ETC },\n\t{ \"size\",\t\"integer (term)\",\t\t\t(void *)t_size,\t    ETC },\n\t{ \"symbolof\",\t\"symbol (term)\",\t\t\t(void *)t_symbolof, ETC },\n\t{ \"select\",\t\"flex (term, integer, const flex)\",\t(void *)t_select, DECL_NIL|DECL_FLEX, ETCf },\n\t{ \"toterm\",\t\"term (any)\",\t\t\t\t(void *)t_toterm1,  ETC },\n\t{ \"toterm\",\t\"term (symbol, const list <any>)\",\t(void *)t_toterm2,  ETC },\n\t{ \"remove\",\t\"term (term, integer)\",\t\t\t(void *)t_remove,   ETC },\n\t{ \"argsof\",\t\"list <any> (term)\",\t\t\t(void *)t_argsof,   ETC },\n\t{ NULL, NULL, NULL, ETC }\n#undef ETC\n#undef ETCf\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinTerm\", declarations);\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPBuiltinTerm.h\""
    ],
    "macros_used": [
      "#define ETCf   NULL, constTypePtr(), NULL",
      "#define ETC 0, NULL, constTypePtr(), NULL"
    ],
    "globals_used": [
      "extern StaticDeclaration static_declarations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_declarations.registerDeclarations",
          "args": [
            "\"YCPBuiltinTerm\"",
            "declarations"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "registerDeclarations",
          "container": "StaticDeclaration",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/StaticDeclaration.cc",
          "lines": "87-237",
          "snippet": "void\nStaticDeclaration::registerDeclarations (const char *filename,\n\t\t\t\t\t declaration_t *declarations)\n{\n    if (declarations == 0)\n    {\n\treturn;\n    }\n\n    SymbolTable *table = m_declTable;\n    const Y2Namespace *name_space = 0;\n    static const Point *builtin_point = new Point (\"<builtin>\");\n    const Point *namespace_point = builtin_point;\t\t// declarations default to builtin\n    declaration_t *namespace_decl = 0;\n\n    std::pair <std::string, Y2Namespace *> *track_info = 0;\n\n    while (declarations->name != 0)\n    {\n#if DO_DEBUG\n\ty2debug( \"Registering %s\", declarations->name );\n#endif\n\tconst char *name = declarations->name;\n\n\tif (*name == 0)\t\t// exit on empty name\n\t    break;\n\n\tif ((declarations->flags & (DECL_WILD|DECL_SYMBOL)) == (DECL_WILD|DECL_SYMBOL))\n\t{\n\t    y2internal (\"Declaration of %s::%s combines wildcard and symbol\\n\", filename, name);\n\t}\n\telse if ((declarations->flags & DECL_NAMESPACE) != 0)\t\t// switch namespace\n\t{\n\t    // new namespace, clear possibly old track_info\n\t    if (track_info != 0)\n\t    {\n\t\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n\t\tm_active_predefined.push_back (*track_info);\n\t\ttrack_info = 0;\n\t    }\n#if DO_DEBUG\n\t    y2debug (\"NAMESPACE (%s)\", name);\n#endif\n            declarations->name_space = namespace_decl;\n\n\t    TableEntry *tentry = table->find (name);\n\t    if (tentry != 0\t\t\t\t\t\t// name already exists\n\t\t&& tentry->sentry()->isNamespace())\t\t\t//   as namespace\n\t    {\n\t\tname_space = tentry->sentry()->nameSpace();\n\t    }\n\t    else if (*name == 0)\t\t\t\t\t// reset namespace\n\t    {\n\t\ttable = m_declTable;\n\t\tname_space = 0;\n\t\tnamespace_point = builtin_point;\n\t    }\n\t    else\t\t\t\t\t\t\t// open up new namespace\n\t    {\n\t\tbool is_predefined = false;\n\n\t\tif (tentry != 0\n\t\t    && tentry->sentry()->isPredefined())\t\t//   replace predefined\n\t\t{\n\t\t    table->remove (tentry);\n\t\t    is_predefined = true;\n\t\t}\n\n\t\t// create definition container for namespace\n\t\tYBlock *block = new YBlock (filename, YBlock::b_namespace);\n\t\tblock->setName (string (name));\n\n\t\tY2Namespace *namespaceNamespace = (Y2Namespace *)block;\n\t\tnamespaceNamespace->createTable();\n\t\tSymbolTable *namespaceTable = block->table();\n\n\t\t// create SymbolEntry::c_namespace for the namespace to be entered into the global table\n\t\tSymbolEntryPtr sentry = new YSymbolEntry (name, Type::Unspec, namespaceTable);\n\n#if DO_DEBUG\n\t\ty2debug (\"Entered Namespace '%s' (block %p) into namespaceTable %p\", name, block, namespaceTable);\n#endif\n\n\t\t// enter into global table\n\t\tnamespace_point = new Point (filename);\n\t\ttable->enter (name, sentry, namespace_point);\n\n\t\t// all further definitions go into this namespace\n\t\t//   -> make it the new global table\n\t\ttable = namespaceTable;\n\t\tnamespace_decl = declarations;\n\n\t\tif (is_predefined)\n\t\t{\n\t\t    // save tracking info, trigger 'Import' _after_ all symbols have been added\n\t\t    track_info = new std::pair<std::string, Y2Namespace *> (name, namespaceNamespace);\n\t\t}\n\t    }\n\t}\n\telse\t// normal entry, not namespace\n\t{\n\t    declarations->name_space = namespace_decl;\n\t    string signature = declarations->signature;\n\n\t    constTypePtr type = Type::fromSignature (signature);\n\t    if (type == 0\n\t\t|| type->isError()\n\t\t|| type->isUnspec()\n\t\t|| type->isWildcard())\n\t    {\n\t\ty2error (\"Invalid signature %s::%s:'%s'\\n\", filename, name, signature.c_str());\n\t\treturn;\n\t    }\n\n#if DO_DEBUG\ny2debug(\"%s sig[%s] type[%s]\", name, signature.c_str(), type->toString().c_str());\n#endif\n#if 0\n\t    if (type->hasFlex()\n\t\t&& (declarations->flags & DECL_FLEX) == 0)\n\t    {\n\t\ty2error (\"%s:'%s' without DECL_FLEX\", name, declarations->signature);\n\t\treturn;\n\t    }\n#endif\n\t    declarations->type = type;\n\n\t    SymbolEntryPtr sentry = new YSymbolEntry (name, type, declarations, name_space);\n\t    declarations->tentry = table->enter (name, sentry, new Point (sentry, 0, namespace_point));\n\n#ifdef BUILTIN_STATISTICS\n\t    FILE *fout = fopen (\"/tmp/builtin-register.txt\", \"a\");\n\t    if (fout) {\n\t\tfprintf (fout, \"%s %s\\n\", declarations->name, declarations->signature);\n\t\tfclose (fout);\n\t    }\n#endif\n\t}\n\tdeclarations++;\n    }\n\n    // clear possibly old track_info\n    if (track_info != 0)\n    {\n\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n\tm_active_predefined.push_back (*track_info);\n\ttrack_info = 0;\n    }\n\n    return;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Import.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include <map>",
            "#include <string>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "static const char *predefined[] = {\n  \"UI\", \"WFM\", \"SCR\", \"Pkg\", 0\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <unistd.h>\n\n#define DO_DEBUG 0\n\nstatic const char *predefined[] = {\n  \"UI\", \"WFM\", \"SCR\", \"Pkg\", 0\n};\n\nStaticDeclaration {\n  void\n  StaticDeclaration::registerDeclarations (const char *filename,\n  \t\t\t\t\t declaration_t *declarations)\n  {\n      if (declarations == 0)\n      {\n  \treturn;\n      }\n  \n      SymbolTable *table = m_declTable;\n      const Y2Namespace *name_space = 0;\n      static const Point *builtin_point = new Point (\"<builtin>\");\n      const Point *namespace_point = builtin_point;\t\t// declarations default to builtin\n      declaration_t *namespace_decl = 0;\n  \n      std::pair <std::string, Y2Namespace *> *track_info = 0;\n  \n      while (declarations->name != 0)\n      {\n  #if DO_DEBUG\n  \ty2debug( \"Registering %s\", declarations->name );\n  #endif\n  \tconst char *name = declarations->name;\n  \n  \tif (*name == 0)\t\t// exit on empty name\n  \t    break;\n  \n  \tif ((declarations->flags & (DECL_WILD|DECL_SYMBOL)) == (DECL_WILD|DECL_SYMBOL))\n  \t{\n  \t    y2internal (\"Declaration of %s::%s combines wildcard and symbol\\n\", filename, name);\n  \t}\n  \telse if ((declarations->flags & DECL_NAMESPACE) != 0)\t\t// switch namespace\n  \t{\n  \t    // new namespace, clear possibly old track_info\n  \t    if (track_info != 0)\n  \t    {\n  \t\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n  \t\tm_active_predefined.push_back (*track_info);\n  \t\ttrack_info = 0;\n  \t    }\n  #if DO_DEBUG\n  \t    y2debug (\"NAMESPACE (%s)\", name);\n  #endif\n              declarations->name_space = namespace_decl;\n  \n  \t    TableEntry *tentry = table->find (name);\n  \t    if (tentry != 0\t\t\t\t\t\t// name already exists\n  \t\t&& tentry->sentry()->isNamespace())\t\t\t//   as namespace\n  \t    {\n  \t\tname_space = tentry->sentry()->nameSpace();\n  \t    }\n  \t    else if (*name == 0)\t\t\t\t\t// reset namespace\n  \t    {\n  \t\ttable = m_declTable;\n  \t\tname_space = 0;\n  \t\tnamespace_point = builtin_point;\n  \t    }\n  \t    else\t\t\t\t\t\t\t// open up new namespace\n  \t    {\n  \t\tbool is_predefined = false;\n  \n  \t\tif (tentry != 0\n  \t\t    && tentry->sentry()->isPredefined())\t\t//   replace predefined\n  \t\t{\n  \t\t    table->remove (tentry);\n  \t\t    is_predefined = true;\n  \t\t}\n  \n  \t\t// create definition container for namespace\n  \t\tYBlock *block = new YBlock (filename, YBlock::b_namespace);\n  \t\tblock->setName (string (name));\n  \n  \t\tY2Namespace *namespaceNamespace = (Y2Namespace *)block;\n  \t\tnamespaceNamespace->createTable();\n  \t\tSymbolTable *namespaceTable = block->table();\n  \n  \t\t// create SymbolEntry::c_namespace for the namespace to be entered into the global table\n  \t\tSymbolEntryPtr sentry = new YSymbolEntry (name, Type::Unspec, namespaceTable);\n  \n  #if DO_DEBUG\n  \t\ty2debug (\"Entered Namespace '%s' (block %p) into namespaceTable %p\", name, block, namespaceTable);\n  #endif\n  \n  \t\t// enter into global table\n  \t\tnamespace_point = new Point (filename);\n  \t\ttable->enter (name, sentry, namespace_point);\n  \n  \t\t// all further definitions go into this namespace\n  \t\t//   -> make it the new global table\n  \t\ttable = namespaceTable;\n  \t\tnamespace_decl = declarations;\n  \n  \t\tif (is_predefined)\n  \t\t{\n  \t\t    // save tracking info, trigger 'Import' _after_ all symbols have been added\n  \t\t    track_info = new std::pair<std::string, Y2Namespace *> (name, namespaceNamespace);\n  \t\t}\n  \t    }\n  \t}\n  \telse\t// normal entry, not namespace\n  \t{\n  \t    declarations->name_space = namespace_decl;\n  \t    string signature = declarations->signature;\n  \n  \t    constTypePtr type = Type::fromSignature (signature);\n  \t    if (type == 0\n  \t\t|| type->isError()\n  \t\t|| type->isUnspec()\n  \t\t|| type->isWildcard())\n  \t    {\n  \t\ty2error (\"Invalid signature %s::%s:'%s'\\n\", filename, name, signature.c_str());\n  \t\treturn;\n  \t    }\n  \n  #if DO_DEBUG\n  y2debug(\"%s sig[%s] type[%s]\", name, signature.c_str(), type->toString().c_str());\n  #endif\n  #if 0\n  \t    if (type->hasFlex()\n  \t\t&& (declarations->flags & DECL_FLEX) == 0)\n  \t    {\n  \t\ty2error (\"%s:'%s' without DECL_FLEX\", name, declarations->signature);\n  \t\treturn;\n  \t    }\n  #endif\n  \t    declarations->type = type;\n  \n  \t    SymbolEntryPtr sentry = new YSymbolEntry (name, type, declarations, name_space);\n  \t    declarations->tentry = table->enter (name, sentry, new Point (sentry, 0, namespace_point));\n  \n  #ifdef BUILTIN_STATISTICS\n  \t    FILE *fout = fopen (\"/tmp/builtin-register.txt\", \"a\");\n  \t    if (fout) {\n  \t\tfprintf (fout, \"%s %s\\n\", declarations->name, declarations->signature);\n  \t\tfclose (fout);\n  \t    }\n  #endif\n  \t}\n  \tdeclarations++;\n      }\n  \n      // clear possibly old track_info\n      if (track_info != 0)\n      {\n  \tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n  \tm_active_predefined.push_back (*track_info);\n  \ttrack_info = 0;\n      }\n  \n      return;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPBuiltinTerm.h\"\n\n#define ETCf   NULL, constTypePtr(), NULL\n#define ETC 0, NULL, constTypePtr(), NULL\n\nextern StaticDeclaration static_declarations;\n\nYCPBuiltinTerm {\n  YCPBuiltinTerm::YCPBuiltinTerm ()\n  {\n      // must be static, registerDeclarations saves a pointer to it!\n      static declaration_t declarations[] = {\n  #define ETC 0, NULL, constTypePtr(), NULL\n  #define ETCf   NULL, constTypePtr(), NULL\n  \t{ \"add\",\t\"term (term, const any)\",\t\t(void *)t_add,      ETC },\n  \t{ \"size\",\t\"integer (term)\",\t\t\t(void *)t_size,\t    ETC },\n  \t{ \"symbolof\",\t\"symbol (term)\",\t\t\t(void *)t_symbolof, ETC },\n  \t{ \"select\",\t\"flex (term, integer, const flex)\",\t(void *)t_select, DECL_NIL|DECL_FLEX, ETCf },\n  \t{ \"toterm\",\t\"term (any)\",\t\t\t\t(void *)t_toterm1,  ETC },\n  \t{ \"toterm\",\t\"term (symbol, const list <any>)\",\t(void *)t_toterm2,  ETC },\n  \t{ \"remove\",\t\"term (term, integer)\",\t\t\t(void *)t_remove,   ETC },\n  \t{ \"argsof\",\t\"list <any> (term)\",\t\t\t(void *)t_argsof,   ETC },\n  \t{ NULL, NULL, NULL, ETC }\n  #undef ETC\n  #undef ETCf\n      };\n  \n      static_declarations.registerDeclarations (\"YCPBuiltinTerm\", declarations);\n  }\n}"
  },
  {
    "function_name": "t_argsof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinTerm.cc",
    "lines": "265-283",
    "snippet": "static YCPValue\nt_argsof (const YCPTerm &term)\n{\n    /**\n     * @builtin argsof\n     * @short Returns the arguments of a term.\n     *\n     * @param term TERM\n     * @return list\n     *\n     * @usage argsof (`fun(1, 2)) -> [1, 2]\n     * @usage argsof(`TextEntry(`id(\"text\"), \"Label\", \"value\")) -> [`id (\"text\"), \"Label\", \"value\"]\n     */\n\n    if (term.isNull ())\n\treturn YCPNull ();\n\n    return term->args();\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPBuiltinTerm.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "term->args",
          "args": [],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "args",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "58-62",
          "snippet": "YCPList\nYCPTermRep::args() const\n{\n    return l;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPList\n  YCPTermRep::args() const\n  {\n      return l;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term.isNull",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPBuiltinTerm.h\"\n\nstatic YCPValue\nt_argsof (const YCPTerm &term)\n{\n    /**\n     * @builtin argsof\n     * @short Returns the arguments of a term.\n     *\n     * @param term TERM\n     * @return list\n     *\n     * @usage argsof (`fun(1, 2)) -> [1, 2]\n     * @usage argsof(`TextEntry(`id(\"text\"), \"Label\", \"value\")) -> [`id (\"text\"), \"Label\", \"value\"]\n     */\n\n    if (term.isNull ())\n\treturn YCPNull ();\n\n    return term->args();\n}"
  },
  {
    "function_name": "t_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinTerm.cc",
    "lines": "221-262",
    "snippet": "static YCPValue\nt_remove (const YCPTerm &term, const YCPInteger &i)\n{\n    /**\n     * @builtin remove\n     * @id remove-term\n     * @short Remove item from term\n     *\n     * @description\n     * Remove the i'th value from a term. The first value has the index 1 (!).\n     * (The index counting is for compatibility reasons with the 'old'\n     * remove which allowed 'remove(`term(1,2,3), 0) = [1,2,3]'\n     * Use 'argsof (term) -> list' for this kind of transformation.)\n     *\n     * The yast2-core version < 2.17.16 returns nil if the index is invalid. This behavior\n     * has changed in version 2.17.16 to return unchanged term.\n     *\n     * @param term TERM\n     * @param integer i\n     * @return term\n     *\n     * @see add\n     * @usage remove (`fun(1, 2), 1) -> `fun(2)\n     * @usage remove (`VBox(`Label(\"a\"), `Label(\"b\")), 2) -> `VBox (`Label (\"a\"))\n     */\n\n    if (term.isNull () || i.isNull ())\n\treturn YCPNull ();\n\n    long idx = i->value ();\n    YCPList args = term->args();\n\n    if (idx <= 0 || idx > args->size ())\n    {\n\tycp2error (\"Index %s for remove () out of range\", toString (idx).c_str ());\n\treturn term;\n    }\n\n    args->remove (idx-1);\n\n    return YCPTerm (term->name(), args);\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPBuiltinTerm.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPTerm",
          "args": [
            "term->name()",
            "args"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "133-137",
          "snippet": "void\nYCPTermRep::set (const int n, const YCPValue& value)\n{\n    return l->set (n, value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::set (const int n, const YCPValue& value)\n  {\n      return l->set (n, value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->name",
          "args": [],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Import",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Import.cc",
          "lines": "189-193",
          "snippet": "string\nImport::name () const\n{\n    return m_name;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Import.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Import.h\"\n#include <libintl.h>\n\nImport {\n  string\n  Import::name () const\n  {\n      return m_name;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "args->remove",
          "args": [
            "idx-1"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "remove",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "104-113",
          "snippet": "void YCPMapRep::remove(const YCPValue& key)\n{\n    if (!key->isString() && !key->isInteger() && !key->isSymbol())\n    {\n        ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n        return;\n    }\n\n    stl_map.erase (key);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void YCPMapRep::remove(const YCPValue& key)\n  {\n      if (!key->isString() && !key->isInteger() && !key->isSymbol())\n      {\n          ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n          return;\n      }\n  \n      stl_map.erase (key);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Index %s for remove () out of range\"",
            "toString (idx).c_str ()"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [
            "idx"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "158-232",
          "snippet": "string \nYSymbolEntry::toString (bool with_type) const\n{\n    string s = (with_type && m_global) ? \"global \" : \"\";\n#if DO_DEBUG\n    y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n    y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n#endif\n    switch (m_category)\n    {\n\tcase c_variable:\n\tcase c_reference:\n\tcase c_function:\n#if DO_DEBUG\n\t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n#endif\n\tcase c_builtin:\n\t{\n\t    if (with_type)\n\t    {\n\t\tconstFunctionTypePtr ftype = m_type;\n\t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n\t\tif (m_global\n\t\t    && m_namespace != 0\n\t\t    && !m_namespace->name().empty())\n\t\t{\n\t\t    s += (m_namespace->name() + \"::\");\n\t\t}\n\t\ts += m_name.asString();\n\t\tif ((m_category == c_builtin)\n\t\t    && (m_payload.m_decl != 0))\n\t\t{\n\t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n\t\t}\n\t\telse if ((m_category == c_function)\n\t\t\t && (m_code != 0))\n\t\t{\n\t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n\t\t}\n\t\treturn s;\n\t    }\n\t    else\n\t    {\n\t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n\t\treturn s;\n\t    }\n\t}\n\tbreak;\n\tcase c_typedef:\n\t{\n\t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n\t}\n\tbreak;\n\tcase c_const:\n\t{\n\t    return s + m_type->toString() + \" \" + m_name.asString();\n\t}\n\tbreak;\n\tcase c_namespace:\n\tcase c_self:\n\tcase c_filename:\n\tcase c_predefined:\n\t{\n\t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    return SymbolEntry::toString (with_type);\n\t}\n\tbreak;\n    }\n\n    return \"?SymbolEntry?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\n#define DO_DEBUG 0\n\nYSymbolEntry {\n  string \n  YSymbolEntry::toString (bool with_type) const\n  {\n      string s = (with_type && m_global) ? \"global \" : \"\";\n  #if DO_DEBUG\n      y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n      y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n  #endif\n      switch (m_category)\n      {\n  \tcase c_variable:\n  \tcase c_reference:\n  \tcase c_function:\n  #if DO_DEBUG\n  \t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n  #endif\n  \tcase c_builtin:\n  \t{\n  \t    if (with_type)\n  \t    {\n  \t\tconstFunctionTypePtr ftype = m_type;\n  \t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n  \t\tif (m_global\n  \t\t    && m_namespace != 0\n  \t\t    && !m_namespace->name().empty())\n  \t\t{\n  \t\t    s += (m_namespace->name() + \"::\");\n  \t\t}\n  \t\ts += m_name.asString();\n  \t\tif ((m_category == c_builtin)\n  \t\t    && (m_payload.m_decl != 0))\n  \t\t{\n  \t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n  \t\t}\n  \t\telse if ((m_category == c_function)\n  \t\t\t && (m_code != 0))\n  \t\t{\n  \t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n  \t\t}\n  \t\treturn s;\n  \t    }\n  \t    else\n  \t    {\n  \t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n  \t\treturn s;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase c_typedef:\n  \t{\n  \t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n  \t}\n  \tbreak;\n  \tcase c_const:\n  \t{\n  \t    return s + m_type->toString() + \" \" + m_name.asString();\n  \t}\n  \tbreak;\n  \tcase c_namespace:\n  \tcase c_self:\n  \tcase c_filename:\n  \tcase c_predefined:\n  \t{\n  \t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    return SymbolEntry::toString (with_type);\n  \t}\n  \tbreak;\n      }\n  \n      return \"?SymbolEntry?\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "args->size",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->args",
          "args": [],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "args",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "58-62",
          "snippet": "YCPList\nYCPTermRep::args() const\n{\n    return l;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPList\n  YCPTermRep::args() const\n  {\n      return l;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "i->value",
          "args": [],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.isNull",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term.isNull",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPBuiltinTerm.h\"\n\nstatic YCPValue\nt_remove (const YCPTerm &term, const YCPInteger &i)\n{\n    /**\n     * @builtin remove\n     * @id remove-term\n     * @short Remove item from term\n     *\n     * @description\n     * Remove the i'th value from a term. The first value has the index 1 (!).\n     * (The index counting is for compatibility reasons with the 'old'\n     * remove which allowed 'remove(`term(1,2,3), 0) = [1,2,3]'\n     * Use 'argsof (term) -> list' for this kind of transformation.)\n     *\n     * The yast2-core version < 2.17.16 returns nil if the index is invalid. This behavior\n     * has changed in version 2.17.16 to return unchanged term.\n     *\n     * @param term TERM\n     * @param integer i\n     * @return term\n     *\n     * @see add\n     * @usage remove (`fun(1, 2), 1) -> `fun(2)\n     * @usage remove (`VBox(`Label(\"a\"), `Label(\"b\")), 2) -> `VBox (`Label (\"a\"))\n     */\n\n    if (term.isNull () || i.isNull ())\n\treturn YCPNull ();\n\n    long idx = i->value ();\n    YCPList args = term->args();\n\n    if (idx <= 0 || idx > args->size ())\n    {\n\tycp2error (\"Index %s for remove () out of range\", toString (idx).c_str ());\n\treturn term;\n    }\n\n    args->remove (idx-1);\n\n    return YCPTerm (term->name(), args);\n}"
  },
  {
    "function_name": "t_toterm2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinTerm.cc",
    "lines": "186-218",
    "snippet": "static YCPValue\nt_toterm2 (const YCPSymbol &s, const YCPList &l)\n{\n   /**\n     * @builtin toterm\n     * @id toterm-list\n     * @short Constructs a term from a symbol and a list.\n     *\n     * @description\n     * Constructs a term from a symbol and a list. Thus complement to symbolof\n     * and argsof.\n     *\n     * @param symbol s\n     * @param list l\n     * @return term\n     *\n     * @usage toterm (`RadioButton, [ `id (`test), \"Test\" ]) -> `RadioButton (`id (`test), \"Test\")\n     */\n\n    if (s.isNull () || l.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPTerm ret = YCPTerm (s->symbol());\n\n    for (int i = 0; i < l->size (); i++)\n    {\n\tret->add(l->value (i));\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPBuiltinTerm.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret->add",
          "args": [
            "l->value (i)"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "l->value",
          "args": [
            "i"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "l->size",
          "args": [],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPByteblockRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPByteblock.cc",
          "lines": "59-63",
          "snippet": "long\nYCPByteblockRep::size() const\n{\n    return len;\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPByteblock.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPByteblock.h\"\n#include <ycp/y2log.h>\n\nYCPByteblockRep {\n  long\n  YCPByteblockRep::size() const\n  {\n      return len;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPTerm",
          "args": [
            "s->symbol()"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "YCPTerm",
          "container": "YCPTerm",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "178-194",
          "snippet": "YCPTerm::YCPTerm (bytecodeistream & str)\n    : YCPValue (YCPTerm(\"no-name-so-far\"))\n{\n    string s;\n    if (Bytecode::readString (str, s))\n    {\n\tYCPList list (str);\n\tif (!list.isNull())\n\t{\n\t    (const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->setName(s);\n\t    for (int i = 0 ; i < list->size () ; i++)\n\t    {\n\t\t(const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->add (list->value (i));\n\t    }\n\t}\n    }\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTerm {\n  YCPTerm::YCPTerm (bytecodeistream & str)\n      : YCPValue (YCPTerm(\"no-name-so-far\"))\n  {\n      string s;\n      if (Bytecode::readString (str, s))\n      {\n  \tYCPList list (str);\n  \tif (!list.isNull())\n  \t{\n  \t    (const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->setName(s);\n  \t    for (int i = 0 ; i < list->size () ; i++)\n  \t    {\n  \t\t(const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->add (list->value (i));\n  \t    }\n  \t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s->symbol",
          "args": [],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "symbol",
          "container": "YCPSymbolRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "40-44",
          "snippet": "string\nYCPSymbolRep::symbol() const\n{\n    return v.asString();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbolRep {\n  string\n  YCPSymbolRep::symbol() const\n  {\n      return v.asString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l.isNull",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.isNull",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPBuiltinTerm.h\"\n\nstatic YCPValue\nt_toterm2 (const YCPSymbol &s, const YCPList &l)\n{\n   /**\n     * @builtin toterm\n     * @id toterm-list\n     * @short Constructs a term from a symbol and a list.\n     *\n     * @description\n     * Constructs a term from a symbol and a list. Thus complement to symbolof\n     * and argsof.\n     *\n     * @param symbol s\n     * @param list l\n     * @return term\n     *\n     * @usage toterm (`RadioButton, [ `id (`test), \"Test\" ]) -> `RadioButton (`id (`test), \"Test\")\n     */\n\n    if (s.isNull () || l.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPTerm ret = YCPTerm (s->symbol());\n\n    for (int i = 0; i < l->size (); i++)\n    {\n\tret->add(l->value (i));\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "t_toterm1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinTerm.cc",
    "lines": "148-183",
    "snippet": "static YCPValue\nt_toterm1 (const YCPValue &v)\n{\n    /**\n     * @builtin toterm\n     * @id toterm-any\n     * @short Converts a value to a term.\n     *\n     * @description\n     * If the value can't be converted to a term, nilterm is returned.\n     *\n     * @param any VALUE\n     * @return term\n     *\n     * @usage toterm (\"VBox\") -> `VBox ()\n     * @usage toterm (`VBox) -> `VBox ()\n     */\n\n    if (v.isNull())\n    {\n\treturn v;\n    }\n    if (v->valuetype() == YT_TERM)\n    {\n\treturn v->asTerm();\n    }\n    else if (v->valuetype() == YT_STRING)\n    {\n\treturn YCPTerm (v->asString()->value());\n    }\n    else if (v->valuetype() == YT_SYMBOL)\n    {\n\treturn YCPTerm (v->asSymbol()->symbol());\n    }\n    return YCPNull();\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPBuiltinTerm.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPTerm",
          "args": [
            "v->asSymbol()->symbol()"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "YCPTerm",
          "container": "YCPTerm",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "178-194",
          "snippet": "YCPTerm::YCPTerm (bytecodeistream & str)\n    : YCPValue (YCPTerm(\"no-name-so-far\"))\n{\n    string s;\n    if (Bytecode::readString (str, s))\n    {\n\tYCPList list (str);\n\tif (!list.isNull())\n\t{\n\t    (const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->setName(s);\n\t    for (int i = 0 ; i < list->size () ; i++)\n\t    {\n\t\t(const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->add (list->value (i));\n\t    }\n\t}\n    }\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTerm {\n  YCPTerm::YCPTerm (bytecodeistream & str)\n      : YCPValue (YCPTerm(\"no-name-so-far\"))\n  {\n      string s;\n      if (Bytecode::readString (str, s))\n      {\n  \tYCPList list (str);\n  \tif (!list.isNull())\n  \t{\n  \t    (const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->setName(s);\n  \t    for (int i = 0 ; i < list->size () ; i++)\n  \t    {\n  \t\t(const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->add (list->value (i));\n  \t    }\n  \t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->asSymbol",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "asSymbol",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "167-177",
          "snippet": "YCPSymbol\nYCPValueRep::asSymbol() const\n{\n    if (!isSymbol())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Symbol!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPSymbol (static_cast<const YCPSymbolRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPSymbol\n  YCPValueRep::asSymbol() const\n  {\n      if (!isSymbol())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Symbol!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPSymbol (static_cast<const YCPSymbolRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->valuetype",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "YCPSymbolRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "69-73",
          "snippet": "YCPValueType\nYCPSymbolRep::valuetype() const\n{\n    return YT_SYMBOL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbolRep {\n  YCPValueType\n  YCPSymbolRep::valuetype() const\n  {\n      return YT_SYMBOL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->asString",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->asTerm",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPBuiltinTerm.h\"\n\nstatic YCPValue\nt_toterm1 (const YCPValue &v)\n{\n    /**\n     * @builtin toterm\n     * @id toterm-any\n     * @short Converts a value to a term.\n     *\n     * @description\n     * If the value can't be converted to a term, nilterm is returned.\n     *\n     * @param any VALUE\n     * @return term\n     *\n     * @usage toterm (\"VBox\") -> `VBox ()\n     * @usage toterm (`VBox) -> `VBox ()\n     */\n\n    if (v.isNull())\n    {\n\treturn v;\n    }\n    if (v->valuetype() == YT_TERM)\n    {\n\treturn v->asTerm();\n    }\n    else if (v->valuetype() == YT_STRING)\n    {\n\treturn YCPTerm (v->asString()->value());\n    }\n    else if (v->valuetype() == YT_SYMBOL)\n    {\n\treturn YCPTerm (v->asSymbol()->symbol());\n    }\n    return YCPNull();\n}"
  },
  {
    "function_name": "t_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinTerm.cc",
    "lines": "104-145",
    "snippet": "YCPValue\nt_select (const YCPValue &term, const YCPValue&i, const YCPValue &def)\n{\n    /**\n     * @builtin select (deprecated, use TERM[ITEM]:DEFAULT)\n     * @id select-term\n     * @short Select item from term\n     * @description\n     * Gets the <tt>i</tt>'th value of the term <tt>t</tt>. The first value\n     * has the index 0. The call <tt>select ([1, 2, 3], 1)</tt> thus returns\n     * 2. Returns the <tt>default</tt> if the index is invalid or the found\n     * value has a diffetent type that <tt>default</tt>.\n     * Functionality replaced with syntax: <code>term a = `VBox(`VSpacing(2), `Label(\"string\"), `VSpacing(2));\n     * a[1]:`Empty() -> `Label (\"string\")\n     * a[9]:`Empty() -> `Empty ()</code>\n     *\n     * @param term TERM\n     * @param integer ITEM\n     * @param any DEFAULT\n     *\n     * @usage select (`hirn (true, false), 33, true) -> true\n     */\n\n    if (term.isNull ()\n\t|| !term->isTerm()\n\t|| i.isNull ()\n\t|| !i->isInteger ())\n    {\n\treturn YCPNull ();\n    }\n\n    long idx = i->asInteger()->value ();\n\n    YCPList list = term->asTerm()->args ();\n\n    if (idx < 0 || idx >= list->size ())\n    {\n\treturn def;\n    }\n\n    return list->value (idx);\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPBuiltinTerm.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list->value",
          "args": [
            "idx"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->size",
          "args": [],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->asTerm",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "i->asInteger",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "asInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "106-116",
          "snippet": "YCPInteger\nYCPValueRep::asInteger() const\n{\n    if (!isInteger())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPInteger\n  YCPValueRep::asInteger() const\n  {\n      if (!isInteger())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->isInteger",
          "args": [],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "63-63",
          "snippet": "bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "i.isNull",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term->isTerm",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "isTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "70-70",
          "snippet": "bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term.isNull",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPBuiltinTerm.h\"\n\nYCPValue\nt_select (const YCPValue &term, const YCPValue&i, const YCPValue &def)\n{\n    /**\n     * @builtin select (deprecated, use TERM[ITEM]:DEFAULT)\n     * @id select-term\n     * @short Select item from term\n     * @description\n     * Gets the <tt>i</tt>'th value of the term <tt>t</tt>. The first value\n     * has the index 0. The call <tt>select ([1, 2, 3], 1)</tt> thus returns\n     * 2. Returns the <tt>default</tt> if the index is invalid or the found\n     * value has a diffetent type that <tt>default</tt>.\n     * Functionality replaced with syntax: <code>term a = `VBox(`VSpacing(2), `Label(\"string\"), `VSpacing(2));\n     * a[1]:`Empty() -> `Label (\"string\")\n     * a[9]:`Empty() -> `Empty ()</code>\n     *\n     * @param term TERM\n     * @param integer ITEM\n     * @param any DEFAULT\n     *\n     * @usage select (`hirn (true, false), 33, true) -> true\n     */\n\n    if (term.isNull ()\n\t|| !term->isTerm()\n\t|| i.isNull ()\n\t|| !i->isInteger ())\n    {\n\treturn YCPNull ();\n    }\n\n    long idx = i->asInteger()->value ();\n\n    YCPList list = term->asTerm()->args ();\n\n    if (idx < 0 || idx >= list->size ())\n    {\n\treturn def;\n    }\n\n    return list->value (idx);\n}"
  },
  {
    "function_name": "t_symbolof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinTerm.cc",
    "lines": "81-99",
    "snippet": "static YCPValue\nt_symbolof (const YCPTerm &term)\n{\n    /**\n     * @builtin symbolof\n     * @short Returns the symbol of the term <tt>TERM</tt>.\n     *\n     * @param term TERM\n     * @return symbol\n     *\n     * @usage symbolof (`hrombuch (18, false)) -> `hrombuch\n     * @usage symbolof (`Label(\"string\")) -> `Label\n     */\n\n    if (term.isNull ())\n\treturn YCPNull ();\n\n    return YCPSymbol (term->name ());\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPBuiltinTerm.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPSymbol",
          "args": [
            "term->name ()"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "YCPSymbol",
          "container": "YCPSymbol",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "104-107",
          "snippet": "YCPSymbol::YCPSymbol (bytecodeistream & str)\n    : YCPValue (new YCPSymbolRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbol {\n  YCPSymbol::YCPSymbol (bytecodeistream & str)\n      : YCPValue (new YCPSymbolRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->name",
          "args": [],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Import",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Import.cc",
          "lines": "189-193",
          "snippet": "string\nImport::name () const\n{\n    return m_name;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Import.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Import.h\"\n#include <libintl.h>\n\nImport {\n  string\n  Import::name () const\n  {\n      return m_name;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term.isNull",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPBuiltinTerm.h\"\n\nstatic YCPValue\nt_symbolof (const YCPTerm &term)\n{\n    /**\n     * @builtin symbolof\n     * @short Returns the symbol of the term <tt>TERM</tt>.\n     *\n     * @param term TERM\n     * @return symbol\n     *\n     * @usage symbolof (`hrombuch (18, false)) -> `hrombuch\n     * @usage symbolof (`Label(\"string\")) -> `Label\n     */\n\n    if (term.isNull ())\n\treturn YCPNull ();\n\n    return YCPSymbol (term->name ());\n}"
  },
  {
    "function_name": "t_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinTerm.cc",
    "lines": "54-78",
    "snippet": "static YCPValue\nt_add (const YCPTerm &term, const YCPValue &value)\n{\n    /**\n     * @builtin add\n     * @id add-term\n     * @short Add value to term\n     * @description\n     * Adds the value <tt>VALUE</tt> to the term <tt>TERM</tt> and returns the\n     * newly created term. As always in YCP, <tt>TERM</tt> is not modified.\n     *\n     * @param term TERM \n     * @param any VALUE \n     * @return term\n     *\n     * @see remove\n     * @usage add (`VBox(`Empty()), `Label(\"a\")) -> `VBox (`Empty (), `Label (\"a\"))\n     * @usage add (`VBox(`Empty()), \"a\") -> `VBox (`Empty (), \"a\")\n     */\n\n    if (term.isNull () || value.isNull ())\n\treturn YCPNull ();\n\n    return term->functionalAdd (value);\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPBuiltinTerm.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "term->functionalAdd",
          "args": [
            "value"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "functionalAdd",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "85-89",
          "snippet": "YCPTerm\nYCPTermRep::functionalAdd (const YCPValue& val) const\n{\n   return YCPTerm (s.asString(), l->functionalAdd(val));\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPTerm\n  YCPTermRep::functionalAdd (const YCPValue& val) const\n  {\n     return YCPTerm (s.asString(), l->functionalAdd(val));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term.isNull",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPBuiltinTerm.h\"\n\nstatic YCPValue\nt_add (const YCPTerm &term, const YCPValue &value)\n{\n    /**\n     * @builtin add\n     * @id add-term\n     * @short Add value to term\n     * @description\n     * Adds the value <tt>VALUE</tt> to the term <tt>TERM</tt> and returns the\n     * newly created term. As always in YCP, <tt>TERM</tt> is not modified.\n     *\n     * @param term TERM \n     * @param any VALUE \n     * @return term\n     *\n     * @see remove\n     * @usage add (`VBox(`Empty()), `Label(\"a\")) -> `VBox (`Empty (), `Label (\"a\"))\n     * @usage add (`VBox(`Empty()), \"a\") -> `VBox (`Empty (), \"a\")\n     */\n\n    if (term.isNull () || value.isNull ())\n\treturn YCPNull ();\n\n    return term->functionalAdd (value);\n}"
  },
  {
    "function_name": "t_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinTerm.cc",
    "lines": "33-51",
    "snippet": "static YCPValue\nt_size (const YCPTerm &term)\n{\n    /**\n     * @builtin size\n     * @id size-term\n     * @short Returns the number of arguments of the term <tt>TERM</tt>.\n     *\n     * @param term TERM \n     * @return integer Size of the <tt>TERM</tt>\n     *\n     * @usage size (`VBox(`Empty(),`Empty(),`Empty())) -> 3\n     */\n\n    if (term.isNull ())\n\treturn YCPNull ();\n\n    return YCPInteger (term->size ());\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPBuiltinTerm.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPInteger",
          "args": [
            "term->size ()"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "YCPInteger",
          "container": "YCPInteger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPInteger.cc",
          "lines": "142-145",
          "snippet": "YCPInteger::YCPInteger (bytecodeistream & str)\n    : YCPValue (new YCPIntegerRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/y2log.h\"\n\nYCPInteger {\n  YCPInteger::YCPInteger (bytecodeistream & str)\n      : YCPValue (new YCPIntegerRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->size",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term.isNull",
          "args": [],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPBuiltinTerm.h\"\n\nstatic YCPValue\nt_size (const YCPTerm &term)\n{\n    /**\n     * @builtin size\n     * @id size-term\n     * @short Returns the number of arguments of the term <tt>TERM</tt>.\n     *\n     * @param term TERM \n     * @return integer Size of the <tt>TERM</tt>\n     *\n     * @usage size (`VBox(`Empty(),`Empty(),`Empty())) -> 3\n     */\n\n    if (term.isNull ())\n\treturn YCPNull ();\n\n    return YCPInteger (term->size ());\n}"
  }
]