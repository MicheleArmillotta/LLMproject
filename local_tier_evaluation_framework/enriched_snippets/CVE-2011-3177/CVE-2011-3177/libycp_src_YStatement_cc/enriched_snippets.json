[
  {
    "function_name": "setBlock",
    "container": "YSSwitch",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "2039-2043",
    "snippet": "void\nYSSwitch::setBlock (YBlockPtr block)\n{\n    m_block = block;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  void\n  YSSwitch::setBlock (YBlockPtr block)\n  {\n      m_block = block;\n  }\n}"
  },
  {
    "function_name": "setDefaultCase",
    "container": "YSSwitch",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "2026-2036",
    "snippet": "bool\nYSSwitch::setDefaultCase ()\n{\n    // fail, if there is default case already\n    if (m_defaultcase != -1)\n\treturn false;\n\n    m_defaultcase = m_block->statementCount ();\n    \n    return true;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_block->statementCount",
          "args": [],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "statementCount",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "824-837",
          "snippet": "int\nYBlock::statementCount () const\n{\n    int res = 0;\n    stmtlist_t *stmt = m_statements;\n\n    while (stmt)\n    {\n\tstmt = stmt->next;\n\tres++;\n    }\n    \n    return res;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  int\n  YBlock::statementCount () const\n  {\n      int res = 0;\n      stmtlist_t *stmt = m_statements;\n  \n      while (stmt)\n      {\n  \tstmt = stmt->next;\n  \tres++;\n      }\n      \n      return res;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  bool\n  YSSwitch::setDefaultCase ()\n  {\n      // fail, if there is default case already\n      if (m_defaultcase != -1)\n  \treturn false;\n  \n      m_defaultcase = m_block->statementCount ();\n      \n      return true;\n  }\n}"
  },
  {
    "function_name": "setCase",
    "container": "YSSwitch",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "2011-2023",
    "snippet": "bool\nYSSwitch::setCase (YCPValue value)\n{\n    // verify duplicate\n    if (m_cases.find (value) != m_cases.end ())\n\treturn false;\n    \n    int index = m_block->statementCount ();\n    \n    m_cases[value]=index;\n    \n    return true;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_block->statementCount",
          "args": [],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "statementCount",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "824-837",
          "snippet": "int\nYBlock::statementCount () const\n{\n    int res = 0;\n    stmtlist_t *stmt = m_statements;\n\n    while (stmt)\n    {\n\tstmt = stmt->next;\n\tres++;\n    }\n    \n    return res;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  int\n  YBlock::statementCount () const\n  {\n      int res = 0;\n      stmtlist_t *stmt = m_statements;\n  \n      while (stmt)\n      {\n  \tstmt = stmt->next;\n  \tres++;\n      }\n      \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_cases.end",
          "args": [],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_cases.find",
          "args": [
            "value"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  bool\n  YSSwitch::setCase (YCPValue value)\n  {\n      // verify duplicate\n      if (m_cases.find (value) != m_cases.end ())\n  \treturn false;\n      \n      int index = m_block->statementCount ();\n      \n      m_cases[value]=index;\n      \n      return true;\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSSwitch",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1958-2008",
    "snippet": "YCPValue\nYSSwitch::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug( \"YSSwitch\");\n#endif\n    if (cse)\n\treturn YCPNull ();\n\t\n    YCPValue condition = m_condition->evaluate ();\n    if (condition.isNull ())\n    {\n\tycperror (\"switch condition evaluates to 'nil'\");\n\treturn YCPNull ();\n    }\n    \n    // if there is a case for this value, execute\n    if (m_cases.find (condition) != m_cases.end ())\n    {\n#if DO_DEBUG\n\ty2debug (\"Evaluating from statement '%d'\",m_cases[condition]);\n#endif\n\tYCPValue res = m_block->evaluateFrom (m_cases[condition]);\n\n\t// break should not be propagated\n\tif (!res.isNull () && res->isBreak ())\n\t    res = YCPNull ();\n\t    \n\treturn res;\n    }\n    // no case, try default if defined\n    else if (m_defaultcase != -1)\n    {\n#if DO_DEBUG\n\ty2debug (\"Evaluating from default statement '%d'\",m_defaultcase);\n#endif\n\tYCPValue res = m_block->evaluateFrom (m_defaultcase);\n\n\t// break should not be propagated\n\tif (!res.isNull () && res->isBreak ())\n\t    res = YCPNull ();\n\t    \n\treturn res;\n    }\n\n#if DO_DEBUG\n    y2debug (\"Switch done\");\n#endif\n\n    return YCPNull ();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Switch done\""
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "res->isBreak",
          "args": [],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "isBreak",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "73-73",
          "snippet": "bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "res.isNull",
          "args": [],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_block->evaluateFrom",
          "args": [
            "m_defaultcase"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "evaluateFrom",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "695-780",
          "snippet": "YCPValue\nYBlock::evaluateFrom (int statement_index)\n{\n#if DO_DEBUG\n    y2debug (\"YBlock::evaluate from statement([%d]%s)\\n\", (int)m_kind, toString().c_str());\n#endif\n\n    // recursion handling - not used for modules\n    if (m_running)\n    {\n\tpushToStack ();\n    }\n    \n    bool old_m_running = m_running;\n    m_running = true;\n\n    string restore_name;\n    if (!filename().empty())\n    {\n\trestore_name = ee.filename ();\n\tee.setFilename (filename());\n    }\n\n    stmtlist_t *stmt = m_statements;\n    YCPValue value = YCPVoid ();\n    \n    // skip statements until index\n    while (stmt && statement_index > 0)\n    {\n\tstmt = stmt->next;\n\tstatement_index--;\n    }\n    \n    // execute the rest of statements\n    while (stmt)\n    {\n\tYStatementPtr statement = stmt->stmt;\n\t\n#if DO_DEBUG\n\ty2debug (\"%d: %s\", statement->line (), statement->toString ().c_str ());\n#endif\n\n\tee.setStatement (statement);\n\tvalue = statement->evaluate ();\n\n\tif (!value.isNull())\n\t{\n#if DO_DEBUG\n\t    y2debug (\"Block exit (%s)\", value->toString().c_str());\n#endif\n\t    break;\n\t}\n\n\tstmt = stmt->next;\n    }\n    if (!restore_name.empty())\n    {\n\tee.setFilename (restore_name);\n    }\n    \n    m_running = old_m_running;\n    \n    // recursion handling - not used for modules\n    if (! isModule () && m_running)\n    {\n\tpopFromStack ();\n    }\n\n#if DO_DEBUG\n    y2debug (\"YBlock::evaluate done (stmt %p, kind %d, value '%s')\\n\", stmt, m_kind, value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n\n    // if stmt==0 we're at the end of the block. If the block is evaluated as a statement,\n    //   it returns NULL, else it returns Void\n    if (stmt == 0)\n    {\n\tif (m_kind == b_statement)\n\t{\n\t    return YCPNull();\n\t}\n\treturn YCPVoid();\n    }\n\n    // if stmt!=0 we just evaluated a break or return statement. A 'return;' evaluates to YCPReturn\n    return value;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "extern ExecutionEnvironment ee;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nextern ExecutionEnvironment ee;\n\nYBlock {\n  YCPValue\n  YBlock::evaluateFrom (int statement_index)\n  {\n  #if DO_DEBUG\n      y2debug (\"YBlock::evaluate from statement([%d]%s)\\n\", (int)m_kind, toString().c_str());\n  #endif\n  \n      // recursion handling - not used for modules\n      if (m_running)\n      {\n  \tpushToStack ();\n      }\n      \n      bool old_m_running = m_running;\n      m_running = true;\n  \n      string restore_name;\n      if (!filename().empty())\n      {\n  \trestore_name = ee.filename ();\n  \tee.setFilename (filename());\n      }\n  \n      stmtlist_t *stmt = m_statements;\n      YCPValue value = YCPVoid ();\n      \n      // skip statements until index\n      while (stmt && statement_index > 0)\n      {\n  \tstmt = stmt->next;\n  \tstatement_index--;\n      }\n      \n      // execute the rest of statements\n      while (stmt)\n      {\n  \tYStatementPtr statement = stmt->stmt;\n  \t\n  #if DO_DEBUG\n  \ty2debug (\"%d: %s\", statement->line (), statement->toString ().c_str ());\n  #endif\n  \n  \tee.setStatement (statement);\n  \tvalue = statement->evaluate ();\n  \n  \tif (!value.isNull())\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"Block exit (%s)\", value->toString().c_str());\n  #endif\n  \t    break;\n  \t}\n  \n  \tstmt = stmt->next;\n      }\n      if (!restore_name.empty())\n      {\n  \tee.setFilename (restore_name);\n      }\n      \n      m_running = old_m_running;\n      \n      // recursion handling - not used for modules\n      if (! isModule () && m_running)\n      {\n  \tpopFromStack ();\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"YBlock::evaluate done (stmt %p, kind %d, value '%s')\\n\", stmt, m_kind, value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n  \n      // if stmt==0 we're at the end of the block. If the block is evaluated as a statement,\n      //   it returns NULL, else it returns Void\n      if (stmt == 0)\n      {\n  \tif (m_kind == b_statement)\n  \t{\n  \t    return YCPNull();\n  \t}\n  \treturn YCPVoid();\n      }\n  \n      // if stmt!=0 we just evaluated a break or return statement. A 'return;' evaluates to YCPReturn\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Evaluating from default statement '%d'\"",
            "m_defaultcase"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "res.isNull",
          "args": [],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Evaluating from statement '%d'\"",
            "m_cases[condition]"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_cases.end",
          "args": [],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_cases.find",
          "args": [
            "condition"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycperror",
          "args": [
            "\"switch condition evaluates to 'nil'\""
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "condition.isNull",
          "args": [],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_condition->evaluate",
          "args": [],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YSSwitch\""
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSSwitch {\n  YCPValue\n  YSSwitch::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug( \"YSSwitch\");\n  #endif\n      if (cse)\n  \treturn YCPNull ();\n  \t\n      YCPValue condition = m_condition->evaluate ();\n      if (condition.isNull ())\n      {\n  \tycperror (\"switch condition evaluates to 'nil'\");\n  \treturn YCPNull ();\n      }\n      \n      // if there is a case for this value, execute\n      if (m_cases.find (condition) != m_cases.end ())\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Evaluating from statement '%d'\",m_cases[condition]);\n  #endif\n  \tYCPValue res = m_block->evaluateFrom (m_cases[condition]);\n  \n  \t// break should not be propagated\n  \tif (!res.isNull () && res->isBreak ())\n  \t    res = YCPNull ();\n  \t    \n  \treturn res;\n      }\n      // no case, try default if defined\n      else if (m_defaultcase != -1)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Evaluating from default statement '%d'\",m_defaultcase);\n  #endif\n  \tYCPValue res = m_block->evaluateFrom (m_defaultcase);\n  \n  \t// break should not be propagated\n  \tif (!res.isNull () && res->isBreak ())\n  \t    res = YCPNull ();\n  \t    \n  \treturn res;\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"Switch done\");\n  #endif\n  \n      return YCPNull ();\n  }\n}"
  },
  {
    "function_name": "YSSwitch",
    "container": "YSSwitch",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1888-1919",
    "snippet": "YSSwitch::YSSwitch (bytecodeistream & str)\n    : YStatement (str)\n    , m_condition (0)\n    , m_block (0)\n    , m_defaultcase (-1)\n{\n    m_condition = Bytecode::readCode (str);\n    if (! m_condition)\n    {\n\tthrow Bytecode::Invalid();\n    }\n\n    int size = Bytecode::readInt32 (str);\n    for (int i = 0; i < size ; i++)\n    {\n\tYCPValue cv = Bytecode::readValue (str);\n\tif (cv.isNull ())\n\t{\n\t    throw Bytecode::Invalid();\n\t}\n\tint index = Bytecode::readInt32 (str);\n\tm_cases[cv] = index;\n    }\n    \n    m_defaultcase = Bytecode::readInt32 (str);\n    \n    m_block = (YBlockPtr)Bytecode::readCode (str);\n    if (! m_block)\n    {\n\tthrow Bytecode::Invalid();\n    }\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::Invalid",
          "args": [],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readInt32",
          "args": [
            "str"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::Invalid",
          "args": [],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cv.isNull",
          "args": [],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readValue",
          "args": [
            "str"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "readValue",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "419-500",
          "snippet": "YCPValue\nBytecode::readValue (bytecodeistream & str)\n{\n    char vt;\n    if (str.get (vt))\n    {\n\tswitch (vt)\n\t{\n\t    case YT_VOID:\n\t    {\n\t\treturn YCPVoid (str);\n\t    }\n\t    break;\n\t    case YT_BOOLEAN:\n\t    {\n\t\treturn YCPBoolean (str);\n\t    }\n\t    break;\n\t    case YT_INTEGER:\n\t    {\n\t\treturn YCPInteger (str);\n\t    }\n\t    break;\n\t    case YT_FLOAT:\n\t    {\n\t\treturn YCPFloat (str);\n\t    }\n\t    break;\n\t    case YT_STRING:\n\t    {\n\t\treturn YCPString (str);\n\t    }\n\t    break;\n\t    case YT_BYTEBLOCK:\n\t    {\n\t\treturn YCPByteblock (str);\n\t    }\n\t    break;\n\t    case YT_PATH:\n\t    {\n\t\treturn YCPPath (str);\n\t    }\n\t    break;\n\t    case YT_SYMBOL:\n\t    {\n\t\treturn YCPSymbol (str);\n\t    }\n\t    break;\n\t    case YT_LIST:\n\t    {\n\t\treturn YCPList (str);\n\t    }\n\t    break;\n\t    case YT_MAP:\n\t    {\n\t\treturn YCPMap (str);\n\t    }\n\t    break;\n\t    case YT_TERM:\n\t    {\n\t\treturn YCPTerm (str);\n\t    }\n\t    break;\n\t    case YT_CODE:\n\t    {\n\t\treturn YCPCode (str);\n\t    }\n\t    break;\n\t    default:\n\t    {\n\t\ty2error (\"readValue stream code %d\", vt);\n\t\tbreak;\n\t    }\n\t}\n    }\n    else\n    {\n\ty2warning (\"readValue(%d:%s) NIL\", (int)vt, YCode::toString((YCode::ykind)vt).c_str());\n    }\n\n    return YCPNull();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  YCPValue\n  Bytecode::readValue (bytecodeistream & str)\n  {\n      char vt;\n      if (str.get (vt))\n      {\n  \tswitch (vt)\n  \t{\n  \t    case YT_VOID:\n  \t    {\n  \t\treturn YCPVoid (str);\n  \t    }\n  \t    break;\n  \t    case YT_BOOLEAN:\n  \t    {\n  \t\treturn YCPBoolean (str);\n  \t    }\n  \t    break;\n  \t    case YT_INTEGER:\n  \t    {\n  \t\treturn YCPInteger (str);\n  \t    }\n  \t    break;\n  \t    case YT_FLOAT:\n  \t    {\n  \t\treturn YCPFloat (str);\n  \t    }\n  \t    break;\n  \t    case YT_STRING:\n  \t    {\n  \t\treturn YCPString (str);\n  \t    }\n  \t    break;\n  \t    case YT_BYTEBLOCK:\n  \t    {\n  \t\treturn YCPByteblock (str);\n  \t    }\n  \t    break;\n  \t    case YT_PATH:\n  \t    {\n  \t\treturn YCPPath (str);\n  \t    }\n  \t    break;\n  \t    case YT_SYMBOL:\n  \t    {\n  \t\treturn YCPSymbol (str);\n  \t    }\n  \t    break;\n  \t    case YT_LIST:\n  \t    {\n  \t\treturn YCPList (str);\n  \t    }\n  \t    break;\n  \t    case YT_MAP:\n  \t    {\n  \t\treturn YCPMap (str);\n  \t    }\n  \t    break;\n  \t    case YT_TERM:\n  \t    {\n  \t\treturn YCPTerm (str);\n  \t    }\n  \t    break;\n  \t    case YT_CODE:\n  \t    {\n  \t\treturn YCPCode (str);\n  \t    }\n  \t    break;\n  \t    default:\n  \t    {\n  \t\ty2error (\"readValue stream code %d\", vt);\n  \t\tbreak;\n  \t    }\n  \t}\n      }\n      else\n      {\n  \ty2warning (\"readValue(%d:%s) NIL\", (int)vt, YCode::toString((YCode::ykind)vt).c_str());\n      }\n  \n      return YCPNull();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::Invalid",
          "args": [],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  YSSwitch::YSSwitch (bytecodeistream & str)\n      : YStatement (str)\n      , m_condition (0)\n      , m_block (0)\n      , m_defaultcase (-1)\n  {\n      m_condition = Bytecode::readCode (str);\n      if (! m_condition)\n      {\n  \tthrow Bytecode::Invalid();\n      }\n  \n      int size = Bytecode::readInt32 (str);\n      for (int i = 0; i < size ; i++)\n      {\n  \tYCPValue cv = Bytecode::readValue (str);\n  \tif (cv.isNull ())\n  \t{\n  \t    throw Bytecode::Invalid();\n  \t}\n  \tint index = Bytecode::readInt32 (str);\n  \tm_cases[cv] = index;\n      }\n      \n      m_defaultcase = Bytecode::readInt32 (str);\n      \n      m_block = (YBlockPtr)Bytecode::readCode (str);\n      if (! m_block)\n      {\n  \tthrow Bytecode::Invalid();\n      }\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSSwitch",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1879-1885",
    "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_block->toStringSwitch",
          "args": [
            "m_cases",
            "m_defaultcase"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "toStringSwitch",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "480-521",
          "snippet": "string\nYBlock::toStringSwitch (map<YCPValue, int, ycp_less> cases, int defaultcase) const\n{\n    // first, create reverse map of cases\n    int statementcount = statementCount ();\n    YCPValue values[statementcount];\n    \n    for (int i = 0; i < statementcount; i++)\n\tvalues[i] = YCPNull ();\n\t\n    for (map<YCPValue, int, ycp_less>::iterator it = cases.begin ();\n\tit != cases.end (); it++ )\n    {\n\tvalues[ it->second ] = it->first;\n    }\n    \n    // create string output\n    string s = \"{\";\n\n    s += environmentToString ();\n\n    stmtlist_t *stmt = m_statements;\n    int index = 0;\n    while (stmt)\n    {\n\ts += \"\\n    \";\n\tif (index == defaultcase)\n\t{\n\t    s += \"default:\\n    \";\n\t}\n\telse if (! values[index].isNull ())\n\t{\n\t    s += \"case \" + values[index]->toString ()+\":\\n    \";\n\t}\n\ts += stmt->stmt->toString();\n\tstmt = stmt->next;\n\tindex++;\n    }\n\n    s += \"\\n}\\n\";\n    return s;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::toStringSwitch (map<YCPValue, int, ycp_less> cases, int defaultcase) const\n  {\n      // first, create reverse map of cases\n      int statementcount = statementCount ();\n      YCPValue values[statementcount];\n      \n      for (int i = 0; i < statementcount; i++)\n  \tvalues[i] = YCPNull ();\n  \t\n      for (map<YCPValue, int, ycp_less>::iterator it = cases.begin ();\n  \tit != cases.end (); it++ )\n      {\n  \tvalues[ it->second ] = it->first;\n      }\n      \n      // create string output\n      string s = \"{\";\n  \n      s += environmentToString ();\n  \n      stmtlist_t *stmt = m_statements;\n      int index = 0;\n      while (stmt)\n      {\n  \ts += \"\\n    \";\n  \tif (index == defaultcase)\n  \t{\n  \t    s += \"default:\\n    \";\n  \t}\n  \telse if (! values[index].isNull ())\n  \t{\n  \t    s += \"case \" + values[index]->toString ()+\":\\n    \";\n  \t}\n  \ts += stmt->stmt->toString();\n  \tstmt = stmt->next;\n  \tindex++;\n      }\n  \n      s += \"\\n}\\n\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_condition->toString",
          "args": [],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"switch (\""
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
  },
  {
    "function_name": "~YSSwitch",
    "container": "YSSwitch",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1874-1876",
    "snippet": "YSSwitch::~YSSwitch ()\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  YSSwitch::~YSSwitch ()\n  {\n  }\n}"
  },
  {
    "function_name": "YSSwitch",
    "container": "YSSwitch",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1865-1871",
    "snippet": "YSSwitch::YSSwitch (YCodePtr condition)\n    : YStatement ()\n    , m_condition (condition)\n    , m_block (0)\n    , m_defaultcase (-1)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  YSSwitch::YSSwitch (YCodePtr condition)\n      : YStatement ()\n      , m_condition (condition)\n      , m_block (0)\n      , m_defaultcase (-1)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSFilename",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1848-1857",
    "snippet": "YCPValue\nYSFilename::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug( \"YSFilename to set %s\", m_filename->c_str ());\n#endif\n    if (! cse) ee.setFilename (m_filename.asString());\n\n    return YCPNull ();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "extern ExecutionEnvironment ee;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee.setFilename",
          "args": [
            "m_filename.asString()"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "setFilename",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "87-96",
          "snippet": "void\nYCPDebugger::setFilename (const char *filename)\n{\n    y2debug (\"setFilename (%s)\\n\", filename);\n    if (filename)\n    {\n\tm_filename = filename;\n    }\n    return;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::setFilename (const char *filename)\n  {\n      y2debug (\"setFilename (%s)\\n\", filename);\n      if (filename)\n      {\n  \tm_filename = filename;\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_filename.asString",
          "args": [],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YSFilename to set %s\"",
            "m_filename->c_str ()"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_filename->c_str",
          "args": [],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nextern ExecutionEnvironment ee;\n\nYSFilename {\n  YCPValue\n  YSFilename::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug( \"YSFilename to set %s\", m_filename->c_str ());\n  #endif\n      if (! cse) ee.setFilename (m_filename.asString());\n  \n      return YCPNull ();\n  }\n}"
  },
  {
    "function_name": "YSFilename",
    "container": "YSFilename",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1826-1830",
    "snippet": "YSFilename::YSFilename (bytecodeistream & str)\n    : YStatement (str)\n    , m_filename (Bytecode::readUstring (str))\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readUstring",
          "args": [
            "str"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "readUstring",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "263-279",
          "snippet": "Ustring\nBytecode::readUstring (bytecodeistream & streamref)\n{\n    u_int32_t len = readInt32 (streamref);\n    Ustring ret = Ustring (*SymbolEntry::_nameHash, \"\");\n    if (len > 0)\n    {\n\tchar *buf = new char [len+1];\n\tif (streamref.read (buf, len))\n\t{\n\t    buf[len] = 0;\n\t    ret = Ustring (*SymbolEntry::_nameHash, buf);\n\t}\n\tdelete [] buf;\n    }\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  Ustring\n  Bytecode::readUstring (bytecodeistream & streamref)\n  {\n      u_int32_t len = readInt32 (streamref);\n      Ustring ret = Ustring (*SymbolEntry::_nameHash, \"\");\n      if (len > 0)\n      {\n  \tchar *buf = new char [len+1];\n  \tif (streamref.read (buf, len))\n  \t{\n  \t    buf[len] = 0;\n  \t    ret = Ustring (*SymbolEntry::_nameHash, buf);\n  \t}\n  \tdelete [] buf;\n      }\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSFilename {\n  YSFilename::YSFilename (bytecodeistream & str)\n      : YStatement (str)\n      , m_filename (Bytecode::readUstring (str))\n  {\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSFilename",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1818-1823",
    "snippet": "string\nYSFilename::toString() const\n{\n    string s = string (\"// force filename: \\\"\") + m_filename.asString() + \"\\\"\";\n    return s;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_filename.asString",
          "args": [],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"// force filename: \\\"\""
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSFilename {\n  string\n  YSFilename::toString() const\n  {\n      string s = string (\"// force filename: \\\"\") + m_filename.asString() + \"\\\"\";\n      return s;\n  }\n}"
  },
  {
    "function_name": "~YSFilename",
    "container": "YSFilename",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1813-1815",
    "snippet": "YSFilename::~YSFilename ()\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSFilename {\n  YSFilename::~YSFilename ()\n  {\n  }\n}"
  },
  {
    "function_name": "YSFilename",
    "container": "YSFilename",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1806-1810",
    "snippet": "YSFilename::YSFilename (const string &filename, int line)\n    : YStatement (line)\n    , m_filename (Ustring (*SymbolEntry::_nameHash, filename))\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Ustring",
          "args": [
            "*SymbolEntry::_nameHash",
            "filename"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSFilename {\n  YSFilename::YSFilename (const string &filename, int line)\n      : YStatement (line)\n      , m_filename (Ustring (*SymbolEntry::_nameHash, filename))\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSImport",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1785-1798",
    "snippet": "YCPValue\nYSImport::evaluate (bool cse)\n{\n    if (!cse && (nameSpace () != NULL))\n    {\n#if DO_DEBUG\n\ty2debug (\"Evaluating namespace '%s'\", m_name->c_str());\n#endif\n\t\n\tnameSpace()->initialize ();\n    }\n\n    return YCPNull();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nameSpace",
          "args": [],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nameSpace",
          "args": [],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Evaluating namespace '%s'\"",
            "m_name->c_str()"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name->c_str",
          "args": [],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nameSpace",
          "args": [],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSImport {\n  YCPValue\n  YSImport::evaluate (bool cse)\n  {\n      if (!cse && (nameSpace () != NULL))\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Evaluating namespace '%s'\", m_name->c_str());\n  #endif\n  \t\n  \tnameSpace()->initialize ();\n      }\n  \n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "YSImport",
    "container": "YSImport",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1691-1756",
    "snippet": "YSImport::YSImport (bytecodeistream & str)\n    : YStatement (str)\n{\n    char *mname = Bytecode::readCharp (str);\n    import (mname);\t\t\t\t// <=== this does the importing\n    delete [] mname;\n\n    if (nameSpace() == 0)\n    {\n\tycp2error (\"Import '%s' failed...\\n\", name().c_str());\n\tycp2error (\"Could not create its namespace\\n\");\n\tthrow Bytecode::Invalid();\n    }\n\n    // now load symbols we need from the just imported namespace\n    // (this import statement is here because symbols are needed from the namespace)\n\n    Bytecode::pushNamespace (nameSpace (), true);\t\t\t// see YBlock::YBlock(str) for popUptoNamespace()\n\n    bool xref_debug = (getenv (XREFDEBUG) != 0);\n\n    int xrefcount = Bytecode::readInt32 (str);\n\n    if (xref_debug) y2milestone (\"Resolving %d symbols from module %s\\n\", xrefcount, m_name->c_str());\n#if DO_DEBUG\n    else y2debug (\"Resolving %d symbols from module %s\\n\", xrefcount, m_name->c_str());\n#endif\n\n    if (xrefcount != 0)\n    {\n\tSymbolTable *table = m_module->second->table();\n\n\tconst char *sname;\n\tTypePtr stype;\n\tTableEntry *tentry;\n\n\twhile (xrefcount-- > 0)\t\t\t\t\t\t// build up xref vector in table\n\t{\n\t    sname = Bytecode::readCharp (str);\n\t    stype = Bytecode::readType (str);\n\n\t    if (xref_debug) y2milestone (\"Xref -------------------------------- '%s' <%s>\\n\", sname, stype->toString().c_str());\n#if DO_DEBUG\n\t    else y2debug (\"Xref -------------------------------- '%s' <%s>\\n\", sname, stype->toString().c_str());\n#endif\n\n\t    tentry = table->xref (sname);\t\t\t\t// look for match in table\n\n\t    if (tentry == 0)\n\t    {\n\t\tycp2error (\"Import '%s' failed\\n\", m_name->c_str());\n\t\tycp2error (\"Symbol '%s::%s' does not exist.\\n\", m_name->c_str(), sname);\n\t\tthrow Bytecode::Invalid();\n\t    }\n\t    else if (tentry->sentry()->type()->match (stype) != 0)\n\t    {\n\t\tycp2error (\"Import '%s' failed\\n\", m_name->c_str());\n\t\tycp2error (\"A reference to '%s::%s' expects type <%s> but module provides type <%s>\\n\",\n\t\t\tm_name->c_str(), sname,\n\t\t\tstype->toString().c_str(), tentry->sentry()->type()->toString().c_str());\n\t\tthrow Bytecode::Invalid();\n\t    }\n\t    delete [] sname;\n\t}\n    }\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::Invalid",
          "args": [],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"A reference to '%s::%s' expects type <%s> but module provides type <%s>\\n\"",
            "m_name->c_str()",
            "sname",
            "stype->toString().c_str()",
            "tentry->sentry()->type()->toString().c_str()"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tentry->sentry",
          "args": [],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "sentry",
          "container": "TableEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "97-101",
          "snippet": "SymbolEntryPtr \nTableEntry::sentry() const\n{\n    return m_entry;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  SymbolEntryPtr \n  TableEntry::sentry() const\n  {\n      return m_entry;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stype->toString",
          "args": [],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_name->c_str",
          "args": [],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Import '%s' failed\\n\"",
            "m_name->c_str()"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name->c_str",
          "args": [],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tentry->sentry",
          "args": [
            "stype"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "sentry",
          "container": "Point",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Point.cc",
          "lines": "90-94",
          "snippet": "SymbolEntryPtr \nPoint::sentry (void) const\n{\n    return m_entry;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include <string>\n\nPoint {\n  SymbolEntryPtr \n  Point::sentry (void) const\n  {\n      return m_entry;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::Invalid",
          "args": [],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Symbol '%s::%s' does not exist.\\n\"",
            "m_name->c_str()",
            "sname"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name->c_str",
          "args": [],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Import '%s' failed\\n\"",
            "m_name->c_str()"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name->c_str",
          "args": [],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table->xref",
          "args": [
            "sname"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2milestone",
          "args": [
            "\"Xref -------------------------------- '%s' <%s>\\n\"",
            "sname",
            "stype->toString().c_str()"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readType",
          "args": [
            "str"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "readType",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "349-387",
          "snippet": "TypePtr\nBytecode::readType (bytecodeistream & str)\n{\n    int kind = readInt32 (str);\n#if DO_DEBUG\ny2debug (\"Bytecode::readType(%d)\", kind);\n#endif\n    switch ((Type::tkind)kind)\n    {\n\tcase Type::UnspecT:\n\tcase Type::ErrorT:\n\tcase Type::AnyT:\n\tcase Type::BooleanT:\n\tcase Type::ByteblockT:\n\tcase Type::FloatT:\n\tcase Type::IntegerT:\n\tcase Type::LocaleT:\n\tcase Type::PathT:\n\tcase Type::StringT:\n\tcase Type::SymbolT:\n\tcase Type::TermT:\n\tcase Type::VoidT:\n\tcase Type::WildcardT:\n\tcase Type::FlexT:\n\tcase Type::NilT:\n\t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n\tbreak;\n\n\tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n\tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n\tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n\tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n\tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n\tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n\tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n    }\n    y2error (\"Unhandled type kind %d\", kind);\n    return Type::Error->clone();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  TypePtr\n  Bytecode::readType (bytecodeistream & str)\n  {\n      int kind = readInt32 (str);\n  #if DO_DEBUG\n  y2debug (\"Bytecode::readType(%d)\", kind);\n  #endif\n      switch ((Type::tkind)kind)\n      {\n  \tcase Type::UnspecT:\n  \tcase Type::ErrorT:\n  \tcase Type::AnyT:\n  \tcase Type::BooleanT:\n  \tcase Type::ByteblockT:\n  \tcase Type::FloatT:\n  \tcase Type::IntegerT:\n  \tcase Type::LocaleT:\n  \tcase Type::PathT:\n  \tcase Type::StringT:\n  \tcase Type::SymbolT:\n  \tcase Type::TermT:\n  \tcase Type::VoidT:\n  \tcase Type::WildcardT:\n  \tcase Type::FlexT:\n  \tcase Type::NilT:\n  \t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n  \tbreak;\n  \n  \tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n  \tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n  \tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n  \tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n  \tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n  \tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n  \tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n      }\n      y2error (\"Unhandled type kind %d\", kind);\n      return Type::Error->clone();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readCharp",
          "args": [
            "str"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_module->second->table",
          "args": [],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name->c_str",
          "args": [],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2milestone",
          "args": [
            "\"Resolving %d symbols from module %s\\n\"",
            "xrefcount",
            "m_name->c_str()"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name->c_str",
          "args": [],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readInt32",
          "args": [
            "str"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "XREFDEBUG"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::pushNamespace",
          "args": [
            "nameSpace ()",
            "true"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "pushNamespace",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "619-645",
          "snippet": "int\nBytecode::pushNamespace (const Y2Namespace *name_space, bool with_xrefs)\n{\n    if (name_space == 0)\n    {\n\ty2error (\"Bytecode::pushNamespace (%p) NULL\", name_space);\n\treturn -1;\n    }\n\n    m_namespace_nesting_level++;\n    if (m_namespace_nesting_array_size <= m_namespace_nesting_level)\n    {\n\tm_namespace_nesting_array_size += 16;\n\tm_namespace_nesting_array = (namespaceentry_t *)realloc (m_namespace_nesting_array, sizeof (namespaceentry_t) * m_namespace_nesting_array_size);\n    }\n#if DO_DEBUG\n    y2debug (\"Bytecode::pushNamespace (%p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n#endif\n    m_namespace_nesting_array[m_namespace_nesting_level].name_space = name_space;\n    m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs = with_xrefs;\n    if (with_xrefs)\n    {\n\tname_space->table()->openXRefs();\n    }\n\n    return m_namespace_nesting_level-m_namespace_tare_level;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "int Bytecode::m_namespace_nesting_level = -1;",
            "int Bytecode::m_namespace_nesting_array_size = 0;",
            "int Bytecode::m_namespace_tare_level = 0;",
            "Bytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nint Bytecode::m_namespace_nesting_level = -1;\nint Bytecode::m_namespace_nesting_array_size = 0;\nint Bytecode::m_namespace_tare_level = 0;\nBytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;\n\nBytecode {\n  int\n  Bytecode::pushNamespace (const Y2Namespace *name_space, bool with_xrefs)\n  {\n      if (name_space == 0)\n      {\n  \ty2error (\"Bytecode::pushNamespace (%p) NULL\", name_space);\n  \treturn -1;\n      }\n  \n      m_namespace_nesting_level++;\n      if (m_namespace_nesting_array_size <= m_namespace_nesting_level)\n      {\n  \tm_namespace_nesting_array_size += 16;\n  \tm_namespace_nesting_array = (namespaceentry_t *)realloc (m_namespace_nesting_array, sizeof (namespaceentry_t) * m_namespace_nesting_array_size);\n      }\n  #if DO_DEBUG\n      y2debug (\"Bytecode::pushNamespace (%p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n  #endif\n      m_namespace_nesting_array[m_namespace_nesting_level].name_space = name_space;\n      m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs = with_xrefs;\n      if (with_xrefs)\n      {\n  \tname_space->table()->openXRefs();\n      }\n  \n      return m_namespace_nesting_level-m_namespace_tare_level;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nameSpace",
          "args": [],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::Invalid",
          "args": [],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Could not create its namespace\\n\""
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Import '%s' failed...\\n\"",
            "name().c_str()"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSFilename",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1818-1823",
          "snippet": "string\nYSFilename::toString() const\n{\n    string s = string (\"// force filename: \\\"\") + m_filename.asString() + \"\\\"\";\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSFilename {\n  string\n  YSFilename::toString() const\n  {\n      string s = string (\"// force filename: \\\"\") + m_filename.asString() + \"\\\"\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nameSpace",
          "args": [],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "import",
          "args": [
            "mname"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readCharp",
          "args": [
            "str"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSImport {\n  YSImport::YSImport (bytecodeistream & str)\n      : YStatement (str)\n  {\n      char *mname = Bytecode::readCharp (str);\n      import (mname);\t\t\t\t// <=== this does the importing\n      delete [] mname;\n  \n      if (nameSpace() == 0)\n      {\n  \tycp2error (\"Import '%s' failed...\\n\", name().c_str());\n  \tycp2error (\"Could not create its namespace\\n\");\n  \tthrow Bytecode::Invalid();\n      }\n  \n      // now load symbols we need from the just imported namespace\n      // (this import statement is here because symbols are needed from the namespace)\n  \n      Bytecode::pushNamespace (nameSpace (), true);\t\t\t// see YBlock::YBlock(str) for popUptoNamespace()\n  \n      bool xref_debug = (getenv (XREFDEBUG) != 0);\n  \n      int xrefcount = Bytecode::readInt32 (str);\n  \n      if (xref_debug) y2milestone (\"Resolving %d symbols from module %s\\n\", xrefcount, m_name->c_str());\n  #if DO_DEBUG\n      else y2debug (\"Resolving %d symbols from module %s\\n\", xrefcount, m_name->c_str());\n  #endif\n  \n      if (xrefcount != 0)\n      {\n  \tSymbolTable *table = m_module->second->table();\n  \n  \tconst char *sname;\n  \tTypePtr stype;\n  \tTableEntry *tentry;\n  \n  \twhile (xrefcount-- > 0)\t\t\t\t\t\t// build up xref vector in table\n  \t{\n  \t    sname = Bytecode::readCharp (str);\n  \t    stype = Bytecode::readType (str);\n  \n  \t    if (xref_debug) y2milestone (\"Xref -------------------------------- '%s' <%s>\\n\", sname, stype->toString().c_str());\n  #if DO_DEBUG\n  \t    else y2debug (\"Xref -------------------------------- '%s' <%s>\\n\", sname, stype->toString().c_str());\n  #endif\n  \n  \t    tentry = table->xref (sname);\t\t\t\t// look for match in table\n  \n  \t    if (tentry == 0)\n  \t    {\n  \t\tycp2error (\"Import '%s' failed\\n\", m_name->c_str());\n  \t\tycp2error (\"Symbol '%s::%s' does not exist.\\n\", m_name->c_str(), sname);\n  \t\tthrow Bytecode::Invalid();\n  \t    }\n  \t    else if (tentry->sentry()->type()->match (stype) != 0)\n  \t    {\n  \t\tycp2error (\"Import '%s' failed\\n\", m_name->c_str());\n  \t\tycp2error (\"A reference to '%s::%s' expects type <%s> but module provides type <%s>\\n\",\n  \t\t\tm_name->c_str(), sname,\n  \t\t\tstype->toString().c_str(), tentry->sentry()->type()->toString().c_str());\n  \t\tthrow Bytecode::Invalid();\n  \t    }\n  \t    delete [] sname;\n  \t}\n      }\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSImport",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1678-1683",
    "snippet": "string\nYSImport::toString() const\n{\n    string s = string (\"import \\\"\") + m_name.asString() + \"\\\";\";\n    return s;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_name.asString",
          "args": [],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"import \\\"\""
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSImport {\n  string\n  YSImport::toString() const\n  {\n      string s = string (\"import \\\"\") + m_name.asString() + \"\\\";\";\n      return s;\n  }\n}"
  },
  {
    "function_name": "name",
    "container": "YSImport",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1671-1675",
    "snippet": "string\nYSImport::name () const\n{\n    return m_name.asString();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_name.asString",
          "args": [],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSImport {\n  string\n  YSImport::name () const\n  {\n      return m_name.asString();\n  }\n}"
  },
  {
    "function_name": "~YSImport",
    "container": "YSImport",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1666-1668",
    "snippet": "YSImport::~YSImport ()\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSImport {\n  YSImport::~YSImport ()\n  {\n  }\n}"
  },
  {
    "function_name": "YSImport",
    "container": "YSImport",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1659-1663",
    "snippet": "YSImport::YSImport (const string &name, Y2Namespace *name_space)\n    : YStatement (0)\n    , Import (name, name_space)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSImport {\n  YSImport::YSImport (const string &name, Y2Namespace *name_space)\n      : YStatement (0)\n      , Import (name, name_space)\n  {\n  }\n}"
  },
  {
    "function_name": "YSImport",
    "container": "YSImport",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1640-1654",
    "snippet": "YSImport::YSImport (const string &name, int line)\n    : YStatement (line)\n{\n    Import::disableTracking();\t\t\t\t// don't track variable usage _inside_ the imported module\n\n    if (import (name) != 0)\n    {\n#if DO_DEBUG\n\ty2debug (\"import '%s' failed\", name.c_str());   // debug only, import() already logged the error\n#endif\n\t// the caller checks this->name().empty() as an error indicator\n    }\n\n    Import::enableTracking();                          // continue tracking in .ycp\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Import::enableTracking",
          "args": [],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "enableTracking",
          "container": "Import",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Import.cc",
          "lines": "165-186",
          "snippet": "void\nImport::enableTracking ()\n{\n    m_disable_tracking--;\n#if DO_DEBUG\n    y2debug (\"Import::enableTracking (%d)\", m_disable_tracking);\n#endif\n    if (m_disable_tracking > 0)\n    {\n\treturn;\n    }\n    while (!m_table_stack.empty())\n    {\n\tSymbolTable *table = m_table_stack.top().second;\n#if DO_DEBUG\n\ty2debug (\"enableUsage (%s:%p)\", m_table_stack.top().first.c_str(), table);\n#endif\n\ttable->enableUsage();\n\tm_table_stack.pop();\n    }\n    return;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Import.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "int Import::m_disable_tracking = 0;",
            "std::stack <std::pair <string, SymbolTable *> > Import::m_table_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Import.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nint Import::m_disable_tracking = 0;\nstd::stack <std::pair <string, SymbolTable *> > Import::m_table_stack;\n\nImport {\n  void\n  Import::enableTracking ()\n  {\n      m_disable_tracking--;\n  #if DO_DEBUG\n      y2debug (\"Import::enableTracking (%d)\", m_disable_tracking);\n  #endif\n      if (m_disable_tracking > 0)\n      {\n  \treturn;\n      }\n      while (!m_table_stack.empty())\n      {\n  \tSymbolTable *table = m_table_stack.top().second;\n  #if DO_DEBUG\n  \ty2debug (\"enableUsage (%s:%p)\", m_table_stack.top().first.c_str(), table);\n  #endif\n  \ttable->enableUsage();\n  \tm_table_stack.pop();\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"import '%s' failed\"",
            "name.c_str()"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "import",
          "args": [
            "name"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Import::disableTracking",
          "args": [],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "disableTracking",
          "container": "Import",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Import.cc",
          "lines": "154-162",
          "snippet": "void\nImport::disableTracking ()\n{\n    m_disable_tracking++;\n#if DO_DEBUG\n    y2debug (\"Import::disableTracking (%d)\", m_disable_tracking);\n#endif\n    return;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Import.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "int Import::m_disable_tracking = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Import.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nint Import::m_disable_tracking = 0;\n\nImport {\n  void\n  Import::disableTracking ()\n  {\n      m_disable_tracking++;\n  #if DO_DEBUG\n      y2debug (\"Import::disableTracking (%d)\", m_disable_tracking);\n  #endif\n      return;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSImport {\n  YSImport::YSImport (const string &name, int line)\n      : YStatement (line)\n  {\n      Import::disableTracking();\t\t\t\t// don't track variable usage _inside_ the imported module\n  \n      if (import (name) != 0)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"import '%s' failed\", name.c_str());   // debug only, import() already logged the error\n  #endif\n  \t// the caller checks this->name().empty() as an error indicator\n      }\n  \n      Import::enableTracking();                          // continue tracking in .ycp\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSInclude",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1628-1633",
    "snippet": "YCPValue\nYSInclude::evaluate (bool cse)\n{\n    if (!cse && !m_skipped) ee.setFilename (m_filename);\n    return YCPNull();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern ExecutionEnvironment ee;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee.setFilename",
          "args": [
            "m_filename"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "setFilename",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "87-96",
          "snippet": "void\nYCPDebugger::setFilename (const char *filename)\n{\n    y2debug (\"setFilename (%s)\\n\", filename);\n    if (filename)\n    {\n\tm_filename = filename;\n    }\n    return;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::setFilename (const char *filename)\n  {\n      y2debug (\"setFilename (%s)\\n\", filename);\n      if (filename)\n      {\n  \tm_filename = filename;\n      }\n      return;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nextern ExecutionEnvironment ee;\n\nYSInclude {\n  YCPValue\n  YSInclude::evaluate (bool cse)\n  {\n      if (!cse && !m_skipped) ee.setFilename (m_filename);\n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "YSInclude",
    "container": "YSInclude",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1602-1607",
    "snippet": "YSInclude::YSInclude (bytecodeistream & str)\n    : YStatement (str)\n    , m_filename (Bytecode::readUstring (str))\n{\n    m_skipped = Bytecode::readBool (str);\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readBool",
          "args": [
            "str"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "readBool",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "158-172",
          "snippet": "bool\nBytecode::readBool (bytecodeistream & str)\n{\n    char c;\n    str.get (c);\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n#endif\n\n    if (c != 0)\n    {\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readBool (bytecodeistream & str)\n  {\n      char c;\n      str.get (c);\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n  #endif\n  \n      if (c != 0)\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readUstring",
          "args": [
            "str"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "readUstring",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "263-279",
          "snippet": "Ustring\nBytecode::readUstring (bytecodeistream & streamref)\n{\n    u_int32_t len = readInt32 (streamref);\n    Ustring ret = Ustring (*SymbolEntry::_nameHash, \"\");\n    if (len > 0)\n    {\n\tchar *buf = new char [len+1];\n\tif (streamref.read (buf, len))\n\t{\n\t    buf[len] = 0;\n\t    ret = Ustring (*SymbolEntry::_nameHash, buf);\n\t}\n\tdelete [] buf;\n    }\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  Ustring\n  Bytecode::readUstring (bytecodeistream & streamref)\n  {\n      u_int32_t len = readInt32 (streamref);\n      Ustring ret = Ustring (*SymbolEntry::_nameHash, \"\");\n      if (len > 0)\n      {\n  \tchar *buf = new char [len+1];\n  \tif (streamref.read (buf, len))\n  \t{\n  \t    buf[len] = 0;\n  \t    ret = Ustring (*SymbolEntry::_nameHash, buf);\n  \t}\n  \tdelete [] buf;\n      }\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSInclude {\n  YSInclude::YSInclude (bytecodeistream & str)\n      : YStatement (str)\n      , m_filename (Bytecode::readUstring (str))\n  {\n      m_skipped = Bytecode::readBool (str);\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSInclude",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1594-1599",
    "snippet": "string\nYSInclude::toString() const\n{\n    string s = string (\"// include \\\"\") + m_filename.asString() + \"\\\";\";\n    return s;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_filename.asString",
          "args": [],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"// include \\\"\""
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSInclude {\n  string\n  YSInclude::toString() const\n  {\n      string s = string (\"// include \\\"\") + m_filename.asString() + \"\\\";\";\n      return s;\n  }\n}"
  },
  {
    "function_name": "~YSInclude",
    "container": "YSInclude",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1589-1591",
    "snippet": "YSInclude::~YSInclude ()\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSInclude {\n  YSInclude::~YSInclude ()\n  {\n  }\n}"
  },
  {
    "function_name": "YSInclude",
    "container": "YSInclude",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1581-1586",
    "snippet": "YSInclude::YSInclude (const string &filename, int line, bool skipped)\n    : YStatement (line)\n    , m_filename (Ustring (*SymbolEntry::_nameHash, filename))\n    , m_skipped (skipped)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Ustring",
          "args": [
            "*SymbolEntry::_nameHash",
            "filename"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSInclude {\n  YSInclude::YSInclude (const string &filename, int line, bool skipped)\n      : YStatement (line)\n      , m_filename (Ustring (*SymbolEntry::_nameHash, filename))\n      , m_skipped (skipped)\n  {\n  }\n}"
  },
  {
    "function_name": "bind",
    "container": "YSTextdomain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1569-1576",
    "snippet": "void\nYSTextdomain::bind ()\n{\n#if DO_DEBUG\n    y2debug (\"going to bind a domain %s\", m_domain->c_str() );\n#endif\n    YLocale::ensureBindDomain (m_domain);\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YLocale::ensureBindDomain",
          "args": [
            "m_domain"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "ensureBindDomain",
          "container": "YLocale",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "561-569",
          "snippet": "void \nYLocale::ensureBindDomain (const string& domain)\n{\n    if (domains.find (domain.c_str ()) == domains.end () \n\t|| ! domains[domain.c_str ()])\n    {\n\tbindDomainDir (domain, LOCALEDIR);\n    }\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YLocale::t_uniquedomains YLocale::domains;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYLocale::t_uniquedomains YLocale::domains;\n\nYLocale {\n  void \n  YLocale::ensureBindDomain (const string& domain)\n  {\n      if (domains.find (domain.c_str ()) == domains.end () \n  \t|| ! domains[domain.c_str ()])\n      {\n  \tbindDomainDir (domain, LOCALEDIR);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"going to bind a domain %s\"",
            "m_domain->c_str()"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_domain->c_str",
          "args": [],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSTextdomain {\n  void\n  YSTextdomain::bind ()\n  {\n  #if DO_DEBUG\n      y2debug (\"going to bind a domain %s\", m_domain->c_str() );\n  #endif\n      YLocale::ensureBindDomain (m_domain);\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSTextdomain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1563-1567",
    "snippet": "YCPValue\nYSTextdomain::evaluate (bool /*cse*/)\n{\n    return YCPNull();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSTextdomain {\n  YCPValue\n  YSTextdomain::evaluate (bool /*cse*/)\n  {\n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "YSTextdomain",
    "container": "YSTextdomain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1540-1545",
    "snippet": "YSTextdomain::YSTextdomain (bytecodeistream & str)\n    : YStatement (str)\n    , m_domain (Bytecode::readUstring (str))\n{\n    bind ();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bind",
          "args": [],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "bind",
          "container": "YSTextdomain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1569-1576",
          "snippet": "void\nYSTextdomain::bind ()\n{\n#if DO_DEBUG\n    y2debug (\"going to bind a domain %s\", m_domain->c_str() );\n#endif\n    YLocale::ensureBindDomain (m_domain);\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSTextdomain {\n  void\n  YSTextdomain::bind ()\n  {\n  #if DO_DEBUG\n      y2debug (\"going to bind a domain %s\", m_domain->c_str() );\n  #endif\n      YLocale::ensureBindDomain (m_domain);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readUstring",
          "args": [
            "str"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "readUstring",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "263-279",
          "snippet": "Ustring\nBytecode::readUstring (bytecodeistream & streamref)\n{\n    u_int32_t len = readInt32 (streamref);\n    Ustring ret = Ustring (*SymbolEntry::_nameHash, \"\");\n    if (len > 0)\n    {\n\tchar *buf = new char [len+1];\n\tif (streamref.read (buf, len))\n\t{\n\t    buf[len] = 0;\n\t    ret = Ustring (*SymbolEntry::_nameHash, buf);\n\t}\n\tdelete [] buf;\n    }\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  Ustring\n  Bytecode::readUstring (bytecodeistream & streamref)\n  {\n      u_int32_t len = readInt32 (streamref);\n      Ustring ret = Ustring (*SymbolEntry::_nameHash, \"\");\n      if (len > 0)\n      {\n  \tchar *buf = new char [len+1];\n  \tif (streamref.read (buf, len))\n  \t{\n  \t    buf[len] = 0;\n  \t    ret = Ustring (*SymbolEntry::_nameHash, buf);\n  \t}\n  \tdelete [] buf;\n      }\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSTextdomain {\n  YSTextdomain::YSTextdomain (bytecodeistream & str)\n      : YStatement (str)\n      , m_domain (Bytecode::readUstring (str))\n  {\n      bind ();\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSTextdomain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1532-1537",
    "snippet": "string\nYSTextdomain::toString() const\n{\n    string s = string (\"textdomain \\\"\") + m_domain.asString() + \"\\\";\";\n    return s;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_domain.asString",
          "args": [],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"textdomain \\\"\""
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSTextdomain {\n  string\n  YSTextdomain::toString() const\n  {\n      string s = string (\"textdomain \\\"\") + m_domain.asString() + \"\\\";\";\n      return s;\n  }\n}"
  },
  {
    "function_name": "~YSTextdomain",
    "container": "YSTextdomain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1527-1529",
    "snippet": "YSTextdomain::~YSTextdomain ()\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSTextdomain {\n  YSTextdomain::~YSTextdomain ()\n  {\n  }\n}"
  },
  {
    "function_name": "YSTextdomain",
    "container": "YSTextdomain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1519-1524",
    "snippet": "YSTextdomain::YSTextdomain (const string &textdomain, int line)\n    : YStatement (line)\n    , m_domain (Ustring (*SymbolEntry::_nameHash, textdomain))\n{\n    bind ();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bind",
          "args": [],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "bind",
          "container": "YSTextdomain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1569-1576",
          "snippet": "void\nYSTextdomain::bind ()\n{\n#if DO_DEBUG\n    y2debug (\"going to bind a domain %s\", m_domain->c_str() );\n#endif\n    YLocale::ensureBindDomain (m_domain);\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSTextdomain {\n  void\n  YSTextdomain::bind ()\n  {\n  #if DO_DEBUG\n      y2debug (\"going to bind a domain %s\", m_domain->c_str() );\n  #endif\n      YLocale::ensureBindDomain (m_domain);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Ustring",
          "args": [
            "*SymbolEntry::_nameHash",
            "textdomain"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSTextdomain {\n  YSTextdomain::YSTextdomain (const string &textdomain, int line)\n      : YStatement (line)\n      , m_domain (Ustring (*SymbolEntry::_nameHash, textdomain))\n  {\n      bind ();\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSDo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1453-1513",
    "snippet": "YCPValue\nYSDo::evaluate (bool cse)\n{\n    if (cse) return YCPNull();\n\n#if DO_DEBUG\n    y2debug (\"YSDo::evaluate(%s)\\n\", toString().c_str());\n#endif\n\n    bool first_iteration = true;\n\n    for (;;)\n    {\n\tYCPValue lval = YCPNull();\n\tif (m_loop != 0)\n\t{\n\t    if (m_loop->isBlock())\n\t    {\n\t\tlval = ((YBlockPtr)m_loop)->evaluate ();\n\t\tif (first_iteration) first_iteration = false;\n\t    }\n\t    else\n\t    {\n\t\tlval = m_loop->evaluate ();\n\t    }\n\t}\n\tif (lval.isNull()\n\t    || lval->isVoid())\t\t// normal block/statement or 'continue'\n\t{\n\t    YCPValue bval = m_condition->evaluate ();\n\t    if (bval.isNull ())\n\t    {\n\t\tycp2error (\"while condition is nil.\");\n\t\treturn YCPNull ();\n\t    }\n    \n\t    if (!bval->isBoolean())\n\t    {\n\t\tycp2error (\"'do (%s)' evaluates to non-boolean '(%s)'.\", m_condition->toString().c_str(), bval->toString().c_str());\n\t\tbreak;\n\t    }\n\t    else if (bval->asBoolean()->value() == false)\n\t    {\n\t\tbreak;\n\t    }\n\t}\n\telse if (lval->isBreak())\t// executed 'break'\n\t{\n\t    break;\n\t}\n\telse if (lval->isReturn())\t// executed 'return;'\n\t{\n\t    return lval;\n\t}\n\telse\n\t{\n\t    return lval;\t\t// executed 'return <expr>;'\n\t}\n    }\n    return YCPNull ();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lval->isReturn",
          "args": [],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "isReturn",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "74-74",
          "snippet": "bool YCPValueRep::isReturn()\t  const { return valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isReturn()\t  const { return valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lval->isBreak",
          "args": [],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "isBreak",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "73-73",
          "snippet": "bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bval->asBoolean",
          "args": [],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "asBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "94-104",
          "snippet": "YCPBoolean\nYCPValueRep::asBoolean() const\n{\n    if (!isBoolean())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPBoolean\n  YCPValueRep::asBoolean() const\n  {\n      if (!isBoolean())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"'do (%s)' evaluates to non-boolean '(%s)'.\"",
            "m_condition->toString().c_str()",
            "bval->toString().c_str()"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bval->toString",
          "args": [],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bval->isBoolean",
          "args": [],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "isBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "62-62",
          "snippet": "bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"while condition is nil.\""
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bval.isNull",
          "args": [],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_condition->evaluate",
          "args": [],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lval->isVoid",
          "args": [],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lval.isNull",
          "args": [],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_loop->evaluate",
          "args": [],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_loop->isBlock",
          "args": [],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "isBlock",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "73-77",
          "snippet": "bool\nYBreakpoint::isBlock () const\n{\n    return m_code->isBlock();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  bool\n  YBreakpoint::isBlock () const\n  {\n      return m_code->isBlock();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YSDo::evaluate(%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSDo {\n  YCPValue\n  YSDo::evaluate (bool cse)\n  {\n      if (cse) return YCPNull();\n  \n  #if DO_DEBUG\n      y2debug (\"YSDo::evaluate(%s)\\n\", toString().c_str());\n  #endif\n  \n      bool first_iteration = true;\n  \n      for (;;)\n      {\n  \tYCPValue lval = YCPNull();\n  \tif (m_loop != 0)\n  \t{\n  \t    if (m_loop->isBlock())\n  \t    {\n  \t\tlval = ((YBlockPtr)m_loop)->evaluate ();\n  \t\tif (first_iteration) first_iteration = false;\n  \t    }\n  \t    else\n  \t    {\n  \t\tlval = m_loop->evaluate ();\n  \t    }\n  \t}\n  \tif (lval.isNull()\n  \t    || lval->isVoid())\t\t// normal block/statement or 'continue'\n  \t{\n  \t    YCPValue bval = m_condition->evaluate ();\n  \t    if (bval.isNull ())\n  \t    {\n  \t\tycp2error (\"while condition is nil.\");\n  \t\treturn YCPNull ();\n  \t    }\n      \n  \t    if (!bval->isBoolean())\n  \t    {\n  \t\tycp2error (\"'do (%s)' evaluates to non-boolean '(%s)'.\", m_condition->toString().c_str(), bval->toString().c_str());\n  \t\tbreak;\n  \t    }\n  \t    else if (bval->asBoolean()->value() == false)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t}\n  \telse if (lval->isBreak())\t// executed 'break'\n  \t{\n  \t    break;\n  \t}\n  \telse if (lval->isReturn())\t// executed 'return;'\n  \t{\n  \t    return lval;\n  \t}\n  \telse\n  \t{\n  \t    return lval;\t\t// executed 'return <expr>;'\n  \t}\n      }\n      return YCPNull ();\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSDo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1407-1422",
    "snippet": "string\nYSDo::toString () const\n{\n    string s = \"do\\n\";\n    if (m_loop != 0)\n    {\n\ts += m_loop->toString();\n    }\n    else\n    {\n\ts += \"{ /* EMPTY */ }\";\n    }\n\n    s = s + \"while (\" + m_condition->toString() + \");\";\n    return s;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_condition->toString",
          "args": [],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSDo {\n  string\n  YSDo::toString () const\n  {\n      string s = \"do\\n\";\n      if (m_loop != 0)\n      {\n  \ts += m_loop->toString();\n      }\n      else\n      {\n  \ts += \"{ /* EMPTY */ }\";\n      }\n  \n      s = s + \"while (\" + m_condition->toString() + \");\";\n      return s;\n  }\n}"
  },
  {
    "function_name": "~YSDo",
    "container": "YSDo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1402-1404",
    "snippet": "YSDo::~YSDo ()\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSDo {\n  YSDo::~YSDo ()\n  {\n  }\n}"
  },
  {
    "function_name": "YSDo",
    "container": "YSDo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1390-1399",
    "snippet": "YSDo::YSDo (bytecodeistream & str)\n    : YStatement (str)\n    , m_loop (0)\n{\n    if (Bytecode::readBool (str))\n    {\n\tm_loop = Bytecode::readCode (str);\n    }\n    m_condition = Bytecode::readCode (str);\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readBool",
          "args": [
            "str"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "readBool",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "158-172",
          "snippet": "bool\nBytecode::readBool (bytecodeistream & str)\n{\n    char c;\n    str.get (c);\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n#endif\n\n    if (c != 0)\n    {\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readBool (bytecodeistream & str)\n  {\n      char c;\n      str.get (c);\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n  #endif\n  \n      if (c != 0)\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSDo {\n  YSDo::YSDo (bytecodeistream & str)\n      : YStatement (str)\n      , m_loop (0)\n  {\n      if (Bytecode::readBool (str))\n      {\n  \tm_loop = Bytecode::readCode (str);\n      }\n      m_condition = Bytecode::readCode (str);\n  }\n}"
  },
  {
    "function_name": "YSDo",
    "container": "YSDo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1382-1387",
    "snippet": "YSDo::YSDo (YCodePtr loop, YCodePtr condition, int line)\n    : YStatement (line)\n    , m_loop (loop)\n    , m_condition (condition)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSDo {\n  YSDo::YSDo (YCodePtr loop, YCodePtr condition, int line)\n      : YStatement (line)\n      , m_loop (loop)\n      , m_condition (condition)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSRepeat",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1315-1376",
    "snippet": "YCPValue\nYSRepeat::evaluate (bool cse)\n{\n    if (cse) return YCPNull();\n\n#if DO_DEBUG\n    y2debug (\"YSRepeat::evaluate(%s)\\n\", toString().c_str());\n#endif\n\n    bool first_iteration = true;\n\n    for (;;)\n    {\n\tYCPValue lval = YCPNull();\n\tif (m_loop != 0)\n\t{\n\t    if (m_loop->isBlock())\n\t    {\n\t\tlval = ((YBlockPtr)m_loop)->evaluate ();\n\t\tif (first_iteration) first_iteration = false;\n\t    }\n\t    else\n\t    {\n\t\tlval = m_loop->evaluate ();\n\t    }\n\t}\n\n\tif (lval.isNull()\n\t    || lval->isVoid())\t\t// normal block/statement or 'continue'\n\t{\n\t    YCPValue bval = m_condition->evaluate ();\n\t    if (bval.isNull ())\n\t    {\n\t\tycp2error (\"until condition is nil.\");\n\t\treturn YCPNull ();\n\t    }\n    \n\t    if (!bval->isBoolean())\n\t    {\n\t\tycp2error ( \"'repeat ... until (%s)' evaluates to non-boolean '(%s)'.\", m_condition->toString().c_str(), bval->toString().c_str());\n\t\tbreak;\n\t    }\n\t    else if (bval->asBoolean()->value() == true)\n\t    {\n\t\tbreak;\n\t    }\n\t}\n\telse if (lval->isBreak())\t// executed 'break'\n\t{\n\t    break;\n\t}\n\telse if (lval->isReturn())\t// executed 'return;'\n\t{\n\t    return lval;\n\t}\n\telse\n\t{\n\t    return lval;\t\t// executed 'return <expr>;'\n\t}\n    }\n    return YCPNull ();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lval->isReturn",
          "args": [],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "isReturn",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "74-74",
          "snippet": "bool YCPValueRep::isReturn()\t  const { return valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isReturn()\t  const { return valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lval->isBreak",
          "args": [],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "isBreak",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "73-73",
          "snippet": "bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bval->asBoolean",
          "args": [],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "asBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "94-104",
          "snippet": "YCPBoolean\nYCPValueRep::asBoolean() const\n{\n    if (!isBoolean())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPBoolean\n  YCPValueRep::asBoolean() const\n  {\n      if (!isBoolean())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"'repeat ... until (%s)' evaluates to non-boolean '(%s)'.\"",
            "m_condition->toString().c_str()",
            "bval->toString().c_str()"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bval->toString",
          "args": [],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bval->isBoolean",
          "args": [],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "isBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "62-62",
          "snippet": "bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"until condition is nil.\""
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bval.isNull",
          "args": [],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_condition->evaluate",
          "args": [],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lval->isVoid",
          "args": [],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lval.isNull",
          "args": [],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_loop->evaluate",
          "args": [],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_loop->isBlock",
          "args": [],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "isBlock",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "73-77",
          "snippet": "bool\nYBreakpoint::isBlock () const\n{\n    return m_code->isBlock();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  bool\n  YBreakpoint::isBlock () const\n  {\n      return m_code->isBlock();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YSRepeat::evaluate(%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSRepeat {\n  YCPValue\n  YSRepeat::evaluate (bool cse)\n  {\n      if (cse) return YCPNull();\n  \n  #if DO_DEBUG\n      y2debug (\"YSRepeat::evaluate(%s)\\n\", toString().c_str());\n  #endif\n  \n      bool first_iteration = true;\n  \n      for (;;)\n      {\n  \tYCPValue lval = YCPNull();\n  \tif (m_loop != 0)\n  \t{\n  \t    if (m_loop->isBlock())\n  \t    {\n  \t\tlval = ((YBlockPtr)m_loop)->evaluate ();\n  \t\tif (first_iteration) first_iteration = false;\n  \t    }\n  \t    else\n  \t    {\n  \t\tlval = m_loop->evaluate ();\n  \t    }\n  \t}\n  \n  \tif (lval.isNull()\n  \t    || lval->isVoid())\t\t// normal block/statement or 'continue'\n  \t{\n  \t    YCPValue bval = m_condition->evaluate ();\n  \t    if (bval.isNull ())\n  \t    {\n  \t\tycp2error (\"until condition is nil.\");\n  \t\treturn YCPNull ();\n  \t    }\n      \n  \t    if (!bval->isBoolean())\n  \t    {\n  \t\tycp2error ( \"'repeat ... until (%s)' evaluates to non-boolean '(%s)'.\", m_condition->toString().c_str(), bval->toString().c_str());\n  \t\tbreak;\n  \t    }\n  \t    else if (bval->asBoolean()->value() == true)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t}\n  \telse if (lval->isBreak())\t// executed 'break'\n  \t{\n  \t    break;\n  \t}\n  \telse if (lval->isReturn())\t// executed 'return;'\n  \t{\n  \t    return lval;\n  \t}\n  \telse\n  \t{\n  \t    return lval;\t\t// executed 'return <expr>;'\n  \t}\n      }\n      return YCPNull ();\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSRepeat",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1298-1313",
    "snippet": "string\nYSRepeat::toString () const\n{\n    string s = \"repeat\\n\";\n    if (m_loop != 0)\n    {\n\ts += m_loop->toString();\n    }\n    else\n    {\n\ts += \"{ /* EMPTY */ }\";\n    }\n\n    s = s + \"until (\" + m_condition->toString() + \");\";\n    return s;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_condition->toString",
          "args": [],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSRepeat {\n  string\n  YSRepeat::toString () const\n  {\n      string s = \"repeat\\n\";\n      if (m_loop != 0)\n      {\n  \ts += m_loop->toString();\n      }\n      else\n      {\n  \ts += \"{ /* EMPTY */ }\";\n      }\n  \n      s = s + \"until (\" + m_condition->toString() + \");\";\n      return s;\n  }\n}"
  },
  {
    "function_name": "~YSRepeat",
    "container": "YSRepeat",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1263-1265",
    "snippet": "YSRepeat::~YSRepeat ()\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSRepeat {\n  YSRepeat::~YSRepeat ()\n  {\n  }\n}"
  },
  {
    "function_name": "YSRepeat",
    "container": "YSRepeat",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1251-1260",
    "snippet": "YSRepeat::YSRepeat (bytecodeistream & str)\n    : YStatement (str)\n    , m_loop (0)\n{\n    if (Bytecode::readBool (str))\n    {\n\tm_loop = Bytecode::readCode (str);\n    }\n    m_condition = Bytecode::readCode (str);\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readBool",
          "args": [
            "str"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "readBool",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "158-172",
          "snippet": "bool\nBytecode::readBool (bytecodeistream & str)\n{\n    char c;\n    str.get (c);\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n#endif\n\n    if (c != 0)\n    {\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readBool (bytecodeistream & str)\n  {\n      char c;\n      str.get (c);\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n  #endif\n  \n      if (c != 0)\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSRepeat {\n  YSRepeat::YSRepeat (bytecodeistream & str)\n      : YStatement (str)\n      , m_loop (0)\n  {\n      if (Bytecode::readBool (str))\n      {\n  \tm_loop = Bytecode::readCode (str);\n      }\n      m_condition = Bytecode::readCode (str);\n  }\n}"
  },
  {
    "function_name": "YSRepeat",
    "container": "YSRepeat",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1243-1248",
    "snippet": "YSRepeat::YSRepeat (YCodePtr loop, YCodePtr condition, int line)\n    : YStatement (line)\n    , m_loop (loop)\n    , m_condition (condition)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSRepeat {\n  YSRepeat::YSRepeat (YCodePtr loop, YCodePtr condition, int line)\n      : YStatement (line)\n      , m_loop (loop)\n      , m_condition (condition)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSWhile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1150-1237",
    "snippet": "YCPValue\nYSWhile::evaluate (bool cse)\n{\n    if (cse) return YCPNull();\n\n#if DO_DEBUG\n    y2debug (\"YSWhile::evaluate(%s)\\n\", toString().c_str());\n#endif\n\n    bool first_iteration = true;\n\n    for (;;)\n    {\n\tYCPValue bval = m_condition->evaluate ();\n\tif (bval.isNull ())\n\t{\n\t    ycp2error (\"while condition is nil.\");\n\t    return YCPNull ();\n\t}\n    \n\tif (!bval->isBoolean())\n\t{\n\t    ycp2error (\"'while (%s)' evaluates to non-boolean '(%s)'.\", m_condition->toString().c_str(), bval->toString().c_str());\n\t    break;\n\t}\n\telse if (bval->asBoolean()->value() == false)\n\t{\n\t    break;\n\t}\n\n\tif (m_loop == 0)\n\t{\n\t    continue;\n\t}\n\tYCPValue lval = YCPNull();\n\n\tif (m_loop->isBlock())\n\t{\n\t    lval = ((YBlockPtr)m_loop)->evaluate ();\n\t    if (first_iteration) first_iteration = false;\n\t}\n\telse\n\t{\n\t    lval = m_loop->evaluate ();\n\t}\n\n#if DO_DEBUG\n\ty2debug (\"YSWhile::evaluate lval (%s)\", lval.isNull() ? \"NULL\" : lval->toString().c_str());\n#endif\n\n\tif (lval.isNull())\n\t{\n#if DO_DEBUG\n\t    y2debug (\"isNull\");\n#endif\n\t    continue;\n\t}\n\telse if (lval->isBreak())\t// executed 'break'\n\t{\n#if DO_DEBUG\n\t    y2debug (\"isBreak\");\n#endif\n\t    break;\n\t}\n\telse if (lval->isReturn())\t// executed 'return;' - YCPReturn is also YCPVoid, keep the order of tests!\n\t{\n#if DO_DEBUG\n\t    y2debug (\"isReturn\");\n#endif\n\t    return lval;\n\t}\n\telse if (lval->isVoid())\t// normal block/statement or 'continue'\n\t{\n#if DO_DEBUG\n\t    y2debug (\"isVoid\");\n#endif\n\t    continue;\n\t}\n\telse\n\t{\n#if DO_DEBUG\n\t    y2debug (\"return <expr>;\");\n#endif\n\t    return lval;\t\t// executed 'return <expr>;'\n\t}\n    }\n    return YCPNull ();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"return <expr>;\""
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"isVoid\""
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lval->isVoid",
          "args": [],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"isReturn\""
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lval->isReturn",
          "args": [],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "isReturn",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "74-74",
          "snippet": "bool YCPValueRep::isReturn()\t  const { return valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isReturn()\t  const { return valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"isBreak\""
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lval->isBreak",
          "args": [],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "isBreak",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "73-73",
          "snippet": "bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"isNull\""
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lval.isNull",
          "args": [],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YSWhile::evaluate lval (%s)\"",
            "lval.isNull() ? \"NULL\" : lval->toString().c_str()"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lval->toString",
          "args": [],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lval.isNull",
          "args": [],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_loop->evaluate",
          "args": [],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_loop->isBlock",
          "args": [],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "isBlock",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "73-77",
          "snippet": "bool\nYBreakpoint::isBlock () const\n{\n    return m_code->isBlock();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  bool\n  YBreakpoint::isBlock () const\n  {\n      return m_code->isBlock();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bval->asBoolean",
          "args": [],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "asBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "94-104",
          "snippet": "YCPBoolean\nYCPValueRep::asBoolean() const\n{\n    if (!isBoolean())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPBoolean\n  YCPValueRep::asBoolean() const\n  {\n      if (!isBoolean())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"'while (%s)' evaluates to non-boolean '(%s)'.\"",
            "m_condition->toString().c_str()",
            "bval->toString().c_str()"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bval->isBoolean",
          "args": [],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "isBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "62-62",
          "snippet": "bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"while condition is nil.\""
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bval.isNull",
          "args": [],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_condition->evaluate",
          "args": [],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YSWhile::evaluate(%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSWhile {\n  YCPValue\n  YSWhile::evaluate (bool cse)\n  {\n      if (cse) return YCPNull();\n  \n  #if DO_DEBUG\n      y2debug (\"YSWhile::evaluate(%s)\\n\", toString().c_str());\n  #endif\n  \n      bool first_iteration = true;\n  \n      for (;;)\n      {\n  \tYCPValue bval = m_condition->evaluate ();\n  \tif (bval.isNull ())\n  \t{\n  \t    ycp2error (\"while condition is nil.\");\n  \t    return YCPNull ();\n  \t}\n      \n  \tif (!bval->isBoolean())\n  \t{\n  \t    ycp2error (\"'while (%s)' evaluates to non-boolean '(%s)'.\", m_condition->toString().c_str(), bval->toString().c_str());\n  \t    break;\n  \t}\n  \telse if (bval->asBoolean()->value() == false)\n  \t{\n  \t    break;\n  \t}\n  \n  \tif (m_loop == 0)\n  \t{\n  \t    continue;\n  \t}\n  \tYCPValue lval = YCPNull();\n  \n  \tif (m_loop->isBlock())\n  \t{\n  \t    lval = ((YBlockPtr)m_loop)->evaluate ();\n  \t    if (first_iteration) first_iteration = false;\n  \t}\n  \telse\n  \t{\n  \t    lval = m_loop->evaluate ();\n  \t}\n  \n  #if DO_DEBUG\n  \ty2debug (\"YSWhile::evaluate lval (%s)\", lval.isNull() ? \"NULL\" : lval->toString().c_str());\n  #endif\n  \n  \tif (lval.isNull())\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"isNull\");\n  #endif\n  \t    continue;\n  \t}\n  \telse if (lval->isBreak())\t// executed 'break'\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"isBreak\");\n  #endif\n  \t    break;\n  \t}\n  \telse if (lval->isReturn())\t// executed 'return;' - YCPReturn is also YCPVoid, keep the order of tests!\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"isReturn\");\n  #endif\n  \t    return lval;\n  \t}\n  \telse if (lval->isVoid())\t// normal block/statement or 'continue'\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"isVoid\");\n  #endif\n  \t    continue;\n  \t}\n  \telse\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"return <expr>;\");\n  #endif\n  \t    return lval;\t\t// executed 'return <expr>;'\n  \t}\n      }\n      return YCPNull ();\n  }\n}"
  },
  {
    "function_name": "YSWhile",
    "container": "YSWhile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1110-1119",
    "snippet": "YSWhile::YSWhile (bytecodeistream & str)\n    : YStatement (str)\n    , m_loop (0)\n{\n    m_condition = Bytecode::readCode (str);\n    if (Bytecode::readBool (str))\n    {\n\tm_loop = Bytecode::readCode (str);\n    }\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readBool",
          "args": [
            "str"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "readBool",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "158-172",
          "snippet": "bool\nBytecode::readBool (bytecodeistream & str)\n{\n    char c;\n    str.get (c);\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n#endif\n\n    if (c != 0)\n    {\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readBool (bytecodeistream & str)\n  {\n      char c;\n      str.get (c);\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n  #endif\n  \n      if (c != 0)\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSWhile {\n  YSWhile::YSWhile (bytecodeistream & str)\n      : YStatement (str)\n      , m_loop (0)\n  {\n      m_condition = Bytecode::readCode (str);\n      if (Bytecode::readBool (str))\n      {\n  \tm_loop = Bytecode::readCode (str);\n      }\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSWhile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1094-1107",
    "snippet": "string\nYSWhile::toString () const\n{\n    string s = \"while (\" + m_condition->toString() + \")\\n    \";\n    if (m_loop != 0)\n    {\n\ts += m_loop->toString();\n    }\n    else\n    {\n\ts += \"{ /* EMPTY */ }\";\n    }\n    return s;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_loop->toString",
          "args": [],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSWhile {\n  string\n  YSWhile::toString () const\n  {\n      string s = \"while (\" + m_condition->toString() + \")\\n    \";\n      if (m_loop != 0)\n      {\n  \ts += m_loop->toString();\n      }\n      else\n      {\n  \ts += \"{ /* EMPTY */ }\";\n      }\n      return s;\n  }\n}"
  },
  {
    "function_name": "~YSWhile",
    "container": "YSWhile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1089-1091",
    "snippet": "YSWhile::~YSWhile ()\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSWhile {\n  YSWhile::~YSWhile ()\n  {\n  }\n}"
  },
  {
    "function_name": "YSWhile",
    "container": "YSWhile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1071-1086",
    "snippet": "YSWhile::YSWhile (YCodePtr condition, YCodePtr loop, int line)\n    : YStatement (line)\n    , m_condition (condition)\n    , m_loop (loop)\n{\n    if (loop\n\t&& loop->isBlock())\n    {\n\tYBlockPtr block = loop;\n\tif (block->isStatement())\n\t{\n\t    y2milestone (\"Converting statement-block to YSBlock\");\n\t    loop = new YSBlock (loop, line);\n\t}\n    }\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2milestone",
          "args": [
            "\"Converting statement-block to YSBlock\""
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block->isStatement",
          "args": [],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "isStatement",
          "container": "YStatement",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YStatement.h",
          "lines": "77-77",
          "snippet": "virtual bool isStatement () const { return true; }",
          "includes": [
            "#include \"ycp/ycpless.h\"",
            "#include \"ycp/Import.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ycpless.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YCode.h\"\n#include <string>\n\nYStatement {\n  virtual bool isStatement () const { return true; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "loop->isBlock",
          "args": [],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "isBlock",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "73-77",
          "snippet": "bool\nYBreakpoint::isBlock () const\n{\n    return m_code->isBlock();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  bool\n  YBreakpoint::isBlock () const\n  {\n      return m_code->isBlock();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSWhile {\n  YSWhile::YSWhile (YCodePtr condition, YCodePtr loop, int line)\n      : YStatement (line)\n      , m_condition (condition)\n      , m_loop (loop)\n  {\n      if (loop\n  \t&& loop->isBlock())\n      {\n  \tYBlockPtr block = loop;\n  \tif (block->isStatement())\n  \t{\n  \t    y2milestone (\"Converting statement-block to YSBlock\");\n  \t    loop = new YSBlock (loop, line);\n  \t}\n      }\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSIf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "1034-1065",
    "snippet": "YCPValue\nYSIf::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug (\"YSIf::evaluate(%s)\\n\", toString().c_str());\n#endif\n    YCPValue bval = m_condition->evaluate (cse);\n    \n    if (bval.isNull ())\n    {\n\tycp2error (\"if condition is nil.\");\n\treturn YCPNull ();\n    }\n    \n    if (!bval->isBoolean())\n    {\n\tycp2warning (ee.filename().c_str(), ee.linenumber(), \"'if (%s)' evaluates to non-boolean '%s' (%s), using 'false' instead.\", m_condition->toString().c_str(), bval->toString().c_str(), bval->valuetype_str());\n\tbval\t= YCPBoolean (false);\n    }\n    if (bval->asBoolean()->value() == true)\n    {\n\tif (m_true != 0)\n\t{\n\t    return m_true->evaluate (cse);\n\t}\n    }\n    else if (m_false != 0)\n    {\n\treturn m_false->evaluate (cse);\n    }\n    return YCPNull ();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "extern ExecutionEnvironment ee;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_false->evaluate",
          "args": [
            "cse"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1958-2008",
          "snippet": "YCPValue\nYSSwitch::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug( \"YSSwitch\");\n#endif\n    if (cse)\n\treturn YCPNull ();\n\t\n    YCPValue condition = m_condition->evaluate ();\n    if (condition.isNull ())\n    {\n\tycperror (\"switch condition evaluates to 'nil'\");\n\treturn YCPNull ();\n    }\n    \n    // if there is a case for this value, execute\n    if (m_cases.find (condition) != m_cases.end ())\n    {\n#if DO_DEBUG\n\ty2debug (\"Evaluating from statement '%d'\",m_cases[condition]);\n#endif\n\tYCPValue res = m_block->evaluateFrom (m_cases[condition]);\n\n\t// break should not be propagated\n\tif (!res.isNull () && res->isBreak ())\n\t    res = YCPNull ();\n\t    \n\treturn res;\n    }\n    // no case, try default if defined\n    else if (m_defaultcase != -1)\n    {\n#if DO_DEBUG\n\ty2debug (\"Evaluating from default statement '%d'\",m_defaultcase);\n#endif\n\tYCPValue res = m_block->evaluateFrom (m_defaultcase);\n\n\t// break should not be propagated\n\tif (!res.isNull () && res->isBreak ())\n\t    res = YCPNull ();\n\t    \n\treturn res;\n    }\n\n#if DO_DEBUG\n    y2debug (\"Switch done\");\n#endif\n\n    return YCPNull ();\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSSwitch {\n  YCPValue\n  YSSwitch::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug( \"YSSwitch\");\n  #endif\n      if (cse)\n  \treturn YCPNull ();\n  \t\n      YCPValue condition = m_condition->evaluate ();\n      if (condition.isNull ())\n      {\n  \tycperror (\"switch condition evaluates to 'nil'\");\n  \treturn YCPNull ();\n      }\n      \n      // if there is a case for this value, execute\n      if (m_cases.find (condition) != m_cases.end ())\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Evaluating from statement '%d'\",m_cases[condition]);\n  #endif\n  \tYCPValue res = m_block->evaluateFrom (m_cases[condition]);\n  \n  \t// break should not be propagated\n  \tif (!res.isNull () && res->isBreak ())\n  \t    res = YCPNull ();\n  \t    \n  \treturn res;\n      }\n      // no case, try default if defined\n      else if (m_defaultcase != -1)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Evaluating from default statement '%d'\",m_defaultcase);\n  #endif\n  \tYCPValue res = m_block->evaluateFrom (m_defaultcase);\n  \n  \t// break should not be propagated\n  \tif (!res.isNull () && res->isBreak ())\n  \t    res = YCPNull ();\n  \t    \n  \treturn res;\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"Switch done\");\n  #endif\n  \n      return YCPNull ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bval->asBoolean",
          "args": [],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "asBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "94-104",
          "snippet": "YCPBoolean\nYCPValueRep::asBoolean() const\n{\n    if (!isBoolean())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPBoolean\n  YCPValueRep::asBoolean() const\n  {\n      if (!isBoolean())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "false"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2warning",
          "args": [
            "ee.filename().c_str()",
            "ee.linenumber()",
            "\"'if (%s)' evaluates to non-boolean '%s' (%s), using 'false' instead.\"",
            "m_condition->toString().c_str()",
            "bval->toString().c_str()",
            "bval->valuetype_str()"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bval->valuetype_str",
          "args": [],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bval->toString",
          "args": [],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.linenumber",
          "args": [],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "linenumber",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "41-45",
          "snippet": "int\nExecutionEnvironment::linenumber () const\n{\n    return m_linenumber;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  int\n  ExecutionEnvironment::linenumber () const\n  {\n      return m_linenumber;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.filename",
          "args": [],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "filename",
          "container": "YSInclude",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YStatement.h",
          "lines": "456-456",
          "snippet": "string filename () const { return m_filename; }",
          "includes": [
            "#include \"ycp/ycpless.h\"",
            "#include \"ycp/Import.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ycpless.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YCode.h\"\n#include <string>\n\nYSInclude {\n  string filename () const { return m_filename; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bval->isBoolean",
          "args": [],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "isBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "62-62",
          "snippet": "bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"if condition is nil.\""
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bval.isNull",
          "args": [],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YSIf::evaluate(%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nextern ExecutionEnvironment ee;\n\nYSIf {\n  YCPValue\n  YSIf::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug (\"YSIf::evaluate(%s)\\n\", toString().c_str());\n  #endif\n      YCPValue bval = m_condition->evaluate (cse);\n      \n      if (bval.isNull ())\n      {\n  \tycp2error (\"if condition is nil.\");\n  \treturn YCPNull ();\n      }\n      \n      if (!bval->isBoolean())\n      {\n  \tycp2warning (ee.filename().c_str(), ee.linenumber(), \"'if (%s)' evaluates to non-boolean '%s' (%s), using 'false' instead.\", m_condition->toString().c_str(), bval->toString().c_str(), bval->valuetype_str());\n  \tbval\t= YCPBoolean (false);\n      }\n      if (bval->asBoolean()->value() == true)\n      {\n  \tif (m_true != 0)\n  \t{\n  \t    return m_true->evaluate (cse);\n  \t}\n      }\n      else if (m_false != 0)\n      {\n  \treturn m_false->evaluate (cse);\n      }\n      return YCPNull ();\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSIf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "959-977",
    "snippet": "string\nYSIf::toString () const\n{\n    string s = \"if (\" + m_condition->toString() + \")\\n\";\n    if (m_true != 0)\n    {\n\ts = s + \"    \" + m_true->toString();\n    }\n    else\n    {\n\ts += \"{ /*EMPTY*/ }\";\n    }\n    if (m_false != 0)\n    {\n\ts += \"\\nelse\\n    \";\n\ts += m_false->toString();\n    }\n    return s;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_false->toString",
          "args": [],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSIf {\n  string\n  YSIf::toString () const\n  {\n      string s = \"if (\" + m_condition->toString() + \")\\n\";\n      if (m_true != 0)\n      {\n  \ts = s + \"    \" + m_true->toString();\n      }\n      else\n      {\n  \ts += \"{ /*EMPTY*/ }\";\n      }\n      if (m_false != 0)\n      {\n  \ts += \"\\nelse\\n    \";\n  \ts += m_false->toString();\n      }\n      return s;\n  }\n}"
  },
  {
    "function_name": "~YSIf",
    "container": "YSIf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "954-956",
    "snippet": "YSIf::~YSIf ()\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSIf {\n  YSIf::~YSIf ()\n  {\n  }\n}"
  },
  {
    "function_name": "YSIf",
    "container": "YSIf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "941-951",
    "snippet": "YSIf::YSIf (bytecodeistream & str)\n    : YStatement (str)\n    , m_true (0)\n    , m_false (0)\n{\n    m_condition = Bytecode::readCode (str);\n    if (Bytecode::readBool (str))\n\tm_true = Bytecode::readCode (str);\n    if (Bytecode::readBool (str))\n\tm_false = Bytecode::readCode (str);\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readBool",
          "args": [
            "str"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "readBool",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "158-172",
          "snippet": "bool\nBytecode::readBool (bytecodeistream & str)\n{\n    char c;\n    str.get (c);\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n#endif\n\n    if (c != 0)\n    {\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readBool (bytecodeistream & str)\n  {\n      char c;\n      str.get (c);\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n  #endif\n  \n      if (c != 0)\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSIf {\n  YSIf::YSIf (bytecodeistream & str)\n      : YStatement (str)\n      , m_true (0)\n      , m_false (0)\n  {\n      m_condition = Bytecode::readCode (str);\n      if (Bytecode::readBool (str))\n  \tm_true = Bytecode::readCode (str);\n      if (Bytecode::readBool (str))\n  \tm_false = Bytecode::readCode (str);\n  }\n}"
  },
  {
    "function_name": "YSIf",
    "container": "YSIf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "932-938",
    "snippet": "YSIf::YSIf (YCodePtr a_condition, YCodePtr a_true, YCodePtr a_false, int line)\n    : YStatement (line)\n    , m_condition (a_condition)\n    , m_true (a_true)\n    , m_false (a_false)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSIf {\n  YSIf::YSIf (YCodePtr a_condition, YCodePtr a_true, YCodePtr a_false, int line)\n      : YStatement (line)\n      , m_condition (a_condition)\n      , m_true (a_true)\n      , m_false (a_false)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSBracket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "873-925",
    "snippet": "YCPValue\nYSBracket::evaluate (bool cse)\n{\n    if (cse) return YCPNull();\n\n    // evaluate other arguments _before_ error checking\n\n    // the bracket arguments\n    YCPValue arg_value = m_arg->evaluate ();\n\n    // the rhs of the assignment\n    YCPValue newvalue = m_code->evaluate ();\n\n    // now check the variable\n\n    YCPValue result = m_entry->value(); \n    if (result.isNull())\n    {\n\t// initial assignment\n\ty2internal (\"Initial assignment reached, not working ATM\");\n\tresult = YCPVoid ();\n//FIXME:\tm_entry->setValue (m_entry->code() ? m_entry->code()->evaluate () : YCPNull());\n//FIXME:\tresult = m_entry->value();\n    }\n\n    // bad variable ?\n    if (result.isNull())\n    {\n\tycp2error (\"Assignment not possible: variable %s is not declared\", m_entry->toString ().c_str ());\n\treturn YCPNull ();\n    }\n\n    // bad bracket argument\n    if (arg_value.isNull()\n\t|| !arg_value->isList())\n    {\n\tycp2error (\"Assignment not possible: bracket %s does not evaluate to list\", m_arg->toString ().c_str ());\n\treturn YCPNull ();\n    }\n\n    result = commit (result, 0, arg_value->asList(), newvalue.isNull() ? YCPVoid() : newvalue);\n\n    if (!result.isNull())\n    {\n\tm_entry->setValue (result);\n#if DO_DEBUG\ny2debug (\"%s = %s\", m_entry->name(), result->toString().c_str());\n#endif\n\tresult = YCPNull();\n    }\n\n    return result;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"%s = %s\"",
            "m_entry->name()",
            "result->toString().c_str()"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result->toString",
          "args": [],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_entry->name",
          "args": [],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "YSImport",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1671-1675",
          "snippet": "string\nYSImport::name () const\n{\n    return m_name.asString();\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSImport {\n  string\n  YSImport::name () const\n  {\n      return m_name.asString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_entry->setValue",
          "args": [
            "result"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "IniEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "155-155",
          "snippet": "void setValue(const string&c)   { dirty = true; val = c;     }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniEntry {\n  void setValue(const string&c)   { dirty = true; val = c;     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.isNull",
          "args": [],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit",
          "args": [
            "result",
            "0",
            "arg_value->asList()",
            "newvalue.isNull() ? YCPVoid() : newvalue"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "commit",
          "container": "YSBracket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "761-870",
          "snippet": "YCPValue\nYSBracket::commit (YCPValue current, int idx, YCPList arg, YCPValue value)\n{\n    if (arg.isNull()\n\t|| (idx > arg->size()))\n    {\n\treturn YCPNull();\n    }\n\n    if (idx == arg->size())\n    {\n\treturn value;\n    }\n\n    if (current.isNull ())\n    {\n\tYCPList correct_until;\n\t\n\tfor (int i = 0 ; i < idx ; i++)\n\t{\n\t    correct_until->add (arg->value (i));\n\t}\n\n\tycp2error (\"Intermediate structure with index %s does not exist\", correct_until->toString ().c_str ());\n\treturn YCPNull ();\n    }\n#if DO_DEBUG\t\n    y2debug (\"commit (%s, %d, %s, %s)\", current->toString().c_str(), idx, arg->toString().c_str(), value.isNull () ? \"nil\" : value->toString().c_str());\n#endif\n    YCPValue argval = arg->value (idx);\n    if (argval.isNull())\n    {\n\tycp2error (\"Invalid bracket parameter 'nil'\");\n\treturn YCPNull ();\n    }\n\n    if (current->isList())\n    {\n\tif (!argval->isInteger())\n\t{\n\t    ycp2error (\"Invalid bracket parameter for list, expected integer, seen '%s'\", argval->toString().c_str());\n\t    return YCPNull ();\n\t}\n\n\tYCPList list = current->asList();\n\tint argint = argval->asInteger()->value();\n\t\n\tYCPValue val = value;\n\n\t//  not the end of the argument list, continue\n\tif (idx < arg->size ()-1)\n\t{\n\t    val = commit (list->value (argint), idx+1, arg, value);\t\t// recurse\n\t    if (val.isNull ())\n\t    {\n\t\treturn val;\n\t    }\n\t}\n\t\n\tlist->set (argint, val.isNull() ? YCPVoid() : val);\n#if DO_DEBUG\t\n    y2debug (\"list[%d] = %s -> %s\", argint, val->toString().c_str(), list->toString().c_str());\n#endif\n\treturn list;\n    }\n    else if (current->isMap())\n    {\n\tYCPMap map = current->asMap();\n\t\n\tYCPValue val = value;\n\t\n\tif (idx < arg->size ()-1)\n\t{\n\t    val = commit (map->value (argval), idx+1, arg, value);\t\t// recurse\n\t    if (val.isNull ())\n\t    {\n\t\treturn val;\n\t    }\n\t}\n\tmap = map->functionalAdd (argval, val.isNull() ? YCPVoid() : val);\n#if DO_DEBUG\t\n    y2debug (\"map[%s] = %s -> %s\", argval->toString().c_str(), val->toString().c_str(), map->toString().c_str());\n#endif\n\treturn map;\n    }\n    else if (current->isTerm())\n    {\n\tif (!argval->isInteger())\n\t{\n\t    ycp2error (\"Invalid bracket parameter for term, expected integer, seen '%s'\", argval->toString().c_str());\n\t    return YCPNull ();\n\t}\n\tYCPTerm term = current->asTerm();\n\tint argint = argval->asInteger()->value();\n\t\n\tYCPValue val = value;\n\t\n\t// not the end of the argument list, continue\n\tif (idx < arg->size ()-1)\n\t{\n\t    val = commit (term->value (argint), idx+1, arg, value);\n\t    if (val.isNull ())\n\t\treturn val;\n\t}\n\tterm->set (argval->asInteger()->value(), val.isNull() ? YCPVoid() : val);\n\treturn term;\n    }\n    ycp2error (\"Bracket assignment '%s'['%s'] = '%s', not to list, map, or term\", current->toString().c_str(), argval->toString().c_str(), value->toString().c_str());\n    return YCPNull ();\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSBracket {\n  YCPValue\n  YSBracket::commit (YCPValue current, int idx, YCPList arg, YCPValue value)\n  {\n      if (arg.isNull()\n  \t|| (idx > arg->size()))\n      {\n  \treturn YCPNull();\n      }\n  \n      if (idx == arg->size())\n      {\n  \treturn value;\n      }\n  \n      if (current.isNull ())\n      {\n  \tYCPList correct_until;\n  \t\n  \tfor (int i = 0 ; i < idx ; i++)\n  \t{\n  \t    correct_until->add (arg->value (i));\n  \t}\n  \n  \tycp2error (\"Intermediate structure with index %s does not exist\", correct_until->toString ().c_str ());\n  \treturn YCPNull ();\n      }\n  #if DO_DEBUG\t\n      y2debug (\"commit (%s, %d, %s, %s)\", current->toString().c_str(), idx, arg->toString().c_str(), value.isNull () ? \"nil\" : value->toString().c_str());\n  #endif\n      YCPValue argval = arg->value (idx);\n      if (argval.isNull())\n      {\n  \tycp2error (\"Invalid bracket parameter 'nil'\");\n  \treturn YCPNull ();\n      }\n  \n      if (current->isList())\n      {\n  \tif (!argval->isInteger())\n  \t{\n  \t    ycp2error (\"Invalid bracket parameter for list, expected integer, seen '%s'\", argval->toString().c_str());\n  \t    return YCPNull ();\n  \t}\n  \n  \tYCPList list = current->asList();\n  \tint argint = argval->asInteger()->value();\n  \t\n  \tYCPValue val = value;\n  \n  \t//  not the end of the argument list, continue\n  \tif (idx < arg->size ()-1)\n  \t{\n  \t    val = commit (list->value (argint), idx+1, arg, value);\t\t// recurse\n  \t    if (val.isNull ())\n  \t    {\n  \t\treturn val;\n  \t    }\n  \t}\n  \t\n  \tlist->set (argint, val.isNull() ? YCPVoid() : val);\n  #if DO_DEBUG\t\n      y2debug (\"list[%d] = %s -> %s\", argint, val->toString().c_str(), list->toString().c_str());\n  #endif\n  \treturn list;\n      }\n      else if (current->isMap())\n      {\n  \tYCPMap map = current->asMap();\n  \t\n  \tYCPValue val = value;\n  \t\n  \tif (idx < arg->size ()-1)\n  \t{\n  \t    val = commit (map->value (argval), idx+1, arg, value);\t\t// recurse\n  \t    if (val.isNull ())\n  \t    {\n  \t\treturn val;\n  \t    }\n  \t}\n  \tmap = map->functionalAdd (argval, val.isNull() ? YCPVoid() : val);\n  #if DO_DEBUG\t\n      y2debug (\"map[%s] = %s -> %s\", argval->toString().c_str(), val->toString().c_str(), map->toString().c_str());\n  #endif\n  \treturn map;\n      }\n      else if (current->isTerm())\n      {\n  \tif (!argval->isInteger())\n  \t{\n  \t    ycp2error (\"Invalid bracket parameter for term, expected integer, seen '%s'\", argval->toString().c_str());\n  \t    return YCPNull ();\n  \t}\n  \tYCPTerm term = current->asTerm();\n  \tint argint = argval->asInteger()->value();\n  \t\n  \tYCPValue val = value;\n  \t\n  \t// not the end of the argument list, continue\n  \tif (idx < arg->size ()-1)\n  \t{\n  \t    val = commit (term->value (argint), idx+1, arg, value);\n  \t    if (val.isNull ())\n  \t\treturn val;\n  \t}\n  \tterm->set (argval->asInteger()->value(), val.isNull() ? YCPVoid() : val);\n  \treturn term;\n      }\n      ycp2error (\"Bracket assignment '%s'['%s'] = '%s', not to list, map, or term\", current->toString().c_str(), argval->toString().c_str(), value->toString().c_str());\n      return YCPNull ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "newvalue.isNull",
          "args": [],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg_value->asList",
          "args": [],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Assignment not possible: bracket %s does not evaluate to list\"",
            "m_arg->toString ().c_str ()"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg_value->isList",
          "args": [],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg_value.isNull",
          "args": [],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Assignment not possible: variable %s is not declared\"",
            "m_entry->toString ().c_str ()"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.isNull",
          "args": [],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2internal",
          "args": [
            "\"Initial assignment reached, not working ATM\""
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.isNull",
          "args": [],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_entry->value",
          "args": [],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YSReturn",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "356-360",
          "snippet": "YCodePtr \nYSReturn::value() const\n{\n    return m_value;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSReturn {\n  YCodePtr \n  YSReturn::value() const\n  {\n      return m_value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_code->evaluate",
          "args": [],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_arg->evaluate",
          "args": [],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSBracket {\n  YCPValue\n  YSBracket::evaluate (bool cse)\n  {\n      if (cse) return YCPNull();\n  \n      // evaluate other arguments _before_ error checking\n  \n      // the bracket arguments\n      YCPValue arg_value = m_arg->evaluate ();\n  \n      // the rhs of the assignment\n      YCPValue newvalue = m_code->evaluate ();\n  \n      // now check the variable\n  \n      YCPValue result = m_entry->value(); \n      if (result.isNull())\n      {\n  \t// initial assignment\n  \ty2internal (\"Initial assignment reached, not working ATM\");\n  \tresult = YCPVoid ();\n  //FIXME:\tm_entry->setValue (m_entry->code() ? m_entry->code()->evaluate () : YCPNull());\n  //FIXME:\tresult = m_entry->value();\n      }\n  \n      // bad variable ?\n      if (result.isNull())\n      {\n  \tycp2error (\"Assignment not possible: variable %s is not declared\", m_entry->toString ().c_str ());\n  \treturn YCPNull ();\n      }\n  \n      // bad bracket argument\n      if (arg_value.isNull()\n  \t|| !arg_value->isList())\n      {\n  \tycp2error (\"Assignment not possible: bracket %s does not evaluate to list\", m_arg->toString ().c_str ());\n  \treturn YCPNull ();\n      }\n  \n      result = commit (result, 0, arg_value->asList(), newvalue.isNull() ? YCPVoid() : newvalue);\n  \n      if (!result.isNull())\n      {\n  \tm_entry->setValue (result);\n  #if DO_DEBUG\n  y2debug (\"%s = %s\", m_entry->name(), result->toString().c_str());\n  #endif\n  \tresult = YCPNull();\n      }\n  \n      return result;\n  }\n}"
  },
  {
    "function_name": "commit",
    "container": "YSBracket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "761-870",
    "snippet": "YCPValue\nYSBracket::commit (YCPValue current, int idx, YCPList arg, YCPValue value)\n{\n    if (arg.isNull()\n\t|| (idx > arg->size()))\n    {\n\treturn YCPNull();\n    }\n\n    if (idx == arg->size())\n    {\n\treturn value;\n    }\n\n    if (current.isNull ())\n    {\n\tYCPList correct_until;\n\t\n\tfor (int i = 0 ; i < idx ; i++)\n\t{\n\t    correct_until->add (arg->value (i));\n\t}\n\n\tycp2error (\"Intermediate structure with index %s does not exist\", correct_until->toString ().c_str ());\n\treturn YCPNull ();\n    }\n#if DO_DEBUG\t\n    y2debug (\"commit (%s, %d, %s, %s)\", current->toString().c_str(), idx, arg->toString().c_str(), value.isNull () ? \"nil\" : value->toString().c_str());\n#endif\n    YCPValue argval = arg->value (idx);\n    if (argval.isNull())\n    {\n\tycp2error (\"Invalid bracket parameter 'nil'\");\n\treturn YCPNull ();\n    }\n\n    if (current->isList())\n    {\n\tif (!argval->isInteger())\n\t{\n\t    ycp2error (\"Invalid bracket parameter for list, expected integer, seen '%s'\", argval->toString().c_str());\n\t    return YCPNull ();\n\t}\n\n\tYCPList list = current->asList();\n\tint argint = argval->asInteger()->value();\n\t\n\tYCPValue val = value;\n\n\t//  not the end of the argument list, continue\n\tif (idx < arg->size ()-1)\n\t{\n\t    val = commit (list->value (argint), idx+1, arg, value);\t\t// recurse\n\t    if (val.isNull ())\n\t    {\n\t\treturn val;\n\t    }\n\t}\n\t\n\tlist->set (argint, val.isNull() ? YCPVoid() : val);\n#if DO_DEBUG\t\n    y2debug (\"list[%d] = %s -> %s\", argint, val->toString().c_str(), list->toString().c_str());\n#endif\n\treturn list;\n    }\n    else if (current->isMap())\n    {\n\tYCPMap map = current->asMap();\n\t\n\tYCPValue val = value;\n\t\n\tif (idx < arg->size ()-1)\n\t{\n\t    val = commit (map->value (argval), idx+1, arg, value);\t\t// recurse\n\t    if (val.isNull ())\n\t    {\n\t\treturn val;\n\t    }\n\t}\n\tmap = map->functionalAdd (argval, val.isNull() ? YCPVoid() : val);\n#if DO_DEBUG\t\n    y2debug (\"map[%s] = %s -> %s\", argval->toString().c_str(), val->toString().c_str(), map->toString().c_str());\n#endif\n\treturn map;\n    }\n    else if (current->isTerm())\n    {\n\tif (!argval->isInteger())\n\t{\n\t    ycp2error (\"Invalid bracket parameter for term, expected integer, seen '%s'\", argval->toString().c_str());\n\t    return YCPNull ();\n\t}\n\tYCPTerm term = current->asTerm();\n\tint argint = argval->asInteger()->value();\n\t\n\tYCPValue val = value;\n\t\n\t// not the end of the argument list, continue\n\tif (idx < arg->size ()-1)\n\t{\n\t    val = commit (term->value (argint), idx+1, arg, value);\n\t    if (val.isNull ())\n\t\treturn val;\n\t}\n\tterm->set (argval->asInteger()->value(), val.isNull() ? YCPVoid() : val);\n\treturn term;\n    }\n    ycp2error (\"Bracket assignment '%s'['%s'] = '%s', not to list, map, or term\", current->toString().c_str(), argval->toString().c_str(), value->toString().c_str());\n    return YCPNull ();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bracket assignment '%s'['%s'] = '%s', not to list, map, or term\"",
            "current->toString().c_str()",
            "argval->toString().c_str()",
            "value->toString().c_str()"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->set",
          "args": [
            "argval->asInteger()->value()",
            "val.isNull() ? YCPVoid() : val"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "133-137",
          "snippet": "void\nYCPTermRep::set (const int n, const YCPValue& value)\n{\n    return l->set (n, value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::set (const int n, const YCPValue& value)\n  {\n      return l->set (n, value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "val.isNull",
          "args": [],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argval->asInteger",
          "args": [],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "asInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "106-116",
          "snippet": "YCPInteger\nYCPValueRep::asInteger() const\n{\n    if (!isInteger())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPInteger\n  YCPValueRep::asInteger() const\n  {\n      if (!isInteger())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "val.isNull",
          "args": [],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit",
          "args": [
            "term->value (argint)",
            "idx+1",
            "arg",
            "value"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "commit",
          "container": "YSBracket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "761-870",
          "snippet": "YCPValue\nYSBracket::commit (YCPValue current, int idx, YCPList arg, YCPValue value)\n{\n    if (arg.isNull()\n\t|| (idx > arg->size()))\n    {\n\treturn YCPNull();\n    }\n\n    if (idx == arg->size())\n    {\n\treturn value;\n    }\n\n    if (current.isNull ())\n    {\n\tYCPList correct_until;\n\t\n\tfor (int i = 0 ; i < idx ; i++)\n\t{\n\t    correct_until->add (arg->value (i));\n\t}\n\n\tycp2error (\"Intermediate structure with index %s does not exist\", correct_until->toString ().c_str ());\n\treturn YCPNull ();\n    }\n#if DO_DEBUG\t\n    y2debug (\"commit (%s, %d, %s, %s)\", current->toString().c_str(), idx, arg->toString().c_str(), value.isNull () ? \"nil\" : value->toString().c_str());\n#endif\n    YCPValue argval = arg->value (idx);\n    if (argval.isNull())\n    {\n\tycp2error (\"Invalid bracket parameter 'nil'\");\n\treturn YCPNull ();\n    }\n\n    if (current->isList())\n    {\n\tif (!argval->isInteger())\n\t{\n\t    ycp2error (\"Invalid bracket parameter for list, expected integer, seen '%s'\", argval->toString().c_str());\n\t    return YCPNull ();\n\t}\n\n\tYCPList list = current->asList();\n\tint argint = argval->asInteger()->value();\n\t\n\tYCPValue val = value;\n\n\t//  not the end of the argument list, continue\n\tif (idx < arg->size ()-1)\n\t{\n\t    val = commit (list->value (argint), idx+1, arg, value);\t\t// recurse\n\t    if (val.isNull ())\n\t    {\n\t\treturn val;\n\t    }\n\t}\n\t\n\tlist->set (argint, val.isNull() ? YCPVoid() : val);\n#if DO_DEBUG\t\n    y2debug (\"list[%d] = %s -> %s\", argint, val->toString().c_str(), list->toString().c_str());\n#endif\n\treturn list;\n    }\n    else if (current->isMap())\n    {\n\tYCPMap map = current->asMap();\n\t\n\tYCPValue val = value;\n\t\n\tif (idx < arg->size ()-1)\n\t{\n\t    val = commit (map->value (argval), idx+1, arg, value);\t\t// recurse\n\t    if (val.isNull ())\n\t    {\n\t\treturn val;\n\t    }\n\t}\n\tmap = map->functionalAdd (argval, val.isNull() ? YCPVoid() : val);\n#if DO_DEBUG\t\n    y2debug (\"map[%s] = %s -> %s\", argval->toString().c_str(), val->toString().c_str(), map->toString().c_str());\n#endif\n\treturn map;\n    }\n    else if (current->isTerm())\n    {\n\tif (!argval->isInteger())\n\t{\n\t    ycp2error (\"Invalid bracket parameter for term, expected integer, seen '%s'\", argval->toString().c_str());\n\t    return YCPNull ();\n\t}\n\tYCPTerm term = current->asTerm();\n\tint argint = argval->asInteger()->value();\n\t\n\tYCPValue val = value;\n\t\n\t// not the end of the argument list, continue\n\tif (idx < arg->size ()-1)\n\t{\n\t    val = commit (term->value (argint), idx+1, arg, value);\n\t    if (val.isNull ())\n\t\treturn val;\n\t}\n\tterm->set (argval->asInteger()->value(), val.isNull() ? YCPVoid() : val);\n\treturn term;\n    }\n    ycp2error (\"Bracket assignment '%s'['%s'] = '%s', not to list, map, or term\", current->toString().c_str(), argval->toString().c_str(), value->toString().c_str());\n    return YCPNull ();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "term->value",
          "args": [
            "argint"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg->size",
          "args": [],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "current->asTerm",
          "args": [],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Invalid bracket parameter for term, expected integer, seen '%s'\"",
            "argval->toString().c_str()"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argval->isInteger",
          "args": [],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "63-63",
          "snippet": "bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "current->isTerm",
          "args": [],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "isTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "70-70",
          "snippet": "bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"map[%s] = %s -> %s\"",
            "argval->toString().c_str()",
            "val->toString().c_str()",
            "map->toString().c_str()"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map->functionalAdd",
          "args": [
            "argval",
            "val.isNull() ? YCPVoid() : val"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "functionalAdd",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "79-101",
          "snippet": "YCPMap\nYCPMapRep::functionalAdd (const YCPValue& key, const YCPValue& value) const\n{\n    y2debug (\"YCPMapRep::functionalAdd ('%s', '%s', '%s')\", key->toString().c_str(), value->toString().c_str(), this->toString().c_str());\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn YCPNull ();\n    }\n\n    YCPMap newmap;\n\n    for (YCPMap::const_iterator pos = begin(); pos != end(); ++pos)\n    {\n\tnewmap->add(pos->first, pos->second);\n    }\n\n    newmap->add( key, value );\n\n    return newmap;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMap\n  YCPMapRep::functionalAdd (const YCPValue& key, const YCPValue& value) const\n  {\n      y2debug (\"YCPMapRep::functionalAdd ('%s', '%s', '%s')\", key->toString().c_str(), value->toString().c_str(), this->toString().c_str());\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn YCPNull ();\n      }\n  \n      YCPMap newmap;\n  \n      for (YCPMap::const_iterator pos = begin(); pos != end(); ++pos)\n      {\n  \tnewmap->add(pos->first, pos->second);\n      }\n  \n      newmap->add( key, value );\n  \n      return newmap;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "val.isNull",
          "args": [],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "val.isNull",
          "args": [],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current->asMap",
          "args": [],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "current->isMap",
          "args": [],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "71-71",
          "snippet": "bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"list[%d] = %s -> %s\"",
            "argint",
            "val->toString().c_str()",
            "list->toString().c_str()"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "val.isNull",
          "args": [],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "val.isNull",
          "args": [],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current->asList",
          "args": [],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Invalid bracket parameter for list, expected integer, seen '%s'\"",
            "argval->toString().c_str()"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current->isList",
          "args": [],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Invalid bracket parameter 'nil'\""
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argval.isNull",
          "args": [],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"commit (%s, %d, %s, %s)\"",
            "current->toString().c_str()",
            "idx",
            "arg->toString().c_str()",
            "value.isNull () ? \"nil\" : value->toString().c_str()"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Intermediate structure with index %s does not exist\"",
            "correct_until->toString ().c_str ()"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "correct_until->add",
          "args": [
            "arg->value (i)"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "current.isNull",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSBracket {\n  YCPValue\n  YSBracket::commit (YCPValue current, int idx, YCPList arg, YCPValue value)\n  {\n      if (arg.isNull()\n  \t|| (idx > arg->size()))\n      {\n  \treturn YCPNull();\n      }\n  \n      if (idx == arg->size())\n      {\n  \treturn value;\n      }\n  \n      if (current.isNull ())\n      {\n  \tYCPList correct_until;\n  \t\n  \tfor (int i = 0 ; i < idx ; i++)\n  \t{\n  \t    correct_until->add (arg->value (i));\n  \t}\n  \n  \tycp2error (\"Intermediate structure with index %s does not exist\", correct_until->toString ().c_str ());\n  \treturn YCPNull ();\n      }\n  #if DO_DEBUG\t\n      y2debug (\"commit (%s, %d, %s, %s)\", current->toString().c_str(), idx, arg->toString().c_str(), value.isNull () ? \"nil\" : value->toString().c_str());\n  #endif\n      YCPValue argval = arg->value (idx);\n      if (argval.isNull())\n      {\n  \tycp2error (\"Invalid bracket parameter 'nil'\");\n  \treturn YCPNull ();\n      }\n  \n      if (current->isList())\n      {\n  \tif (!argval->isInteger())\n  \t{\n  \t    ycp2error (\"Invalid bracket parameter for list, expected integer, seen '%s'\", argval->toString().c_str());\n  \t    return YCPNull ();\n  \t}\n  \n  \tYCPList list = current->asList();\n  \tint argint = argval->asInteger()->value();\n  \t\n  \tYCPValue val = value;\n  \n  \t//  not the end of the argument list, continue\n  \tif (idx < arg->size ()-1)\n  \t{\n  \t    val = commit (list->value (argint), idx+1, arg, value);\t\t// recurse\n  \t    if (val.isNull ())\n  \t    {\n  \t\treturn val;\n  \t    }\n  \t}\n  \t\n  \tlist->set (argint, val.isNull() ? YCPVoid() : val);\n  #if DO_DEBUG\t\n      y2debug (\"list[%d] = %s -> %s\", argint, val->toString().c_str(), list->toString().c_str());\n  #endif\n  \treturn list;\n      }\n      else if (current->isMap())\n      {\n  \tYCPMap map = current->asMap();\n  \t\n  \tYCPValue val = value;\n  \t\n  \tif (idx < arg->size ()-1)\n  \t{\n  \t    val = commit (map->value (argval), idx+1, arg, value);\t\t// recurse\n  \t    if (val.isNull ())\n  \t    {\n  \t\treturn val;\n  \t    }\n  \t}\n  \tmap = map->functionalAdd (argval, val.isNull() ? YCPVoid() : val);\n  #if DO_DEBUG\t\n      y2debug (\"map[%s] = %s -> %s\", argval->toString().c_str(), val->toString().c_str(), map->toString().c_str());\n  #endif\n  \treturn map;\n      }\n      else if (current->isTerm())\n      {\n  \tif (!argval->isInteger())\n  \t{\n  \t    ycp2error (\"Invalid bracket parameter for term, expected integer, seen '%s'\", argval->toString().c_str());\n  \t    return YCPNull ();\n  \t}\n  \tYCPTerm term = current->asTerm();\n  \tint argint = argval->asInteger()->value();\n  \t\n  \tYCPValue val = value;\n  \t\n  \t// not the end of the argument list, continue\n  \tif (idx < arg->size ()-1)\n  \t{\n  \t    val = commit (term->value (argint), idx+1, arg, value);\n  \t    if (val.isNull ())\n  \t\treturn val;\n  \t}\n  \tterm->set (argval->asInteger()->value(), val.isNull() ? YCPVoid() : val);\n  \treturn term;\n      }\n      ycp2error (\"Bracket assignment '%s'['%s'] = '%s', not to list, map, or term\", current->toString().c_str(), argval->toString().c_str(), value->toString().c_str());\n      return YCPNull ();\n  }\n}"
  },
  {
    "function_name": "YSBracket",
    "container": "YSBracket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "726-732",
    "snippet": "YSBracket::YSBracket (bytecodeistream & str)\n    : YStatement (str)\n{\n    m_entry = Bytecode::readEntry (str);\n    m_arg = Bytecode::readCode (str);\n    m_code = Bytecode::readCode (str);\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readEntry",
          "args": [
            "str"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "readEntry",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "762-815",
          "snippet": "SymbolEntryPtr \nBytecode::readEntry (bytecodeistream & str)\n{\n    // read reference to namespaces (namespace_id) symbol table (position)\n    int namespace_id = Bytecode::readInt32 (str);\n    int position = Bytecode::readInt32 (str);\n\n    if (namespace_id == -1)\n    {\n#if DO_DEBUG\n\ty2debug( \"Special entry without namespace\" );\n#endif\n\t// FIXME: this may be wrong\n\treturn 0;\n    }\n\n    // get namespace pointer and SymbolEntry within namespace\n    const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n    if (name_space == 0)\n    {\n\ty2error (\"invalid namespace %d for entry\", namespace_id);\n\treturn 0;\n    }\n\n    SymbolEntryPtr sentry;\n    if (position < 0)\t\t\t\t// it's an Xref !\n    {\n\tSymbolTable *table = name_space->table();\n\tif (table == 0)\n\t{\n\t    ycp2error (\"No table associated to xref namespace\\n\");\n\t    exit (1);\n\t}\n\tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n#if DO_DEBUG\n\ty2debug (\"get reference %d from table %p\", position, table);\n#endif\n\tsentry = table->getXRef(position);\n    }\n    else\n    {\n\tsentry = name_space->symbolEntry (position);\n    }\n\n    if (sentry == 0)\n    {\n\ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n\treturn 0;\n    }\n#if DO_DEBUG\n    y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n#endif\n    return sentry;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  SymbolEntryPtr \n  Bytecode::readEntry (bytecodeistream & str)\n  {\n      // read reference to namespaces (namespace_id) symbol table (position)\n      int namespace_id = Bytecode::readInt32 (str);\n      int position = Bytecode::readInt32 (str);\n  \n      if (namespace_id == -1)\n      {\n  #if DO_DEBUG\n  \ty2debug( \"Special entry without namespace\" );\n  #endif\n  \t// FIXME: this may be wrong\n  \treturn 0;\n      }\n  \n      // get namespace pointer and SymbolEntry within namespace\n      const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n      if (name_space == 0)\n      {\n  \ty2error (\"invalid namespace %d for entry\", namespace_id);\n  \treturn 0;\n      }\n  \n      SymbolEntryPtr sentry;\n      if (position < 0)\t\t\t\t// it's an Xref !\n      {\n  \tSymbolTable *table = name_space->table();\n  \tif (table == 0)\n  \t{\n  \t    ycp2error (\"No table associated to xref namespace\\n\");\n  \t    exit (1);\n  \t}\n  \tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n  #if DO_DEBUG\n  \ty2debug (\"get reference %d from table %p\", position, table);\n  #endif\n  \tsentry = table->getXRef(position);\n      }\n      else\n      {\n  \tsentry = name_space->symbolEntry (position);\n      }\n  \n      if (sentry == 0)\n      {\n  \ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n  \treturn 0;\n      }\n  #if DO_DEBUG\n      y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n  #endif\n      return sentry;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSBracket {\n  YSBracket::YSBracket (bytecodeistream & str)\n      : YStatement (str)\n  {\n      m_entry = Bytecode::readEntry (str);\n      m_arg = Bytecode::readCode (str);\n      m_code = Bytecode::readCode (str);\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSBracket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "715-723",
    "snippet": "string\nYSBracket::toString () const\n{\n    return m_entry->toString (false)\n\t+ m_arg->toString()\n    \t+ \" = \"\n\t+ m_code->toString()\n\t+ \";\";\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_code->toString",
          "args": [],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_entry->toString",
          "args": [
            "false"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "158-232",
          "snippet": "string \nYSymbolEntry::toString (bool with_type) const\n{\n    string s = (with_type && m_global) ? \"global \" : \"\";\n#if DO_DEBUG\n    y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n    y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n#endif\n    switch (m_category)\n    {\n\tcase c_variable:\n\tcase c_reference:\n\tcase c_function:\n#if DO_DEBUG\n\t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n#endif\n\tcase c_builtin:\n\t{\n\t    if (with_type)\n\t    {\n\t\tconstFunctionTypePtr ftype = m_type;\n\t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n\t\tif (m_global\n\t\t    && m_namespace != 0\n\t\t    && !m_namespace->name().empty())\n\t\t{\n\t\t    s += (m_namespace->name() + \"::\");\n\t\t}\n\t\ts += m_name.asString();\n\t\tif ((m_category == c_builtin)\n\t\t    && (m_payload.m_decl != 0))\n\t\t{\n\t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n\t\t}\n\t\telse if ((m_category == c_function)\n\t\t\t && (m_code != 0))\n\t\t{\n\t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n\t\t}\n\t\treturn s;\n\t    }\n\t    else\n\t    {\n\t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n\t\treturn s;\n\t    }\n\t}\n\tbreak;\n\tcase c_typedef:\n\t{\n\t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n\t}\n\tbreak;\n\tcase c_const:\n\t{\n\t    return s + m_type->toString() + \" \" + m_name.asString();\n\t}\n\tbreak;\n\tcase c_namespace:\n\tcase c_self:\n\tcase c_filename:\n\tcase c_predefined:\n\t{\n\t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    return SymbolEntry::toString (with_type);\n\t}\n\tbreak;\n    }\n\n    return \"?SymbolEntry?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\n#define DO_DEBUG 0\n\nYSymbolEntry {\n  string \n  YSymbolEntry::toString (bool with_type) const\n  {\n      string s = (with_type && m_global) ? \"global \" : \"\";\n  #if DO_DEBUG\n      y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n      y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n  #endif\n      switch (m_category)\n      {\n  \tcase c_variable:\n  \tcase c_reference:\n  \tcase c_function:\n  #if DO_DEBUG\n  \t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n  #endif\n  \tcase c_builtin:\n  \t{\n  \t    if (with_type)\n  \t    {\n  \t\tconstFunctionTypePtr ftype = m_type;\n  \t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n  \t\tif (m_global\n  \t\t    && m_namespace != 0\n  \t\t    && !m_namespace->name().empty())\n  \t\t{\n  \t\t    s += (m_namespace->name() + \"::\");\n  \t\t}\n  \t\ts += m_name.asString();\n  \t\tif ((m_category == c_builtin)\n  \t\t    && (m_payload.m_decl != 0))\n  \t\t{\n  \t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n  \t\t}\n  \t\telse if ((m_category == c_function)\n  \t\t\t && (m_code != 0))\n  \t\t{\n  \t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n  \t\t}\n  \t\treturn s;\n  \t    }\n  \t    else\n  \t    {\n  \t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n  \t\treturn s;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase c_typedef:\n  \t{\n  \t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n  \t}\n  \tbreak;\n  \tcase c_const:\n  \t{\n  \t    return s + m_type->toString() + \" \" + m_name.asString();\n  \t}\n  \tbreak;\n  \tcase c_namespace:\n  \tcase c_self:\n  \tcase c_filename:\n  \tcase c_predefined:\n  \t{\n  \t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    return SymbolEntry::toString (with_type);\n  \t}\n  \tbreak;\n      }\n  \n      return \"?SymbolEntry?\";\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSBracket {\n  string\n  YSBracket::toString () const\n  {\n      return m_entry->toString (false)\n  \t+ m_arg->toString()\n      \t+ \" = \"\n  \t+ m_code->toString()\n  \t+ \";\";\n  }\n}"
  },
  {
    "function_name": "~YSBracket",
    "container": "YSBracket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "709-712",
    "snippet": "YSBracket::~YSBracket ()\n{\n    // don't delete m_entry here, it belongs to SymbolTable\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSBracket {\n  YSBracket::~YSBracket ()\n  {\n      // don't delete m_entry here, it belongs to SymbolTable\n  }\n}"
  },
  {
    "function_name": "YSBracket",
    "container": "YSBracket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "700-706",
    "snippet": "YSBracket::YSBracket (SymbolEntryPtr entry, YCodePtr arg, YCodePtr code, int line)\n    : YStatement (line)\n    , m_entry (entry)\n    , m_arg (arg)\n    , m_code (code)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSBracket {\n  YSBracket::YSBracket (SymbolEntryPtr entry, YCodePtr arg, YCodePtr code, int line)\n      : YStatement (line)\n      , m_entry (entry)\n      , m_arg (arg)\n      , m_code (code)\n  {\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSVariable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "685-693",
    "snippet": "string\nYSVariable::toString () const\n{\n    return ( (m_entry->nameSpace() == 0) ? \"global \" : \"\")\n\t+ m_entry->toString (true /*definition*/)\n    \t+ \" = \"\n\t+ m_code->toString()\n\t+ \";\";\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_code->toString",
          "args": [],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_entry->toString",
          "args": [
            "true/*definition*/"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "158-232",
          "snippet": "string \nYSymbolEntry::toString (bool with_type) const\n{\n    string s = (with_type && m_global) ? \"global \" : \"\";\n#if DO_DEBUG\n    y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n    y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n#endif\n    switch (m_category)\n    {\n\tcase c_variable:\n\tcase c_reference:\n\tcase c_function:\n#if DO_DEBUG\n\t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n#endif\n\tcase c_builtin:\n\t{\n\t    if (with_type)\n\t    {\n\t\tconstFunctionTypePtr ftype = m_type;\n\t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n\t\tif (m_global\n\t\t    && m_namespace != 0\n\t\t    && !m_namespace->name().empty())\n\t\t{\n\t\t    s += (m_namespace->name() + \"::\");\n\t\t}\n\t\ts += m_name.asString();\n\t\tif ((m_category == c_builtin)\n\t\t    && (m_payload.m_decl != 0))\n\t\t{\n\t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n\t\t}\n\t\telse if ((m_category == c_function)\n\t\t\t && (m_code != 0))\n\t\t{\n\t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n\t\t}\n\t\treturn s;\n\t    }\n\t    else\n\t    {\n\t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n\t\treturn s;\n\t    }\n\t}\n\tbreak;\n\tcase c_typedef:\n\t{\n\t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n\t}\n\tbreak;\n\tcase c_const:\n\t{\n\t    return s + m_type->toString() + \" \" + m_name.asString();\n\t}\n\tbreak;\n\tcase c_namespace:\n\tcase c_self:\n\tcase c_filename:\n\tcase c_predefined:\n\t{\n\t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    return SymbolEntry::toString (with_type);\n\t}\n\tbreak;\n    }\n\n    return \"?SymbolEntry?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\n#define DO_DEBUG 0\n\nYSymbolEntry {\n  string \n  YSymbolEntry::toString (bool with_type) const\n  {\n      string s = (with_type && m_global) ? \"global \" : \"\";\n  #if DO_DEBUG\n      y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n      y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n  #endif\n      switch (m_category)\n      {\n  \tcase c_variable:\n  \tcase c_reference:\n  \tcase c_function:\n  #if DO_DEBUG\n  \t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n  #endif\n  \tcase c_builtin:\n  \t{\n  \t    if (with_type)\n  \t    {\n  \t\tconstFunctionTypePtr ftype = m_type;\n  \t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n  \t\tif (m_global\n  \t\t    && m_namespace != 0\n  \t\t    && !m_namespace->name().empty())\n  \t\t{\n  \t\t    s += (m_namespace->name() + \"::\");\n  \t\t}\n  \t\ts += m_name.asString();\n  \t\tif ((m_category == c_builtin)\n  \t\t    && (m_payload.m_decl != 0))\n  \t\t{\n  \t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n  \t\t}\n  \t\telse if ((m_category == c_function)\n  \t\t\t && (m_code != 0))\n  \t\t{\n  \t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n  \t\t}\n  \t\treturn s;\n  \t    }\n  \t    else\n  \t    {\n  \t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n  \t\treturn s;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase c_typedef:\n  \t{\n  \t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n  \t}\n  \tbreak;\n  \tcase c_const:\n  \t{\n  \t    return s + m_type->toString() + \" \" + m_name.asString();\n  \t}\n  \tbreak;\n  \tcase c_namespace:\n  \tcase c_self:\n  \tcase c_filename:\n  \tcase c_predefined:\n  \t{\n  \t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    return SymbolEntry::toString (with_type);\n  \t}\n  \tbreak;\n      }\n  \n      return \"?SymbolEntry?\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_entry->nameSpace",
          "args": [],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSVariable {\n  string\n  YSVariable::toString () const\n  {\n      return ( (m_entry->nameSpace() == 0) ? \"global \" : \"\")\n  \t+ m_entry->toString (true /*definition*/)\n      \t+ \" = \"\n  \t+ m_code->toString()\n  \t+ \";\";\n  }\n}"
  },
  {
    "function_name": "~YSVariable",
    "container": "YSVariable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "680-682",
    "snippet": "YSVariable::~YSVariable ()\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSVariable {\n  YSVariable::~YSVariable ()\n  {\n  }\n}"
  },
  {
    "function_name": "YSVariable",
    "container": "YSVariable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "672-677",
    "snippet": "YSVariable::YSVariable (bytecodeistream & str)\n    : YSAssign (str)\n{\n    // setup default value\n    ((YSymbolEntryPtr)m_entry)->setCode (m_code);\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "m_code"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSVariable {\n  YSVariable::YSVariable (bytecodeistream & str)\n      : YSAssign (str)\n  {\n      // setup default value\n      ((YSymbolEntryPtr)m_entry)->setCode (m_code);\n  }\n}"
  },
  {
    "function_name": "YSVariable",
    "container": "YSVariable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "666-669",
    "snippet": "YSVariable::YSVariable (SymbolEntryPtr entry, YCodePtr code, int line)\n    : YSAssign (entry, code, line)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSVariable {\n  YSVariable::YSVariable (SymbolEntryPtr entry, YCodePtr code, int line)\n      : YSAssign (entry, code, line)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSAssign",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "646-660",
    "snippet": "YCPValue\nYSAssign::evaluate (bool cse)\n{\n    if (cse) return YCPNull();\n#if DO_DEBUG\n    y2debug (\"YSAssign::evaluate(%s)\\n\", toString().c_str());\n#endif\n    YCPValue value = m_code->evaluate ();\n    m_entry->setValue (value.isNull() ? YCPVoid() : value);\n#if DO_DEBUG\n    y2debug (\"YSAssign::evaluate (%s) = '%s'\\n\", m_code->toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n\n    return YCPNull();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YSAssign::evaluate (%s) = '%s'\\n\"",
            "m_code->toString().c_str()",
            "value.isNull() ? \"NULL\" : value->toString().c_str()"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_entry->setValue",
          "args": [
            "value.isNull() ? YCPVoid() : value"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "IniEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "155-155",
          "snippet": "void setValue(const string&c)   { dirty = true; val = c;     }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniEntry {\n  void setValue(const string&c)   { dirty = true; val = c;     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_code->evaluate",
          "args": [],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YSAssign::evaluate(%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSAssign {\n  YCPValue\n  YSAssign::evaluate (bool cse)\n  {\n      if (cse) return YCPNull();\n  #if DO_DEBUG\n      y2debug (\"YSAssign::evaluate(%s)\\n\", toString().c_str());\n  #endif\n      YCPValue value = m_code->evaluate ();\n      m_entry->setValue (value.isNull() ? YCPVoid() : value);\n  #if DO_DEBUG\n      y2debug (\"YSAssign::evaluate (%s) = '%s'\\n\", m_code->toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n  \n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSAssign",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "618-625",
    "snippet": "string\nYSAssign::toString () const\n{\n    return m_entry->toString (false /*definition*/)\n    \t+ \" = \"\n\t+ m_code->toString()\n\t+ \";\";\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_code->toString",
          "args": [],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_entry->toString",
          "args": [
            "false/*definition*/"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "158-232",
          "snippet": "string \nYSymbolEntry::toString (bool with_type) const\n{\n    string s = (with_type && m_global) ? \"global \" : \"\";\n#if DO_DEBUG\n    y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n    y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n#endif\n    switch (m_category)\n    {\n\tcase c_variable:\n\tcase c_reference:\n\tcase c_function:\n#if DO_DEBUG\n\t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n#endif\n\tcase c_builtin:\n\t{\n\t    if (with_type)\n\t    {\n\t\tconstFunctionTypePtr ftype = m_type;\n\t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n\t\tif (m_global\n\t\t    && m_namespace != 0\n\t\t    && !m_namespace->name().empty())\n\t\t{\n\t\t    s += (m_namespace->name() + \"::\");\n\t\t}\n\t\ts += m_name.asString();\n\t\tif ((m_category == c_builtin)\n\t\t    && (m_payload.m_decl != 0))\n\t\t{\n\t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n\t\t}\n\t\telse if ((m_category == c_function)\n\t\t\t && (m_code != 0))\n\t\t{\n\t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n\t\t}\n\t\treturn s;\n\t    }\n\t    else\n\t    {\n\t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n\t\treturn s;\n\t    }\n\t}\n\tbreak;\n\tcase c_typedef:\n\t{\n\t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n\t}\n\tbreak;\n\tcase c_const:\n\t{\n\t    return s + m_type->toString() + \" \" + m_name.asString();\n\t}\n\tbreak;\n\tcase c_namespace:\n\tcase c_self:\n\tcase c_filename:\n\tcase c_predefined:\n\t{\n\t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    return SymbolEntry::toString (with_type);\n\t}\n\tbreak;\n    }\n\n    return \"?SymbolEntry?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\n#define DO_DEBUG 0\n\nYSymbolEntry {\n  string \n  YSymbolEntry::toString (bool with_type) const\n  {\n      string s = (with_type && m_global) ? \"global \" : \"\";\n  #if DO_DEBUG\n      y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n      y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n  #endif\n      switch (m_category)\n      {\n  \tcase c_variable:\n  \tcase c_reference:\n  \tcase c_function:\n  #if DO_DEBUG\n  \t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n  #endif\n  \tcase c_builtin:\n  \t{\n  \t    if (with_type)\n  \t    {\n  \t\tconstFunctionTypePtr ftype = m_type;\n  \t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n  \t\tif (m_global\n  \t\t    && m_namespace != 0\n  \t\t    && !m_namespace->name().empty())\n  \t\t{\n  \t\t    s += (m_namespace->name() + \"::\");\n  \t\t}\n  \t\ts += m_name.asString();\n  \t\tif ((m_category == c_builtin)\n  \t\t    && (m_payload.m_decl != 0))\n  \t\t{\n  \t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n  \t\t}\n  \t\telse if ((m_category == c_function)\n  \t\t\t && (m_code != 0))\n  \t\t{\n  \t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n  \t\t}\n  \t\treturn s;\n  \t    }\n  \t    else\n  \t    {\n  \t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n  \t\treturn s;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase c_typedef:\n  \t{\n  \t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n  \t}\n  \tbreak;\n  \tcase c_const:\n  \t{\n  \t    return s + m_type->toString() + \" \" + m_name.asString();\n  \t}\n  \tbreak;\n  \tcase c_namespace:\n  \tcase c_self:\n  \tcase c_filename:\n  \tcase c_predefined:\n  \t{\n  \t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    return SymbolEntry::toString (with_type);\n  \t}\n  \tbreak;\n      }\n  \n      return \"?SymbolEntry?\";\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSAssign {\n  string\n  YSAssign::toString () const\n  {\n      return m_entry->toString (false /*definition*/)\n      \t+ \" = \"\n  \t+ m_code->toString()\n  \t+ \";\";\n  }\n}"
  },
  {
    "function_name": "~YSAssign",
    "container": "YSAssign",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "612-615",
    "snippet": "YSAssign::~YSAssign ()\n{\n    // don't delete m_entry here, it belongs to SymbolTable\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSAssign {\n  YSAssign::~YSAssign ()\n  {\n      // don't delete m_entry here, it belongs to SymbolTable\n  }\n}"
  },
  {
    "function_name": "YSAssign",
    "container": "YSAssign",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "604-609",
    "snippet": "YSAssign::YSAssign (bytecodeistream & str)\n    : YStatement (str)\n{\n    m_entry = Bytecode::readEntry (str);\n    m_code = Bytecode::readCode (str);\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readEntry",
          "args": [
            "str"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "readEntry",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "762-815",
          "snippet": "SymbolEntryPtr \nBytecode::readEntry (bytecodeistream & str)\n{\n    // read reference to namespaces (namespace_id) symbol table (position)\n    int namespace_id = Bytecode::readInt32 (str);\n    int position = Bytecode::readInt32 (str);\n\n    if (namespace_id == -1)\n    {\n#if DO_DEBUG\n\ty2debug( \"Special entry without namespace\" );\n#endif\n\t// FIXME: this may be wrong\n\treturn 0;\n    }\n\n    // get namespace pointer and SymbolEntry within namespace\n    const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n    if (name_space == 0)\n    {\n\ty2error (\"invalid namespace %d for entry\", namespace_id);\n\treturn 0;\n    }\n\n    SymbolEntryPtr sentry;\n    if (position < 0)\t\t\t\t// it's an Xref !\n    {\n\tSymbolTable *table = name_space->table();\n\tif (table == 0)\n\t{\n\t    ycp2error (\"No table associated to xref namespace\\n\");\n\t    exit (1);\n\t}\n\tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n#if DO_DEBUG\n\ty2debug (\"get reference %d from table %p\", position, table);\n#endif\n\tsentry = table->getXRef(position);\n    }\n    else\n    {\n\tsentry = name_space->symbolEntry (position);\n    }\n\n    if (sentry == 0)\n    {\n\ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n\treturn 0;\n    }\n#if DO_DEBUG\n    y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n#endif\n    return sentry;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  SymbolEntryPtr \n  Bytecode::readEntry (bytecodeistream & str)\n  {\n      // read reference to namespaces (namespace_id) symbol table (position)\n      int namespace_id = Bytecode::readInt32 (str);\n      int position = Bytecode::readInt32 (str);\n  \n      if (namespace_id == -1)\n      {\n  #if DO_DEBUG\n  \ty2debug( \"Special entry without namespace\" );\n  #endif\n  \t// FIXME: this may be wrong\n  \treturn 0;\n      }\n  \n      // get namespace pointer and SymbolEntry within namespace\n      const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n      if (name_space == 0)\n      {\n  \ty2error (\"invalid namespace %d for entry\", namespace_id);\n  \treturn 0;\n      }\n  \n      SymbolEntryPtr sentry;\n      if (position < 0)\t\t\t\t// it's an Xref !\n      {\n  \tSymbolTable *table = name_space->table();\n  \tif (table == 0)\n  \t{\n  \t    ycp2error (\"No table associated to xref namespace\\n\");\n  \t    exit (1);\n  \t}\n  \tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n  #if DO_DEBUG\n  \ty2debug (\"get reference %d from table %p\", position, table);\n  #endif\n  \tsentry = table->getXRef(position);\n      }\n      else\n      {\n  \tsentry = name_space->symbolEntry (position);\n      }\n  \n      if (sentry == 0)\n      {\n  \ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n  \treturn 0;\n      }\n  #if DO_DEBUG\n      y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n  #endif\n      return sentry;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSAssign {\n  YSAssign::YSAssign (bytecodeistream & str)\n      : YStatement (str)\n  {\n      m_entry = Bytecode::readEntry (str);\n      m_code = Bytecode::readCode (str);\n  }\n}"
  },
  {
    "function_name": "YSAssign",
    "container": "YSAssign",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "596-601",
    "snippet": "YSAssign::YSAssign (SymbolEntryPtr entry, YCodePtr code, int line)\n    : YStatement (line)\n    , m_entry (entry)\n    , m_code (code)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSAssign {\n  YSAssign::YSAssign (SymbolEntryPtr entry, YCodePtr code, int line)\n      : YStatement (line)\n      , m_entry (entry)\n      , m_code (code)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSTypedef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "584-591",
    "snippet": "YCPValue\nYSTypedef::evaluate (bool /*cse*/)\n{\n#if DO_DEBUG\n    y2debug(\"evaluate(%s) = nil\", toString().c_str());\n#endif\n    return YCPNull();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"evaluate(%s) = nil\"",
            "toString().c_str()"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSTypedef {\n  YCPValue\n  YSTypedef::evaluate (bool /*cse*/)\n  {\n  #if DO_DEBUG\n      y2debug(\"evaluate(%s) = nil\", toString().c_str());\n  #endif\n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSTypedef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "556-561",
    "snippet": "string\nYSTypedef::toString() const\n{\n    string s = string (\"typedef \") + m_type->toString() + \" \" + m_name.asString() + \";\";\n    return s;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_name.asString",
          "args": [],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_type->toString",
          "args": [],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"typedef \""
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSTypedef {\n  string\n  YSTypedef::toString() const\n  {\n      string s = string (\"typedef \") + m_type->toString() + \" \" + m_name.asString() + \";\";\n      return s;\n  }\n}"
  },
  {
    "function_name": "YSTypedef",
    "container": "YSTypedef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "548-553",
    "snippet": "YSTypedef::YSTypedef (bytecodeistream & str)\n    : YStatement (str)\n    , m_name (Bytecode::readUstring (str))\n{\n    m_type = Bytecode::readType (str);\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readType",
          "args": [
            "str"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "readType",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "349-387",
          "snippet": "TypePtr\nBytecode::readType (bytecodeistream & str)\n{\n    int kind = readInt32 (str);\n#if DO_DEBUG\ny2debug (\"Bytecode::readType(%d)\", kind);\n#endif\n    switch ((Type::tkind)kind)\n    {\n\tcase Type::UnspecT:\n\tcase Type::ErrorT:\n\tcase Type::AnyT:\n\tcase Type::BooleanT:\n\tcase Type::ByteblockT:\n\tcase Type::FloatT:\n\tcase Type::IntegerT:\n\tcase Type::LocaleT:\n\tcase Type::PathT:\n\tcase Type::StringT:\n\tcase Type::SymbolT:\n\tcase Type::TermT:\n\tcase Type::VoidT:\n\tcase Type::WildcardT:\n\tcase Type::FlexT:\n\tcase Type::NilT:\n\t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n\tbreak;\n\n\tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n\tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n\tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n\tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n\tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n\tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n\tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n    }\n    y2error (\"Unhandled type kind %d\", kind);\n    return Type::Error->clone();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  TypePtr\n  Bytecode::readType (bytecodeistream & str)\n  {\n      int kind = readInt32 (str);\n  #if DO_DEBUG\n  y2debug (\"Bytecode::readType(%d)\", kind);\n  #endif\n      switch ((Type::tkind)kind)\n      {\n  \tcase Type::UnspecT:\n  \tcase Type::ErrorT:\n  \tcase Type::AnyT:\n  \tcase Type::BooleanT:\n  \tcase Type::ByteblockT:\n  \tcase Type::FloatT:\n  \tcase Type::IntegerT:\n  \tcase Type::LocaleT:\n  \tcase Type::PathT:\n  \tcase Type::StringT:\n  \tcase Type::SymbolT:\n  \tcase Type::TermT:\n  \tcase Type::VoidT:\n  \tcase Type::WildcardT:\n  \tcase Type::FlexT:\n  \tcase Type::NilT:\n  \t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n  \tbreak;\n  \n  \tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n  \tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n  \tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n  \tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n  \tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n  \tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n  \tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n      }\n      y2error (\"Unhandled type kind %d\", kind);\n      return Type::Error->clone();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readUstring",
          "args": [
            "str"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "readUstring",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "263-279",
          "snippet": "Ustring\nBytecode::readUstring (bytecodeistream & streamref)\n{\n    u_int32_t len = readInt32 (streamref);\n    Ustring ret = Ustring (*SymbolEntry::_nameHash, \"\");\n    if (len > 0)\n    {\n\tchar *buf = new char [len+1];\n\tif (streamref.read (buf, len))\n\t{\n\t    buf[len] = 0;\n\t    ret = Ustring (*SymbolEntry::_nameHash, buf);\n\t}\n\tdelete [] buf;\n    }\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  Ustring\n  Bytecode::readUstring (bytecodeistream & streamref)\n  {\n      u_int32_t len = readInt32 (streamref);\n      Ustring ret = Ustring (*SymbolEntry::_nameHash, \"\");\n      if (len > 0)\n      {\n  \tchar *buf = new char [len+1];\n  \tif (streamref.read (buf, len))\n  \t{\n  \t    buf[len] = 0;\n  \t    ret = Ustring (*SymbolEntry::_nameHash, buf);\n  \t}\n  \tdelete [] buf;\n      }\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSTypedef {\n  YSTypedef::YSTypedef (bytecodeistream & str)\n      : YStatement (str)\n      , m_name (Bytecode::readUstring (str))\n  {\n      m_type = Bytecode::readType (str);\n  }\n}"
  },
  {
    "function_name": "YSTypedef",
    "container": "YSTypedef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "540-545",
    "snippet": "YSTypedef::YSTypedef (const string &name, constTypePtr type, int line)\n    : YStatement (line)\n    , m_name (Ustring (*SymbolEntry::_nameHash, name))\n    , m_type (type)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Ustring",
          "args": [
            "*SymbolEntry::_nameHash",
            "name"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSTypedef {\n  YSTypedef::YSTypedef (const string &name, constTypePtr type, int line)\n      : YStatement (line)\n      , m_name (Ustring (*SymbolEntry::_nameHash, name))\n      , m_type (type)\n  {\n  }\n}"
  },
  {
    "function_name": "YSFunction",
    "container": "YSFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "500-509",
    "snippet": "YSFunction::YSFunction (bytecodeistream & str)\n    : YStatement (str)\n    , m_entry (Bytecode::readEntry (str))\n{\n    if (!m_entry->isGlobal())\n    {\n\tm_entry->setCode (Bytecode::readCode (str));\n    }\n    function()->setDefinition (str);\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "function",
          "args": [
            "str"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "functionalAdd",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "85-89",
          "snippet": "YCPTerm\nYCPTermRep::functionalAdd (const YCPValue& val) const\n{\n   return YCPTerm (s.asString(), l->functionalAdd(val));\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPTerm\n  YCPTermRep::functionalAdd (const YCPValue& val) const\n  {\n     return YCPTerm (s.asString(), l->functionalAdd(val));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "function",
          "args": [],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "function",
          "container": "YSFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "474-478",
          "snippet": "YFunctionPtr\nYSFunction::function() const\n{\n    return (YFunctionPtr)(m_entry->code());\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSFunction {\n  YFunctionPtr\n  YSFunction::function() const\n  {\n      return (YFunctionPtr)(m_entry->code());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_entry->setCode",
          "args": [
            "Bytecode::readCode (str)"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "setCode",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "127-136",
          "snippet": "void\nYSymbolEntry::setCode (YCodePtr code)\n{\n    if (m_category == c_builtin || m_category == c_module)\n    {\n\ty2error (\"setDeclaration: Wrong category (%s)\", toString().c_str());\n\treturn;\n    }\n    m_code = code;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nYSymbolEntry {\n  void\n  YSymbolEntry::setCode (YCodePtr code)\n  {\n      if (m_category == c_builtin || m_category == c_module)\n      {\n  \ty2error (\"setDeclaration: Wrong category (%s)\", toString().c_str());\n  \treturn;\n      }\n      m_code = code;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_entry->isGlobal",
          "args": [],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "isGlobal",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "82-86",
          "snippet": "bool\nSymbolEntry::isGlobal () const\n{\n    return m_global;\n}",
          "includes": [
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  bool\n  SymbolEntry::isGlobal () const\n  {\n      return m_global;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readEntry",
          "args": [
            "str"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "readEntry",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "762-815",
          "snippet": "SymbolEntryPtr \nBytecode::readEntry (bytecodeistream & str)\n{\n    // read reference to namespaces (namespace_id) symbol table (position)\n    int namespace_id = Bytecode::readInt32 (str);\n    int position = Bytecode::readInt32 (str);\n\n    if (namespace_id == -1)\n    {\n#if DO_DEBUG\n\ty2debug( \"Special entry without namespace\" );\n#endif\n\t// FIXME: this may be wrong\n\treturn 0;\n    }\n\n    // get namespace pointer and SymbolEntry within namespace\n    const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n    if (name_space == 0)\n    {\n\ty2error (\"invalid namespace %d for entry\", namespace_id);\n\treturn 0;\n    }\n\n    SymbolEntryPtr sentry;\n    if (position < 0)\t\t\t\t// it's an Xref !\n    {\n\tSymbolTable *table = name_space->table();\n\tif (table == 0)\n\t{\n\t    ycp2error (\"No table associated to xref namespace\\n\");\n\t    exit (1);\n\t}\n\tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n#if DO_DEBUG\n\ty2debug (\"get reference %d from table %p\", position, table);\n#endif\n\tsentry = table->getXRef(position);\n    }\n    else\n    {\n\tsentry = name_space->symbolEntry (position);\n    }\n\n    if (sentry == 0)\n    {\n\ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n\treturn 0;\n    }\n#if DO_DEBUG\n    y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n#endif\n    return sentry;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  SymbolEntryPtr \n  Bytecode::readEntry (bytecodeistream & str)\n  {\n      // read reference to namespaces (namespace_id) symbol table (position)\n      int namespace_id = Bytecode::readInt32 (str);\n      int position = Bytecode::readInt32 (str);\n  \n      if (namespace_id == -1)\n      {\n  #if DO_DEBUG\n  \ty2debug( \"Special entry without namespace\" );\n  #endif\n  \t// FIXME: this may be wrong\n  \treturn 0;\n      }\n  \n      // get namespace pointer and SymbolEntry within namespace\n      const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n      if (name_space == 0)\n      {\n  \ty2error (\"invalid namespace %d for entry\", namespace_id);\n  \treturn 0;\n      }\n  \n      SymbolEntryPtr sentry;\n      if (position < 0)\t\t\t\t// it's an Xref !\n      {\n  \tSymbolTable *table = name_space->table();\n  \tif (table == 0)\n  \t{\n  \t    ycp2error (\"No table associated to xref namespace\\n\");\n  \t    exit (1);\n  \t}\n  \tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n  #if DO_DEBUG\n  \ty2debug (\"get reference %d from table %p\", position, table);\n  #endif\n  \tsentry = table->getXRef(position);\n      }\n      else\n      {\n  \tsentry = name_space->symbolEntry (position);\n      }\n  \n      if (sentry == 0)\n      {\n  \ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n  \treturn 0;\n      }\n  #if DO_DEBUG\n      y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n  #endif\n      return sentry;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSFunction {\n  YSFunction::YSFunction (bytecodeistream & str)\n      : YStatement (str)\n      , m_entry (Bytecode::readEntry (str))\n  {\n      if (!m_entry->isGlobal())\n      {\n  \tm_entry->setCode (Bytecode::readCode (str));\n      }\n      function()->setDefinition (str);\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "488-497",
    "snippet": "YCPValue\nYSFunction::evaluate (bool /*cse*/)\n{\n#if DO_DEBUG\n    y2debug (\"YSFunction::evaluate(%s)\\n\", toString().c_str());\n#endif\n    // there's nothing to evaluate for a function _definition_\n    // its all in the function call.\n    return YCPNull();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YSFunction::evaluate(%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSFunction {\n  YCPValue\n  YSFunction::evaluate (bool /*cse*/)\n  {\n  #if DO_DEBUG\n      y2debug (\"YSFunction::evaluate(%s)\\n\", toString().c_str());\n  #endif\n      // there's nothing to evaluate for a function _definition_\n      // its all in the function call.\n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "481-485",
    "snippet": "string\nYSFunction::toString() const\n{\n    return m_entry->toString() + \"\\n\" + ((YFunctionPtr)(m_entry->code()))->definition()->toString();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "m_entry->code()"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_entry->code",
          "args": [],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "code",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "139-147",
          "snippet": "YCodePtr\nYSymbolEntry::code () const\n{\n    if (m_category == c_builtin || m_category == c_module)\n    {\n\treturn 0;\n    }\n    return m_code;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nYSymbolEntry {\n  YCodePtr\n  YSymbolEntry::code () const\n  {\n      if (m_category == c_builtin || m_category == c_module)\n      {\n  \treturn 0;\n      }\n      return m_code;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_entry->toString",
          "args": [],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSFunction {\n  string\n  YSFunction::toString() const\n  {\n      return m_entry->toString() + \"\\n\" + ((YFunctionPtr)(m_entry->code()))->definition()->toString();\n  }\n}"
  },
  {
    "function_name": "function",
    "container": "YSFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "474-478",
    "snippet": "YFunctionPtr\nYSFunction::function() const\n{\n    return (YFunctionPtr)(m_entry->code());\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "m_entry->code()"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_entry->code",
          "args": [],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "code",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "139-147",
          "snippet": "YCodePtr\nYSymbolEntry::code () const\n{\n    if (m_category == c_builtin || m_category == c_module)\n    {\n\treturn 0;\n    }\n    return m_code;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nYSymbolEntry {\n  YCodePtr\n  YSymbolEntry::code () const\n  {\n      if (m_category == c_builtin || m_category == c_module)\n      {\n  \treturn 0;\n      }\n      return m_code;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSFunction {\n  YFunctionPtr\n  YSFunction::function() const\n  {\n      return (YFunctionPtr)(m_entry->code());\n  }\n}"
  },
  {
    "function_name": "entry",
    "container": "YSFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "467-471",
    "snippet": "SymbolEntryPtr\nYSFunction::entry() const\n{\n    return m_entry;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSFunction {\n  SymbolEntryPtr\n  YSFunction::entry() const\n  {\n      return m_entry;\n  }\n}"
  },
  {
    "function_name": "~YSFunction",
    "container": "YSFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "461-464",
    "snippet": "YSFunction::~YSFunction ()\n{\n    // don't delete m_entry here, it belongs to SymbolTable\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSFunction {\n  YSFunction::~YSFunction ()\n  {\n      // don't delete m_entry here, it belongs to SymbolTable\n  }\n}"
  },
  {
    "function_name": "YSFunction",
    "container": "YSFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "454-458",
    "snippet": "YSFunction::YSFunction (YSymbolEntryPtr entry, int line)\n    : YStatement (line)\n    , m_entry (entry)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSFunction {\n  YSFunction::YSFunction (YSymbolEntryPtr entry, int line)\n      : YStatement (line)\n      , m_entry (entry)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSReturn",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "427-448",
    "snippet": "YCPValue\nYSReturn::evaluate (bool cse)\n{\n    if (cse) return YCPNull();\n#if DO_DEBUG\n    y2debug (\"YSReturn::evaluate (%s)\\n\", m_value ? m_value->toString().c_str() : \"\");\n#endif\n    if (m_value != 0)\n    {\n\tYCPValue val = m_value->evaluate (cse);\n\n\tif (!val.isNull()\n\t    && !val->isVoid())\t\t// treat 'return nil;' as 'return;'\n\t{\n\t    return val;\n\t}\n    }\n    // don't return YCPVoid() here since YBlock() needs YCPReturn to distinguish\n    // a normal statement (returning YCPVoid) from the 'return' statement which\n    // ends the block\n    return YCPReturn();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPReturn",
          "args": [],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "YCPReturn",
          "container": "YCPReturn",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YCPCode.h",
          "lines": "237-237",
          "snippet": "YCPReturn() : YCPValue (new YCPReturnRep ()) {}",
          "includes": [
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPValue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/SymbolEntry.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPValue.h\"\n\nYCPReturn {\n  YCPReturn() : YCPValue (new YCPReturnRep ()) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "val->isVoid",
          "args": [],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "val.isNull",
          "args": [],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_value->evaluate",
          "args": [
            "cse"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1958-2008",
          "snippet": "YCPValue\nYSSwitch::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug( \"YSSwitch\");\n#endif\n    if (cse)\n\treturn YCPNull ();\n\t\n    YCPValue condition = m_condition->evaluate ();\n    if (condition.isNull ())\n    {\n\tycperror (\"switch condition evaluates to 'nil'\");\n\treturn YCPNull ();\n    }\n    \n    // if there is a case for this value, execute\n    if (m_cases.find (condition) != m_cases.end ())\n    {\n#if DO_DEBUG\n\ty2debug (\"Evaluating from statement '%d'\",m_cases[condition]);\n#endif\n\tYCPValue res = m_block->evaluateFrom (m_cases[condition]);\n\n\t// break should not be propagated\n\tif (!res.isNull () && res->isBreak ())\n\t    res = YCPNull ();\n\t    \n\treturn res;\n    }\n    // no case, try default if defined\n    else if (m_defaultcase != -1)\n    {\n#if DO_DEBUG\n\ty2debug (\"Evaluating from default statement '%d'\",m_defaultcase);\n#endif\n\tYCPValue res = m_block->evaluateFrom (m_defaultcase);\n\n\t// break should not be propagated\n\tif (!res.isNull () && res->isBreak ())\n\t    res = YCPNull ();\n\t    \n\treturn res;\n    }\n\n#if DO_DEBUG\n    y2debug (\"Switch done\");\n#endif\n\n    return YCPNull ();\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSSwitch {\n  YCPValue\n  YSSwitch::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug( \"YSSwitch\");\n  #endif\n      if (cse)\n  \treturn YCPNull ();\n  \t\n      YCPValue condition = m_condition->evaluate ();\n      if (condition.isNull ())\n      {\n  \tycperror (\"switch condition evaluates to 'nil'\");\n  \treturn YCPNull ();\n      }\n      \n      // if there is a case for this value, execute\n      if (m_cases.find (condition) != m_cases.end ())\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Evaluating from statement '%d'\",m_cases[condition]);\n  #endif\n  \tYCPValue res = m_block->evaluateFrom (m_cases[condition]);\n  \n  \t// break should not be propagated\n  \tif (!res.isNull () && res->isBreak ())\n  \t    res = YCPNull ();\n  \t    \n  \treturn res;\n      }\n      // no case, try default if defined\n      else if (m_defaultcase != -1)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Evaluating from default statement '%d'\",m_defaultcase);\n  #endif\n  \tYCPValue res = m_block->evaluateFrom (m_defaultcase);\n  \n  \t// break should not be propagated\n  \tif (!res.isNull () && res->isBreak ())\n  \t    res = YCPNull ();\n  \t    \n  \treturn res;\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"Switch done\");\n  #endif\n  \n      return YCPNull ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YSReturn::evaluate (%s)\\n\"",
            "m_value ? m_value->toString().c_str() : \"\""
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_value->toString",
          "args": [],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSReturn {\n  YCPValue\n  YSReturn::evaluate (bool cse)\n  {\n      if (cse) return YCPNull();\n  #if DO_DEBUG\n      y2debug (\"YSReturn::evaluate (%s)\\n\", m_value ? m_value->toString().c_str() : \"\");\n  #endif\n      if (m_value != 0)\n      {\n  \tYCPValue val = m_value->evaluate (cse);\n  \n  \tif (!val.isNull()\n  \t    && !val->isVoid())\t\t// treat 'return nil;' as 'return;'\n  \t{\n  \t    return val;\n  \t}\n      }\n      // don't return YCPVoid() here since YBlock() needs YCPReturn to distinguish\n      // a normal statement (returning YCPVoid) from the 'return' statement which\n      // ends the block\n      return YCPReturn();\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSReturn",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "390-401",
    "snippet": "string\nYSReturn::toString() const\n{\n    string s = \"return\";\n    if (m_value != 0)\n    {\n\ts += \" \";\n\ts += m_value->toString();\n    }\n    s += \";\";\n    return s;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_value->toString",
          "args": [],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSReturn {\n  string\n  YSReturn::toString() const\n  {\n      string s = \"return\";\n      if (m_value != 0)\n      {\n  \ts += \" \";\n  \ts += m_value->toString();\n      }\n      s += \";\";\n      return s;\n  }\n}"
  },
  {
    "function_name": "propagate",
    "container": "YSReturn",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "379-387",
    "snippet": "void\nYSReturn::propagate (constTypePtr from, constTypePtr to)\n{\n    if (m_value != 0)\n    {\n\tm_value = new YEPropagate (m_value, from, to);\n    }\n    return;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSReturn {\n  void\n  YSReturn::propagate (constTypePtr from, constTypePtr to)\n  {\n      if (m_value != 0)\n      {\n  \tm_value = new YEPropagate (m_value, from, to);\n      }\n      return;\n  }\n}"
  },
  {
    "function_name": "clearValue",
    "container": "YSReturn",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "369-374",
    "snippet": "void\nYSReturn::clearValue()\n{\n    m_value = 0;\n    return;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSReturn {\n  void\n  YSReturn::clearValue()\n  {\n      m_value = 0;\n      return;\n  }\n}"
  },
  {
    "function_name": "value",
    "container": "YSReturn",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "356-360",
    "snippet": "YCodePtr \nYSReturn::value() const\n{\n    return m_value;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSReturn {\n  YCodePtr \n  YSReturn::value() const\n  {\n      return m_value;\n  }\n}"
  },
  {
    "function_name": "~YSReturn",
    "container": "YSReturn",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "351-353",
    "snippet": "YSReturn::~YSReturn ()\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSReturn {\n  YSReturn::~YSReturn ()\n  {\n  }\n}"
  },
  {
    "function_name": "YSReturn",
    "container": "YSReturn",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "340-348",
    "snippet": "YSReturn::YSReturn (bytecodeistream & str)\n    : YStatement (str)\n    , m_value (0)\n{\n    if (Bytecode::readBool (str))\n    {\n\tm_value = Bytecode::readCode (str);\n    }\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readBool",
          "args": [
            "str"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "readBool",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "158-172",
          "snippet": "bool\nBytecode::readBool (bytecodeistream & str)\n{\n    char c;\n    str.get (c);\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n#endif\n\n    if (c != 0)\n    {\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readBool (bytecodeistream & str)\n  {\n      char c;\n      str.get (c);\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n  #endif\n  \n      if (c != 0)\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSReturn {\n  YSReturn::YSReturn (bytecodeistream & str)\n      : YStatement (str)\n      , m_value (0)\n  {\n      if (Bytecode::readBool (str))\n      {\n  \tm_value = Bytecode::readCode (str);\n      }\n  }\n}"
  },
  {
    "function_name": "YSReturn",
    "container": "YSReturn",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "333-337",
    "snippet": "YSReturn::YSReturn (YCodePtr value, int line)\n    : YStatement (line)\n    , m_value (value)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSReturn {\n  YSReturn::YSReturn (YCodePtr value, int line)\n      : YStatement (line)\n      , m_value (value)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "320-327",
    "snippet": "YCPValue\nYSBlock::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug (\"YSBlock::evaluate(%s:%d)\\n\", toString().c_str(), line());\n#endif\n    return m_block->evaluate (cse);\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_block->evaluate",
          "args": [
            "cse"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1958-2008",
          "snippet": "YCPValue\nYSSwitch::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug( \"YSSwitch\");\n#endif\n    if (cse)\n\treturn YCPNull ();\n\t\n    YCPValue condition = m_condition->evaluate ();\n    if (condition.isNull ())\n    {\n\tycperror (\"switch condition evaluates to 'nil'\");\n\treturn YCPNull ();\n    }\n    \n    // if there is a case for this value, execute\n    if (m_cases.find (condition) != m_cases.end ())\n    {\n#if DO_DEBUG\n\ty2debug (\"Evaluating from statement '%d'\",m_cases[condition]);\n#endif\n\tYCPValue res = m_block->evaluateFrom (m_cases[condition]);\n\n\t// break should not be propagated\n\tif (!res.isNull () && res->isBreak ())\n\t    res = YCPNull ();\n\t    \n\treturn res;\n    }\n    // no case, try default if defined\n    else if (m_defaultcase != -1)\n    {\n#if DO_DEBUG\n\ty2debug (\"Evaluating from default statement '%d'\",m_defaultcase);\n#endif\n\tYCPValue res = m_block->evaluateFrom (m_defaultcase);\n\n\t// break should not be propagated\n\tif (!res.isNull () && res->isBreak ())\n\t    res = YCPNull ();\n\t    \n\treturn res;\n    }\n\n#if DO_DEBUG\n    y2debug (\"Switch done\");\n#endif\n\n    return YCPNull ();\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSSwitch {\n  YCPValue\n  YSSwitch::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug( \"YSSwitch\");\n  #endif\n      if (cse)\n  \treturn YCPNull ();\n  \t\n      YCPValue condition = m_condition->evaluate ();\n      if (condition.isNull ())\n      {\n  \tycperror (\"switch condition evaluates to 'nil'\");\n  \treturn YCPNull ();\n      }\n      \n      // if there is a case for this value, execute\n      if (m_cases.find (condition) != m_cases.end ())\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Evaluating from statement '%d'\",m_cases[condition]);\n  #endif\n  \tYCPValue res = m_block->evaluateFrom (m_cases[condition]);\n  \n  \t// break should not be propagated\n  \tif (!res.isNull () && res->isBreak ())\n  \t    res = YCPNull ();\n  \t    \n  \treturn res;\n      }\n      // no case, try default if defined\n      else if (m_defaultcase != -1)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Evaluating from default statement '%d'\",m_defaultcase);\n  #endif\n  \tYCPValue res = m_block->evaluateFrom (m_defaultcase);\n  \n  \t// break should not be propagated\n  \tif (!res.isNull () && res->isBreak ())\n  \t    res = YCPNull ();\n  \t    \n  \treturn res;\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"Switch done\");\n  #endif\n  \n      return YCPNull ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YSBlock::evaluate(%s:%d)\\n\"",
            "toString().c_str()",
            "line()"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line",
          "args": [],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "line",
          "container": "YStatement",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YStatement.h",
          "lines": "78-78",
          "snippet": "int line () const { return m_line; }",
          "includes": [
            "#include \"ycp/ycpless.h\"",
            "#include \"ycp/Import.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ycpless.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YCode.h\"\n#include <string>\n\nYStatement {\n  int line () const { return m_line; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSBlock {\n  YCPValue\n  YSBlock::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug (\"YSBlock::evaluate(%s:%d)\\n\", toString().c_str(), line());\n  #endif\n      return m_block->evaluate (cse);\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "297-302",
    "snippet": "string\nYSBlock::toString() const\n{\n    string s = m_block->toString();\n    return s;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_block->toString",
          "args": [],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSBlock {\n  string\n  YSBlock::toString() const\n  {\n      string s = m_block->toString();\n      return s;\n  }\n}"
  },
  {
    "function_name": "~YSBlock",
    "container": "YSBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "292-294",
    "snippet": "YSBlock::~YSBlock ()\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSBlock {\n  YSBlock::~YSBlock ()\n  {\n  }\n}"
  },
  {
    "function_name": "YSBlock",
    "container": "YSBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "285-289",
    "snippet": "YSBlock::YSBlock (bytecodeistream & str)\n    : YStatement (str)\n{\n    m_block = Bytecode::readCode (str);\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSBlock {\n  YSBlock::YSBlock (bytecodeistream & str)\n      : YStatement (str)\n  {\n      m_block = Bytecode::readCode (str);\n  }\n}"
  },
  {
    "function_name": "YSBlock",
    "container": "YSBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "277-282",
    "snippet": "YSBlock::YSBlock (YBlockPtr block, int line)\n    : YStatement (line)\n    , m_block (block)\n{\n    m_block->setKind (YBlock::b_statement);\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_block->setKind",
          "args": [
            "YBlock::b_statement"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "setKind",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "349-357",
          "snippet": "void\nYBlock::setKind (YBlock::blockkind_t kind)\n{\n#if DO_DEBUG\n    y2debug (\"YBlock::setKind %p: %d\", this, (int)kind);\n#endif\n    m_kind = kind;\n    return;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  void\n  YBlock::setKind (YBlock::blockkind_t kind)\n  {\n  #if DO_DEBUG\n      y2debug (\"YBlock::setKind %p: %d\", this, (int)kind);\n  #endif\n      m_kind = kind;\n      return;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSBlock {\n  YSBlock::YSBlock (YBlockPtr block, int line)\n      : YStatement (line)\n      , m_block (block)\n  {\n      m_block->setKind (YBlock::b_statement);\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSExpression",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "263-271",
    "snippet": "YCPValue\nYSExpression::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug (\"YSExpression::evaluate(%s:%d)\\n\", toString().c_str(), line());\n#endif\n    m_expr->evaluate (cse);\n    return YCPNull();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_expr->evaluate",
          "args": [
            "cse"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1958-2008",
          "snippet": "YCPValue\nYSSwitch::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug( \"YSSwitch\");\n#endif\n    if (cse)\n\treturn YCPNull ();\n\t\n    YCPValue condition = m_condition->evaluate ();\n    if (condition.isNull ())\n    {\n\tycperror (\"switch condition evaluates to 'nil'\");\n\treturn YCPNull ();\n    }\n    \n    // if there is a case for this value, execute\n    if (m_cases.find (condition) != m_cases.end ())\n    {\n#if DO_DEBUG\n\ty2debug (\"Evaluating from statement '%d'\",m_cases[condition]);\n#endif\n\tYCPValue res = m_block->evaluateFrom (m_cases[condition]);\n\n\t// break should not be propagated\n\tif (!res.isNull () && res->isBreak ())\n\t    res = YCPNull ();\n\t    \n\treturn res;\n    }\n    // no case, try default if defined\n    else if (m_defaultcase != -1)\n    {\n#if DO_DEBUG\n\ty2debug (\"Evaluating from default statement '%d'\",m_defaultcase);\n#endif\n\tYCPValue res = m_block->evaluateFrom (m_defaultcase);\n\n\t// break should not be propagated\n\tif (!res.isNull () && res->isBreak ())\n\t    res = YCPNull ();\n\t    \n\treturn res;\n    }\n\n#if DO_DEBUG\n    y2debug (\"Switch done\");\n#endif\n\n    return YCPNull ();\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSSwitch {\n  YCPValue\n  YSSwitch::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug( \"YSSwitch\");\n  #endif\n      if (cse)\n  \treturn YCPNull ();\n  \t\n      YCPValue condition = m_condition->evaluate ();\n      if (condition.isNull ())\n      {\n  \tycperror (\"switch condition evaluates to 'nil'\");\n  \treturn YCPNull ();\n      }\n      \n      // if there is a case for this value, execute\n      if (m_cases.find (condition) != m_cases.end ())\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Evaluating from statement '%d'\",m_cases[condition]);\n  #endif\n  \tYCPValue res = m_block->evaluateFrom (m_cases[condition]);\n  \n  \t// break should not be propagated\n  \tif (!res.isNull () && res->isBreak ())\n  \t    res = YCPNull ();\n  \t    \n  \treturn res;\n      }\n      // no case, try default if defined\n      else if (m_defaultcase != -1)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Evaluating from default statement '%d'\",m_defaultcase);\n  #endif\n  \tYCPValue res = m_block->evaluateFrom (m_defaultcase);\n  \n  \t// break should not be propagated\n  \tif (!res.isNull () && res->isBreak ())\n  \t    res = YCPNull ();\n  \t    \n  \treturn res;\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"Switch done\");\n  #endif\n  \n      return YCPNull ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YSExpression::evaluate(%s:%d)\\n\"",
            "toString().c_str()",
            "line()"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "line",
          "container": "YStatement",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YStatement.h",
          "lines": "78-78",
          "snippet": "int line () const { return m_line; }",
          "includes": [
            "#include \"ycp/ycpless.h\"",
            "#include \"ycp/Import.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ycpless.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YCode.h\"\n#include <string>\n\nYStatement {\n  int line () const { return m_line; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSExpression {\n  YCPValue\n  YSExpression::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug (\"YSExpression::evaluate(%s:%d)\\n\", toString().c_str(), line());\n  #endif\n      m_expr->evaluate (cse);\n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSExpression",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "234-243",
    "snippet": "string\nYSExpression::toString() const\n{\n    string s = m_expr->toString();\n    if (!m_expr->isBlock())\n    {\n\ts += \";\";\n    }\n    return s;\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_expr->isBlock",
          "args": [],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "isBlock",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "73-77",
          "snippet": "bool\nYBreakpoint::isBlock () const\n{\n    return m_code->isBlock();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  bool\n  YBreakpoint::isBlock () const\n  {\n      return m_code->isBlock();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_expr->toString",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSExpression {\n  string\n  YSExpression::toString() const\n  {\n      string s = m_expr->toString();\n      if (!m_expr->isBlock())\n      {\n  \ts += \";\";\n      }\n      return s;\n  }\n}"
  },
  {
    "function_name": "~YSExpression",
    "container": "YSExpression",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "229-231",
    "snippet": "YSExpression::~YSExpression ()\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSExpression {\n  YSExpression::~YSExpression ()\n  {\n  }\n}"
  },
  {
    "function_name": "YSExpression",
    "container": "YSExpression",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "222-226",
    "snippet": "YSExpression::YSExpression (bytecodeistream & str)\n    : YStatement (str)\n{\n    m_expr = Bytecode::readCode (str);\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSExpression {\n  YSExpression::YSExpression (bytecodeistream & str)\n      : YStatement (str)\n  {\n      m_expr = Bytecode::readCode (str);\n  }\n}"
  },
  {
    "function_name": "YSExpression",
    "container": "YSExpression",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "215-219",
    "snippet": "YSExpression::YSExpression (YCodePtr expr, int line)\n    : YStatement (line)\n    , m_expr (expr)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSExpression {\n  YSExpression::YSExpression (YCodePtr expr, int line)\n      : YStatement (line)\n      , m_expr (expr)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSContinue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "190-197",
    "snippet": "YCPValue\nYSContinue::evaluate (bool /*cse*/)\n{\n#if DO_DEBUG\n    y2debug (\"YSContinue::evaluate(%s)\\n\", toString().c_str());\n#endif\n    return YCPVoid();\t\t// special meaning!\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YSContinue::evaluate(%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSContinue {\n  YCPValue\n  YSContinue::evaluate (bool /*cse*/)\n  {\n  #if DO_DEBUG\n      y2debug (\"YSContinue::evaluate(%s)\\n\", toString().c_str());\n  #endif\n      return YCPVoid();\t\t// special meaning!\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSContinue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "183-187",
    "snippet": "string\nYSContinue::toString () const\n{\n    return \"continue;\";\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSContinue {\n  string\n  YSContinue::toString () const\n  {\n      return \"continue;\";\n  }\n}"
  },
  {
    "function_name": "YSContinue",
    "container": "YSContinue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "177-180",
    "snippet": "YSContinue::YSContinue (bytecodeistream & str)\n    : YStatement (str)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSContinue {\n  YSContinue::YSContinue (bytecodeistream & str)\n      : YStatement (str)\n  {\n  }\n}"
  },
  {
    "function_name": "YSContinue",
    "container": "YSContinue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "171-174",
    "snippet": "YSContinue::YSContinue (int line)\n    : YStatement (line)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSContinue {\n  YSContinue::YSContinue (int line)\n      : YStatement (line)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YSBreak",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "146-153",
    "snippet": "YCPValue\nYSBreak::evaluate (bool /*cse*/)\n{\n#if DO_DEBUG\n    y2debug (\"YSBreak::evaluate(%s)\\n\", toString().c_str());\n#endif\n    return YCPBreak();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBreak",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBreak",
          "container": "YCPBreak",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YCPCode.h",
          "lines": "169-169",
          "snippet": "YCPBreak() : YCPValue (new YCPBreakRep ()) {}",
          "includes": [
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPValue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/SymbolEntry.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPValue.h\"\n\nYCPBreak {\n  YCPBreak() : YCPValue (new YCPBreakRep ()) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YSBreak::evaluate(%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYSBreak {\n  YCPValue\n  YSBreak::evaluate (bool /*cse*/)\n  {\n  #if DO_DEBUG\n      y2debug (\"YSBreak::evaluate(%s)\\n\", toString().c_str());\n  #endif\n      return YCPBreak();\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YSBreak",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "139-143",
    "snippet": "string\nYSBreak::toString () const\n{\n    return \"break;\";\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSBreak {\n  string\n  YSBreak::toString () const\n  {\n      return \"break;\";\n  }\n}"
  },
  {
    "function_name": "YSBreak",
    "container": "YSBreak",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "133-136",
    "snippet": "YSBreak::YSBreak (bytecodeistream & str)\n    : YStatement (str)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSBreak {\n  YSBreak::YSBreak (bytecodeistream & str)\n      : YStatement (str)\n  {\n  }\n}"
  },
  {
    "function_name": "YSBreak",
    "container": "YSBreak",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "127-130",
    "snippet": "YSBreak::YSBreak (int line)\n    : YStatement (line)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSBreak {\n  YSBreak::YSBreak (int line)\n      : YStatement (line)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YStatement",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "98-105",
    "snippet": "YCPValue\nYStatement::evaluate (bool /*cse*/)\n{\n#if DO_DEBUG\n    y2debug (\"YStatement::evaluate(%s)\\n\", toString().c_str());\n#endif\n    return YCPNull();\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YStatement::evaluate(%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSSwitch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "1879-1885",
          "snippet": "string\nYSSwitch::toString() const\n{\n    string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n    s += m_block->toStringSwitch (m_cases, m_defaultcase);\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSSwitch {\n  string\n  YSSwitch::toString() const\n  {\n      string s = string (\"switch (\") + m_condition->toString () + \") \\n\";\n      s += m_block->toStringSwitch (m_cases, m_defaultcase);\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYStatement {\n  YCPValue\n  YStatement::evaluate (bool /*cse*/)\n  {\n  #if DO_DEBUG\n      y2debug (\"YStatement::evaluate(%s)\\n\", toString().c_str());\n  #endif\n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YStatement",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "91-95",
    "snippet": "string\nYStatement::toString () const\n{\n    return \"<<undefined statement>>\";\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYStatement {\n  string\n  YStatement::toString () const\n  {\n      return \"<<undefined statement>>\";\n  }\n}"
  },
  {
    "function_name": "YStatement",
    "container": "YStatement",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "81-88",
    "snippet": "YStatement::YStatement (bytecodeistream & str)\n    : YCode ()\n{\n    m_line = Bytecode::readInt32 (str);\n#if DO_DEBUG\n    y2debug (\"YStatement::YStatement([%d]:%d)\", (int)kind, m_line);\n#endif\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YStatement::YStatement([%d]:%d)\"",
            "(int)kind",
            "m_line"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readInt32",
          "args": [
            "str"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYStatement {\n  YStatement::YStatement (bytecodeistream & str)\n      : YCode ()\n  {\n      m_line = Bytecode::readInt32 (str);\n  #if DO_DEBUG\n      y2debug (\"YStatement::YStatement([%d]:%d)\", (int)kind, m_line);\n  #endif\n  }\n}"
  },
  {
    "function_name": "YStatement",
    "container": "YStatement",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
    "lines": "74-78",
    "snippet": "YStatement::YStatement (int line)\n    : YCode ()\n    , m_line (line)\n{\n}",
    "includes": [
      "#include \"y2/Y2ComponentBroker.h\"",
      "#include \"y2/Y2Component.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include <libintl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYStatement {\n  YStatement::YStatement (int line)\n      : YCode ()\n      , m_line (line)\n  {\n  }\n}"
  }
]