[
  {
    "function_name": "ain(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/tty_wrapper/tty_wrapper.cc",
    "lines": "102-221",
    "snippet": "nt main(int argc, char **argv)\n{\n    if (argc > 1)\n    {\n\t// register SIGCHLD handler\n\tif (!registerSignalHandler())\n\t{\n\t    return 1;\n\t}\n\n\tsigset_t new_sigset, old_sigset;\n\n\t// set asll signals\n\t::sigfillset(&new_sigset);\n\t// get the current mask\n\t::sigprocmask(0, NULL, &old_sigset);\n\n\t// block all signals\n\t::sigprocmask(SIG_SETMASK, &new_sigset, NULL);\n\n\t// start the subprocess\n\tProcess subprocess(argv + 1, ExternalProgram::Environment(), true /* use pty */,\n\t    false /* no default locale */, false /* no LF to CRLF output translation*/);\n\n\t// check stdin, subprocess::stdout and subprocess::stderr\n\tint stdin_fd = 0;\n\tint sub_stdout_fd = fileno(subprocess.outputFile());\n\tint sub_stderr_fd = fileno(subprocess.errorFile());\n\tint max_fd = (sub_stdout_fd > sub_stderr_fd) ? sub_stdout_fd : sub_stderr_fd;\n\n\t// set nonblocking IO\n\tsubprocess.setBlocking(false);\n\n\tfd_set rfds;\n\n\t// this is a buffer for reading from stdin\n\tchar stdin_buffer[128];\n\n\twhile (true)\n\t{\n\t    // block all signals\n\t    ::sigprocmask(SIG_SETMASK, &new_sigset, NULL);\n\n\t    if (finish)\n\t    {\n\t\t// read the remaining pieces\n\t\tstd::string std_out(subprocess.read());\n\t\toutput(std_out, 1);\n\t\tstd::string err_out(subprocess.readErr());\n\t\toutput(err_out, 2);\n\t\t// SIGCHLD received, return the exit status\n\t\treturn subprocess.close();\n\t    }\n\n\t    FD_ZERO(&rfds);\n\n\t    // watch stdin (fd 0)\n\t    FD_SET(stdin_fd, &rfds);\n\n\t    // watch subprocess::stdout\n\t    FD_SET(sub_stdout_fd, &rfds);\n\n\t    // watch subprocess::stderr\n\t    FD_SET(sub_stderr_fd, &rfds);\n\n\t    // wait for an IO event or for a signal\n\t    int retval = ::pselect(max_fd + 1, &rfds, NULL, NULL, NULL, &old_sigset);\n\n\t    // enable signals back\n\t    ::sigprocmask(SIG_SETMASK, &old_sigset, NULL);\n\n\t    // ignore EINTR (Interrupted system call) caused by a signal\n\t    if (retval == -1 && errno != EINTR)\n\t    {\n\t\t::perror(\"pselect()\");\n\t\treturn 1;\n\t    }\n\t    // handle the input\n\t    else if (retval > 0)\n\t    {\n\t\t// stdin available\n\t\tif (FD_ISSET(stdin_fd, &rfds))\n\t\t{\n\t\t    // read a string from stdin and pass it to the subprocess\n\t\t    ssize_t len = read(stdin_fd, stdin_buffer, sizeof(stdin_buffer) - 1);\n\n\t\t    if (len > 0)\n\t\t    {\n\t\t\t// terminate the string in the buffer\n\t\t\tstdin_buffer[len + 1] = '\\0';\n\t\t\tsubprocess.send(stdin_buffer);\n\t\t    }\n\t\t}\n\n\t\t// stdout available\n\t\tif (FD_ISSET(sub_stdout_fd, &rfds))\n\t\t{\n\t\t    // read stdout of the subprocess and print it on stdout\n\t\t    std::string std_out(subprocess.read());\n\t\t    output(std_out, 1);\n\t\t}\n\n\t\t// stderr available\n\t\tif (FD_ISSET(sub_stderr_fd, &rfds))\n\t\t{\n\t\t    // read stderr of the subprocess and print it on stderr\n\t\t    std::string err_out(subprocess.readErr());\n\t\t    output(err_out, 2);\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tstd::cerr << \"tty_wrapper - Generic tty wrapper\" << std::endl;\n\tstd::cerr << \"Error: No argument\" << std::endl;\n\tstd::cerr << \"Usage: \" << argv[0] << \" <command> [<option1> [<option2> [....]]\" << std::endl;\n\treturn 1;\n    }\n}",
    "includes": [
      "include <errno.h>\n}",
      "include <signal.h>\n#",
      "include <sys/select.h>\n#",
      "include <iostream>",
      "include <y2util/Process.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic sig_atomic_t finish = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "utput(",
          "args": [
            "rr_out,",
            ")"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "utput(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/tty_wrapper/tty_wrapper.cc",
          "lines": "76-100",
          "snippet": "oid output(const std::string & s, int fd)\n{\n    const char *cs = s.c_str();\n    ssize_t n = s.size();\n    while (true) {\n\tssize_t w = write(fd, cs, n);\n\tif (w == n)\n\t    break;\t\t// success\n\telse if (w == -1) {\n\t    if (errno == EINTR) {\n\t\t// perror(\"gotcha\"); // bnc#470645\n\t    }\n\t    else {\n\t\tperror(\"write\"); // other cases\n\t\tbreak;\n\t    }\n\t}\n\telse {\n\t    errno = 0;\n\t    perror(\"short\");\n\t    cs += w;\n\t    n -= w;\n\t}\n    }\n}",
          "includes": [
            "include <errno.h>\n}",
            "include <signal.h>\n#",
            "include <sys/select.h>\n#",
            "include <iostream>",
            "include <y2util/Process.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <errno.h>\n}\ninclude <signal.h>\n#\ninclude <sys/select.h>\n#\ninclude <iostream>\ninclude <y2util/Process.h>\n#\n\noid output(const std::string & s, int fd)\n{\n    const char *cs = s.c_str();\n    ssize_t n = s.size();\n    while (true) {\n\tssize_t w = write(fd, cs, n);\n\tif (w == n)\n\t    break;\t\t// success\n\telse if (w == -1) {\n\t    if (errno == EINTR) {\n\t\t// perror(\"gotcha\"); // bnc#470645\n\t    }\n\t    else {\n\t\tperror(\"write\"); // other cases\n\t\tbreak;\n\t    }\n\t}\n\telse {\n\t    errno = 0;\n\t    perror(\"short\");\n\t    cs += w;\n\t    n -= w;\n\t}\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubprocess.readErr",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D_ISSET(",
          "args": [
            "ub_stderr_fd,",
            "rfds)"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubprocess.read",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D_ISSET(",
          "args": [
            "ub_stdout_fd,",
            "rfds)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubprocess.send",
          "args": [
            "tdin_buffer)"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "Y2StdioComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
          "lines": "125-132",
          "snippet": "void\nY2StdioComponent::send (const YCPValue& v) const\n{\n    string s = \"(\" + (v.isNull () ? \"(nil)\" : v->toString ()) + \")\\n\";\n    y2debug (\"send begin %s\", s.c_str ());\n    write (to_stderr ? STDERR_FILENO : STDOUT_FILENO, s.c_str (), s.length ());\n    y2debug (\"send end %s\", s.c_str ());\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include \"Y2StdioComponent.h\"",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  void\n  Y2StdioComponent::send (const YCPValue& v) const\n  {\n      string s = \"(\" + (v.isNull () ? \"(nil)\" : v->toString ()) + \")\\n\";\n      y2debug (\"send begin %s\", s.c_str ());\n      write (to_stderr ? STDERR_FILENO : STDOUT_FILENO, s.c_str (), s.length ());\n      y2debug (\"send end %s\", s.c_str ());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ead(",
          "args": [
            "tdin_fd,",
            "tdin_buffer,",
            "izeof(stdin_buffer) - 1)"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "Read(",
          "container": "rocessAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-process/src/ProcessAgent.cc",
          "lines": "101-243",
          "snippet": "CPValue ProcessAgent::Read(const YCPPath &path, const YCPValue& arg, const YCPValue& opt)\n{\n    std::string cmd(path->component_str(0));\n\n    if (arg.isNull() || !arg->isInteger())\n    {\n\ty2error(\"ID of the process is missing\");\n\treturn YCPNull();\n    }\n\n    pid_t id = arg->asInteger()->value();\n\n    y2debug(\"Requested path: %s, id: %d\", cmd.c_str(), id);\n\n    ProcessContainer::iterator proc(_processes.find(id));\n\n    if (proc == _processes.end())\n    {\n\ty2error(\"Process '%d' not found\", id);\n\treturn YCPNull();\n    }\n\n    // handler for \"running\" path\n    if (cmd == \"running\")\n    {\n\t/**\n\t * @builtin Read (.process.running, integer id) -> boolean\n\t * Returns true if the process is running\n\t *\n\t * @example Read (.process.running, 12345) -> true\n\t */\n\n\t// read output to unblock the process\n\tproc->second->readStdoutToBuffer();\n\tproc->second->readStderrToBuffer();\n\n\treturn YCPBoolean(proc->second->running());\n    }\n    // handler for \"pid\" path\n    else if (cmd == \"pid\")\n    {\n\t/**\n\t * @builtin Read (.process.pid, integer id) -> integer\n\t * Returns the PID of a process\n\t *\n\t * @example Read (.process.pid, 12345) -> 6789\n\t */\n\treturn YCPInteger(id);\n    }\n    else if (cmd == \"read_line\")\n    {\n\t/**\n\t * @builtin Read (.process.read_line, integer id) -> string\n\t * Returns one line from stdout of the process, nil if there is no output\n\t *\n\t * @example Read (.process.read_line, 12345) -> nil\n\t */\n\tstd::string out = proc->second->readLine();\n\treturn ProcessOutput(out);\n    }\n    else if (cmd == \"read\")\n    {\n\t/**\n\t * @builtin Read (.process.read, integer id) -> string\n\t * Returns read stdout of the process, nil if there is no output.\n\t * This read function is not line-oriented, the output can contain multiple lines or just part of a line.\n\t *\n\t * @example Read (.process.read, 12345) -> nil\n\t */\n\tstd::string out(proc->second->read());\n\n\tif (out.empty())\n\t{\n\t    return YCPVoid();\n\t}\n\telse\n\t{\n\t    return YCPString(out);\n\t}\n    }\n    else if (cmd == \"read_line_stderr\")\n    {\n\t/**\n\t * @builtin Read (.process.read_line_stderr, integer id) -> string\n\t * Returns one line from stderr of the process, nil if there is no output\n\t *\n\t * @example Read (.process.read_line_stderr, 12345) -> nil\n\t */\n\tstd::string err = proc->second->readErrLine();\n\treturn ProcessOutput(err);\n    }\n    else if (cmd == \"read_stderr\")\n    {\n\t/**\n\t * @builtin Read (.process.read_stderr, integer id) -> string\n\t * Returns read stderr of the process, nil if there is no output.\n\t * This read function is not line-oriented, the output can contain multiple lines or just part of a line.\n\t *\n\t * @example Read (.process.read_stderr, 12345) -> nil\n\t */\n\tstd::string out(proc->second->readErr());\n\n\tif (out.empty())\n\t{\n\t    return YCPVoid();\n\t}\n\telse\n\t{\n\t    return YCPString(out);\n\t}\n    }\n    else if (cmd == \"status\")\n    {\n\t/**\n\t * @builtin Read (.process.status, integer id) -> integer\n\t * Returns exit status of the process, if the process is still running nil is returned.\n\t *\n\t * @example Read (.process.status, 12345) -> 0\n\t */\n\tif (proc->second->running())\n\t{\n\t    // the process is still running\n\t    return YCPVoid();\n\t}\n\telse\n\t{\n\t    return YCPInteger(proc->second->close());\n\t}\n    }\n    else if (cmd == \"buffer_empty\")\n    {\n\t/**\n\t * @builtin Read (.process.buffer_empty, integer id) -> boolean\n\t * Returns boolean whether the stdout buffer is empty, if buffer is not empty, false is returned.\n\t *\n\t * @example Read (.process.buffer_empty, 12345) -> false\n\t */\n\treturn YCPBoolean (proc->second->anyLineInStdout());\n    }\n\n    y2error(\"Wrong path '%s' in Read().\", path->toString().c_str());\n    return YCPNull();\n}",
          "includes": [
            "include <y2util/ExternalProgram.h>",
            "include <y2util/Process.h>",
            "include \"ProcessAgent.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <y2util/ExternalProgram.h>\ninclude <y2util/Process.h>\ninclude \"ProcessAgent.h\"\n#\n\nrocessAgent {\n  CPValue ProcessAgent::Read(const YCPPath &path, const YCPValue& arg, const YCPValue& opt)\n  {\n      std::string cmd(path->component_str(0));\n  \n      if (arg.isNull() || !arg->isInteger())\n      {\n  \ty2error(\"ID of the process is missing\");\n  \treturn YCPNull();\n      }\n  \n      pid_t id = arg->asInteger()->value();\n  \n      y2debug(\"Requested path: %s, id: %d\", cmd.c_str(), id);\n  \n      ProcessContainer::iterator proc(_processes.find(id));\n  \n      if (proc == _processes.end())\n      {\n  \ty2error(\"Process '%d' not found\", id);\n  \treturn YCPNull();\n      }\n  \n      // handler for \"running\" path\n      if (cmd == \"running\")\n      {\n  \t/**\n  \t * @builtin Read (.process.running, integer id) -> boolean\n  \t * Returns true if the process is running\n  \t *\n  \t * @example Read (.process.running, 12345) -> true\n  \t */\n  \n  \t// read output to unblock the process\n  \tproc->second->readStdoutToBuffer();\n  \tproc->second->readStderrToBuffer();\n  \n  \treturn YCPBoolean(proc->second->running());\n      }\n      // handler for \"pid\" path\n      else if (cmd == \"pid\")\n      {\n  \t/**\n  \t * @builtin Read (.process.pid, integer id) -> integer\n  \t * Returns the PID of a process\n  \t *\n  \t * @example Read (.process.pid, 12345) -> 6789\n  \t */\n  \treturn YCPInteger(id);\n      }\n      else if (cmd == \"read_line\")\n      {\n  \t/**\n  \t * @builtin Read (.process.read_line, integer id) -> string\n  \t * Returns one line from stdout of the process, nil if there is no output\n  \t *\n  \t * @example Read (.process.read_line, 12345) -> nil\n  \t */\n  \tstd::string out = proc->second->readLine();\n  \treturn ProcessOutput(out);\n      }\n      else if (cmd == \"read\")\n      {\n  \t/**\n  \t * @builtin Read (.process.read, integer id) -> string\n  \t * Returns read stdout of the process, nil if there is no output.\n  \t * This read function is not line-oriented, the output can contain multiple lines or just part of a line.\n  \t *\n  \t * @example Read (.process.read, 12345) -> nil\n  \t */\n  \tstd::string out(proc->second->read());\n  \n  \tif (out.empty())\n  \t{\n  \t    return YCPVoid();\n  \t}\n  \telse\n  \t{\n  \t    return YCPString(out);\n  \t}\n      }\n      else if (cmd == \"read_line_stderr\")\n      {\n  \t/**\n  \t * @builtin Read (.process.read_line_stderr, integer id) -> string\n  \t * Returns one line from stderr of the process, nil if there is no output\n  \t *\n  \t * @example Read (.process.read_line_stderr, 12345) -> nil\n  \t */\n  \tstd::string err = proc->second->readErrLine();\n  \treturn ProcessOutput(err);\n      }\n      else if (cmd == \"read_stderr\")\n      {\n  \t/**\n  \t * @builtin Read (.process.read_stderr, integer id) -> string\n  \t * Returns read stderr of the process, nil if there is no output.\n  \t * This read function is not line-oriented, the output can contain multiple lines or just part of a line.\n  \t *\n  \t * @example Read (.process.read_stderr, 12345) -> nil\n  \t */\n  \tstd::string out(proc->second->readErr());\n  \n  \tif (out.empty())\n  \t{\n  \t    return YCPVoid();\n  \t}\n  \telse\n  \t{\n  \t    return YCPString(out);\n  \t}\n      }\n      else if (cmd == \"status\")\n      {\n  \t/**\n  \t * @builtin Read (.process.status, integer id) -> integer\n  \t * Returns exit status of the process, if the process is still running nil is returned.\n  \t *\n  \t * @example Read (.process.status, 12345) -> 0\n  \t */\n  \tif (proc->second->running())\n  \t{\n  \t    // the process is still running\n  \t    return YCPVoid();\n  \t}\n  \telse\n  \t{\n  \t    return YCPInteger(proc->second->close());\n  \t}\n      }\n      else if (cmd == \"buffer_empty\")\n      {\n  \t/**\n  \t * @builtin Read (.process.buffer_empty, integer id) -> boolean\n  \t * Returns boolean whether the stdout buffer is empty, if buffer is not empty, false is returned.\n  \t *\n  \t * @example Read (.process.buffer_empty, 12345) -> false\n  \t */\n  \treturn YCPBoolean (proc->second->anyLineInStdout());\n      }\n  \n      y2error(\"Wrong path '%s' in Read().\", path->toString().c_str());\n      return YCPNull();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "D_ISSET(",
          "args": [
            "tdin_fd,",
            "rfds)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ":perror(",
          "args": [
            "pselect()\")"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ":sigprocmask(",
          "args": [
            "IG_SETMASK,",
            "old_sigset,",
            "ULL)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ":pselect(",
          "args": [
            "ax_fd + 1,",
            "rfds,",
            "ULL,",
            "ULL,",
            "ULL,",
            "old_sigset)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D_SET(",
          "args": [
            "ub_stderr_fd,",
            "rfds)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D_SET(",
          "args": [
            "ub_stdout_fd,",
            "rfds)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D_SET(",
          "args": [
            "tdin_fd,",
            "rfds)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D_ZERO(",
          "args": [
            "rfds)"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubprocess.close",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "325-351",
          "snippet": "int\nExternalProgram::close()\n{\n    if (pid > 0)\n    {\n\tExternalDataSource::close();\n\t// Wait for child to exit\n\tint ret;\n        int status = 0;\n\tdo\n\t{\n\t    ret = waitpid(pid, &status, 0);\n\t}\n\twhile (ret == -1 && errno == EINTR);\n\n\tif (ret != -1)\n\t{\n\t    status = checkStatus( status );\n\t}\n        pid = -1;\n        return status;\n    }\n    else\n    {\n        return _exitStatus;\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  int\n  ExternalProgram::close()\n  {\n      if (pid > 0)\n      {\n  \tExternalDataSource::close();\n  \t// Wait for child to exit\n  \tint ret;\n          int status = 0;\n  \tdo\n  \t{\n  \t    ret = waitpid(pid, &status, 0);\n  \t}\n  \twhile (ret == -1 && errno == EINTR);\n  \n  \tif (ret != -1)\n  \t{\n  \t    status = checkStatus( status );\n  \t}\n          pid = -1;\n          return status;\n      }\n      else\n      {\n          return _exitStatus;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubprocess.readErr",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubprocess.read",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ":sigprocmask(",
          "args": [
            "IG_SETMASK,",
            "new_sigset,",
            "ULL)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubprocess.setBlocking",
          "args": [
            "alse)"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "setBlocking",
          "container": "ExternalDataSource",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalDataSource.cc",
          "lines": "118-141",
          "snippet": "void ExternalDataSource::setBlocking(bool mode)\n{\n    if(!inputfile) return;\n\n    int fd = ::fileno(inputfile);\n\n    if(fd == -1)\n\t{ ERR << strerror(errno) << endl; return; }\n\n    int flags = ::fcntl(fd,F_GETFL);\n\n    if(flags == -1)\n\t{ ERR << strerror(errno) << endl; return; }\n\n    if(!mode)\n\tflags = flags | O_NONBLOCK;\n    else if(flags & O_NONBLOCK)\n\tflags = flags ^ O_NONBLOCK;\n\n    flags = ::fcntl(fd,F_SETFL,flags);\n\n    if(flags == -1)\n\t{ ERR << strerror(errno) << endl; return; }\n}",
          "includes": [
            "#include <y2util/ExternalDataSource.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalDataSource.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalDataSource {\n  void ExternalDataSource::setBlocking(bool mode)\n  {\n      if(!inputfile) return;\n  \n      int fd = ::fileno(inputfile);\n  \n      if(fd == -1)\n  \t{ ERR << strerror(errno) << endl; return; }\n  \n      int flags = ::fcntl(fd,F_GETFL);\n  \n      if(flags == -1)\n  \t{ ERR << strerror(errno) << endl; return; }\n  \n      if(!mode)\n  \tflags = flags | O_NONBLOCK;\n      else if(flags & O_NONBLOCK)\n  \tflags = flags ^ O_NONBLOCK;\n  \n      flags = ::fcntl(fd,F_SETFL,flags);\n  \n      if(flags == -1)\n  \t{ ERR << strerror(errno) << endl; return; }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ileno(",
          "args": [
            "ubprocess.errorFile())"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubprocess.errorFile",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ileno(",
          "args": [
            "ubprocess.outputFile())"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubprocess.outputFile",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xternalProgram::Environment(",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ":sigprocmask(",
          "args": [
            "IG_SETMASK,",
            "new_sigset,",
            "ULL)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ":sigprocmask(",
          "args": [
            ",",
            "ULL,",
            "old_sigset)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ":sigfillset(",
          "args": [
            "new_sigset)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egisterSignalHandler(",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "egisterSignalHandler(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/tty_wrapper/tty_wrapper.cc",
          "lines": "58-74",
          "snippet": "ool registerSignalHandler()\n{\n    struct sigaction new_action, old_action;\n\n    // use sa_sigaction parameter\n    new_action.sa_flags = SA_SIGINFO;\n    new_action.sa_sigaction = &sig_chld_handler;\n    ::sigemptyset(&new_action.sa_mask);\n\n    if (::sigaction(SIGCHLD, &new_action, &old_action))\n    {\n\tstd::cerr << \"Cannot register SIGCHLD handler!\\n\";\n\treturn false;\n    }\n\n    return true;\n}",
          "includes": [
            "include <errno.h>\n}",
            "include <signal.h>\n#",
            "include <sys/select.h>\n#",
            "include <iostream>",
            "include <y2util/Process.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <errno.h>\n}\ninclude <signal.h>\n#\ninclude <sys/select.h>\n#\ninclude <iostream>\ninclude <y2util/Process.h>\n#\n\nool registerSignalHandler()\n{\n    struct sigaction new_action, old_action;\n\n    // use sa_sigaction parameter\n    new_action.sa_flags = SA_SIGINFO;\n    new_action.sa_sigaction = &sig_chld_handler;\n    ::sigemptyset(&new_action.sa_mask);\n\n    if (::sigaction(SIGCHLD, &new_action, &old_action))\n    {\n\tstd::cerr << \"Cannot register SIGCHLD handler!\\n\";\n\treturn false;\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "include <errno.h>\n}\ninclude <signal.h>\n#\ninclude <sys/select.h>\n#\ninclude <iostream>\ninclude <y2util/Process.h>\n#\n\ntatic sig_atomic_t finish = false;\n\nnt main(int argc, char **argv)\n{\n    if (argc > 1)\n    {\n\t// register SIGCHLD handler\n\tif (!registerSignalHandler())\n\t{\n\t    return 1;\n\t}\n\n\tsigset_t new_sigset, old_sigset;\n\n\t// set asll signals\n\t::sigfillset(&new_sigset);\n\t// get the current mask\n\t::sigprocmask(0, NULL, &old_sigset);\n\n\t// block all signals\n\t::sigprocmask(SIG_SETMASK, &new_sigset, NULL);\n\n\t// start the subprocess\n\tProcess subprocess(argv + 1, ExternalProgram::Environment(), true /* use pty */,\n\t    false /* no default locale */, false /* no LF to CRLF output translation*/);\n\n\t// check stdin, subprocess::stdout and subprocess::stderr\n\tint stdin_fd = 0;\n\tint sub_stdout_fd = fileno(subprocess.outputFile());\n\tint sub_stderr_fd = fileno(subprocess.errorFile());\n\tint max_fd = (sub_stdout_fd > sub_stderr_fd) ? sub_stdout_fd : sub_stderr_fd;\n\n\t// set nonblocking IO\n\tsubprocess.setBlocking(false);\n\n\tfd_set rfds;\n\n\t// this is a buffer for reading from stdin\n\tchar stdin_buffer[128];\n\n\twhile (true)\n\t{\n\t    // block all signals\n\t    ::sigprocmask(SIG_SETMASK, &new_sigset, NULL);\n\n\t    if (finish)\n\t    {\n\t\t// read the remaining pieces\n\t\tstd::string std_out(subprocess.read());\n\t\toutput(std_out, 1);\n\t\tstd::string err_out(subprocess.readErr());\n\t\toutput(err_out, 2);\n\t\t// SIGCHLD received, return the exit status\n\t\treturn subprocess.close();\n\t    }\n\n\t    FD_ZERO(&rfds);\n\n\t    // watch stdin (fd 0)\n\t    FD_SET(stdin_fd, &rfds);\n\n\t    // watch subprocess::stdout\n\t    FD_SET(sub_stdout_fd, &rfds);\n\n\t    // watch subprocess::stderr\n\t    FD_SET(sub_stderr_fd, &rfds);\n\n\t    // wait for an IO event or for a signal\n\t    int retval = ::pselect(max_fd + 1, &rfds, NULL, NULL, NULL, &old_sigset);\n\n\t    // enable signals back\n\t    ::sigprocmask(SIG_SETMASK, &old_sigset, NULL);\n\n\t    // ignore EINTR (Interrupted system call) caused by a signal\n\t    if (retval == -1 && errno != EINTR)\n\t    {\n\t\t::perror(\"pselect()\");\n\t\treturn 1;\n\t    }\n\t    // handle the input\n\t    else if (retval > 0)\n\t    {\n\t\t// stdin available\n\t\tif (FD_ISSET(stdin_fd, &rfds))\n\t\t{\n\t\t    // read a string from stdin and pass it to the subprocess\n\t\t    ssize_t len = read(stdin_fd, stdin_buffer, sizeof(stdin_buffer) - 1);\n\n\t\t    if (len > 0)\n\t\t    {\n\t\t\t// terminate the string in the buffer\n\t\t\tstdin_buffer[len + 1] = '\\0';\n\t\t\tsubprocess.send(stdin_buffer);\n\t\t    }\n\t\t}\n\n\t\t// stdout available\n\t\tif (FD_ISSET(sub_stdout_fd, &rfds))\n\t\t{\n\t\t    // read stdout of the subprocess and print it on stdout\n\t\t    std::string std_out(subprocess.read());\n\t\t    output(std_out, 1);\n\t\t}\n\n\t\t// stderr available\n\t\tif (FD_ISSET(sub_stderr_fd, &rfds))\n\t\t{\n\t\t    // read stderr of the subprocess and print it on stderr\n\t\t    std::string err_out(subprocess.readErr());\n\t\t    output(err_out, 2);\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tstd::cerr << \"tty_wrapper - Generic tty wrapper\" << std::endl;\n\tstd::cerr << \"Error: No argument\" << std::endl;\n\tstd::cerr << \"Usage: \" << argv[0] << \" <command> [<option1> [<option2> [....]]\" << std::endl;\n\treturn 1;\n    }\n}"
  },
  {
    "function_name": "utput(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/tty_wrapper/tty_wrapper.cc",
    "lines": "76-100",
    "snippet": "oid output(const std::string & s, int fd)\n{\n    const char *cs = s.c_str();\n    ssize_t n = s.size();\n    while (true) {\n\tssize_t w = write(fd, cs, n);\n\tif (w == n)\n\t    break;\t\t// success\n\telse if (w == -1) {\n\t    if (errno == EINTR) {\n\t\t// perror(\"gotcha\"); // bnc#470645\n\t    }\n\t    else {\n\t\tperror(\"write\"); // other cases\n\t\tbreak;\n\t    }\n\t}\n\telse {\n\t    errno = 0;\n\t    perror(\"short\");\n\t    cs += w;\n\t    n -= w;\n\t}\n    }\n}",
    "includes": [
      "include <errno.h>\n}",
      "include <signal.h>\n#",
      "include <sys/select.h>\n#",
      "include <iostream>",
      "include <y2util/Process.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error(",
          "args": [
            "short\")"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error(",
          "args": [
            "write\")"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rite(",
          "args": [
            "d,",
            "s,",
            ")"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "Write(",
          "container": "rocessAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-process/src/ProcessAgent.cc",
          "lines": "248-297",
          "snippet": "CPBoolean ProcessAgent::Write(const YCPPath &path, const YCPValue& value,\n    const YCPValue& arg)\n{\n    if (!path->isRoot())\n    {\n\ty2error(\"Unsupported path in Write(): %s\", path->toString().c_str());\n\treturn YCPNull();\n    }\n\n    if (value.isNull() || !value->isInteger())\n    {\n\ty2error(\"ID of the process is missing\");\n\treturn YCPNull();\n    }\n\n    pid_t id = value->asInteger()->value();\n\n    y2debug(\"Writing to %d\", id);\n\n    ProcessContainer::iterator proc(_processes.find(id));\n\n    if (proc == _processes.end())\n    {\n\ty2error(\"Process '%d' not found\", id);\n\treturn YCPNull();\n    }\n\n    if (!arg.isNull() && arg->isString())\n    {\n\tif (!proc->second->running())\n\t{\n\t    y2warning(\"Process '%d' is not running, cannot write to stdin!\", id);\n\t    return YCPBoolean(false);\n\t}\n\t/**\n\t * @builtin Write(.process, integer id, input_string) -> boolean\n\t * Wrtites the input string to stdin of the process. Returns true on success.\n\t *\n\t * @example Write(.process, 12345, \"foo\") -> true\n\t */\n\n\treturn YCPBoolean(proc->second->send(arg->asString()->value()));\n    }\n    else\n    {\n\t// wrong type of the arg\n\ty2error(\"Value '%s' is not a string\", arg->toString().c_str());\n\treturn YCPBoolean(false);\n    }\n}",
          "includes": [
            "include <y2util/ExternalProgram.h>",
            "include <y2util/Process.h>",
            "include \"ProcessAgent.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <y2util/ExternalProgram.h>\ninclude <y2util/Process.h>\ninclude \"ProcessAgent.h\"\n#\n\nrocessAgent {\n  CPBoolean ProcessAgent::Write(const YCPPath &path, const YCPValue& value,\n      const YCPValue& arg)\n  {\n      if (!path->isRoot())\n      {\n  \ty2error(\"Unsupported path in Write(): %s\", path->toString().c_str());\n  \treturn YCPNull();\n      }\n  \n      if (value.isNull() || !value->isInteger())\n      {\n  \ty2error(\"ID of the process is missing\");\n  \treturn YCPNull();\n      }\n  \n      pid_t id = value->asInteger()->value();\n  \n      y2debug(\"Writing to %d\", id);\n  \n      ProcessContainer::iterator proc(_processes.find(id));\n  \n      if (proc == _processes.end())\n      {\n  \ty2error(\"Process '%d' not found\", id);\n  \treturn YCPNull();\n      }\n  \n      if (!arg.isNull() && arg->isString())\n      {\n  \tif (!proc->second->running())\n  \t{\n  \t    y2warning(\"Process '%d' is not running, cannot write to stdin!\", id);\n  \t    return YCPBoolean(false);\n  \t}\n  \t/**\n  \t * @builtin Write(.process, integer id, input_string) -> boolean\n  \t * Wrtites the input string to stdin of the process. Returns true on success.\n  \t *\n  \t * @example Write(.process, 12345, \"foo\") -> true\n  \t */\n  \n  \treturn YCPBoolean(proc->second->send(arg->asString()->value()));\n      }\n      else\n      {\n  \t// wrong type of the arg\n  \ty2error(\"Value '%s' is not a string\", arg->toString().c_str());\n  \treturn YCPBoolean(false);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": ".size",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": ".c_str",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <errno.h>\n}\ninclude <signal.h>\n#\ninclude <sys/select.h>\n#\ninclude <iostream>\ninclude <y2util/Process.h>\n#\n\noid output(const std::string & s, int fd)\n{\n    const char *cs = s.c_str();\n    ssize_t n = s.size();\n    while (true) {\n\tssize_t w = write(fd, cs, n);\n\tif (w == n)\n\t    break;\t\t// success\n\telse if (w == -1) {\n\t    if (errno == EINTR) {\n\t\t// perror(\"gotcha\"); // bnc#470645\n\t    }\n\t    else {\n\t\tperror(\"write\"); // other cases\n\t\tbreak;\n\t    }\n\t}\n\telse {\n\t    errno = 0;\n\t    perror(\"short\");\n\t    cs += w;\n\t    n -= w;\n\t}\n    }\n}"
  },
  {
    "function_name": "egisterSignalHandler(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/tty_wrapper/tty_wrapper.cc",
    "lines": "58-74",
    "snippet": "ool registerSignalHandler()\n{\n    struct sigaction new_action, old_action;\n\n    // use sa_sigaction parameter\n    new_action.sa_flags = SA_SIGINFO;\n    new_action.sa_sigaction = &sig_chld_handler;\n    ::sigemptyset(&new_action.sa_mask);\n\n    if (::sigaction(SIGCHLD, &new_action, &old_action))\n    {\n\tstd::cerr << \"Cannot register SIGCHLD handler!\\n\";\n\treturn false;\n    }\n\n    return true;\n}",
    "includes": [
      "include <errno.h>\n}",
      "include <signal.h>\n#",
      "include <sys/select.h>\n#",
      "include <iostream>",
      "include <y2util/Process.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ":sigaction(",
          "args": [
            "IGCHLD,",
            "new_action,",
            "old_action)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ":sigemptyset(",
          "args": [
            "new_action.sa_mask)"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <errno.h>\n}\ninclude <signal.h>\n#\ninclude <sys/select.h>\n#\ninclude <iostream>\ninclude <y2util/Process.h>\n#\n\nool registerSignalHandler()\n{\n    struct sigaction new_action, old_action;\n\n    // use sa_sigaction parameter\n    new_action.sa_flags = SA_SIGINFO;\n    new_action.sa_sigaction = &sig_chld_handler;\n    ::sigemptyset(&new_action.sa_mask);\n\n    if (::sigaction(SIGCHLD, &new_action, &old_action))\n    {\n\tstd::cerr << \"Cannot register SIGCHLD handler!\\n\";\n\treturn false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "ig_chld_handler(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/tty_wrapper/tty_wrapper.cc",
    "lines": "48-55",
    "snippet": "oid sig_chld_handler(int signal, siginfo_t *info, void *data)\n{\n    if (signal == SIGCHLD)\n    {\n\t// set the finish flag for the main loop\n\tfinish = true;\n    }\n}",
    "includes": [
      "include <errno.h>\n}",
      "include <signal.h>\n#",
      "include <sys/select.h>\n#",
      "include <iostream>",
      "include <y2util/Process.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic sig_atomic_t finish = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "include <errno.h>\n}\ninclude <signal.h>\n#\ninclude <sys/select.h>\n#\ninclude <iostream>\ninclude <y2util/Process.h>\n#\n\ntatic sig_atomic_t finish = false;\n\noid sig_chld_handler(int signal, siginfo_t *info, void *data)\n{\n    if (signal == SIGCHLD)\n    {\n\t// set the finish flag for the main loop\n\tfinish = true;\n    }\n}"
  }
]