[
  {
    "function_name": "setTracing",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "565-568",
    "snippet": "void Debugger::setTracing (bool enable)\n{\n    m_tracing = enable;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::setTracing (bool enable)\n  {\n      m_tracing = enable;\n  }\n}"
  },
  {
    "function_name": "tracing",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "560-563",
    "snippet": "bool Debugger::tracing () const\n{\n    return m_tracing;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  bool Debugger::tracing () const\n  {\n      return m_tracing;\n  }\n}"
  },
  {
    "function_name": "popBlock",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "555-558",
    "snippet": "void Debugger::popBlock ()\n{\n    m_blockstack.pop_front ();\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_blockstack.pop_front",
          "args": [],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::popBlock ()\n  {\n      m_blockstack.pop_front ();\n  }\n}"
  },
  {
    "function_name": "pushBlock",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "546-553",
    "snippet": "void Debugger::pushBlock (Y2Namespace* block, bool tracing)\n{\n    stackitem_t si;\n    si.ns = block;\n    si.tracing = tracing;\n    \n    m_blockstack.push_front (si);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_blockstack.push_front",
          "args": [
            "si"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::pushBlock (Y2Namespace* block, bool tracing)\n  {\n      stackitem_t si;\n      si.ns = block;\n      si.tracing = tracing;\n      \n      m_blockstack.push_front (si);\n  }\n}"
  },
  {
    "function_name": "tracing",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "536-544",
    "snippet": "bool Debugger::tracing (Y2Namespace* block) const\n{\n    for( std::list<stackitem_t>::const_iterator it = m_blockstack.begin (); it != m_blockstack.end (); it++)\n    {\n\tif ( it->ns == block )\n\t    return it->tracing;\n    }\n    return false;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_blockstack.end",
          "args": [],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_blockstack.begin",
          "args": [],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  bool Debugger::tracing (Y2Namespace* block) const\n  {\n      for( std::list<stackitem_t>::const_iterator it = m_blockstack.begin (); it != m_blockstack.end (); it++)\n      {\n  \tif ( it->ns == block )\n  \t    return it->tracing;\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "enableTracing",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "526-534",
    "snippet": "void Debugger::enableTracing (Y2Namespace* block, bool enable)\n {\n    for( std::list<stackitem_t>::iterator it = m_blockstack.begin (); it != m_blockstack.end (); it++)\n    {\n\tif ( it->ns == block )\n\t    it->tracing = enable;\n\treturn;\n    }\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_blockstack.end",
          "args": [],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_blockstack.begin",
          "args": [],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::enableTracing (Y2Namespace* block, bool enable)\n   {\n      for( std::list<stackitem_t>::iterator it = m_blockstack.begin (); it != m_blockstack.end (); it++)\n      {\n  \tif ( it->ns == block )\n  \t    it->tracing = enable;\n  \treturn;\n      }\n  }\n}"
  },
  {
    "function_name": "stashOutput",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "521-524",
    "snippet": "void Debugger::stashOutput( std::string output )\n{\n    m_outputstash += output;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::stashOutput( std::string output )\n  {\n      m_outputstash += output;\n  }\n}"
  },
  {
    "function_name": "sendOutput",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "507-519",
    "snippet": "bool Debugger::sendOutput( std::string output )\n{\n    output = m_outputstash + output;\n    y2debug (\"Sending out output %s\", output.c_str() );\n    if( output.empty() )\n\toutput = \" \";\n    output = output + \"\\n<EOF>\\n\";\n    send (m_ns, output.c_str (), strlen( output.c_str ()), 0);\n    \n    // clean up the output stash, it's sent already\n    m_outputstash = \"\";\n    return true;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send",
          "args": [
            "m_ns",
            "output.c_str ()",
            "strlen( output.c_str ())",
            "0"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "output.c_str ()"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.c_str",
          "args": [],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.c_str",
          "args": [],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.empty",
          "args": [],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Sending out output %s\"",
            "output.c_str()"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.c_str",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  bool Debugger::sendOutput( std::string output )\n  {\n      output = m_outputstash + output;\n      y2debug (\"Sending out output %s\", output.c_str() );\n      if( output.empty() )\n  \toutput = \" \";\n      output = output + \"\\n<EOF>\\n\";\n      send (m_ns, output.c_str (), strlen( output.c_str ()), 0);\n      \n      // clean up the output stash, it's sent already\n      m_outputstash = \"\";\n      return true;\n  }\n}"
  },
  {
    "function_name": "processInput",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "387-505",
    "snippet": "bool Debugger::processInput (command_t &command, std::list<std::string> &arguments)\n{\n    char c;\n    std::string s;\n    std::list<std::string> args;\n\n    // FIXME: use flex\n    if (m_descriptor == NULL)\n\treturn false;\n\t\n    // First, send the current context\n    YStatementPtr statement = ee.statement ();\n    \nafter_internal:\n    if (statement)\n\tsendOutput (ee.filename() + \":\" + stringutil::numstring(ee.linenumber()) + \" >>> \" + statement->toString ());\n    else\n\tsendOutput (\"no code\");\n    \n    // clean up for next command\n    s = \"\";\n    args.clear();\n\n    while ((c = fgetc (m_descriptor)) != EOF)\n    {\n\tif (c == '\\n')\n\t{\n\t    break;\n\t}\n\ts += c;\n    }\n    \n    if (s.empty ())\n    {\n\ty2error (\"Communication with debugging UI closed\");\n\tclose (m_socket);\n\t\n\tif (m_remote)\n\t    unlink (ADDRESS);\n\n\tm_socket = -1;\n\tm_descriptor = NULL;\n\treturn false;\n    }\n    \n    command = c_unknown;\n    // FIXME: I said flex!\n    if (s == \"c\")\n    {\n\tcommand = Debugger::c_continue;\n    }\n    else if (s == \"n\")\n    {\n\tcommand = Debugger::c_next;\n    }\n    else if (s == \"s\")\n    {\n\tcommand = Debugger::c_step;\n    }\n    else if (s == \"bt\")\n    {\n\tcommand = Debugger::c_backtrace;\n    }\n    else if (s[0] == 'v')\n    {\n\tcommand = Debugger::c_setvalue;\n\targs.push_back(s.substr(2));\n    }\n    else if ( s[0] == 'b' )\n    {\n\tcommand = Debugger::c_breakpoint;\n\targs.push_back(s.substr(2));\n    }\n    else if ( s[0] == 'r' && s[1] == 'b')\n    {\n\tcommand = Debugger::c_removebreakpoint;\n\targs.push_back(s.substr(3));\n    }\n    else if (s[0] == 'p')\n    {\n\tcommand = Debugger::c_print;\n\targs.push_back(s.substr(2));\n    }\n    \n    if (command == Debugger::c_print)\n    {\n\tprintVariable (args.front () );\n\tgoto after_internal;\n    }\n    \n    if (command == Debugger::c_breakpoint)\n    {\n\tsetBreakpoint (args);\n\tgoto after_internal;\n    }\n\n    if (command == Debugger::c_removebreakpoint)\n    {\n\tremoveBreakpoint (args);\n\tgoto after_internal;\n    }\n\n    if (command == Debugger::c_backtrace)\n    {\n\tgenerateBacktrace ();\n\tgoto after_internal;\n    }\n    \n    if (command == Debugger::c_setvalue)\n    {\n\tsetVariable (args.front () );\n\tgoto after_internal;\n    }\n    \n    arguments = args;\n    m_last_command = command;\n\n    return true;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [
      "#define ADDRESS     \"/tmp/yast.socket\""
    ],
    "globals_used": [
      "extern ExecutionEnvironment ee;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "setVariable",
          "args": [
            "args.front ()"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "setVariable",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "348-385",
          "snippet": "void Debugger::setVariable (std::string assign)\n{\n    // first, split by '='\n    std::vector<std::string> words;\n    stringutil::split(assign, words, \"=\");\n    \n    if( words.size() != 2 )\n    {\n\tsendOutput (\"Set variable format is <name>=<constant>\");\n\treturn;\n    }\n\n    SymbolEntryPtr sentry = findSymbol (words.front ());\n\n    if (sentry)\n    {\n\tif( !sentry->isVariable ())\n\t    sendOutput (\"Identifier is not a variable\");\n\telse\n\t{\n\t    // set the new value\n\t    Parser parser (words[1].c_str()); // set parser to value\n\n\t    YCodePtr pc = parser.parse ();\n\t    if (!pc )\n\t    {\n\t\tsendOutput (\"Cannot parse new value\");\n\t    }\n\t    else\n\t    {\n\t\tsentry->setValue (pc->evaluate (true));   // set the new value\n\t\tsendOutput ( std::string(sentry->name ()) + \" = \" + sentry->value ()->toString () );\n\t    }\n\t}\n    }\n    else\n\tsendOutput (\"Identifier not found\");\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::setVariable (std::string assign)\n  {\n      // first, split by '='\n      std::vector<std::string> words;\n      stringutil::split(assign, words, \"=\");\n      \n      if( words.size() != 2 )\n      {\n  \tsendOutput (\"Set variable format is <name>=<constant>\");\n  \treturn;\n      }\n  \n      SymbolEntryPtr sentry = findSymbol (words.front ());\n  \n      if (sentry)\n      {\n  \tif( !sentry->isVariable ())\n  \t    sendOutput (\"Identifier is not a variable\");\n  \telse\n  \t{\n  \t    // set the new value\n  \t    Parser parser (words[1].c_str()); // set parser to value\n  \n  \t    YCodePtr pc = parser.parse ();\n  \t    if (!pc )\n  \t    {\n  \t\tsendOutput (\"Cannot parse new value\");\n  \t    }\n  \t    else\n  \t    {\n  \t\tsentry->setValue (pc->evaluate (true));   // set the new value\n  \t\tsendOutput ( std::string(sentry->name ()) + \" = \" + sentry->value ()->toString () );\n  \t    }\n  \t}\n      }\n      else\n  \tsendOutput (\"Identifier not found\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "args.front",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generateBacktrace",
          "args": [],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "generateBacktrace",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "234-269",
          "snippet": "void Debugger::generateBacktrace ()\n{\n    std::string result = \"Call stack:\";\n    ExecutionEnvironment::CallStack stack = ee.callstack();\n    ExecutionEnvironment::CallStack::const_reverse_iterator it = stack.rbegin();\n    while (it != stack.rend())\n    {\n        result = result \n    \t  + \"\\n\"\n    \t  + ( (*it)->filename ) \n          + \":\" \n          + stringutil::numstring((*it)->linenumber) \n          + \": \"\n          + ((*it)->function->entry()->toString());\n\n        int paramcount = ((constFunctionTypePtr)((*it)->function->entry()->type()))->parameterCount();\n        if( paramcount > 0 )\n\t\tresult += \" with paramters: \";\n        for( int i = 0; i < paramcount ; i++ )\n        {\n          string param = (*it)->params[0]->toString();\n          if (param.length() > 80)\n          {\n              param = \"<too long>\";\n          }\n          result += param;\n          if (i < paramcount - 1)\n          {\n            result += \", \";\n          }\n        }\n        ++it;\n    };\n\n    sendOutput (result);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ExecutionEnvironment ee;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nextern ExecutionEnvironment ee;\n\nDebugger {\n  void Debugger::generateBacktrace ()\n  {\n      std::string result = \"Call stack:\";\n      ExecutionEnvironment::CallStack stack = ee.callstack();\n      ExecutionEnvironment::CallStack::const_reverse_iterator it = stack.rbegin();\n      while (it != stack.rend())\n      {\n          result = result \n      \t  + \"\\n\"\n      \t  + ( (*it)->filename ) \n            + \":\" \n            + stringutil::numstring((*it)->linenumber) \n            + \": \"\n            + ((*it)->function->entry()->toString());\n  \n          int paramcount = ((constFunctionTypePtr)((*it)->function->entry()->type()))->parameterCount();\n          if( paramcount > 0 )\n  \t\tresult += \" with paramters: \";\n          for( int i = 0; i < paramcount ; i++ )\n          {\n            string param = (*it)->params[0]->toString();\n            if (param.length() > 80)\n            {\n                param = \"<too long>\";\n            }\n            result += param;\n            if (i < paramcount - 1)\n            {\n              result += \", \";\n            }\n          }\n          ++it;\n      };\n  \n      sendOutput (result);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "removeBreakpoint",
          "args": [
            "args"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "removeBreakpoint",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "208-232",
          "snippet": "void Debugger::removeBreakpoint (std::list<std::string> &args)\n{\n    SymbolEntryPtr sentry = findSymbol (args.front ());\n\n    if (sentry)\n    {\n\tif( !sentry->isFunction ())\n\t    sendOutput (\"Identifier is not a function\");\n\telse\n\t{\n\t    YFunctionPtr fnc = ((YFunctionPtr)((YSymbolEntryPtr)sentry)->code());\n\t\n\t    if (fnc->definition ()->kind () == YCode::yiBreakpoint)\n\t    {\n\t\t// disable the breakpoint wrapper\n\t\t((YBreakpointPtr)fnc->definition ())->setEnabled (false);\n\t\tsendOutput (\"Breakpoint disabled\");\n\t\treturn;\n\t    }\n\t    sendOutput (\"Breakpoint not found\");\n\t}\n    }\n    else\n\tsendOutput (\"Identifier not found\");\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::removeBreakpoint (std::list<std::string> &args)\n  {\n      SymbolEntryPtr sentry = findSymbol (args.front ());\n  \n      if (sentry)\n      {\n  \tif( !sentry->isFunction ())\n  \t    sendOutput (\"Identifier is not a function\");\n  \telse\n  \t{\n  \t    YFunctionPtr fnc = ((YFunctionPtr)((YSymbolEntryPtr)sentry)->code());\n  \t\n  \t    if (fnc->definition ()->kind () == YCode::yiBreakpoint)\n  \t    {\n  \t\t// disable the breakpoint wrapper\n  \t\t((YBreakpointPtr)fnc->definition ())->setEnabled (false);\n  \t\tsendOutput (\"Breakpoint disabled\");\n  \t\treturn;\n  \t    }\n  \t    sendOutput (\"Breakpoint not found\");\n  \t}\n      }\n      else\n  \tsendOutput (\"Identifier not found\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setBreakpoint",
          "args": [
            "args"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "setBreakpoint",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "177-206",
          "snippet": "void Debugger::setBreakpoint (std::list<std::string> &args)\n{\n    SymbolEntryPtr sentry = findSymbol (args.front ());\n\n    if (sentry)\n    {\n\tif( !sentry->isFunction ())\n\t    sendOutput (\"Identifier is not a function\");\n\telse\n\t{\n\t    YFunctionPtr fnc = ((YFunctionPtr)((YSymbolEntryPtr)sentry)->code());\n\t\n\t    // set the breakpoint wrapper\n\t    if (fnc->definition ()->kind () == YCode::yiBreakpoint)\n\t    {\n\t\t((YBreakpointPtr)fnc->definition ())->setEnabled (true);\n\t\tsendOutput (\"Breakpoint enabled\");\n\t\treturn;\n\t    }\n\t\n\t    YBreakpointPtr bp = new YBreakpoint (fnc->definition(), args.front () );\n\t\n\t    fnc->setDefinition (bp);\n\t    std::string result = \"Set breakpoint to \" + sentry->toString();\n\t    sendOutput (result);\n\t}\n    }\n    else\n\tsendOutput (\"Identifier not found\");\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::setBreakpoint (std::list<std::string> &args)\n  {\n      SymbolEntryPtr sentry = findSymbol (args.front ());\n  \n      if (sentry)\n      {\n  \tif( !sentry->isFunction ())\n  \t    sendOutput (\"Identifier is not a function\");\n  \telse\n  \t{\n  \t    YFunctionPtr fnc = ((YFunctionPtr)((YSymbolEntryPtr)sentry)->code());\n  \t\n  \t    // set the breakpoint wrapper\n  \t    if (fnc->definition ()->kind () == YCode::yiBreakpoint)\n  \t    {\n  \t\t((YBreakpointPtr)fnc->definition ())->setEnabled (true);\n  \t\tsendOutput (\"Breakpoint enabled\");\n  \t\treturn;\n  \t    }\n  \t\n  \t    YBreakpointPtr bp = new YBreakpoint (fnc->definition(), args.front () );\n  \t\n  \t    fnc->setDefinition (bp);\n  \t    std::string result = \"Set breakpoint to \" + sentry->toString();\n  \t    sendOutput (result);\n  \t}\n      }\n      else\n  \tsendOutput (\"Identifier not found\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printVariable",
          "args": [
            "args.front ()"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "printVariable",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "328-346",
          "snippet": "void Debugger::printVariable (std::string arg)\n{\n    SymbolEntryPtr sentry = findSymbol (arg);\n\n    if (sentry)\n    {\n\tif( !sentry->isVariable ())\n\t    sendOutput (\"Identifier is not a variable\");\n\telse\n\t{\n\t    if( sentry->value().isNull() )\n\t\tsendOutput (\"nil\");\n\t    else\n\t\tsendOutput (sentry->value()->toString());\n\t}\n    }\n    else\n\tsendOutput (\"Identifier not found\");\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::printVariable (std::string arg)\n  {\n      SymbolEntryPtr sentry = findSymbol (arg);\n  \n      if (sentry)\n      {\n  \tif( !sentry->isVariable ())\n  \t    sendOutput (\"Identifier is not a variable\");\n  \telse\n  \t{\n  \t    if( sentry->value().isNull() )\n  \t\tsendOutput (\"nil\");\n  \t    else\n  \t\tsendOutput (sentry->value()->toString());\n  \t}\n      }\n      else\n  \tsendOutput (\"Identifier not found\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "args.front",
          "args": [],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.push_back",
          "args": [
            "s.substr(2)"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.substr",
          "args": [
            "2"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.substr",
          "args": [
            "3"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.substr",
          "args": [
            "2"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.substr",
          "args": [
            "2"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "ADDRESS"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "unlink",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "541-548",
          "snippet": "int PathInfo::unlink( const Pathname & path )\n{\n  DBG << \"unlink \" << path;\n  if ( ::unlink( path.asString().c_str() ) == -1 ) {\n    return _Log_Result( errno );\n  }\n  return _Log_Result( 0 );\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::unlink( const Pathname & path )\n  {\n    DBG << \"unlink \" << path;\n    if ( ::unlink( path.asString().c_str() ) == -1 ) {\n      return _Log_Result( errno );\n    }\n    return _Log_Result( 0 );\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "m_socket"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Communication with debugging UI closed\""
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.empty",
          "args": [],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgetc",
          "args": [
            "m_descriptor"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.clear",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/PathInfo.h",
          "lines": "461-461",
          "snippet": "void clear() { _devino.clear(); }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <map>",
            "#include <set>",
            "#include <list>",
            "#include <iosfwd>",
            "#include <cerrno>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <map>\n#include <set>\n#include <list>\n#include <iosfwd>\n#include <cerrno>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid clear() { _devino.clear(); }"
        }
      },
      {
        "call_info": {
          "callee": "sendOutput",
          "args": [
            "\"no code\""
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "sendOutput",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "507-519",
          "snippet": "bool Debugger::sendOutput( std::string output )\n{\n    output = m_outputstash + output;\n    y2debug (\"Sending out output %s\", output.c_str() );\n    if( output.empty() )\n\toutput = \" \";\n    output = output + \"\\n<EOF>\\n\";\n    send (m_ns, output.c_str (), strlen( output.c_str ()), 0);\n    \n    // clean up the output stash, it's sent already\n    m_outputstash = \"\";\n    return true;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  bool Debugger::sendOutput( std::string output )\n  {\n      output = m_outputstash + output;\n      y2debug (\"Sending out output %s\", output.c_str() );\n      if( output.empty() )\n  \toutput = \" \";\n      output = output + \"\\n<EOF>\\n\";\n      send (m_ns, output.c_str (), strlen( output.c_str ()), 0);\n      \n      // clean up the output stash, it's sent already\n      m_outputstash = \"\";\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "statement->toString",
          "args": [],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stringutil::numstring",
          "args": [
            "ee.linenumber()"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "numstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/stringutil.h",
          "lines": "110-110",
          "snippet": "inline std::string numstring( unsigned long long n, int w = 0 ) { return form( \"%*llu\",  w, n ); }",
          "includes": [
            "#include <list>",
            "#include <string>",
            "#include <vector>",
            "#include <iosfwd>",
            "#include <cstdlib>",
            "#include <cstdarg>",
            "#include <cstdio>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <string>\n#include <vector>\n#include <iosfwd>\n#include <cstdlib>\n#include <cstdarg>\n#include <cstdio>\n\ninline std::string numstring( unsigned long long n, int w = 0 ) { return form( \"%*llu\",  w, n ); }"
        }
      },
      {
        "call_info": {
          "callee": "ee.linenumber",
          "args": [],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "linenumber",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "41-45",
          "snippet": "int\nExecutionEnvironment::linenumber () const\n{\n    return m_linenumber;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  int\n  ExecutionEnvironment::linenumber () const\n  {\n      return m_linenumber;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.filename",
          "args": [],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "filename",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "335-339",
          "snippet": "string\nScanner::filename () const\n{\n    return m_filename;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  string\n  Scanner::filename () const\n  {\n      return m_filename;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.statement",
          "args": [],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "statement",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "71-75",
          "snippet": "YStatementPtr\nExecutionEnvironment::statement () const\n{\n    return m_statement;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  YStatementPtr\n  ExecutionEnvironment::statement () const\n  {\n      return m_statement;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\n#define ADDRESS     \"/tmp/yast.socket\"\n\nextern ExecutionEnvironment ee;\n\nDebugger {\n  bool Debugger::processInput (command_t &command, std::list<std::string> &arguments)\n  {\n      char c;\n      std::string s;\n      std::list<std::string> args;\n  \n      // FIXME: use flex\n      if (m_descriptor == NULL)\n  \treturn false;\n  \t\n      // First, send the current context\n      YStatementPtr statement = ee.statement ();\n      \n  after_internal:\n      if (statement)\n  \tsendOutput (ee.filename() + \":\" + stringutil::numstring(ee.linenumber()) + \" >>> \" + statement->toString ());\n      else\n  \tsendOutput (\"no code\");\n      \n      // clean up for next command\n      s = \"\";\n      args.clear();\n  \n      while ((c = fgetc (m_descriptor)) != EOF)\n      {\n  \tif (c == '\\n')\n  \t{\n  \t    break;\n  \t}\n  \ts += c;\n      }\n      \n      if (s.empty ())\n      {\n  \ty2error (\"Communication with debugging UI closed\");\n  \tclose (m_socket);\n  \t\n  \tif (m_remote)\n  \t    unlink (ADDRESS);\n  \n  \tm_socket = -1;\n  \tm_descriptor = NULL;\n  \treturn false;\n      }\n      \n      command = c_unknown;\n      // FIXME: I said flex!\n      if (s == \"c\")\n      {\n  \tcommand = Debugger::c_continue;\n      }\n      else if (s == \"n\")\n      {\n  \tcommand = Debugger::c_next;\n      }\n      else if (s == \"s\")\n      {\n  \tcommand = Debugger::c_step;\n      }\n      else if (s == \"bt\")\n      {\n  \tcommand = Debugger::c_backtrace;\n      }\n      else if (s[0] == 'v')\n      {\n  \tcommand = Debugger::c_setvalue;\n  \targs.push_back(s.substr(2));\n      }\n      else if ( s[0] == 'b' )\n      {\n  \tcommand = Debugger::c_breakpoint;\n  \targs.push_back(s.substr(2));\n      }\n      else if ( s[0] == 'r' && s[1] == 'b')\n      {\n  \tcommand = Debugger::c_removebreakpoint;\n  \targs.push_back(s.substr(3));\n      }\n      else if (s[0] == 'p')\n      {\n  \tcommand = Debugger::c_print;\n  \targs.push_back(s.substr(2));\n      }\n      \n      if (command == Debugger::c_print)\n      {\n  \tprintVariable (args.front () );\n  \tgoto after_internal;\n      }\n      \n      if (command == Debugger::c_breakpoint)\n      {\n  \tsetBreakpoint (args);\n  \tgoto after_internal;\n      }\n  \n      if (command == Debugger::c_removebreakpoint)\n      {\n  \tremoveBreakpoint (args);\n  \tgoto after_internal;\n      }\n  \n      if (command == Debugger::c_backtrace)\n      {\n  \tgenerateBacktrace ();\n  \tgoto after_internal;\n      }\n      \n      if (command == Debugger::c_setvalue)\n      {\n  \tsetVariable (args.front () );\n  \tgoto after_internal;\n      }\n      \n      arguments = args;\n      m_last_command = command;\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "setVariable",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "348-385",
    "snippet": "void Debugger::setVariable (std::string assign)\n{\n    // first, split by '='\n    std::vector<std::string> words;\n    stringutil::split(assign, words, \"=\");\n    \n    if( words.size() != 2 )\n    {\n\tsendOutput (\"Set variable format is <name>=<constant>\");\n\treturn;\n    }\n\n    SymbolEntryPtr sentry = findSymbol (words.front ());\n\n    if (sentry)\n    {\n\tif( !sentry->isVariable ())\n\t    sendOutput (\"Identifier is not a variable\");\n\telse\n\t{\n\t    // set the new value\n\t    Parser parser (words[1].c_str()); // set parser to value\n\n\t    YCodePtr pc = parser.parse ();\n\t    if (!pc )\n\t    {\n\t\tsendOutput (\"Cannot parse new value\");\n\t    }\n\t    else\n\t    {\n\t\tsentry->setValue (pc->evaluate (true));   // set the new value\n\t\tsendOutput ( std::string(sentry->name ()) + \" = \" + sentry->value ()->toString () );\n\t    }\n\t}\n    }\n    else\n\tsendOutput (\"Identifier not found\");\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendOutput",
          "args": [
            "\"Identifier not found\""
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "sendOutput",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "507-519",
          "snippet": "bool Debugger::sendOutput( std::string output )\n{\n    output = m_outputstash + output;\n    y2debug (\"Sending out output %s\", output.c_str() );\n    if( output.empty() )\n\toutput = \" \";\n    output = output + \"\\n<EOF>\\n\";\n    send (m_ns, output.c_str (), strlen( output.c_str ()), 0);\n    \n    // clean up the output stash, it's sent already\n    m_outputstash = \"\";\n    return true;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  bool Debugger::sendOutput( std::string output )\n  {\n      output = m_outputstash + output;\n      y2debug (\"Sending out output %s\", output.c_str() );\n      if( output.empty() )\n  \toutput = \" \";\n      output = output + \"\\n<EOF>\\n\";\n      send (m_ns, output.c_str (), strlen( output.c_str ()), 0);\n      \n      // clean up the output stash, it's sent already\n      m_outputstash = \"\";\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sentry->value",
          "args": [],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "sentry->name ()"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sentry->name",
          "args": [],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2AgentComp",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "44-44",
          "snippet": "string name () const { return my_name; }",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp {\n  string name () const { return my_name; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sentry->setValue",
          "args": [
            "pc->evaluate (true)"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "IniEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "155-155",
          "snippet": "void setValue(const string&c)   { dirty = true; val = c;     }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniEntry {\n  void setValue(const string&c)   { dirty = true; val = c;     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pc->evaluate",
          "args": [
            "true"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2AgentComp<Agent>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "91-166",
          "snippet": "YCPValue\nY2AgentComp<Agent>::evaluate (const YCPValue& v)\n{\n    y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n\n    if (!agent)\n\tgetSCRAgent ();\n\n    y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n\t\n    YCPValue value = v;\n    if (value->isCode ())\n    {\n\tYCodePtr c = v->asCode ()->code ();\n\n\t\n\tif ( c->kind () != YCode::yeTerm)\n\t{\n\t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n\t    value = value->asCode ()->evaluate ();\n\t    return value;\n\t}\n\n\tvalue = value->asCode ()->evaluate ();\n    }\n\t\n    if (value.isNull () || value->isVoid ())\n\treturn value;\n\n    y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n\n    if( value->isTerm () ) {\n\tYCPTerm term = value ->asTerm ();\n\tstring command = term->name ();\n\tYCPList args = term->args ();\n\n\t// evaluate the term in native functions\n\tif( command == \"Read\" ) {\n\t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n\t}\n\telse if( command == \"Write\" ) {\n\t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n\t}\n\telse if( command == \"Dir\" ) {\n\t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Error\" ) {\n\t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Execute\" ) {\n\t    y2debug( \"Execute, arg size is %d\", args->size() );\n\t    switch( args->size() ) {\n\t\tcase 1:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n\t\tcase 2:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n\t\tdefault:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n\t    }\n\t}\n\telse {\n\t    y2debug( \"Passing term to otherCommand\" );\n\t    return getSCRAgent ()-> otherCommand (term);\n\t}\n    }\n#if 0\n    if( value->isCode () ) {\n\ty2debug( \"Passing (evaluated) code to otherCommand\" );\n\treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n    }\n#endif\n\n    y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n\n    return YCPVoid();\n}",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp<Agent> {\n  YCPValue\n  Y2AgentComp<Agent>::evaluate (const YCPValue& v)\n  {\n      y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n  \n      if (!agent)\n  \tgetSCRAgent ();\n  \n      y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n  \t\n      YCPValue value = v;\n      if (value->isCode ())\n      {\n  \tYCodePtr c = v->asCode ()->code ();\n  \n  \t\n  \tif ( c->kind () != YCode::yeTerm)\n  \t{\n  \t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n  \t    value = value->asCode ()->evaluate ();\n  \t    return value;\n  \t}\n  \n  \tvalue = value->asCode ()->evaluate ();\n      }\n  \t\n      if (value.isNull () || value->isVoid ())\n  \treturn value;\n  \n      y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n  \n      if( value->isTerm () ) {\n  \tYCPTerm term = value ->asTerm ();\n  \tstring command = term->name ();\n  \tYCPList args = term->args ();\n  \n  \t// evaluate the term in native functions\n  \tif( command == \"Read\" ) {\n  \t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Write\" ) {\n  \t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Dir\" ) {\n  \t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Error\" ) {\n  \t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Execute\" ) {\n  \t    y2debug( \"Execute, arg size is %d\", args->size() );\n  \t    switch( args->size() ) {\n  \t\tcase 1:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n  \t\tcase 2:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n  \t\tdefault:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n  \t    }\n  \t}\n  \telse {\n  \t    y2debug( \"Passing term to otherCommand\" );\n  \t    return getSCRAgent ()-> otherCommand (term);\n  \t}\n      }\n  #if 0\n      if( value->isCode () ) {\n  \ty2debug( \"Passing (evaluated) code to otherCommand\" );\n  \treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n      }\n  #endif\n  \n      y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n  \n      return YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.parse",
          "args": [],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "484-562",
          "snippet": "int IniParser::parse()\n{\n    if (multiple_files)\n    {\n\tglob_t do_files;\n\tint len = files.size ();\n\tint flags = 0;\n\tfor (int i = 0;i<len;i++)\n\t{\n\t    glob (files[i].c_str (),flags, NULL, &do_files);\n\t    flags = GLOB_APPEND;\n\t}\n\tchar**f = do_files.gl_pathv;\n\tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n\t{\n\t    int section_index = -1;\n\t    string section_name = *f;\n\t    //FIXME: create function out of it.\n\t    // do we have name rewrite rules?\n\t    for (size_t j = 0; j < rewrites.size (); j++)\n\t\t{\n\t\t    RegexMatch m (rewrites[j].rx, section_name);\n\t\t    if (m)\n\t\t    {\n\t\t\tsection_index = j;\n\t\t\tsection_name = m[1];\n\t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    // do we know about the file?\n\t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n\t    if (ff == multi_files.end())\n\t    {\n\t\t// new file\n\t\tif (scanner_start (*f))\n\t\t    y2error (\"Cannot open %s.\", *f);\n\t\telse\n\t\t{\n\t\t    FileDescr fdsc (*f);\n\t\t    multi_files[*f] = fdsc;\n\t\t    inifile.initSection (section_name, \"\", -1, section_index);\n\t\t    parse_helper(inifile.getSection(section_name.c_str()));\n\t\t    scanner_stop();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif ((*ff).second.changed ())\n\t\t{\n\t\t    if (scanner_start (*f))\n\t\t\ty2error (\"Cannot open %s.\", *f);\n\t\t    else\n\t\t    {\n\t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n\t\t\tFileDescr fdsc (*f);\n\t\t\tmulti_files [*f] = fdsc;\n\t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n\t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n\t\t\tscanner_stop();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tif (scanner_start (file.c_str()))\n\t    {\n\t\ty2error (\"Can not open %s.\", file.c_str());\n\t\treturn -1;\n\t    }\n\tparse_helper(inifile);\n\tscanner_stop();\n\ttimestamp = getTimeStamp ();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse()\n  {\n      if (multiple_files)\n      {\n  \tglob_t do_files;\n  \tint len = files.size ();\n  \tint flags = 0;\n  \tfor (int i = 0;i<len;i++)\n  \t{\n  \t    glob (files[i].c_str (),flags, NULL, &do_files);\n  \t    flags = GLOB_APPEND;\n  \t}\n  \tchar**f = do_files.gl_pathv;\n  \tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n  \t{\n  \t    int section_index = -1;\n  \t    string section_name = *f;\n  \t    //FIXME: create function out of it.\n  \t    // do we have name rewrite rules?\n  \t    for (size_t j = 0; j < rewrites.size (); j++)\n  \t\t{\n  \t\t    RegexMatch m (rewrites[j].rx, section_name);\n  \t\t    if (m)\n  \t\t    {\n  \t\t\tsection_index = j;\n  \t\t\tsection_name = m[1];\n  \t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \n  \t    // do we know about the file?\n  \t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n  \t    if (ff == multi_files.end())\n  \t    {\n  \t\t// new file\n  \t\tif (scanner_start (*f))\n  \t\t    y2error (\"Cannot open %s.\", *f);\n  \t\telse\n  \t\t{\n  \t\t    FileDescr fdsc (*f);\n  \t\t    multi_files[*f] = fdsc;\n  \t\t    inifile.initSection (section_name, \"\", -1, section_index);\n  \t\t    parse_helper(inifile.getSection(section_name.c_str()));\n  \t\t    scanner_stop();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif ((*ff).second.changed ())\n  \t\t{\n  \t\t    if (scanner_start (*f))\n  \t\t\ty2error (\"Cannot open %s.\", *f);\n  \t\t    else\n  \t\t    {\n  \t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n  \t\t\tFileDescr fdsc (*f);\n  \t\t\tmulti_files [*f] = fdsc;\n  \t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n  \t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n  \t\t\tscanner_stop();\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n      else\n      {\n  \tif (scanner_start (file.c_str()))\n  \t    {\n  \t\ty2error (\"Can not open %s.\", file.c_str());\n  \t\treturn -1;\n  \t    }\n  \tparse_helper(inifile);\n  \tscanner_stop();\n  \ttimestamp = getTimeStamp ();\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "words[1].c_str",
          "args": [],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sentry->isVariable",
          "args": [],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "isVariable",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "298-298",
          "snippet": "bool isVariable () const\t{ return m_kind == VariableT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isVariable () const\t{ return m_kind == VariableT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "findSymbol",
          "args": [
            "words.front ()"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "findSymbol",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "271-326",
          "snippet": "SymbolEntryPtr Debugger::findSymbol (std::string arg)\n{\n    std::vector<std::string> words;\n    SymbolEntryPtr sentry = NULL;\n\n    stringutil::split(arg, words, \":\");\n\n    if (words.size () > 1)\n    {\n\t// name contains namespace, handle here\n\tstd::string ns_name = words[0];\n\tstd::string name = words[1];\n\tY2Component* c = Y2ComponentBroker::getNamespaceComponent (ns_name.c_str());\n\tif( c )\n\t{\n\t    if (c->name () == \"wfm\")\n\t    {\n\t\tY2Namespace* ns = c->import (ns_name.c_str());\n\t\tif (ns) \n\t\t    // this returns NULL in case the name was not found\n\t\t    return ns->lookupSymbol (name.c_str());\n\t    }\n\t    else\n\t\treturn NULL; // this is not YCP symbol\n\t}\n    }\n    else \n    {\n\t// try parameters\n\tExecutionEnvironment::CallStack stack = ee.callstack();\n\t    \n\tif( stack.size() > 0 )\n\t{\n\t    ExecutionEnvironment::CallStack::const_reverse_iterator it = stack.rbegin();\n\t    \n    \t    YSymbolEntryPtr ysentry = (YSymbolEntryPtr)((*it)->function->entry());\n\n\t    // this returns NULL in case the name was not found\n\t    sentry = ((YFunctionPtr)ysentry->code())->declaration ()->lookupSymbol (words[0].c_str());\n\n\t    if (sentry)\n\t\treturn sentry;\n\t}\n\t    \n\t// try block stack\n\tfor( std::list<stackitem_t>::iterator blk = m_blockstack.begin(); blk != m_blockstack.end (); blk++)\n\t{\n\t    sentry = blk->ns->lookupSymbol (words[0].c_str());\n\t    if (sentry)\n\t\treturn sentry;\n\t}\n    }\n\n    // not found\n    return NULL;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ExecutionEnvironment ee;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nextern ExecutionEnvironment ee;\n\nDebugger {\n  SymbolEntryPtr Debugger::findSymbol (std::string arg)\n  {\n      std::vector<std::string> words;\n      SymbolEntryPtr sentry = NULL;\n  \n      stringutil::split(arg, words, \":\");\n  \n      if (words.size () > 1)\n      {\n  \t// name contains namespace, handle here\n  \tstd::string ns_name = words[0];\n  \tstd::string name = words[1];\n  \tY2Component* c = Y2ComponentBroker::getNamespaceComponent (ns_name.c_str());\n  \tif( c )\n  \t{\n  \t    if (c->name () == \"wfm\")\n  \t    {\n  \t\tY2Namespace* ns = c->import (ns_name.c_str());\n  \t\tif (ns) \n  \t\t    // this returns NULL in case the name was not found\n  \t\t    return ns->lookupSymbol (name.c_str());\n  \t    }\n  \t    else\n  \t\treturn NULL; // this is not YCP symbol\n  \t}\n      }\n      else \n      {\n  \t// try parameters\n  \tExecutionEnvironment::CallStack stack = ee.callstack();\n  \t    \n  \tif( stack.size() > 0 )\n  \t{\n  \t    ExecutionEnvironment::CallStack::const_reverse_iterator it = stack.rbegin();\n  \t    \n      \t    YSymbolEntryPtr ysentry = (YSymbolEntryPtr)((*it)->function->entry());\n  \n  \t    // this returns NULL in case the name was not found\n  \t    sentry = ((YFunctionPtr)ysentry->code())->declaration ()->lookupSymbol (words[0].c_str());\n  \n  \t    if (sentry)\n  \t\treturn sentry;\n  \t}\n  \t    \n  \t// try block stack\n  \tfor( std::list<stackitem_t>::iterator blk = m_blockstack.begin(); blk != m_blockstack.end (); blk++)\n  \t{\n  \t    sentry = blk->ns->lookupSymbol (words[0].c_str());\n  \t    if (sentry)\n  \t\treturn sentry;\n  \t}\n      }\n  \n      // not found\n      return NULL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "words.front",
          "args": [],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "words.size",
          "args": [],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stringutil::split",
          "args": [
            "assign",
            "words",
            "\"=\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::setVariable (std::string assign)\n  {\n      // first, split by '='\n      std::vector<std::string> words;\n      stringutil::split(assign, words, \"=\");\n      \n      if( words.size() != 2 )\n      {\n  \tsendOutput (\"Set variable format is <name>=<constant>\");\n  \treturn;\n      }\n  \n      SymbolEntryPtr sentry = findSymbol (words.front ());\n  \n      if (sentry)\n      {\n  \tif( !sentry->isVariable ())\n  \t    sendOutput (\"Identifier is not a variable\");\n  \telse\n  \t{\n  \t    // set the new value\n  \t    Parser parser (words[1].c_str()); // set parser to value\n  \n  \t    YCodePtr pc = parser.parse ();\n  \t    if (!pc )\n  \t    {\n  \t\tsendOutput (\"Cannot parse new value\");\n  \t    }\n  \t    else\n  \t    {\n  \t\tsentry->setValue (pc->evaluate (true));   // set the new value\n  \t\tsendOutput ( std::string(sentry->name ()) + \" = \" + sentry->value ()->toString () );\n  \t    }\n  \t}\n      }\n      else\n  \tsendOutput (\"Identifier not found\");\n  }\n}"
  },
  {
    "function_name": "printVariable",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "328-346",
    "snippet": "void Debugger::printVariable (std::string arg)\n{\n    SymbolEntryPtr sentry = findSymbol (arg);\n\n    if (sentry)\n    {\n\tif( !sentry->isVariable ())\n\t    sendOutput (\"Identifier is not a variable\");\n\telse\n\t{\n\t    if( sentry->value().isNull() )\n\t\tsendOutput (\"nil\");\n\t    else\n\t\tsendOutput (sentry->value()->toString());\n\t}\n    }\n    else\n\tsendOutput (\"Identifier not found\");\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendOutput",
          "args": [
            "\"Identifier not found\""
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "sendOutput",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "507-519",
          "snippet": "bool Debugger::sendOutput( std::string output )\n{\n    output = m_outputstash + output;\n    y2debug (\"Sending out output %s\", output.c_str() );\n    if( output.empty() )\n\toutput = \" \";\n    output = output + \"\\n<EOF>\\n\";\n    send (m_ns, output.c_str (), strlen( output.c_str ()), 0);\n    \n    // clean up the output stash, it's sent already\n    m_outputstash = \"\";\n    return true;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  bool Debugger::sendOutput( std::string output )\n  {\n      output = m_outputstash + output;\n      y2debug (\"Sending out output %s\", output.c_str() );\n      if( output.empty() )\n  \toutput = \" \";\n      output = output + \"\\n<EOF>\\n\";\n      send (m_ns, output.c_str (), strlen( output.c_str ()), 0);\n      \n      // clean up the output stash, it's sent already\n      m_outputstash = \"\";\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sentry->value",
          "args": [],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sentry->isVariable",
          "args": [],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "isVariable",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "298-298",
          "snippet": "bool isVariable () const\t{ return m_kind == VariableT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isVariable () const\t{ return m_kind == VariableT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "findSymbol",
          "args": [
            "arg"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "findSymbol",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "271-326",
          "snippet": "SymbolEntryPtr Debugger::findSymbol (std::string arg)\n{\n    std::vector<std::string> words;\n    SymbolEntryPtr sentry = NULL;\n\n    stringutil::split(arg, words, \":\");\n\n    if (words.size () > 1)\n    {\n\t// name contains namespace, handle here\n\tstd::string ns_name = words[0];\n\tstd::string name = words[1];\n\tY2Component* c = Y2ComponentBroker::getNamespaceComponent (ns_name.c_str());\n\tif( c )\n\t{\n\t    if (c->name () == \"wfm\")\n\t    {\n\t\tY2Namespace* ns = c->import (ns_name.c_str());\n\t\tif (ns) \n\t\t    // this returns NULL in case the name was not found\n\t\t    return ns->lookupSymbol (name.c_str());\n\t    }\n\t    else\n\t\treturn NULL; // this is not YCP symbol\n\t}\n    }\n    else \n    {\n\t// try parameters\n\tExecutionEnvironment::CallStack stack = ee.callstack();\n\t    \n\tif( stack.size() > 0 )\n\t{\n\t    ExecutionEnvironment::CallStack::const_reverse_iterator it = stack.rbegin();\n\t    \n    \t    YSymbolEntryPtr ysentry = (YSymbolEntryPtr)((*it)->function->entry());\n\n\t    // this returns NULL in case the name was not found\n\t    sentry = ((YFunctionPtr)ysentry->code())->declaration ()->lookupSymbol (words[0].c_str());\n\n\t    if (sentry)\n\t\treturn sentry;\n\t}\n\t    \n\t// try block stack\n\tfor( std::list<stackitem_t>::iterator blk = m_blockstack.begin(); blk != m_blockstack.end (); blk++)\n\t{\n\t    sentry = blk->ns->lookupSymbol (words[0].c_str());\n\t    if (sentry)\n\t\treturn sentry;\n\t}\n    }\n\n    // not found\n    return NULL;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ExecutionEnvironment ee;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nextern ExecutionEnvironment ee;\n\nDebugger {\n  SymbolEntryPtr Debugger::findSymbol (std::string arg)\n  {\n      std::vector<std::string> words;\n      SymbolEntryPtr sentry = NULL;\n  \n      stringutil::split(arg, words, \":\");\n  \n      if (words.size () > 1)\n      {\n  \t// name contains namespace, handle here\n  \tstd::string ns_name = words[0];\n  \tstd::string name = words[1];\n  \tY2Component* c = Y2ComponentBroker::getNamespaceComponent (ns_name.c_str());\n  \tif( c )\n  \t{\n  \t    if (c->name () == \"wfm\")\n  \t    {\n  \t\tY2Namespace* ns = c->import (ns_name.c_str());\n  \t\tif (ns) \n  \t\t    // this returns NULL in case the name was not found\n  \t\t    return ns->lookupSymbol (name.c_str());\n  \t    }\n  \t    else\n  \t\treturn NULL; // this is not YCP symbol\n  \t}\n      }\n      else \n      {\n  \t// try parameters\n  \tExecutionEnvironment::CallStack stack = ee.callstack();\n  \t    \n  \tif( stack.size() > 0 )\n  \t{\n  \t    ExecutionEnvironment::CallStack::const_reverse_iterator it = stack.rbegin();\n  \t    \n      \t    YSymbolEntryPtr ysentry = (YSymbolEntryPtr)((*it)->function->entry());\n  \n  \t    // this returns NULL in case the name was not found\n  \t    sentry = ((YFunctionPtr)ysentry->code())->declaration ()->lookupSymbol (words[0].c_str());\n  \n  \t    if (sentry)\n  \t\treturn sentry;\n  \t}\n  \t    \n  \t// try block stack\n  \tfor( std::list<stackitem_t>::iterator blk = m_blockstack.begin(); blk != m_blockstack.end (); blk++)\n  \t{\n  \t    sentry = blk->ns->lookupSymbol (words[0].c_str());\n  \t    if (sentry)\n  \t\treturn sentry;\n  \t}\n      }\n  \n      // not found\n      return NULL;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::printVariable (std::string arg)\n  {\n      SymbolEntryPtr sentry = findSymbol (arg);\n  \n      if (sentry)\n      {\n  \tif( !sentry->isVariable ())\n  \t    sendOutput (\"Identifier is not a variable\");\n  \telse\n  \t{\n  \t    if( sentry->value().isNull() )\n  \t\tsendOutput (\"nil\");\n  \t    else\n  \t\tsendOutput (sentry->value()->toString());\n  \t}\n      }\n      else\n  \tsendOutput (\"Identifier not found\");\n  }\n}"
  },
  {
    "function_name": "findSymbol",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "271-326",
    "snippet": "SymbolEntryPtr Debugger::findSymbol (std::string arg)\n{\n    std::vector<std::string> words;\n    SymbolEntryPtr sentry = NULL;\n\n    stringutil::split(arg, words, \":\");\n\n    if (words.size () > 1)\n    {\n\t// name contains namespace, handle here\n\tstd::string ns_name = words[0];\n\tstd::string name = words[1];\n\tY2Component* c = Y2ComponentBroker::getNamespaceComponent (ns_name.c_str());\n\tif( c )\n\t{\n\t    if (c->name () == \"wfm\")\n\t    {\n\t\tY2Namespace* ns = c->import (ns_name.c_str());\n\t\tif (ns) \n\t\t    // this returns NULL in case the name was not found\n\t\t    return ns->lookupSymbol (name.c_str());\n\t    }\n\t    else\n\t\treturn NULL; // this is not YCP symbol\n\t}\n    }\n    else \n    {\n\t// try parameters\n\tExecutionEnvironment::CallStack stack = ee.callstack();\n\t    \n\tif( stack.size() > 0 )\n\t{\n\t    ExecutionEnvironment::CallStack::const_reverse_iterator it = stack.rbegin();\n\t    \n    \t    YSymbolEntryPtr ysentry = (YSymbolEntryPtr)((*it)->function->entry());\n\n\t    // this returns NULL in case the name was not found\n\t    sentry = ((YFunctionPtr)ysentry->code())->declaration ()->lookupSymbol (words[0].c_str());\n\n\t    if (sentry)\n\t\treturn sentry;\n\t}\n\t    \n\t// try block stack\n\tfor( std::list<stackitem_t>::iterator blk = m_blockstack.begin(); blk != m_blockstack.end (); blk++)\n\t{\n\t    sentry = blk->ns->lookupSymbol (words[0].c_str());\n\t    if (sentry)\n\t\treturn sentry;\n\t}\n    }\n\n    // not found\n    return NULL;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern ExecutionEnvironment ee;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk->ns->lookupSymbol",
          "args": [
            "words[0].c_str()"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "lookupSymbol",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "145-158",
          "snippet": "SymbolEntryPtr\nY2Namespace::lookupSymbol (const char *name) const\n{\n    for (unsigned int p = 0; p < m_symbolcount; p++)\n    {\n\tif ( m_symbols[p] && (strcmp (m_symbols[p]->name(), name) == 0)\n            && !m_symbols[p]->likeNamespace())\t\t\t// allow symbol if namespace of same name already declared\n        {\n            return m_symbols[p];\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  SymbolEntryPtr\n  Y2Namespace::lookupSymbol (const char *name) const\n  {\n      for (unsigned int p = 0; p < m_symbolcount; p++)\n      {\n  \tif ( m_symbols[p] && (strcmp (m_symbols[p]->name(), name) == 0)\n              && !m_symbols[p]->likeNamespace())\t\t\t// allow symbol if namespace of same name already declared\n          {\n              return m_symbols[p];\n          }\n      }\n  \n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "words[0].c_str",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_blockstack.end",
          "args": [],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_blockstack.begin",
          "args": [],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "words[0].c_str()"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "words[0].c_str",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ysentry->code",
          "args": [],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "code",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "139-147",
          "snippet": "YCodePtr\nYSymbolEntry::code () const\n{\n    if (m_category == c_builtin || m_category == c_module)\n    {\n\treturn 0;\n    }\n    return m_code;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nYSymbolEntry {\n  YCodePtr\n  YSymbolEntry::code () const\n  {\n      if (m_category == c_builtin || m_category == c_module)\n      {\n  \treturn 0;\n      }\n      return m_code;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(*it)->function->entry()"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.rbegin",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.size",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.callstack",
          "args": [],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "callstack",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "145-149",
          "snippet": "ExecutionEnvironment::CallStack ExecutionEnvironment::callstack() const\n{\n    // backtrace( LOG_MILESTONE, 0 );\n    return m_backtrace;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  ExecutionEnvironment::CallStack ExecutionEnvironment::callstack() const\n  {\n      // backtrace( LOG_MILESTONE, 0 );\n      return m_backtrace;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->import",
          "args": [
            "ns_name.c_str()"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_name.c_str",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->name",
          "args": [],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "382-386",
          "snippet": "const string \nYBlock::name () const\n{\n    return m_name;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  const string \n  YBlock::name () const\n  {\n      return m_name;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2ComponentBroker::getNamespaceComponent",
          "args": [
            "ns_name.c_str()"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_name.c_str",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringutil::split",
          "args": [
            "arg",
            "words",
            "\":\""
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nextern ExecutionEnvironment ee;\n\nDebugger {\n  SymbolEntryPtr Debugger::findSymbol (std::string arg)\n  {\n      std::vector<std::string> words;\n      SymbolEntryPtr sentry = NULL;\n  \n      stringutil::split(arg, words, \":\");\n  \n      if (words.size () > 1)\n      {\n  \t// name contains namespace, handle here\n  \tstd::string ns_name = words[0];\n  \tstd::string name = words[1];\n  \tY2Component* c = Y2ComponentBroker::getNamespaceComponent (ns_name.c_str());\n  \tif( c )\n  \t{\n  \t    if (c->name () == \"wfm\")\n  \t    {\n  \t\tY2Namespace* ns = c->import (ns_name.c_str());\n  \t\tif (ns) \n  \t\t    // this returns NULL in case the name was not found\n  \t\t    return ns->lookupSymbol (name.c_str());\n  \t    }\n  \t    else\n  \t\treturn NULL; // this is not YCP symbol\n  \t}\n      }\n      else \n      {\n  \t// try parameters\n  \tExecutionEnvironment::CallStack stack = ee.callstack();\n  \t    \n  \tif( stack.size() > 0 )\n  \t{\n  \t    ExecutionEnvironment::CallStack::const_reverse_iterator it = stack.rbegin();\n  \t    \n      \t    YSymbolEntryPtr ysentry = (YSymbolEntryPtr)((*it)->function->entry());\n  \n  \t    // this returns NULL in case the name was not found\n  \t    sentry = ((YFunctionPtr)ysentry->code())->declaration ()->lookupSymbol (words[0].c_str());\n  \n  \t    if (sentry)\n  \t\treturn sentry;\n  \t}\n  \t    \n  \t// try block stack\n  \tfor( std::list<stackitem_t>::iterator blk = m_blockstack.begin(); blk != m_blockstack.end (); blk++)\n  \t{\n  \t    sentry = blk->ns->lookupSymbol (words[0].c_str());\n  \t    if (sentry)\n  \t\treturn sentry;\n  \t}\n      }\n  \n      // not found\n      return NULL;\n  }\n}"
  },
  {
    "function_name": "generateBacktrace",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "234-269",
    "snippet": "void Debugger::generateBacktrace ()\n{\n    std::string result = \"Call stack:\";\n    ExecutionEnvironment::CallStack stack = ee.callstack();\n    ExecutionEnvironment::CallStack::const_reverse_iterator it = stack.rbegin();\n    while (it != stack.rend())\n    {\n        result = result \n    \t  + \"\\n\"\n    \t  + ( (*it)->filename ) \n          + \":\" \n          + stringutil::numstring((*it)->linenumber) \n          + \": \"\n          + ((*it)->function->entry()->toString());\n\n        int paramcount = ((constFunctionTypePtr)((*it)->function->entry()->type()))->parameterCount();\n        if( paramcount > 0 )\n\t\tresult += \" with paramters: \";\n        for( int i = 0; i < paramcount ; i++ )\n        {\n          string param = (*it)->params[0]->toString();\n          if (param.length() > 80)\n          {\n              param = \"<too long>\";\n          }\n          result += param;\n          if (i < paramcount - 1)\n          {\n            result += \", \";\n          }\n        }\n        ++it;\n    };\n\n    sendOutput (result);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern ExecutionEnvironment ee;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendOutput",
          "args": [
            "result"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "sendOutput",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "507-519",
          "snippet": "bool Debugger::sendOutput( std::string output )\n{\n    output = m_outputstash + output;\n    y2debug (\"Sending out output %s\", output.c_str() );\n    if( output.empty() )\n\toutput = \" \";\n    output = output + \"\\n<EOF>\\n\";\n    send (m_ns, output.c_str (), strlen( output.c_str ()), 0);\n    \n    // clean up the output stash, it's sent already\n    m_outputstash = \"\";\n    return true;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  bool Debugger::sendOutput( std::string output )\n  {\n      output = m_outputstash + output;\n      y2debug (\"Sending out output %s\", output.c_str() );\n      if( output.empty() )\n  \toutput = \" \";\n      output = output + \"\\n<EOF>\\n\";\n      send (m_ns, output.c_str (), strlen( output.c_str ()), 0);\n      \n      // clean up the output stash, it's sent already\n      m_outputstash = \"\";\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "param.length",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(*it)->function->entry()->type()"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringutil::numstring",
          "args": [
            "(*it)->linenumber"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "numstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/stringutil.h",
          "lines": "110-110",
          "snippet": "inline std::string numstring( unsigned long long n, int w = 0 ) { return form( \"%*llu\",  w, n ); }",
          "includes": [
            "#include <list>",
            "#include <string>",
            "#include <vector>",
            "#include <iosfwd>",
            "#include <cstdlib>",
            "#include <cstdarg>",
            "#include <cstdio>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <string>\n#include <vector>\n#include <iosfwd>\n#include <cstdlib>\n#include <cstdarg>\n#include <cstdio>\n\ninline std::string numstring( unsigned long long n, int w = 0 ) { return form( \"%*llu\",  w, n ); }"
        }
      },
      {
        "call_info": {
          "callee": "stack.rend",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.rbegin",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee.callstack",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "callstack",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "145-149",
          "snippet": "ExecutionEnvironment::CallStack ExecutionEnvironment::callstack() const\n{\n    // backtrace( LOG_MILESTONE, 0 );\n    return m_backtrace;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  ExecutionEnvironment::CallStack ExecutionEnvironment::callstack() const\n  {\n      // backtrace( LOG_MILESTONE, 0 );\n      return m_backtrace;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nextern ExecutionEnvironment ee;\n\nDebugger {\n  void Debugger::generateBacktrace ()\n  {\n      std::string result = \"Call stack:\";\n      ExecutionEnvironment::CallStack stack = ee.callstack();\n      ExecutionEnvironment::CallStack::const_reverse_iterator it = stack.rbegin();\n      while (it != stack.rend())\n      {\n          result = result \n      \t  + \"\\n\"\n      \t  + ( (*it)->filename ) \n            + \":\" \n            + stringutil::numstring((*it)->linenumber) \n            + \": \"\n            + ((*it)->function->entry()->toString());\n  \n          int paramcount = ((constFunctionTypePtr)((*it)->function->entry()->type()))->parameterCount();\n          if( paramcount > 0 )\n  \t\tresult += \" with paramters: \";\n          for( int i = 0; i < paramcount ; i++ )\n          {\n            string param = (*it)->params[0]->toString();\n            if (param.length() > 80)\n            {\n                param = \"<too long>\";\n            }\n            result += param;\n            if (i < paramcount - 1)\n            {\n              result += \", \";\n            }\n          }\n          ++it;\n      };\n  \n      sendOutput (result);\n  }\n}"
  },
  {
    "function_name": "removeBreakpoint",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "208-232",
    "snippet": "void Debugger::removeBreakpoint (std::list<std::string> &args)\n{\n    SymbolEntryPtr sentry = findSymbol (args.front ());\n\n    if (sentry)\n    {\n\tif( !sentry->isFunction ())\n\t    sendOutput (\"Identifier is not a function\");\n\telse\n\t{\n\t    YFunctionPtr fnc = ((YFunctionPtr)((YSymbolEntryPtr)sentry)->code());\n\t\n\t    if (fnc->definition ()->kind () == YCode::yiBreakpoint)\n\t    {\n\t\t// disable the breakpoint wrapper\n\t\t((YBreakpointPtr)fnc->definition ())->setEnabled (false);\n\t\tsendOutput (\"Breakpoint disabled\");\n\t\treturn;\n\t    }\n\t    sendOutput (\"Breakpoint not found\");\n\t}\n    }\n    else\n\tsendOutput (\"Identifier not found\");\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendOutput",
          "args": [
            "\"Identifier not found\""
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "sendOutput",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "507-519",
          "snippet": "bool Debugger::sendOutput( std::string output )\n{\n    output = m_outputstash + output;\n    y2debug (\"Sending out output %s\", output.c_str() );\n    if( output.empty() )\n\toutput = \" \";\n    output = output + \"\\n<EOF>\\n\";\n    send (m_ns, output.c_str (), strlen( output.c_str ()), 0);\n    \n    // clean up the output stash, it's sent already\n    m_outputstash = \"\";\n    return true;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  bool Debugger::sendOutput( std::string output )\n  {\n      output = m_outputstash + output;\n      y2debug (\"Sending out output %s\", output.c_str() );\n      if( output.empty() )\n  \toutput = \" \";\n      output = output + \"\\n<EOF>\\n\";\n      send (m_ns, output.c_str (), strlen( output.c_str ()), 0);\n      \n      // clean up the output stash, it's sent already\n      m_outputstash = \"\";\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "false"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fnc->definition",
          "args": [],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "definition",
          "container": "YFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "602-606",
          "snippet": "YCodePtr\nYFunction::definition() const\n{\n    return m_definition;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  YCodePtr\n  YFunction::definition() const\n  {\n      return m_definition;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(YSymbolEntryPtr)sentry"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sentry->isFunction",
          "args": [],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "isFunction",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "303-303",
          "snippet": "bool isFunction () const\t{ return m_kind == FunctionT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isFunction () const\t{ return m_kind == FunctionT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "findSymbol",
          "args": [
            "args.front ()"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "findSymbol",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "271-326",
          "snippet": "SymbolEntryPtr Debugger::findSymbol (std::string arg)\n{\n    std::vector<std::string> words;\n    SymbolEntryPtr sentry = NULL;\n\n    stringutil::split(arg, words, \":\");\n\n    if (words.size () > 1)\n    {\n\t// name contains namespace, handle here\n\tstd::string ns_name = words[0];\n\tstd::string name = words[1];\n\tY2Component* c = Y2ComponentBroker::getNamespaceComponent (ns_name.c_str());\n\tif( c )\n\t{\n\t    if (c->name () == \"wfm\")\n\t    {\n\t\tY2Namespace* ns = c->import (ns_name.c_str());\n\t\tif (ns) \n\t\t    // this returns NULL in case the name was not found\n\t\t    return ns->lookupSymbol (name.c_str());\n\t    }\n\t    else\n\t\treturn NULL; // this is not YCP symbol\n\t}\n    }\n    else \n    {\n\t// try parameters\n\tExecutionEnvironment::CallStack stack = ee.callstack();\n\t    \n\tif( stack.size() > 0 )\n\t{\n\t    ExecutionEnvironment::CallStack::const_reverse_iterator it = stack.rbegin();\n\t    \n    \t    YSymbolEntryPtr ysentry = (YSymbolEntryPtr)((*it)->function->entry());\n\n\t    // this returns NULL in case the name was not found\n\t    sentry = ((YFunctionPtr)ysentry->code())->declaration ()->lookupSymbol (words[0].c_str());\n\n\t    if (sentry)\n\t\treturn sentry;\n\t}\n\t    \n\t// try block stack\n\tfor( std::list<stackitem_t>::iterator blk = m_blockstack.begin(); blk != m_blockstack.end (); blk++)\n\t{\n\t    sentry = blk->ns->lookupSymbol (words[0].c_str());\n\t    if (sentry)\n\t\treturn sentry;\n\t}\n    }\n\n    // not found\n    return NULL;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ExecutionEnvironment ee;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nextern ExecutionEnvironment ee;\n\nDebugger {\n  SymbolEntryPtr Debugger::findSymbol (std::string arg)\n  {\n      std::vector<std::string> words;\n      SymbolEntryPtr sentry = NULL;\n  \n      stringutil::split(arg, words, \":\");\n  \n      if (words.size () > 1)\n      {\n  \t// name contains namespace, handle here\n  \tstd::string ns_name = words[0];\n  \tstd::string name = words[1];\n  \tY2Component* c = Y2ComponentBroker::getNamespaceComponent (ns_name.c_str());\n  \tif( c )\n  \t{\n  \t    if (c->name () == \"wfm\")\n  \t    {\n  \t\tY2Namespace* ns = c->import (ns_name.c_str());\n  \t\tif (ns) \n  \t\t    // this returns NULL in case the name was not found\n  \t\t    return ns->lookupSymbol (name.c_str());\n  \t    }\n  \t    else\n  \t\treturn NULL; // this is not YCP symbol\n  \t}\n      }\n      else \n      {\n  \t// try parameters\n  \tExecutionEnvironment::CallStack stack = ee.callstack();\n  \t    \n  \tif( stack.size() > 0 )\n  \t{\n  \t    ExecutionEnvironment::CallStack::const_reverse_iterator it = stack.rbegin();\n  \t    \n      \t    YSymbolEntryPtr ysentry = (YSymbolEntryPtr)((*it)->function->entry());\n  \n  \t    // this returns NULL in case the name was not found\n  \t    sentry = ((YFunctionPtr)ysentry->code())->declaration ()->lookupSymbol (words[0].c_str());\n  \n  \t    if (sentry)\n  \t\treturn sentry;\n  \t}\n  \t    \n  \t// try block stack\n  \tfor( std::list<stackitem_t>::iterator blk = m_blockstack.begin(); blk != m_blockstack.end (); blk++)\n  \t{\n  \t    sentry = blk->ns->lookupSymbol (words[0].c_str());\n  \t    if (sentry)\n  \t\treturn sentry;\n  \t}\n      }\n  \n      // not found\n      return NULL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "args.front",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::removeBreakpoint (std::list<std::string> &args)\n  {\n      SymbolEntryPtr sentry = findSymbol (args.front ());\n  \n      if (sentry)\n      {\n  \tif( !sentry->isFunction ())\n  \t    sendOutput (\"Identifier is not a function\");\n  \telse\n  \t{\n  \t    YFunctionPtr fnc = ((YFunctionPtr)((YSymbolEntryPtr)sentry)->code());\n  \t\n  \t    if (fnc->definition ()->kind () == YCode::yiBreakpoint)\n  \t    {\n  \t\t// disable the breakpoint wrapper\n  \t\t((YBreakpointPtr)fnc->definition ())->setEnabled (false);\n  \t\tsendOutput (\"Breakpoint disabled\");\n  \t\treturn;\n  \t    }\n  \t    sendOutput (\"Breakpoint not found\");\n  \t}\n      }\n      else\n  \tsendOutput (\"Identifier not found\");\n  }\n}"
  },
  {
    "function_name": "setBreakpoint",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "177-206",
    "snippet": "void Debugger::setBreakpoint (std::list<std::string> &args)\n{\n    SymbolEntryPtr sentry = findSymbol (args.front ());\n\n    if (sentry)\n    {\n\tif( !sentry->isFunction ())\n\t    sendOutput (\"Identifier is not a function\");\n\telse\n\t{\n\t    YFunctionPtr fnc = ((YFunctionPtr)((YSymbolEntryPtr)sentry)->code());\n\t\n\t    // set the breakpoint wrapper\n\t    if (fnc->definition ()->kind () == YCode::yiBreakpoint)\n\t    {\n\t\t((YBreakpointPtr)fnc->definition ())->setEnabled (true);\n\t\tsendOutput (\"Breakpoint enabled\");\n\t\treturn;\n\t    }\n\t\n\t    YBreakpointPtr bp = new YBreakpoint (fnc->definition(), args.front () );\n\t\n\t    fnc->setDefinition (bp);\n\t    std::string result = \"Set breakpoint to \" + sentry->toString();\n\t    sendOutput (result);\n\t}\n    }\n    else\n\tsendOutput (\"Identifier not found\");\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendOutput",
          "args": [
            "\"Identifier not found\""
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "sendOutput",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "507-519",
          "snippet": "bool Debugger::sendOutput( std::string output )\n{\n    output = m_outputstash + output;\n    y2debug (\"Sending out output %s\", output.c_str() );\n    if( output.empty() )\n\toutput = \" \";\n    output = output + \"\\n<EOF>\\n\";\n    send (m_ns, output.c_str (), strlen( output.c_str ()), 0);\n    \n    // clean up the output stash, it's sent already\n    m_outputstash = \"\";\n    return true;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  bool Debugger::sendOutput( std::string output )\n  {\n      output = m_outputstash + output;\n      y2debug (\"Sending out output %s\", output.c_str() );\n      if( output.empty() )\n  \toutput = \" \";\n      output = output + \"\\n<EOF>\\n\";\n      send (m_ns, output.c_str (), strlen( output.c_str ()), 0);\n      \n      // clean up the output stash, it's sent already\n      m_outputstash = \"\";\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sentry->toString",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnc->setDefinition",
          "args": [
            "bp"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "setDefinition",
          "container": "YFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "634-672",
          "snippet": "void\nYFunction::setDefinition (bytecodeistream & str)\n{\n    if (Bytecode::readBool (str))\n    {\n#if DO_DEBUG\n\ty2debug (\"YFunction::YFunction: have definition!\");\n#endif\n\n\tif (m_declaration != 0)\n\t{\n\t    Bytecode::pushNamespace (m_declaration->nameSpace());\n\t}\n\t\n\tYBlockPtr def = (YBlockPtr)Bytecode::readCode (str);\n\tdef->setKind (YBlock::b_definition);\n\n\tm_definition = def;\n\n\tif (m_declaration != 0)\n\t{\n\t    Bytecode::popNamespace (m_declaration->nameSpace());\n\t}\n\n\tif ((m_definition == 0)\n\t    || (!m_definition->isBlock()))\n\t{\n\t    y2error (\"Error reading definition\");\n\t}\n    }\n    else\n    {\n#if DO_DEBUG\n\ty2debug (\"YFunction::setDefinition(stream): no definition!\");\n#endif\n    }\n\n    return;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\n#define DO_DEBUG 0\n\nYFunction {\n  void\n  YFunction::setDefinition (bytecodeistream & str)\n  {\n      if (Bytecode::readBool (str))\n      {\n  #if DO_DEBUG\n  \ty2debug (\"YFunction::YFunction: have definition!\");\n  #endif\n  \n  \tif (m_declaration != 0)\n  \t{\n  \t    Bytecode::pushNamespace (m_declaration->nameSpace());\n  \t}\n  \t\n  \tYBlockPtr def = (YBlockPtr)Bytecode::readCode (str);\n  \tdef->setKind (YBlock::b_definition);\n  \n  \tm_definition = def;\n  \n  \tif (m_declaration != 0)\n  \t{\n  \t    Bytecode::popNamespace (m_declaration->nameSpace());\n  \t}\n  \n  \tif ((m_definition == 0)\n  \t    || (!m_definition->isBlock()))\n  \t{\n  \t    y2error (\"Error reading definition\");\n  \t}\n      }\n      else\n      {\n  #if DO_DEBUG\n  \ty2debug (\"YFunction::setDefinition(stream): no definition!\");\n  #endif\n      }\n  \n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "args.front",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fnc->definition",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "definition",
          "container": "YFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "602-606",
          "snippet": "YCodePtr\nYFunction::definition() const\n{\n    return m_definition;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  YCodePtr\n  YFunction::definition() const\n  {\n      return m_definition;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "true"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(YSymbolEntryPtr)sentry"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sentry->isFunction",
          "args": [],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "isFunction",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "303-303",
          "snippet": "bool isFunction () const\t{ return m_kind == FunctionT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isFunction () const\t{ return m_kind == FunctionT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "findSymbol",
          "args": [
            "args.front ()"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "findSymbol",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "271-326",
          "snippet": "SymbolEntryPtr Debugger::findSymbol (std::string arg)\n{\n    std::vector<std::string> words;\n    SymbolEntryPtr sentry = NULL;\n\n    stringutil::split(arg, words, \":\");\n\n    if (words.size () > 1)\n    {\n\t// name contains namespace, handle here\n\tstd::string ns_name = words[0];\n\tstd::string name = words[1];\n\tY2Component* c = Y2ComponentBroker::getNamespaceComponent (ns_name.c_str());\n\tif( c )\n\t{\n\t    if (c->name () == \"wfm\")\n\t    {\n\t\tY2Namespace* ns = c->import (ns_name.c_str());\n\t\tif (ns) \n\t\t    // this returns NULL in case the name was not found\n\t\t    return ns->lookupSymbol (name.c_str());\n\t    }\n\t    else\n\t\treturn NULL; // this is not YCP symbol\n\t}\n    }\n    else \n    {\n\t// try parameters\n\tExecutionEnvironment::CallStack stack = ee.callstack();\n\t    \n\tif( stack.size() > 0 )\n\t{\n\t    ExecutionEnvironment::CallStack::const_reverse_iterator it = stack.rbegin();\n\t    \n    \t    YSymbolEntryPtr ysentry = (YSymbolEntryPtr)((*it)->function->entry());\n\n\t    // this returns NULL in case the name was not found\n\t    sentry = ((YFunctionPtr)ysentry->code())->declaration ()->lookupSymbol (words[0].c_str());\n\n\t    if (sentry)\n\t\treturn sentry;\n\t}\n\t    \n\t// try block stack\n\tfor( std::list<stackitem_t>::iterator blk = m_blockstack.begin(); blk != m_blockstack.end (); blk++)\n\t{\n\t    sentry = blk->ns->lookupSymbol (words[0].c_str());\n\t    if (sentry)\n\t\treturn sentry;\n\t}\n    }\n\n    // not found\n    return NULL;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ExecutionEnvironment ee;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nextern ExecutionEnvironment ee;\n\nDebugger {\n  SymbolEntryPtr Debugger::findSymbol (std::string arg)\n  {\n      std::vector<std::string> words;\n      SymbolEntryPtr sentry = NULL;\n  \n      stringutil::split(arg, words, \":\");\n  \n      if (words.size () > 1)\n      {\n  \t// name contains namespace, handle here\n  \tstd::string ns_name = words[0];\n  \tstd::string name = words[1];\n  \tY2Component* c = Y2ComponentBroker::getNamespaceComponent (ns_name.c_str());\n  \tif( c )\n  \t{\n  \t    if (c->name () == \"wfm\")\n  \t    {\n  \t\tY2Namespace* ns = c->import (ns_name.c_str());\n  \t\tif (ns) \n  \t\t    // this returns NULL in case the name was not found\n  \t\t    return ns->lookupSymbol (name.c_str());\n  \t    }\n  \t    else\n  \t\treturn NULL; // this is not YCP symbol\n  \t}\n      }\n      else \n      {\n  \t// try parameters\n  \tExecutionEnvironment::CallStack stack = ee.callstack();\n  \t    \n  \tif( stack.size() > 0 )\n  \t{\n  \t    ExecutionEnvironment::CallStack::const_reverse_iterator it = stack.rbegin();\n  \t    \n      \t    YSymbolEntryPtr ysentry = (YSymbolEntryPtr)((*it)->function->entry());\n  \n  \t    // this returns NULL in case the name was not found\n  \t    sentry = ((YFunctionPtr)ysentry->code())->declaration ()->lookupSymbol (words[0].c_str());\n  \n  \t    if (sentry)\n  \t\treturn sentry;\n  \t}\n  \t    \n  \t// try block stack\n  \tfor( std::list<stackitem_t>::iterator blk = m_blockstack.begin(); blk != m_blockstack.end (); blk++)\n  \t{\n  \t    sentry = blk->ns->lookupSymbol (words[0].c_str());\n  \t    if (sentry)\n  \t\treturn sentry;\n  \t}\n      }\n  \n      // not found\n      return NULL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "args.front",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::setBreakpoint (std::list<std::string> &args)\n  {\n      SymbolEntryPtr sentry = findSymbol (args.front ());\n  \n      if (sentry)\n      {\n  \tif( !sentry->isFunction ())\n  \t    sendOutput (\"Identifier is not a function\");\n  \telse\n  \t{\n  \t    YFunctionPtr fnc = ((YFunctionPtr)((YSymbolEntryPtr)sentry)->code());\n  \t\n  \t    // set the breakpoint wrapper\n  \t    if (fnc->definition ()->kind () == YCode::yiBreakpoint)\n  \t    {\n  \t\t((YBreakpointPtr)fnc->definition ())->setEnabled (true);\n  \t\tsendOutput (\"Breakpoint enabled\");\n  \t\treturn;\n  \t    }\n  \t\n  \t    YBreakpointPtr bp = new YBreakpoint (fnc->definition(), args.front () );\n  \t\n  \t    fnc->setDefinition (bp);\n  \t    std::string result = \"Set breakpoint to \" + sentry->toString();\n  \t    sendOutput (result);\n  \t}\n      }\n      else\n  \tsendOutput (\"Identifier not found\");\n  }\n}"
  },
  {
    "function_name": "setTracing",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "171-175",
    "snippet": "void Debugger::setTracing()\n{\n    m_last_command = c_step;\n    m_tracing = true;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::setTracing()\n  {\n      m_last_command = c_step;\n      m_tracing = true;\n  }\n}"
  },
  {
    "function_name": "initializeRemote",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "124-169",
    "snippet": "bool Debugger::initializeRemote()\n{\n  socklen_t fromlen;\n  int ns;\n  struct sockaddr_in sain, fsain;\n\n  // FIXME: possible leak\n  m_socket = -1;\n  m_descriptor = NULL;\n\n  if ((m_socket = socket (PF_INET, SOCK_STREAM, 0)) < 0)\n    {\n      return false;\n    }\n\n  sain.sin_family = PF_UNIX;\n  sain.sin_addr.s_addr=htonl(INADDR_ANY);\n  sain.sin_port=htons(PORT);\n\n  if (bind (m_socket,(struct sockaddr *) &sain, sizeof (sain)) < 0)\n  {\n    y2error (\"Debugger: bind failed\");\n    return false;\n  }\n\n  // wait for connection\n  if (listen (m_socket, 1) < 0)\n  {\n    y2error (\"Debugger: listen failed\");\n    return false;\n  }\n\n  fromlen = sizeof(fsain);\n\n  if ((ns = accept (m_socket, (struct sockaddr *) &fsain, &fromlen)) < 0)\n  {\n    y2error (\"Debugger: accept failed\");\n    return false;\n  }\n\n  m_descriptor = fdopen (ns, \"r\");\n  m_last_command = c_step;\t// step to enable debugging from the start\n  m_ns = ns;\n\n  return true;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [
      "#define PORT\t    16384"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "ns",
            "\"r\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Debugger: accept failed\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "m_socket",
            "(struct sockaddr *) &fsain",
            "&fromlen"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Debugger: listen failed\""
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "m_socket",
            "1"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Debugger: bind failed\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "m_socket",
            "(struct sockaddr *) &sain",
            "sizeof (sain)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "PORT"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_ANY"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_INET",
            "SOCK_STREAM",
            "0"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\n#define PORT\t    16384\n\nDebugger {\n  bool Debugger::initializeRemote()\n  {\n    socklen_t fromlen;\n    int ns;\n    struct sockaddr_in sain, fsain;\n  \n    // FIXME: possible leak\n    m_socket = -1;\n    m_descriptor = NULL;\n  \n    if ((m_socket = socket (PF_INET, SOCK_STREAM, 0)) < 0)\n      {\n        return false;\n      }\n  \n    sain.sin_family = PF_UNIX;\n    sain.sin_addr.s_addr=htonl(INADDR_ANY);\n    sain.sin_port=htons(PORT);\n  \n    if (bind (m_socket,(struct sockaddr *) &sain, sizeof (sain)) < 0)\n    {\n      y2error (\"Debugger: bind failed\");\n      return false;\n    }\n  \n    // wait for connection\n    if (listen (m_socket, 1) < 0)\n    {\n      y2error (\"Debugger: listen failed\");\n      return false;\n    }\n  \n    fromlen = sizeof(fsain);\n  \n    if ((ns = accept (m_socket, (struct sockaddr *) &fsain, &fromlen)) < 0)\n    {\n      y2error (\"Debugger: accept failed\");\n      return false;\n    }\n  \n    m_descriptor = fdopen (ns, \"r\");\n    m_last_command = c_step;\t// step to enable debugging from the start\n    m_ns = ns;\n  \n    return true;\n  }\n}"
  },
  {
    "function_name": "initializeLocal",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "71-122",
    "snippet": "bool Debugger::initializeLocal()\n{\n  socklen_t fromlen;\n  int ns, len;\n  struct sockaddr_un saun, fsaun;\n\n  // FIXME: possible leak\n  m_socket = -1;\n  m_descriptor = NULL;\n\n  if ((m_socket = socket (AF_UNIX, SOCK_STREAM, 0)) < 0)\n    {\n      return false;\n    }\n\n  saun.sun_family = AF_UNIX;\n  strcpy (saun.sun_path, ADDRESS);\n\n  int res = access (ADDRESS, F_OK);\n  if ( res == 0 || errno != ENOENT )\n  {\n    y2security (\"Cannot create debugger socket: %s\", res == 0 ? \"File exists\" : strerror (errno) );\n    return false;\n  }\n\n  len = sizeof (saun.sun_family) + strlen (saun.sun_path);\n\n  if (bind (m_socket,(struct sockaddr *) &saun, len) < 0)\n  {\n    return false;\n  }\n\n  // wait for connection\n  if (listen (m_socket, 1) < 0)\n  {\n    y2error (\"Debugger: listen failed\");\n    return false;\n  }\n  fromlen = 108;\n\n  if ((ns = accept (m_socket, (struct sockaddr *) &fsaun, &fromlen)) < 0)\n  {\n    y2error (\"Debugger: accept failed\");\n    return false;\n  }\n\n  m_descriptor = fdopen (ns, \"r\");\n  m_last_command = c_step;\t// step to enable debugging from the start\n  m_ns = ns;\n\n  return true;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [
      "#define ADDRESS     \"/tmp/yast.socket\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "ns",
            "\"r\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Debugger: accept failed\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "m_socket",
            "(struct sockaddr *) &fsaun",
            "&fromlen"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Debugger: listen failed\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "m_socket",
            "1"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "m_socket",
            "(struct sockaddr *) &saun",
            "len"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "saun.sun_path"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2security",
          "args": [
            "\"Cannot create debugger socket: %s\"",
            "res == 0 ? \"File exists\" : strerror (errno)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "ADDRESS",
            "F_OK"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "saun.sun_path",
            "ADDRESS"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\n#define ADDRESS     \"/tmp/yast.socket\"\n\nDebugger {\n  bool Debugger::initializeLocal()\n  {\n    socklen_t fromlen;\n    int ns, len;\n    struct sockaddr_un saun, fsaun;\n  \n    // FIXME: possible leak\n    m_socket = -1;\n    m_descriptor = NULL;\n  \n    if ((m_socket = socket (AF_UNIX, SOCK_STREAM, 0)) < 0)\n      {\n        return false;\n      }\n  \n    saun.sun_family = AF_UNIX;\n    strcpy (saun.sun_path, ADDRESS);\n  \n    int res = access (ADDRESS, F_OK);\n    if ( res == 0 || errno != ENOENT )\n    {\n      y2security (\"Cannot create debugger socket: %s\", res == 0 ? \"File exists\" : strerror (errno) );\n      return false;\n    }\n  \n    len = sizeof (saun.sun_family) + strlen (saun.sun_path);\n  \n    if (bind (m_socket,(struct sockaddr *) &saun, len) < 0)\n    {\n      return false;\n    }\n  \n    // wait for connection\n    if (listen (m_socket, 1) < 0)\n    {\n      y2error (\"Debugger: listen failed\");\n      return false;\n    }\n    fromlen = 108;\n  \n    if ((ns = accept (m_socket, (struct sockaddr *) &fsaun, &fromlen)) < 0)\n    {\n      y2error (\"Debugger: accept failed\");\n      return false;\n    }\n  \n    m_descriptor = fdopen (ns, \"r\");\n    m_last_command = c_step;\t// step to enable debugging from the start\n    m_ns = ns;\n  \n    return true;\n  }\n}"
  },
  {
    "function_name": "initialize",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "65-69",
    "snippet": "bool Debugger::initialize(bool remote)\n{\n    m_remote = remote;\n    return remote ? initializeRemote() : initializeLocal();\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "initializeLocal",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "initializeLocal",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "71-122",
          "snippet": "bool Debugger::initializeLocal()\n{\n  socklen_t fromlen;\n  int ns, len;\n  struct sockaddr_un saun, fsaun;\n\n  // FIXME: possible leak\n  m_socket = -1;\n  m_descriptor = NULL;\n\n  if ((m_socket = socket (AF_UNIX, SOCK_STREAM, 0)) < 0)\n    {\n      return false;\n    }\n\n  saun.sun_family = AF_UNIX;\n  strcpy (saun.sun_path, ADDRESS);\n\n  int res = access (ADDRESS, F_OK);\n  if ( res == 0 || errno != ENOENT )\n  {\n    y2security (\"Cannot create debugger socket: %s\", res == 0 ? \"File exists\" : strerror (errno) );\n    return false;\n  }\n\n  len = sizeof (saun.sun_family) + strlen (saun.sun_path);\n\n  if (bind (m_socket,(struct sockaddr *) &saun, len) < 0)\n  {\n    return false;\n  }\n\n  // wait for connection\n  if (listen (m_socket, 1) < 0)\n  {\n    y2error (\"Debugger: listen failed\");\n    return false;\n  }\n  fromlen = 108;\n\n  if ((ns = accept (m_socket, (struct sockaddr *) &fsaun, &fromlen)) < 0)\n  {\n    y2error (\"Debugger: accept failed\");\n    return false;\n  }\n\n  m_descriptor = fdopen (ns, \"r\");\n  m_last_command = c_step;\t// step to enable debugging from the start\n  m_ns = ns;\n\n  return true;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [
            "#define ADDRESS     \"/tmp/yast.socket\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\n#define ADDRESS     \"/tmp/yast.socket\"\n\nDebugger {\n  bool Debugger::initializeLocal()\n  {\n    socklen_t fromlen;\n    int ns, len;\n    struct sockaddr_un saun, fsaun;\n  \n    // FIXME: possible leak\n    m_socket = -1;\n    m_descriptor = NULL;\n  \n    if ((m_socket = socket (AF_UNIX, SOCK_STREAM, 0)) < 0)\n      {\n        return false;\n      }\n  \n    saun.sun_family = AF_UNIX;\n    strcpy (saun.sun_path, ADDRESS);\n  \n    int res = access (ADDRESS, F_OK);\n    if ( res == 0 || errno != ENOENT )\n    {\n      y2security (\"Cannot create debugger socket: %s\", res == 0 ? \"File exists\" : strerror (errno) );\n      return false;\n    }\n  \n    len = sizeof (saun.sun_family) + strlen (saun.sun_path);\n  \n    if (bind (m_socket,(struct sockaddr *) &saun, len) < 0)\n    {\n      return false;\n    }\n  \n    // wait for connection\n    if (listen (m_socket, 1) < 0)\n    {\n      y2error (\"Debugger: listen failed\");\n      return false;\n    }\n    fromlen = 108;\n  \n    if ((ns = accept (m_socket, (struct sockaddr *) &fsaun, &fromlen)) < 0)\n    {\n      y2error (\"Debugger: accept failed\");\n      return false;\n    }\n  \n    m_descriptor = fdopen (ns, \"r\");\n    m_last_command = c_step;\t// step to enable debugging from the start\n    m_ns = ns;\n  \n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "initializeRemote",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "initializeRemote",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "124-169",
          "snippet": "bool Debugger::initializeRemote()\n{\n  socklen_t fromlen;\n  int ns;\n  struct sockaddr_in sain, fsain;\n\n  // FIXME: possible leak\n  m_socket = -1;\n  m_descriptor = NULL;\n\n  if ((m_socket = socket (PF_INET, SOCK_STREAM, 0)) < 0)\n    {\n      return false;\n    }\n\n  sain.sin_family = PF_UNIX;\n  sain.sin_addr.s_addr=htonl(INADDR_ANY);\n  sain.sin_port=htons(PORT);\n\n  if (bind (m_socket,(struct sockaddr *) &sain, sizeof (sain)) < 0)\n  {\n    y2error (\"Debugger: bind failed\");\n    return false;\n  }\n\n  // wait for connection\n  if (listen (m_socket, 1) < 0)\n  {\n    y2error (\"Debugger: listen failed\");\n    return false;\n  }\n\n  fromlen = sizeof(fsain);\n\n  if ((ns = accept (m_socket, (struct sockaddr *) &fsain, &fromlen)) < 0)\n  {\n    y2error (\"Debugger: accept failed\");\n    return false;\n  }\n\n  m_descriptor = fdopen (ns, \"r\");\n  m_last_command = c_step;\t// step to enable debugging from the start\n  m_ns = ns;\n\n  return true;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [
            "#define PORT\t    16384"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\n#define PORT\t    16384\n\nDebugger {\n  bool Debugger::initializeRemote()\n  {\n    socklen_t fromlen;\n    int ns;\n    struct sockaddr_in sain, fsain;\n  \n    // FIXME: possible leak\n    m_socket = -1;\n    m_descriptor = NULL;\n  \n    if ((m_socket = socket (PF_INET, SOCK_STREAM, 0)) < 0)\n      {\n        return false;\n      }\n  \n    sain.sin_family = PF_UNIX;\n    sain.sin_addr.s_addr=htonl(INADDR_ANY);\n    sain.sin_port=htons(PORT);\n  \n    if (bind (m_socket,(struct sockaddr *) &sain, sizeof (sain)) < 0)\n    {\n      y2error (\"Debugger: bind failed\");\n      return false;\n    }\n  \n    // wait for connection\n    if (listen (m_socket, 1) < 0)\n    {\n      y2error (\"Debugger: listen failed\");\n      return false;\n    }\n  \n    fromlen = sizeof(fsain);\n  \n    if ((ns = accept (m_socket, (struct sockaddr *) &fsain, &fromlen)) < 0)\n    {\n      y2error (\"Debugger: accept failed\");\n      return false;\n    }\n  \n    m_descriptor = fdopen (ns, \"r\");\n    m_last_command = c_step;\t// step to enable debugging from the start\n    m_ns = ns;\n  \n    return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  bool Debugger::initialize(bool remote)\n  {\n      m_remote = remote;\n      return remote ? initializeRemote() : initializeLocal();\n  }\n}"
  },
  {
    "function_name": "~Debugger",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "53-63",
    "snippet": "Debugger::~Debugger ()\n{\n    // close the controll socket\n    if (m_socket) \n    {\n\tclose (m_socket);\n\tif (m_remote) \n\t    unlink (ADDRESS);\n    }\n    m_socket = -1;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [
      "#define ADDRESS     \"/tmp/yast.socket\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "ADDRESS"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "unlink",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "541-548",
          "snippet": "int PathInfo::unlink( const Pathname & path )\n{\n  DBG << \"unlink \" << path;\n  if ( ::unlink( path.asString().c_str() ) == -1 ) {\n    return _Log_Result( errno );\n  }\n  return _Log_Result( 0 );\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::unlink( const Pathname & path )\n  {\n    DBG << \"unlink \" << path;\n    if ( ::unlink( path.asString().c_str() ) == -1 ) {\n      return _Log_Result( errno );\n    }\n    return _Log_Result( 0 );\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "m_socket"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\n#define ADDRESS     \"/tmp/yast.socket\"\n\nDebugger {\n  Debugger::~Debugger ()\n  {\n      // close the controll socket\n      if (m_socket) \n      {\n  \tclose (m_socket);\n  \tif (m_remote) \n  \t    unlink (ADDRESS);\n      }\n      m_socket = -1;\n  }\n}"
  },
  {
    "function_name": "Debugger",
    "container": "Debugger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
    "lines": "45-51",
    "snippet": "Debugger::Debugger () : \n  m_socket (-1),\n  m_descriptor (NULL),\n  m_outputstash (\"\"),\n  m_tracing (false),\n  m_remote (false)\n{}",
    "includes": [
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"Debugger.h\"",
      "#include <y2util/stringutil.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YBreakpoint.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <y2/Y2Namespace.h>",
      "#include <y2/Y2Component.h>",
      "#include <y2/Y2ComponentBroker.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  Debugger::Debugger () : \n    m_socket (-1),\n    m_descriptor (NULL),\n    m_outputstash (\"\"),\n    m_tracing (false),\n    m_remote (false)\n  {}\n}"
  }
]