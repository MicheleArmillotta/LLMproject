[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runycp.cc",
    "lines": "66-217",
    "snippet": "int\nmain (int argc, const char *argv[])\n{\n    const char *fname = 0;\n    FILE *infile = stdin;\n    bool make_depends = false;\n\n    YCPPathSearch::initialize ();\n\n    if (argc > 1)\n    {\n\tint argp = 1;\n\twhile (argp < argc)\n\t{\n\t    if ((argv[argp][0] == '-')\n\t        && (argv[argp][1] == 'l')\n\t        && (argp+1 < argc))\n\t    {\n\t\targp++;\n\t\tset_log_filename (argv[argp]);\n\t    }\n\t    // TODO - this is getting messy, use getopt_long\n\t    else if ((argv[argp][0] == '-')\n\t        && (argv[argp][1] == 'I'))\n\t    {\n\t\tconst char *path = argv[argp] + 2;\n\t\tif ((*path == 0)\n\t\t    && (argp+1 < argc))\n\t\t{\n\t\t    argp++;\n\t\t    path = argv[argp];\n\t\t}\n\t\tif (*path == 0)\n\t\t{\n\t\t    fprintf (stderr, \"missing argument to '-I'\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    YCPPathSearch::addPath (YCPPathSearch::Include, path);\n\t\t}\n\t    }\n\t    else if ((argv[argp][0] == '-')\n\t        && (argv[argp][1] == 'M'))\n\t    {\n\t\tconst char *path = argv[argp] + 2;\n\t\tif ((*path == 0)\n\t\t    && (argp+1 < argc))\n\t\t{\n\t\t    argp++;\n\t\t    path = argv[argp];\n\t\t}\n\t\tif (*path == 0)\n\t\t{\n\t\t    fprintf (stderr, \"missing argument to '-M'\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    YCPPathSearch::addPath (YCPPathSearch::Module, path);\n\t\t}\n\t    }\n\t    else if ((argv[argp][0] == '-')\n\t        && (argv[argp][1] == '-')\n\t        && (strcmp (argv[argp] + 2, \"depends\") == 0))\n\t    {\n\t\tmake_depends = true;\t\n\t    }\n\t    else if ((argv[argp][0] != '-')\n\t\t     && fname == 0)\n\t    {\n\t\tfname = argv[argp];\n\t    }\n\t    else\n\t    {\n\t\tfprintf (stderr, \"Bad argument '%s'\\nUsage: runycp [-l log] {-I include-path} {-M module-path} [name.ycp]\\n\", argv[argp]);\n\t\treturn 1;\n\t    }\n\t    argp++;\n\t}\n    }\n\n    Parser *parser;\n    parser = new Parser ();\n\n    if (!parser)\n    {\n\tfprintf (stderr, \"Failed to create Parser\\n\");\n\treturn 1;\n    }\n\n    if (fname != 0)\n    {\n\tinfile = fopen (fname, \"r\");\n\tif (infile == 0)\n\t{\n\t    fprintf (stderr, \"Failed to open '%s'\\n\", fname);\n\t    return 1;\n\t}\n    }\n    else\n    {\n\tfname = \"stdin\";\n    }\n\n    parser->setInput (infile, fname);\n    parser->setBuffered();\n    if (make_depends)\n\tparser->setDepends();\n\t\n    ee.setFilename (string (fname));\n\n    YCodePtr code = 0;\n\n    SymbolTableDebug = 0;\n\n    for (;;)\n    {\n\ty2debug (\"\\n------------------------------------------- parsing\");\n\tcode = parser->parse ();\n\tif (parser->atEOF())\n\t{\n\t    break;\n\t}\n\n\tif (code == 0)\n\t{\n\t    fprintf (stderr, \"runycp: parser error\\n\");\n\t    break;\n\t}\n\n\tfprintf (stderr, \n\t    \"Parsed:\\n\"\n\t    \"----------------------------------------------------------------------\\n\"\n\t    \"%s\\n\"\n\t    \"----------------------------------------------------------------------\\n\",\n\t    code->toString().c_str());\n\n\ty2debug (\"\\n------------------------------------------- running\");\n\tYCPValue value = code->evaluate ();\n\n\ty2debug (\"\\n------------------------------------------- done\");\n\tprintf (\"(%s)\\n\", value.isNull() ? \"nil\" : value->toString().c_str());\n\n    }\n\n    delete parser;\n\n    if (infile != stdin)\n    {\n\tfclose (infile);\n    }\n    return 0;\n}",
    "includes": [
      "#include <y2/Y2ComponentCreator.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern ExecutionEnvironment ee;",
      "extern int SymbolTableDebug;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "infile"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"(%s)\\n\"",
            "value.isNull() ? \"nil\" : value->toString().c_str()"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"\\n------------------------------------------- done\""
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "code->evaluate",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"\\n------------------------------------------- running\""
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Parsed:\\n\"\n\t    \"----------------------------------------------------------------------\\n\"\n\t    \"%s\\n\"\n\t    \"----------------------------------------------------------------------\\n\"",
            "code->toString().c_str()"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"runycp: parser error\\n\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->atEOF",
          "args": [],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "atEOF",
          "container": "Parser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Parser.cc",
          "lines": "134-138",
          "snippet": "bool\nParser::atEOF()\n{\n    return m_at_eof;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Parser.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Parser.h\"\n#include <stdlib.h>\n\nParser {\n  bool\n  Parser::atEOF()\n  {\n      return m_at_eof;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->parse",
          "args": [],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "484-562",
          "snippet": "int IniParser::parse()\n{\n    if (multiple_files)\n    {\n\tglob_t do_files;\n\tint len = files.size ();\n\tint flags = 0;\n\tfor (int i = 0;i<len;i++)\n\t{\n\t    glob (files[i].c_str (),flags, NULL, &do_files);\n\t    flags = GLOB_APPEND;\n\t}\n\tchar**f = do_files.gl_pathv;\n\tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n\t{\n\t    int section_index = -1;\n\t    string section_name = *f;\n\t    //FIXME: create function out of it.\n\t    // do we have name rewrite rules?\n\t    for (size_t j = 0; j < rewrites.size (); j++)\n\t\t{\n\t\t    RegexMatch m (rewrites[j].rx, section_name);\n\t\t    if (m)\n\t\t    {\n\t\t\tsection_index = j;\n\t\t\tsection_name = m[1];\n\t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    // do we know about the file?\n\t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n\t    if (ff == multi_files.end())\n\t    {\n\t\t// new file\n\t\tif (scanner_start (*f))\n\t\t    y2error (\"Cannot open %s.\", *f);\n\t\telse\n\t\t{\n\t\t    FileDescr fdsc (*f);\n\t\t    multi_files[*f] = fdsc;\n\t\t    inifile.initSection (section_name, \"\", -1, section_index);\n\t\t    parse_helper(inifile.getSection(section_name.c_str()));\n\t\t    scanner_stop();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif ((*ff).second.changed ())\n\t\t{\n\t\t    if (scanner_start (*f))\n\t\t\ty2error (\"Cannot open %s.\", *f);\n\t\t    else\n\t\t    {\n\t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n\t\t\tFileDescr fdsc (*f);\n\t\t\tmulti_files [*f] = fdsc;\n\t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n\t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n\t\t\tscanner_stop();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tif (scanner_start (file.c_str()))\n\t    {\n\t\ty2error (\"Can not open %s.\", file.c_str());\n\t\treturn -1;\n\t    }\n\tparse_helper(inifile);\n\tscanner_stop();\n\ttimestamp = getTimeStamp ();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse()\n  {\n      if (multiple_files)\n      {\n  \tglob_t do_files;\n  \tint len = files.size ();\n  \tint flags = 0;\n  \tfor (int i = 0;i<len;i++)\n  \t{\n  \t    glob (files[i].c_str (),flags, NULL, &do_files);\n  \t    flags = GLOB_APPEND;\n  \t}\n  \tchar**f = do_files.gl_pathv;\n  \tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n  \t{\n  \t    int section_index = -1;\n  \t    string section_name = *f;\n  \t    //FIXME: create function out of it.\n  \t    // do we have name rewrite rules?\n  \t    for (size_t j = 0; j < rewrites.size (); j++)\n  \t\t{\n  \t\t    RegexMatch m (rewrites[j].rx, section_name);\n  \t\t    if (m)\n  \t\t    {\n  \t\t\tsection_index = j;\n  \t\t\tsection_name = m[1];\n  \t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \n  \t    // do we know about the file?\n  \t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n  \t    if (ff == multi_files.end())\n  \t    {\n  \t\t// new file\n  \t\tif (scanner_start (*f))\n  \t\t    y2error (\"Cannot open %s.\", *f);\n  \t\telse\n  \t\t{\n  \t\t    FileDescr fdsc (*f);\n  \t\t    multi_files[*f] = fdsc;\n  \t\t    inifile.initSection (section_name, \"\", -1, section_index);\n  \t\t    parse_helper(inifile.getSection(section_name.c_str()));\n  \t\t    scanner_stop();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif ((*ff).second.changed ())\n  \t\t{\n  \t\t    if (scanner_start (*f))\n  \t\t\ty2error (\"Cannot open %s.\", *f);\n  \t\t    else\n  \t\t    {\n  \t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n  \t\t\tFileDescr fdsc (*f);\n  \t\t\tmulti_files [*f] = fdsc;\n  \t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n  \t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n  \t\t\tscanner_stop();\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n      else\n      {\n  \tif (scanner_start (file.c_str()))\n  \t    {\n  \t\ty2error (\"Can not open %s.\", file.c_str());\n  \t\treturn -1;\n  \t    }\n  \tparse_helper(inifile);\n  \tscanner_stop();\n  \ttimestamp = getTimeStamp ();\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"\\n------------------------------------------- parsing\""
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee.setFilename",
          "args": [
            "string (fname)"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "setFilename",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "87-96",
          "snippet": "void\nYCPDebugger::setFilename (const char *filename)\n{\n    y2debug (\"setFilename (%s)\\n\", filename);\n    if (filename)\n    {\n\tm_filename = filename;\n    }\n    return;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::setFilename (const char *filename)\n  {\n      y2debug (\"setFilename (%s)\\n\", filename);\n      if (filename)\n      {\n  \tm_filename = filename;\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "fname"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->setDepends",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "setDepends",
          "container": "Parser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Parser.cc",
          "lines": "127-131",
          "snippet": "void\nParser::setDepends()\n{\n    m_depends = true;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Parser.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Parser.h\"\n#include <stdlib.h>\n\nParser {\n  void\n  Parser::setDepends()\n  {\n      m_depends = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->setBuffered",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "setBuffered",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "128-132",
          "snippet": "void\nScanner::setBuffered ()\n{\n    m_buffered = true;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  void\n  Scanner::setBuffered ()\n  {\n      m_buffered = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->setInput",
          "args": [
            "infile",
            "fname"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "setInput",
          "container": "Parser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Parser.cc",
          "lines": "108-115",
          "snippet": "void\nParser::setInput(int fd, const char *filename)\n{\n    if (m_scanner) delete m_scanner;\n    m_scanner = new Scanner (fd, filename);\n    if (m_buffered) m_scanner->setBuffered ();\n    m_at_eof = false;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Parser.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Parser.h\"\n#include <stdlib.h>\n\nParser {\n  void\n  Parser::setInput(int fd, const char *filename)\n  {\n      if (m_scanner) delete m_scanner;\n      m_scanner = new Scanner (fd, filename);\n      if (m_buffered) m_scanner->setBuffered ();\n      m_at_eof = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to open '%s'\\n\"",
            "fname"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to create Parser\\n\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Bad argument '%s'\\nUsage: runycp [-l log] {-I include-path} {-M module-path} [name.ycp]\\n\"",
            "argv[argp]"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[argp] + 2",
            "\"depends\""
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPPathSearch::addPath",
          "args": [
            "YCPPathSearch::Module",
            "path"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "addPath",
          "container": "YCPPathSearch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/pathsearch.cc",
          "lines": "343-349",
          "snippet": "void\nYCPPathSearch::addPath (Kind kind, const string& path)\n{\n    std::list<string>& l = searchList[kind];\n    if (std::find(l.begin(), l.end(), path) == l.end())\n\tl.push_front(path);\n}",
          "includes": [
            "#include \"pathsearch.h\"",
            "#include <ycp/y2log.h>",
            "#include <boost/algorithm/string.hpp>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "std::list<string> YCPPathSearch::searchList[YCPPathSearch::num_Kind];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pathsearch.h\"\n#include <ycp/y2log.h>\n#include <boost/algorithm/string.hpp>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n\nstd::list<string> YCPPathSearch::searchList[YCPPathSearch::num_Kind];\n\nYCPPathSearch {\n  void\n  YCPPathSearch::addPath (Kind kind, const string& path)\n  {\n      std::list<string>& l = searchList[kind];\n      if (std::find(l.begin(), l.end(), path) == l.end())\n  \tl.push_front(path);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"missing argument to '-M'\\n\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"missing argument to '-I'\\n\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_log_filename",
          "args": [
            "argv[argp]"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "set_log_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2changes.cc",
          "lines": "188-240",
          "snippet": "static void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2CHANGES_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2CHANGES_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2CHANGES_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2CHANGES_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2CHANGES_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2CHANGES_FALLBACK );\n\n\t\tlogname = Y2CHANGES_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2CHANGES_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2CHANGES_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2CHANGES_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2CHANGES_VAR_NUM\t\"Y2MAXLOGNUM\"",
            "#define Y2CHANGES_VAR_SIZE\t\"Y2MAXLOGSIZE\"",
            "#define Y2CHANGES_FALLBACK\t\"/y2changes\"",
            "#define Y2CHANGES_USER\t\"/.y2changes\"\t\t/* Relative to $HOME */",
            "#define Y2CHANGES_ROOT\tLOGDIR \"/y2changes\"",
            "#define Y2CHANGES_MAXNUM\t10\t\t\t/* Maximum logfiles number */",
            "#define Y2CHANGES_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */"
          ],
          "globals_used": [
            "static bool did_set_logname = false;",
            "static const char *logname;",
            "static off_t maxlogsize;",
            "static int   maxlognum;",
            "static bool log_to_file = true;",
            "static bool log_to_syslog = false;",
            "static FILE *Y2CHANGES_STDERR = stderr;",
            "static void shift_log_files(string filename);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/y2changes.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2CHANGES_VAR_NUM\t\"Y2MAXLOGNUM\"\n#define Y2CHANGES_VAR_SIZE\t\"Y2MAXLOGSIZE\"\n#define Y2CHANGES_FALLBACK\t\"/y2changes\"\n#define Y2CHANGES_USER\t\"/.y2changes\"\t\t/* Relative to $HOME */\n#define Y2CHANGES_ROOT\tLOGDIR \"/y2changes\"\n#define Y2CHANGES_MAXNUM\t10\t\t\t/* Maximum logfiles number */\n#define Y2CHANGES_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */\n\nstatic bool did_set_logname = false;\nstatic const char *logname;\nstatic off_t maxlogsize;\nstatic int   maxlognum;\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic FILE *Y2CHANGES_STDERR = stderr;\nstatic void shift_log_files(string filename);\n\nstatic void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2CHANGES_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2CHANGES_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2CHANGES_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2CHANGES_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2CHANGES_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2CHANGES_FALLBACK );\n\n\t\tlogname = Y2CHANGES_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2CHANGES_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2CHANGES_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2CHANGES_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPPathSearch::initialize",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "initialize",
          "container": "YCPPathSearch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/pathsearch.cc",
          "lines": "274-284",
          "snippet": "void\nYCPPathSearch::initialize ()\n{\n    if (! initialized)\n    {\n\tinitialize (Client, \"/clients\");\n\tinitialize (Include, \"/include\");\n\tinitialize (Module, \"/modules\");\n\tinitialized = true;\n    }\n}",
          "includes": [
            "#include \"pathsearch.h\"",
            "#include <ycp/y2log.h>",
            "#include <boost/algorithm/string.hpp>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool YCPPathSearch::initialized = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pathsearch.h\"\n#include <ycp/y2log.h>\n#include <boost/algorithm/string.hpp>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n\nbool YCPPathSearch::initialized = false;\n\nYCPPathSearch {\n  void\n  YCPPathSearch::initialize ()\n  {\n      if (! initialized)\n      {\n  \tinitialize (Client, \"/clients\");\n  \tinitialize (Include, \"/include\");\n  \tinitialize (Module, \"/modules\");\n  \tinitialized = true;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <stdio.h>\n\nextern ExecutionEnvironment ee;\nextern int SymbolTableDebug;\n\nint\nmain (int argc, const char *argv[])\n{\n    const char *fname = 0;\n    FILE *infile = stdin;\n    bool make_depends = false;\n\n    YCPPathSearch::initialize ();\n\n    if (argc > 1)\n    {\n\tint argp = 1;\n\twhile (argp < argc)\n\t{\n\t    if ((argv[argp][0] == '-')\n\t        && (argv[argp][1] == 'l')\n\t        && (argp+1 < argc))\n\t    {\n\t\targp++;\n\t\tset_log_filename (argv[argp]);\n\t    }\n\t    // TODO - this is getting messy, use getopt_long\n\t    else if ((argv[argp][0] == '-')\n\t        && (argv[argp][1] == 'I'))\n\t    {\n\t\tconst char *path = argv[argp] + 2;\n\t\tif ((*path == 0)\n\t\t    && (argp+1 < argc))\n\t\t{\n\t\t    argp++;\n\t\t    path = argv[argp];\n\t\t}\n\t\tif (*path == 0)\n\t\t{\n\t\t    fprintf (stderr, \"missing argument to '-I'\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    YCPPathSearch::addPath (YCPPathSearch::Include, path);\n\t\t}\n\t    }\n\t    else if ((argv[argp][0] == '-')\n\t        && (argv[argp][1] == 'M'))\n\t    {\n\t\tconst char *path = argv[argp] + 2;\n\t\tif ((*path == 0)\n\t\t    && (argp+1 < argc))\n\t\t{\n\t\t    argp++;\n\t\t    path = argv[argp];\n\t\t}\n\t\tif (*path == 0)\n\t\t{\n\t\t    fprintf (stderr, \"missing argument to '-M'\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    YCPPathSearch::addPath (YCPPathSearch::Module, path);\n\t\t}\n\t    }\n\t    else if ((argv[argp][0] == '-')\n\t        && (argv[argp][1] == '-')\n\t        && (strcmp (argv[argp] + 2, \"depends\") == 0))\n\t    {\n\t\tmake_depends = true;\t\n\t    }\n\t    else if ((argv[argp][0] != '-')\n\t\t     && fname == 0)\n\t    {\n\t\tfname = argv[argp];\n\t    }\n\t    else\n\t    {\n\t\tfprintf (stderr, \"Bad argument '%s'\\nUsage: runycp [-l log] {-I include-path} {-M module-path} [name.ycp]\\n\", argv[argp]);\n\t\treturn 1;\n\t    }\n\t    argp++;\n\t}\n    }\n\n    Parser *parser;\n    parser = new Parser ();\n\n    if (!parser)\n    {\n\tfprintf (stderr, \"Failed to create Parser\\n\");\n\treturn 1;\n    }\n\n    if (fname != 0)\n    {\n\tinfile = fopen (fname, \"r\");\n\tif (infile == 0)\n\t{\n\t    fprintf (stderr, \"Failed to open '%s'\\n\", fname);\n\t    return 1;\n\t}\n    }\n    else\n    {\n\tfname = \"stdin\";\n    }\n\n    parser->setInput (infile, fname);\n    parser->setBuffered();\n    if (make_depends)\n\tparser->setDepends();\n\t\n    ee.setFilename (string (fname));\n\n    YCodePtr code = 0;\n\n    SymbolTableDebug = 0;\n\n    for (;;)\n    {\n\ty2debug (\"\\n------------------------------------------- parsing\");\n\tcode = parser->parse ();\n\tif (parser->atEOF())\n\t{\n\t    break;\n\t}\n\n\tif (code == 0)\n\t{\n\t    fprintf (stderr, \"runycp: parser error\\n\");\n\t    break;\n\t}\n\n\tfprintf (stderr, \n\t    \"Parsed:\\n\"\n\t    \"----------------------------------------------------------------------\\n\"\n\t    \"%s\\n\"\n\t    \"----------------------------------------------------------------------\\n\",\n\t    code->toString().c_str());\n\n\ty2debug (\"\\n------------------------------------------- running\");\n\tYCPValue value = code->evaluate ();\n\n\ty2debug (\"\\n------------------------------------------- done\");\n\tprintf (\"(%s)\\n\", value.isNull() ? \"nil\" : value->toString().c_str());\n\n    }\n\n    delete parser;\n\n    if (infile != stdin)\n    {\n\tfclose (infile);\n    }\n    return 0;\n}"
  },
  {
    "function_name": "isServerCreator",
    "container": "TestY2CC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runycp.cc",
    "lines": "60-60",
    "snippet": "virtual bool isServerCreator () const { return true;}",
    "includes": [
      "#include <y2/Y2ComponentCreator.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <stdio.h>\n\nTestY2CC {\n  virtual bool isServerCreator () const { return true;}\n}"
  },
  {
    "function_name": "TestY2CC",
    "container": "TestY2CC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runycp.cc",
    "lines": "54-54",
    "snippet": "TestY2CC() : Y2ComponentCreator(Y2ComponentBroker::SCRIPT) {}",
    "includes": [
      "#include <y2/Y2ComponentCreator.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <stdio.h>\n\nTestY2CC {\n  TestY2CC() : Y2ComponentCreator(Y2ComponentBroker::SCRIPT) {}\n}"
  },
  {
    "function_name": "name",
    "container": "TestY2Component",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runycp.cc",
    "lines": "46-46",
    "snippet": "virtual string name () const { return \"test\";}",
    "includes": [
      "#include <y2/Y2ComponentCreator.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <stdio.h>\n\nTestY2Component {\n  virtual string name () const { return \"test\";}\n}"
  }
]