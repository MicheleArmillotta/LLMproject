[
  {
    "function_name": "determineFlexType",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/TypeStatics.cc",
    "lines": "524-564",
    "snippet": "constTypePtr\nType::determineFlexType (constFunctionTypePtr actual, constFunctionTypePtr declared)\n{\n    y2debug (\"determineFlexType (actual %s, declared %s)\", actual ? actual->toString().c_str() : \"NULL\", declared ? declared->toString().c_str() : \"NULL\");\n\n    // if builtin decl returns 'flex', the parameter deduces the return type\n\n    constTypePtr result;\n\n    if (declared->parameterCount() <= 0)\n    {\n\tycp2error (\"declared->parameterCount() <= 0\");\n\treturn 0;\n    }\n\n    unsigned int flexnumber = 0;\n\n    constTypePtr flextype;\n\n    do\n    {\n\tflextype = declared->matchFlex (actual, flexnumber);\n\n\ty2debug (\"flextype %d:'%s'\", flexnumber, flextype == 0 ? \"NONE\" : flextype->toString().c_str());\n\n\tif (flextype == 0)\n\t{\n\t    result = declared;\n\t}\n\telse\n\t{\n\t    // exchange <flex> with the correct type\n\t    result = declared->unflex (flextype, flexnumber);\n\t    declared = result;\n\t}\n    }\n    while ((flexnumber++ == 0) || (flextype != 0));\n\n    y2debug (\"determineFlexType returns '%s'\", result ? result->toString().c_str() : \"ERROR\");\n    return result;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"determineFlexType returns '%s'\"",
            "result ? result->toString().c_str() : \"ERROR\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result->toString",
          "args": [],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "declared->unflex",
          "args": [
            "flextype",
            "flexnumber"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "unflex",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1857-1872",
          "snippet": "constTypePtr\nFunctionType::unflex (constTypePtr type, unsigned int number) const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype->unflex (type, number)));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount (); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType(index)->unflex (type, number));\n\t}\n    }\n#if DO_DEBUG\n    y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n#endif\n    return tp;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  constTypePtr\n  FunctionType::unflex (constTypePtr type, unsigned int number) const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype->unflex (type, number)));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount (); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType(index)->unflex (type, number));\n  \t}\n      }\n  #if DO_DEBUG\n      y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n  #endif\n      return tp;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"flextype %d:'%s'\"",
            "flexnumber",
            "flextype == 0 ? \"NONE\" : flextype->toString().c_str()"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "declared->matchFlex",
          "args": [
            "actual",
            "flexnumber"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "matchFlex",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1716-1736",
          "snippet": "constTypePtr\nFunctionType::matchFlex (constTypePtr type, unsigned int number) const\n{\n#if DO_DEBUG\n    y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n#endif\n    if (!type->isFunction())\n    {\n\treturn 0;\n    }\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    constFunctionTypePtr ft = (constFunctionTypePtr)type;\n    if (!ft->m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->matchFlex (ft->m_arguments, number);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  constTypePtr\n  FunctionType::matchFlex (constTypePtr type, unsigned int number) const\n  {\n  #if DO_DEBUG\n      y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n  #endif\n      if (!type->isFunction())\n      {\n  \treturn 0;\n      }\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      constFunctionTypePtr ft = (constFunctionTypePtr)type;\n      if (!ft->m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->matchFlex (ft->m_arguments, number);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"declared->parameterCount() <= 0\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "declared->parameterCount",
          "args": [],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"determineFlexType (actual %s, declared %s)\"",
            "actual ? actual->toString().c_str() : \"NULL\"",
            "declared ? declared->toString().c_str() : \"NULL\""
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  constTypePtr\n  Type::determineFlexType (constFunctionTypePtr actual, constFunctionTypePtr declared)\n  {\n      y2debug (\"determineFlexType (actual %s, declared %s)\", actual ? actual->toString().c_str() : \"NULL\", declared ? declared->toString().c_str() : \"NULL\");\n  \n      // if builtin decl returns 'flex', the parameter deduces the return type\n  \n      constTypePtr result;\n  \n      if (declared->parameterCount() <= 0)\n      {\n  \tycp2error (\"declared->parameterCount() <= 0\");\n  \treturn 0;\n      }\n  \n      unsigned int flexnumber = 0;\n  \n      constTypePtr flextype;\n  \n      do\n      {\n  \tflextype = declared->matchFlex (actual, flexnumber);\n  \n  \ty2debug (\"flextype %d:'%s'\", flexnumber, flextype == 0 ? \"NONE\" : flextype->toString().c_str());\n  \n  \tif (flextype == 0)\n  \t{\n  \t    result = declared;\n  \t}\n  \telse\n  \t{\n  \t    // exchange <flex> with the correct type\n  \t    result = declared->unflex (flextype, flexnumber);\n  \t    declared = result;\n  \t}\n      }\n      while ((flexnumber++ == 0) || (flextype != 0));\n  \n      y2debug (\"determineFlexType returns '%s'\", result ? result->toString().c_str() : \"ERROR\");\n      return result;\n  }\n}"
  },
  {
    "function_name": "fromSignature",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/TypeStatics.cc",
    "lines": "280-512",
    "snippet": "constTypePtr\nType::fromSignature (const char ** signature)\n{\n    if ((signature == 0)\n\t|| (*signature == 0))\n    {\n\treturn 0;\n    }\n    if (**signature == 0)\n    {\n\treturn Type::Unspec;\n    }\n\n    constTypePtr t = 0;\n\n    bool as_const = false;\n\n    const char *signature_copy = *signature;\n    const char *signature_start = *signature;\n\n//    y2debug (\"Type::fromSignature (\\\"%s\\\")\\n\", *signature);\n\n    int k = nextToken (signature);\n\n    if (k == -1)\t\t// const\n    {\n//\ty2debug (\"Const !\");\n\tas_const = true;\n\tsignature_copy = *signature;\n\tk = nextToken (signature);\n    }\n\n    char next = 0;\n\n    switch (k)\n    {\n\tcase AnyT:\t\tt = (as_const) ? Type::ConstAny : Type::Any; break;\n\tcase BooleanT:\t\tt = (as_const) ? Type::ConstBoolean : Type::Boolean; break;\n\tcase ByteblockT:\tt = (as_const) ? Type::ConstByteblock : Type::Byteblock; break;\n\tcase ErrorT:\t\tt = Type::Error; break;\n\tcase FlexT:\t\tt = (as_const) ? Type::ConstFlex : Type::Flex; break;\n\tcase FloatT:\t\tt = (as_const) ? Type::ConstFloat : Type::Float; break;\n\tcase IntegerT:\t\tt = (as_const) ? Type::ConstInteger : Type::Integer; break;\n\tcase LocaleT:\t\tt = (as_const) ? Type::ConstLocale : Type::Locale; break;\n\tcase PathT:\t\tt = (as_const) ? Type::ConstPath : Type::Path; break;\n\tcase StringT:\t\tt = (as_const) ? Type::ConstString : Type::String; break;\n\tcase SymbolT:\t\tt = (as_const) ? Type::ConstSymbol : Type::Symbol; break;\n\tcase TermT:\t\tt = (as_const) ? Type::ConstTerm : Type::Term; break;\n\tcase VoidT:\t\tt = (as_const) ? Type::ConstVoid : Type::Void; break;\n\tcase WildcardT:\t\tt = Type::Wildcard; break;\n\n\t// codes\n\tcase VariableT:\t\tk = VariableT; next = '<'; break;\n\tcase '(':\t\tk = FunctionT; break;\n\n\t// constructors\n\tcase BlockT:\t\tk = BlockT; next = '<'; break;\n\tcase ListT:\t\tk = ListT; next = '<'; break;\n\tcase MapT:\t\tk = MapT; next = '<'; break;\n\tcase TupleT:\t\tk = TupleT; next = '<'; break;\n\tdefault:\n\t    if (k < -100)\n\t    {\n\t\tswitch (k)\n\t\t{\n\t\t    case -101:\tt = (as_const) ? Type::ConstNFlex1 : Type::NFlex1; break;\n\t\t    case -102:\tt = (as_const) ? Type::ConstNFlex2 : Type::NFlex2; break;\n\t\t    case -103:\tt = (as_const) ? Type::ConstNFlex3 : Type::NFlex3; break;\n\t\t    case -104:\tt = (as_const) ? Type::ConstNFlex4 : Type::NFlex4; break;\n\t\t    default:\tt = NFlexTypePtr (new NFlexType (-(k+100))); break;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ty2error (\"Builtin signature code %d [%s] not handled\\n\", **signature, signature_start);\n\t    }\n\tbreak;\n    }\n\n    signature_copy = *signature;\n\n    if (next != 0)\n    {\n\tif (nextToken (signature) != next)\n\t{\n\t    y2error (\"Expecting '%c' at '%s' [Complete signature is '%s']\\n\", next, signature_copy, signature_start);\n\t    return 0;\n\t}\n    }\n\n    if (t == 0)\t\t\t// no base type yet\n    {\n//\ty2debug (\"k %d, signature '%s'\", k, *signature);\n\tif (k == UnspecT)\t// no nothing\n\t{\n\t    y2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n\t    return 0;\n\t}\n\n\tsignature_copy = *signature;\n\tconstTypePtr t1 = fromSignature (signature);\n\n\tif (t1 == 0)\n\t{\n\t    y2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n\t    return 0;\n\t}\n//\ty2debug (\"t1 '%s', k %d, signature '%s'\", t1->toString().c_str(), k, *signature);\n\n\tswitch (k)\n\t{\n\t    case VariableT: t = VariableTypePtr (new VariableType (t1, as_const)); next = '>'; break;\n\t    case BlockT:    t = BlockTypePtr (new BlockType (t1, as_const)); next = '>'; break;\n\t    case ListT:\t    t = ListTypePtr (new ListType (t1, as_const)); next = '>'; break;\n\t    case MapT:\n\t    {\n\t\tsignature_copy = *signature;\n\n\t\tif (nextToken (signature) != ',')\n\t\t{\n\t\t    y2error (\"Expected ',' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n\t\t    return 0;\n\t\t}\n\n\t\tconstTypePtr t2 = fromSignature (signature);\n\t\tif (t2 == 0)\n\t\t{\n\t\t    y2debug (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n\t\t    return 0;\n\t\t}\n\n\t\tt = MapTypePtr (new MapType (t1, t2, as_const));\n\t\tnext = '>'; \n\t    }\n\t    break;\n\t    case TupleT:    t = TupleTypePtr (new TupleType (t1, as_const)); next = 0; break;\n\t    case FunctionT: t = FunctionTypePtr (new FunctionType (t1, as_const)); next = 0; break;\n\t    default:\n\t\ty2error (\"Post-Kind '%d'[%c] not handled\\n\", k, isprint (k) ? k : '?');\n\t\treturn 0;\n\t    break;\n\t}\n\n\tif (next != 0)\n\t{\n\t    if (nextToken (signature) != next)\n\t    {\n\t\ty2error (\"Expected '%c' at '%s' [Complete signature is '%s']\\n\", next, signature_copy, signature_start);\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n    if (t == 0)\n    {\n\treturn 0;\n    }\n\n//    y2debug (\"t '%s', signature '%s', k %d\", t->toString().c_str(), *signature, k);\n\n    signature_copy = *signature;\n    if (**signature == '&')\n    {\n\tTypePtr tr = t->clone();\n\ttr->asReference();\n\tt = tr;\n\tdo { (*signature)++; } while (isspace (**signature));\n    }\n\n    // check for function, it's postfix !\n\n    if (**signature == '(')\n    {\n//\ty2debug (\"function!\");\n\tFunctionTypePtr f (new FunctionType (t, as_const));\n\n\tdo\n\t{\n\t    do { (*signature)++; } while (isspace (**signature));\n\t    if (**signature == ')')\n\t    {\n\t\tbreak;\n\t    }\n\t    signature_copy = *signature;\n\t    constTypePtr t1 = fromSignature (signature);\n\t    if (t1 == 0)\n\t    {\n\t\t*signature = signature_copy;\n\t\tbreak;\n\t    }\n\n\t    f->concat (t1);\n\t}\n\twhile (**signature == ',');\n\n\tif (**signature != ')')\n\t{\n\t    y2error (\"Expected ')' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n\t    return 0;\n\t}\n\n\t(*signature)++;\n\tt = f;\n    }\n    else if (k == TupleT)\n    {\n\tTupleTypePtr tt = t->clone();\n//\ty2debug (\"tuple! '%s', signature '%s'\", tt->toString().c_str(), *signature);\n\twhile (**signature == ',')\n\t{\n\t    (*signature)++;\n\t    signature_copy = *signature;\n\t    constTypePtr t1 = fromSignature (signature);\n\t    if (t1 == 0)\n\t    {\n\t\ty2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n\t\treturn 0;\n\t    }\n\n\t    tt->concat (t1);\n\t}\n\tif (**signature != '>')\n\t{\n\t    y2error (\"Expected '>' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n\t    return 0;\n\t}\n\tt = tt;\n    }\n\n//    y2debug (\"Type::fromSignature Done: '%s' -> '%s' [%s]\\n\", signature_start, t->toString().c_str(), *signature);\n\n    return t;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Expected '>' at '%s' [Complete signature is '%s']\\n\"",
            "signature_copy",
            "signature_start"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tt->concat",
          "args": [
            "t1"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "concat",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1649-1661",
          "snippet": "void\nFunctionType::concat (constTypePtr t)\n{\n    if (!m_arguments)\n    {\n\tm_arguments = TupleTypePtr (new TupleType (t));\n    }\n    else\n    {\n\tm_arguments->concat (t);\n    }\n    return;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  void\n  FunctionType::concat (constTypePtr t)\n  {\n      if (!m_arguments)\n      {\n  \tm_arguments = TupleTypePtr (new TupleType (t));\n      }\n      else\n      {\n  \tm_arguments->concat (t);\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unknown type at '%s' [Complete signature is '%s']!\\n\"",
            "signature_copy",
            "signature_start"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fromSignature",
          "args": [
            "signature"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "fromSignature",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/TypeStatics.cc",
          "lines": "280-512",
          "snippet": "constTypePtr\nType::fromSignature (const char ** signature)\n{\n    if ((signature == 0)\n\t|| (*signature == 0))\n    {\n\treturn 0;\n    }\n    if (**signature == 0)\n    {\n\treturn Type::Unspec;\n    }\n\n    constTypePtr t = 0;\n\n    bool as_const = false;\n\n    const char *signature_copy = *signature;\n    const char *signature_start = *signature;\n\n//    y2debug (\"Type::fromSignature (\\\"%s\\\")\\n\", *signature);\n\n    int k = nextToken (signature);\n\n    if (k == -1)\t\t// const\n    {\n//\ty2debug (\"Const !\");\n\tas_const = true;\n\tsignature_copy = *signature;\n\tk = nextToken (signature);\n    }\n\n    char next = 0;\n\n    switch (k)\n    {\n\tcase AnyT:\t\tt = (as_const) ? Type::ConstAny : Type::Any; break;\n\tcase BooleanT:\t\tt = (as_const) ? Type::ConstBoolean : Type::Boolean; break;\n\tcase ByteblockT:\tt = (as_const) ? Type::ConstByteblock : Type::Byteblock; break;\n\tcase ErrorT:\t\tt = Type::Error; break;\n\tcase FlexT:\t\tt = (as_const) ? Type::ConstFlex : Type::Flex; break;\n\tcase FloatT:\t\tt = (as_const) ? Type::ConstFloat : Type::Float; break;\n\tcase IntegerT:\t\tt = (as_const) ? Type::ConstInteger : Type::Integer; break;\n\tcase LocaleT:\t\tt = (as_const) ? Type::ConstLocale : Type::Locale; break;\n\tcase PathT:\t\tt = (as_const) ? Type::ConstPath : Type::Path; break;\n\tcase StringT:\t\tt = (as_const) ? Type::ConstString : Type::String; break;\n\tcase SymbolT:\t\tt = (as_const) ? Type::ConstSymbol : Type::Symbol; break;\n\tcase TermT:\t\tt = (as_const) ? Type::ConstTerm : Type::Term; break;\n\tcase VoidT:\t\tt = (as_const) ? Type::ConstVoid : Type::Void; break;\n\tcase WildcardT:\t\tt = Type::Wildcard; break;\n\n\t// codes\n\tcase VariableT:\t\tk = VariableT; next = '<'; break;\n\tcase '(':\t\tk = FunctionT; break;\n\n\t// constructors\n\tcase BlockT:\t\tk = BlockT; next = '<'; break;\n\tcase ListT:\t\tk = ListT; next = '<'; break;\n\tcase MapT:\t\tk = MapT; next = '<'; break;\n\tcase TupleT:\t\tk = TupleT; next = '<'; break;\n\tdefault:\n\t    if (k < -100)\n\t    {\n\t\tswitch (k)\n\t\t{\n\t\t    case -101:\tt = (as_const) ? Type::ConstNFlex1 : Type::NFlex1; break;\n\t\t    case -102:\tt = (as_const) ? Type::ConstNFlex2 : Type::NFlex2; break;\n\t\t    case -103:\tt = (as_const) ? Type::ConstNFlex3 : Type::NFlex3; break;\n\t\t    case -104:\tt = (as_const) ? Type::ConstNFlex4 : Type::NFlex4; break;\n\t\t    default:\tt = NFlexTypePtr (new NFlexType (-(k+100))); break;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ty2error (\"Builtin signature code %d [%s] not handled\\n\", **signature, signature_start);\n\t    }\n\tbreak;\n    }\n\n    signature_copy = *signature;\n\n    if (next != 0)\n    {\n\tif (nextToken (signature) != next)\n\t{\n\t    y2error (\"Expecting '%c' at '%s' [Complete signature is '%s']\\n\", next, signature_copy, signature_start);\n\t    return 0;\n\t}\n    }\n\n    if (t == 0)\t\t\t// no base type yet\n    {\n//\ty2debug (\"k %d, signature '%s'\", k, *signature);\n\tif (k == UnspecT)\t// no nothing\n\t{\n\t    y2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n\t    return 0;\n\t}\n\n\tsignature_copy = *signature;\n\tconstTypePtr t1 = fromSignature (signature);\n\n\tif (t1 == 0)\n\t{\n\t    y2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n\t    return 0;\n\t}\n//\ty2debug (\"t1 '%s', k %d, signature '%s'\", t1->toString().c_str(), k, *signature);\n\n\tswitch (k)\n\t{\n\t    case VariableT: t = VariableTypePtr (new VariableType (t1, as_const)); next = '>'; break;\n\t    case BlockT:    t = BlockTypePtr (new BlockType (t1, as_const)); next = '>'; break;\n\t    case ListT:\t    t = ListTypePtr (new ListType (t1, as_const)); next = '>'; break;\n\t    case MapT:\n\t    {\n\t\tsignature_copy = *signature;\n\n\t\tif (nextToken (signature) != ',')\n\t\t{\n\t\t    y2error (\"Expected ',' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n\t\t    return 0;\n\t\t}\n\n\t\tconstTypePtr t2 = fromSignature (signature);\n\t\tif (t2 == 0)\n\t\t{\n\t\t    y2debug (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n\t\t    return 0;\n\t\t}\n\n\t\tt = MapTypePtr (new MapType (t1, t2, as_const));\n\t\tnext = '>'; \n\t    }\n\t    break;\n\t    case TupleT:    t = TupleTypePtr (new TupleType (t1, as_const)); next = 0; break;\n\t    case FunctionT: t = FunctionTypePtr (new FunctionType (t1, as_const)); next = 0; break;\n\t    default:\n\t\ty2error (\"Post-Kind '%d'[%c] not handled\\n\", k, isprint (k) ? k : '?');\n\t\treturn 0;\n\t    break;\n\t}\n\n\tif (next != 0)\n\t{\n\t    if (nextToken (signature) != next)\n\t    {\n\t\ty2error (\"Expected '%c' at '%s' [Complete signature is '%s']\\n\", next, signature_copy, signature_start);\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n    if (t == 0)\n    {\n\treturn 0;\n    }\n\n//    y2debug (\"t '%s', signature '%s', k %d\", t->toString().c_str(), *signature, k);\n\n    signature_copy = *signature;\n    if (**signature == '&')\n    {\n\tTypePtr tr = t->clone();\n\ttr->asReference();\n\tt = tr;\n\tdo { (*signature)++; } while (isspace (**signature));\n    }\n\n    // check for function, it's postfix !\n\n    if (**signature == '(')\n    {\n//\ty2debug (\"function!\");\n\tFunctionTypePtr f (new FunctionType (t, as_const));\n\n\tdo\n\t{\n\t    do { (*signature)++; } while (isspace (**signature));\n\t    if (**signature == ')')\n\t    {\n\t\tbreak;\n\t    }\n\t    signature_copy = *signature;\n\t    constTypePtr t1 = fromSignature (signature);\n\t    if (t1 == 0)\n\t    {\n\t\t*signature = signature_copy;\n\t\tbreak;\n\t    }\n\n\t    f->concat (t1);\n\t}\n\twhile (**signature == ',');\n\n\tif (**signature != ')')\n\t{\n\t    y2error (\"Expected ')' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n\t    return 0;\n\t}\n\n\t(*signature)++;\n\tt = f;\n    }\n    else if (k == TupleT)\n    {\n\tTupleTypePtr tt = t->clone();\n//\ty2debug (\"tuple! '%s', signature '%s'\", tt->toString().c_str(), *signature);\n\twhile (**signature == ',')\n\t{\n\t    (*signature)++;\n\t    signature_copy = *signature;\n\t    constTypePtr t1 = fromSignature (signature);\n\t    if (t1 == 0)\n\t    {\n\t\ty2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n\t\treturn 0;\n\t    }\n\n\t    tt->concat (t1);\n\t}\n\tif (**signature != '>')\n\t{\n\t    y2error (\"Expected '>' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n\t    return 0;\n\t}\n\tt = tt;\n    }\n\n//    y2debug (\"Type::fromSignature Done: '%s' -> '%s' [%s]\\n\", signature_start, t->toString().c_str(), *signature);\n\n    return t;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "t->clone",
          "args": [],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "clone",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1842-1854",
          "snippet": "TypePtr\nFunctionType::clone () const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType (index));\n\t}\n    }\n    return tp;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  TypePtr\n  FunctionType::clone () const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType (index));\n  \t}\n      }\n      return tp;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Expected ')' at '%s' [Complete signature is '%s']\\n\"",
            "signature_copy",
            "signature_start"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "**signature"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "**signature"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr->asReference",
          "args": [],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "asReference",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "239-249",
          "snippet": "YCPReference\nYCPValueRep::asReference() const\n{\n    if (!isReference())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Reference!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPReference (static_cast<const YCPReferenceRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPReference\n  YCPValueRep::asReference() const\n  {\n      if (!isReference())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Reference!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPReference (static_cast<const YCPReferenceRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Expected '%c' at '%s' [Complete signature is '%s']\\n\"",
            "next",
            "signature_copy",
            "signature_start"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nextToken",
          "args": [
            "signature"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "nextToken",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/TypeStatics.cc",
          "lines": "68-271",
          "snippet": "int\nType::nextToken (const char **signature)\n{\n//    const char *signature_copy = *signature;\n\n    while (isspace (**signature)) (*signature)++;\n\n    int k = UnspecT;\n\n    switch (**signature)\n    {\n\tcase 0:\n\tbreak;\n\tcase 'a':\t// any\n\tcase 'A':\n\t{\n\t    if (strncasecmp (*signature, \"any\", 3) == 0)\n\t    {\n\t\t*signature += 3;\n\t\tk = AnyT;\n\t    }\n\t}\n\tbreak;\n\tcase 'b':\t// boolean, byteblock, block\n\tcase 'B':\n\t{\n\t    if (strncasecmp (*signature, \"boolean\", 7) == 0)\n\t    {\n\t\t*signature += 7;\n\t\tk = BooleanT;\n\t    }\n\t    else if (strncasecmp (*signature, \"byteblock\", 9) == 0)\n\t    {\n\t\t*signature += 9;\n\t\tk = ByteblockT;\n\t    }\n\t    else if (strncasecmp (*signature, \"block\", 5) == 0)\n\t    {\n\t\t*signature += 5;\n\t\tk = BlockT;\n\t    }\n\t}\n\tbreak;\n\tcase 'c':\t// const\n\tcase 'C':\n\t{\n\t    if (strncasecmp (*signature, \"const\", 5) == 0)\n\t    {\n\t\t*signature += 5;\n\t\tk = -1;\n\t    }\n\t}\n\tbreak;\n\tcase 'f':\t// float, flex\n\tcase 'F':\n\t{\n\t    if (strncasecmp (*signature, \"float\", 5) == 0)\n\t    {\n\t\t*signature += 5;\n\t\tk = FloatT;\n\t    }\n\t    else if (strncasecmp (*signature, \"flex\", 4) == 0)\n\t    {\n\t\t*signature += 4;\n\t\tk = 0;\n\t\twhile (isdigit (**signature))\n\t\t{\n\t\t    k *= 10;\n\t\t    k += (**signature - '0');\n\t\t    *signature += 1;\n\t\t}\n\t\tif (k == 0)\n\t\t{\n\t\t    k = FlexT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    k = -100 - k;\n\t\t}\n\t    }\n\t}\n\tbreak;\n\tcase 'i':\t// integer\n\tcase 'I':\n\t{\n\t    if (strncasecmp (*signature, \"integer\", 7) == 0)\n\t    {\n\t\t*signature += 7;\n\t\tk = IntegerT;\n\t    }\n\t}\n\tbreak;\n\tcase 'l':\t// list, locale\n\tcase 'L':\n\t{\n\t    if (strncasecmp (*signature, \"list\", 4) == 0)\n\t    {\n\t\t*signature += 4;\n\t\tk = ListT;\n\t    }\n\t    else if (strncasecmp (*signature, \"locale\", 6) == 0)\n\t    {\n\t\t*signature += 6;\n\t\tk = LocaleT;\n\t    }\n\t}\n\tbreak;\n\tcase 'm':\t// map\n\tcase 'M':\n\t{\n\t    if (strncasecmp (*signature, \"map\", 3) == 0)\n\t    {\n\t\t*signature += 3;\n\t\tk = MapT;\n\t    }\n\t}\n\tbreak;\n\tcase 'p':\t// path\n\tcase 'P':\n\t{\n\t    if (strncasecmp (*signature, \"path\", 4) == 0)\n\t    {\n\t\t*signature += 4;\n\t\tk = PathT;\n\t    }\n\t}\n\tbreak;\n\tcase 's':\t// static, string, symbol\n\tcase 'S':\n\t{\n\t    if (strncasecmp (*signature, \"string\", 6) == 0)\n\t    {\n\t\t*signature += 6;\n\t\tk = StringT;\n\t    }\n\t    else if (strncasecmp (*signature, \"symbol\", 6) == 0)\n\t    {\n\t\t*signature += 6;\n\t\tk = SymbolT;\n\t    }\n\t}\n\tbreak;\n\tcase 't':\t// term, tuple\n\tcase 'T':\n\t{\n\t    if (strncasecmp (*signature, \"term\", 4) == 0)\n\t    {\n\t\t*signature += 4;\n\t\tk = TermT;\n\t    }\n\t    else if (strncasecmp (*signature, \"tuple\", 5) == 0)\n\t    {\n\t\t*signature += 5;\n\t\tk = TupleT;\n\t    }\n\t}\n\tbreak;\n\tcase 'v':\t// void, variable\n\tcase 'V':\n\t{\n\t    if (strncasecmp (*signature, \"void\", 4) == 0)\n\t    {\n\t\t*signature += 4;\n\t\tk = VoidT;\n\t    }\n\t    else if (strncasecmp (*signature, \"variable\", 8) == 0)\n\t    {\n\t\t*signature += 8;\n\t\tk = VariableT;\n\t    }\n\t}\n\tbreak;\n\tcase '.':\t// wildcard\n\t{\n\t    if (strncasecmp (*signature, \"...\", 3) == 0)\n\t    {\n\t\t*signature += 3;\n\t\tk = WildcardT;\n\t    }\n\t}\n\tbreak;\n\tcase '&':\n\tcase '<':\n\tcase '>':\n\tcase ',':\n\tcase '(':\n\tcase ')':\n\t{\n\t    k = **signature;\n\t    (*signature)++;\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    k = ErrorT;\n\t}\n\tbreak;\n    }\n\n    while (isspace (**signature)) (*signature)++;\n\n//    y2debug (\"nextToken (%s) = %d [%s]\", signature_copy, k, *signature);\n    return k;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  int\n  Type::nextToken (const char **signature)\n  {\n  //    const char *signature_copy = *signature;\n  \n      while (isspace (**signature)) (*signature)++;\n  \n      int k = UnspecT;\n  \n      switch (**signature)\n      {\n  \tcase 0:\n  \tbreak;\n  \tcase 'a':\t// any\n  \tcase 'A':\n  \t{\n  \t    if (strncasecmp (*signature, \"any\", 3) == 0)\n  \t    {\n  \t\t*signature += 3;\n  \t\tk = AnyT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 'b':\t// boolean, byteblock, block\n  \tcase 'B':\n  \t{\n  \t    if (strncasecmp (*signature, \"boolean\", 7) == 0)\n  \t    {\n  \t\t*signature += 7;\n  \t\tk = BooleanT;\n  \t    }\n  \t    else if (strncasecmp (*signature, \"byteblock\", 9) == 0)\n  \t    {\n  \t\t*signature += 9;\n  \t\tk = ByteblockT;\n  \t    }\n  \t    else if (strncasecmp (*signature, \"block\", 5) == 0)\n  \t    {\n  \t\t*signature += 5;\n  \t\tk = BlockT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 'c':\t// const\n  \tcase 'C':\n  \t{\n  \t    if (strncasecmp (*signature, \"const\", 5) == 0)\n  \t    {\n  \t\t*signature += 5;\n  \t\tk = -1;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 'f':\t// float, flex\n  \tcase 'F':\n  \t{\n  \t    if (strncasecmp (*signature, \"float\", 5) == 0)\n  \t    {\n  \t\t*signature += 5;\n  \t\tk = FloatT;\n  \t    }\n  \t    else if (strncasecmp (*signature, \"flex\", 4) == 0)\n  \t    {\n  \t\t*signature += 4;\n  \t\tk = 0;\n  \t\twhile (isdigit (**signature))\n  \t\t{\n  \t\t    k *= 10;\n  \t\t    k += (**signature - '0');\n  \t\t    *signature += 1;\n  \t\t}\n  \t\tif (k == 0)\n  \t\t{\n  \t\t    k = FlexT;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t    k = -100 - k;\n  \t\t}\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 'i':\t// integer\n  \tcase 'I':\n  \t{\n  \t    if (strncasecmp (*signature, \"integer\", 7) == 0)\n  \t    {\n  \t\t*signature += 7;\n  \t\tk = IntegerT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 'l':\t// list, locale\n  \tcase 'L':\n  \t{\n  \t    if (strncasecmp (*signature, \"list\", 4) == 0)\n  \t    {\n  \t\t*signature += 4;\n  \t\tk = ListT;\n  \t    }\n  \t    else if (strncasecmp (*signature, \"locale\", 6) == 0)\n  \t    {\n  \t\t*signature += 6;\n  \t\tk = LocaleT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 'm':\t// map\n  \tcase 'M':\n  \t{\n  \t    if (strncasecmp (*signature, \"map\", 3) == 0)\n  \t    {\n  \t\t*signature += 3;\n  \t\tk = MapT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 'p':\t// path\n  \tcase 'P':\n  \t{\n  \t    if (strncasecmp (*signature, \"path\", 4) == 0)\n  \t    {\n  \t\t*signature += 4;\n  \t\tk = PathT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 's':\t// static, string, symbol\n  \tcase 'S':\n  \t{\n  \t    if (strncasecmp (*signature, \"string\", 6) == 0)\n  \t    {\n  \t\t*signature += 6;\n  \t\tk = StringT;\n  \t    }\n  \t    else if (strncasecmp (*signature, \"symbol\", 6) == 0)\n  \t    {\n  \t\t*signature += 6;\n  \t\tk = SymbolT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 't':\t// term, tuple\n  \tcase 'T':\n  \t{\n  \t    if (strncasecmp (*signature, \"term\", 4) == 0)\n  \t    {\n  \t\t*signature += 4;\n  \t\tk = TermT;\n  \t    }\n  \t    else if (strncasecmp (*signature, \"tuple\", 5) == 0)\n  \t    {\n  \t\t*signature += 5;\n  \t\tk = TupleT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 'v':\t// void, variable\n  \tcase 'V':\n  \t{\n  \t    if (strncasecmp (*signature, \"void\", 4) == 0)\n  \t    {\n  \t\t*signature += 4;\n  \t\tk = VoidT;\n  \t    }\n  \t    else if (strncasecmp (*signature, \"variable\", 8) == 0)\n  \t    {\n  \t\t*signature += 8;\n  \t\tk = VariableT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase '.':\t// wildcard\n  \t{\n  \t    if (strncasecmp (*signature, \"...\", 3) == 0)\n  \t    {\n  \t\t*signature += 3;\n  \t\tk = WildcardT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase '&':\n  \tcase '<':\n  \tcase '>':\n  \tcase ',':\n  \tcase '(':\n  \tcase ')':\n  \t{\n  \t    k = **signature;\n  \t    (*signature)++;\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    k = ErrorT;\n  \t}\n  \tbreak;\n      }\n  \n      while (isspace (**signature)) (*signature)++;\n  \n  //    y2debug (\"nextToken (%s) = %d [%s]\", signature_copy, k, *signature);\n      return k;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Post-Kind '%d'[%c] not handled\\n\"",
            "k",
            "isprint (k) ? k : '?'"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isprint",
          "args": [
            "k"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionTypePtr",
          "args": [
            "new FunctionType (t1, as_const)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleTypePtr",
          "args": [
            "new TupleType (t1, as_const)"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MapTypePtr",
          "args": [
            "new MapType (t1, t2, as_const)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Unknown type at '%s' [Complete signature is '%s']!\\n\"",
            "signature_copy",
            "signature_start"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Expected ',' at '%s' [Complete signature is '%s']\\n\"",
            "signature_copy",
            "signature_start"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListTypePtr",
          "args": [
            "new ListType (t1, as_const)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlockTypePtr",
          "args": [
            "new BlockType (t1, as_const)"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VariableTypePtr",
          "args": [
            "new VariableType (t1, as_const)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unknown type at '%s' [Complete signature is '%s']!\\n\"",
            "signature_copy",
            "signature_start"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unknown type at '%s' [Complete signature is '%s']!\\n\"",
            "signature_copy",
            "signature_start"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Expecting '%c' at '%s' [Complete signature is '%s']\\n\"",
            "next",
            "signature_copy",
            "signature_start"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Builtin signature code %d [%s] not handled\\n\"",
            "**signature",
            "signature_start"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFlexTypePtr",
          "args": [
            "new NFlexType (-(k+100))"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  constTypePtr\n  Type::fromSignature (const char ** signature)\n  {\n      if ((signature == 0)\n  \t|| (*signature == 0))\n      {\n  \treturn 0;\n      }\n      if (**signature == 0)\n      {\n  \treturn Type::Unspec;\n      }\n  \n      constTypePtr t = 0;\n  \n      bool as_const = false;\n  \n      const char *signature_copy = *signature;\n      const char *signature_start = *signature;\n  \n  //    y2debug (\"Type::fromSignature (\\\"%s\\\")\\n\", *signature);\n  \n      int k = nextToken (signature);\n  \n      if (k == -1)\t\t// const\n      {\n  //\ty2debug (\"Const !\");\n  \tas_const = true;\n  \tsignature_copy = *signature;\n  \tk = nextToken (signature);\n      }\n  \n      char next = 0;\n  \n      switch (k)\n      {\n  \tcase AnyT:\t\tt = (as_const) ? Type::ConstAny : Type::Any; break;\n  \tcase BooleanT:\t\tt = (as_const) ? Type::ConstBoolean : Type::Boolean; break;\n  \tcase ByteblockT:\tt = (as_const) ? Type::ConstByteblock : Type::Byteblock; break;\n  \tcase ErrorT:\t\tt = Type::Error; break;\n  \tcase FlexT:\t\tt = (as_const) ? Type::ConstFlex : Type::Flex; break;\n  \tcase FloatT:\t\tt = (as_const) ? Type::ConstFloat : Type::Float; break;\n  \tcase IntegerT:\t\tt = (as_const) ? Type::ConstInteger : Type::Integer; break;\n  \tcase LocaleT:\t\tt = (as_const) ? Type::ConstLocale : Type::Locale; break;\n  \tcase PathT:\t\tt = (as_const) ? Type::ConstPath : Type::Path; break;\n  \tcase StringT:\t\tt = (as_const) ? Type::ConstString : Type::String; break;\n  \tcase SymbolT:\t\tt = (as_const) ? Type::ConstSymbol : Type::Symbol; break;\n  \tcase TermT:\t\tt = (as_const) ? Type::ConstTerm : Type::Term; break;\n  \tcase VoidT:\t\tt = (as_const) ? Type::ConstVoid : Type::Void; break;\n  \tcase WildcardT:\t\tt = Type::Wildcard; break;\n  \n  \t// codes\n  \tcase VariableT:\t\tk = VariableT; next = '<'; break;\n  \tcase '(':\t\tk = FunctionT; break;\n  \n  \t// constructors\n  \tcase BlockT:\t\tk = BlockT; next = '<'; break;\n  \tcase ListT:\t\tk = ListT; next = '<'; break;\n  \tcase MapT:\t\tk = MapT; next = '<'; break;\n  \tcase TupleT:\t\tk = TupleT; next = '<'; break;\n  \tdefault:\n  \t    if (k < -100)\n  \t    {\n  \t\tswitch (k)\n  \t\t{\n  \t\t    case -101:\tt = (as_const) ? Type::ConstNFlex1 : Type::NFlex1; break;\n  \t\t    case -102:\tt = (as_const) ? Type::ConstNFlex2 : Type::NFlex2; break;\n  \t\t    case -103:\tt = (as_const) ? Type::ConstNFlex3 : Type::NFlex3; break;\n  \t\t    case -104:\tt = (as_const) ? Type::ConstNFlex4 : Type::NFlex4; break;\n  \t\t    default:\tt = NFlexTypePtr (new NFlexType (-(k+100))); break;\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\ty2error (\"Builtin signature code %d [%s] not handled\\n\", **signature, signature_start);\n  \t    }\n  \tbreak;\n      }\n  \n      signature_copy = *signature;\n  \n      if (next != 0)\n      {\n  \tif (nextToken (signature) != next)\n  \t{\n  \t    y2error (\"Expecting '%c' at '%s' [Complete signature is '%s']\\n\", next, signature_copy, signature_start);\n  \t    return 0;\n  \t}\n      }\n  \n      if (t == 0)\t\t\t// no base type yet\n      {\n  //\ty2debug (\"k %d, signature '%s'\", k, *signature);\n  \tif (k == UnspecT)\t// no nothing\n  \t{\n  \t    y2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n  \t    return 0;\n  \t}\n  \n  \tsignature_copy = *signature;\n  \tconstTypePtr t1 = fromSignature (signature);\n  \n  \tif (t1 == 0)\n  \t{\n  \t    y2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n  \t    return 0;\n  \t}\n  //\ty2debug (\"t1 '%s', k %d, signature '%s'\", t1->toString().c_str(), k, *signature);\n  \n  \tswitch (k)\n  \t{\n  \t    case VariableT: t = VariableTypePtr (new VariableType (t1, as_const)); next = '>'; break;\n  \t    case BlockT:    t = BlockTypePtr (new BlockType (t1, as_const)); next = '>'; break;\n  \t    case ListT:\t    t = ListTypePtr (new ListType (t1, as_const)); next = '>'; break;\n  \t    case MapT:\n  \t    {\n  \t\tsignature_copy = *signature;\n  \n  \t\tif (nextToken (signature) != ',')\n  \t\t{\n  \t\t    y2error (\"Expected ',' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n  \t\t    return 0;\n  \t\t}\n  \n  \t\tconstTypePtr t2 = fromSignature (signature);\n  \t\tif (t2 == 0)\n  \t\t{\n  \t\t    y2debug (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n  \t\t    return 0;\n  \t\t}\n  \n  \t\tt = MapTypePtr (new MapType (t1, t2, as_const));\n  \t\tnext = '>'; \n  \t    }\n  \t    break;\n  \t    case TupleT:    t = TupleTypePtr (new TupleType (t1, as_const)); next = 0; break;\n  \t    case FunctionT: t = FunctionTypePtr (new FunctionType (t1, as_const)); next = 0; break;\n  \t    default:\n  \t\ty2error (\"Post-Kind '%d'[%c] not handled\\n\", k, isprint (k) ? k : '?');\n  \t\treturn 0;\n  \t    break;\n  \t}\n  \n  \tif (next != 0)\n  \t{\n  \t    if (nextToken (signature) != next)\n  \t    {\n  \t\ty2error (\"Expected '%c' at '%s' [Complete signature is '%s']\\n\", next, signature_copy, signature_start);\n  \t\treturn 0;\n  \t    }\n  \t}\n      }\n  \n      if (t == 0)\n      {\n  \treturn 0;\n      }\n  \n  //    y2debug (\"t '%s', signature '%s', k %d\", t->toString().c_str(), *signature, k);\n  \n      signature_copy = *signature;\n      if (**signature == '&')\n      {\n  \tTypePtr tr = t->clone();\n  \ttr->asReference();\n  \tt = tr;\n  \tdo { (*signature)++; } while (isspace (**signature));\n      }\n  \n      // check for function, it's postfix !\n  \n      if (**signature == '(')\n      {\n  //\ty2debug (\"function!\");\n  \tFunctionTypePtr f (new FunctionType (t, as_const));\n  \n  \tdo\n  \t{\n  \t    do { (*signature)++; } while (isspace (**signature));\n  \t    if (**signature == ')')\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    signature_copy = *signature;\n  \t    constTypePtr t1 = fromSignature (signature);\n  \t    if (t1 == 0)\n  \t    {\n  \t\t*signature = signature_copy;\n  \t\tbreak;\n  \t    }\n  \n  \t    f->concat (t1);\n  \t}\n  \twhile (**signature == ',');\n  \n  \tif (**signature != ')')\n  \t{\n  \t    y2error (\"Expected ')' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n  \t    return 0;\n  \t}\n  \n  \t(*signature)++;\n  \tt = f;\n      }\n      else if (k == TupleT)\n      {\n  \tTupleTypePtr tt = t->clone();\n  //\ty2debug (\"tuple! '%s', signature '%s'\", tt->toString().c_str(), *signature);\n  \twhile (**signature == ',')\n  \t{\n  \t    (*signature)++;\n  \t    signature_copy = *signature;\n  \t    constTypePtr t1 = fromSignature (signature);\n  \t    if (t1 == 0)\n  \t    {\n  \t\ty2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n  \t\treturn 0;\n  \t    }\n  \n  \t    tt->concat (t1);\n  \t}\n  \tif (**signature != '>')\n  \t{\n  \t    y2error (\"Expected '>' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n  \t    return 0;\n  \t}\n  \tt = tt;\n      }\n  \n  //    y2debug (\"Type::fromSignature Done: '%s' -> '%s' [%s]\\n\", signature_start, t->toString().c_str(), *signature);\n  \n      return t;\n  }\n}"
  },
  {
    "function_name": "nextToken",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/TypeStatics.cc",
    "lines": "68-271",
    "snippet": "int\nType::nextToken (const char **signature)\n{\n//    const char *signature_copy = *signature;\n\n    while (isspace (**signature)) (*signature)++;\n\n    int k = UnspecT;\n\n    switch (**signature)\n    {\n\tcase 0:\n\tbreak;\n\tcase 'a':\t// any\n\tcase 'A':\n\t{\n\t    if (strncasecmp (*signature, \"any\", 3) == 0)\n\t    {\n\t\t*signature += 3;\n\t\tk = AnyT;\n\t    }\n\t}\n\tbreak;\n\tcase 'b':\t// boolean, byteblock, block\n\tcase 'B':\n\t{\n\t    if (strncasecmp (*signature, \"boolean\", 7) == 0)\n\t    {\n\t\t*signature += 7;\n\t\tk = BooleanT;\n\t    }\n\t    else if (strncasecmp (*signature, \"byteblock\", 9) == 0)\n\t    {\n\t\t*signature += 9;\n\t\tk = ByteblockT;\n\t    }\n\t    else if (strncasecmp (*signature, \"block\", 5) == 0)\n\t    {\n\t\t*signature += 5;\n\t\tk = BlockT;\n\t    }\n\t}\n\tbreak;\n\tcase 'c':\t// const\n\tcase 'C':\n\t{\n\t    if (strncasecmp (*signature, \"const\", 5) == 0)\n\t    {\n\t\t*signature += 5;\n\t\tk = -1;\n\t    }\n\t}\n\tbreak;\n\tcase 'f':\t// float, flex\n\tcase 'F':\n\t{\n\t    if (strncasecmp (*signature, \"float\", 5) == 0)\n\t    {\n\t\t*signature += 5;\n\t\tk = FloatT;\n\t    }\n\t    else if (strncasecmp (*signature, \"flex\", 4) == 0)\n\t    {\n\t\t*signature += 4;\n\t\tk = 0;\n\t\twhile (isdigit (**signature))\n\t\t{\n\t\t    k *= 10;\n\t\t    k += (**signature - '0');\n\t\t    *signature += 1;\n\t\t}\n\t\tif (k == 0)\n\t\t{\n\t\t    k = FlexT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    k = -100 - k;\n\t\t}\n\t    }\n\t}\n\tbreak;\n\tcase 'i':\t// integer\n\tcase 'I':\n\t{\n\t    if (strncasecmp (*signature, \"integer\", 7) == 0)\n\t    {\n\t\t*signature += 7;\n\t\tk = IntegerT;\n\t    }\n\t}\n\tbreak;\n\tcase 'l':\t// list, locale\n\tcase 'L':\n\t{\n\t    if (strncasecmp (*signature, \"list\", 4) == 0)\n\t    {\n\t\t*signature += 4;\n\t\tk = ListT;\n\t    }\n\t    else if (strncasecmp (*signature, \"locale\", 6) == 0)\n\t    {\n\t\t*signature += 6;\n\t\tk = LocaleT;\n\t    }\n\t}\n\tbreak;\n\tcase 'm':\t// map\n\tcase 'M':\n\t{\n\t    if (strncasecmp (*signature, \"map\", 3) == 0)\n\t    {\n\t\t*signature += 3;\n\t\tk = MapT;\n\t    }\n\t}\n\tbreak;\n\tcase 'p':\t// path\n\tcase 'P':\n\t{\n\t    if (strncasecmp (*signature, \"path\", 4) == 0)\n\t    {\n\t\t*signature += 4;\n\t\tk = PathT;\n\t    }\n\t}\n\tbreak;\n\tcase 's':\t// static, string, symbol\n\tcase 'S':\n\t{\n\t    if (strncasecmp (*signature, \"string\", 6) == 0)\n\t    {\n\t\t*signature += 6;\n\t\tk = StringT;\n\t    }\n\t    else if (strncasecmp (*signature, \"symbol\", 6) == 0)\n\t    {\n\t\t*signature += 6;\n\t\tk = SymbolT;\n\t    }\n\t}\n\tbreak;\n\tcase 't':\t// term, tuple\n\tcase 'T':\n\t{\n\t    if (strncasecmp (*signature, \"term\", 4) == 0)\n\t    {\n\t\t*signature += 4;\n\t\tk = TermT;\n\t    }\n\t    else if (strncasecmp (*signature, \"tuple\", 5) == 0)\n\t    {\n\t\t*signature += 5;\n\t\tk = TupleT;\n\t    }\n\t}\n\tbreak;\n\tcase 'v':\t// void, variable\n\tcase 'V':\n\t{\n\t    if (strncasecmp (*signature, \"void\", 4) == 0)\n\t    {\n\t\t*signature += 4;\n\t\tk = VoidT;\n\t    }\n\t    else if (strncasecmp (*signature, \"variable\", 8) == 0)\n\t    {\n\t\t*signature += 8;\n\t\tk = VariableT;\n\t    }\n\t}\n\tbreak;\n\tcase '.':\t// wildcard\n\t{\n\t    if (strncasecmp (*signature, \"...\", 3) == 0)\n\t    {\n\t\t*signature += 3;\n\t\tk = WildcardT;\n\t    }\n\t}\n\tbreak;\n\tcase '&':\n\tcase '<':\n\tcase '>':\n\tcase ',':\n\tcase '(':\n\tcase ')':\n\t{\n\t    k = **signature;\n\t    (*signature)++;\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    k = ErrorT;\n\t}\n\tbreak;\n    }\n\n    while (isspace (**signature)) (*signature)++;\n\n//    y2debug (\"nextToken (%s) = %d [%s]\", signature_copy, k, *signature);\n    return k;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "**signature"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"...\"",
            "3"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"variable\"",
            "8"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"void\"",
            "4"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"tuple\"",
            "5"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"term\"",
            "4"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"symbol\"",
            "6"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"string\"",
            "6"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"path\"",
            "4"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"map\"",
            "3"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"locale\"",
            "6"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"list\"",
            "4"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"integer\"",
            "7"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "**signature"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"flex\"",
            "4"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"float\"",
            "5"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"const\"",
            "5"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"block\"",
            "5"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"byteblock\"",
            "9"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"boolean\"",
            "7"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "*signature",
            "\"any\"",
            "3"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "**signature"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  int\n  Type::nextToken (const char **signature)\n  {\n  //    const char *signature_copy = *signature;\n  \n      while (isspace (**signature)) (*signature)++;\n  \n      int k = UnspecT;\n  \n      switch (**signature)\n      {\n  \tcase 0:\n  \tbreak;\n  \tcase 'a':\t// any\n  \tcase 'A':\n  \t{\n  \t    if (strncasecmp (*signature, \"any\", 3) == 0)\n  \t    {\n  \t\t*signature += 3;\n  \t\tk = AnyT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 'b':\t// boolean, byteblock, block\n  \tcase 'B':\n  \t{\n  \t    if (strncasecmp (*signature, \"boolean\", 7) == 0)\n  \t    {\n  \t\t*signature += 7;\n  \t\tk = BooleanT;\n  \t    }\n  \t    else if (strncasecmp (*signature, \"byteblock\", 9) == 0)\n  \t    {\n  \t\t*signature += 9;\n  \t\tk = ByteblockT;\n  \t    }\n  \t    else if (strncasecmp (*signature, \"block\", 5) == 0)\n  \t    {\n  \t\t*signature += 5;\n  \t\tk = BlockT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 'c':\t// const\n  \tcase 'C':\n  \t{\n  \t    if (strncasecmp (*signature, \"const\", 5) == 0)\n  \t    {\n  \t\t*signature += 5;\n  \t\tk = -1;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 'f':\t// float, flex\n  \tcase 'F':\n  \t{\n  \t    if (strncasecmp (*signature, \"float\", 5) == 0)\n  \t    {\n  \t\t*signature += 5;\n  \t\tk = FloatT;\n  \t    }\n  \t    else if (strncasecmp (*signature, \"flex\", 4) == 0)\n  \t    {\n  \t\t*signature += 4;\n  \t\tk = 0;\n  \t\twhile (isdigit (**signature))\n  \t\t{\n  \t\t    k *= 10;\n  \t\t    k += (**signature - '0');\n  \t\t    *signature += 1;\n  \t\t}\n  \t\tif (k == 0)\n  \t\t{\n  \t\t    k = FlexT;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t    k = -100 - k;\n  \t\t}\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 'i':\t// integer\n  \tcase 'I':\n  \t{\n  \t    if (strncasecmp (*signature, \"integer\", 7) == 0)\n  \t    {\n  \t\t*signature += 7;\n  \t\tk = IntegerT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 'l':\t// list, locale\n  \tcase 'L':\n  \t{\n  \t    if (strncasecmp (*signature, \"list\", 4) == 0)\n  \t    {\n  \t\t*signature += 4;\n  \t\tk = ListT;\n  \t    }\n  \t    else if (strncasecmp (*signature, \"locale\", 6) == 0)\n  \t    {\n  \t\t*signature += 6;\n  \t\tk = LocaleT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 'm':\t// map\n  \tcase 'M':\n  \t{\n  \t    if (strncasecmp (*signature, \"map\", 3) == 0)\n  \t    {\n  \t\t*signature += 3;\n  \t\tk = MapT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 'p':\t// path\n  \tcase 'P':\n  \t{\n  \t    if (strncasecmp (*signature, \"path\", 4) == 0)\n  \t    {\n  \t\t*signature += 4;\n  \t\tk = PathT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 's':\t// static, string, symbol\n  \tcase 'S':\n  \t{\n  \t    if (strncasecmp (*signature, \"string\", 6) == 0)\n  \t    {\n  \t\t*signature += 6;\n  \t\tk = StringT;\n  \t    }\n  \t    else if (strncasecmp (*signature, \"symbol\", 6) == 0)\n  \t    {\n  \t\t*signature += 6;\n  \t\tk = SymbolT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 't':\t// term, tuple\n  \tcase 'T':\n  \t{\n  \t    if (strncasecmp (*signature, \"term\", 4) == 0)\n  \t    {\n  \t\t*signature += 4;\n  \t\tk = TermT;\n  \t    }\n  \t    else if (strncasecmp (*signature, \"tuple\", 5) == 0)\n  \t    {\n  \t\t*signature += 5;\n  \t\tk = TupleT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase 'v':\t// void, variable\n  \tcase 'V':\n  \t{\n  \t    if (strncasecmp (*signature, \"void\", 4) == 0)\n  \t    {\n  \t\t*signature += 4;\n  \t\tk = VoidT;\n  \t    }\n  \t    else if (strncasecmp (*signature, \"variable\", 8) == 0)\n  \t    {\n  \t\t*signature += 8;\n  \t\tk = VariableT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase '.':\t// wildcard\n  \t{\n  \t    if (strncasecmp (*signature, \"...\", 3) == 0)\n  \t    {\n  \t\t*signature += 3;\n  \t\tk = WildcardT;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase '&':\n  \tcase '<':\n  \tcase '>':\n  \tcase ',':\n  \tcase '(':\n  \tcase ')':\n  \t{\n  \t    k = **signature;\n  \t    (*signature)++;\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    k = ErrorT;\n  \t}\n  \tbreak;\n      }\n  \n      while (isspace (**signature)) (*signature)++;\n  \n  //    y2debug (\"nextToken (%s) = %d [%s]\", signature_copy, k, *signature);\n      return k;\n  }\n}"
  },
  {
    "function_name": "vt2type",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/TypeStatics.cc",
    "lines": "29-54",
    "snippet": "constTypePtr\nType::vt2type (enum YCPValueType vt)\n{\n    // FIXME locale???\n    switch (vt)\n    {\n\tcase YT_VOID:\t\treturn Type::Void;\n\tcase YT_BOOLEAN:\treturn Type::Boolean;\n\tcase YT_INTEGER:\treturn Type::Integer;\n\tcase YT_FLOAT:\t\treturn Type::Float;\n\tcase YT_STRING :\treturn Type::String;\n\tcase YT_BYTEBLOCK:\treturn Type::Byteblock;\n\tcase YT_PATH:\t\treturn Type::Path;\n\tcase YT_SYMBOL:\t\treturn Type::Symbol;\n\tcase YT_LIST:\t\treturn Type::List;\n\tcase YT_TERM:\t\treturn Type::Term;\n\tcase YT_MAP:\t\treturn Type::Map;\n\tcase YT_CODE:\t\treturn Type::Block;\n\tcase YT_ENTRY:\t\treturn Type::Variable;\n\tcase YT_EXTERNAL:\treturn Type::Any;\n\tdefault:\n\t\treturn Type::Unspec;\n    }\n\n    return Type::Error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  constTypePtr\n  Type::vt2type (enum YCPValueType vt)\n  {\n      // FIXME locale???\n      switch (vt)\n      {\n  \tcase YT_VOID:\t\treturn Type::Void;\n  \tcase YT_BOOLEAN:\treturn Type::Boolean;\n  \tcase YT_INTEGER:\treturn Type::Integer;\n  \tcase YT_FLOAT:\t\treturn Type::Float;\n  \tcase YT_STRING :\treturn Type::String;\n  \tcase YT_BYTEBLOCK:\treturn Type::Byteblock;\n  \tcase YT_PATH:\t\treturn Type::Path;\n  \tcase YT_SYMBOL:\t\treturn Type::Symbol;\n  \tcase YT_LIST:\t\treturn Type::List;\n  \tcase YT_TERM:\t\treturn Type::Term;\n  \tcase YT_MAP:\t\treturn Type::Map;\n  \tcase YT_CODE:\t\treturn Type::Block;\n  \tcase YT_ENTRY:\t\treturn Type::Variable;\n  \tcase YT_EXTERNAL:\treturn Type::Any;\n  \tdefault:\n  \t\treturn Type::Unspec;\n      }\n  \n      return Type::Error;\n  }\n}"
  }
]