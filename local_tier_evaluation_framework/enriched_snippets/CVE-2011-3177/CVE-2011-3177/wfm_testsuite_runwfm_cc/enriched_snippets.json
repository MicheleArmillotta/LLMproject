[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/wfm/testsuite/runwfm.cc",
    "lines": "32-145",
    "snippet": "int\nmain (int argc, char *argv[])\n{\n    const char *fname = 0;\n    FILE *infile = stdin;\n\n    if (argc > 1)\n    {\n\tint argp = 1;\n\twhile (argp < argc)\n\t{\n\t    if ((argv[argp][0] == '-')\n\t        && (argv[argp][1] == 'l')\n\t        && (argp+1 < argc))\n\t    {\n\t\targp++;\n\t\tset_log_filename (argv[argp]);\n\t    }\n\t    else if (fname == 0)\n\t    {\n\t\tfname = argv[argp];\n\t    }\n\t    else\n\t    {\n\t\tfprintf (stderr, \"Bad argument '%s'\\nUsage: runwfm [ name.ycp ]\\n\", argv[argp]);\n\t    }\n\t    argp++;\n\t}\n    }\n\n    Parser *parser;\n    parser = new Parser ();\n\n    if (!parser)\n    {\n\tfprintf (stderr, \"Failed to create Parser\\n\");\n\treturn 1;\n    }\n\n    // create stdio as UI component, disable textdomain calls\n\n    Y2Component *user_interface = new Y2StdioComponent (false, false, true);\n    if (!user_interface)\n    {\n\tfprintf (stderr, \"Failed to create Y2StdioComponent\\n\");\n\tdelete parser;\n\treturn 1;\n    }\n\n    // create the component \"wfm\", the Workflowmanager to do the work.\n    Y2WFMComponent *workflowmanager = dynamic_cast<Y2WFMComponent*>(Y2ComponentBroker::createClient(\"wfm\"));\n\n    if (!workflowmanager)\n    {\n        y2error (\"Failed to create component wfm (Workflowmanager)\");\n\tdelete parser;\n        return 1;\n    }\n\n    if (fname != 0)\n    {\n\tinfile = fopen (fname, \"r\");\n\tif (infile == 0)\n\t{\n\t    fprintf (stderr, \"Failed to open '%s'\\n\", fname);\n\t    return 1;\n\t}\n    }\n    else\n    {\n\tfname = \"stdin\";\n    }\n\n    parser->setInput (infile, fname);\n    parser->setBuffered();\n    \n    // register builtins;\n    WFM wfm;\n\n    YCodePtr value = 0;\n\n    for (;;)\n    {\n\tvalue = parser->parse();\n\tif (value == 0)\n\t{\n\t    break;\n\t}\n\t\n\t// Prepare the arguments. It has the form [script, [clientargs...]]\n\tYCPList wfm_arglist;\n\twfm_arglist->add (YCPCode (value));\n\twfm_arglist->add (YCPString (\"testing\"));\n\twfm_arglist->add (YCPString (\"testing-fullname\"));\n\twfm_arglist->add (YCPList());\n\t\n\tworkflowmanager->setupComponent ( \"testing\", \"testing-fullname:\"\n\t    , YCPCode (value));\n\n\t// Let the wfm do the work\n\tYCPValue res = workflowmanager->doActualWork(YCPList(), user_interface);\n\n\tprintf (\"(%s)\\n\", res.isNull()?\"nil\":res->toString().c_str());\n    }\n\n    delete parser;\n\n    if (infile != stdin)\n    {\n\tfclose (infile);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <WFM.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/YCPCode.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2WFMComponent.h\"",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2StdioComponent.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "infile"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"(%s)\\n\"",
            "res.isNull()?\"nil\":res->toString().c_str()"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "res->toString",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSExpression",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YStatement.cc",
          "lines": "234-243",
          "snippet": "string\nYSExpression::toString() const\n{\n    string s = m_expr->toString();\n    if (!m_expr->isBlock())\n    {\n\ts += \";\";\n    }\n    return s;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YStatement.h\"\n#include <libintl.h>\n\nYSExpression {\n  string\n  YSExpression::toString() const\n  {\n      string s = m_expr->toString();\n      if (!m_expr->isBlock())\n      {\n  \ts += \";\";\n      }\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "res.isNull",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "workflowmanager->doActualWork",
          "args": [
            "YCPList()",
            "user_interface"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "doActualWork",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "172-261",
          "snippet": "YCPValue Y2ProgramComponent::doActualWork(const YCPList& arglist, Y2Component *user_interface)\n{\n    int argc;      // this shadows the corresponding member variables for servers\n    char **argv;\n\n    if (is_non_y2)   // this is a nony2 program like a shell and such like\n    {\n\tint arg = 0;\n\n\t// Prepare arguments as command line parameters for program being called\n\targc = !arglist.isNull() ? arglist->size() + 1 : 1;\n\targv = new char *[argc+1];\n\targv[0] = strdup((name().c_str()));\n\targv[argc] = NULL;\n\n\tfor (arg = 1; arg < argc; arg++)\n\t{\n\t    YCPValue a = arglist->value(arg-1);\n\t    if (a->isString())\n\t    {\n\t\targv[arg] = strdup(a->asString()->value().c_str());\n\t    }\n\t    else\n\t    {\n\t\targv[arg] = strdup(a->toString().c_str());\n\t    }\n\t}\n\n\t// launch component if not yet done\n\tif (pid == -1) launchExternalProgram(argv);\n\n\tif (argv)\n\t{\n\t    for (arg = 0; arg < argc; arg++)\n\t    {\n\t\tif (argv[arg])\n\t\t{\n\t\t    free(argv[arg]);\n\t\t}\n\t    }\n\t    delete[] argv;\n\t}\n    }\n    else   // this is a real liby2 component\n    {\n\t// send arguments via stdio\n\targc = 4;   // name, -s\n\targv = new char *[argc+1];\n\targv[0] = strdup(name().c_str());\n\targv[1] = argv[0];\n\targv[2] = \"-s\";    // get arguments on stdin\n\targv[3] = \"stdio\"; // communicate via stdio\n\targv[argc] = NULL;\n\n\t// launch component if not yet done\n\tif (pid == -1) launchExternalProgram(argv);\n\n\tsendToExternal(arglist);   // now send arguments\n\n\tif (argv)\n\t{\n\t    if (argv[0]) free(argv[0]);\n\t    delete[] argv;\n\t}\n    }\n\n    // Communication loop with module. Module sends 'result(...)',\n    // when finished\n    YCPValue retval = YCPNull();\n    YCPValue value = YCPNull();\n\n    while (!(value = receiveFromExternal()).isNull())\n    {\n\tif (value->isTerm()\n\t    && value->asTerm()->size() == 1\n\t    && value->asTerm()->name() == \"result\")\n\t{\n\t    retval = value->asTerm()->value(0);\n\t    y2debug (\"Got result from client component %s: %s\", name().c_str(), retval->toString().c_str());\n\t    break;\n\t}\n\telse\n\t{\n\t    // Send this to the UI and get UI answer\n\t    sendToExternal(user_interface->evaluate(value));\n\t}\n    }\n\n    return !retval.isNull() ? retval : YCPVoid();\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  YCPValue Y2ProgramComponent::doActualWork(const YCPList& arglist, Y2Component *user_interface)\n  {\n      int argc;      // this shadows the corresponding member variables for servers\n      char **argv;\n  \n      if (is_non_y2)   // this is a nony2 program like a shell and such like\n      {\n  \tint arg = 0;\n  \n  \t// Prepare arguments as command line parameters for program being called\n  \targc = !arglist.isNull() ? arglist->size() + 1 : 1;\n  \targv = new char *[argc+1];\n  \targv[0] = strdup((name().c_str()));\n  \targv[argc] = NULL;\n  \n  \tfor (arg = 1; arg < argc; arg++)\n  \t{\n  \t    YCPValue a = arglist->value(arg-1);\n  \t    if (a->isString())\n  \t    {\n  \t\targv[arg] = strdup(a->asString()->value().c_str());\n  \t    }\n  \t    else\n  \t    {\n  \t\targv[arg] = strdup(a->toString().c_str());\n  \t    }\n  \t}\n  \n  \t// launch component if not yet done\n  \tif (pid == -1) launchExternalProgram(argv);\n  \n  \tif (argv)\n  \t{\n  \t    for (arg = 0; arg < argc; arg++)\n  \t    {\n  \t\tif (argv[arg])\n  \t\t{\n  \t\t    free(argv[arg]);\n  \t\t}\n  \t    }\n  \t    delete[] argv;\n  \t}\n      }\n      else   // this is a real liby2 component\n      {\n  \t// send arguments via stdio\n  \targc = 4;   // name, -s\n  \targv = new char *[argc+1];\n  \targv[0] = strdup(name().c_str());\n  \targv[1] = argv[0];\n  \targv[2] = \"-s\";    // get arguments on stdin\n  \targv[3] = \"stdio\"; // communicate via stdio\n  \targv[argc] = NULL;\n  \n  \t// launch component if not yet done\n  \tif (pid == -1) launchExternalProgram(argv);\n  \n  \tsendToExternal(arglist);   // now send arguments\n  \n  \tif (argv)\n  \t{\n  \t    if (argv[0]) free(argv[0]);\n  \t    delete[] argv;\n  \t}\n      }\n  \n      // Communication loop with module. Module sends 'result(...)',\n      // when finished\n      YCPValue retval = YCPNull();\n      YCPValue value = YCPNull();\n  \n      while (!(value = receiveFromExternal()).isNull())\n      {\n  \tif (value->isTerm()\n  \t    && value->asTerm()->size() == 1\n  \t    && value->asTerm()->name() == \"result\")\n  \t{\n  \t    retval = value->asTerm()->value(0);\n  \t    y2debug (\"Got result from client component %s: %s\", name().c_str(), retval->toString().c_str());\n  \t    break;\n  \t}\n  \telse\n  \t{\n  \t    // Send this to the UI and get UI answer\n  \t    sendToExternal(user_interface->evaluate(value));\n  \t}\n      }\n  \n      return !retval.isNull() ? retval : YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPList",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "commaList",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "254-265",
          "snippet": "string\nYCPListRep::commaList() const\n{\n    string ret;\n\n    for (unsigned index = 0; index < elements.size(); index++)\n    {\n\tif (index != 0) ret += \", \";\n\tret += elements[index].isNull() ? \"(null)\" : elements[index]->toString();\n    }\n    return ret;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  string\n  YCPListRep::commaList() const\n  {\n      string ret;\n  \n      for (unsigned index = 0; index < elements.size(); index++)\n      {\n  \tif (index != 0) ret += \", \";\n  \tret += elements[index].isNull() ? \"(null)\" : elements[index]->toString();\n      }\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "workflowmanager->setupComponent",
          "args": [
            "\"testing\"",
            "\"testing-fullname:\"",
            "YCPCode (value)"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "setupComponent",
          "container": "Y2WFMComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/wfm/src/Y2WFMComponent.cc",
          "lines": "784-790",
          "snippet": "void Y2WFMComponent::setupComponent (string cn, string fn,\n\t\t\t\t      const YCPValue& sc)\n{\n    script = sc;\n    client_name = cn;\n    fullname = fn;\n}",
          "includes": [
            "#include \"Y2SystemNamespace.h\"",
            "#include \"Y2WFMComponent.h\"",
            "#include <scr/SCR.h>",
            "#include <scr/SCRAgent.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2ProgramComponent.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <algorithm>",
            "#include <errno.h>",
            "#include <locale.h>",
            "#include <langinfo.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2SystemNamespace.h\"\n#include \"Y2WFMComponent.h\"\n#include <scr/SCR.h>\n#include <scr/SCRAgent.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <y2/Y2ProgramComponent.h>\n#include <y2/Y2ComponentBroker.h>\n#include <algorithm>\n#include <errno.h>\n#include <locale.h>\n#include <langinfo.h>\n#include <libintl.h>\n\nY2WFMComponent {\n  void Y2WFMComponent::setupComponent (string cn, string fn,\n  \t\t\t\t      const YCPValue& sc)\n  {\n      script = sc;\n      client_name = cn;\n      fullname = fn;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPCode",
          "args": [
            "value"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "YCPCode",
          "container": "YCPCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "103-107",
          "snippet": "YCPCode::YCPCode (bytecodeistream & str)\n    : YCPValue (YCPCode())\n{\n    (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPCode {\n  YCPCode::YCPCode (bytecodeistream & str)\n      : YCPValue (YCPCode())\n  {\n      (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "wfm_arglist->add",
          "args": [
            "YCPList()"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "\"testing-fullname\""
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->parse",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "484-562",
          "snippet": "int IniParser::parse()\n{\n    if (multiple_files)\n    {\n\tglob_t do_files;\n\tint len = files.size ();\n\tint flags = 0;\n\tfor (int i = 0;i<len;i++)\n\t{\n\t    glob (files[i].c_str (),flags, NULL, &do_files);\n\t    flags = GLOB_APPEND;\n\t}\n\tchar**f = do_files.gl_pathv;\n\tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n\t{\n\t    int section_index = -1;\n\t    string section_name = *f;\n\t    //FIXME: create function out of it.\n\t    // do we have name rewrite rules?\n\t    for (size_t j = 0; j < rewrites.size (); j++)\n\t\t{\n\t\t    RegexMatch m (rewrites[j].rx, section_name);\n\t\t    if (m)\n\t\t    {\n\t\t\tsection_index = j;\n\t\t\tsection_name = m[1];\n\t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    // do we know about the file?\n\t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n\t    if (ff == multi_files.end())\n\t    {\n\t\t// new file\n\t\tif (scanner_start (*f))\n\t\t    y2error (\"Cannot open %s.\", *f);\n\t\telse\n\t\t{\n\t\t    FileDescr fdsc (*f);\n\t\t    multi_files[*f] = fdsc;\n\t\t    inifile.initSection (section_name, \"\", -1, section_index);\n\t\t    parse_helper(inifile.getSection(section_name.c_str()));\n\t\t    scanner_stop();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif ((*ff).second.changed ())\n\t\t{\n\t\t    if (scanner_start (*f))\n\t\t\ty2error (\"Cannot open %s.\", *f);\n\t\t    else\n\t\t    {\n\t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n\t\t\tFileDescr fdsc (*f);\n\t\t\tmulti_files [*f] = fdsc;\n\t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n\t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n\t\t\tscanner_stop();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tif (scanner_start (file.c_str()))\n\t    {\n\t\ty2error (\"Can not open %s.\", file.c_str());\n\t\treturn -1;\n\t    }\n\tparse_helper(inifile);\n\tscanner_stop();\n\ttimestamp = getTimeStamp ();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse()\n  {\n      if (multiple_files)\n      {\n  \tglob_t do_files;\n  \tint len = files.size ();\n  \tint flags = 0;\n  \tfor (int i = 0;i<len;i++)\n  \t{\n  \t    glob (files[i].c_str (),flags, NULL, &do_files);\n  \t    flags = GLOB_APPEND;\n  \t}\n  \tchar**f = do_files.gl_pathv;\n  \tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n  \t{\n  \t    int section_index = -1;\n  \t    string section_name = *f;\n  \t    //FIXME: create function out of it.\n  \t    // do we have name rewrite rules?\n  \t    for (size_t j = 0; j < rewrites.size (); j++)\n  \t\t{\n  \t\t    RegexMatch m (rewrites[j].rx, section_name);\n  \t\t    if (m)\n  \t\t    {\n  \t\t\tsection_index = j;\n  \t\t\tsection_name = m[1];\n  \t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \n  \t    // do we know about the file?\n  \t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n  \t    if (ff == multi_files.end())\n  \t    {\n  \t\t// new file\n  \t\tif (scanner_start (*f))\n  \t\t    y2error (\"Cannot open %s.\", *f);\n  \t\telse\n  \t\t{\n  \t\t    FileDescr fdsc (*f);\n  \t\t    multi_files[*f] = fdsc;\n  \t\t    inifile.initSection (section_name, \"\", -1, section_index);\n  \t\t    parse_helper(inifile.getSection(section_name.c_str()));\n  \t\t    scanner_stop();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif ((*ff).second.changed ())\n  \t\t{\n  \t\t    if (scanner_start (*f))\n  \t\t\ty2error (\"Cannot open %s.\", *f);\n  \t\t    else\n  \t\t    {\n  \t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n  \t\t\tFileDescr fdsc (*f);\n  \t\t\tmulti_files [*f] = fdsc;\n  \t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n  \t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n  \t\t\tscanner_stop();\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n      else\n      {\n  \tif (scanner_start (file.c_str()))\n  \t    {\n  \t\ty2error (\"Can not open %s.\", file.c_str());\n  \t\treturn -1;\n  \t    }\n  \tparse_helper(inifile);\n  \tscanner_stop();\n  \ttimestamp = getTimeStamp ();\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->setBuffered",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "setBuffered",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "128-132",
          "snippet": "void\nScanner::setBuffered ()\n{\n    m_buffered = true;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  void\n  Scanner::setBuffered ()\n  {\n      m_buffered = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->setInput",
          "args": [
            "infile",
            "fname"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "setInput",
          "container": "Parser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Parser.cc",
          "lines": "108-115",
          "snippet": "void\nParser::setInput(int fd, const char *filename)\n{\n    if (m_scanner) delete m_scanner;\n    m_scanner = new Scanner (fd, filename);\n    if (m_buffered) m_scanner->setBuffered ();\n    m_at_eof = false;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Parser.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Parser.h\"\n#include <stdlib.h>\n\nParser {\n  void\n  Parser::setInput(int fd, const char *filename)\n  {\n      if (m_scanner) delete m_scanner;\n      m_scanner = new Scanner (fd, filename);\n      if (m_buffered) m_scanner->setBuffered ();\n      m_at_eof = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to open '%s'\\n\"",
            "fname"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Failed to create component wfm (Workflowmanager)\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dynamic_cast<Y2WFMComponent*>",
          "args": [
            "Y2ComponentBroker::createClient(\"wfm\")"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2ComponentBroker::createClient",
          "args": [
            "\"wfm\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to create Y2StdioComponent\\n\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to create Parser\\n\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Bad argument '%s'\\nUsage: runwfm [ name.ycp ]\\n\"",
            "argv[argp]"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_log_filename",
          "args": [
            "argv[argp]"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "set_log_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2changes.cc",
          "lines": "188-240",
          "snippet": "static void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2CHANGES_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2CHANGES_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2CHANGES_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2CHANGES_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2CHANGES_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2CHANGES_FALLBACK );\n\n\t\tlogname = Y2CHANGES_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2CHANGES_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2CHANGES_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2CHANGES_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2CHANGES_VAR_NUM\t\"Y2MAXLOGNUM\"",
            "#define Y2CHANGES_VAR_SIZE\t\"Y2MAXLOGSIZE\"",
            "#define Y2CHANGES_FALLBACK\t\"/y2changes\"",
            "#define Y2CHANGES_USER\t\"/.y2changes\"\t\t/* Relative to $HOME */",
            "#define Y2CHANGES_ROOT\tLOGDIR \"/y2changes\"",
            "#define Y2CHANGES_MAXNUM\t10\t\t\t/* Maximum logfiles number */",
            "#define Y2CHANGES_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */"
          ],
          "globals_used": [
            "static bool did_set_logname = false;",
            "static const char *logname;",
            "static off_t maxlogsize;",
            "static int   maxlognum;",
            "static bool log_to_file = true;",
            "static bool log_to_syslog = false;",
            "static FILE *Y2CHANGES_STDERR = stderr;",
            "static void shift_log_files(string filename);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/y2changes.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2CHANGES_VAR_NUM\t\"Y2MAXLOGNUM\"\n#define Y2CHANGES_VAR_SIZE\t\"Y2MAXLOGSIZE\"\n#define Y2CHANGES_FALLBACK\t\"/y2changes\"\n#define Y2CHANGES_USER\t\"/.y2changes\"\t\t/* Relative to $HOME */\n#define Y2CHANGES_ROOT\tLOGDIR \"/y2changes\"\n#define Y2CHANGES_MAXNUM\t10\t\t\t/* Maximum logfiles number */\n#define Y2CHANGES_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */\n\nstatic bool did_set_logname = false;\nstatic const char *logname;\nstatic off_t maxlogsize;\nstatic int   maxlognum;\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic FILE *Y2CHANGES_STDERR = stderr;\nstatic void shift_log_files(string filename);\n\nstatic void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2CHANGES_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2CHANGES_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2CHANGES_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2CHANGES_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2CHANGES_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2CHANGES_FALLBACK );\n\n\t\tlogname = Y2CHANGES_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2CHANGES_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2CHANGES_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2CHANGES_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <WFM.h>\n#include <ycp/y2log.h>\n#include <ycp/YCPCode.h>\n#include <ycp/Parser.h>\n#include \"Y2WFMComponent.h\"\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2StdioComponent.h>\n#include <stdio.h>\n\nint\nmain (int argc, char *argv[])\n{\n    const char *fname = 0;\n    FILE *infile = stdin;\n\n    if (argc > 1)\n    {\n\tint argp = 1;\n\twhile (argp < argc)\n\t{\n\t    if ((argv[argp][0] == '-')\n\t        && (argv[argp][1] == 'l')\n\t        && (argp+1 < argc))\n\t    {\n\t\targp++;\n\t\tset_log_filename (argv[argp]);\n\t    }\n\t    else if (fname == 0)\n\t    {\n\t\tfname = argv[argp];\n\t    }\n\t    else\n\t    {\n\t\tfprintf (stderr, \"Bad argument '%s'\\nUsage: runwfm [ name.ycp ]\\n\", argv[argp]);\n\t    }\n\t    argp++;\n\t}\n    }\n\n    Parser *parser;\n    parser = new Parser ();\n\n    if (!parser)\n    {\n\tfprintf (stderr, \"Failed to create Parser\\n\");\n\treturn 1;\n    }\n\n    // create stdio as UI component, disable textdomain calls\n\n    Y2Component *user_interface = new Y2StdioComponent (false, false, true);\n    if (!user_interface)\n    {\n\tfprintf (stderr, \"Failed to create Y2StdioComponent\\n\");\n\tdelete parser;\n\treturn 1;\n    }\n\n    // create the component \"wfm\", the Workflowmanager to do the work.\n    Y2WFMComponent *workflowmanager = dynamic_cast<Y2WFMComponent*>(Y2ComponentBroker::createClient(\"wfm\"));\n\n    if (!workflowmanager)\n    {\n        y2error (\"Failed to create component wfm (Workflowmanager)\");\n\tdelete parser;\n        return 1;\n    }\n\n    if (fname != 0)\n    {\n\tinfile = fopen (fname, \"r\");\n\tif (infile == 0)\n\t{\n\t    fprintf (stderr, \"Failed to open '%s'\\n\", fname);\n\t    return 1;\n\t}\n    }\n    else\n    {\n\tfname = \"stdin\";\n    }\n\n    parser->setInput (infile, fname);\n    parser->setBuffered();\n    \n    // register builtins;\n    WFM wfm;\n\n    YCodePtr value = 0;\n\n    for (;;)\n    {\n\tvalue = parser->parse();\n\tif (value == 0)\n\t{\n\t    break;\n\t}\n\t\n\t// Prepare the arguments. It has the form [script, [clientargs...]]\n\tYCPList wfm_arglist;\n\twfm_arglist->add (YCPCode (value));\n\twfm_arglist->add (YCPString (\"testing\"));\n\twfm_arglist->add (YCPString (\"testing-fullname\"));\n\twfm_arglist->add (YCPList());\n\t\n\tworkflowmanager->setupComponent ( \"testing\", \"testing-fullname:\"\n\t    , YCPCode (value));\n\n\t// Let the wfm do the work\n\tYCPValue res = workflowmanager->doActualWork(YCPList(), user_interface);\n\n\tprintf (\"(%s)\\n\", res.isNull()?\"nil\":res->toString().c_str());\n    }\n\n    delete parser;\n\n    if (infile != stdin)\n    {\n\tfclose (infile);\n    }\n\n    return 0;\n}"
  }
]