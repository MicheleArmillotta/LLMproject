[
  {
    "function_name": "Y2Loglinestreamset",
    "container": "Y2Loglinestreamset",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/Y2SLog.cc",
    "lines": "185-191",
    "snippet": "Y2Loglinestreamset( const Y2Loglinestreamset & rhs )\n      : class_t( rhs.class_t )\n    {\n      for ( unsigned i = 0; i < maxSet_i; ++i ) {\n\tset_VpC[i] = 0;\n      }\n    }",
    "includes": [
      "#include <y2util/Y2SLog.h>",
      "#include <map>",
      "#include <string>",
      "#include <cstdlib>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <y2util/Y2SLog.h>\n#include <map>\n#include <string>\n#include <cstdlib>\n\nY2Loglinestreamset {\n  Y2Loglinestreamset( const Y2Loglinestreamset & rhs )\n        : class_t( rhs.class_t )\n      {\n        for ( unsigned i = 0; i < maxSet_i; ++i ) {\n  \tset_VpC[i] = 0;\n        }\n      }\n}"
  },
  {
    "function_name": "Y2Loglinestreamset",
    "container": "Y2Loglinestreamset",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/Y2SLog.cc",
    "lines": "177-183",
    "snippet": "Y2Loglinestreamset( const char * which )\n      : class_t( which )\n    {\n      for ( unsigned i = 0; i < maxSet_i; ++i ) {\n\tset_VpC[i] = 0;\n      }\n    }",
    "includes": [
      "#include <y2util/Y2SLog.h>",
      "#include <map>",
      "#include <string>",
      "#include <cstdlib>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <y2util/Y2SLog.h>\n#include <map>\n#include <string>\n#include <cstdlib>\n\nY2Loglinestreamset {\n  Y2Loglinestreamset( const char * which )\n        : class_t( which )\n      {\n        for ( unsigned i = 0; i < maxSet_i; ++i ) {\n  \tset_VpC[i] = 0;\n        }\n      }\n}"
  },
  {
    "function_name": "Y2Loglinestream",
    "container": "Y2Loglinestream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/Y2SLog.cc",
    "lines": "143-146",
    "snippet": "Y2Loglinestream( const char *const name, const unsigned level )\n      : mybuf( name, level )\n      , mystream( &mybuf )\n    {}",
    "includes": [
      "#include <y2util/Y2SLog.h>",
      "#include <map>",
      "#include <string>",
      "#include <cstdlib>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <y2util/Y2SLog.h>\n#include <map>\n#include <string>\n#include <cstdlib>\n\nY2Loglinestream {\n  Y2Loglinestream( const char *const name, const unsigned level )\n        : mybuf( name, level )\n        , mystream( &mybuf )\n      {}\n}"
  },
  {
    "function_name": "Y2Loglinebuf",
    "container": "Y2Loglinebuf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/Y2SLog.cc",
    "lines": "113-119",
    "snippet": "Y2Loglinebuf(  const char * myname, const unsigned mylevel )\n      : name( myname )\n      , level( (loglevel_t)mylevel )\n    {\n      file = func = \"\";\n      line = -1;\n    }",
    "includes": [
      "#include <y2util/Y2SLog.h>",
      "#include <map>",
      "#include <string>",
      "#include <cstdlib>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <y2util/Y2SLog.h>\n#include <map>\n#include <string>\n#include <cstdlib>\n\nY2Loglinebuf {\n  Y2Loglinebuf(  const char * myname, const unsigned mylevel )\n        : name( myname )\n        , level( (loglevel_t)mylevel )\n      {\n        file = func = \"\";\n        line = -1;\n      }\n}"
  },
  {
    "function_name": "writeout",
    "container": "Y2Loglinebuf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/Y2SLog.cc",
    "lines": "95-111",
    "snippet": "virtual int writeout( const char* s, streamsize n ) {\n      if ( s && n ) {\n\tconst char * c = s;\n\tfor ( int i = 0; i < n; ++i, ++c ) {\n\t  if ( *c == '\\n' ) {\n\t    buffer += string( s, c-s );\n\t    y2_logger( level, name, file, line, func, \"%s\", buffer.c_str() );\n\t    buffer = \"\";\n\t    s = c+1;\n\t  }\n\t}\n\tif ( s < c ) {\n\t  buffer += string( s, c-s );\n\t}\n      }\n      return n;\n    }",
    "includes": [
      "#include <y2util/Y2SLog.h>",
      "#include <map>",
      "#include <string>",
      "#include <cstdlib>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "string",
          "args": [
            "s",
            "c-s"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "read_file_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
          "lines": "145-165",
          "snippet": "static int read_file_to_string (const char* filename, string& output)\n{\n    int fd = open (filename, O_RDONLY);\n    output = \"\";\n    if (fd < 0)\n    {\n\treturn errno;\n    }\n\n    while (true)\n    {\n\tchar buffer[4096];\n\tssize_t bytes_read = read (fd, buffer, 4095);\n\tif (bytes_read <= 0)\n\t    break;\n\tbuffer[bytes_read] = 0; // 0 terminate string\n\toutput += buffer;\n    }\n    close(fd);\n    return 0;\n}",
          "includes": [
            "#include \"ShellCommand.h\"",
            "#include \"SystemAgent.h\"",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/pathsearch.h>",
            "#include <YCP.h>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <string>",
            "#include <linux/lp.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <resolv.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int read_file_to_string (const char* filename, string& output)\n{\n    int fd = open (filename, O_RDONLY);\n    output = \"\";\n    if (fd < 0)\n    {\n\treturn errno;\n    }\n\n    while (true)\n    {\n\tchar buffer[4096];\n\tssize_t bytes_read = read (fd, buffer, 4095);\n\tif (bytes_read <= 0)\n\t    break;\n\tbuffer[bytes_read] = 0; // 0 terminate string\n\toutput += buffer;\n    }\n    close(fd);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2_logger",
          "args": [
            "level",
            "name",
            "file",
            "line",
            "func",
            "\"%s\"",
            "buffer.c_str()"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer.c_str",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/Y2SLog.h>\n#include <map>\n#include <string>\n#include <cstdlib>\n\nY2Loglinebuf {\n  virtual int writeout( const char* s, streamsize n ) {\n        if ( s && n ) {\n  \tconst char * c = s;\n  \tfor ( int i = 0; i < n; ++i, ++c ) {\n  \t  if ( *c == '\\n' ) {\n  \t    buffer += string( s, c-s );\n  \t    y2_logger( level, name, file, line, func, \"%s\", buffer.c_str() );\n  \t    buffer = \"\";\n  \t    s = c+1;\n  \t  }\n  \t}\n  \tif ( s < c ) {\n  \t  buffer += string( s, c-s );\n  \t}\n        }\n        return n;\n      }\n}"
  },
  {
    "function_name": "overflow",
    "container": "Y2Loglinebuf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/Y2SLog.cc",
    "lines": "87-93",
    "snippet": "virtual int overflow( int ch = EOF ) {\n      if ( ch != EOF ) {\n\tchar tmp = ch;\n        writeout( &tmp, 1 );\n      }\n      return 0;\n    }",
    "includes": [
      "#include <y2util/Y2SLog.h>",
      "#include <map>",
      "#include <string>",
      "#include <cstdlib>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeout",
          "args": [
            "&tmp",
            "1"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "writeout",
          "container": "Y2Loglinebuf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/Y2SLog.cc",
          "lines": "95-111",
          "snippet": "virtual int writeout( const char* s, streamsize n ) {\n      if ( s && n ) {\n\tconst char * c = s;\n\tfor ( int i = 0; i < n; ++i, ++c ) {\n\t  if ( *c == '\\n' ) {\n\t    buffer += string( s, c-s );\n\t    y2_logger( level, name, file, line, func, \"%s\", buffer.c_str() );\n\t    buffer = \"\";\n\t    s = c+1;\n\t  }\n\t}\n\tif ( s < c ) {\n\t  buffer += string( s, c-s );\n\t}\n      }\n      return n;\n    }",
          "includes": [
            "#include <y2util/Y2SLog.h>",
            "#include <map>",
            "#include <string>",
            "#include <cstdlib>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Y2SLog.h>\n#include <map>\n#include <string>\n#include <cstdlib>\n\nY2Loglinebuf {\n  virtual int writeout( const char* s, streamsize n ) {\n        if ( s && n ) {\n  \tconst char * c = s;\n  \tfor ( int i = 0; i < n; ++i, ++c ) {\n  \t  if ( *c == '\\n' ) {\n  \t    buffer += string( s, c-s );\n  \t    y2_logger( level, name, file, line, func, \"%s\", buffer.c_str() );\n  \t    buffer = \"\";\n  \t    s = c+1;\n  \t  }\n  \t}\n  \tif ( s < c ) {\n  \t  buffer += string( s, c-s );\n  \t}\n        }\n        return n;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/Y2SLog.h>\n#include <map>\n#include <string>\n#include <cstdlib>\n\nY2Loglinebuf {\n  virtual int overflow( int ch = EOF ) {\n        if ( ch != EOF ) {\n  \tchar tmp = ch;\n          writeout( &tmp, 1 );\n        }\n        return 0;\n      }\n}"
  },
  {
    "function_name": "xsputn",
    "container": "Y2Loglinebuf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/Y2SLog.cc",
    "lines": "83-85",
    "snippet": "virtual streamsize xsputn( const char * s, streamsize n ) {\n      return writeout( s, n );\n    }",
    "includes": [
      "#include <y2util/Y2SLog.h>",
      "#include <map>",
      "#include <string>",
      "#include <cstdlib>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeout",
          "args": [
            "s",
            "n"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "writeout",
          "container": "Y2Loglinebuf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/Y2SLog.cc",
          "lines": "95-111",
          "snippet": "virtual int writeout( const char* s, streamsize n ) {\n      if ( s && n ) {\n\tconst char * c = s;\n\tfor ( int i = 0; i < n; ++i, ++c ) {\n\t  if ( *c == '\\n' ) {\n\t    buffer += string( s, c-s );\n\t    y2_logger( level, name, file, line, func, \"%s\", buffer.c_str() );\n\t    buffer = \"\";\n\t    s = c+1;\n\t  }\n\t}\n\tif ( s < c ) {\n\t  buffer += string( s, c-s );\n\t}\n      }\n      return n;\n    }",
          "includes": [
            "#include <y2util/Y2SLog.h>",
            "#include <map>",
            "#include <string>",
            "#include <cstdlib>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Y2SLog.h>\n#include <map>\n#include <string>\n#include <cstdlib>\n\nY2Loglinebuf {\n  virtual int writeout( const char* s, streamsize n ) {\n        if ( s && n ) {\n  \tconst char * c = s;\n  \tfor ( int i = 0; i < n; ++i, ++c ) {\n  \t  if ( *c == '\\n' ) {\n  \t    buffer += string( s, c-s );\n  \t    y2_logger( level, name, file, line, func, \"%s\", buffer.c_str() );\n  \t    buffer = \"\";\n  \t    s = c+1;\n  \t  }\n  \t}\n  \tif ( s < c ) {\n  \t  buffer += string( s, c-s );\n  \t}\n        }\n        return n;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/Y2SLog.h>\n#include <map>\n#include <string>\n#include <cstdlib>\n\nY2Loglinebuf {\n  virtual streamsize xsputn( const char * s, streamsize n ) {\n        return writeout( s, n );\n      }\n}"
  },
  {
    "function_name": "init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/Y2SLog.cc",
    "lines": "52-58",
    "snippet": "static bool init() {\n  char * y2lfile = getenv( \"Y2SLOG_FILE\" );\n  if ( y2lfile ) {\n    set_log_filename( y2lfile );\n  }\n  return( getenv( \"Y2SLOG_DEBUG\" ) != NULL );\n}",
    "includes": [
      "#include <y2util/Y2SLog.h>",
      "#include <map>",
      "#include <string>",
      "#include <cstdlib>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"Y2SLOG_DEBUG\""
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_log_filename",
          "args": [
            "y2lfile"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "set_log_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2changes.cc",
          "lines": "188-240",
          "snippet": "static void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2CHANGES_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2CHANGES_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2CHANGES_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2CHANGES_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2CHANGES_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2CHANGES_FALLBACK );\n\n\t\tlogname = Y2CHANGES_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2CHANGES_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2CHANGES_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2CHANGES_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2CHANGES_VAR_NUM\t\"Y2MAXLOGNUM\"",
            "#define Y2CHANGES_VAR_SIZE\t\"Y2MAXLOGSIZE\"",
            "#define Y2CHANGES_FALLBACK\t\"/y2changes\"",
            "#define Y2CHANGES_USER\t\"/.y2changes\"\t\t/* Relative to $HOME */",
            "#define Y2CHANGES_ROOT\tLOGDIR \"/y2changes\"",
            "#define Y2CHANGES_MAXNUM\t10\t\t\t/* Maximum logfiles number */",
            "#define Y2CHANGES_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */"
          ],
          "globals_used": [
            "static bool did_set_logname = false;",
            "static const char *logname;",
            "static off_t maxlogsize;",
            "static int   maxlognum;",
            "static bool log_to_file = true;",
            "static bool log_to_syslog = false;",
            "static FILE *Y2CHANGES_STDERR = stderr;",
            "static void shift_log_files(string filename);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/y2changes.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2CHANGES_VAR_NUM\t\"Y2MAXLOGNUM\"\n#define Y2CHANGES_VAR_SIZE\t\"Y2MAXLOGSIZE\"\n#define Y2CHANGES_FALLBACK\t\"/y2changes\"\n#define Y2CHANGES_USER\t\"/.y2changes\"\t\t/* Relative to $HOME */\n#define Y2CHANGES_ROOT\tLOGDIR \"/y2changes\"\n#define Y2CHANGES_MAXNUM\t10\t\t\t/* Maximum logfiles number */\n#define Y2CHANGES_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */\n\nstatic bool did_set_logname = false;\nstatic const char *logname;\nstatic off_t maxlogsize;\nstatic int   maxlognum;\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic FILE *Y2CHANGES_STDERR = stderr;\nstatic void shift_log_files(string filename);\n\nstatic void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2CHANGES_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2CHANGES_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2CHANGES_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2CHANGES_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2CHANGES_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2CHANGES_FALLBACK );\n\n\t\tlogname = Y2CHANGES_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2CHANGES_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2CHANGES_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2CHANGES_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"Y2SLOG_FILE\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/Y2SLog.h>\n#include <map>\n#include <string>\n#include <cstdlib>\n\nstatic bool init() {\n  char * y2lfile = getenv( \"Y2SLOG_FILE\" );\n  if ( y2lfile ) {\n    set_log_filename( y2lfile );\n  }\n  return( getenv( \"Y2SLOG_DEBUG\" ) != NULL );\n}"
  }
]