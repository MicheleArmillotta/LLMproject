[
  {
    "function_name": "run_agent_instance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/run_agent.h",
    "lines": "78-169",
    "snippet": "void\nrun_agent_instance (int argc, char* argv[], bool load_scr, SCRAgent* agent)\n{\n    const char* fname = process_options (argc, argv);\n    \n    // fill in SCR builtins\n    SCR scr;\n\n    // create parser\n    Parser* parser = new Parser ();\n    if (!parser)\n    {\n\tfprintf (stderr, \"Failed to create Parser\\n\");\n\texit (EXIT_FAILURE);\n    }\n    \n    // create stdio as UI component, disable textdomain calls\n    Y2Component* user_interface = new Y2StdioComponent (false, true);\n    if (!user_interface)\n    {\n\tfprintf (stderr, \"Failed to create Y2StdioComponent\\n\");\n\texit (EXIT_FAILURE);\n    }\n\n    // load config file (if existing)\n    if (fname && load_scr)\n    {\n\tint len = strlen (fname);\n\tif (len > 5\n\t    && strcmp (&fname[len-4], \".ycp\") == 0)\n\t{\n\t    char* cname = strdup (fname);\n\t    strcpy (&cname[len-4], \".scr\");\n\t    if (access (cname, R_OK) == 0)\n\t    {\n\t\tYCPValue confval = SCRAgent::readconf (cname);\n\t\tif (confval.isNull ()\n\t\t    || !confval->isTerm ())\n\t\t{\n\t\t    fprintf (stderr, \"Failed to read '%s'\\n\", cname);\n\t\t    fprintf (stderr, \"Read result: %s\\n\", confval->toString().c_str());\n\t\t    exit (EXIT_FAILURE);\n\t\t}\n\t\tYCPTerm term = confval->asTerm();\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    agent->otherCommand (term->value (i)->asTerm ());\n\t\t}\n\t    }\n\t}\n    }\n\n    // open ycp script\n    FILE* infile = stdin;\n    if (fname != 0)\n    {\n\tinfile = fopen (fname, \"r\");\n\tif (infile == 0)\n\t{\n\t    fprintf (stderr, \"Failed to open '%s'\\n\", fname);\n\t    exit (EXIT_FAILURE);\n\t}\n    }\n    else\n    {\n\tfname = \"stdin\";\n    }\n\n    // evaluate ycp script\n    parser->setInput (infile, fname);\n    parser->setBuffered ();\n    YCodePtr value = 0;\n    while (true)\n    {\n\tvalue = parser->parse ();\t\t\t// error reports show our filename\n\tif (value == 0)\n\t{\n\t    break;\n\t}\n\tYCPValue result = value->evaluate ();\n\tprintf (\"(%s)\\n\", result->toString ().c_str ());\t// send result to caller\n\tfflush (0);\n    }\n\n    if (infile != stdin)\n    {\n\tfclose (infile);\n    }\n    delete user_interface;\n    delete parser;\t\t\t\t\t// restores callers filename\n\n}",
    "includes": [
      "#include <scr/SCR.h>",
      "#include <scr/SCRAgent.h>",
      "#include <y2/Y2StdioComponent.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/y2log.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void run_agent_instance (int, char*[], bool, SCRAgent*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "infile"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "0"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"(%s)\\n\"",
            "result->toString ().c_str ()"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result->toString",
          "args": [],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->evaluate",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->parse",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "484-562",
          "snippet": "int IniParser::parse()\n{\n    if (multiple_files)\n    {\n\tglob_t do_files;\n\tint len = files.size ();\n\tint flags = 0;\n\tfor (int i = 0;i<len;i++)\n\t{\n\t    glob (files[i].c_str (),flags, NULL, &do_files);\n\t    flags = GLOB_APPEND;\n\t}\n\tchar**f = do_files.gl_pathv;\n\tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n\t{\n\t    int section_index = -1;\n\t    string section_name = *f;\n\t    //FIXME: create function out of it.\n\t    // do we have name rewrite rules?\n\t    for (size_t j = 0; j < rewrites.size (); j++)\n\t\t{\n\t\t    RegexMatch m (rewrites[j].rx, section_name);\n\t\t    if (m)\n\t\t    {\n\t\t\tsection_index = j;\n\t\t\tsection_name = m[1];\n\t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    // do we know about the file?\n\t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n\t    if (ff == multi_files.end())\n\t    {\n\t\t// new file\n\t\tif (scanner_start (*f))\n\t\t    y2error (\"Cannot open %s.\", *f);\n\t\telse\n\t\t{\n\t\t    FileDescr fdsc (*f);\n\t\t    multi_files[*f] = fdsc;\n\t\t    inifile.initSection (section_name, \"\", -1, section_index);\n\t\t    parse_helper(inifile.getSection(section_name.c_str()));\n\t\t    scanner_stop();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif ((*ff).second.changed ())\n\t\t{\n\t\t    if (scanner_start (*f))\n\t\t\ty2error (\"Cannot open %s.\", *f);\n\t\t    else\n\t\t    {\n\t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n\t\t\tFileDescr fdsc (*f);\n\t\t\tmulti_files [*f] = fdsc;\n\t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n\t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n\t\t\tscanner_stop();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tif (scanner_start (file.c_str()))\n\t    {\n\t\ty2error (\"Can not open %s.\", file.c_str());\n\t\treturn -1;\n\t    }\n\tparse_helper(inifile);\n\tscanner_stop();\n\ttimestamp = getTimeStamp ();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse()\n  {\n      if (multiple_files)\n      {\n  \tglob_t do_files;\n  \tint len = files.size ();\n  \tint flags = 0;\n  \tfor (int i = 0;i<len;i++)\n  \t{\n  \t    glob (files[i].c_str (),flags, NULL, &do_files);\n  \t    flags = GLOB_APPEND;\n  \t}\n  \tchar**f = do_files.gl_pathv;\n  \tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n  \t{\n  \t    int section_index = -1;\n  \t    string section_name = *f;\n  \t    //FIXME: create function out of it.\n  \t    // do we have name rewrite rules?\n  \t    for (size_t j = 0; j < rewrites.size (); j++)\n  \t\t{\n  \t\t    RegexMatch m (rewrites[j].rx, section_name);\n  \t\t    if (m)\n  \t\t    {\n  \t\t\tsection_index = j;\n  \t\t\tsection_name = m[1];\n  \t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \n  \t    // do we know about the file?\n  \t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n  \t    if (ff == multi_files.end())\n  \t    {\n  \t\t// new file\n  \t\tif (scanner_start (*f))\n  \t\t    y2error (\"Cannot open %s.\", *f);\n  \t\telse\n  \t\t{\n  \t\t    FileDescr fdsc (*f);\n  \t\t    multi_files[*f] = fdsc;\n  \t\t    inifile.initSection (section_name, \"\", -1, section_index);\n  \t\t    parse_helper(inifile.getSection(section_name.c_str()));\n  \t\t    scanner_stop();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif ((*ff).second.changed ())\n  \t\t{\n  \t\t    if (scanner_start (*f))\n  \t\t\ty2error (\"Cannot open %s.\", *f);\n  \t\t    else\n  \t\t    {\n  \t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n  \t\t\tFileDescr fdsc (*f);\n  \t\t\tmulti_files [*f] = fdsc;\n  \t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n  \t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n  \t\t\tscanner_stop();\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n      else\n      {\n  \tif (scanner_start (file.c_str()))\n  \t    {\n  \t\ty2error (\"Can not open %s.\", file.c_str());\n  \t\treturn -1;\n  \t    }\n  \tparse_helper(inifile);\n  \tscanner_stop();\n  \ttimestamp = getTimeStamp ();\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->setBuffered",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "setBuffered",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "128-132",
          "snippet": "void\nScanner::setBuffered ()\n{\n    m_buffered = true;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  void\n  Scanner::setBuffered ()\n  {\n      m_buffered = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->setInput",
          "args": [
            "infile",
            "fname"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "setInput",
          "container": "Parser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Parser.cc",
          "lines": "108-115",
          "snippet": "void\nParser::setInput(int fd, const char *filename)\n{\n    if (m_scanner) delete m_scanner;\n    m_scanner = new Scanner (fd, filename);\n    if (m_buffered) m_scanner->setBuffered ();\n    m_at_eof = false;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Parser.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Parser.h\"\n#include <stdlib.h>\n\nParser {\n  void\n  Parser::setInput(int fd, const char *filename)\n  {\n      if (m_scanner) delete m_scanner;\n      m_scanner = new Scanner (fd, filename);\n      if (m_buffered) m_scanner->setBuffered ();\n      m_at_eof = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to open '%s'\\n\"",
            "fname"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "agent->otherCommand",
          "args": [
            "term->value (i)->asTerm ()"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "otherCommand",
          "container": "SCRAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/SCRAgent.cc",
          "lines": "66-70",
          "snippet": "YCPValue\nSCRAgent::otherCommand (const YCPTerm&)\n{\n    return YCPNull();\n}",
          "includes": [
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/Parser.h\"",
            "#include \"include/scr/SCR.h\"",
            "#include \"include/scr/SCRAgent.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCode.h\"\n#include \"ycp/Parser.h\"\n#include \"include/scr/SCR.h\"\n#include \"include/scr/SCRAgent.h\"\n#include <ycp/y2log.h>\n\nSCRAgent {\n  YCPValue\n  SCRAgent::otherCommand (const YCPTerm&)\n  {\n      return YCPNull();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->value",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->value",
          "args": [
            "i"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->size",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "confval->asTerm",
          "args": [],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Read result: %s\\n\"",
            "confval->toString().c_str()"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to read '%s'\\n\"",
            "cname"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "confval->isTerm",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "isTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "70-70",
          "snippet": "bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "confval.isNull",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCRAgent::readconf",
          "args": [
            "cname"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "readconf",
          "container": "SCRAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/SCRAgent.cc",
          "lines": "73-108",
          "snippet": "YCPValue\nSCRAgent::readconf (const char *filename)\n{\n    FILE *file = fopen (filename, \"r\");\n    if (!file)\n    {\n\tycp2error (\"Can't open %s for reading.\", filename);\n\treturn YCPNull ();\n    }\n\n    // find first line starting with \".\"\n    const int size = 250;\n    char line[size];\n    char *fgets_result;\n    do\n    {\n\tfgets_result = fgets (line, size, file);\n    }\n    while ((fgets_result != 0) && (line[0] != '.'));\n\n    Parser parser (file, filename);\n    YCodePtr tmpvalue = parser.parse ();\n    fclose (file);\n\n    y2debug( \"Parsed value '%s'\", tmpvalue != 0 ? tmpvalue->toString().c_str() : \"not available\" );\n    if (tmpvalue == 0 || tmpvalue->kind () != YCode::yeTerm )\n    {\n\tycp2error (\"Not a term in scr file.\");\n\treturn YCPNull();\n    }\n\n    // it is a term, generate YCPValue through its evaluation\n    YCPValue ret = tmpvalue->evaluate();\n\n    return ret;\n}",
          "includes": [
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/Parser.h\"",
            "#include \"include/scr/SCR.h\"",
            "#include \"include/scr/SCRAgent.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCode.h\"\n#include \"ycp/Parser.h\"\n#include \"include/scr/SCR.h\"\n#include \"include/scr/SCRAgent.h\"\n#include <ycp/y2log.h>\n\nSCRAgent {\n  YCPValue\n  SCRAgent::readconf (const char *filename)\n  {\n      FILE *file = fopen (filename, \"r\");\n      if (!file)\n      {\n  \tycp2error (\"Can't open %s for reading.\", filename);\n  \treturn YCPNull ();\n      }\n  \n      // find first line starting with \".\"\n      const int size = 250;\n      char line[size];\n      char *fgets_result;\n      do\n      {\n  \tfgets_result = fgets (line, size, file);\n      }\n      while ((fgets_result != 0) && (line[0] != '.'));\n  \n      Parser parser (file, filename);\n      YCodePtr tmpvalue = parser.parse ();\n      fclose (file);\n  \n      y2debug( \"Parsed value '%s'\", tmpvalue != 0 ? tmpvalue->toString().c_str() : \"not available\" );\n      if (tmpvalue == 0 || tmpvalue->kind () != YCode::yeTerm )\n      {\n  \tycp2error (\"Not a term in scr file.\");\n  \treturn YCPNull();\n      }\n  \n      // it is a term, generate YCPValue through its evaluation\n      YCPValue ret = tmpvalue->evaluate();\n  \n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "cname",
            "R_OK"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "&cname[len-4]",
            "\".scr\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "fname"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "&fname[len-4]",
            "\".ycp\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fname"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to create Y2StdioComponent\\n\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to create Parser\\n\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_options",
          "args": [
            "argc",
            "argv"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scr/SCR.h>\n#include <scr/SCRAgent.h>\n#include <y2/Y2StdioComponent.h>\n#include <ycp/Parser.h>\n#include <ycp/y2log.h>\n#include <unistd.h>\n#include <stdio.h>\n\nvoid run_agent_instance (int, char*[], bool, SCRAgent*);\n\nvoid\nrun_agent_instance (int argc, char* argv[], bool load_scr, SCRAgent* agent)\n{\n    const char* fname = process_options (argc, argv);\n    \n    // fill in SCR builtins\n    SCR scr;\n\n    // create parser\n    Parser* parser = new Parser ();\n    if (!parser)\n    {\n\tfprintf (stderr, \"Failed to create Parser\\n\");\n\texit (EXIT_FAILURE);\n    }\n    \n    // create stdio as UI component, disable textdomain calls\n    Y2Component* user_interface = new Y2StdioComponent (false, true);\n    if (!user_interface)\n    {\n\tfprintf (stderr, \"Failed to create Y2StdioComponent\\n\");\n\texit (EXIT_FAILURE);\n    }\n\n    // load config file (if existing)\n    if (fname && load_scr)\n    {\n\tint len = strlen (fname);\n\tif (len > 5\n\t    && strcmp (&fname[len-4], \".ycp\") == 0)\n\t{\n\t    char* cname = strdup (fname);\n\t    strcpy (&cname[len-4], \".scr\");\n\t    if (access (cname, R_OK) == 0)\n\t    {\n\t\tYCPValue confval = SCRAgent::readconf (cname);\n\t\tif (confval.isNull ()\n\t\t    || !confval->isTerm ())\n\t\t{\n\t\t    fprintf (stderr, \"Failed to read '%s'\\n\", cname);\n\t\t    fprintf (stderr, \"Read result: %s\\n\", confval->toString().c_str());\n\t\t    exit (EXIT_FAILURE);\n\t\t}\n\t\tYCPTerm term = confval->asTerm();\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    agent->otherCommand (term->value (i)->asTerm ());\n\t\t}\n\t    }\n\t}\n    }\n\n    // open ycp script\n    FILE* infile = stdin;\n    if (fname != 0)\n    {\n\tinfile = fopen (fname, \"r\");\n\tif (infile == 0)\n\t{\n\t    fprintf (stderr, \"Failed to open '%s'\\n\", fname);\n\t    exit (EXIT_FAILURE);\n\t}\n    }\n    else\n    {\n\tfname = \"stdin\";\n    }\n\n    // evaluate ycp script\n    parser->setInput (infile, fname);\n    parser->setBuffered ();\n    YCodePtr value = 0;\n    while (true)\n    {\n\tvalue = parser->parse ();\t\t\t// error reports show our filename\n\tif (value == 0)\n\t{\n\t    break;\n\t}\n\tYCPValue result = value->evaluate ();\n\tprintf (\"(%s)\\n\", result->toString ().c_str ());\t// send result to caller\n\tfflush (0);\n    }\n\n    if (infile != stdin)\n    {\n\tfclose (infile);\n    }\n    delete user_interface;\n    delete parser;\t\t\t\t\t// restores callers filename\n\n}"
  },
  {
    "function_name": "run_agent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/run_agent.h",
    "lines": "24-39",
    "snippet": "inline void\nrun_agent (int argc, char* argv[], bool load_scr)\n{\n    // create Agent\n    SCRAgent* agent = new Agent ();\n    if (!agent)\n    {\n\tfprintf (stderr, \"Failed to create Agent\\n\");\n\texit (EXIT_FAILURE);\n    }\n\n    run_agent_instance (argc, argv, load_scr, agent);\n\n    delete agent;\n    exit (EXIT_SUCCESS);\n}",
    "includes": [
      "#include <scr/SCR.h>",
      "#include <scr/SCRAgent.h>",
      "#include <y2/Y2StdioComponent.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/y2log.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void run_agent_instance (int, char*[], bool, SCRAgent*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_agent_instance",
          "args": [
            "argc",
            "argv",
            "load_scr",
            "agent"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "run_agent_instance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/run_agent.h",
          "lines": "78-169",
          "snippet": "void\nrun_agent_instance (int argc, char* argv[], bool load_scr, SCRAgent* agent)\n{\n    const char* fname = process_options (argc, argv);\n    \n    // fill in SCR builtins\n    SCR scr;\n\n    // create parser\n    Parser* parser = new Parser ();\n    if (!parser)\n    {\n\tfprintf (stderr, \"Failed to create Parser\\n\");\n\texit (EXIT_FAILURE);\n    }\n    \n    // create stdio as UI component, disable textdomain calls\n    Y2Component* user_interface = new Y2StdioComponent (false, true);\n    if (!user_interface)\n    {\n\tfprintf (stderr, \"Failed to create Y2StdioComponent\\n\");\n\texit (EXIT_FAILURE);\n    }\n\n    // load config file (if existing)\n    if (fname && load_scr)\n    {\n\tint len = strlen (fname);\n\tif (len > 5\n\t    && strcmp (&fname[len-4], \".ycp\") == 0)\n\t{\n\t    char* cname = strdup (fname);\n\t    strcpy (&cname[len-4], \".scr\");\n\t    if (access (cname, R_OK) == 0)\n\t    {\n\t\tYCPValue confval = SCRAgent::readconf (cname);\n\t\tif (confval.isNull ()\n\t\t    || !confval->isTerm ())\n\t\t{\n\t\t    fprintf (stderr, \"Failed to read '%s'\\n\", cname);\n\t\t    fprintf (stderr, \"Read result: %s\\n\", confval->toString().c_str());\n\t\t    exit (EXIT_FAILURE);\n\t\t}\n\t\tYCPTerm term = confval->asTerm();\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    agent->otherCommand (term->value (i)->asTerm ());\n\t\t}\n\t    }\n\t}\n    }\n\n    // open ycp script\n    FILE* infile = stdin;\n    if (fname != 0)\n    {\n\tinfile = fopen (fname, \"r\");\n\tif (infile == 0)\n\t{\n\t    fprintf (stderr, \"Failed to open '%s'\\n\", fname);\n\t    exit (EXIT_FAILURE);\n\t}\n    }\n    else\n    {\n\tfname = \"stdin\";\n    }\n\n    // evaluate ycp script\n    parser->setInput (infile, fname);\n    parser->setBuffered ();\n    YCodePtr value = 0;\n    while (true)\n    {\n\tvalue = parser->parse ();\t\t\t// error reports show our filename\n\tif (value == 0)\n\t{\n\t    break;\n\t}\n\tYCPValue result = value->evaluate ();\n\tprintf (\"(%s)\\n\", result->toString ().c_str ());\t// send result to caller\n\tfflush (0);\n    }\n\n    if (infile != stdin)\n    {\n\tfclose (infile);\n    }\n    delete user_interface;\n    delete parser;\t\t\t\t\t// restores callers filename\n\n}",
          "includes": [
            "#include <scr/SCR.h>",
            "#include <scr/SCRAgent.h>",
            "#include <y2/Y2StdioComponent.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/y2log.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void run_agent_instance (int, char*[], bool, SCRAgent*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scr/SCR.h>\n#include <scr/SCRAgent.h>\n#include <y2/Y2StdioComponent.h>\n#include <ycp/Parser.h>\n#include <ycp/y2log.h>\n#include <unistd.h>\n#include <stdio.h>\n\nvoid run_agent_instance (int, char*[], bool, SCRAgent*);\n\nvoid\nrun_agent_instance (int argc, char* argv[], bool load_scr, SCRAgent* agent)\n{\n    const char* fname = process_options (argc, argv);\n    \n    // fill in SCR builtins\n    SCR scr;\n\n    // create parser\n    Parser* parser = new Parser ();\n    if (!parser)\n    {\n\tfprintf (stderr, \"Failed to create Parser\\n\");\n\texit (EXIT_FAILURE);\n    }\n    \n    // create stdio as UI component, disable textdomain calls\n    Y2Component* user_interface = new Y2StdioComponent (false, true);\n    if (!user_interface)\n    {\n\tfprintf (stderr, \"Failed to create Y2StdioComponent\\n\");\n\texit (EXIT_FAILURE);\n    }\n\n    // load config file (if existing)\n    if (fname && load_scr)\n    {\n\tint len = strlen (fname);\n\tif (len > 5\n\t    && strcmp (&fname[len-4], \".ycp\") == 0)\n\t{\n\t    char* cname = strdup (fname);\n\t    strcpy (&cname[len-4], \".scr\");\n\t    if (access (cname, R_OK) == 0)\n\t    {\n\t\tYCPValue confval = SCRAgent::readconf (cname);\n\t\tif (confval.isNull ()\n\t\t    || !confval->isTerm ())\n\t\t{\n\t\t    fprintf (stderr, \"Failed to read '%s'\\n\", cname);\n\t\t    fprintf (stderr, \"Read result: %s\\n\", confval->toString().c_str());\n\t\t    exit (EXIT_FAILURE);\n\t\t}\n\t\tYCPTerm term = confval->asTerm();\n\t\tfor (int i = 0; i < term->size (); i++)\n\t\t{\n\t\t    agent->otherCommand (term->value (i)->asTerm ());\n\t\t}\n\t    }\n\t}\n    }\n\n    // open ycp script\n    FILE* infile = stdin;\n    if (fname != 0)\n    {\n\tinfile = fopen (fname, \"r\");\n\tif (infile == 0)\n\t{\n\t    fprintf (stderr, \"Failed to open '%s'\\n\", fname);\n\t    exit (EXIT_FAILURE);\n\t}\n    }\n    else\n    {\n\tfname = \"stdin\";\n    }\n\n    // evaluate ycp script\n    parser->setInput (infile, fname);\n    parser->setBuffered ();\n    YCodePtr value = 0;\n    while (true)\n    {\n\tvalue = parser->parse ();\t\t\t// error reports show our filename\n\tif (value == 0)\n\t{\n\t    break;\n\t}\n\tYCPValue result = value->evaluate ();\n\tprintf (\"(%s)\\n\", result->toString ().c_str ());\t// send result to caller\n\tfflush (0);\n    }\n\n    if (infile != stdin)\n    {\n\tfclose (infile);\n    }\n    delete user_interface;\n    delete parser;\t\t\t\t\t// restores callers filename\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to create Agent\\n\""
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scr/SCR.h>\n#include <scr/SCRAgent.h>\n#include <y2/Y2StdioComponent.h>\n#include <ycp/Parser.h>\n#include <ycp/y2log.h>\n#include <unistd.h>\n#include <stdio.h>\n\nvoid run_agent_instance (int, char*[], bool, SCRAgent*);\n\ninline void\nrun_agent (int argc, char* argv[], bool load_scr)\n{\n    // create Agent\n    SCRAgent* agent = new Agent ();\n    if (!agent)\n    {\n\tfprintf (stderr, \"Failed to create Agent\\n\");\n\texit (EXIT_FAILURE);\n    }\n\n    run_agent_instance (argc, argv, load_scr, agent);\n\n    delete agent;\n    exit (EXIT_SUCCESS);\n}"
  }
]