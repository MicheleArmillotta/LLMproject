[
  {
    "function_name": "wchar2utf8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
    "lines": "117-142",
    "snippet": "bool\nwchar2utf8 (const std::wstring& in, std::string* out)\n{\n    static iconv_t cd = (iconv_t)(-1);\n\n    if (cd == (iconv_t)(-1))\n    {\n\tcd = iconv_open (\"UTF-8\", \"WCHAR_T\");\n\n\t// TODO: also call iconv_close somewhere, perhaps use\n\t// pthread_key_create et.al.\n\n\tif (cd == (iconv_t)(-1))\n\t{\n\t    static bool shown_once = false;\n\t    if (!shown_once) {\n\t\ty2error (\"iconv_open: %m\");\n\t\tshown_once = true;\n\t    }\n\n\t    return false;\n\t}\n    }\n\n    return recode (cd, in, out);\n}",
    "includes": [
      "#include \"y2string.h\"",
      "#include \"y2log.h\"",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recode",
          "args": [
            "cd",
            "in",
            "out"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "recode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
          "lines": "82-86",
          "snippet": "bool\nrecode (iconv_t cd, const std::wstring& in, std::wstring* out)\n{\n    return recode_all (cd, in, out, L'?');\n}",
          "includes": [
            "#include \"y2string.h\"",
            "#include \"y2log.h\"",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nrecode (iconv_t cd, const std::wstring& in, std::wstring* out)\n{\n    return recode_all (cd, in, out, L'?');\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"iconv_open: %m\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-1"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iconv_open",
          "args": [
            "\"UTF-8\"",
            "\"WCHAR_T\""
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-1"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-1"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nwchar2utf8 (const std::wstring& in, std::string* out)\n{\n    static iconv_t cd = (iconv_t)(-1);\n\n    if (cd == (iconv_t)(-1))\n    {\n\tcd = iconv_open (\"UTF-8\", \"WCHAR_T\");\n\n\t// TODO: also call iconv_close somewhere, perhaps use\n\t// pthread_key_create et.al.\n\n\tif (cd == (iconv_t)(-1))\n\t{\n\t    static bool shown_once = false;\n\t    if (!shown_once) {\n\t\ty2error (\"iconv_open: %m\");\n\t\tshown_once = true;\n\t    }\n\n\t    return false;\n\t}\n    }\n\n    return recode (cd, in, out);\n}"
  },
  {
    "function_name": "utf82wchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
    "lines": "89-114",
    "snippet": "bool\nutf82wchar (const std::string& in, std::wstring* out)\n{\n    static iconv_t cd = (iconv_t)(-1);\n\n    if (cd == (iconv_t)(-1))\n    {\n\tcd = iconv_open (\"WCHAR_T\", \"UTF-8\");\n\n\t// TODO: also call iconv_close somewhere, perhaps use\n\t// pthread_key_create et.al.\n\n\tif (cd == (iconv_t)(-1))\n\t{\n\t    static bool shown_once = false;\n\t    if (!shown_once) {\n\t\ty2error (\"iconv_open: %m\");\n\t\tshown_once = true;\n\t    }\n\n\t    return false;\n\t}\n    }\n\n    return recode (cd, in, out);\n}",
    "includes": [
      "#include \"y2string.h\"",
      "#include \"y2log.h\"",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recode",
          "args": [
            "cd",
            "in",
            "out"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "recode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
          "lines": "82-86",
          "snippet": "bool\nrecode (iconv_t cd, const std::wstring& in, std::wstring* out)\n{\n    return recode_all (cd, in, out, L'?');\n}",
          "includes": [
            "#include \"y2string.h\"",
            "#include \"y2log.h\"",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nrecode (iconv_t cd, const std::wstring& in, std::wstring* out)\n{\n    return recode_all (cd, in, out, L'?');\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"iconv_open: %m\""
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-1"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iconv_open",
          "args": [
            "\"WCHAR_T\"",
            "\"UTF-8\""
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-1"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-1"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nutf82wchar (const std::string& in, std::wstring* out)\n{\n    static iconv_t cd = (iconv_t)(-1);\n\n    if (cd == (iconv_t)(-1))\n    {\n\tcd = iconv_open (\"WCHAR_T\", \"UTF-8\");\n\n\t// TODO: also call iconv_close somewhere, perhaps use\n\t// pthread_key_create et.al.\n\n\tif (cd == (iconv_t)(-1))\n\t{\n\t    static bool shown_once = false;\n\t    if (!shown_once) {\n\t\ty2error (\"iconv_open: %m\");\n\t\tshown_once = true;\n\t    }\n\n\t    return false;\n\t}\n    }\n\n    return recode (cd, in, out);\n}"
  },
  {
    "function_name": "recode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
    "lines": "82-86",
    "snippet": "bool\nrecode (iconv_t cd, const std::wstring& in, std::wstring* out)\n{\n    return recode_all (cd, in, out, L'?');\n}",
    "includes": [
      "#include \"y2string.h\"",
      "#include \"y2log.h\"",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recode_all",
          "args": [
            "cd",
            "in",
            "out",
            "L'?'"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "recode_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
          "lines": "14-58",
          "snippet": "bool\nrecode_all (iconv_t cd, const In& in, Out* out, const typename Out::value_type\n\t    errorsign)\n{\n    typedef typename In::value_type in_t;\n    typedef typename Out::value_type out_t;\n\n    char* in_ptr = (char*)(in.data ());\n    size_t in_len = in.length () * sizeof (in_t);\n\n    const size_t buffer_size = 1024;\n    out_t buffer[buffer_size];\n\n    out->clear ();\n\n    while (in_len != (size_t)(0))\n    {\n\tchar* tmp_ptr = (char*)(buffer);\n\tsize_t tmp_len = buffer_size * sizeof (out_t);\n\n\tsize_t r = iconv (cd, &in_ptr, &in_len, &tmp_ptr, &tmp_len);\n\tsize_t n = (out_t*)(tmp_ptr) - buffer;\n\n\tout->append (buffer, n);\n\n\tif (r == (size_t)(-1))\n\t{\n\t    if (errno == EINVAL || errno == EILSEQ)\n\t    {\n\t\t// more or less harmless\n\t\tout->append (1, errorsign);\n\t\tin_ptr += sizeof (in_t);\n\t\tin_len -= sizeof (in_t);\n\t    }\n\t    else if (errno == E2BIG && n == 0)\n\t    {\n\t\t// fatal: the buffer is too small to hold a\n\t\t// single multi-byte sequence\n\t\treturn false;\n\t    }\n\t}\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"y2string.h\"",
            "#include \"y2log.h\"",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nrecode_all (iconv_t cd, const In& in, Out* out, const typename Out::value_type\n\t    errorsign)\n{\n    typedef typename In::value_type in_t;\n    typedef typename Out::value_type out_t;\n\n    char* in_ptr = (char*)(in.data ());\n    size_t in_len = in.length () * sizeof (in_t);\n\n    const size_t buffer_size = 1024;\n    out_t buffer[buffer_size];\n\n    out->clear ();\n\n    while (in_len != (size_t)(0))\n    {\n\tchar* tmp_ptr = (char*)(buffer);\n\tsize_t tmp_len = buffer_size * sizeof (out_t);\n\n\tsize_t r = iconv (cd, &in_ptr, &in_len, &tmp_ptr, &tmp_len);\n\tsize_t n = (out_t*)(tmp_ptr) - buffer;\n\n\tout->append (buffer, n);\n\n\tif (r == (size_t)(-1))\n\t{\n\t    if (errno == EINVAL || errno == EILSEQ)\n\t    {\n\t\t// more or less harmless\n\t\tout->append (1, errorsign);\n\t\tin_ptr += sizeof (in_t);\n\t\tin_len -= sizeof (in_t);\n\t    }\n\t    else if (errno == E2BIG && n == 0)\n\t    {\n\t\t// fatal: the buffer is too small to hold a\n\t\t// single multi-byte sequence\n\t\treturn false;\n\t    }\n\t}\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nrecode (iconv_t cd, const std::wstring& in, std::wstring* out)\n{\n    return recode_all (cd, in, out, L'?');\n}"
  },
  {
    "function_name": "recode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
    "lines": "75-79",
    "snippet": "bool\nrecode (iconv_t cd, const std::wstring& in, std::string* out)\n{\n    return recode_all (cd, in, out, '?');\n}",
    "includes": [
      "#include \"y2string.h\"",
      "#include \"y2log.h\"",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recode_all",
          "args": [
            "cd",
            "in",
            "out",
            "'?'"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "recode_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
          "lines": "14-58",
          "snippet": "bool\nrecode_all (iconv_t cd, const In& in, Out* out, const typename Out::value_type\n\t    errorsign)\n{\n    typedef typename In::value_type in_t;\n    typedef typename Out::value_type out_t;\n\n    char* in_ptr = (char*)(in.data ());\n    size_t in_len = in.length () * sizeof (in_t);\n\n    const size_t buffer_size = 1024;\n    out_t buffer[buffer_size];\n\n    out->clear ();\n\n    while (in_len != (size_t)(0))\n    {\n\tchar* tmp_ptr = (char*)(buffer);\n\tsize_t tmp_len = buffer_size * sizeof (out_t);\n\n\tsize_t r = iconv (cd, &in_ptr, &in_len, &tmp_ptr, &tmp_len);\n\tsize_t n = (out_t*)(tmp_ptr) - buffer;\n\n\tout->append (buffer, n);\n\n\tif (r == (size_t)(-1))\n\t{\n\t    if (errno == EINVAL || errno == EILSEQ)\n\t    {\n\t\t// more or less harmless\n\t\tout->append (1, errorsign);\n\t\tin_ptr += sizeof (in_t);\n\t\tin_len -= sizeof (in_t);\n\t    }\n\t    else if (errno == E2BIG && n == 0)\n\t    {\n\t\t// fatal: the buffer is too small to hold a\n\t\t// single multi-byte sequence\n\t\treturn false;\n\t    }\n\t}\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"y2string.h\"",
            "#include \"y2log.h\"",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nrecode_all (iconv_t cd, const In& in, Out* out, const typename Out::value_type\n\t    errorsign)\n{\n    typedef typename In::value_type in_t;\n    typedef typename Out::value_type out_t;\n\n    char* in_ptr = (char*)(in.data ());\n    size_t in_len = in.length () * sizeof (in_t);\n\n    const size_t buffer_size = 1024;\n    out_t buffer[buffer_size];\n\n    out->clear ();\n\n    while (in_len != (size_t)(0))\n    {\n\tchar* tmp_ptr = (char*)(buffer);\n\tsize_t tmp_len = buffer_size * sizeof (out_t);\n\n\tsize_t r = iconv (cd, &in_ptr, &in_len, &tmp_ptr, &tmp_len);\n\tsize_t n = (out_t*)(tmp_ptr) - buffer;\n\n\tout->append (buffer, n);\n\n\tif (r == (size_t)(-1))\n\t{\n\t    if (errno == EINVAL || errno == EILSEQ)\n\t    {\n\t\t// more or less harmless\n\t\tout->append (1, errorsign);\n\t\tin_ptr += sizeof (in_t);\n\t\tin_len -= sizeof (in_t);\n\t    }\n\t    else if (errno == E2BIG && n == 0)\n\t    {\n\t\t// fatal: the buffer is too small to hold a\n\t\t// single multi-byte sequence\n\t\treturn false;\n\t    }\n\t}\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nrecode (iconv_t cd, const std::wstring& in, std::string* out)\n{\n    return recode_all (cd, in, out, '?');\n}"
  },
  {
    "function_name": "recode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
    "lines": "68-72",
    "snippet": "bool\nrecode (iconv_t cd, const std::string& in, std::wstring* out)\n{\n    return recode_all (cd, in, out, L'?');\n}",
    "includes": [
      "#include \"y2string.h\"",
      "#include \"y2log.h\"",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recode_all",
          "args": [
            "cd",
            "in",
            "out",
            "L'?'"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "recode_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
          "lines": "14-58",
          "snippet": "bool\nrecode_all (iconv_t cd, const In& in, Out* out, const typename Out::value_type\n\t    errorsign)\n{\n    typedef typename In::value_type in_t;\n    typedef typename Out::value_type out_t;\n\n    char* in_ptr = (char*)(in.data ());\n    size_t in_len = in.length () * sizeof (in_t);\n\n    const size_t buffer_size = 1024;\n    out_t buffer[buffer_size];\n\n    out->clear ();\n\n    while (in_len != (size_t)(0))\n    {\n\tchar* tmp_ptr = (char*)(buffer);\n\tsize_t tmp_len = buffer_size * sizeof (out_t);\n\n\tsize_t r = iconv (cd, &in_ptr, &in_len, &tmp_ptr, &tmp_len);\n\tsize_t n = (out_t*)(tmp_ptr) - buffer;\n\n\tout->append (buffer, n);\n\n\tif (r == (size_t)(-1))\n\t{\n\t    if (errno == EINVAL || errno == EILSEQ)\n\t    {\n\t\t// more or less harmless\n\t\tout->append (1, errorsign);\n\t\tin_ptr += sizeof (in_t);\n\t\tin_len -= sizeof (in_t);\n\t    }\n\t    else if (errno == E2BIG && n == 0)\n\t    {\n\t\t// fatal: the buffer is too small to hold a\n\t\t// single multi-byte sequence\n\t\treturn false;\n\t    }\n\t}\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"y2string.h\"",
            "#include \"y2log.h\"",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nrecode_all (iconv_t cd, const In& in, Out* out, const typename Out::value_type\n\t    errorsign)\n{\n    typedef typename In::value_type in_t;\n    typedef typename Out::value_type out_t;\n\n    char* in_ptr = (char*)(in.data ());\n    size_t in_len = in.length () * sizeof (in_t);\n\n    const size_t buffer_size = 1024;\n    out_t buffer[buffer_size];\n\n    out->clear ();\n\n    while (in_len != (size_t)(0))\n    {\n\tchar* tmp_ptr = (char*)(buffer);\n\tsize_t tmp_len = buffer_size * sizeof (out_t);\n\n\tsize_t r = iconv (cd, &in_ptr, &in_len, &tmp_ptr, &tmp_len);\n\tsize_t n = (out_t*)(tmp_ptr) - buffer;\n\n\tout->append (buffer, n);\n\n\tif (r == (size_t)(-1))\n\t{\n\t    if (errno == EINVAL || errno == EILSEQ)\n\t    {\n\t\t// more or less harmless\n\t\tout->append (1, errorsign);\n\t\tin_ptr += sizeof (in_t);\n\t\tin_len -= sizeof (in_t);\n\t    }\n\t    else if (errno == E2BIG && n == 0)\n\t    {\n\t\t// fatal: the buffer is too small to hold a\n\t\t// single multi-byte sequence\n\t\treturn false;\n\t    }\n\t}\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nrecode (iconv_t cd, const std::string& in, std::wstring* out)\n{\n    return recode_all (cd, in, out, L'?');\n}"
  },
  {
    "function_name": "recode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
    "lines": "61-65",
    "snippet": "bool\nrecode (iconv_t cd, const std::string& in, std::string* out)\n{\n    return recode_all (cd, in, out, '?');\n}",
    "includes": [
      "#include \"y2string.h\"",
      "#include \"y2log.h\"",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recode_all",
          "args": [
            "cd",
            "in",
            "out",
            "'?'"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "recode_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
          "lines": "14-58",
          "snippet": "bool\nrecode_all (iconv_t cd, const In& in, Out* out, const typename Out::value_type\n\t    errorsign)\n{\n    typedef typename In::value_type in_t;\n    typedef typename Out::value_type out_t;\n\n    char* in_ptr = (char*)(in.data ());\n    size_t in_len = in.length () * sizeof (in_t);\n\n    const size_t buffer_size = 1024;\n    out_t buffer[buffer_size];\n\n    out->clear ();\n\n    while (in_len != (size_t)(0))\n    {\n\tchar* tmp_ptr = (char*)(buffer);\n\tsize_t tmp_len = buffer_size * sizeof (out_t);\n\n\tsize_t r = iconv (cd, &in_ptr, &in_len, &tmp_ptr, &tmp_len);\n\tsize_t n = (out_t*)(tmp_ptr) - buffer;\n\n\tout->append (buffer, n);\n\n\tif (r == (size_t)(-1))\n\t{\n\t    if (errno == EINVAL || errno == EILSEQ)\n\t    {\n\t\t// more or less harmless\n\t\tout->append (1, errorsign);\n\t\tin_ptr += sizeof (in_t);\n\t\tin_len -= sizeof (in_t);\n\t    }\n\t    else if (errno == E2BIG && n == 0)\n\t    {\n\t\t// fatal: the buffer is too small to hold a\n\t\t// single multi-byte sequence\n\t\treturn false;\n\t    }\n\t}\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"y2string.h\"",
            "#include \"y2log.h\"",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nrecode_all (iconv_t cd, const In& in, Out* out, const typename Out::value_type\n\t    errorsign)\n{\n    typedef typename In::value_type in_t;\n    typedef typename Out::value_type out_t;\n\n    char* in_ptr = (char*)(in.data ());\n    size_t in_len = in.length () * sizeof (in_t);\n\n    const size_t buffer_size = 1024;\n    out_t buffer[buffer_size];\n\n    out->clear ();\n\n    while (in_len != (size_t)(0))\n    {\n\tchar* tmp_ptr = (char*)(buffer);\n\tsize_t tmp_len = buffer_size * sizeof (out_t);\n\n\tsize_t r = iconv (cd, &in_ptr, &in_len, &tmp_ptr, &tmp_len);\n\tsize_t n = (out_t*)(tmp_ptr) - buffer;\n\n\tout->append (buffer, n);\n\n\tif (r == (size_t)(-1))\n\t{\n\t    if (errno == EINVAL || errno == EILSEQ)\n\t    {\n\t\t// more or less harmless\n\t\tout->append (1, errorsign);\n\t\tin_ptr += sizeof (in_t);\n\t\tin_len -= sizeof (in_t);\n\t    }\n\t    else if (errno == E2BIG && n == 0)\n\t    {\n\t\t// fatal: the buffer is too small to hold a\n\t\t// single multi-byte sequence\n\t\treturn false;\n\t    }\n\t}\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nrecode (iconv_t cd, const std::string& in, std::string* out)\n{\n    return recode_all (cd, in, out, '?');\n}"
  },
  {
    "function_name": "recode_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
    "lines": "14-58",
    "snippet": "bool\nrecode_all (iconv_t cd, const In& in, Out* out, const typename Out::value_type\n\t    errorsign)\n{\n    typedef typename In::value_type in_t;\n    typedef typename Out::value_type out_t;\n\n    char* in_ptr = (char*)(in.data ());\n    size_t in_len = in.length () * sizeof (in_t);\n\n    const size_t buffer_size = 1024;\n    out_t buffer[buffer_size];\n\n    out->clear ();\n\n    while (in_len != (size_t)(0))\n    {\n\tchar* tmp_ptr = (char*)(buffer);\n\tsize_t tmp_len = buffer_size * sizeof (out_t);\n\n\tsize_t r = iconv (cd, &in_ptr, &in_len, &tmp_ptr, &tmp_len);\n\tsize_t n = (out_t*)(tmp_ptr) - buffer;\n\n\tout->append (buffer, n);\n\n\tif (r == (size_t)(-1))\n\t{\n\t    if (errno == EINVAL || errno == EILSEQ)\n\t    {\n\t\t// more or less harmless\n\t\tout->append (1, errorsign);\n\t\tin_ptr += sizeof (in_t);\n\t\tin_len -= sizeof (in_t);\n\t    }\n\t    else if (errno == E2BIG && n == 0)\n\t    {\n\t\t// fatal: the buffer is too small to hold a\n\t\t// single multi-byte sequence\n\t\treturn false;\n\t    }\n\t}\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"y2string.h\"",
      "#include \"y2log.h\"",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "out->append",
          "args": [
            "1",
            "errorsign"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out->append",
          "args": [
            "buffer",
            "n"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iconv",
          "args": [
            "cd",
            "&in_ptr",
            "&in_len",
            "&tmp_ptr",
            "&tmp_len"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out->clear",
          "args": [],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/PathInfo.h",
          "lines": "461-461",
          "snippet": "void clear() { _devino.clear(); }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <map>",
            "#include <set>",
            "#include <list>",
            "#include <iosfwd>",
            "#include <cerrno>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <map>\n#include <set>\n#include <list>\n#include <iosfwd>\n#include <cerrno>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid clear() { _devino.clear(); }"
        }
      },
      {
        "call_info": {
          "callee": "in.length",
          "args": [],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "in.data",
          "args": [],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nrecode_all (iconv_t cd, const In& in, Out* out, const typename Out::value_type\n\t    errorsign)\n{\n    typedef typename In::value_type in_t;\n    typedef typename Out::value_type out_t;\n\n    char* in_ptr = (char*)(in.data ());\n    size_t in_len = in.length () * sizeof (in_t);\n\n    const size_t buffer_size = 1024;\n    out_t buffer[buffer_size];\n\n    out->clear ();\n\n    while (in_len != (size_t)(0))\n    {\n\tchar* tmp_ptr = (char*)(buffer);\n\tsize_t tmp_len = buffer_size * sizeof (out_t);\n\n\tsize_t r = iconv (cd, &in_ptr, &in_len, &tmp_ptr, &tmp_len);\n\tsize_t n = (out_t*)(tmp_ptr) - buffer;\n\n\tout->append (buffer, n);\n\n\tif (r == (size_t)(-1))\n\t{\n\t    if (errno == EINVAL || errno == EILSEQ)\n\t    {\n\t\t// more or less harmless\n\t\tout->append (1, errorsign);\n\t\tin_ptr += sizeof (in_t);\n\t\tin_len -= sizeof (in_t);\n\t    }\n\t    else if (errno == E2BIG && n == 0)\n\t    {\n\t\t// fatal: the buffer is too small to hold a\n\t\t// single multi-byte sequence\n\t\treturn false;\n\t    }\n\t}\n    }\n\n    return true;\n}"
  }
]