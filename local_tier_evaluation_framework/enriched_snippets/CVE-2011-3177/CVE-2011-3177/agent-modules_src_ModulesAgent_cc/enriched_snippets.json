[
  {
    "function_name": "otherCommand",
    "container": "ModulesAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesAgent.cc",
    "lines": "345-360",
    "snippet": "YCPValue ModulesAgent::otherCommand(const YCPTerm& term) {\n    string sym = term->name();\n\n    if (sym == \"ModulesConf\" && term->size() == 1) {\n\tif (term->value(0)->isString()) {\n\t    YCPString s = term->value(0)->asString();\n\t    if (modules_conf != NULL)\n\t\tdelete modules_conf;\n\t    modules_conf = new ModulesConf(s->value());\n\t    return YCPVoid();\n\t} else \n\t    Y2_RETURN_VOID(\"Bad first arg of ModulesConf(): is not a string.\");\n    }\n\n    return YCPNull();\n}",
    "includes": [
      "#include \"ModulesConf.h\"",
      "#include \"ModulesAgent.h\"",
      "#include \"Y2Logger.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_VOID",
          "args": [
            "\"Bad first arg of ModulesConf(): is not a string.\""
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s->value",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YConst",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "342-346",
          "snippet": "YCPValue\nYConst::value() const\n{\n    return m_value;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYConst {\n  YCPValue\n  YConst::value() const\n  {\n      return m_value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->value",
          "args": [],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->value",
          "args": [
            "0"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->size",
          "args": [],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->name",
          "args": [],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2AgentComp",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "44-44",
          "snippet": "string name () const { return my_name; }",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp {\n  string name () const { return my_name; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ModulesConf.h\"\n#include \"ModulesAgent.h\"\n#include \"Y2Logger.h\"\n\nModulesAgent {\n  YCPValue ModulesAgent::otherCommand(const YCPTerm& term) {\n      string sym = term->name();\n  \n      if (sym == \"ModulesConf\" && term->size() == 1) {\n  \tif (term->value(0)->isString()) {\n  \t    YCPString s = term->value(0)->asString();\n  \t    if (modules_conf != NULL)\n  \t\tdelete modules_conf;\n  \t    modules_conf = new ModulesConf(s->value());\n  \t    return YCPVoid();\n  \t} else \n  \t    Y2_RETURN_VOID(\"Bad first arg of ModulesConf(): is not a string.\");\n      }\n  \n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "Write",
    "container": "ModulesAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesAgent.cc",
    "lines": "230-339",
    "snippet": "YCPBoolean ModulesAgent::Write(const YCPPath &path, const YCPValue& value, const YCPValue& arg) {\n\n    if (modules_conf == NULL)\n\tY2_RETURN_VOID(\"Can't execute Write before being mounted.\");\n\n    if (path->isRoot() && value->isVoid ())\n\treturn YCPBoolean(modules_conf->writeFile());\n\n    switch (path->length ()) {\n\n    case 1:\n\t/* FIXME: remove */\n\tif (!arg.isNull () && arg->isString ()) {\n\t    y2error(\"Obsolete interface, don't use any more!\");\n\t    if (value->isVoid ())\n\t\treturn YCPBoolean (modules_conf->removeEntry (PC(0), VAL2STR(arg)));\n\t    if (PC(0) == \"options\") {\n\t\tif (value->isMap ())\n\t\t    return YCPBoolean (modules_conf->setOptions(VAL2STR(arg),\n\t\t\t\t\t\t\t\tycpmap2map (value->asMap ()),\n\t\t\t\t\t\t\t\tModuleEntry::SET));\n\t\telse \n\t\t    Y2_RETURN_YCP_FALSE(\"Argument for Write () not map.\");\n\t    }\n\t    return YCPBoolean (modules_conf->setArgument (PC(0), VAL2STR(arg),\n\t\t\t\t\t\t\t  VAL2STR(value),\n\t\t\t\t\t\t\t  ModuleEntry::SET));\n\t}\n\n#if 0 /* some attempts to support other directives */\n\n\t/* .modules.keep, nil */\n\t/* .modules.prune, nil */\n\tif (PC(0) != \"keep\" && PC(0) != \"prune\")\n\t    Y2_RETURN_YCP_FALSE(\"Unsupported simple directive: %s,\"\n\t\t    \"please inform maintainer\", PC(0).c_str());\n\n\tif (value->isVoid ())\n\t    return YCPBoolean (modules_conf->removeEntry (PC(0), \"\"));\n\n\t/* .modules.keep, \"\" [zero args directives -> ignore 2nd arg] */\n\tif (PC(0) == \"keep\")\n\t    return YCPBoolean (modules_conf->setArgument (PC(0), \"\",\n\t\t\t\"\", ModuleEntry::SET));\n\n\tif (!value->isString())\n\t    Y2_RETURN_YCP_FALSE(\"Argument for Write() is not string: %s.\",\n\t\t    value->toString().c_str());\n\n\t/* .modules.prune, \"filename\" */\n\treturn YCPBoolean (modules_conf->setArgument (PC(0), \"\",\n\t\t    VAL2STR(value), ModuleEntry::SET));\n#endif\n\n\tY2_RETURN_YCP_FALSE(\"Argument (2nd) for Write() is not string.\");\n\n    case 2:\n\t/* FIXME: remove */\n\tif (value->isString () && !arg.isNull () && arg->isString ()) {\n\t    y2error(\"Obsolete interface, don't use any more!\");\n\t    if (PC(0) == \"options\")\n\t\treturn YCPBoolean (modules_conf->setOption (VAL2STR(arg), PC(1),\n\t\t\t\t\t\t\t    VAL2STR(value),\n\t\t\t\t\t\t\t    ModuleEntry::SET));\n\t    if (PC(1) == \"comment\")\n\t\treturn YCPBoolean (modules_conf->setComment (PC(0), VAL2STR(arg),\n\t\t\t\t\t\t\t     VAL2STR(value),\n\t\t\t\t\t\t\t     ModuleEntry::SET));\n\t}\n\n\t/* .modules.alias.eth0, nil */\n\tif (value->isVoid ())\n\t    return YCPBoolean (modules_conf->removeEntry (PC(0), PC(1)));\n\n\t/* .modules.options.eth0, $[\"irq\":\"7\"] */\n\tif (PC(0) == \"options\") {\n\t    if (value->isMap ())\n\t\treturn YCPBoolean (modules_conf->setOptions(PC(1),\n\t\t\t    ycpmap2map (value->asMap ()), ModuleEntry::SET));\n\t    else \n\t\tY2_RETURN_YCP_FALSE(\"Argument for Write(.options) not map: %s.\",\n\t\t\tvalue->toString().c_str());\n\t}\n\n\tif (!value->isString())\n\t    Y2_RETURN_YCP_FALSE(\"Argument for Write() is not string: %s.\",\n\t\t    value->toString().c_str());\n\n\t/* .modules.alias.eth0, \"off\" */\n\treturn YCPBoolean (modules_conf->setArgument (PC(0), PC(1),\n\t\t    VAL2STR(value), ModuleEntry::SET));\n\n    case 3:\n\tif (!value->isString())\n\t    Y2_RETURN_YCP_FALSE(\"Argument for Write() is not string: %s.\",\n\t\t    value->toString().c_str());\n\n\t/* .modules.alias.eth0.comment, \"# First tulip\\n\" */\n\tif (PC(2) == \"comment\") {\n\t    return YCPBoolean (modules_conf->setComment (PC(0), PC(1),\n\t\t\tVAL2STR(value), ModuleEntry::SET));\n\t}\n\t/* .modules.options.eth0.irq, \"7\" */\n\tif (PC(0) == \"options\")\n\t    return YCPBoolean (modules_conf->setOption (PC(1), PC(2),\n\t\t\tVAL2STR(value), ModuleEntry::SET));\n    }\n\n    Y2_RETURN_VOID(\"Wrong path '%s' in Write().\", path->toString().c_str());\n}",
    "includes": [
      "#include \"ModulesConf.h\"",
      "#include \"ModulesAgent.h\"",
      "#include \"Y2Logger.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Y2_RETURN_VOID",
          "args": [
            "\"Wrong path '%s' in Write().\"",
            "path->toString().c_str()"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->toString",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "modules_conf->setOption (PC(1), PC(2),\n\t\t\tVAL2STR(value), ModuleEntry::SET)"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf->setOption",
          "args": [
            "PC(1)",
            "PC(2)",
            "VAL2STR(value)",
            "ModuleEntry::SET"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "setOption",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "218-227",
          "snippet": "bool ModulesConf::setOption(const string module, const string option, const string value, ModuleEntry::Mode m) {\n    if(option == \"\" || module == \"\" || value == \"\") {\n\ty2error(\"empty argument: %s, %s, %s\", module.c_str(), option.c_str(), value.c_str());\n\treturn false;\n    }\n    modified |= (m == ModuleEntry::SET);\n    updateIndex(\"options\",module);\n    modules_conf_map[\"options\"][module].setOption(option, value, m);\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::setOption(const string module, const string option, const string value, ModuleEntry::Mode m) {\n      if(option == \"\" || module == \"\" || value == \"\") {\n  \ty2error(\"empty argument: %s, %s, %s\", module.c_str(), option.c_str(), value.c_str());\n  \treturn false;\n      }\n      modified |= (m == ModuleEntry::SET);\n      updateIndex(\"options\",module);\n      modules_conf_map[\"options\"][module].setOption(option, value, m);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "value"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PC",
          "args": [
            "2"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "YCPCode",
          "container": "YCPCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "103-107",
          "snippet": "YCPCode::YCPCode (bytecodeistream & str)\n    : YCPValue (YCPCode())\n{\n    (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPCode {\n  YCPCode::YCPCode (bytecodeistream & str)\n      : YCPValue (YCPCode())\n  {\n      (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf->setComment",
          "args": [
            "PC(0)",
            "PC(1)",
            "VAL2STR(value)",
            "ModuleEntry::SET"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "setComment",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "249-253",
          "snippet": "bool ModulesConf::setComment(const string directive, const string module, const string arg, ModuleEntry::Mode m) {\n    modified |= (m == ModuleEntry::SET);\n    modules_conf_map[directive][module].setComment(arg, m);\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::setComment(const string directive, const string module, const string arg, ModuleEntry::Mode m) {\n      modified |= (m == ModuleEntry::SET);\n      modules_conf_map[directive][module].setComment(arg, m);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "value"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_YCP_FALSE",
          "args": [
            "\"Argument for Write() is not string: %s.\"",
            "value->toString().c_str()"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->isString",
          "args": [],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf->setArgument",
          "args": [
            "PC(0)",
            "PC(1)",
            "VAL2STR(value)",
            "ModuleEntry::SET"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "setArgument",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "238-247",
          "snippet": "bool ModulesConf::setArgument(const string directive, const string module, const string arg, ModuleEntry::Mode m) {\n    if((directive == \"alias\" || directive == \"options\" || directive == \"pre-install\" || directive == \"post-install\" ) && (directive == \"\" || module == \"\" || arg == \"\")) {\n\ty2error(\"empty argument: %s, %s, %s\", directive.c_str(), module.c_str(), arg.c_str());\n\treturn false;\n    }\n    modified |= (m == ModuleEntry::SET);\n    updateIndex(directive,module);\n    modules_conf_map[directive][module].setArgument(arg, m);\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::setArgument(const string directive, const string module, const string arg, ModuleEntry::Mode m) {\n      if((directive == \"alias\" || directive == \"options\" || directive == \"pre-install\" || directive == \"post-install\" ) && (directive == \"\" || module == \"\" || arg == \"\")) {\n  \ty2error(\"empty argument: %s, %s, %s\", directive.c_str(), module.c_str(), arg.c_str());\n  \treturn false;\n      }\n      modified |= (m == ModuleEntry::SET);\n      updateIndex(directive,module);\n      modules_conf_map[directive][module].setArgument(arg, m);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "value"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_YCP_FALSE",
          "args": [
            "\"Argument for Write() is not string: %s.\"",
            "value->toString().c_str()"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_YCP_FALSE",
          "args": [
            "\"Argument for Write(.options) not map: %s.\"",
            "value->toString().c_str()"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modules_conf->setOptions",
          "args": [
            "PC(1)",
            "ycpmap2map (value->asMap ())",
            "ModuleEntry::SET"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "setOptions",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "229-236",
          "snippet": "bool ModulesConf::setOptions(const string module, const ModuleEntry::EntryArg arg, ModuleEntry::Mode m) {\n    modified |= (m == ModuleEntry::SET);\n    if(arg.empty())\n        Y2_RETURN_FALSE(\"setOptions:Empty map\");\n    updateIndex(\"options\",module);\n    modules_conf_map[\"options\"][module].setOptions(arg, m);\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::setOptions(const string module, const ModuleEntry::EntryArg arg, ModuleEntry::Mode m) {\n      modified |= (m == ModuleEntry::SET);\n      if(arg.empty())\n          Y2_RETURN_FALSE(\"setOptions:Empty map\");\n      updateIndex(\"options\",module);\n      modules_conf_map[\"options\"][module].setOptions(arg, m);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycpmap2map",
          "args": [
            "value->asMap ()"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "ycpmap2map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesAgent.cc",
          "lines": "88-101",
          "snippet": "ModuleEntry::EntryArg ycpmap2map (const YCPMap &m) {\n    ModuleEntry::EntryArg ret_map;\n    YCPMap::const_iterator it = m->begin ();\n\n    for (; it != m->end(); ++it)\n\tif (it->first->isString () && it->second->isString ())\n\t    ret_map[VAL2STR(it->first)] = VAL2STR(it->second);\n\telse {\n\t    y2error(\"Map element must be string!\");\n\t    return ModuleEntry::EntryArg();\n\t}\n    \n    return ret_map;\n}",
          "includes": [
            "#include \"ModulesConf.h\"",
            "#include \"ModulesAgent.h\"",
            "#include \"Y2Logger.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ModulesConf.h\"\n#include \"ModulesAgent.h\"\n#include \"Y2Logger.h\"\n\nModuleEntry::EntryArg ycpmap2map (const YCPMap &m) {\n    ModuleEntry::EntryArg ret_map;\n    YCPMap::const_iterator it = m->begin ();\n\n    for (; it != m->end(); ++it)\n\tif (it->first->isString () && it->second->isString ())\n\t    ret_map[VAL2STR(it->first)] = VAL2STR(it->second);\n\telse {\n\t    y2error(\"Map element must be string!\");\n\t    return ModuleEntry::EntryArg();\n\t}\n    \n    return ret_map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asMap",
          "args": [],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->isMap",
          "args": [],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "71-71",
          "snippet": "bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf->removeEntry",
          "args": [
            "PC(0)",
            "PC(1)"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "removeEntry",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "457-470",
          "snippet": "bool ModulesConf::removeEntry(const string directive, const string module) {\n    modified = true;\n    if(!isModule(directive,module)) {\n        y2warning(\"removeEntry: no such directive or module (%s,%s)\",directive.c_str(),module.c_str());\n\treturn false;\n    }\n    if(modules_conf_map[directive].erase(module) < 1)\n        Y2_RETURN_FALSE(\"removeEntry: erase failed (%s,%s)\",directive.c_str(),module.c_str());\n    if(modules_conf_map[directive].empty())\n        if(modules_conf_map.erase(directive) < 1)\n            Y2_RETURN_FALSE(\"removeEntry: erase failed (%s)\",directive.c_str());\n    modules_conf_index.remove(\".\"+directive+\".\"+module);\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::removeEntry(const string directive, const string module) {\n      modified = true;\n      if(!isModule(directive,module)) {\n          y2warning(\"removeEntry: no such directive or module (%s,%s)\",directive.c_str(),module.c_str());\n  \treturn false;\n      }\n      if(modules_conf_map[directive].erase(module) < 1)\n          Y2_RETURN_FALSE(\"removeEntry: erase failed (%s,%s)\",directive.c_str(),module.c_str());\n      if(modules_conf_map[directive].empty())\n          if(modules_conf_map.erase(directive) < 1)\n              Y2_RETURN_FALSE(\"removeEntry: erase failed (%s)\",directive.c_str());\n      modules_conf_index.remove(\".\"+directive+\".\"+module);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->isVoid",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "value"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "arg"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "value"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "arg"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Obsolete interface, don't use any more!\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_YCP_FALSE",
          "args": [
            "\"Argument (2nd) for Write() is not string.\""
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "value"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_YCP_FALSE",
          "args": [
            "\"Argument for Write() is not string: %s.\"",
            "value->toString().c_str()"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_YCP_FALSE",
          "args": [
            "\"Unsupported simple directive: %s,\"\n\t\t    \"please inform maintainer\"",
            "PC(0).c_str()"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PC",
          "args": [],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "YCPCodeRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "69-73",
          "snippet": "YCPValueType\nYCPCodeRep::valuetype() const\n{\n    return YT_CODE;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPCodeRep {\n  YCPValueType\n  YCPCodeRep::valuetype() const\n  {\n      return YT_CODE;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "value"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "arg"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_YCP_FALSE",
          "args": [
            "\"Argument for Write () not map.\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "arg"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "arg"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Obsolete interface, don't use any more!\""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->length",
          "args": [],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf->writeFile",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->isRoot",
          "args": [],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "isRoot",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "83-87",
          "snippet": "bool\nYCPPathRep::isRoot() const\n{\n    return components.empty();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  bool\n  YCPPathRep::isRoot() const\n  {\n      return components.empty();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_VOID",
          "args": [
            "\"Can't execute Write before being mounted.\""
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ModulesConf.h\"\n#include \"ModulesAgent.h\"\n#include \"Y2Logger.h\"\n\nModulesAgent {\n  YCPBoolean ModulesAgent::Write(const YCPPath &path, const YCPValue& value, const YCPValue& arg) {\n  \n      if (modules_conf == NULL)\n  \tY2_RETURN_VOID(\"Can't execute Write before being mounted.\");\n  \n      if (path->isRoot() && value->isVoid ())\n  \treturn YCPBoolean(modules_conf->writeFile());\n  \n      switch (path->length ()) {\n  \n      case 1:\n  \t/* FIXME: remove */\n  \tif (!arg.isNull () && arg->isString ()) {\n  \t    y2error(\"Obsolete interface, don't use any more!\");\n  \t    if (value->isVoid ())\n  \t\treturn YCPBoolean (modules_conf->removeEntry (PC(0), VAL2STR(arg)));\n  \t    if (PC(0) == \"options\") {\n  \t\tif (value->isMap ())\n  \t\t    return YCPBoolean (modules_conf->setOptions(VAL2STR(arg),\n  \t\t\t\t\t\t\t\tycpmap2map (value->asMap ()),\n  \t\t\t\t\t\t\t\tModuleEntry::SET));\n  \t\telse \n  \t\t    Y2_RETURN_YCP_FALSE(\"Argument for Write () not map.\");\n  \t    }\n  \t    return YCPBoolean (modules_conf->setArgument (PC(0), VAL2STR(arg),\n  \t\t\t\t\t\t\t  VAL2STR(value),\n  \t\t\t\t\t\t\t  ModuleEntry::SET));\n  \t}\n  \n  #if 0 /* some attempts to support other directives */\n  \n  \t/* .modules.keep, nil */\n  \t/* .modules.prune, nil */\n  \tif (PC(0) != \"keep\" && PC(0) != \"prune\")\n  \t    Y2_RETURN_YCP_FALSE(\"Unsupported simple directive: %s,\"\n  \t\t    \"please inform maintainer\", PC(0).c_str());\n  \n  \tif (value->isVoid ())\n  \t    return YCPBoolean (modules_conf->removeEntry (PC(0), \"\"));\n  \n  \t/* .modules.keep, \"\" [zero args directives -> ignore 2nd arg] */\n  \tif (PC(0) == \"keep\")\n  \t    return YCPBoolean (modules_conf->setArgument (PC(0), \"\",\n  \t\t\t\"\", ModuleEntry::SET));\n  \n  \tif (!value->isString())\n  \t    Y2_RETURN_YCP_FALSE(\"Argument for Write() is not string: %s.\",\n  \t\t    value->toString().c_str());\n  \n  \t/* .modules.prune, \"filename\" */\n  \treturn YCPBoolean (modules_conf->setArgument (PC(0), \"\",\n  \t\t    VAL2STR(value), ModuleEntry::SET));\n  #endif\n  \n  \tY2_RETURN_YCP_FALSE(\"Argument (2nd) for Write() is not string.\");\n  \n      case 2:\n  \t/* FIXME: remove */\n  \tif (value->isString () && !arg.isNull () && arg->isString ()) {\n  \t    y2error(\"Obsolete interface, don't use any more!\");\n  \t    if (PC(0) == \"options\")\n  \t\treturn YCPBoolean (modules_conf->setOption (VAL2STR(arg), PC(1),\n  \t\t\t\t\t\t\t    VAL2STR(value),\n  \t\t\t\t\t\t\t    ModuleEntry::SET));\n  \t    if (PC(1) == \"comment\")\n  \t\treturn YCPBoolean (modules_conf->setComment (PC(0), VAL2STR(arg),\n  \t\t\t\t\t\t\t     VAL2STR(value),\n  \t\t\t\t\t\t\t     ModuleEntry::SET));\n  \t}\n  \n  \t/* .modules.alias.eth0, nil */\n  \tif (value->isVoid ())\n  \t    return YCPBoolean (modules_conf->removeEntry (PC(0), PC(1)));\n  \n  \t/* .modules.options.eth0, $[\"irq\":\"7\"] */\n  \tif (PC(0) == \"options\") {\n  \t    if (value->isMap ())\n  \t\treturn YCPBoolean (modules_conf->setOptions(PC(1),\n  \t\t\t    ycpmap2map (value->asMap ()), ModuleEntry::SET));\n  \t    else \n  \t\tY2_RETURN_YCP_FALSE(\"Argument for Write(.options) not map: %s.\",\n  \t\t\tvalue->toString().c_str());\n  \t}\n  \n  \tif (!value->isString())\n  \t    Y2_RETURN_YCP_FALSE(\"Argument for Write() is not string: %s.\",\n  \t\t    value->toString().c_str());\n  \n  \t/* .modules.alias.eth0, \"off\" */\n  \treturn YCPBoolean (modules_conf->setArgument (PC(0), PC(1),\n  \t\t    VAL2STR(value), ModuleEntry::SET));\n  \n      case 3:\n  \tif (!value->isString())\n  \t    Y2_RETURN_YCP_FALSE(\"Argument for Write() is not string: %s.\",\n  \t\t    value->toString().c_str());\n  \n  \t/* .modules.alias.eth0.comment, \"# First tulip\\n\" */\n  \tif (PC(2) == \"comment\") {\n  \t    return YCPBoolean (modules_conf->setComment (PC(0), PC(1),\n  \t\t\tVAL2STR(value), ModuleEntry::SET));\n  \t}\n  \t/* .modules.options.eth0.irq, \"7\" */\n  \tif (PC(0) == \"options\")\n  \t    return YCPBoolean (modules_conf->setOption (PC(1), PC(2),\n  \t\t\tVAL2STR(value), ModuleEntry::SET));\n      }\n  \n      Y2_RETURN_VOID(\"Wrong path '%s' in Write().\", path->toString().c_str());\n  }\n}"
  },
  {
    "function_name": "Read",
    "container": "ModulesAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesAgent.cc",
    "lines": "143-225",
    "snippet": "YCPValue ModulesAgent::Read(const YCPPath &path, const YCPValue& arg, const YCPValue& optarg) {\n\t    \n    if (modules_conf == NULL)\n\tY2_RETURN_VOID(\"Can't execute Read before being mounted.\");\n\t    \n    y2debug(\"Read(%s)\", path->toString().c_str());\n\n    switch (path->length ()) {\n\n    case 0:\n\t/* .modules -> [\"alias\",\"options\"] */\n\treturn YCPList (map2list (modules_conf->getDirectives()));\n\n    case 1:\n\t/* FIXME: remove */\n\tif (!arg.isNull() && arg->isString ()) {\n\t    y2error(\"Obsolete interface, don't use any more!\");\n\t    if (PC(0) == \"options\")\n\t\treturn YCPMap (map2ycpmap (modules_conf->getOptions(VAL2STR(arg))));\n\t    else\n\t\treturn YCPString (modules_conf->getArgument(PC(0), VAL2STR(arg)));\n\t}\n\n\t/* .modules.options -> [\"eth0\",\"eth1\"] */\n\treturn YCPList (map2list (modules_conf->getModules(PC(0))));\n\n#if 0 /* some attempts to support other directives */\n\n\t/* .modules.keep -> \"\" */\n\t/* .modules.prune -> \"filename\" */\n\tif (PC(0) == \"keep\" || PC(0) == \"prune\") {\n\t    YCPPath newpath;\n\t    newpath->append(PC(0));\n\t    newpath->append(string(\"\"));\n\t    //newpath->append(string(\"\\\"\\\"\"));\n\t    return Read(newpath, arg);\n\t}\n\n\t/* .modules.keep -> \"\" */\n\t/* .modules.prune -> \"filename\" */\n\tif (PC(0) != \"keep\" && PC(0) != \"prune\")\n\t    Y2_RETURN_VOID(\"Unsupported simple directive: %s,\"\n\t\t    \"please inform maintainer\", PC(0).c_str());\n\n\t/* .modules.keep -> \"\" [zero args directives -> ignore 2nd arg] */\n\tif(PC(0) == \"keep\")\n\t    return YCPString (\"\");\n\n\t/* .modules.prune, \"filename\" */\n\treturn YCPString (modules_conf->getArgument(PC(0), \"\"));\n#endif\n\n\tY2_RETURN_VOID(\"Wrong path '%s' in Read().\", path->toString().c_str());\n\n    case 2:\n\t/* FIXME: remove */\n\tif (!arg.isNull () && arg->isString ()) {\n\t    y2error(\"Obsolete interface, don't use any more!\");\n\t    if (PC(1) == \"comment\")\n\t\treturn YCPString (modules_conf->getComment(PC(0), VAL2STR(arg)));\n\t    if (PC(0) == \"options\")\n\t\treturn YCPString (modules_conf->getOption(VAL2STR(arg), PC(1)));\n\t}\n\n\t/* .modules.options.eth0 -> $[\"irq\":\"7\"] */\n\tif(PC(0) == \"options\")\n\t    return YCPMap (map2ycpmap (modules_conf->getOptions(PC(1))));\n\t/* .modules.alias.eth0 -> \"off\" */\n\telse\n\t    return YCPString (modules_conf->getArgument(PC(0), PC(1)));\n\n    case 3:\n\t/* .modules.alias.eth0.comment -> \"# comment\\n\" */\n\tif (PC(2) == \"comment\")\n\t    return YCPString (modules_conf->getComment(PC(0), PC(1)));\n\t/* .modules.options.eth0.irq -> \"7\" */\n\tif (PC(0) == \"options\")\n\t    return YCPString (modules_conf->getOption(PC(1), PC(2)));\n\n    }\n    \n    Y2_RETURN_VOID(\"Wrong path '%s' in Read().\", path->toString().c_str());\n}",
    "includes": [
      "#include \"ModulesConf.h\"",
      "#include \"ModulesAgent.h\"",
      "#include \"Y2Logger.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Y2_RETURN_VOID",
          "args": [
            "\"Wrong path '%s' in Read().\"",
            "path->toString().c_str()"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->toString",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "modules_conf->getOption(PC(1), PC(2))"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf->getOption",
          "args": [
            "PC(1)",
            "PC(2)"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "getOption",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "187-198",
          "snippet": "string ModulesConf::getOption(const string module, const string option) {\n    updateIfModified ();\n    if(!isOption(module,option))\n\tY2_RETURN_STR(\"Bad module or option: %s, %s\", module.c_str(), option.c_str());\n    ModuleEntry::EntryArg ea = modules_conf_map[\"options\"][module].getArgument();\n    if(ea.find(MAGIC_ENTRY)!=ea.end())\n\tY2_RETURN_STR(\"Bad request for option while there is a string (%s, %s).\", module.c_str(), option.c_str());\n    if(ea.find(option)==ea.end())\n\tY2_RETURN_STR(\"Bad request for option %s (%s).\", option.c_str(), module.c_str());\n    y2debug(\"OPTION: %s\", ea[option].c_str());\n    return ea[option];\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  string ModulesConf::getOption(const string module, const string option) {\n      updateIfModified ();\n      if(!isOption(module,option))\n  \tY2_RETURN_STR(\"Bad module or option: %s, %s\", module.c_str(), option.c_str());\n      ModuleEntry::EntryArg ea = modules_conf_map[\"options\"][module].getArgument();\n      if(ea.find(MAGIC_ENTRY)!=ea.end())\n  \tY2_RETURN_STR(\"Bad request for option while there is a string (%s, %s).\", module.c_str(), option.c_str());\n      if(ea.find(option)==ea.end())\n  \tY2_RETURN_STR(\"Bad request for option %s (%s).\", option.c_str(), module.c_str());\n      y2debug(\"OPTION: %s\", ea[option].c_str());\n      return ea[option];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PC",
          "args": [
            "2"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "YCPCode",
          "container": "YCPCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "103-107",
          "snippet": "YCPCode::YCPCode (bytecodeistream & str)\n    : YCPValue (YCPCode())\n{\n    (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPCode {\n  YCPCode::YCPCode (bytecodeistream & str)\n      : YCPValue (YCPCode())\n  {\n      (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf->getComment",
          "args": [
            "PC(0)",
            "PC(1)"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "getComment",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "158-164",
          "snippet": "string ModulesConf::getComment(const string directive, const string module) {\n    updateIfModified ();\n    if(!isModule(directive,module))\n\tY2_RETURN_STR(\"Bad directive or module: %s, %s\", directive.c_str(), module.c_str());\n\n    return modules_conf_map[directive][module].getComment();\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  string ModulesConf::getComment(const string directive, const string module) {\n      updateIfModified ();\n      if(!isModule(directive,module))\n  \tY2_RETURN_STR(\"Bad directive or module: %s, %s\", directive.c_str(), module.c_str());\n  \n      return modules_conf_map[directive][module].getComment();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf->getArgument",
          "args": [
            "PC(0)",
            "PC(1)"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "getArgument",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "143-156",
          "snippet": "string ModulesConf::getArgument(const string directive, const string module) {\n    updateIfModified ();\n    if(!isModule(directive,module))\n\tY2_RETURN_STR(\"Bad directive or module: %s, %s\", directive.c_str(), module.c_str());\n\n    ModuleEntry::EntryArg ea = modules_conf_map[directive][module].getArgument();\n    y2debug(\"getArgument(%s,%s) %p\",directive.c_str(),module.c_str(), this);\n    if(ea.find(MAGIC_ENTRY)==ea.end()) {\n        y2warning(\"Bad request for string while there are options (%s, %s).\", directive.c_str(), module.c_str());\n        return getOptionsAsString(module);\n    }\n    y2debug(\"MAGIC: %s\", ea[MAGIC_ENTRY].c_str());\n    return ea[MAGIC_ENTRY];\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  string ModulesConf::getArgument(const string directive, const string module) {\n      updateIfModified ();\n      if(!isModule(directive,module))\n  \tY2_RETURN_STR(\"Bad directive or module: %s, %s\", directive.c_str(), module.c_str());\n  \n      ModuleEntry::EntryArg ea = modules_conf_map[directive][module].getArgument();\n      y2debug(\"getArgument(%s,%s) %p\",directive.c_str(),module.c_str(), this);\n      if(ea.find(MAGIC_ENTRY)==ea.end()) {\n          y2warning(\"Bad request for string while there are options (%s, %s).\", directive.c_str(), module.c_str());\n          return getOptionsAsString(module);\n      }\n      y2debug(\"MAGIC: %s\", ea[MAGIC_ENTRY].c_str());\n      return ea[MAGIC_ENTRY];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPMap",
          "args": [
            "map2ycpmap (modules_conf->getOptions(PC(1)))"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "YCPMap",
          "container": "YCPMap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "261-274",
          "snippet": "YCPMap::YCPMap(bytecodeistream & str)\n    : YCPValue (YCPMap())\n{\n    u_int32_t len = Bytecode::readInt32 (str);\n    if (str.good())\n    {\n\tfor (unsigned index=0; index < len; index++)\n\t{\n\t    YCPValue key = Bytecode::readValue (str);\n\t    YCPValue value = Bytecode::readValue (str);\n\t    (*this)->add (key, value);\n\t}\n    }\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMap {\n  YCPMap::YCPMap(bytecodeistream & str)\n      : YCPValue (YCPMap())\n  {\n      u_int32_t len = Bytecode::readInt32 (str);\n      if (str.good())\n      {\n  \tfor (unsigned index=0; index < len; index++)\n  \t{\n  \t    YCPValue key = Bytecode::readValue (str);\n  \t    YCPValue value = Bytecode::readValue (str);\n  \t    (*this)->add (key, value);\n  \t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map2ycpmap",
          "args": [
            "modules_conf->getOptions(PC(1))"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "map2ycpmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesAgent.cc",
          "lines": "75-83",
          "snippet": "YCPMap map2ycpmap(const T &m) {\n    YCPMap ret_map;\n    typename T::const_iterator it = m.begin ();\n\t\n    for (; it != m.end(); ++it)\n\tret_map->add (YCPString (it->first), YCPString (it->second));\n\t\n    return ret_map;\n}",
          "includes": [
            "#include \"ModulesConf.h\"",
            "#include \"ModulesAgent.h\"",
            "#include \"Y2Logger.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ModulesConf.h\"\n#include \"ModulesAgent.h\"\n#include \"Y2Logger.h\"\n\nYCPMap map2ycpmap(const T &m) {\n    YCPMap ret_map;\n    typename T::const_iterator it = m.begin ();\n\t\n    for (; it != m.end(); ++it)\n\tret_map->add (YCPString (it->first), YCPString (it->second));\n\t\n    return ret_map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf->getOptions",
          "args": [
            "PC(1)"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "getOptions",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "166-178",
          "snippet": "ModuleEntry::EntryArg ModulesConf::getOptions(const string module) {\n    updateIfModified ();\n    if(!isModule(\"options\",module)) {\n\ty2error(\"Bad options for module: %s\", module.c_str());\n        return ModuleEntry::EntryArg();\n    }\n    ModuleEntry::EntryArg ea = modules_conf_map[\"options\"][module].getArgument();\n    if(ea.find(MAGIC_ENTRY)!=ea.end()) {\n\ty2error(\"Bad request for options while there is only a string (%s).\", module.c_str());\n\treturn ModuleEntry::EntryArg();\n    }\n    return ea;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  ModuleEntry::EntryArg ModulesConf::getOptions(const string module) {\n      updateIfModified ();\n      if(!isModule(\"options\",module)) {\n  \ty2error(\"Bad options for module: %s\", module.c_str());\n          return ModuleEntry::EntryArg();\n      }\n      ModuleEntry::EntryArg ea = modules_conf_map[\"options\"][module].getArgument();\n      if(ea.find(MAGIC_ENTRY)!=ea.end()) {\n  \ty2error(\"Bad request for options while there is only a string (%s).\", module.c_str());\n  \treturn ModuleEntry::EntryArg();\n      }\n      return ea;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "arg"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "arg"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Obsolete interface, don't use any more!\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg->isString",
          "args": [],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_VOID",
          "args": [
            "\"Wrong path '%s' in Read().\"",
            "path->toString().c_str()"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_VOID",
          "args": [
            "\"Unsupported simple directive: %s,\"\n\t\t    \"please inform maintainer\"",
            "PC(0).c_str()"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PC",
          "args": [],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "YCPCodeRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "69-73",
          "snippet": "YCPValueType\nYCPCodeRep::valuetype() const\n{\n    return YT_CODE;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPCodeRep {\n  YCPValueType\n  YCPCodeRep::valuetype() const\n  {\n      return YT_CODE;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Read",
          "args": [
            "newpath",
            "arg"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "SCRRead2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/SCR.cc",
          "lines": "48-51",
          "snippet": "static YCPValue \nSCRRead2 (const YCPPath &path, const YCPValue &arg) {\n    return SCRRead3 (path, arg);\n}",
          "includes": [
            "#include \"scr/SCRAgent.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"scr/SCR.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"scr/SCRAgent.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"scr/SCR.h\"\n\nstatic YCPValue \nSCRRead2 (const YCPPath &path, const YCPValue &arg) {\n    return SCRRead3 (path, arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "newpath->append",
          "args": [
            "string(\"\")"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "append",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "106-113",
          "snippet": "void\nYCPPathRep::append(string c)\n{\n    Component added;\n    added.component = Ustring (*SymbolEntry::_nameHash, c);\n    added.complex = true;  //it would be nicer if we checked if it is really complex, but this is faster\n    components.push_back(added);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  void\n  YCPPathRep::append(string c)\n  {\n      Component added;\n      added.component = Ustring (*SymbolEntry::_nameHash, c);\n      added.complex = true;  //it would be nicer if we checked if it is really complex, but this is faster\n      components.push_back(added);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"\""
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPList",
          "args": [
            "map2list (modules_conf->getModules(PC(0)))"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "YCPList",
          "container": "YCPList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "303-316",
          "snippet": "YCPList::YCPList(bytecodeistream & str)\n    : YCPValue (YCPList())\n{\n    u_int32_t len = Bytecode::readInt32 (str);\n    if (str.good())\n    {\n\t(const_cast<YCPListRep*>(static_cast<const YCPListRep*>(element)))->reserve (len);\n\tfor (unsigned index = 0; index < len; index++)\n\t{\n\t    YCPValue value = Bytecode::readValue (str);\n\t    (const_cast<YCPListRep*>(static_cast<const YCPListRep*>(element)))->set (index, value);\n\t}\n    }\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPList {\n  YCPList::YCPList(bytecodeistream & str)\n      : YCPValue (YCPList())\n  {\n      u_int32_t len = Bytecode::readInt32 (str);\n      if (str.good())\n      {\n  \t(const_cast<YCPListRep*>(static_cast<const YCPListRep*>(element)))->reserve (len);\n  \tfor (unsigned index = 0; index < len; index++)\n  \t{\n  \t    YCPValue value = Bytecode::readValue (str);\n  \t    (const_cast<YCPListRep*>(static_cast<const YCPListRep*>(element)))->set (index, value);\n  \t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map2list",
          "args": [
            "modules_conf->getModules(PC(0))"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "map2list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesAgent.cc",
          "lines": "60-70",
          "snippet": "YCPList map2list(const T &m) {\n    YCPList list;\n    typename T::const_iterator it = m.begin ();\n\t\n    for (; it != m.end (); ++it)\n\t/* Preserve listing of the final comment */\n\tif(it->first != \"YaST2_final_modules_conf_comment\")\n\t    list->add(YCPString (it->first));\n\t\n    return list;\n}",
          "includes": [
            "#include \"ModulesConf.h\"",
            "#include \"ModulesAgent.h\"",
            "#include \"Y2Logger.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ModulesConf.h\"\n#include \"ModulesAgent.h\"\n#include \"Y2Logger.h\"\n\nYCPList map2list(const T &m) {\n    YCPList list;\n    typename T::const_iterator it = m.begin ();\n\t\n    for (; it != m.end (); ++it)\n\t/* Preserve listing of the final comment */\n\tif(it->first != \"YaST2_final_modules_conf_comment\")\n\t    list->add(YCPString (it->first));\n\t\n    return list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf->getModules",
          "args": [
            "PC(0)"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "getModules",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "134-141",
          "snippet": "ModulesConf::ModuleEntryMap ModulesConf::getModules(const string directive) {\n    updateIfModified ();\n    if(!isDirective(directive)) {\n\ty2error(\"Bad directive: %s\", directive.c_str());\n        return ModulesConf::ModuleEntryMap();\n    }\n    return modules_conf_map[directive];\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  ModulesConf::ModuleEntryMap ModulesConf::getModules(const string directive) {\n      updateIfModified ();\n      if(!isDirective(directive)) {\n  \ty2error(\"Bad directive: %s\", directive.c_str());\n          return ModulesConf::ModuleEntryMap();\n      }\n      return modules_conf_map[directive];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "arg"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "arg"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Obsolete interface, don't use any more!\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modules_conf->getDirectives",
          "args": [],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "getDirectives",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "129-132",
          "snippet": "ModulesConf::ModulesConfMap ModulesConf::getDirectives() {\n    updateIfModified ();\n    return modules_conf_map;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  ModulesConf::ModulesConfMap ModulesConf::getDirectives() {\n      updateIfModified ();\n      return modules_conf_map;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "path->length",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Read(%s)\"",
            "path->toString().c_str()"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_VOID",
          "args": [
            "\"Can't execute Read before being mounted.\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ModulesConf.h\"\n#include \"ModulesAgent.h\"\n#include \"Y2Logger.h\"\n\nModulesAgent {\n  YCPValue ModulesAgent::Read(const YCPPath &path, const YCPValue& arg, const YCPValue& optarg) {\n  \t    \n      if (modules_conf == NULL)\n  \tY2_RETURN_VOID(\"Can't execute Read before being mounted.\");\n  \t    \n      y2debug(\"Read(%s)\", path->toString().c_str());\n  \n      switch (path->length ()) {\n  \n      case 0:\n  \t/* .modules -> [\"alias\",\"options\"] */\n  \treturn YCPList (map2list (modules_conf->getDirectives()));\n  \n      case 1:\n  \t/* FIXME: remove */\n  \tif (!arg.isNull() && arg->isString ()) {\n  \t    y2error(\"Obsolete interface, don't use any more!\");\n  \t    if (PC(0) == \"options\")\n  \t\treturn YCPMap (map2ycpmap (modules_conf->getOptions(VAL2STR(arg))));\n  \t    else\n  \t\treturn YCPString (modules_conf->getArgument(PC(0), VAL2STR(arg)));\n  \t}\n  \n  \t/* .modules.options -> [\"eth0\",\"eth1\"] */\n  \treturn YCPList (map2list (modules_conf->getModules(PC(0))));\n  \n  #if 0 /* some attempts to support other directives */\n  \n  \t/* .modules.keep -> \"\" */\n  \t/* .modules.prune -> \"filename\" */\n  \tif (PC(0) == \"keep\" || PC(0) == \"prune\") {\n  \t    YCPPath newpath;\n  \t    newpath->append(PC(0));\n  \t    newpath->append(string(\"\"));\n  \t    //newpath->append(string(\"\\\"\\\"\"));\n  \t    return Read(newpath, arg);\n  \t}\n  \n  \t/* .modules.keep -> \"\" */\n  \t/* .modules.prune -> \"filename\" */\n  \tif (PC(0) != \"keep\" && PC(0) != \"prune\")\n  \t    Y2_RETURN_VOID(\"Unsupported simple directive: %s,\"\n  \t\t    \"please inform maintainer\", PC(0).c_str());\n  \n  \t/* .modules.keep -> \"\" [zero args directives -> ignore 2nd arg] */\n  \tif(PC(0) == \"keep\")\n  \t    return YCPString (\"\");\n  \n  \t/* .modules.prune, \"filename\" */\n  \treturn YCPString (modules_conf->getArgument(PC(0), \"\"));\n  #endif\n  \n  \tY2_RETURN_VOID(\"Wrong path '%s' in Read().\", path->toString().c_str());\n  \n      case 2:\n  \t/* FIXME: remove */\n  \tif (!arg.isNull () && arg->isString ()) {\n  \t    y2error(\"Obsolete interface, don't use any more!\");\n  \t    if (PC(1) == \"comment\")\n  \t\treturn YCPString (modules_conf->getComment(PC(0), VAL2STR(arg)));\n  \t    if (PC(0) == \"options\")\n  \t\treturn YCPString (modules_conf->getOption(VAL2STR(arg), PC(1)));\n  \t}\n  \n  \t/* .modules.options.eth0 -> $[\"irq\":\"7\"] */\n  \tif(PC(0) == \"options\")\n  \t    return YCPMap (map2ycpmap (modules_conf->getOptions(PC(1))));\n  \t/* .modules.alias.eth0 -> \"off\" */\n  \telse\n  \t    return YCPString (modules_conf->getArgument(PC(0), PC(1)));\n  \n      case 3:\n  \t/* .modules.alias.eth0.comment -> \"# comment\\n\" */\n  \tif (PC(2) == \"comment\")\n  \t    return YCPString (modules_conf->getComment(PC(0), PC(1)));\n  \t/* .modules.options.eth0.irq -> \"7\" */\n  \tif (PC(0) == \"options\")\n  \t    return YCPString (modules_conf->getOption(PC(1), PC(2)));\n  \n      }\n      \n      Y2_RETURN_VOID(\"Wrong path '%s' in Read().\", path->toString().c_str());\n  }\n}"
  },
  {
    "function_name": "Dir",
    "container": "ModulesAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesAgent.cc",
    "lines": "107-137",
    "snippet": "YCPList ModulesAgent::Dir(const YCPPath& path) {\n    YCPList list;\n    string elem;\n\n    if (modules_conf == NULL) {\n\tycp2error(\"Can't execute Dir before being mounted.\");\n\treturn YCPNull();\n    }\n\n    switch (path->length ()) {\n\n\tcase 0:\n\t    /* .modules -> [\"alias\",\"options\"] */\n\t    return YCPList (map2list (modules_conf->getDirectives ()));\n\n\tcase 1:\n\t    if(PC(0) == MAGIC_DIRECTIVE)\n\t\tY2_RETURN_VOID(\"Dir() doesn't support the .%s directive\", MAGIC_DIRECTIVE);\n\n\t    /* .modules.options -> [\"eth0\",\"eth1\"] */\n\t    return YCPList (map2list (modules_conf->getModules(PC(0))));\n\n\tcase 2:\n\t    /* .modules.options.eth0 -> [\"irq\",\"io\"] */\n\t    if(PC(0) == \"options\")\n\t\treturn YCPList (map2list (modules_conf->getOptions(PC(1))));\n\n    }\n\n    Y2_RETURN_VOID(\"Wrong path '%s' in Dir().\", path->toString().c_str());\n}",
    "includes": [
      "#include \"ModulesConf.h\"",
      "#include \"ModulesAgent.h\"",
      "#include \"Y2Logger.h\""
    ],
    "macros_used": [
      "#define MAGIC_DIRECTIVE \"extra\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Y2_RETURN_VOID",
          "args": [
            "\"Wrong path '%s' in Dir().\"",
            "path->toString().c_str()"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->toString",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPList",
          "args": [
            "map2list (modules_conf->getOptions(PC(1)))"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "YCPList",
          "container": "YCPList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "303-316",
          "snippet": "YCPList::YCPList(bytecodeistream & str)\n    : YCPValue (YCPList())\n{\n    u_int32_t len = Bytecode::readInt32 (str);\n    if (str.good())\n    {\n\t(const_cast<YCPListRep*>(static_cast<const YCPListRep*>(element)))->reserve (len);\n\tfor (unsigned index = 0; index < len; index++)\n\t{\n\t    YCPValue value = Bytecode::readValue (str);\n\t    (const_cast<YCPListRep*>(static_cast<const YCPListRep*>(element)))->set (index, value);\n\t}\n    }\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPList {\n  YCPList::YCPList(bytecodeistream & str)\n      : YCPValue (YCPList())\n  {\n      u_int32_t len = Bytecode::readInt32 (str);\n      if (str.good())\n      {\n  \t(const_cast<YCPListRep*>(static_cast<const YCPListRep*>(element)))->reserve (len);\n  \tfor (unsigned index = 0; index < len; index++)\n  \t{\n  \t    YCPValue value = Bytecode::readValue (str);\n  \t    (const_cast<YCPListRep*>(static_cast<const YCPListRep*>(element)))->set (index, value);\n  \t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map2list",
          "args": [
            "modules_conf->getOptions(PC(1))"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "map2list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesAgent.cc",
          "lines": "60-70",
          "snippet": "YCPList map2list(const T &m) {\n    YCPList list;\n    typename T::const_iterator it = m.begin ();\n\t\n    for (; it != m.end (); ++it)\n\t/* Preserve listing of the final comment */\n\tif(it->first != \"YaST2_final_modules_conf_comment\")\n\t    list->add(YCPString (it->first));\n\t\n    return list;\n}",
          "includes": [
            "#include \"ModulesConf.h\"",
            "#include \"ModulesAgent.h\"",
            "#include \"Y2Logger.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ModulesConf.h\"\n#include \"ModulesAgent.h\"\n#include \"Y2Logger.h\"\n\nYCPList map2list(const T &m) {\n    YCPList list;\n    typename T::const_iterator it = m.begin ();\n\t\n    for (; it != m.end (); ++it)\n\t/* Preserve listing of the final comment */\n\tif(it->first != \"YaST2_final_modules_conf_comment\")\n\t    list->add(YCPString (it->first));\n\t\n    return list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf->getOptions",
          "args": [
            "PC(1)"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "getOptions",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "166-178",
          "snippet": "ModuleEntry::EntryArg ModulesConf::getOptions(const string module) {\n    updateIfModified ();\n    if(!isModule(\"options\",module)) {\n\ty2error(\"Bad options for module: %s\", module.c_str());\n        return ModuleEntry::EntryArg();\n    }\n    ModuleEntry::EntryArg ea = modules_conf_map[\"options\"][module].getArgument();\n    if(ea.find(MAGIC_ENTRY)!=ea.end()) {\n\ty2error(\"Bad request for options while there is only a string (%s).\", module.c_str());\n\treturn ModuleEntry::EntryArg();\n    }\n    return ea;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  ModuleEntry::EntryArg ModulesConf::getOptions(const string module) {\n      updateIfModified ();\n      if(!isModule(\"options\",module)) {\n  \ty2error(\"Bad options for module: %s\", module.c_str());\n          return ModuleEntry::EntryArg();\n      }\n      ModuleEntry::EntryArg ea = modules_conf_map[\"options\"][module].getArgument();\n      if(ea.find(MAGIC_ENTRY)!=ea.end()) {\n  \ty2error(\"Bad request for options while there is only a string (%s).\", module.c_str());\n  \treturn ModuleEntry::EntryArg();\n      }\n      return ea;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PC",
          "args": [
            "1"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "YCPCode",
          "container": "YCPCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "103-107",
          "snippet": "YCPCode::YCPCode (bytecodeistream & str)\n    : YCPValue (YCPCode())\n{\n    (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPCode {\n  YCPCode::YCPCode (bytecodeistream & str)\n      : YCPValue (YCPCode())\n  {\n      (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf->getModules",
          "args": [
            "PC(0)"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "getModules",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "134-141",
          "snippet": "ModulesConf::ModuleEntryMap ModulesConf::getModules(const string directive) {\n    updateIfModified ();\n    if(!isDirective(directive)) {\n\ty2error(\"Bad directive: %s\", directive.c_str());\n        return ModulesConf::ModuleEntryMap();\n    }\n    return modules_conf_map[directive];\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  ModulesConf::ModuleEntryMap ModulesConf::getModules(const string directive) {\n      updateIfModified ();\n      if(!isDirective(directive)) {\n  \ty2error(\"Bad directive: %s\", directive.c_str());\n          return ModulesConf::ModuleEntryMap();\n      }\n      return modules_conf_map[directive];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_VOID",
          "args": [
            "\"Dir() doesn't support the .%s directive\"",
            "MAGIC_DIRECTIVE"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modules_conf->getDirectives",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "getDirectives",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "129-132",
          "snippet": "ModulesConf::ModulesConfMap ModulesConf::getDirectives() {\n    updateIfModified ();\n    return modules_conf_map;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  ModulesConf::ModulesConfMap ModulesConf::getDirectives() {\n      updateIfModified ();\n      return modules_conf_map;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "path->length",
          "args": [],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Can't execute Dir before being mounted.\""
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ModulesConf.h\"\n#include \"ModulesAgent.h\"\n#include \"Y2Logger.h\"\n\n#define MAGIC_DIRECTIVE \"extra\"\n\nModulesAgent {\n  YCPList ModulesAgent::Dir(const YCPPath& path) {\n      YCPList list;\n      string elem;\n  \n      if (modules_conf == NULL) {\n  \tycp2error(\"Can't execute Dir before being mounted.\");\n  \treturn YCPNull();\n      }\n  \n      switch (path->length ()) {\n  \n  \tcase 0:\n  \t    /* .modules -> [\"alias\",\"options\"] */\n  \t    return YCPList (map2list (modules_conf->getDirectives ()));\n  \n  \tcase 1:\n  \t    if(PC(0) == MAGIC_DIRECTIVE)\n  \t\tY2_RETURN_VOID(\"Dir() doesn't support the .%s directive\", MAGIC_DIRECTIVE);\n  \n  \t    /* .modules.options -> [\"eth0\",\"eth1\"] */\n  \t    return YCPList (map2list (modules_conf->getModules(PC(0))));\n  \n  \tcase 2:\n  \t    /* .modules.options.eth0 -> [\"irq\",\"io\"] */\n  \t    if(PC(0) == \"options\")\n  \t\treturn YCPList (map2list (modules_conf->getOptions(PC(1))));\n  \n      }\n  \n      Y2_RETURN_VOID(\"Wrong path '%s' in Dir().\", path->toString().c_str());\n  }\n}"
  },
  {
    "function_name": "ycpmap2map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesAgent.cc",
    "lines": "88-101",
    "snippet": "ModuleEntry::EntryArg ycpmap2map (const YCPMap &m) {\n    ModuleEntry::EntryArg ret_map;\n    YCPMap::const_iterator it = m->begin ();\n\n    for (; it != m->end(); ++it)\n\tif (it->first->isString () && it->second->isString ())\n\t    ret_map[VAL2STR(it->first)] = VAL2STR(it->second);\n\telse {\n\t    y2error(\"Map element must be string!\");\n\t    return ModuleEntry::EntryArg();\n\t}\n    \n    return ret_map;\n}",
    "includes": [
      "#include \"ModulesConf.h\"",
      "#include \"ModulesAgent.h\"",
      "#include \"Y2Logger.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ModuleEntry::EntryArg",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Map element must be string!\""
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "it->second"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VAL2STR",
          "args": [
            "it->first"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it->second->isString",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->end",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->begin",
          "args": [],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ModulesConf.h\"\n#include \"ModulesAgent.h\"\n#include \"Y2Logger.h\"\n\nModuleEntry::EntryArg ycpmap2map (const YCPMap &m) {\n    ModuleEntry::EntryArg ret_map;\n    YCPMap::const_iterator it = m->begin ();\n\n    for (; it != m->end(); ++it)\n\tif (it->first->isString () && it->second->isString ())\n\t    ret_map[VAL2STR(it->first)] = VAL2STR(it->second);\n\telse {\n\t    y2error(\"Map element must be string!\");\n\t    return ModuleEntry::EntryArg();\n\t}\n    \n    return ret_map;\n}"
  },
  {
    "function_name": "map2ycpmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesAgent.cc",
    "lines": "75-83",
    "snippet": "YCPMap map2ycpmap(const T &m) {\n    YCPMap ret_map;\n    typename T::const_iterator it = m.begin ();\n\t\n    for (; it != m.end(); ++it)\n\tret_map->add (YCPString (it->first), YCPString (it->second));\n\t\n    return ret_map;\n}",
    "includes": [
      "#include \"ModulesConf.h\"",
      "#include \"ModulesAgent.h\"",
      "#include \"Y2Logger.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret_map->add",
          "args": [
            "YCPString (it->first)",
            "YCPString (it->second)"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "50-76",
          "snippet": "void\nYCPMapRep::add (const YCPValue& key, const YCPValue& value)\n{\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn;\n    }\n\n    // Note: 'stl_map[key] = value' would create a temporary object using the\n    // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n    // 24.\n\n    YCPMap::iterator pos = stl_map.lower_bound(key);\n    if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n    {\n\tpos->second = value;\n    }\n    else\n    {\n\t// pos is just a hint but can avoid a second search through the map\n\tstl_map.insert(pos, YCPMap::value_type(key, value));\n    }\n\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void\n  YCPMapRep::add (const YCPValue& key, const YCPValue& value)\n  {\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn;\n      }\n  \n      // Note: 'stl_map[key] = value' would create a temporary object using the\n      // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n      // 24.\n  \n      YCPMap::iterator pos = stl_map.lower_bound(key);\n      if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n      {\n  \tpos->second = value;\n      }\n      else\n      {\n  \t// pos is just a hint but can avoid a second search through the map\n  \tstl_map.insert(pos, YCPMap::value_type(key, value));\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "it->second"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "m.end",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m.begin",
          "args": [],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ModulesConf.h\"\n#include \"ModulesAgent.h\"\n#include \"Y2Logger.h\"\n\nYCPMap map2ycpmap(const T &m) {\n    YCPMap ret_map;\n    typename T::const_iterator it = m.begin ();\n\t\n    for (; it != m.end(); ++it)\n\tret_map->add (YCPString (it->first), YCPString (it->second));\n\t\n    return ret_map;\n}"
  },
  {
    "function_name": "map2list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesAgent.cc",
    "lines": "60-70",
    "snippet": "YCPList map2list(const T &m) {\n    YCPList list;\n    typename T::const_iterator it = m.begin ();\n\t\n    for (; it != m.end (); ++it)\n\t/* Preserve listing of the final comment */\n\tif(it->first != \"YaST2_final_modules_conf_comment\")\n\t    list->add(YCPString (it->first));\n\t\n    return list;\n}",
    "includes": [
      "#include \"ModulesConf.h\"",
      "#include \"ModulesAgent.h\"",
      "#include \"Y2Logger.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list->add",
          "args": [
            "YCPString (it->first)"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "it->first"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "m.end",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m.begin",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ModulesConf.h\"\n#include \"ModulesAgent.h\"\n#include \"Y2Logger.h\"\n\nYCPList map2list(const T &m) {\n    YCPList list;\n    typename T::const_iterator it = m.begin ();\n\t\n    for (; it != m.end (); ++it)\n\t/* Preserve listing of the final comment */\n\tif(it->first != \"YaST2_final_modules_conf_comment\")\n\t    list->add(YCPString (it->first));\n\t\n    return list;\n}"
  },
  {
    "function_name": "~ModulesAgent",
    "container": "ModulesAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesAgent.cc",
    "lines": "52-55",
    "snippet": "ModulesAgent::~ModulesAgent() {\n    if (modules_conf != NULL)\n\tdelete modules_conf;\n}",
    "includes": [
      "#include \"ModulesConf.h\"",
      "#include \"ModulesAgent.h\"",
      "#include \"Y2Logger.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ModulesConf.h\"\n#include \"ModulesAgent.h\"\n#include \"Y2Logger.h\"\n\nModulesAgent {\n  ModulesAgent::~ModulesAgent() {\n      if (modules_conf != NULL)\n  \tdelete modules_conf;\n  }\n}"
  },
  {
    "function_name": "ModulesAgent",
    "container": "ModulesAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesAgent.cc",
    "lines": "46-47",
    "snippet": "ModulesAgent::ModulesAgent() : SCRAgent(), modules_conf(NULL) {\n}",
    "includes": [
      "#include \"ModulesConf.h\"",
      "#include \"ModulesAgent.h\"",
      "#include \"Y2Logger.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ModulesConf.h\"\n#include \"ModulesAgent.h\"\n#include \"Y2Logger.h\"\n\nModulesAgent {\n  ModulesAgent::ModulesAgent() : SCRAgent(), modules_conf(NULL) {\n  }\n}"
  }
]