[
  {
    "function_name": "generateSysConfigTemplate",
    "container": "IniAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniAgent.cc",
    "lines": "183-242",
    "snippet": "YCPTerm IniAgent::generateSysConfigTemplate (string fn)\n{\n    YCPTerm t (string (\"IniAgent\"));\n    YCPMap m;\n    YCPList l;\n\n    // file name\n    t->add (YCPString (fn));\n\n    l->add (YCPString (\"flat\"));\n    l->add (YCPString (\"line_can_continue\"));\n    l->add (YCPString (\"global_values\"));\n    l->add (YCPString (\"join_multiline\"));\n    l->add (YCPString (\"comments_last\"));\n    m->add (YCPString (\"options\"), l);\n\n    // comments\n    l = YCPList ();\n    l->add (YCPString (\"^[ \\t]*#.*$\"));\n    l->add (YCPString (\"#.*\"));\n    l->add (YCPString (\"^[ \\t]*$\"));\n    m->add (YCPString (\"comments\"), l);\n\n    // sections are empty so we will omit them\n\n    // params\n    YCPMap param;\n    YCPList lp;\n    l = YCPList ();\n    lp->add (YCPString (\"([[:alnum:]_]+)[ \\t]*=[ \\t]*\\\"([^\\\"]*)\\\"\"));\n    lp->add (YCPString (\"%s=\\\"%s\\\"\"));\n    param->add (YCPString (\"match\"), lp);\n    lp = YCPList ();\n    lp->add (YCPString (\"([[:alnum:]_]+)[ \\t]*=[ \\t]*\\\"([^\\\"]*)\"));\n    lp->add (YCPString (\"([^\\\"]*)\\\"\"));\n    param->add (YCPString (\"multiline\"), lp);\n    l->add (param);\n\n    lp = YCPList ();\n    param = YCPMap ();\n    lp->add (YCPString (\"^[ \\t]*([[:alpha:]_][[:alnum:]_]*)[ \\t]*=[ \\t]*'([^']*)'\"));\n    lp->add (YCPString (\"%s='%s'\"));\n    param->add (YCPString (\"match\"), lp);\n    lp = YCPList ();\n    lp->add (YCPString (\"([[:alpha:]_][[:alnum:]_]*)[ \\t]*=[ \\t]*'([^']*)\"));\n    lp->add (YCPString (\"([^']*)'\"));\n    param->add (YCPString (\"multiline\"), lp);\n    l->add (param);\n\n    lp = YCPList ();\n    param = YCPMap ();\n    lp->add (YCPString (\"([[:alnum:]_]+)[ \\t]*=[ \\t]*([^\\\"]*[^ \\t\\\"]|)[ \\t]*$\"));\n    lp->add (YCPString (\"%s=\\\"%s\\\"\"));\n    param->add (YCPString (\"match\"), lp);\n    l->add (param);\n\n    m->add (YCPString (\"params\"), l);\n    t->add (m);\n    return t;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include \"IniAgent.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->add",
          "args": [
            "m"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "63-67",
          "snippet": "void\nYCPListRep::add (const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::add (const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->add",
          "args": [
            "YCPString (\"params\")",
            "l"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "50-76",
          "snippet": "void\nYCPMapRep::add (const YCPValue& key, const YCPValue& value)\n{\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn;\n    }\n\n    // Note: 'stl_map[key] = value' would create a temporary object using the\n    // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n    // 24.\n\n    YCPMap::iterator pos = stl_map.lower_bound(key);\n    if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n    {\n\tpos->second = value;\n    }\n    else\n    {\n\t// pos is just a hint but can avoid a second search through the map\n\tstl_map.insert(pos, YCPMap::value_type(key, value));\n    }\n\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void\n  YCPMapRep::add (const YCPValue& key, const YCPValue& value)\n  {\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn;\n      }\n  \n      // Note: 'stl_map[key] = value' would create a temporary object using the\n      // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n      // 24.\n  \n      YCPMap::iterator pos = stl_map.lower_bound(key);\n      if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n      {\n  \tpos->second = value;\n      }\n      else\n      {\n  \t// pos is just a hint but can avoid a second search through the map\n  \tstl_map.insert(pos, YCPMap::value_type(key, value));\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "\"params\""
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "l->add",
          "args": [
            "param"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPMap",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "219-223",
          "snippet": "YCPValueType\nYCPMapRep::valuetype() const\n{\n    return YT_MAP;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPValueType\n  YCPMapRep::valuetype() const\n  {\n      return YT_MAP;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPList",
          "args": [],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "commaList",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "254-265",
          "snippet": "string\nYCPListRep::commaList() const\n{\n    string ret;\n\n    for (unsigned index = 0; index < elements.size(); index++)\n    {\n\tif (index != 0) ret += \", \";\n\tret += elements[index].isNull() ? \"(null)\" : elements[index]->toString();\n    }\n    return ret;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  string\n  YCPListRep::commaList() const\n  {\n      string ret;\n  \n      for (unsigned index = 0; index < elements.size(); index++)\n      {\n  \tif (index != 0) ret += \", \";\n  \tret += elements[index].isNull() ? \"(null)\" : elements[index]->toString();\n      }\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"IniAgent\""
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include \"IniAgent.h\"\n\nIniAgent {\n  YCPTerm IniAgent::generateSysConfigTemplate (string fn)\n  {\n      YCPTerm t (string (\"IniAgent\"));\n      YCPMap m;\n      YCPList l;\n  \n      // file name\n      t->add (YCPString (fn));\n  \n      l->add (YCPString (\"flat\"));\n      l->add (YCPString (\"line_can_continue\"));\n      l->add (YCPString (\"global_values\"));\n      l->add (YCPString (\"join_multiline\"));\n      l->add (YCPString (\"comments_last\"));\n      m->add (YCPString (\"options\"), l);\n  \n      // comments\n      l = YCPList ();\n      l->add (YCPString (\"^[ \\t]*#.*$\"));\n      l->add (YCPString (\"#.*\"));\n      l->add (YCPString (\"^[ \\t]*$\"));\n      m->add (YCPString (\"comments\"), l);\n  \n      // sections are empty so we will omit them\n  \n      // params\n      YCPMap param;\n      YCPList lp;\n      l = YCPList ();\n      lp->add (YCPString (\"([[:alnum:]_]+)[ \\t]*=[ \\t]*\\\"([^\\\"]*)\\\"\"));\n      lp->add (YCPString (\"%s=\\\"%s\\\"\"));\n      param->add (YCPString (\"match\"), lp);\n      lp = YCPList ();\n      lp->add (YCPString (\"([[:alnum:]_]+)[ \\t]*=[ \\t]*\\\"([^\\\"]*)\"));\n      lp->add (YCPString (\"([^\\\"]*)\\\"\"));\n      param->add (YCPString (\"multiline\"), lp);\n      l->add (param);\n  \n      lp = YCPList ();\n      param = YCPMap ();\n      lp->add (YCPString (\"^[ \\t]*([[:alpha:]_][[:alnum:]_]*)[ \\t]*=[ \\t]*'([^']*)'\"));\n      lp->add (YCPString (\"%s='%s'\"));\n      param->add (YCPString (\"match\"), lp);\n      lp = YCPList ();\n      lp->add (YCPString (\"([[:alpha:]_][[:alnum:]_]*)[ \\t]*=[ \\t]*'([^']*)\"));\n      lp->add (YCPString (\"([^']*)'\"));\n      param->add (YCPString (\"multiline\"), lp);\n      l->add (param);\n  \n      lp = YCPList ();\n      param = YCPMap ();\n      lp->add (YCPString (\"([[:alnum:]_]+)[ \\t]*=[ \\t]*([^\\\"]*[^ \\t\\\"]|)[ \\t]*$\"));\n      lp->add (YCPString (\"%s=\\\"%s\\\"\"));\n      param->add (YCPString (\"match\"), lp);\n      l->add (param);\n  \n      m->add (YCPString (\"params\"), l);\n      t->add (m);\n      return t;\n  }\n}"
  },
  {
    "function_name": "otherCommand",
    "container": "IniAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniAgent.cc",
    "lines": "147-181",
    "snippet": "YCPValue IniAgent::otherCommand(const YCPTerm& term)\n{\n    string sym = term->name();\n    if (sym == \"SysConfigFile\") \n    {\n\tif (term->size () != 1 || !term->value (0)->isString ())\n\t{\n\t    return YCPError (\"Bad number of arguments. Expecting SysConfigFile (\\\"filename\\\")\");\n\t}\n\tstring file_name;\n\tfile_name = term->value(0)->asString()->value();\n\tYCPTerm tt = generateSysConfigTemplate (file_name);\n\treturn otherCommand (tt);\n    }\n    if (sym == \"IniAgent\") \n    {\n\tif (2 == term->size()) // fixme: we will provide some default actions if 2nd arg is missing in future\n\t{\n\t    if (!term->value(0)->isString () && !term->value(0)->isList ())\n\t        return YCPError (\"Bad initialization of IniFile(): first argument must be string or list of strings.\");\n\t    if (!term->value(1)->isMap())\n\t\treturn YCPError (\"Bad initialization of IniFile(): second argument is not map.\");\n\t    if (term->value (0)->isString ())\n\t\tparser.initFiles(term->value(0)->asString()->value().c_str());\n\t    else\n\t\tparser.initFiles(term->value(0)->asList());\n\t    parser.initMachine (term->value(1)->asMap());\n\t    parser.parse ();\n\t    return YCPVoid ();\n\t}\n\treturn YCPError (\"Bad initialization of IniFile(): 2 arguments expected.\");\n    }\n\n    return YCPNull ();\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include \"IniAgent.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "\"Bad initialization of IniFile(): 2 arguments expected.\""
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.parse",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "484-562",
          "snippet": "int IniParser::parse()\n{\n    if (multiple_files)\n    {\n\tglob_t do_files;\n\tint len = files.size ();\n\tint flags = 0;\n\tfor (int i = 0;i<len;i++)\n\t{\n\t    glob (files[i].c_str (),flags, NULL, &do_files);\n\t    flags = GLOB_APPEND;\n\t}\n\tchar**f = do_files.gl_pathv;\n\tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n\t{\n\t    int section_index = -1;\n\t    string section_name = *f;\n\t    //FIXME: create function out of it.\n\t    // do we have name rewrite rules?\n\t    for (size_t j = 0; j < rewrites.size (); j++)\n\t\t{\n\t\t    RegexMatch m (rewrites[j].rx, section_name);\n\t\t    if (m)\n\t\t    {\n\t\t\tsection_index = j;\n\t\t\tsection_name = m[1];\n\t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    // do we know about the file?\n\t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n\t    if (ff == multi_files.end())\n\t    {\n\t\t// new file\n\t\tif (scanner_start (*f))\n\t\t    y2error (\"Cannot open %s.\", *f);\n\t\telse\n\t\t{\n\t\t    FileDescr fdsc (*f);\n\t\t    multi_files[*f] = fdsc;\n\t\t    inifile.initSection (section_name, \"\", -1, section_index);\n\t\t    parse_helper(inifile.getSection(section_name.c_str()));\n\t\t    scanner_stop();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif ((*ff).second.changed ())\n\t\t{\n\t\t    if (scanner_start (*f))\n\t\t\ty2error (\"Cannot open %s.\", *f);\n\t\t    else\n\t\t    {\n\t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n\t\t\tFileDescr fdsc (*f);\n\t\t\tmulti_files [*f] = fdsc;\n\t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n\t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n\t\t\tscanner_stop();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tif (scanner_start (file.c_str()))\n\t    {\n\t\ty2error (\"Can not open %s.\", file.c_str());\n\t\treturn -1;\n\t    }\n\tparse_helper(inifile);\n\tscanner_stop();\n\ttimestamp = getTimeStamp ();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse()\n  {\n      if (multiple_files)\n      {\n  \tglob_t do_files;\n  \tint len = files.size ();\n  \tint flags = 0;\n  \tfor (int i = 0;i<len;i++)\n  \t{\n  \t    glob (files[i].c_str (),flags, NULL, &do_files);\n  \t    flags = GLOB_APPEND;\n  \t}\n  \tchar**f = do_files.gl_pathv;\n  \tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n  \t{\n  \t    int section_index = -1;\n  \t    string section_name = *f;\n  \t    //FIXME: create function out of it.\n  \t    // do we have name rewrite rules?\n  \t    for (size_t j = 0; j < rewrites.size (); j++)\n  \t\t{\n  \t\t    RegexMatch m (rewrites[j].rx, section_name);\n  \t\t    if (m)\n  \t\t    {\n  \t\t\tsection_index = j;\n  \t\t\tsection_name = m[1];\n  \t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \n  \t    // do we know about the file?\n  \t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n  \t    if (ff == multi_files.end())\n  \t    {\n  \t\t// new file\n  \t\tif (scanner_start (*f))\n  \t\t    y2error (\"Cannot open %s.\", *f);\n  \t\telse\n  \t\t{\n  \t\t    FileDescr fdsc (*f);\n  \t\t    multi_files[*f] = fdsc;\n  \t\t    inifile.initSection (section_name, \"\", -1, section_index);\n  \t\t    parse_helper(inifile.getSection(section_name.c_str()));\n  \t\t    scanner_stop();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif ((*ff).second.changed ())\n  \t\t{\n  \t\t    if (scanner_start (*f))\n  \t\t\ty2error (\"Cannot open %s.\", *f);\n  \t\t    else\n  \t\t    {\n  \t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n  \t\t\tFileDescr fdsc (*f);\n  \t\t\tmulti_files [*f] = fdsc;\n  \t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n  \t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n  \t\t\tscanner_stop();\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n      else\n      {\n  \tif (scanner_start (file.c_str()))\n  \t    {\n  \t\ty2error (\"Can not open %s.\", file.c_str());\n  \t\treturn -1;\n  \t    }\n  \tparse_helper(inifile);\n  \tscanner_stop();\n  \ttimestamp = getTimeStamp ();\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.initMachine",
          "args": [
            "term->value(1)->asMap()"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "initMachine",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "168-408",
          "snippet": "int IniParser::initMachine (const YCPMap&scr)\n{\n    started = true;\n\n    //\n    // now process the script\n    //\n    ignore_case_regexps = ignore_case = prefer_uppercase = first_upper = line_can_continue = no_nested_sections =\n\tglobal_values = repeat_names = comments_last = join_multiline =\n\tno_finalcomment_kill = read_only = flat = false;\n\n    // read the options\n    YCPValue v = scr->value(YCPString(\"options\"));\n    if (!v.isNull()) {\n\tif (!v->isList ())\n\t    y2error (\"'options' must be a list\");\n\telse {\n\t    int len = v->asList()->size();\n\t    for (int i = 0;i<len;i++)\n\t\t{\n\t\t    if (!v->asList()->value(i)->isString()) {\n\t\t\ty2error (\"items of 'options' must be strings\");\n\t\t\tcontinue;\n\t\t    }\n\t\t    string sv = v->asList()->value(i)->asString()->value();\n#define COMPARE_OPTION(X) if (sv == #X) X = true; else \n\t\t    COMPARE_OPTION (ignore_case_regexps)\n\t\t    COMPARE_OPTION (ignore_case)\n\t\t    COMPARE_OPTION (prefer_uppercase)\n\t\t    COMPARE_OPTION (first_upper)\n\t\t    COMPARE_OPTION (line_can_continue)\n\t\t    COMPARE_OPTION (no_nested_sections)\n\t\t    COMPARE_OPTION (global_values)\n\t\t    COMPARE_OPTION (repeat_names)\n\t\t    COMPARE_OPTION (comments_last)\n\t\t    COMPARE_OPTION (join_multiline)\n\t\t    COMPARE_OPTION (no_finalcomment_kill)\n\t\t    COMPARE_OPTION (read_only)\n\t\t    COMPARE_OPTION (flat)\n\t\t\ty2error (\"Option not implemented yet: %s\", sv.c_str());\n#undef  COMPARE_OPTION\n\t\t}\n\t}\n    }\n\n    if (ignore_case && multiple_files)\n    {\n       ycperror (\"When using multiple files, ignore_case does not work\");\n       ignore_case = false;\n    }\n\n    v = scr->value(YCPString(\"rewrite\"));\n    if (!v.isNull()) {\n\tif (!v->isList ())\n\t    y2error (\"'rewrite' must be a list\");\n\telse {\n\n\tint len = v->asList()->size();\n\trewrites.clear ();\n\trewrites.reserve (len);\n\tfor (int i = 0; i<len;i++)\n\t{\n\t    YCPValue ival = v->asList()->value(i);\n\t    if (ival->isList() && \n\t\t2 == ival->asList()->size() && \n\t\tival->asList()->value(0)->isString() &&\n\t\tival->asList()->value(1)->isString())\n\t    {\n\t\tIoPattern p;\n\t\tif (!p.rx.compile (ival->asList()->value(0)->asString()->value(), ignore_case_regexps))\n\t\t{\n\t\t    p.out = ival->asList()->value(1)->asString()->value();\n\t\t    rewrites.push_back (p);\n\t\t}\n\t    }\n\t    else\n\t\ty2error (\"items of 'rewrite' must be lists of two strings\");\n\t}\n\n\t}\n    }\n\n    v = scr->value(YCPString(\"subindent\"));\n    if (!v.isNull()) {\n\tif (!v->isString ())\n\t    y2error (\"'subindent' must be a string\");\n\telse\n\t    subindent = v->asString()->value();\n    }\n\n    // read comments\n    v = scr->value(YCPString(\"comments\"));\n    if (!v.isNull()) {\n\tif (!v->isList ())\n\t    y2error (\"'comments' must be a list\");\n\telse {\n\t    int len = v->asList()->size();\n\t    linecomments.clear ();\n\t    comments.clear ();\n\t    linecomments.reserve (len);\n\t    comments.reserve (len);\n\t    for (int i = 0;  i < len; i++)\n\t    {\n\t\tif (!v->asList()->value(i)->isString()) {\n\t\t    y2error (\"items of 'comments' must be strings\");\n\t\t    continue;\n\t\t}\n\t\tYCPString s = v->asList()->value(i)->asString();\n\t\tvector <Regex> & regexes = ('^' == s->value_cstr()[0]) ?\n\t\t    linecomments : comments;\n\t\tRegex r;\n\t\tif (!r.compile (s->value (), ignore_case_regexps))\n\t\t{\n\t\t    regexes.push_back (r);\n\t\t}\n\t    }\n\t}\n    }\n\n    // read sections\n    v = scr->value(YCPString(\"sections\"));\n    if (!v.isNull()) {\n\tif (!v->isList ())\n\t    y2error (\"'sections' must be a list\");\n\telse {\n\t    int len = v->asList()->size();\n\t    // compile them to regex_t\n\t    sections.clear ();\n\t    sections.reserve (len);\n\t    for (int i = 0;  i < len; i++)\n\t\t{\n\t\t    if (!v->asList()->value(i)->isMap())\n\t\t\ty2error (\"items of 'sections' must be maps\");\n\t\t    else\n\t\t\t{\n\t\t\t    section s;\n\t\t\t    YCPMap m = v->asList()->value(i)->asMap ();\n\t\t\t    s.end_valid = false;\n\t\t\t    YCPList p;\n\t\t\t    switch (getBeginEndType (m))\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t    p = m->value(YCPString(\"end\"))->asList();\n\t\t\t\t    if (s.end.rx.compile (\n\t\t\t\t\t    p->value(0)->asString()->value (),\n\t\t\t\t\t    ignore_case_regexps))\n\t\t\t\t\tbreak;\n\t\t\t\t    s.end.out =\n\t\t\t\t\tp->value(1)->asString()->value ();\n\t\t\t\t    s.end_valid = true;\n\t\t\t\t    // Fall through\n\t\t\t\tcase 1:\n\t\t\t\t    p = m->value(YCPString(\"begin\"))->asList();\n\t\t\t\t    if (s.begin.rx.compile (\n\t\t\t\t\t    p->value(0)->asString()->value (),\n\t\t\t\t\t    ignore_case_regexps))\n\t\t\t\t\t{\n\t\t\t\t\t    // compile failed\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t    s.begin.out =\n\t\t\t\t\tp->value(1)->asString()->value ();\n\t\t\t\t    sections.push_back (s);\n\t\t\t\t    break;\n\t\t\t\tcase -1:\n\t\t\t\tdefault:\n\t\t\t\t    y2error (\"Bad format of %dth section map\", i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    }\n\n    // read parameters\n    v = scr->value(YCPString(\"params\"));\n    if (!v.isNull()) {\n\tif (!v->isList ())\n\t    y2error (\"'params' must be a list\");\n\telse {\n\t    int len = v->asList()->size();\n\t    // compile them to regex_t\n\t    params.clear ();\n\t    params.reserve (len);\n\t    for (int i = 0; i < len; i++)\n\t\t{\n\t\t    if (!v->asList()->value(i)->isMap())\n\t\t\ty2error (\"items of 'params' must be maps\");\n\t\t    else\n\t\t\t{\n\t\t\t    YCPMap m = v->asList()->value(i)->asMap ();\n\t\t\t    param pa;\n\t\t\t    pa.multiline_valid = false;\n\t\t\t    YCPList p;\n\t\t\t    switch (getParamsType (m))\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t    p = m->value(YCPString(\"multiline\"))->asList();\n\t\t\t\t    if (!pa.begin.compile (\n\t\t\t\t\t    p->value(0)->asString()->value (),\n\t\t\t\t\t    ignore_case_regexps))\n\t\t\t\t\tif (!pa.end.compile (\n\t\t\t\t\t\tp->value(1)->asString()->value (),\n\t\t\t\t\t\tignore_case_regexps))\n\t\t\t\t\t    {\n\t\t\t\t\t\tpa.multiline_valid = true;\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t    y2error (\"Bad regexp(multiline): %s\",\n\t\t\t\t\t\tp->value(1)->asString()->value_cstr());\n\t\t\t\t\t}\n\t\t\t\t    else\n\t\t\t\t\t  y2error (\"Bad regexp(multiline): %s\",\n\t\t\t\t\t      p->value(0)->asString()->value_cstr());\n\t\t\t\tcase 1:\n\t\t\t\t    p = m->value(YCPString(\"match\"))->asList();\n\t\t\t\t    if (pa.line.rx.compile (\n\t\t\t\t\t    p->value(0)->asString()->value (),\n\t\t\t\t\t    ignore_case_regexps))\n\t\t\t\t    {\n\t\t\t\t\tif (pa.multiline_valid)\n\t\t\t\t\t{\n\t\t\t\t\t    y2error (\"Bad regexp(match): %s\",\n\t\t\t\t\t\tp->value(0)->asString()->value_cstr());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t    }\n\t\t\t\t    pa.line.out =\n\t\t\t\t\tp->value(1)->asString()->value ();\n\t\t\t\t    params.push_back (pa);\n\t\t\t\t    break;\n\t\t\t\tcase -1:\n\t\t\t\tdefault:\n\t\t\t\t    y2error (\"Bad format of %dth param map\", i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::initMachine (const YCPMap&scr)\n  {\n      started = true;\n  \n      //\n      // now process the script\n      //\n      ignore_case_regexps = ignore_case = prefer_uppercase = first_upper = line_can_continue = no_nested_sections =\n  \tglobal_values = repeat_names = comments_last = join_multiline =\n  \tno_finalcomment_kill = read_only = flat = false;\n  \n      // read the options\n      YCPValue v = scr->value(YCPString(\"options\"));\n      if (!v.isNull()) {\n  \tif (!v->isList ())\n  \t    y2error (\"'options' must be a list\");\n  \telse {\n  \t    int len = v->asList()->size();\n  \t    for (int i = 0;i<len;i++)\n  \t\t{\n  \t\t    if (!v->asList()->value(i)->isString()) {\n  \t\t\ty2error (\"items of 'options' must be strings\");\n  \t\t\tcontinue;\n  \t\t    }\n  \t\t    string sv = v->asList()->value(i)->asString()->value();\n  #define COMPARE_OPTION(X) if (sv == #X) X = true; else \n  \t\t    COMPARE_OPTION (ignore_case_regexps)\n  \t\t    COMPARE_OPTION (ignore_case)\n  \t\t    COMPARE_OPTION (prefer_uppercase)\n  \t\t    COMPARE_OPTION (first_upper)\n  \t\t    COMPARE_OPTION (line_can_continue)\n  \t\t    COMPARE_OPTION (no_nested_sections)\n  \t\t    COMPARE_OPTION (global_values)\n  \t\t    COMPARE_OPTION (repeat_names)\n  \t\t    COMPARE_OPTION (comments_last)\n  \t\t    COMPARE_OPTION (join_multiline)\n  \t\t    COMPARE_OPTION (no_finalcomment_kill)\n  \t\t    COMPARE_OPTION (read_only)\n  \t\t    COMPARE_OPTION (flat)\n  \t\t\ty2error (\"Option not implemented yet: %s\", sv.c_str());\n  #undef  COMPARE_OPTION\n  \t\t}\n  \t}\n      }\n  \n      if (ignore_case && multiple_files)\n      {\n         ycperror (\"When using multiple files, ignore_case does not work\");\n         ignore_case = false;\n      }\n  \n      v = scr->value(YCPString(\"rewrite\"));\n      if (!v.isNull()) {\n  \tif (!v->isList ())\n  \t    y2error (\"'rewrite' must be a list\");\n  \telse {\n  \n  \tint len = v->asList()->size();\n  \trewrites.clear ();\n  \trewrites.reserve (len);\n  \tfor (int i = 0; i<len;i++)\n  \t{\n  \t    YCPValue ival = v->asList()->value(i);\n  \t    if (ival->isList() && \n  \t\t2 == ival->asList()->size() && \n  \t\tival->asList()->value(0)->isString() &&\n  \t\tival->asList()->value(1)->isString())\n  \t    {\n  \t\tIoPattern p;\n  \t\tif (!p.rx.compile (ival->asList()->value(0)->asString()->value(), ignore_case_regexps))\n  \t\t{\n  \t\t    p.out = ival->asList()->value(1)->asString()->value();\n  \t\t    rewrites.push_back (p);\n  \t\t}\n  \t    }\n  \t    else\n  \t\ty2error (\"items of 'rewrite' must be lists of two strings\");\n  \t}\n  \n  \t}\n      }\n  \n      v = scr->value(YCPString(\"subindent\"));\n      if (!v.isNull()) {\n  \tif (!v->isString ())\n  \t    y2error (\"'subindent' must be a string\");\n  \telse\n  \t    subindent = v->asString()->value();\n      }\n  \n      // read comments\n      v = scr->value(YCPString(\"comments\"));\n      if (!v.isNull()) {\n  \tif (!v->isList ())\n  \t    y2error (\"'comments' must be a list\");\n  \telse {\n  \t    int len = v->asList()->size();\n  \t    linecomments.clear ();\n  \t    comments.clear ();\n  \t    linecomments.reserve (len);\n  \t    comments.reserve (len);\n  \t    for (int i = 0;  i < len; i++)\n  \t    {\n  \t\tif (!v->asList()->value(i)->isString()) {\n  \t\t    y2error (\"items of 'comments' must be strings\");\n  \t\t    continue;\n  \t\t}\n  \t\tYCPString s = v->asList()->value(i)->asString();\n  \t\tvector <Regex> & regexes = ('^' == s->value_cstr()[0]) ?\n  \t\t    linecomments : comments;\n  \t\tRegex r;\n  \t\tif (!r.compile (s->value (), ignore_case_regexps))\n  \t\t{\n  \t\t    regexes.push_back (r);\n  \t\t}\n  \t    }\n  \t}\n      }\n  \n      // read sections\n      v = scr->value(YCPString(\"sections\"));\n      if (!v.isNull()) {\n  \tif (!v->isList ())\n  \t    y2error (\"'sections' must be a list\");\n  \telse {\n  \t    int len = v->asList()->size();\n  \t    // compile them to regex_t\n  \t    sections.clear ();\n  \t    sections.reserve (len);\n  \t    for (int i = 0;  i < len; i++)\n  \t\t{\n  \t\t    if (!v->asList()->value(i)->isMap())\n  \t\t\ty2error (\"items of 'sections' must be maps\");\n  \t\t    else\n  \t\t\t{\n  \t\t\t    section s;\n  \t\t\t    YCPMap m = v->asList()->value(i)->asMap ();\n  \t\t\t    s.end_valid = false;\n  \t\t\t    YCPList p;\n  \t\t\t    switch (getBeginEndType (m))\n  \t\t\t\t{\n  \t\t\t\tcase 0:\n  \t\t\t\t    p = m->value(YCPString(\"end\"))->asList();\n  \t\t\t\t    if (s.end.rx.compile (\n  \t\t\t\t\t    p->value(0)->asString()->value (),\n  \t\t\t\t\t    ignore_case_regexps))\n  \t\t\t\t\tbreak;\n  \t\t\t\t    s.end.out =\n  \t\t\t\t\tp->value(1)->asString()->value ();\n  \t\t\t\t    s.end_valid = true;\n  \t\t\t\t    // Fall through\n  \t\t\t\tcase 1:\n  \t\t\t\t    p = m->value(YCPString(\"begin\"))->asList();\n  \t\t\t\t    if (s.begin.rx.compile (\n  \t\t\t\t\t    p->value(0)->asString()->value (),\n  \t\t\t\t\t    ignore_case_regexps))\n  \t\t\t\t\t{\n  \t\t\t\t\t    // compile failed\n  \t\t\t\t\t    break;\n  \t\t\t\t\t}\n  \t\t\t\t    s.begin.out =\n  \t\t\t\t\tp->value(1)->asString()->value ();\n  \t\t\t\t    sections.push_back (s);\n  \t\t\t\t    break;\n  \t\t\t\tcase -1:\n  \t\t\t\tdefault:\n  \t\t\t\t    y2error (\"Bad format of %dth section map\", i);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n      }\n  \n      // read parameters\n      v = scr->value(YCPString(\"params\"));\n      if (!v.isNull()) {\n  \tif (!v->isList ())\n  \t    y2error (\"'params' must be a list\");\n  \telse {\n  \t    int len = v->asList()->size();\n  \t    // compile them to regex_t\n  \t    params.clear ();\n  \t    params.reserve (len);\n  \t    for (int i = 0; i < len; i++)\n  \t\t{\n  \t\t    if (!v->asList()->value(i)->isMap())\n  \t\t\ty2error (\"items of 'params' must be maps\");\n  \t\t    else\n  \t\t\t{\n  \t\t\t    YCPMap m = v->asList()->value(i)->asMap ();\n  \t\t\t    param pa;\n  \t\t\t    pa.multiline_valid = false;\n  \t\t\t    YCPList p;\n  \t\t\t    switch (getParamsType (m))\n  \t\t\t\t{\n  \t\t\t\tcase 0:\n  \t\t\t\t    p = m->value(YCPString(\"multiline\"))->asList();\n  \t\t\t\t    if (!pa.begin.compile (\n  \t\t\t\t\t    p->value(0)->asString()->value (),\n  \t\t\t\t\t    ignore_case_regexps))\n  \t\t\t\t\tif (!pa.end.compile (\n  \t\t\t\t\t\tp->value(1)->asString()->value (),\n  \t\t\t\t\t\tignore_case_regexps))\n  \t\t\t\t\t    {\n  \t\t\t\t\t\tpa.multiline_valid = true;\n  \t\t\t\t\t    }\n  \t\t\t\t\telse\n  \t\t\t\t\t{\n  \t\t\t\t\t    y2error (\"Bad regexp(multiline): %s\",\n  \t\t\t\t\t\tp->value(1)->asString()->value_cstr());\n  \t\t\t\t\t}\n  \t\t\t\t    else\n  \t\t\t\t\t  y2error (\"Bad regexp(multiline): %s\",\n  \t\t\t\t\t      p->value(0)->asString()->value_cstr());\n  \t\t\t\tcase 1:\n  \t\t\t\t    p = m->value(YCPString(\"match\"))->asList();\n  \t\t\t\t    if (pa.line.rx.compile (\n  \t\t\t\t\t    p->value(0)->asString()->value (),\n  \t\t\t\t\t    ignore_case_regexps))\n  \t\t\t\t    {\n  \t\t\t\t\tif (pa.multiline_valid)\n  \t\t\t\t\t{\n  \t\t\t\t\t    y2error (\"Bad regexp(match): %s\",\n  \t\t\t\t\t\tp->value(0)->asString()->value_cstr());\n  \t\t\t\t\t}\n  \t\t\t\t\tbreak;\n  \t\t\t\t    }\n  \t\t\t\t    pa.line.out =\n  \t\t\t\t\tp->value(1)->asString()->value ();\n  \t\t\t\t    params.push_back (pa);\n  \t\t\t\t    break;\n  \t\t\t\tcase -1:\n  \t\t\t\tdefault:\n  \t\t\t\t    y2error (\"Bad format of %dth param map\", i);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->value",
          "args": [],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->value",
          "args": [
            "1"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.initFiles",
          "args": [
            "term->value(0)->asList()"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "initFiles",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "163-167",
          "snippet": "void IniParser::initFiles (const char*fn)\n{\n    file = fn;\n    multiple_files = false;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  void IniParser::initFiles (const char*fn)\n  {\n      file = fn;\n      multiple_files = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "\"Bad initialization of IniFile(): second argument is not map.\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "\"Bad initialization of IniFile(): first argument must be string or list of strings.\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term->size",
          "args": [],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "otherCommand",
          "args": [
            "tt"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "otherCommand",
          "container": "IniAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniAgent.cc",
          "lines": "147-181",
          "snippet": "YCPValue IniAgent::otherCommand(const YCPTerm& term)\n{\n    string sym = term->name();\n    if (sym == \"SysConfigFile\") \n    {\n\tif (term->size () != 1 || !term->value (0)->isString ())\n\t{\n\t    return YCPError (\"Bad number of arguments. Expecting SysConfigFile (\\\"filename\\\")\");\n\t}\n\tstring file_name;\n\tfile_name = term->value(0)->asString()->value();\n\tYCPTerm tt = generateSysConfigTemplate (file_name);\n\treturn otherCommand (tt);\n    }\n    if (sym == \"IniAgent\") \n    {\n\tif (2 == term->size()) // fixme: we will provide some default actions if 2nd arg is missing in future\n\t{\n\t    if (!term->value(0)->isString () && !term->value(0)->isList ())\n\t        return YCPError (\"Bad initialization of IniFile(): first argument must be string or list of strings.\");\n\t    if (!term->value(1)->isMap())\n\t\treturn YCPError (\"Bad initialization of IniFile(): second argument is not map.\");\n\t    if (term->value (0)->isString ())\n\t\tparser.initFiles(term->value(0)->asString()->value().c_str());\n\t    else\n\t\tparser.initFiles(term->value(0)->asList());\n\t    parser.initMachine (term->value(1)->asMap());\n\t    parser.parse ();\n\t    return YCPVoid ();\n\t}\n\treturn YCPError (\"Bad initialization of IniFile(): 2 arguments expected.\");\n    }\n\n    return YCPNull ();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "generateSysConfigTemplate",
          "args": [
            "file_name"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "generateSysConfigTemplate",
          "container": "IniAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniAgent.cc",
          "lines": "183-242",
          "snippet": "YCPTerm IniAgent::generateSysConfigTemplate (string fn)\n{\n    YCPTerm t (string (\"IniAgent\"));\n    YCPMap m;\n    YCPList l;\n\n    // file name\n    t->add (YCPString (fn));\n\n    l->add (YCPString (\"flat\"));\n    l->add (YCPString (\"line_can_continue\"));\n    l->add (YCPString (\"global_values\"));\n    l->add (YCPString (\"join_multiline\"));\n    l->add (YCPString (\"comments_last\"));\n    m->add (YCPString (\"options\"), l);\n\n    // comments\n    l = YCPList ();\n    l->add (YCPString (\"^[ \\t]*#.*$\"));\n    l->add (YCPString (\"#.*\"));\n    l->add (YCPString (\"^[ \\t]*$\"));\n    m->add (YCPString (\"comments\"), l);\n\n    // sections are empty so we will omit them\n\n    // params\n    YCPMap param;\n    YCPList lp;\n    l = YCPList ();\n    lp->add (YCPString (\"([[:alnum:]_]+)[ \\t]*=[ \\t]*\\\"([^\\\"]*)\\\"\"));\n    lp->add (YCPString (\"%s=\\\"%s\\\"\"));\n    param->add (YCPString (\"match\"), lp);\n    lp = YCPList ();\n    lp->add (YCPString (\"([[:alnum:]_]+)[ \\t]*=[ \\t]*\\\"([^\\\"]*)\"));\n    lp->add (YCPString (\"([^\\\"]*)\\\"\"));\n    param->add (YCPString (\"multiline\"), lp);\n    l->add (param);\n\n    lp = YCPList ();\n    param = YCPMap ();\n    lp->add (YCPString (\"^[ \\t]*([[:alpha:]_][[:alnum:]_]*)[ \\t]*=[ \\t]*'([^']*)'\"));\n    lp->add (YCPString (\"%s='%s'\"));\n    param->add (YCPString (\"match\"), lp);\n    lp = YCPList ();\n    lp->add (YCPString (\"([[:alpha:]_][[:alnum:]_]*)[ \\t]*=[ \\t]*'([^']*)\"));\n    lp->add (YCPString (\"([^']*)'\"));\n    param->add (YCPString (\"multiline\"), lp);\n    l->add (param);\n\n    lp = YCPList ();\n    param = YCPMap ();\n    lp->add (YCPString (\"([[:alnum:]_]+)[ \\t]*=[ \\t]*([^\\\"]*[^ \\t\\\"]|)[ \\t]*$\"));\n    lp->add (YCPString (\"%s=\\\"%s\\\"\"));\n    param->add (YCPString (\"match\"), lp);\n    l->add (param);\n\n    m->add (YCPString (\"params\"), l);\n    t->add (m);\n    return t;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include \"IniAgent.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include \"IniAgent.h\"\n\nIniAgent {\n  YCPTerm IniAgent::generateSysConfigTemplate (string fn)\n  {\n      YCPTerm t (string (\"IniAgent\"));\n      YCPMap m;\n      YCPList l;\n  \n      // file name\n      t->add (YCPString (fn));\n  \n      l->add (YCPString (\"flat\"));\n      l->add (YCPString (\"line_can_continue\"));\n      l->add (YCPString (\"global_values\"));\n      l->add (YCPString (\"join_multiline\"));\n      l->add (YCPString (\"comments_last\"));\n      m->add (YCPString (\"options\"), l);\n  \n      // comments\n      l = YCPList ();\n      l->add (YCPString (\"^[ \\t]*#.*$\"));\n      l->add (YCPString (\"#.*\"));\n      l->add (YCPString (\"^[ \\t]*$\"));\n      m->add (YCPString (\"comments\"), l);\n  \n      // sections are empty so we will omit them\n  \n      // params\n      YCPMap param;\n      YCPList lp;\n      l = YCPList ();\n      lp->add (YCPString (\"([[:alnum:]_]+)[ \\t]*=[ \\t]*\\\"([^\\\"]*)\\\"\"));\n      lp->add (YCPString (\"%s=\\\"%s\\\"\"));\n      param->add (YCPString (\"match\"), lp);\n      lp = YCPList ();\n      lp->add (YCPString (\"([[:alnum:]_]+)[ \\t]*=[ \\t]*\\\"([^\\\"]*)\"));\n      lp->add (YCPString (\"([^\\\"]*)\\\"\"));\n      param->add (YCPString (\"multiline\"), lp);\n      l->add (param);\n  \n      lp = YCPList ();\n      param = YCPMap ();\n      lp->add (YCPString (\"^[ \\t]*([[:alpha:]_][[:alnum:]_]*)[ \\t]*=[ \\t]*'([^']*)'\"));\n      lp->add (YCPString (\"%s='%s'\"));\n      param->add (YCPString (\"match\"), lp);\n      lp = YCPList ();\n      lp->add (YCPString (\"([[:alpha:]_][[:alnum:]_]*)[ \\t]*=[ \\t]*'([^']*)\"));\n      lp->add (YCPString (\"([^']*)'\"));\n      param->add (YCPString (\"multiline\"), lp);\n      l->add (param);\n  \n      lp = YCPList ();\n      param = YCPMap ();\n      lp->add (YCPString (\"([[:alnum:]_]+)[ \\t]*=[ \\t]*([^\\\"]*[^ \\t\\\"]|)[ \\t]*$\"));\n      lp->add (YCPString (\"%s=\\\"%s\\\"\"));\n      param->add (YCPString (\"match\"), lp);\n      l->add (param);\n  \n      m->add (YCPString (\"params\"), l);\n      t->add (m);\n      return t;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "\"Bad number of arguments. Expecting SysConfigFile (\\\"filename\\\")\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term->name",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2IniAgentComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/Y2IniAgentComponent.cc",
          "lines": "40-44",
          "snippet": "string\nY2IniAgentComponent::name() const\n{\n    return \"ag_ini\";\n}",
          "includes": [
            "#include \"IniAgent.h\"",
            "#include <scr/SCRInterpreter.h>",
            "#include \"Y2IniAgentComponent.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniAgent.h\"\n#include <scr/SCRInterpreter.h>\n#include \"Y2IniAgentComponent.h\"\n\nY2IniAgentComponent {\n  string\n  Y2IniAgentComponent::name() const\n  {\n      return \"ag_ini\";\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include \"IniAgent.h\"\n\nIniAgent {\n  YCPValue IniAgent::otherCommand(const YCPTerm& term)\n  {\n      string sym = term->name();\n      if (sym == \"SysConfigFile\") \n      {\n  \tif (term->size () != 1 || !term->value (0)->isString ())\n  \t{\n  \t    return YCPError (\"Bad number of arguments. Expecting SysConfigFile (\\\"filename\\\")\");\n  \t}\n  \tstring file_name;\n  \tfile_name = term->value(0)->asString()->value();\n  \tYCPTerm tt = generateSysConfigTemplate (file_name);\n  \treturn otherCommand (tt);\n      }\n      if (sym == \"IniAgent\") \n      {\n  \tif (2 == term->size()) // fixme: we will provide some default actions if 2nd arg is missing in future\n  \t{\n  \t    if (!term->value(0)->isString () && !term->value(0)->isList ())\n  \t        return YCPError (\"Bad initialization of IniFile(): first argument must be string or list of strings.\");\n  \t    if (!term->value(1)->isMap())\n  \t\treturn YCPError (\"Bad initialization of IniFile(): second argument is not map.\");\n  \t    if (term->value (0)->isString ())\n  \t\tparser.initFiles(term->value(0)->asString()->value().c_str());\n  \t    else\n  \t\tparser.initFiles(term->value(0)->asList());\n  \t    parser.initMachine (term->value(1)->asMap());\n  \t    parser.parse ();\n  \t    return YCPVoid ();\n  \t}\n  \treturn YCPError (\"Bad initialization of IniFile(): 2 arguments expected.\");\n      }\n  \n      return YCPNull ();\n  }\n}"
  },
  {
    "function_name": "Write",
    "container": "IniAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniAgent.cc",
    "lines": "75-142",
    "snippet": "YCPBoolean IniAgent::Write(const YCPPath &path, const YCPValue& value, const YCPValue& arg)\n{\n    if (!parser.isStarted())\n    {\n\ty2warning(\"Can't execute Write before being mounted.\");\n\treturn YCPBoolean (false);\n    }\n    // no need to update if modified, we are changing value\n\n    bool ok = false; // is the _path_ ok?\n    // return value\n    YCPBoolean b (true);\n\n    if (0 == path->length ())\n    {\n\tif (value->isString() && value->asString()->value() == \"force\")\n\t    parser.inifile.setDirty();\n\telse if (value->isString () && value->asString()->value() == \"clean\")\n\t    parser.inifile.clean ();\n\tif (0 != parser.write ())\n\t    b = false;\n\tok = true;\n    }\n    else\n    {\n\tif (( parser.repeatNames () && value->isList ()) ||\n\t    (!parser.repeatNames () &&  (value->isString () || value->isInteger())) ||\n\t    path->component_str(0) == \"all\"\n\t    )\n\t    {\n\t\tok = true;\n\t\tif (parser.inifile.Write (path, value, parser.HaveRewrites ()))\n\t\t    b = false;\n\t    }\n        else if (value->isVoid ())\n\t    {\n\t\tint wb  = -1;\n\t\tstring del_sec = \"\";\n\t\tok = true;\n\t\tif (2 == path->length ())\n\t\t{\n\t\t    string pc = path->component_str(0);\n\t\t    if (\"s\" == pc || \"section\" == pc)\n\t\t    {\t// request to delete section. Find the file name\n\t\t\tdel_sec = path->component_str (1);\n\t\t\twb = parser.inifile.getSubSectionRewriteBy (del_sec.c_str());\n\t\t    }\n\t\t}\n\t\tif (parser.inifile.Delete (path))\n\t\t    b = false;\n\t\telse if (del_sec != \"\")\n\t\t{\n\t\t    parser.deleted_sections.insert (parser.getFileName (del_sec, wb));\n\t\t}\n\t    }\n\telse\n\t{\n\t    ycp2error (\"Wrong value for path %s: %s\", path->toString ().c_str (), value->toString ().c_str ());\n\t    b = false;\n\t}\n    }\n    if (!ok)\n    {\n    \tycp2error ( \"Wrong path '%s' in Write().\", path->toString().c_str () );\n    }\n\n    return b;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include \"IniAgent.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Wrong path '%s' in Write().\"",
            "path->toString().c_str ()"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->toString",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Wrong value for path %s: %s\"",
            "path->toString ().c_str ()",
            "value->toString ().c_str ()"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser.deleted_sections.insert",
          "args": [
            "parser.getFileName (del_sec, wb)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser.getFileName",
          "args": [
            "del_sec",
            "wb"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "getFileName",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "1078-1091",
          "snippet": "string IniParser::getFileName (const string&sec, int rb) const\n{\n    string file = sec;\n    if (-1 != rb && (int) rewrites.size () > rb)\n    {\n\tint max = rewrites[rb].out.length () + sec.length () + 1;\n\tchar*buf = new char[max + 1];\n\tsnprintf (buf, max, rewrites[rb].out.c_str (), sec.c_str());\n\ty2debug (\"Rewriting %s to %s\", sec.c_str(), buf);\n\tfile = buf;\n\tdelete [] buf;\n    }\n    return file;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  string IniParser::getFileName (const string&sec, int rb) const\n  {\n      string file = sec;\n      if (-1 != rb && (int) rewrites.size () > rb)\n      {\n  \tint max = rewrites[rb].out.length () + sec.length () + 1;\n  \tchar*buf = new char[max + 1];\n  \tsnprintf (buf, max, rewrites[rb].out.c_str (), sec.c_str());\n  \ty2debug (\"Rewriting %s to %s\", sec.c_str(), buf);\n  \tfile = buf;\n  \tdelete [] buf;\n      }\n      return file;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.inifile.Delete",
          "args": [
            "path"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "Delete",
          "container": "IniSection",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "446-461",
          "snippet": "int IniSection::Delete (const YCPPath&p)\n{\n    if (ip->isFlat ())\n\treturn delValueFlat (p);\n    if (p->length() < 2)\n    {\n\ty2error (\"I do not know what to delete at %s.\", p->toString().c_str());\n\treturn -1;\n    }\n    string s = p->component_str (0);\n    if (s == \"v\" || s == \"value\")\n\treturn delValue (p, 1);\n    if (s == \"s\" || s == \"section\")\n      return delSection (p, 1);\n    return -1;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nIniSection {\n  int IniSection::Delete (const YCPPath&p)\n  {\n      if (ip->isFlat ())\n  \treturn delValueFlat (p);\n      if (p->length() < 2)\n      {\n  \ty2error (\"I do not know what to delete at %s.\", p->toString().c_str());\n  \treturn -1;\n      }\n      string s = p->component_str (0);\n      if (s == \"v\" || s == \"value\")\n  \treturn delValue (p, 1);\n      if (s == \"s\" || s == \"section\")\n        return delSection (p, 1);\n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.inifile.getSubSectionRewriteBy",
          "args": [
            "del_sec.c_str()"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "getSubSectionRewriteBy",
          "container": "IniSection",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "1131-1142",
          "snippet": "int IniSection::getSubSectionRewriteBy (const char*name)\n{\n    pair <IniSectionIdxIterator, IniSectionIdxIterator> r =\n\tisections.equal_range (name);\n    IniSectionIdxIterator xi = r.first, xe = r.second;\n\n    if (xi == xe)\n    {\n\treturn -1;\n    }\n    return (--xe)->second->s ().getRewriteBy ();\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nIniSection {\n  int IniSection::getSubSectionRewriteBy (const char*name)\n  {\n      pair <IniSectionIdxIterator, IniSectionIdxIterator> r =\n  \tisections.equal_range (name);\n      IniSectionIdxIterator xi = r.first, xe = r.second;\n  \n      if (xi == xe)\n      {\n  \treturn -1;\n      }\n      return (--xe)->second->s ().getRewriteBy ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_sec.c_str",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [
            "1"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "component_str",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "161-165",
          "snippet": "string\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  string\n  YCPPathRep::component_str(long index) const\n  {\n      return components[index].component.asString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "path->length",
          "args": [],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->isVoid",
          "args": [],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.inifile.Write",
          "args": [
            "path",
            "value",
            "parser.HaveRewrites ()"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "IniAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniAgent.cc",
          "lines": "75-142",
          "snippet": "YCPBoolean IniAgent::Write(const YCPPath &path, const YCPValue& value, const YCPValue& arg)\n{\n    if (!parser.isStarted())\n    {\n\ty2warning(\"Can't execute Write before being mounted.\");\n\treturn YCPBoolean (false);\n    }\n    // no need to update if modified, we are changing value\n\n    bool ok = false; // is the _path_ ok?\n    // return value\n    YCPBoolean b (true);\n\n    if (0 == path->length ())\n    {\n\tif (value->isString() && value->asString()->value() == \"force\")\n\t    parser.inifile.setDirty();\n\telse if (value->isString () && value->asString()->value() == \"clean\")\n\t    parser.inifile.clean ();\n\tif (0 != parser.write ())\n\t    b = false;\n\tok = true;\n    }\n    else\n    {\n\tif (( parser.repeatNames () && value->isList ()) ||\n\t    (!parser.repeatNames () &&  (value->isString () || value->isInteger())) ||\n\t    path->component_str(0) == \"all\"\n\t    )\n\t    {\n\t\tok = true;\n\t\tif (parser.inifile.Write (path, value, parser.HaveRewrites ()))\n\t\t    b = false;\n\t    }\n        else if (value->isVoid ())\n\t    {\n\t\tint wb  = -1;\n\t\tstring del_sec = \"\";\n\t\tok = true;\n\t\tif (2 == path->length ())\n\t\t{\n\t\t    string pc = path->component_str(0);\n\t\t    if (\"s\" == pc || \"section\" == pc)\n\t\t    {\t// request to delete section. Find the file name\n\t\t\tdel_sec = path->component_str (1);\n\t\t\twb = parser.inifile.getSubSectionRewriteBy (del_sec.c_str());\n\t\t    }\n\t\t}\n\t\tif (parser.inifile.Delete (path))\n\t\t    b = false;\n\t\telse if (del_sec != \"\")\n\t\t{\n\t\t    parser.deleted_sections.insert (parser.getFileName (del_sec, wb));\n\t\t}\n\t    }\n\telse\n\t{\n\t    ycp2error (\"Wrong value for path %s: %s\", path->toString ().c_str (), value->toString ().c_str ());\n\t    b = false;\n\t}\n    }\n    if (!ok)\n    {\n    \tycp2error ( \"Wrong path '%s' in Write().\", path->toString().c_str () );\n    }\n\n    return b;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "parser.HaveRewrites",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "HaveRewrites",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.h",
          "lines": "455-455",
          "snippet": "bool HaveRewrites () const { return rewrites.size () > 0; }",
          "includes": [
            "#include \"IniFile.h\"",
            "#include <set>",
            "#include <vector>",
            "#include <string>",
            "#include <fstream>",
            "#include <iosfwd>",
            "#include <YCP.h>",
            "#include <y2util/RepDef.h>",
            "#include <locale.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include <set>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <iosfwd>\n#include <YCP.h>\n#include <y2util/RepDef.h>\n#include <locale.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nIniParser {\n  bool HaveRewrites () const { return rewrites.size () > 0; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->isInteger",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "63-63",
          "snippet": "bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->isString",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.repeatNames",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "repeatNames",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.h",
          "lines": "458-458",
          "snippet": "bool repeatNames () const { return repeat_names; }",
          "includes": [
            "#include \"IniFile.h\"",
            "#include <set>",
            "#include <vector>",
            "#include <string>",
            "#include <fstream>",
            "#include <iosfwd>",
            "#include <YCP.h>",
            "#include <y2util/RepDef.h>",
            "#include <locale.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include <set>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <iosfwd>\n#include <YCP.h>\n#include <y2util/RepDef.h>\n#include <locale.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nIniParser {\n  bool repeatNames () const { return repeat_names; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->isList",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.write",
          "args": [],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "928-1017",
          "snippet": "int IniParser::write()\n{\n    int bugs = 0;\n    if (!inifile.isDirty())\n    {\n        y2debug (\"File %s did not change. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n\treturn 0;\n    }\n    if (read_only)\n    {\n        y2debug (\"Attempt to write file %s that was mounted read-only. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n\treturn 0;\n    }\n    UpdateIfModif ();\n\n    if (multiple_files)\n    {\n\tIniIterator\n\t    ci = inifile.getContainerBegin (),\n\t    ce = inifile.getContainerEnd ();\n\n\tfor (;ci != ce; ++ci)\n\t    {\n\t\tif (ci->t () == SECTION)\n\t\t    {\n\t\t\tIniSection&s = ci->s ();\n\t\t\tint wb = s.getRewriteBy (); // bug #19066 \n\t\t\tstring filename = getFileName (s.getName (), wb);\n\n\t\t\t// This is the only place where we unmark a\n\t\t\t// section for deletion - when it is a file\n\t\t\t// that got some data again. We can do it\n\t\t\t// because we only erase the files afterwards.\n\t\t\tdeleted_sections.erase (filename);\n\n\t\t\tif (!s.isDirty ()) {\n\t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\ts.initReadBy ();\n\t\t\t// ensure that the directories exist\n\t\t\tPathname pn (filename);\n\t\t\tPathInfo::assert_dir (pn.dirname ());\n\t\t\tofstream of(filename.c_str());\n\t\t\tif (!of.good())\n\t\t\t{\n\t\t\t    bugs++;\n\t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\twrite_helper (s, of, 0);\n\t\t\ts.clean();\n\t\t\tof.close ();\n\t\t    }\n\t\telse\n\t\t    {\n\t\t\ty2error (\"Value %s encountered at multifile top level\",\n\t\t\t\t ci->e ().getName ());\n\t\t    }\n\t    }\n\n\t// FIXME: update time stamps of files...\n\n\t// erase removed files...\n\tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n\t    if (multi_files.find (*i) != multi_files.end ()) {\n\t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n\t\tunlink ((*i).c_str());\n\t    }\n    }\n    else\n    {\n\t// ensure that the directories exist\n\tPathname pn (file);\n\tPathInfo::assert_dir (pn.dirname ());\n\tofstream of(file.c_str());\n\tif (!of.good())\n\t{\n\t    y2error (\"Can not open file %s for write\", file.c_str());\n\t    return -1;\n\t}\n\n\twrite_helper (inifile, of, 0);\n\n\tof.close();\n\ttimestamp = getTimeStamp ();\n    }\n    inifile.clean ();\n    return bugs ? -1 : 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::write()\n  {\n      int bugs = 0;\n      if (!inifile.isDirty())\n      {\n          y2debug (\"File %s did not change. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n  \treturn 0;\n      }\n      if (read_only)\n      {\n          y2debug (\"Attempt to write file %s that was mounted read-only. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n  \treturn 0;\n      }\n      UpdateIfModif ();\n  \n      if (multiple_files)\n      {\n  \tIniIterator\n  \t    ci = inifile.getContainerBegin (),\n  \t    ce = inifile.getContainerEnd ();\n  \n  \tfor (;ci != ce; ++ci)\n  \t    {\n  \t\tif (ci->t () == SECTION)\n  \t\t    {\n  \t\t\tIniSection&s = ci->s ();\n  \t\t\tint wb = s.getRewriteBy (); // bug #19066 \n  \t\t\tstring filename = getFileName (s.getName (), wb);\n  \n  \t\t\t// This is the only place where we unmark a\n  \t\t\t// section for deletion - when it is a file\n  \t\t\t// that got some data again. We can do it\n  \t\t\t// because we only erase the files afterwards.\n  \t\t\tdeleted_sections.erase (filename);\n  \n  \t\t\tif (!s.isDirty ()) {\n  \t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n  \t\t\t    continue;\n  \t\t\t}\n  \t\t\ts.initReadBy ();\n  \t\t\t// ensure that the directories exist\n  \t\t\tPathname pn (filename);\n  \t\t\tPathInfo::assert_dir (pn.dirname ());\n  \t\t\tofstream of(filename.c_str());\n  \t\t\tif (!of.good())\n  \t\t\t{\n  \t\t\t    bugs++;\n  \t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n  \t\t\t    continue;\n  \t\t\t}\n  \t\t\twrite_helper (s, of, 0);\n  \t\t\ts.clean();\n  \t\t\tof.close ();\n  \t\t    }\n  \t\telse\n  \t\t    {\n  \t\t\ty2error (\"Value %s encountered at multifile top level\",\n  \t\t\t\t ci->e ().getName ());\n  \t\t    }\n  \t    }\n  \n  \t// FIXME: update time stamps of files...\n  \n  \t// erase removed files...\n  \tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n  \t    if (multi_files.find (*i) != multi_files.end ()) {\n  \t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n  \t\tunlink ((*i).c_str());\n  \t    }\n      }\n      else\n      {\n  \t// ensure that the directories exist\n  \tPathname pn (file);\n  \tPathInfo::assert_dir (pn.dirname ());\n  \tofstream of(file.c_str());\n  \tif (!of.good())\n  \t{\n  \t    y2error (\"Can not open file %s for write\", file.c_str());\n  \t    return -1;\n  \t}\n  \n  \twrite_helper (inifile, of, 0);\n  \n  \tof.close();\n  \ttimestamp = getTimeStamp ();\n      }\n      inifile.clean ();\n      return bugs ? -1 : 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.inifile.clean",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "clean",
          "container": "IniBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "62-62",
          "snippet": "virtual void clean() { dirty = false; }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniBase {\n  virtual void clean() { dirty = false; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asString",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.inifile.setDirty",
          "args": [],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "setDirty",
          "container": "IniBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "71-71",
          "snippet": "void setDirty()\t\t    { dirty = true; }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniBase {\n  void setDirty()\t\t    { dirty = true; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "false"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"Can't execute Write before being mounted.\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser.isStarted",
          "args": [],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "isStarted",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.h",
          "lines": "419-419",
          "snippet": "bool isStarted() { return started; }",
          "includes": [
            "#include \"IniFile.h\"",
            "#include <set>",
            "#include <vector>",
            "#include <string>",
            "#include <fstream>",
            "#include <iosfwd>",
            "#include <YCP.h>",
            "#include <y2util/RepDef.h>",
            "#include <locale.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include <set>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <iosfwd>\n#include <YCP.h>\n#include <y2util/RepDef.h>\n#include <locale.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nIniParser {\n  bool isStarted() { return started; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include \"IniAgent.h\"\n\nIniAgent {\n  YCPBoolean IniAgent::Write(const YCPPath &path, const YCPValue& value, const YCPValue& arg)\n  {\n      if (!parser.isStarted())\n      {\n  \ty2warning(\"Can't execute Write before being mounted.\");\n  \treturn YCPBoolean (false);\n      }\n      // no need to update if modified, we are changing value\n  \n      bool ok = false; // is the _path_ ok?\n      // return value\n      YCPBoolean b (true);\n  \n      if (0 == path->length ())\n      {\n  \tif (value->isString() && value->asString()->value() == \"force\")\n  \t    parser.inifile.setDirty();\n  \telse if (value->isString () && value->asString()->value() == \"clean\")\n  \t    parser.inifile.clean ();\n  \tif (0 != parser.write ())\n  \t    b = false;\n  \tok = true;\n      }\n      else\n      {\n  \tif (( parser.repeatNames () && value->isList ()) ||\n  \t    (!parser.repeatNames () &&  (value->isString () || value->isInteger())) ||\n  \t    path->component_str(0) == \"all\"\n  \t    )\n  \t    {\n  \t\tok = true;\n  \t\tif (parser.inifile.Write (path, value, parser.HaveRewrites ()))\n  \t\t    b = false;\n  \t    }\n          else if (value->isVoid ())\n  \t    {\n  \t\tint wb  = -1;\n  \t\tstring del_sec = \"\";\n  \t\tok = true;\n  \t\tif (2 == path->length ())\n  \t\t{\n  \t\t    string pc = path->component_str(0);\n  \t\t    if (\"s\" == pc || \"section\" == pc)\n  \t\t    {\t// request to delete section. Find the file name\n  \t\t\tdel_sec = path->component_str (1);\n  \t\t\twb = parser.inifile.getSubSectionRewriteBy (del_sec.c_str());\n  \t\t    }\n  \t\t}\n  \t\tif (parser.inifile.Delete (path))\n  \t\t    b = false;\n  \t\telse if (del_sec != \"\")\n  \t\t{\n  \t\t    parser.deleted_sections.insert (parser.getFileName (del_sec, wb));\n  \t\t}\n  \t    }\n  \telse\n  \t{\n  \t    ycp2error (\"Wrong value for path %s: %s\", path->toString ().c_str (), value->toString ().c_str ());\n  \t    b = false;\n  \t}\n      }\n      if (!ok)\n      {\n      \tycp2error ( \"Wrong path '%s' in Write().\", path->toString().c_str () );\n      }\n  \n      return b;\n  }\n}"
  },
  {
    "function_name": "Read",
    "container": "IniAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniAgent.cc",
    "lines": "56-70",
    "snippet": "YCPValue IniAgent::Read(const YCPPath &path, const YCPValue& arg, const YCPValue& optarg)\n{\n    if (!parser.isStarted())\n\t{\n\t    y2warning(\"Can't execute Read before being mounted.\");\n\t    return YCPVoid();\n\t}\n    parser.UpdateIfModif ();\n\n    YCPValue out = YCPVoid ();\n    if (!parser.inifile.Read (path, out, parser.HaveRewrites ()))\n\treturn out;\n\n    return YCPVoid();\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include \"IniAgent.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.inifile.Read",
          "args": [
            "path",
            "out",
            "parser.HaveRewrites ()"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "Read",
          "container": "IniAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniAgent.cc",
          "lines": "56-70",
          "snippet": "YCPValue IniAgent::Read(const YCPPath &path, const YCPValue& arg, const YCPValue& optarg)\n{\n    if (!parser.isStarted())\n\t{\n\t    y2warning(\"Can't execute Read before being mounted.\");\n\t    return YCPVoid();\n\t}\n    parser.UpdateIfModif ();\n\n    YCPValue out = YCPVoid ();\n    if (!parser.inifile.Read (path, out, parser.HaveRewrites ()))\n\treturn out;\n\n    return YCPVoid();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "parser.HaveRewrites",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "HaveRewrites",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.h",
          "lines": "455-455",
          "snippet": "bool HaveRewrites () const { return rewrites.size () > 0; }",
          "includes": [
            "#include \"IniFile.h\"",
            "#include <set>",
            "#include <vector>",
            "#include <string>",
            "#include <fstream>",
            "#include <iosfwd>",
            "#include <YCP.h>",
            "#include <y2util/RepDef.h>",
            "#include <locale.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include <set>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <iosfwd>\n#include <YCP.h>\n#include <y2util/RepDef.h>\n#include <locale.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nIniParser {\n  bool HaveRewrites () const { return rewrites.size () > 0; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.UpdateIfModif",
          "args": [],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "UpdateIfModif",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "888-911",
          "snippet": "void IniParser::UpdateIfModif ()\n{\n    if (read_only)\n        return;\n    // #42297: parsing a file with repeat_names cannot remove duplicates\n    // so reparsing it would duplicate the whole file.\n    // Therefore we do not reparse.\n    if (repeat_names)\n    {\n\ty2debug (\"Skipping possible reparse due to repeat_names\");\n\treturn;\n    }\n    if (multiple_files)\n\tparse ();\n    else\n    {\n\tif (timestamp != getTimeStamp())\n\t{\n\t    y2warning(\"Data file '%s' was changed externaly!\", file.c_str());\n\t    parse ();\n\t}\n    }\n    return ;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  void IniParser::UpdateIfModif ()\n  {\n      if (read_only)\n          return;\n      // #42297: parsing a file with repeat_names cannot remove duplicates\n      // so reparsing it would duplicate the whole file.\n      // Therefore we do not reparse.\n      if (repeat_names)\n      {\n  \ty2debug (\"Skipping possible reparse due to repeat_names\");\n  \treturn;\n      }\n      if (multiple_files)\n  \tparse ();\n      else\n      {\n  \tif (timestamp != getTimeStamp())\n  \t{\n  \t    y2warning(\"Data file '%s' was changed externaly!\", file.c_str());\n  \t    parse ();\n  \t}\n      }\n      return ;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"Can't execute Read before being mounted.\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser.isStarted",
          "args": [],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "isStarted",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.h",
          "lines": "419-419",
          "snippet": "bool isStarted() { return started; }",
          "includes": [
            "#include \"IniFile.h\"",
            "#include <set>",
            "#include <vector>",
            "#include <string>",
            "#include <fstream>",
            "#include <iosfwd>",
            "#include <YCP.h>",
            "#include <y2util/RepDef.h>",
            "#include <locale.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include <set>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <iosfwd>\n#include <YCP.h>\n#include <y2util/RepDef.h>\n#include <locale.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nIniParser {\n  bool isStarted() { return started; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include \"IniAgent.h\"\n\nIniAgent {\n  YCPValue IniAgent::Read(const YCPPath &path, const YCPValue& arg, const YCPValue& optarg)\n  {\n      if (!parser.isStarted())\n  \t{\n  \t    y2warning(\"Can't execute Read before being mounted.\");\n  \t    return YCPVoid();\n  \t}\n      parser.UpdateIfModif ();\n  \n      YCPValue out = YCPVoid ();\n      if (!parser.inifile.Read (path, out, parser.HaveRewrites ()))\n  \treturn out;\n  \n      return YCPVoid();\n  }\n}"
  },
  {
    "function_name": "Dir",
    "container": "IniAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniAgent.cc",
    "lines": "37-51",
    "snippet": "YCPList IniAgent::Dir(const YCPPath& path)\n{\n    if (!parser.isStarted())\n\t{\n\t    y2warning(\"Can't execute Dir before being mounted.\");\n\t    return YCPNull();\n\t}\n    parser.UpdateIfModif ();\n\n    YCPList l;\n    if (!parser.inifile.Dir (path, l))\n\treturn l;\n\n    return YCPNull();\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include \"IniAgent.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser.inifile.Dir",
          "args": [
            "path",
            "l"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "Dir",
          "container": "IniSection",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "1073-1092",
          "snippet": "int IniSection::Dir (const YCPPath&p, YCPList&l)\n{\n    if (ip->isFlat ())\n\treturn dirValueFlat (p, l);\n    if (p->length()<1)\n\t{\n\t    l.add (YCPString (\"section\"));\n\t    l.add (YCPString (\"value\"));\n\t    return 0;\n\t}\n\n    string s = p->component_str(0);\n    if (s == \"v\" || s == \"value\")\n\treturn dirHelper (p, l, 0, 1);\n    else if (s == \"s\" || s == \"section\")\n\treturn dirHelper (p, l, 1, 1);\n\n    y2error (\"I do not know what to dir from %s.\", p->toString().c_str());\n    return -1;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nIniSection {\n  int IniSection::Dir (const YCPPath&p, YCPList&l)\n  {\n      if (ip->isFlat ())\n  \treturn dirValueFlat (p, l);\n      if (p->length()<1)\n  \t{\n  \t    l.add (YCPString (\"section\"));\n  \t    l.add (YCPString (\"value\"));\n  \t    return 0;\n  \t}\n  \n      string s = p->component_str(0);\n      if (s == \"v\" || s == \"value\")\n  \treturn dirHelper (p, l, 0, 1);\n      else if (s == \"s\" || s == \"section\")\n  \treturn dirHelper (p, l, 1, 1);\n  \n      y2error (\"I do not know what to dir from %s.\", p->toString().c_str());\n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.UpdateIfModif",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "UpdateIfModif",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "888-911",
          "snippet": "void IniParser::UpdateIfModif ()\n{\n    if (read_only)\n        return;\n    // #42297: parsing a file with repeat_names cannot remove duplicates\n    // so reparsing it would duplicate the whole file.\n    // Therefore we do not reparse.\n    if (repeat_names)\n    {\n\ty2debug (\"Skipping possible reparse due to repeat_names\");\n\treturn;\n    }\n    if (multiple_files)\n\tparse ();\n    else\n    {\n\tif (timestamp != getTimeStamp())\n\t{\n\t    y2warning(\"Data file '%s' was changed externaly!\", file.c_str());\n\t    parse ();\n\t}\n    }\n    return ;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  void IniParser::UpdateIfModif ()\n  {\n      if (read_only)\n          return;\n      // #42297: parsing a file with repeat_names cannot remove duplicates\n      // so reparsing it would duplicate the whole file.\n      // Therefore we do not reparse.\n      if (repeat_names)\n      {\n  \ty2debug (\"Skipping possible reparse due to repeat_names\");\n  \treturn;\n      }\n      if (multiple_files)\n  \tparse ();\n      else\n      {\n  \tif (timestamp != getTimeStamp())\n  \t{\n  \t    y2warning(\"Data file '%s' was changed externaly!\", file.c_str());\n  \t    parse ();\n  \t}\n      }\n      return ;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"Can't execute Dir before being mounted.\""
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser.isStarted",
          "args": [],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "isStarted",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.h",
          "lines": "419-419",
          "snippet": "bool isStarted() { return started; }",
          "includes": [
            "#include \"IniFile.h\"",
            "#include <set>",
            "#include <vector>",
            "#include <string>",
            "#include <fstream>",
            "#include <iosfwd>",
            "#include <YCP.h>",
            "#include <y2util/RepDef.h>",
            "#include <locale.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include <set>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <iosfwd>\n#include <YCP.h>\n#include <y2util/RepDef.h>\n#include <locale.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nIniParser {\n  bool isStarted() { return started; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include \"IniAgent.h\"\n\nIniAgent {\n  YCPList IniAgent::Dir(const YCPPath& path)\n  {\n      if (!parser.isStarted())\n  \t{\n  \t    y2warning(\"Can't execute Dir before being mounted.\");\n  \t    return YCPNull();\n  \t}\n      parser.UpdateIfModif ();\n  \n      YCPList l;\n      if (!parser.inifile.Dir (path, l))\n  \treturn l;\n  \n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "~IniAgent",
    "container": "IniAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniAgent.cc",
    "lines": "28-32",
    "snippet": "IniAgent::~IniAgent()\n{\n    if (parser.isStarted())\n\tparser.write();\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include \"IniAgent.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parser.write",
          "args": [],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "928-1017",
          "snippet": "int IniParser::write()\n{\n    int bugs = 0;\n    if (!inifile.isDirty())\n    {\n        y2debug (\"File %s did not change. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n\treturn 0;\n    }\n    if (read_only)\n    {\n        y2debug (\"Attempt to write file %s that was mounted read-only. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n\treturn 0;\n    }\n    UpdateIfModif ();\n\n    if (multiple_files)\n    {\n\tIniIterator\n\t    ci = inifile.getContainerBegin (),\n\t    ce = inifile.getContainerEnd ();\n\n\tfor (;ci != ce; ++ci)\n\t    {\n\t\tif (ci->t () == SECTION)\n\t\t    {\n\t\t\tIniSection&s = ci->s ();\n\t\t\tint wb = s.getRewriteBy (); // bug #19066 \n\t\t\tstring filename = getFileName (s.getName (), wb);\n\n\t\t\t// This is the only place where we unmark a\n\t\t\t// section for deletion - when it is a file\n\t\t\t// that got some data again. We can do it\n\t\t\t// because we only erase the files afterwards.\n\t\t\tdeleted_sections.erase (filename);\n\n\t\t\tif (!s.isDirty ()) {\n\t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\ts.initReadBy ();\n\t\t\t// ensure that the directories exist\n\t\t\tPathname pn (filename);\n\t\t\tPathInfo::assert_dir (pn.dirname ());\n\t\t\tofstream of(filename.c_str());\n\t\t\tif (!of.good())\n\t\t\t{\n\t\t\t    bugs++;\n\t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\twrite_helper (s, of, 0);\n\t\t\ts.clean();\n\t\t\tof.close ();\n\t\t    }\n\t\telse\n\t\t    {\n\t\t\ty2error (\"Value %s encountered at multifile top level\",\n\t\t\t\t ci->e ().getName ());\n\t\t    }\n\t    }\n\n\t// FIXME: update time stamps of files...\n\n\t// erase removed files...\n\tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n\t    if (multi_files.find (*i) != multi_files.end ()) {\n\t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n\t\tunlink ((*i).c_str());\n\t    }\n    }\n    else\n    {\n\t// ensure that the directories exist\n\tPathname pn (file);\n\tPathInfo::assert_dir (pn.dirname ());\n\tofstream of(file.c_str());\n\tif (!of.good())\n\t{\n\t    y2error (\"Can not open file %s for write\", file.c_str());\n\t    return -1;\n\t}\n\n\twrite_helper (inifile, of, 0);\n\n\tof.close();\n\ttimestamp = getTimeStamp ();\n    }\n    inifile.clean ();\n    return bugs ? -1 : 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::write()\n  {\n      int bugs = 0;\n      if (!inifile.isDirty())\n      {\n          y2debug (\"File %s did not change. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n  \treturn 0;\n      }\n      if (read_only)\n      {\n          y2debug (\"Attempt to write file %s that was mounted read-only. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n  \treturn 0;\n      }\n      UpdateIfModif ();\n  \n      if (multiple_files)\n      {\n  \tIniIterator\n  \t    ci = inifile.getContainerBegin (),\n  \t    ce = inifile.getContainerEnd ();\n  \n  \tfor (;ci != ce; ++ci)\n  \t    {\n  \t\tif (ci->t () == SECTION)\n  \t\t    {\n  \t\t\tIniSection&s = ci->s ();\n  \t\t\tint wb = s.getRewriteBy (); // bug #19066 \n  \t\t\tstring filename = getFileName (s.getName (), wb);\n  \n  \t\t\t// This is the only place where we unmark a\n  \t\t\t// section for deletion - when it is a file\n  \t\t\t// that got some data again. We can do it\n  \t\t\t// because we only erase the files afterwards.\n  \t\t\tdeleted_sections.erase (filename);\n  \n  \t\t\tif (!s.isDirty ()) {\n  \t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n  \t\t\t    continue;\n  \t\t\t}\n  \t\t\ts.initReadBy ();\n  \t\t\t// ensure that the directories exist\n  \t\t\tPathname pn (filename);\n  \t\t\tPathInfo::assert_dir (pn.dirname ());\n  \t\t\tofstream of(filename.c_str());\n  \t\t\tif (!of.good())\n  \t\t\t{\n  \t\t\t    bugs++;\n  \t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n  \t\t\t    continue;\n  \t\t\t}\n  \t\t\twrite_helper (s, of, 0);\n  \t\t\ts.clean();\n  \t\t\tof.close ();\n  \t\t    }\n  \t\telse\n  \t\t    {\n  \t\t\ty2error (\"Value %s encountered at multifile top level\",\n  \t\t\t\t ci->e ().getName ());\n  \t\t    }\n  \t    }\n  \n  \t// FIXME: update time stamps of files...\n  \n  \t// erase removed files...\n  \tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n  \t    if (multi_files.find (*i) != multi_files.end ()) {\n  \t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n  \t\tunlink ((*i).c_str());\n  \t    }\n      }\n      else\n      {\n  \t// ensure that the directories exist\n  \tPathname pn (file);\n  \tPathInfo::assert_dir (pn.dirname ());\n  \tofstream of(file.c_str());\n  \tif (!of.good())\n  \t{\n  \t    y2error (\"Can not open file %s for write\", file.c_str());\n  \t    return -1;\n  \t}\n  \n  \twrite_helper (inifile, of, 0);\n  \n  \tof.close();\n  \ttimestamp = getTimeStamp ();\n      }\n      inifile.clean ();\n      return bugs ? -1 : 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.isStarted",
          "args": [],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "isStarted",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.h",
          "lines": "419-419",
          "snippet": "bool isStarted() { return started; }",
          "includes": [
            "#include \"IniFile.h\"",
            "#include <set>",
            "#include <vector>",
            "#include <string>",
            "#include <fstream>",
            "#include <iosfwd>",
            "#include <YCP.h>",
            "#include <y2util/RepDef.h>",
            "#include <locale.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include <set>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <iosfwd>\n#include <YCP.h>\n#include <y2util/RepDef.h>\n#include <locale.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nIniParser {\n  bool isStarted() { return started; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include \"IniAgent.h\"\n\nIniAgent {\n  IniAgent::~IniAgent()\n  {\n      if (parser.isStarted())\n  \tparser.write();\n  }\n}"
  },
  {
    "function_name": "IniAgent",
    "container": "IniAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniAgent.cc",
    "lines": "21-23",
    "snippet": "IniAgent::IniAgent() : SCRAgent()\n{\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include \"IniAgent.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include \"IniAgent.h\"\n\nIniAgent {\n  IniAgent::IniAgent() : SCRAgent()\n  {\n  }\n}"
  }
]