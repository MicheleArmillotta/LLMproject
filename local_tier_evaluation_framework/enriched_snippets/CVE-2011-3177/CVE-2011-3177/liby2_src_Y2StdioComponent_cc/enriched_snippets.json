[
  {
    "function_name": "receive",
    "container": "Y2StdioComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
    "lines": "135-155",
    "snippet": "YCPValue\nY2StdioComponent::receive ()\n{\n    y2debug (\"receive begin\");\n    YCodePtr pc = parser.parse ();\n    if (pc)\n    {\n        // try constant evaluation\n        YCPValue val = pc->evaluate (true);\n        if (val.isNull ())\n        {\n            val = YCPCode (pc);\n        }\n\n        y2debug (\"receive end %s\", val->toString ().c_str ());\n        return val;\n    }\n\n    y2debug (\"receive end - parse error\");\n    return YCPNull ();\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include \"Y2StdioComponent.h\"",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"receive end - parse error\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"receive end %s\"",
            "val->toString ().c_str ()"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "val->toString",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "76-88",
          "snippet": "string\nY2Namespace::toString () const\n{\n    if (m_table == 0)\n    {\n\treturn \"<empty>\";\n    }\n\n    SymbolTable* t = m_table;\n    string s = t->toString ();\n\n    return s + symbolsToString ();\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  string\n  Y2Namespace::toString () const\n  {\n      if (m_table == 0)\n      {\n  \treturn \"<empty>\";\n      }\n  \n      SymbolTable* t = m_table;\n      string s = t->toString ();\n  \n      return s + symbolsToString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPCode",
          "args": [
            "pc"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "YCPCode",
          "container": "YCPCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "103-107",
          "snippet": "YCPCode::YCPCode (bytecodeistream & str)\n    : YCPValue (YCPCode())\n{\n    (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPCode {\n  YCPCode::YCPCode (bytecodeistream & str)\n      : YCPValue (YCPCode())\n  {\n      (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "val.isNull",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc->evaluate",
          "args": [
            "true"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2StdioComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
          "lines": "54-80",
          "snippet": "YCPValue Y2StdioComponent::evaluate (const YCPValue& command)\n{\n    if (!is_server && !batchmode) {\n\t// FIXME:\n\treturn YCPVoid ();\n    }\n\n    send (command);\n\n    // don't receive anything in batchmode\n    if (batchmode)\n    {\n\treturn YCPVoid ();\n    }\n\n    while (true)\n    {\n\tYCPValue ret = receive ();\n\n\tif (!ret.isNull ())\n\t    return ret;\n\n\ty2error (\"Couldn't read return value from stdin. Aborting!\");\n\texit (10);\n\treturn YCPVoid ();\n    }\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include \"Y2StdioComponent.h\"",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  YCPValue Y2StdioComponent::evaluate (const YCPValue& command)\n  {\n      if (!is_server && !batchmode) {\n  \t// FIXME:\n  \treturn YCPVoid ();\n      }\n  \n      send (command);\n  \n      // don't receive anything in batchmode\n      if (batchmode)\n      {\n  \treturn YCPVoid ();\n      }\n  \n      while (true)\n      {\n  \tYCPValue ret = receive ();\n  \n  \tif (!ret.isNull ())\n  \t    return ret;\n  \n  \ty2error (\"Couldn't read return value from stdin. Aborting!\");\n  \texit (10);\n  \treturn YCPVoid ();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.parse",
          "args": [],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "484-562",
          "snippet": "int IniParser::parse()\n{\n    if (multiple_files)\n    {\n\tglob_t do_files;\n\tint len = files.size ();\n\tint flags = 0;\n\tfor (int i = 0;i<len;i++)\n\t{\n\t    glob (files[i].c_str (),flags, NULL, &do_files);\n\t    flags = GLOB_APPEND;\n\t}\n\tchar**f = do_files.gl_pathv;\n\tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n\t{\n\t    int section_index = -1;\n\t    string section_name = *f;\n\t    //FIXME: create function out of it.\n\t    // do we have name rewrite rules?\n\t    for (size_t j = 0; j < rewrites.size (); j++)\n\t\t{\n\t\t    RegexMatch m (rewrites[j].rx, section_name);\n\t\t    if (m)\n\t\t    {\n\t\t\tsection_index = j;\n\t\t\tsection_name = m[1];\n\t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    // do we know about the file?\n\t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n\t    if (ff == multi_files.end())\n\t    {\n\t\t// new file\n\t\tif (scanner_start (*f))\n\t\t    y2error (\"Cannot open %s.\", *f);\n\t\telse\n\t\t{\n\t\t    FileDescr fdsc (*f);\n\t\t    multi_files[*f] = fdsc;\n\t\t    inifile.initSection (section_name, \"\", -1, section_index);\n\t\t    parse_helper(inifile.getSection(section_name.c_str()));\n\t\t    scanner_stop();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif ((*ff).second.changed ())\n\t\t{\n\t\t    if (scanner_start (*f))\n\t\t\ty2error (\"Cannot open %s.\", *f);\n\t\t    else\n\t\t    {\n\t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n\t\t\tFileDescr fdsc (*f);\n\t\t\tmulti_files [*f] = fdsc;\n\t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n\t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n\t\t\tscanner_stop();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tif (scanner_start (file.c_str()))\n\t    {\n\t\ty2error (\"Can not open %s.\", file.c_str());\n\t\treturn -1;\n\t    }\n\tparse_helper(inifile);\n\tscanner_stop();\n\ttimestamp = getTimeStamp ();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse()\n  {\n      if (multiple_files)\n      {\n  \tglob_t do_files;\n  \tint len = files.size ();\n  \tint flags = 0;\n  \tfor (int i = 0;i<len;i++)\n  \t{\n  \t    glob (files[i].c_str (),flags, NULL, &do_files);\n  \t    flags = GLOB_APPEND;\n  \t}\n  \tchar**f = do_files.gl_pathv;\n  \tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n  \t{\n  \t    int section_index = -1;\n  \t    string section_name = *f;\n  \t    //FIXME: create function out of it.\n  \t    // do we have name rewrite rules?\n  \t    for (size_t j = 0; j < rewrites.size (); j++)\n  \t\t{\n  \t\t    RegexMatch m (rewrites[j].rx, section_name);\n  \t\t    if (m)\n  \t\t    {\n  \t\t\tsection_index = j;\n  \t\t\tsection_name = m[1];\n  \t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \n  \t    // do we know about the file?\n  \t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n  \t    if (ff == multi_files.end())\n  \t    {\n  \t\t// new file\n  \t\tif (scanner_start (*f))\n  \t\t    y2error (\"Cannot open %s.\", *f);\n  \t\telse\n  \t\t{\n  \t\t    FileDescr fdsc (*f);\n  \t\t    multi_files[*f] = fdsc;\n  \t\t    inifile.initSection (section_name, \"\", -1, section_index);\n  \t\t    parse_helper(inifile.getSection(section_name.c_str()));\n  \t\t    scanner_stop();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif ((*ff).second.changed ())\n  \t\t{\n  \t\t    if (scanner_start (*f))\n  \t\t\ty2error (\"Cannot open %s.\", *f);\n  \t\t    else\n  \t\t    {\n  \t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n  \t\t\tFileDescr fdsc (*f);\n  \t\t\tmulti_files [*f] = fdsc;\n  \t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n  \t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n  \t\t\tscanner_stop();\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n      else\n      {\n  \tif (scanner_start (file.c_str()))\n  \t    {\n  \t\ty2error (\"Can not open %s.\", file.c_str());\n  \t\treturn -1;\n  \t    }\n  \tparse_helper(inifile);\n  \tscanner_stop();\n  \ttimestamp = getTimeStamp ();\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"receive begin\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  YCPValue\n  Y2StdioComponent::receive ()\n  {\n      y2debug (\"receive begin\");\n      YCodePtr pc = parser.parse ();\n      if (pc)\n      {\n          // try constant evaluation\n          YCPValue val = pc->evaluate (true);\n          if (val.isNull ())\n          {\n              val = YCPCode (pc);\n          }\n  \n          y2debug (\"receive end %s\", val->toString ().c_str ());\n          return val;\n      }\n  \n      y2debug (\"receive end - parse error\");\n      return YCPNull ();\n  }\n}"
  },
  {
    "function_name": "send",
    "container": "Y2StdioComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
    "lines": "125-132",
    "snippet": "void\nY2StdioComponent::send (const YCPValue& v) const\n{\n    string s = \"(\" + (v.isNull () ? \"(nil)\" : v->toString ()) + \")\\n\";\n    y2debug (\"send begin %s\", s.c_str ());\n    write (to_stderr ? STDERR_FILENO : STDOUT_FILENO, s.c_str (), s.length ());\n    y2debug (\"send end %s\", s.c_str ());\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include \"Y2StdioComponent.h\"",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"send end %s\"",
            "s.c_str ()"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.c_str",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "to_stderr ? STDERR_FILENO : STDOUT_FILENO",
            "s.c_str ()",
            "s.length ()"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "write_helper",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "1018-1077",
          "snippet": "int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n{\n    char * out_buffer;\n    string indent;\n    string indent2;\n    int readby = ini.getReadBy ();\n    if (!subindent.empty ())\n    {\n\tfor (int ii = 0; ii<depth - 1;ii++)\n\t    indent = indent + subindent;\n\tif (depth)\n\t    indent2 = indent + subindent;\n    }\n\n    if (ini.getComment ()[0])\n        of << ini.getComment();\n    if (readby>=0 && readby < (int)sections.size ())\n\t{\n\t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free (out_buffer);\n\t}\n    \n    IniIterator\n\tci = ini.getContainerBegin (),\n\tce = ini.getContainerEnd ();\n\n    for (;ci != ce; ++ci)\n\t{\n\t    if (ci->t () == SECTION)\n\t\t{\n\t\t    write_helper (ci->s (), of, depth + 1);\n\t\t    ci->s ().clean();\n\t\t}\n\t    else\n\t\t{\n\t\t    IniEntry&e = ci->e ();\n\t\t    if (e.getComment ()[0])\n\t\t\tof << e.getComment();\n\t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n\t\t\t// bnc#492859, a fixed buffer is too small\n\t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n\t\t\tof << indent2 << out_buffer << \"\\n\";\n\t\t\tfree(out_buffer);\n\t\t    }\n\t\t    e.clean();\n\t\t}\n\t}\n\n    if (ini.getEndComment ()[0])\n        of << indent << ini.getEndComment();\n    if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n\t{\n\t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free(out_buffer);\n\t}\n    ini.clean();\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n  {\n      char * out_buffer;\n      string indent;\n      string indent2;\n      int readby = ini.getReadBy ();\n      if (!subindent.empty ())\n      {\n  \tfor (int ii = 0; ii<depth - 1;ii++)\n  \t    indent = indent + subindent;\n  \tif (depth)\n  \t    indent2 = indent + subindent;\n      }\n  \n      if (ini.getComment ()[0])\n          of << ini.getComment();\n      if (readby>=0 && readby < (int)sections.size ())\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free (out_buffer);\n  \t}\n      \n      IniIterator\n  \tci = ini.getContainerBegin (),\n  \tce = ini.getContainerEnd ();\n  \n      for (;ci != ce; ++ci)\n  \t{\n  \t    if (ci->t () == SECTION)\n  \t\t{\n  \t\t    write_helper (ci->s (), of, depth + 1);\n  \t\t    ci->s ().clean();\n  \t\t}\n  \t    else\n  \t\t{\n  \t\t    IniEntry&e = ci->e ();\n  \t\t    if (e.getComment ()[0])\n  \t\t\tof << e.getComment();\n  \t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n  \t\t\t// bnc#492859, a fixed buffer is too small\n  \t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n  \t\t\tof << indent2 << out_buffer << \"\\n\";\n  \t\t\tfree(out_buffer);\n  \t\t    }\n  \t\t    e.clean();\n  \t\t}\n  \t}\n  \n      if (ini.getEndComment ()[0])\n          of << indent << ini.getEndComment();\n      if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free(out_buffer);\n  \t}\n      ini.clean();\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.length",
          "args": [],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.c_str",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"send begin %s\"",
            "s.c_str ()"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.c_str",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->toString",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "76-88",
          "snippet": "string\nY2Namespace::toString () const\n{\n    if (m_table == 0)\n    {\n\treturn \"<empty>\";\n    }\n\n    SymbolTable* t = m_table;\n    string s = t->toString ();\n\n    return s + symbolsToString ();\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  string\n  Y2Namespace::toString () const\n  {\n      if (m_table == 0)\n      {\n  \treturn \"<empty>\";\n      }\n  \n      SymbolTable* t = m_table;\n      string s = t->toString ();\n  \n      return s + symbolsToString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  void\n  Y2StdioComponent::send (const YCPValue& v) const\n  {\n      string s = \"(\" + (v.isNull () ? \"(nil)\" : v->toString ()) + \")\\n\";\n      y2debug (\"send begin %s\", s.c_str ());\n      write (to_stderr ? STDERR_FILENO : STDOUT_FILENO, s.c_str (), s.length ());\n      y2debug (\"send end %s\", s.c_str ());\n  }\n}"
  },
  {
    "function_name": "doActualWork",
    "container": "Y2StdioComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
    "lines": "96-122",
    "snippet": "YCPValue Y2StdioComponent::doActualWork (const YCPList& arglist,\n\t\t\t\t\t Y2Component *user_interface)\n{\n    send (arglist);\n\n    YCPValue value = YCPNull();\n    while (!parser.atEOF())\n    {\n\tvalue = receive();\n\tif (value.isNull())\n\t{\n\t    send (value);\t// bnc#498407\n\t    continue;\t\t// parse error, or EOF\n\t}\n\n\tif (value->isTerm() && value->asTerm()->size() == 1 &&\n\t    value->asTerm()->name () == \"result\")\n\t{\n\t    return value->asTerm()->value(0);\n\t}\n\n\tsend (user_interface->evaluate(value));\n    }\n\n    y2warning (\"Communication ended prior to result () message\");\n    return YCPVoid ();\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include \"Y2StdioComponent.h\"",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"Communication ended prior to result () message\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "user_interface->evaluate(value)"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "Y2StdioComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
          "lines": "125-132",
          "snippet": "void\nY2StdioComponent::send (const YCPValue& v) const\n{\n    string s = \"(\" + (v.isNull () ? \"(nil)\" : v->toString ()) + \")\\n\";\n    y2debug (\"send begin %s\", s.c_str ());\n    write (to_stderr ? STDERR_FILENO : STDOUT_FILENO, s.c_str (), s.length ());\n    y2debug (\"send end %s\", s.c_str ());\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include \"Y2StdioComponent.h\"",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  void\n  Y2StdioComponent::send (const YCPValue& v) const\n  {\n      string s = \"(\" + (v.isNull () ? \"(nil)\" : v->toString ()) + \")\\n\";\n      y2debug (\"send begin %s\", s.c_str ());\n      write (to_stderr ? STDERR_FILENO : STDOUT_FILENO, s.c_str (), s.length ());\n      y2debug (\"send end %s\", s.c_str ());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_interface->evaluate",
          "args": [
            "value"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2StdioComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
          "lines": "54-80",
          "snippet": "YCPValue Y2StdioComponent::evaluate (const YCPValue& command)\n{\n    if (!is_server && !batchmode) {\n\t// FIXME:\n\treturn YCPVoid ();\n    }\n\n    send (command);\n\n    // don't receive anything in batchmode\n    if (batchmode)\n    {\n\treturn YCPVoid ();\n    }\n\n    while (true)\n    {\n\tYCPValue ret = receive ();\n\n\tif (!ret.isNull ())\n\t    return ret;\n\n\ty2error (\"Couldn't read return value from stdin. Aborting!\");\n\texit (10);\n\treturn YCPVoid ();\n    }\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include \"Y2StdioComponent.h\"",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  YCPValue Y2StdioComponent::evaluate (const YCPValue& command)\n  {\n      if (!is_server && !batchmode) {\n  \t// FIXME:\n  \treturn YCPVoid ();\n      }\n  \n      send (command);\n  \n      // don't receive anything in batchmode\n      if (batchmode)\n      {\n  \treturn YCPVoid ();\n      }\n  \n      while (true)\n      {\n  \tYCPValue ret = receive ();\n  \n  \tif (!ret.isNull ())\n  \t    return ret;\n  \n  \ty2error (\"Couldn't read return value from stdin. Aborting!\");\n  \texit (10);\n  \treturn YCPVoid ();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asTerm",
          "args": [
            "0"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->asTerm",
          "args": [],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->isTerm",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "isTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "70-70",
          "snippet": "bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "receive",
          "container": "Y2StdioComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
          "lines": "135-155",
          "snippet": "YCPValue\nY2StdioComponent::receive ()\n{\n    y2debug (\"receive begin\");\n    YCodePtr pc = parser.parse ();\n    if (pc)\n    {\n        // try constant evaluation\n        YCPValue val = pc->evaluate (true);\n        if (val.isNull ())\n        {\n            val = YCPCode (pc);\n        }\n\n        y2debug (\"receive end %s\", val->toString ().c_str ());\n        return val;\n    }\n\n    y2debug (\"receive end - parse error\");\n    return YCPNull ();\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include \"Y2StdioComponent.h\"",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  YCPValue\n  Y2StdioComponent::receive ()\n  {\n      y2debug (\"receive begin\");\n      YCodePtr pc = parser.parse ();\n      if (pc)\n      {\n          // try constant evaluation\n          YCPValue val = pc->evaluate (true);\n          if (val.isNull ())\n          {\n              val = YCPCode (pc);\n          }\n  \n          y2debug (\"receive end %s\", val->toString ().c_str ());\n          return val;\n      }\n  \n      y2debug (\"receive end - parse error\");\n      return YCPNull ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.atEOF",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "atEOF",
          "container": "Parser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Parser.cc",
          "lines": "134-138",
          "snippet": "bool\nParser::atEOF()\n{\n    return m_at_eof;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Parser.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Parser.h\"\n#include <stdlib.h>\n\nParser {\n  bool\n  Parser::atEOF()\n  {\n      return m_at_eof;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  YCPValue Y2StdioComponent::doActualWork (const YCPList& arglist,\n  \t\t\t\t\t Y2Component *user_interface)\n  {\n      send (arglist);\n  \n      YCPValue value = YCPNull();\n      while (!parser.atEOF())\n      {\n  \tvalue = receive();\n  \tif (value.isNull())\n  \t{\n  \t    send (value);\t// bnc#498407\n  \t    continue;\t\t// parse error, or EOF\n  \t}\n  \n  \tif (value->isTerm() && value->asTerm()->size() == 1 &&\n  \t    value->asTerm()->name () == \"result\")\n  \t{\n  \t    return value->asTerm()->value(0);\n  \t}\n  \n  \tsend (user_interface->evaluate(value));\n      }\n  \n      y2warning (\"Communication ended prior to result () message\");\n      return YCPVoid ();\n  }\n}"
  },
  {
    "function_name": "setServerOptions",
    "container": "Y2StdioComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
    "lines": "91-93",
    "snippet": "void Y2StdioComponent::setServerOptions(int, char **)\n{\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include \"Y2StdioComponent.h\"",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  void Y2StdioComponent::setServerOptions(int, char **)\n  {\n  }\n}"
  },
  {
    "function_name": "result",
    "container": "Y2StdioComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
    "lines": "83-88",
    "snippet": "void Y2StdioComponent::result (const YCPValue& result)\n{\n    YCPTerm resultterm (\"result\");\n    resultterm->add (result);\n    send (resultterm);\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include \"Y2StdioComponent.h\"",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send",
          "args": [
            "resultterm"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "Y2StdioComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
          "lines": "125-132",
          "snippet": "void\nY2StdioComponent::send (const YCPValue& v) const\n{\n    string s = \"(\" + (v.isNull () ? \"(nil)\" : v->toString ()) + \")\\n\";\n    y2debug (\"send begin %s\", s.c_str ());\n    write (to_stderr ? STDERR_FILENO : STDOUT_FILENO, s.c_str (), s.length ());\n    y2debug (\"send end %s\", s.c_str ());\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include \"Y2StdioComponent.h\"",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  void\n  Y2StdioComponent::send (const YCPValue& v) const\n  {\n      string s = \"(\" + (v.isNull () ? \"(nil)\" : v->toString ()) + \")\\n\";\n      y2debug (\"send begin %s\", s.c_str ());\n      write (to_stderr ? STDERR_FILENO : STDOUT_FILENO, s.c_str (), s.length ());\n      y2debug (\"send end %s\", s.c_str ());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "resultterm->add",
          "args": [
            "result"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  void Y2StdioComponent::result (const YCPValue& result)\n  {\n      YCPTerm resultterm (\"result\");\n      resultterm->add (result);\n      send (resultterm);\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "Y2StdioComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
    "lines": "54-80",
    "snippet": "YCPValue Y2StdioComponent::evaluate (const YCPValue& command)\n{\n    if (!is_server && !batchmode) {\n\t// FIXME:\n\treturn YCPVoid ();\n    }\n\n    send (command);\n\n    // don't receive anything in batchmode\n    if (batchmode)\n    {\n\treturn YCPVoid ();\n    }\n\n    while (true)\n    {\n\tYCPValue ret = receive ();\n\n\tif (!ret.isNull ())\n\t    return ret;\n\n\ty2error (\"Couldn't read return value from stdin. Aborting!\");\n\texit (10);\n\treturn YCPVoid ();\n    }\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include \"Y2StdioComponent.h\"",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "10"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Couldn't read return value from stdin. Aborting!\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret.isNull",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive",
          "args": [],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "receive",
          "container": "Y2StdioComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
          "lines": "135-155",
          "snippet": "YCPValue\nY2StdioComponent::receive ()\n{\n    y2debug (\"receive begin\");\n    YCodePtr pc = parser.parse ();\n    if (pc)\n    {\n        // try constant evaluation\n        YCPValue val = pc->evaluate (true);\n        if (val.isNull ())\n        {\n            val = YCPCode (pc);\n        }\n\n        y2debug (\"receive end %s\", val->toString ().c_str ());\n        return val;\n    }\n\n    y2debug (\"receive end - parse error\");\n    return YCPNull ();\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include \"Y2StdioComponent.h\"",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  YCPValue\n  Y2StdioComponent::receive ()\n  {\n      y2debug (\"receive begin\");\n      YCodePtr pc = parser.parse ();\n      if (pc)\n      {\n          // try constant evaluation\n          YCPValue val = pc->evaluate (true);\n          if (val.isNull ())\n          {\n              val = YCPCode (pc);\n          }\n  \n          y2debug (\"receive end %s\", val->toString ().c_str ());\n          return val;\n      }\n  \n      y2debug (\"receive end - parse error\");\n      return YCPNull ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "command"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "Y2StdioComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
          "lines": "125-132",
          "snippet": "void\nY2StdioComponent::send (const YCPValue& v) const\n{\n    string s = \"(\" + (v.isNull () ? \"(nil)\" : v->toString ()) + \")\\n\";\n    y2debug (\"send begin %s\", s.c_str ());\n    write (to_stderr ? STDERR_FILENO : STDOUT_FILENO, s.c_str (), s.length ());\n    y2debug (\"send end %s\", s.c_str ());\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include \"Y2StdioComponent.h\"",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  void\n  Y2StdioComponent::send (const YCPValue& v) const\n  {\n      string s = \"(\" + (v.isNull () ? \"(nil)\" : v->toString ()) + \")\\n\";\n      y2debug (\"send begin %s\", s.c_str ());\n      write (to_stderr ? STDERR_FILENO : STDOUT_FILENO, s.c_str (), s.length ());\n      y2debug (\"send end %s\", s.c_str ());\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  YCPValue Y2StdioComponent::evaluate (const YCPValue& command)\n  {\n      if (!is_server && !batchmode) {\n  \t// FIXME:\n  \treturn YCPVoid ();\n      }\n  \n      send (command);\n  \n      // don't receive anything in batchmode\n      if (batchmode)\n      {\n  \treturn YCPVoid ();\n      }\n  \n      while (true)\n      {\n  \tYCPValue ret = receive ();\n  \n  \tif (!ret.isNull ())\n  \t    return ret;\n  \n  \ty2error (\"Couldn't read return value from stdin. Aborting!\");\n  \texit (10);\n  \treturn YCPVoid ();\n      }\n  }\n}"
  },
  {
    "function_name": "name",
    "container": "Y2StdioComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
    "lines": "46-51",
    "snippet": "string Y2StdioComponent::name() const\n{\n    if (batchmode)\n\treturn \"testsuite\";\n    return to_stderr ? \"stderr\" : \"stdio\";\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include \"Y2StdioComponent.h\"",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  string Y2StdioComponent::name() const\n  {\n      if (batchmode)\n  \treturn \"testsuite\";\n      return to_stderr ? \"stderr\" : \"stdio\";\n  }\n}"
  },
  {
    "function_name": "~Y2StdioComponent",
    "container": "Y2StdioComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
    "lines": "41-43",
    "snippet": "Y2StdioComponent::~Y2StdioComponent()\n{\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include \"Y2StdioComponent.h\"",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  Y2StdioComponent::~Y2StdioComponent()\n  {\n  }\n}"
  },
  {
    "function_name": "Y2StdioComponent",
    "container": "Y2StdioComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
    "lines": "31-38",
    "snippet": "Y2StdioComponent::Y2StdioComponent (bool is_server, bool to_stderr,\n\t\t\t\t    bool in_batchmode)\n    : is_server (is_server),\n      to_stderr (to_stderr),\n      batchmode (in_batchmode),\n      parser (STDIN_FILENO, \"<stdin>\")\n{\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include \"Y2StdioComponent.h\"",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  Y2StdioComponent::Y2StdioComponent (bool is_server, bool to_stderr,\n  \t\t\t\t    bool in_batchmode)\n      : is_server (is_server),\n        to_stderr (to_stderr),\n        batchmode (in_batchmode),\n        parser (STDIN_FILENO, \"<stdin>\")\n  {\n  }\n}"
  }
]