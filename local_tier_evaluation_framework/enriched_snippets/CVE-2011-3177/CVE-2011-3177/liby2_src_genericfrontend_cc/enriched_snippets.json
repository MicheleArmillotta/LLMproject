[
  {
    "function_name": "has_parens",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "975-979",
    "snippet": "static bool\nhas_parens (const char* arg)\n{\n    return arg[0] == '(' && arg[strlen (arg) - 1] == ')';\n}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool has_parens (const char* arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "arg"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic bool has_parens (const char* arg);\n\nstatic bool\nhas_parens (const char* arg)\n{\n    return arg[0] == '(' && arg[strlen (arg) - 1] == ')';\n}"
  },
  {
    "function_name": "print_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "958-972",
    "snippet": "static void\nprint_error (const char* format, ...)\n{\n    char* msg;\n\n    va_list ap;\n    va_start (ap, format);\n    vasprintf (&msg, format, ap);\n    va_end (ap);\n\n    fprintf (stderr, \"%s\\n\", msg);\n    y2error (\"%s\", msg);\n\n    free (msg);\n}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "msg"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"%s\"",
            "msg"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "msg"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vasprintf",
          "args": [
            "&msg",
            "format",
            "ap"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "format"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic void\nprint_error (const char* format, ...)\n{\n    char* msg;\n\n    va_list ap;\n    va_start (ap, format);\n    vasprintf (&msg, format, ap);\n    va_end (ap);\n\n    fprintf (stderr, \"%s\\n\", msg);\n    y2error (\"%s\", msg);\n\n    free (msg);\n}"
  },
  {
    "function_name": "print_help",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "921-955",
    "snippet": "static void\nprint_help()\n{\n    fprintf (stderr, \"\\n\"\n\t     \"Usage: %s [GenericOpts] Client [ClientOpts] Server [Generic ServerOpts] \"\n\t     \"[Specific ServerOpts]\\n\",\n\t     progname);\n\n    fprintf (stderr,\n\t     \"GenericOptions are:\\n\"\n\t     \"    -l | --logfile LogFile    : Set logfile\\n\"\n\t     \"    -c | --logconf ConfFile   : Configure logging\\n\"\n\t     \"    -n Namespace=Component    : Override component for namespace\\n\"\n\t     \"    -I Path                   : Add include search path\\n\"\n\t     \"    -M Path                   : Add module search path\\n\"\n\t     \"    --debugger                : Start local debugger\\n\"\n\t     \"    --debugger-remote         : Start remote debugger\\n\"\n\t     \"ClientOptions are:\\n\"\n\t     \"    -s                        : Get options as one YCPList from stdin\\n\"\n\t     \"    -f FileName               : Get YCPValue(s) from file\\n\"\n\t     \"    -S                        : Parameters are strings, not YCP to be parsed\\n\"\n\t     \"    '(any YCPValue)...'       : Parameter _IS_ a YCPValue\\n\"\n\t     \"                                -S '(t1)' '(\\\\t2)' is equivalent to '(\\\"t1\\\")' '(\\\"\\\\\\\\t2\\\")'\\n\"\n\t     \"Generic ServerOptions are:\\n\"\n\t     \"    -p FileName               : Evaluate YCPValue(s) from file (preload)\\n\"\n\t     \"    '(any YCPValue)'          : Parameter _IS_ a YCPValue to be evaluated\\n\"\n\t     \"Specific ServerOptions are any options passed on unevaluated.\\n\\n\"\n\t     \"Examples:\\n\"\n\t     \"y2base installation qt\\n\"\n\t     \"    Start binary y2base with intallation.ycp as client and qt as server\\n\"\n\t     \"y2base installation '(\\\"test\\\")' qt\\n\"\n\t     \"    Provide YCPValue '\\\"test\\\"' as parameter for client installation\\n\"\n\t     \"y2base installation qt -geometry 800x600\\n\"\n\t     \"    Provide geometry information as specific server options\\n\");\n}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *progname = \"genericfrontend\";",
      "static void print_help ();",
      "bool debugger = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"GenericOptions are:\\n\"\n\t     \"    -l | --logfile LogFile    : Set logfile\\n\"\n\t     \"    -c | --logconf ConfFile   : Configure logging\\n\"\n\t     \"    -n Namespace=Component    : Override component for namespace\\n\"\n\t     \"    -I Path                   : Add include search path\\n\"\n\t     \"    -M Path                   : Add module search path\\n\"\n\t     \"    --debugger                : Start local debugger\\n\"\n\t     \"    --debugger-remote         : Start remote debugger\\n\"\n\t     \"ClientOptions are:\\n\"\n\t     \"    -s                        : Get options as one YCPList from stdin\\n\"\n\t     \"    -f FileName               : Get YCPValue(s) from file\\n\"\n\t     \"    -S                        : Parameters are strings, not YCP to be parsed\\n\"\n\t     \"    '(any YCPValue)...'       : Parameter _IS_ a YCPValue\\n\"\n\t     \"                                -S '(t1)' '(\\\\t2)' is equivalent to '(\\\"t1\\\")' '(\\\"\\\\\\\\t2\\\")'\\n\"\n\t     \"Generic ServerOptions are:\\n\"\n\t     \"    -p FileName               : Evaluate YCPValue(s) from file (preload)\\n\"\n\t     \"    '(any YCPValue)'          : Parameter _IS_ a YCPValue to be evaluated\\n\"\n\t     \"Specific ServerOptions are any options passed on unevaluated.\\n\\n\"\n\t     \"Examples:\\n\"\n\t     \"y2base installation qt\\n\"\n\t     \"    Start binary y2base with intallation.ycp as client and qt as server\\n\"\n\t     \"y2base installation '(\\\"test\\\")' qt\\n\"\n\t     \"    Provide YCPValue '\\\"test\\\"' as parameter for client installation\\n\"\n\t     \"y2base installation qt -geometry 800x600\\n\"\n\t     \"    Provide geometry information as specific server options\\n\""
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\"\n\t     \"Usage: %s [GenericOpts] Client [ClientOpts] Server [Generic ServerOpts] \"\n\t     \"[Specific ServerOpts]\\n\"",
            "progname"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic const char *progname = \"genericfrontend\";\nstatic void print_help ();\nbool debugger = false;\n\nstatic void\nprint_help()\n{\n    fprintf (stderr, \"\\n\"\n\t     \"Usage: %s [GenericOpts] Client [ClientOpts] Server [Generic ServerOpts] \"\n\t     \"[Specific ServerOpts]\\n\",\n\t     progname);\n\n    fprintf (stderr,\n\t     \"GenericOptions are:\\n\"\n\t     \"    -l | --logfile LogFile    : Set logfile\\n\"\n\t     \"    -c | --logconf ConfFile   : Configure logging\\n\"\n\t     \"    -n Namespace=Component    : Override component for namespace\\n\"\n\t     \"    -I Path                   : Add include search path\\n\"\n\t     \"    -M Path                   : Add module search path\\n\"\n\t     \"    --debugger                : Start local debugger\\n\"\n\t     \"    --debugger-remote         : Start remote debugger\\n\"\n\t     \"ClientOptions are:\\n\"\n\t     \"    -s                        : Get options as one YCPList from stdin\\n\"\n\t     \"    -f FileName               : Get YCPValue(s) from file\\n\"\n\t     \"    -S                        : Parameters are strings, not YCP to be parsed\\n\"\n\t     \"    '(any YCPValue)...'       : Parameter _IS_ a YCPValue\\n\"\n\t     \"                                -S '(t1)' '(\\\\t2)' is equivalent to '(\\\"t1\\\")' '(\\\"\\\\\\\\t2\\\")'\\n\"\n\t     \"Generic ServerOptions are:\\n\"\n\t     \"    -p FileName               : Evaluate YCPValue(s) from file (preload)\\n\"\n\t     \"    '(any YCPValue)'          : Parameter _IS_ a YCPValue to be evaluated\\n\"\n\t     \"Specific ServerOptions are any options passed on unevaluated.\\n\\n\"\n\t     \"Examples:\\n\"\n\t     \"y2base installation qt\\n\"\n\t     \"    Start binary y2base with intallation.ycp as client and qt as server\\n\"\n\t     \"y2base installation '(\\\"test\\\")' qt\\n\"\n\t     \"    Provide YCPValue '\\\"test\\\"' as parameter for client installation\\n\"\n\t     \"y2base installation qt -geometry 800x600\\n\"\n\t     \"    Provide geometry information as specific server options\\n\");\n}"
  },
  {
    "function_name": "print_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "913-918",
    "snippet": "static void\nprint_usage()\n{\n    fprintf (stderr,\n\t     \"\\nRun 'yast2 -h' for help on usage\\n\");\n}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void print_usage ();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nRun 'yast2 -h' for help on usage\\n\""
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic void print_usage ();\n\nstatic void\nprint_usage()\n{\n    fprintf (stderr,\n\t     \"\\nRun 'yast2 -h' for help on usage\\n\");\n}"
  },
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "588-910",
    "snippet": "int\nmain (int argc, char **argv)\n{\n    if (!argv[0])\n    {\n\tfprintf (stderr, \"Missing argv[0]. It is a NULL pointer.\");\n\texit (YAST_OPTIONERROR);\n    }\n\n    progname = basename (argv[0]);\t// get program name\n\n    // Ignore SIGPIPE. No use in signals. Signals can't be assigned to\n    // components\n    signal(SIGPIPE, SIG_IGN);\n\n    // Give some output for the SIGSEGV\n    // and other signals too, #238172\n    // Note that USR1 and USR2 are handled by the logger.\n    signal (SIGHUP,  signal_handler);\n    signal (SIGINT,  signal_handler);\n    signal (SIGQUIT, signal_handler);\n    signal (SIGILL , signal_handler);\n    signal (SIGABRT, signal_handler);\n    signal (SIGFPE,  signal_handler);\n    signal (SIGSEGV, signal_handler);\n    signal (SIGTERM, signal_handler);\n\n    if (argc < 2) {\n\tfprintf (stderr, \"\\nToo few arguments\");\n\tprint_usage();\n\texit (YAST_FEWARGUMENTS);\n    }\n\n    if (!strcmp (argv[1], \"-h\") || !strcmp (argv[1], \"--help\")) {\n\tprint_help ();\n\texit (YAST_OK);\n    }\n\n    // client _AND_ server must be given\n    if (argc < 3)\n    {\n\tfprintf (stderr, \"\\nPlease give client and server as arguments\");\n\tprint_usage();\n\texit(5);\n    }\n\n    // Scan all options for -l/--logfile. They must be honored BEFORE\n    // the logger is used the first time.\n    for (int arg = 1; arg < argc; arg++)\n    {\n\tif (!strcmp(argv[arg], \"-l\") || !strcmp(argv[arg], \"--logfile\"))\n\t{\n\t    arg++;   // switch to filename\n\n\t    if (arg >= argc)\n\t    {\n\t\tprint_error (\"Option %s is missing an argument\", argv[arg-1]);\n\t\texit(5);\n\t    }\n\n\t    set_log_filename( argv[arg] );   // set logfile given in command line\n\t}\n\tif (!strcmp(argv[arg], \"-c\") || !strcmp(argv[arg], \"--logconf\"))\n\t{\n\t    arg++;   // switch to filename\n\n\t    if (arg >= argc)\n\t    {\n\t\tprint_error (\"Option %s is missing an argument\", argv[arg-1]);\n\t\texit(5);\n\t    }\n\n\t    set_log_conf( argv[arg] );\n\t}\n    }\n\n    // set a defined umask\n    umask (0022);\n\n    YCPPathSearch::initialize();\n\n    ostringstream argdump;\n    for (int arg = 1; arg < argc; arg++)\n    {\n\targdump << \" '\" << argv[arg] << \"'\";\n    }\n\n    y2milestone (\"Launched YaST2 component '%s'%s\", progname, argdump.str().c_str());\n\n    // Now evaluate command line options in sequence\n\n    int arg = 1;\n\n    // The first argument might be the log option or MUST be the client name\n    if (!strcmp(argv[arg], \"-l\") || !strcmp(argv[arg], \"--logfile\"))\n    {\n\t// Logfile already done at program start --> ignore here\n\targ+=2;\t  // skip over logfilename\n    }\n    if (!strcmp(argv[arg], \"-c\") || !strcmp(argv[arg], \"--logconf\"))\n    {\n\t// Logfile already done at program start --> ignore here\n\targ+=2;\t  // skip over logfilename\n    }\n    // The first argument might be the log option or MUST be the client name\n    if (!strcmp(argv[arg], \"-l\") || !strcmp(argv[arg], \"--logfile\"))\n    {\n\t// Logfile already done at program start --> ignore here\n\targ+=2;\t  // skip over logfilename\n    }\n\n\n    // Check for namespace exceptions registration\n    while (!strcmp(argv[arg], \"-n\"))\n    {\n\targ++;\n\tchar *pos = index (argv[arg], '=');\n\tif (pos == NULL)\n\t{\n\t    print_error (\"Option %s argument must be in format namespace=component\", argv[arg-1]);\n\t    exit (YAST_OPTIONERROR);\n\t}\n\t*pos = 0;\n\tY2ComponentBroker::registerNamespaceException (argv[arg], pos+1);\n\t*pos = '=';\n\targ++;\n    }\n\n// FIXME the whole option parsing sucks **** !\n\n    // Check, if debugger should be enabled\n    if (!strcmp(argv[arg], \"--debugger\"))\n    {\n\t// set the flag\n\tdebugger = true;\n\targ+=1;\n    }\n    \n    if (!strcmp(argv[arg], \"--debugger-remote\"))\n    {\n\t// set the flag\n\tdebugger = true;\n\tdebugger_remote = true;\n\targ+=1;\n    }\n    \n    // also handle environment variable\n    if( getenv (\"Y2DEBUGGER\") )\n    {\n\tif (strcmp (getenv (\"Y2DEBUGGER\"), \"1\")==0 )\n\t    debugger = true;\n\telse if (strcmp (getenv (\"Y2DEBUGGER\"), \"2\")==0 )\n\t{\n\t    debugger = true;\n\t    debugger_remote = true;\n\t}\n    }\n\n    if (debugger)\n    {\n\t// initialize the Debugger instance\n\tdebugger_instance = new Debugger ();\n\tdebugger_instance->initialize (debugger_remote);\n    }\n\n\n    // list of -I / -M pathes\n    //   will be pushed to YCPPathSearch later to keep correct order\n    //   (the last added path to YCPPathSearch will be searched first)\n    std::list<std::string> modpaths;\n    std::list<std::string> incpaths;\n\n    // include paths\n    while (!strcmp(argv[arg], \"-I\"))\n    {\n\targ++;\n\tincpaths.push_front (string (argv[arg])); // push to front so first one is last in list\n\targ++;\n    }\n\n    while (!strcmp(argv[arg], \"-M\"))\n    {\n\targ++;\n\tmodpaths.push_front (string (argv[arg])); // push to front so first one is last in list\n\targ++;\n    }\n\n    // add include and module pathes to YCPPathSearch so that the argument order is kept\n\n    std::list<std::string>::iterator pathit;\n    for (pathit = incpaths.begin(); pathit != incpaths.end(); pathit++)\n    {\n\tYCPPathSearch::addPath (YCPPathSearch::Include, pathit->c_str());\n    }\n    for (pathit = modpaths.begin(); pathit != modpaths.end(); pathit++)\n    {\n\tYCPPathSearch::addPath (YCPPathSearch::Module, pathit->c_str());\n    }\n\n    // \"arg\" and these two are output params\n    char * client_name;\n    YCPList arglist;\n    parse_client_and_options (argc, argv, arg, client_name, arglist);\n    // add debugger information if needed\n    if (debugger)\n\targlist->add ( YCPSymbol(\"debugger\") );\n\n    // \"arg\" and these two are output params\n    char * server_name;\n    YCPList preload;\t\t       // prepare preload files from option -p\n    parse_server_and_options (argc, argv, arg, server_name, preload);\n\n    // now create server\n\n#if 0\n    Y2ComponentBroker::registerNamespaceException (\"UI\", server_name);\n#endif\n    Y2ComponentBroker::getNamespaceComponent( \"UI\" );\n    y2debug( \"Creating server \\\"%s\\\"\", server_name );\n    Y2Component *server = Y2ComponentBroker::createServer( server_name );\n    if (!server) {\n\tprint_error (\"No such server module %s\", server_name);\n\tprint_usage();\n\texit(5);\n    }\n\n    // Put argument into a nice new array and give them to the server\n    char **server_argv = new char *[argc-arg+2];\n    server_argv[0] = strdup (server_name);\n    for (int i = arg; i < argc; i++)\n\tserver_argv[i-arg+1] = argv[i];\n    argv[argc] = NULL;\n\n    // set the server options directly\n    server->setServerOptions(argc-arg+1, server_argv);\n\n    // Preload server with scripts from -p and directly given YCPValues\n    for (int i = 0; i < preload->size(); i++)\n    {\n\tserver->evaluate(preload->value(i));\n    }\n\n    // now create client\n\n    Y2Component *client = Y2ComponentBroker::createClient (client_name);\n    if (!client)\n    {\n\tprint_error (\"No such client module %s\", client_name);\n\n\tstd::list<string>::const_iterator\n\t    i = YCPPathSearch::searchListBegin(YCPPathSearch::Client),\n\t    e = YCPPathSearch::searchListEnd(YCPPathSearch::Client);\n\tfprintf (stderr, \"The search path follows. It does not include the current directory.\\n\");\n\tfor (; i != e; ++i)\n\t    fprintf (stderr, \"  %s\\n\", i->c_str());\n\n\tprint_usage ();\n\texit (YAST_OPTIONERROR);\n    }\n    if (dynamic_cast<Y2ErrorComponent *>(client))\n    {\n\tprint_error (\"Error while creating client module %s\", client_name);\n\texit (YAST_OPTIONERROR);\n    }\n\n\n    // The environment variable YAST_IS_RUNNING is checked in rpm\n    // post install scripts. Might be useful for other scripts as\n    // well.\n    if (strcmp (client_name, \"live-installer\") == 0 // bnc#389099\n\t|| (strcmp (client_name, \"installation\") == 0\n\t    && arglist->contains (YCPString (\"initial\"))))\n    {\n\tsetenv (\"YAST_IS_RUNNING\", \"instsys\", 1);\n    }\n    else\n    {\n\tsetenv (\"YAST_IS_RUNNING\", \"yes\", 1);\n    }\n\n    y2milestone (\"YAST_IS_RUNNING is %s\", getenv (\"YAST_IS_RUNNING\"));\n\n\n    YCPValue result = YCPVoid();\n    // Now start communication\n    result = client->doActualWork(arglist, server);   // give arglist collected above\n\n    // get result\n    server->result(result);\n\n    // Cleanup\n    delete server;\n    delete[] server_argv;\n    delete client;\n\n    // might be useful in tracking segmentation faults\n    y2milestone (\"Finished YaST2 component '%s'\", progname);\n\n    if( result.isNull () )\n\texit (YAST_OK);\n\n    y2milestone( \"Exiting with client return value '%s'\", result->toString ().c_str ());\n\n    if( result->isBoolean () )\n    {\n\texit( result->asBoolean()->value() ? YAST_OK : YAST_CLIENTRESULT );\n    }\n\t\n    if( result->isInteger () )\n\texit( YAST_CLIENTRESULT + result->asInteger ()->value () );\n\n    // if it is one of error symbols, return it as error\n    if( result->isSymbol () )\n    {\n\tstring symbol = result->asSymbol()->symbol();\n\tfor( int i = 0 ; i < MAX_YCP_ERROR_EXIT_SYMBOLS; i++ )\n\t    if( symbol == ycp_error_exit_symbols[i] )\n\t\texit( YAST_CLIENTRESULT );\n    }\n    \n    // all other values\n    exit (YAST_OK);\n}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [
      "#define MAX_YCP_ERROR_EXIT_SYMBOLS\t2"
    ],
    "globals_used": [
      "const char* ycp_error_exit_symbols[MAX_YCP_ERROR_EXIT_SYMBOLS] = { \n    \"abort\",\n    \"cancel\"\n};",
      "Debugger *debugger_instance;",
      "static const char *progname = \"genericfrontend\";",
      "static void print_usage ();",
      "static void print_help ();",
      "static bool has_parens (const char* arg);",
      "bool debugger = false;",
      "bool debugger_remote = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "YAST_OK"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "YAST_CLIENTRESULT"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result->asSymbol",
          "args": [],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "asSymbol",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "167-177",
          "snippet": "YCPSymbol\nYCPValueRep::asSymbol() const\n{\n    if (!isSymbol())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Symbol!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPSymbol (static_cast<const YCPSymbolRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPSymbol\n  YCPValueRep::asSymbol() const\n  {\n      if (!isSymbol())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Symbol!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPSymbol (static_cast<const YCPSymbolRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result->isSymbol",
          "args": [],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "isSymbol",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "68-68",
          "snippet": "bool YCPValueRep::isSymbol()      const { return valuetype() == YT_SYMBOL; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isSymbol()      const { return valuetype() == YT_SYMBOL; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "YAST_CLIENTRESULT + result->asInteger ()->value ()"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result->asInteger",
          "args": [],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "asInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "106-116",
          "snippet": "YCPInteger\nYCPValueRep::asInteger() const\n{\n    if (!isInteger())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPInteger\n  YCPValueRep::asInteger() const\n  {\n      if (!isInteger())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result->isInteger",
          "args": [],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "63-63",
          "snippet": "bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "result->asBoolean()->value() ? YAST_OK : YAST_CLIENTRESULT"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result->asBoolean",
          "args": [],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "asBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "94-104",
          "snippet": "YCPBoolean\nYCPValueRep::asBoolean() const\n{\n    if (!isBoolean())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPBoolean\n  YCPValueRep::asBoolean() const\n  {\n      if (!isBoolean())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result->isBoolean",
          "args": [],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "isBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "62-62",
          "snippet": "bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2milestone",
          "args": [
            "\"Exiting with client return value '%s'\"",
            "result->toString ().c_str ()"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result->toString",
          "args": [],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "76-88",
          "snippet": "string\nY2Namespace::toString () const\n{\n    if (m_table == 0)\n    {\n\treturn \"<empty>\";\n    }\n\n    SymbolTable* t = m_table;\n    string s = t->toString ();\n\n    return s + symbolsToString ();\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  string\n  Y2Namespace::toString () const\n  {\n      if (m_table == 0)\n      {\n  \treturn \"<empty>\";\n      }\n  \n      SymbolTable* t = m_table;\n      string s = t->toString ();\n  \n      return s + symbolsToString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "YAST_OK"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.isNull",
          "args": [],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2milestone",
          "args": [
            "\"Finished YaST2 component '%s'\"",
            "progname"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->result",
          "args": [
            "result"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "result",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "141-163",
          "snippet": "void Y2ProgramComponent::result(const YCPValue& result)\n{\n    // It may be, that no evaluate() call has been issued at all\n    // before the call to this function(). This is likely to happen\n    // in the context of the SCR. For each MountAgent() all it\n    // creates the component that handles the certain path. But\n    // if it may well be that some paths are not used in one\n    // run of YaST2. In that case no evaluate() for that agent\n    // has been issued. Therefore at this point the external\n    // program may not have been started after all. So we need\n    // to check, if it's running.\n    \n    if (pid != -1)\n    {\n\tYCPTerm resultterm(\"result\");\n\tresultterm->add(result);\n\tsendToExternal(resultterm);\n\n        y2milestone (\"Sending result: %s\", resultterm->toString ().c_str ());\n\n\tterminateExternalProgram();\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::result(const YCPValue& result)\n  {\n      // It may be, that no evaluate() call has been issued at all\n      // before the call to this function(). This is likely to happen\n      // in the context of the SCR. For each MountAgent() all it\n      // creates the component that handles the certain path. But\n      // if it may well be that some paths are not used in one\n      // run of YaST2. In that case no evaluate() for that agent\n      // has been issued. Therefore at this point the external\n      // program may not have been started after all. So we need\n      // to check, if it's running.\n      \n      if (pid != -1)\n      {\n  \tYCPTerm resultterm(\"result\");\n  \tresultterm->add(result);\n  \tsendToExternal(resultterm);\n  \n          y2milestone (\"Sending result: %s\", resultterm->toString ().c_str ());\n  \n  \tterminateExternalProgram();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "client->doActualWork",
          "args": [
            "arglist",
            "server"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "doActualWork",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "172-261",
          "snippet": "YCPValue Y2ProgramComponent::doActualWork(const YCPList& arglist, Y2Component *user_interface)\n{\n    int argc;      // this shadows the corresponding member variables for servers\n    char **argv;\n\n    if (is_non_y2)   // this is a nony2 program like a shell and such like\n    {\n\tint arg = 0;\n\n\t// Prepare arguments as command line parameters for program being called\n\targc = !arglist.isNull() ? arglist->size() + 1 : 1;\n\targv = new char *[argc+1];\n\targv[0] = strdup((name().c_str()));\n\targv[argc] = NULL;\n\n\tfor (arg = 1; arg < argc; arg++)\n\t{\n\t    YCPValue a = arglist->value(arg-1);\n\t    if (a->isString())\n\t    {\n\t\targv[arg] = strdup(a->asString()->value().c_str());\n\t    }\n\t    else\n\t    {\n\t\targv[arg] = strdup(a->toString().c_str());\n\t    }\n\t}\n\n\t// launch component if not yet done\n\tif (pid == -1) launchExternalProgram(argv);\n\n\tif (argv)\n\t{\n\t    for (arg = 0; arg < argc; arg++)\n\t    {\n\t\tif (argv[arg])\n\t\t{\n\t\t    free(argv[arg]);\n\t\t}\n\t    }\n\t    delete[] argv;\n\t}\n    }\n    else   // this is a real liby2 component\n    {\n\t// send arguments via stdio\n\targc = 4;   // name, -s\n\targv = new char *[argc+1];\n\targv[0] = strdup(name().c_str());\n\targv[1] = argv[0];\n\targv[2] = \"-s\";    // get arguments on stdin\n\targv[3] = \"stdio\"; // communicate via stdio\n\targv[argc] = NULL;\n\n\t// launch component if not yet done\n\tif (pid == -1) launchExternalProgram(argv);\n\n\tsendToExternal(arglist);   // now send arguments\n\n\tif (argv)\n\t{\n\t    if (argv[0]) free(argv[0]);\n\t    delete[] argv;\n\t}\n    }\n\n    // Communication loop with module. Module sends 'result(...)',\n    // when finished\n    YCPValue retval = YCPNull();\n    YCPValue value = YCPNull();\n\n    while (!(value = receiveFromExternal()).isNull())\n    {\n\tif (value->isTerm()\n\t    && value->asTerm()->size() == 1\n\t    && value->asTerm()->name() == \"result\")\n\t{\n\t    retval = value->asTerm()->value(0);\n\t    y2debug (\"Got result from client component %s: %s\", name().c_str(), retval->toString().c_str());\n\t    break;\n\t}\n\telse\n\t{\n\t    // Send this to the UI and get UI answer\n\t    sendToExternal(user_interface->evaluate(value));\n\t}\n    }\n\n    return !retval.isNull() ? retval : YCPVoid();\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  YCPValue Y2ProgramComponent::doActualWork(const YCPList& arglist, Y2Component *user_interface)\n  {\n      int argc;      // this shadows the corresponding member variables for servers\n      char **argv;\n  \n      if (is_non_y2)   // this is a nony2 program like a shell and such like\n      {\n  \tint arg = 0;\n  \n  \t// Prepare arguments as command line parameters for program being called\n  \targc = !arglist.isNull() ? arglist->size() + 1 : 1;\n  \targv = new char *[argc+1];\n  \targv[0] = strdup((name().c_str()));\n  \targv[argc] = NULL;\n  \n  \tfor (arg = 1; arg < argc; arg++)\n  \t{\n  \t    YCPValue a = arglist->value(arg-1);\n  \t    if (a->isString())\n  \t    {\n  \t\targv[arg] = strdup(a->asString()->value().c_str());\n  \t    }\n  \t    else\n  \t    {\n  \t\targv[arg] = strdup(a->toString().c_str());\n  \t    }\n  \t}\n  \n  \t// launch component if not yet done\n  \tif (pid == -1) launchExternalProgram(argv);\n  \n  \tif (argv)\n  \t{\n  \t    for (arg = 0; arg < argc; arg++)\n  \t    {\n  \t\tif (argv[arg])\n  \t\t{\n  \t\t    free(argv[arg]);\n  \t\t}\n  \t    }\n  \t    delete[] argv;\n  \t}\n      }\n      else   // this is a real liby2 component\n      {\n  \t// send arguments via stdio\n  \targc = 4;   // name, -s\n  \targv = new char *[argc+1];\n  \targv[0] = strdup(name().c_str());\n  \targv[1] = argv[0];\n  \targv[2] = \"-s\";    // get arguments on stdin\n  \targv[3] = \"stdio\"; // communicate via stdio\n  \targv[argc] = NULL;\n  \n  \t// launch component if not yet done\n  \tif (pid == -1) launchExternalProgram(argv);\n  \n  \tsendToExternal(arglist);   // now send arguments\n  \n  \tif (argv)\n  \t{\n  \t    if (argv[0]) free(argv[0]);\n  \t    delete[] argv;\n  \t}\n      }\n  \n      // Communication loop with module. Module sends 'result(...)',\n      // when finished\n      YCPValue retval = YCPNull();\n      YCPValue value = YCPNull();\n  \n      while (!(value = receiveFromExternal()).isNull())\n      {\n  \tif (value->isTerm()\n  \t    && value->asTerm()->size() == 1\n  \t    && value->asTerm()->name() == \"result\")\n  \t{\n  \t    retval = value->asTerm()->value(0);\n  \t    y2debug (\"Got result from client component %s: %s\", name().c_str(), retval->toString().c_str());\n  \t    break;\n  \t}\n  \telse\n  \t{\n  \t    // Send this to the UI and get UI answer\n  \t    sendToExternal(user_interface->evaluate(value));\n  \t}\n      }\n  \n      return !retval.isNull() ? retval : YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2milestone",
          "args": [
            "\"YAST_IS_RUNNING is %s\"",
            "getenv (\"YAST_IS_RUNNING\")"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"YAST_IS_RUNNING\""
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"YAST_IS_RUNNING\"",
            "\"yes\"",
            "1"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"YAST_IS_RUNNING\"",
            "\"instsys\"",
            "1"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arglist->contains",
          "args": [
            "YCPString (\"initial\")"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "contains",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "111-114",
          "snippet": "bool YCPListRep::contains (const YCPValue& value) const\n{\n    return find_if(begin(), end(), bind2nd(ycp_equal_to(), value)) != end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  bool YCPListRep::contains (const YCPValue& value) const\n  {\n      return find_if(begin(), end(), bind2nd(ycp_equal_to(), value)) != end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "\"initial\""
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "client_name",
            "\"installation\""
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "client_name",
            "\"live-installer\""
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "YAST_OPTIONERROR"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_error",
          "args": [
            "\"Error while creating client module %s\"",
            "client_name"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dynamic_cast<Y2ErrorComponent *>",
          "args": [
            "client"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "YAST_OPTIONERROR"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_usage",
          "args": [],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "913-918",
          "snippet": "static void\nprint_usage()\n{\n    fprintf (stderr,\n\t     \"\\nRun 'yast2 -h' for help on usage\\n\");\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void print_usage ();"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic void print_usage ();\n\nstatic void\nprint_usage()\n{\n    fprintf (stderr,\n\t     \"\\nRun 'yast2 -h' for help on usage\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  %s\\n\"",
            "i->c_str()"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->c_str",
          "args": [],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"The search path follows. It does not include the current directory.\\n\""
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPPathSearch::searchListEnd",
          "args": [
            "YCPPathSearch::Client"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPPathSearch::searchListBegin",
          "args": [
            "YCPPathSearch::Client"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_error",
          "args": [
            "\"No such client module %s\"",
            "client_name"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2ComponentBroker::createClient",
          "args": [
            "client_name"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->evaluate",
          "args": [
            "preload->value(i)"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "69-138",
          "snippet": "YCPValue Y2ProgramComponent::evaluate(const YCPValue& command)\n{\n    if (pid == -1)   // server component not yet started --> do it\n    {\n\tif (is_non_y2)   // this is a nony2 program like a shell and such like\n\t{\n\t    // Prepare options: argv[0] must be server component name,\n\t    // argv[1] must _NOT_ be 'stdio' like for real Y2 components (see below).\n\t    // If no options have been set so far via setServerOptions(),\n\t    // fill in argv[0] correctly.\n\n\t    int l_argc = 1 + (argc > 0 ? argc - 1 : 0);\n\t    char **l_argv = new char *[l_argc + 1];\n\n\t    l_argv[0] = (argc >= 1) ? argv[0] : strdup(name().c_str()); // component name\n\t    for (int arg = 1; arg < argc; arg++) l_argv[arg] = argv[arg];\n\t    l_argv[l_argc] = 0; // Terminate array\n\n\t    // launch program\n\t    launchExternalProgram(l_argv);\n\n\t    // NonY2 servers will not send arguments to the client (me).\n\t    // Therefore it is not necessary to receive something in this case.\n\n\t    if (argc < 1) free (l_argv[0]);\n\t    if (l_argv) delete[] l_argv;  // free l_argv\n\t}\n\telse   // this is a real liby2 component\n\t{\n\t    // Prepare options: argv[0] must be server component name,\n\t    // argv[1] must be 'stdio' in order to make the gf of the\n\t    // called component communicate via stdio, argv[2...] contains\n\t    // all further options. If no options have been set so far\n\t    // via setServerOptions(), fill in argv[0] correctly.\n\n\t    int l_argc = 3 + (argc > 0 ? argc - 1 : 0);\n\t    char **l_argv = new char *[l_argc + 1];\n\n\t    l_argv[0] = argc >= 1 ? argv[0] : strdup(name().c_str()); // component name\n\t    l_argv[1] = \"stdio\"; // I will speak to the server via his stdio\n\t    l_argv[2] = strdup(name().c_str());\n\t    for (int arg = 1; arg < argc; arg++) l_argv[arg+2] = argv[arg];\n\t    l_argv[l_argc] = 0; // Terminate array\n\n\t    // launch program\n\t    launchExternalProgram(l_argv);\n\n\t    // I am myself a module in this context. Therefore the server\n\t    // will send me my arguments. Since I initiated the session\n\t    // myself, I am not interested in these arguments.\n\n\t    if (receiveFromExternal().isNull())\n\t    {\n\t\ty2error (\"Couldn't launch external server %s\", name().c_str ());\n\t\treturn YCPNull ();\n\t    }\n\n\t    if (argc < 1) free (l_argv[0]);\n\t    free (l_argv[2]);\n\t    delete[] l_argv;  // free l_argv\n\t}\n    }\n\n    // send command\n    sendToExternal (command);\n\n    // get answer\n    YCPValue retval = receiveFromExternal();\n    return !retval.isNull() ? retval : YCPVoid();\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  YCPValue Y2ProgramComponent::evaluate(const YCPValue& command)\n  {\n      if (pid == -1)   // server component not yet started --> do it\n      {\n  \tif (is_non_y2)   // this is a nony2 program like a shell and such like\n  \t{\n  \t    // Prepare options: argv[0] must be server component name,\n  \t    // argv[1] must _NOT_ be 'stdio' like for real Y2 components (see below).\n  \t    // If no options have been set so far via setServerOptions(),\n  \t    // fill in argv[0] correctly.\n  \n  \t    int l_argc = 1 + (argc > 0 ? argc - 1 : 0);\n  \t    char **l_argv = new char *[l_argc + 1];\n  \n  \t    l_argv[0] = (argc >= 1) ? argv[0] : strdup(name().c_str()); // component name\n  \t    for (int arg = 1; arg < argc; arg++) l_argv[arg] = argv[arg];\n  \t    l_argv[l_argc] = 0; // Terminate array\n  \n  \t    // launch program\n  \t    launchExternalProgram(l_argv);\n  \n  \t    // NonY2 servers will not send arguments to the client (me).\n  \t    // Therefore it is not necessary to receive something in this case.\n  \n  \t    if (argc < 1) free (l_argv[0]);\n  \t    if (l_argv) delete[] l_argv;  // free l_argv\n  \t}\n  \telse   // this is a real liby2 component\n  \t{\n  \t    // Prepare options: argv[0] must be server component name,\n  \t    // argv[1] must be 'stdio' in order to make the gf of the\n  \t    // called component communicate via stdio, argv[2...] contains\n  \t    // all further options. If no options have been set so far\n  \t    // via setServerOptions(), fill in argv[0] correctly.\n  \n  \t    int l_argc = 3 + (argc > 0 ? argc - 1 : 0);\n  \t    char **l_argv = new char *[l_argc + 1];\n  \n  \t    l_argv[0] = argc >= 1 ? argv[0] : strdup(name().c_str()); // component name\n  \t    l_argv[1] = \"stdio\"; // I will speak to the server via his stdio\n  \t    l_argv[2] = strdup(name().c_str());\n  \t    for (int arg = 1; arg < argc; arg++) l_argv[arg+2] = argv[arg];\n  \t    l_argv[l_argc] = 0; // Terminate array\n  \n  \t    // launch program\n  \t    launchExternalProgram(l_argv);\n  \n  \t    // I am myself a module in this context. Therefore the server\n  \t    // will send me my arguments. Since I initiated the session\n  \t    // myself, I am not interested in these arguments.\n  \n  \t    if (receiveFromExternal().isNull())\n  \t    {\n  \t\ty2error (\"Couldn't launch external server %s\", name().c_str ());\n  \t\treturn YCPNull ();\n  \t    }\n  \n  \t    if (argc < 1) free (l_argv[0]);\n  \t    free (l_argv[2]);\n  \t    delete[] l_argv;  // free l_argv\n  \t}\n      }\n  \n      // send command\n      sendToExternal (command);\n  \n      // get answer\n      YCPValue retval = receiveFromExternal();\n      return !retval.isNull() ? retval : YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "preload->value",
          "args": [
            "i"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "preload->size",
          "args": [],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->setServerOptions",
          "args": [
            "argc-arg+1",
            "server_argv"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "setServerOptions",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "62-66",
          "snippet": "void Y2ProgramComponent::setServerOptions (int argc, char **argv)\n{\n    this->argc = argc;\n    this->argv = argv;\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::setServerOptions (int argc, char **argv)\n  {\n      this->argc = argc;\n      this->argv = argv;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "server_name"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "5"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_error",
          "args": [
            "\"No such server module %s\"",
            "server_name"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2ComponentBroker::createServer",
          "args": [
            "server_name"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Creating server \\\"%s\\\"\"",
            "server_name"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2ComponentBroker::getNamespaceComponent",
          "args": [
            "\"UI\""
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2ComponentBroker::registerNamespaceException",
          "args": [
            "\"UI\"",
            "server_name"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "registerNamespaceException",
          "container": "Y2ComponentBroker",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ComponentBroker.cc",
          "lines": "183-196",
          "snippet": "bool Y2ComponentBroker::registerNamespaceException(const char* name_space, const char* component_name)\n{\n    map<const char*, const Y2Component*, ltstr>::iterator ci = namespaces.find (name_space);\n    if ( ci != namespaces.end () )\n    {\n        const Y2Component *c = ci->second;\n        y2error (\"namespace %s already instantiated by %p\", name_space, c );\n        return false;\n    }\n\n    namespace_exceptions.insert ( std::pair<string,string>(name_space,component_name) );\n    \n    return true;\n}",
          "includes": [
            "#include <y2util/y2log.h>",
            "#include <ycp/pathsearch.h>",
            "#include \"Y2ComponentCreator.h\"",
            "#include \"Y2ComponentBroker.h\"",
            "#include <dlfcn.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "map<const char*, const Y2Component*, Y2ComponentBroker::ltstr> Y2ComponentBroker::namespaces;",
            "map<string, string> Y2ComponentBroker::namespace_exceptions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/y2log.h>\n#include <ycp/pathsearch.h>\n#include \"Y2ComponentCreator.h\"\n#include \"Y2ComponentBroker.h\"\n#include <dlfcn.h>\n#include <stdio.h>\n\nmap<const char*, const Y2Component*, Y2ComponentBroker::ltstr> Y2ComponentBroker::namespaces;\nmap<string, string> Y2ComponentBroker::namespace_exceptions;\n\nY2ComponentBroker {\n  bool Y2ComponentBroker::registerNamespaceException(const char* name_space, const char* component_name)\n  {\n      map<const char*, const Y2Component*, ltstr>::iterator ci = namespaces.find (name_space);\n      if ( ci != namespaces.end () )\n      {\n          const Y2Component *c = ci->second;\n          y2error (\"namespace %s already instantiated by %p\", name_space, c );\n          return false;\n      }\n  \n      namespace_exceptions.insert ( std::pair<string,string>(name_space,component_name) );\n      \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_server_and_options",
          "args": [
            "argc",
            "argv",
            "arg",
            "server_name",
            "preload"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "parse_server_and_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "497-586",
          "snippet": "void\nparse_server_and_options (int argc, char ** argv, int& arg, char *& server_name, YCPList& preload)\n{\n    if (arg >= argc)\n    {\n\tfprintf(stderr, \"No server module given\\n\");\n\tprint_usage ();\n\texit (YAST_OPTIONERROR);\n    }\n\n    // now create server\n    if (!argv[arg]) {\n\tprint_usage ();\n\texit (YAST_FEWARGUMENTS);\n    }\n\n    server_name = argv[arg];\n    arg++;   // next argument (first server option)\n\n    // Prepare server and general options\n\n    while (arg < argc)\n    {\n\tif (!strcmp(argv[arg], \"-l\") || !strcmp(argv[arg], \"--logfile\"))\n\t{\n\t    // Logfile already done at program start --> ignore here\n\t    arg++;   // skip filename\n\t}\n\telse if (!strcmp(argv[arg], \"-p\"))   // preload\n\t{\n\t    arg++;   // switch to filename\n\n\t    if (arg >= argc)\n\t    {\n\t\tprint_error (\"Server option -p is missing an argument\");\n\t\tprint_usage();\n\t\texit(5);\n\t    }\n\n\t    FILE *file = fopen (argv[arg], \"r\");\n\t    if (!file)\n\t    {\n\t\tprint_error (\"Client option -p: Couldn't open %s for reading\", argv[arg]);\n\t\texit(5);\n\t    }\n\n\t    bool one_value_parsed = false;\n\n\t    while (!feof(file))\t  // Parse all values until EOF\n\t    {\n\t\tParser parser(file, argv[arg]);   // set parser to file\n\n\t\tYCodePtr pc = parser.parse ();\n\n\t\tif (pc)\n\t\t{\n\t\t    preload->add(pc->evaluate (true));   // add to preload list\n\t\t    one_value_parsed = true;\n\t\t}\n\t    }\n\n\t    fclose (file);\n\n\t    if (!one_value_parsed)\n\t    {\n\t\tprint_error (\"Server option -p: Couldn't parse a valid YCP value from file %s\",\n\t\t\t     argv[arg]);\n\t\texit(5);\n\t    }\n\t}\n\telse if (has_parens (argv[arg]))\t// option is a YCP value -> parse it directly\n\t{\n\t    Parser parser (argv[arg]);\t// set parser to option\n\n\t    YCodePtr pc = parser.parse ();\n\n\t    if (!pc)\n\t    {\n\t\tprint_error (\"Server option %s is not a valid YCP value\", argv[arg]);\n\t\texit(5);\n\t    }\n\n\t    preload->add (pc->evaluate (true));\t// add to preload list\n\t}\n\telse break; // specific server options\n\n\targ++;\t    // switch to next argument\n    }\t// parsing server options\n\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void print_usage ();",
            "static bool has_parens (const char* arg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic void print_usage ();\nstatic bool has_parens (const char* arg);\n\nvoid\nparse_server_and_options (int argc, char ** argv, int& arg, char *& server_name, YCPList& preload)\n{\n    if (arg >= argc)\n    {\n\tfprintf(stderr, \"No server module given\\n\");\n\tprint_usage ();\n\texit (YAST_OPTIONERROR);\n    }\n\n    // now create server\n    if (!argv[arg]) {\n\tprint_usage ();\n\texit (YAST_FEWARGUMENTS);\n    }\n\n    server_name = argv[arg];\n    arg++;   // next argument (first server option)\n\n    // Prepare server and general options\n\n    while (arg < argc)\n    {\n\tif (!strcmp(argv[arg], \"-l\") || !strcmp(argv[arg], \"--logfile\"))\n\t{\n\t    // Logfile already done at program start --> ignore here\n\t    arg++;   // skip filename\n\t}\n\telse if (!strcmp(argv[arg], \"-p\"))   // preload\n\t{\n\t    arg++;   // switch to filename\n\n\t    if (arg >= argc)\n\t    {\n\t\tprint_error (\"Server option -p is missing an argument\");\n\t\tprint_usage();\n\t\texit(5);\n\t    }\n\n\t    FILE *file = fopen (argv[arg], \"r\");\n\t    if (!file)\n\t    {\n\t\tprint_error (\"Client option -p: Couldn't open %s for reading\", argv[arg]);\n\t\texit(5);\n\t    }\n\n\t    bool one_value_parsed = false;\n\n\t    while (!feof(file))\t  // Parse all values until EOF\n\t    {\n\t\tParser parser(file, argv[arg]);   // set parser to file\n\n\t\tYCodePtr pc = parser.parse ();\n\n\t\tif (pc)\n\t\t{\n\t\t    preload->add(pc->evaluate (true));   // add to preload list\n\t\t    one_value_parsed = true;\n\t\t}\n\t    }\n\n\t    fclose (file);\n\n\t    if (!one_value_parsed)\n\t    {\n\t\tprint_error (\"Server option -p: Couldn't parse a valid YCP value from file %s\",\n\t\t\t     argv[arg]);\n\t\texit(5);\n\t    }\n\t}\n\telse if (has_parens (argv[arg]))\t// option is a YCP value -> parse it directly\n\t{\n\t    Parser parser (argv[arg]);\t// set parser to option\n\n\t    YCodePtr pc = parser.parse ();\n\n\t    if (!pc)\n\t    {\n\t\tprint_error (\"Server option %s is not a valid YCP value\", argv[arg]);\n\t\texit(5);\n\t    }\n\n\t    preload->add (pc->evaluate (true));\t// add to preload list\n\t}\n\telse break; // specific server options\n\n\targ++;\t    // switch to next argument\n    }\t// parsing server options\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "arglist->add",
          "args": [
            "YCPSymbol(\"debugger\")"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPSymbol",
          "args": [
            "\"debugger\""
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "YCPSymbol",
          "container": "YCPSymbol",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "104-107",
          "snippet": "YCPSymbol::YCPSymbol (bytecodeistream & str)\n    : YCPValue (new YCPSymbolRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbol {\n  YCPSymbol::YCPSymbol (bytecodeistream & str)\n      : YCPValue (new YCPSymbolRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_client_and_options",
          "args": [
            "argc",
            "argv",
            "arg",
            "client_name",
            "arglist"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "parse_client_and_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "372-495",
          "snippet": "void\nparse_client_and_options (int argc, char ** argv, int& arg, char  *& client_name, YCPList& arglist)\n{\n    bool args_are_ycp = true;\n\n    if (!argv[arg]) {\n\tprint_usage ();\n\texit (YAST_FEWARGUMENTS);\n    }\n\n    client_name = argv[arg];\n    arg++;   // next argument (first client option)\n\n    // Prepare client options\n    while (arg < argc)\n    {\n\tif (!strcmp(argv[arg], \"-l\") || !strcmp(argv[arg], \"--logfile\"))\n\t{\n\t    // Logfile already done at program start --> ignore here\n\t    arg++;   // skip filename\n\t}\n\telse if (!strcmp(argv[arg], \"-c\") || !strcmp(argv[arg], \"--logconf\"))\n\t{\n\t    // Logfile already done at program start --> ignore here\n\t    arg++;   // skip filename\n\t}\n\telse if (!strcmp(argv[arg], \"-S\"))\n\t{\n\t    args_are_ycp = false;\n\t}\n\telse if (!strcmp(argv[arg], \"-s\"))\t// Parse one value (YCPList of options) from stdin\n\t{\n\t    Parser parser (0, \"<stdin>\");\t// set parser to stdin\n\t    YCodePtr pc = parser.parse ();\n\n\t    YCPValue option = YCPNull ();\n\t    if (pc)\n\t    {\n\t\toption = pc->evaluate(true);\t// get one value (should be a YCPList)\n\t    }\n\n\t    if (option.isNull())\n\t    {\n\t\tprint_error (\"Client option -s: Couldn't parse valid YCP value from stdin\");\n\t\texit (YAST_OPTIONERROR);\n\t    }\n\n\t    if (!option->isList())\n\t    {\n\t\tprint_error (\"Client option -s: Parsed YCP value is NOT a YCPList\");\n\t\texit (YAST_OPTIONERROR);\n\t    }\n\n\t    arglist = option->asList();\t  // the option read _IS_ arglist\n\t}\n\telse if (!strcmp(argv[arg], \"-f\"))\t// Parse values from file\n\t{\n\t    arg++;   // switch to filename\n\n\t    if (arg >= argc)\n\t    {\n\t\tprint_error (\"Client option -f is missing an argument\");\n\t\tprint_usage();\n\t\texit(5);\n\t    }\n\n\t    FILE *file = fopen (argv[arg], \"r\");\n\t    if (!file)\n\t    {\n\t\tprint_error (\"Client option -f: Couldn't open %s for reading\", argv[arg]);\n\t\texit(5);\n\t    }\n\n\t    bool one_value_parsed = false;\n\n\t    while (!feof(file))\t  // Parse all values until EOF\n\t    {\n\t\tParser parser(file, argv[arg]);   // set parser to file\n\n\t\tYCodePtr pc = parser.parse ();\n\n\t\tif ( pc )\n\t\t{\n\t\t    arglist->add( pc->evaluate(true) );\n\t\t    one_value_parsed = true;\n\t\t}\n\t    }\n\n\t    fclose (file);\n\n\t    if (!one_value_parsed)\n\t    {\n\t\tprint_error (\"Client option -f: Couldn't parse valid YCP value from file %s\",\n\t\t\t     argv[arg]);\n\t\texit(5);\n\t    }\n\t}\n\telse if (has_parens (argv[arg]))\t// client args\n\t{\n\t  if (args_are_ycp)\t// bnc#382883\n\t  {\n\t    Parser parser (argv[arg]);\t// set parser to option\n\n\t    YCodePtr pc = parser.parse ();\n\n\t    if (!pc )\n\t    {\n\t\tprint_error (\"Client option %s is not a valid YCP value\", argv[arg]);\n\t\texit(5);\n\t    }\n\n\t    arglist->add( pc->evaluate (true));   // add to arglist\n\t  }\n\t  else\n\t  {\n\t      string value(argv[arg] + 1, strlen (argv[arg]) - 2);\n\t      arglist->add (YCPString (value));\n\t  }\n\t}\n\telse break;   // must be server name\n\n\targ++;\t      // switch to next argument\n    } // Parsing client options\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void print_usage ();",
            "static bool has_parens (const char* arg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic void print_usage ();\nstatic bool has_parens (const char* arg);\n\nvoid\nparse_client_and_options (int argc, char ** argv, int& arg, char  *& client_name, YCPList& arglist)\n{\n    bool args_are_ycp = true;\n\n    if (!argv[arg]) {\n\tprint_usage ();\n\texit (YAST_FEWARGUMENTS);\n    }\n\n    client_name = argv[arg];\n    arg++;   // next argument (first client option)\n\n    // Prepare client options\n    while (arg < argc)\n    {\n\tif (!strcmp(argv[arg], \"-l\") || !strcmp(argv[arg], \"--logfile\"))\n\t{\n\t    // Logfile already done at program start --> ignore here\n\t    arg++;   // skip filename\n\t}\n\telse if (!strcmp(argv[arg], \"-c\") || !strcmp(argv[arg], \"--logconf\"))\n\t{\n\t    // Logfile already done at program start --> ignore here\n\t    arg++;   // skip filename\n\t}\n\telse if (!strcmp(argv[arg], \"-S\"))\n\t{\n\t    args_are_ycp = false;\n\t}\n\telse if (!strcmp(argv[arg], \"-s\"))\t// Parse one value (YCPList of options) from stdin\n\t{\n\t    Parser parser (0, \"<stdin>\");\t// set parser to stdin\n\t    YCodePtr pc = parser.parse ();\n\n\t    YCPValue option = YCPNull ();\n\t    if (pc)\n\t    {\n\t\toption = pc->evaluate(true);\t// get one value (should be a YCPList)\n\t    }\n\n\t    if (option.isNull())\n\t    {\n\t\tprint_error (\"Client option -s: Couldn't parse valid YCP value from stdin\");\n\t\texit (YAST_OPTIONERROR);\n\t    }\n\n\t    if (!option->isList())\n\t    {\n\t\tprint_error (\"Client option -s: Parsed YCP value is NOT a YCPList\");\n\t\texit (YAST_OPTIONERROR);\n\t    }\n\n\t    arglist = option->asList();\t  // the option read _IS_ arglist\n\t}\n\telse if (!strcmp(argv[arg], \"-f\"))\t// Parse values from file\n\t{\n\t    arg++;   // switch to filename\n\n\t    if (arg >= argc)\n\t    {\n\t\tprint_error (\"Client option -f is missing an argument\");\n\t\tprint_usage();\n\t\texit(5);\n\t    }\n\n\t    FILE *file = fopen (argv[arg], \"r\");\n\t    if (!file)\n\t    {\n\t\tprint_error (\"Client option -f: Couldn't open %s for reading\", argv[arg]);\n\t\texit(5);\n\t    }\n\n\t    bool one_value_parsed = false;\n\n\t    while (!feof(file))\t  // Parse all values until EOF\n\t    {\n\t\tParser parser(file, argv[arg]);   // set parser to file\n\n\t\tYCodePtr pc = parser.parse ();\n\n\t\tif ( pc )\n\t\t{\n\t\t    arglist->add( pc->evaluate(true) );\n\t\t    one_value_parsed = true;\n\t\t}\n\t    }\n\n\t    fclose (file);\n\n\t    if (!one_value_parsed)\n\t    {\n\t\tprint_error (\"Client option -f: Couldn't parse valid YCP value from file %s\",\n\t\t\t     argv[arg]);\n\t\texit(5);\n\t    }\n\t}\n\telse if (has_parens (argv[arg]))\t// client args\n\t{\n\t  if (args_are_ycp)\t// bnc#382883\n\t  {\n\t    Parser parser (argv[arg]);\t// set parser to option\n\n\t    YCodePtr pc = parser.parse ();\n\n\t    if (!pc )\n\t    {\n\t\tprint_error (\"Client option %s is not a valid YCP value\", argv[arg]);\n\t\texit(5);\n\t    }\n\n\t    arglist->add( pc->evaluate (true));   // add to arglist\n\t  }\n\t  else\n\t  {\n\t      string value(argv[arg] + 1, strlen (argv[arg]) - 2);\n\t      arglist->add (YCPString (value));\n\t  }\n\t}\n\telse break;   // must be server name\n\n\targ++;\t      // switch to next argument\n    } // Parsing client options\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPPathSearch::addPath",
          "args": [
            "YCPPathSearch::Module",
            "pathit->c_str()"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "addPath",
          "container": "YCPPathSearch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/pathsearch.cc",
          "lines": "343-349",
          "snippet": "void\nYCPPathSearch::addPath (Kind kind, const string& path)\n{\n    std::list<string>& l = searchList[kind];\n    if (std::find(l.begin(), l.end(), path) == l.end())\n\tl.push_front(path);\n}",
          "includes": [
            "#include \"pathsearch.h\"",
            "#include <ycp/y2log.h>",
            "#include <boost/algorithm/string.hpp>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "std::list<string> YCPPathSearch::searchList[YCPPathSearch::num_Kind];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pathsearch.h\"\n#include <ycp/y2log.h>\n#include <boost/algorithm/string.hpp>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n\nstd::list<string> YCPPathSearch::searchList[YCPPathSearch::num_Kind];\n\nYCPPathSearch {\n  void\n  YCPPathSearch::addPath (Kind kind, const string& path)\n  {\n      std::list<string>& l = searchList[kind];\n      if (std::find(l.begin(), l.end(), path) == l.end())\n  \tl.push_front(path);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathit->c_str",
          "args": [],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modpaths.end",
          "args": [],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modpaths.begin",
          "args": [],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathit->c_str",
          "args": [],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modpaths.push_front",
          "args": [
            "string (argv[arg])"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "argv[arg]"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"-M\""
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "incpaths.push_front",
          "args": [
            "string (argv[arg])"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"-I\""
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugger_instance->initialize",
          "args": [
            "debugger_remote"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "initialize",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "65-69",
          "snippet": "bool Debugger::initialize(bool remote)\n{\n    m_remote = remote;\n    return remote ? initializeRemote() : initializeLocal();\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  bool Debugger::initialize(bool remote)\n  {\n      m_remote = remote;\n      return remote ? initializeRemote() : initializeLocal();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "getenv (\"Y2DEBUGGER\")",
            "\"2\""
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"Y2DEBUGGER\""
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "getenv (\"Y2DEBUGGER\")",
            "\"1\""
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"Y2DEBUGGER\""
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"Y2DEBUGGER\""
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"--debugger-remote\""
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"--debugger\""
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "YAST_OPTIONERROR"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_error",
          "args": [
            "\"Option %s argument must be in format namespace=component\"",
            "argv[arg-1]"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index",
          "args": [
            "argv[arg]",
            "'='"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"-n\""
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"--logfile\""
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"-l\""
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"--logconf\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"-c\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"--logfile\""
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"-l\""
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2milestone",
          "args": [
            "\"Launched YaST2 component '%s'%s\"",
            "progname",
            "argdump.str().c_str()"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argdump.str",
          "args": [],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": "DirStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/Pathname.cc",
          "lines": "102-114",
          "snippet": "string str() {\n      if ( !bot )\n\treturn \"\";\n      string ret;\n      for ( Dir * d = bot; d; d = d->up ) {\n\tif ( d != bot )\n\t  ret += \"/\";\n\tret += d->name;\n      }\n      if ( ret.empty() )\n\treturn \"/\";\n      return ret;\n    }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <iostream>\n\nDirStack {\n  string str() {\n        if ( !bot )\n  \treturn \"\";\n        string ret;\n        for ( Dir * d = bot; d; d = d->up ) {\n  \tif ( d != bot )\n  \t  ret += \"/\";\n  \tret += d->name;\n        }\n        if ( ret.empty() )\n  \treturn \"/\";\n        return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPPathSearch::initialize",
          "args": [],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "initialize",
          "container": "YCPPathSearch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/pathsearch.cc",
          "lines": "274-284",
          "snippet": "void\nYCPPathSearch::initialize ()\n{\n    if (! initialized)\n    {\n\tinitialize (Client, \"/clients\");\n\tinitialize (Include, \"/include\");\n\tinitialize (Module, \"/modules\");\n\tinitialized = true;\n    }\n}",
          "includes": [
            "#include \"pathsearch.h\"",
            "#include <ycp/y2log.h>",
            "#include <boost/algorithm/string.hpp>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool YCPPathSearch::initialized = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pathsearch.h\"\n#include <ycp/y2log.h>\n#include <boost/algorithm/string.hpp>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n\nbool YCPPathSearch::initialized = false;\n\nYCPPathSearch {\n  void\n  YCPPathSearch::initialize ()\n  {\n      if (! initialized)\n      {\n  \tinitialize (Client, \"/clients\");\n  \tinitialize (Include, \"/include\");\n  \tinitialize (Module, \"/modules\");\n  \tinitialized = true;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "0022"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_log_conf",
          "args": [
            "argv[arg]"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "set_log_conf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "516-554",
          "snippet": "void set_log_conf(string confname) {\n\n    did_read_logconf = true;\n\n    set_signal_handler (SIGUSR2);\n    set_signal_handler (SIGUSR1);\n\n    string logconfname = confname;\n    if(logconfname == \"\") {\n\t/* Read the logconf.ycp */\n\tstruct passwd *pw = getpwuid(geteuid());\n\tif(!pw) {\n\t    fprintf (stderr, \"Cannot read pwd entry for user \"\n\t\t    \"id %d. No logconf, using defaults.\\n\", geteuid ());\n\t    return;\n\t}\n\tif(getuid())\n\t    logconfname = string (pw->pw_dir) + \"/.yast2/\" + Y2LOG_CONF;\n\telse\n\t    logconfname = \"/etc/YaST2/\" Y2LOG_CONF;\n    }\n\n    if(getenv(Y2LOG_VAR_ALL)) log_all_variable = true;\n\n    /* We have to remember the errno. Otherwise a call of\n     * y2error (\"error: %m\") can display a wrong message. */\n    int save_errno = errno;\n    inifile i = miniini(logconfname.c_str());\n    logconf = i[\"Debug\"];\n\n    log_to_file = i[\"Log\"][\"file\"] != \"false\";\n    log_to_syslog = i[\"Log\"][\"syslog\"] == \"true\";\n    log_debug = (i[\"Log\"][\"debug\"] == \"true\") || getenv(Y2LOG_VAR_DEBUG);\n\n    if(i[\"Log\"][\"filename\"] != \"\")\n\tlogname = strdup(i[\"Log\"][\"filename\"].c_str());\n\n    errno = save_errno;\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2LOG_VAR_ALL\t\"Y2DEBUGALL\"",
            "#define Y2LOG_VAR_DEBUG\t\"Y2DEBUG\"",
            "#define Y2LOG_CONF\t\"log.conf\"\t/* Relative to $HOME or /etc/YaST2 */"
          ],
          "globals_used": [
            "inisection logconf;",
            "static sig_atomic_t did_read_logconf = 0;",
            "static const char *logname;",
            "static sig_atomic_t log_debug = false;",
            "static bool log_to_file = true;",
            "static bool log_to_syslog = false;",
            "static bool log_all_variable = false;",
            "static void shift_log_files(string filename);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_VAR_ALL\t\"Y2DEBUGALL\"\n#define Y2LOG_VAR_DEBUG\t\"Y2DEBUG\"\n#define Y2LOG_CONF\t\"log.conf\"\t/* Relative to $HOME or /etc/YaST2 */\n\ninisection logconf;\nstatic sig_atomic_t did_read_logconf = 0;\nstatic const char *logname;\nstatic sig_atomic_t log_debug = false;\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic bool log_all_variable = false;\nstatic void shift_log_files(string filename);\n\nvoid set_log_conf(string confname) {\n\n    did_read_logconf = true;\n\n    set_signal_handler (SIGUSR2);\n    set_signal_handler (SIGUSR1);\n\n    string logconfname = confname;\n    if(logconfname == \"\") {\n\t/* Read the logconf.ycp */\n\tstruct passwd *pw = getpwuid(geteuid());\n\tif(!pw) {\n\t    fprintf (stderr, \"Cannot read pwd entry for user \"\n\t\t    \"id %d. No logconf, using defaults.\\n\", geteuid ());\n\t    return;\n\t}\n\tif(getuid())\n\t    logconfname = string (pw->pw_dir) + \"/.yast2/\" + Y2LOG_CONF;\n\telse\n\t    logconfname = \"/etc/YaST2/\" Y2LOG_CONF;\n    }\n\n    if(getenv(Y2LOG_VAR_ALL)) log_all_variable = true;\n\n    /* We have to remember the errno. Otherwise a call of\n     * y2error (\"error: %m\") can display a wrong message. */\n    int save_errno = errno;\n    inifile i = miniini(logconfname.c_str());\n    logconf = i[\"Debug\"];\n\n    log_to_file = i[\"Log\"][\"file\"] != \"false\";\n    log_to_syslog = i[\"Log\"][\"syslog\"] == \"true\";\n    log_debug = (i[\"Log\"][\"debug\"] == \"true\") || getenv(Y2LOG_VAR_DEBUG);\n\n    if(i[\"Log\"][\"filename\"] != \"\")\n\tlogname = strdup(i[\"Log\"][\"filename\"].c_str());\n\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "5"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_error",
          "args": [
            "\"Option %s is missing an argument\"",
            "argv[arg-1]"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"--logconf\""
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"-c\""
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_log_filename",
          "args": [
            "argv[arg]"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "set_log_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2changes.cc",
          "lines": "188-240",
          "snippet": "static void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2CHANGES_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2CHANGES_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2CHANGES_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2CHANGES_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2CHANGES_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2CHANGES_FALLBACK );\n\n\t\tlogname = Y2CHANGES_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2CHANGES_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2CHANGES_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2CHANGES_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2CHANGES_VAR_NUM\t\"Y2MAXLOGNUM\"",
            "#define Y2CHANGES_VAR_SIZE\t\"Y2MAXLOGSIZE\"",
            "#define Y2CHANGES_FALLBACK\t\"/y2changes\"",
            "#define Y2CHANGES_USER\t\"/.y2changes\"\t\t/* Relative to $HOME */",
            "#define Y2CHANGES_ROOT\tLOGDIR \"/y2changes\"",
            "#define Y2CHANGES_MAXNUM\t10\t\t\t/* Maximum logfiles number */",
            "#define Y2CHANGES_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */"
          ],
          "globals_used": [
            "static bool did_set_logname = false;",
            "static const char *logname;",
            "static off_t maxlogsize;",
            "static int   maxlognum;",
            "static bool log_to_file = true;",
            "static bool log_to_syslog = false;",
            "static FILE *Y2CHANGES_STDERR = stderr;",
            "static void shift_log_files(string filename);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/y2changes.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2CHANGES_VAR_NUM\t\"Y2MAXLOGNUM\"\n#define Y2CHANGES_VAR_SIZE\t\"Y2MAXLOGSIZE\"\n#define Y2CHANGES_FALLBACK\t\"/y2changes\"\n#define Y2CHANGES_USER\t\"/.y2changes\"\t\t/* Relative to $HOME */\n#define Y2CHANGES_ROOT\tLOGDIR \"/y2changes\"\n#define Y2CHANGES_MAXNUM\t10\t\t\t/* Maximum logfiles number */\n#define Y2CHANGES_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */\n\nstatic bool did_set_logname = false;\nstatic const char *logname;\nstatic off_t maxlogsize;\nstatic int   maxlognum;\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic FILE *Y2CHANGES_STDERR = stderr;\nstatic void shift_log_files(string filename);\n\nstatic void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2CHANGES_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2CHANGES_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2CHANGES_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2CHANGES_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2CHANGES_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2CHANGES_FALLBACK );\n\n\t\tlogname = Y2CHANGES_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2CHANGES_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2CHANGES_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2CHANGES_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "5"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_error",
          "args": [
            "\"Option %s is missing an argument\"",
            "argv[arg-1]"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"--logfile\""
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"-l\""
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "5"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nPlease give client and server as arguments\""
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "YAST_OK"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_help",
          "args": [],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "print_help",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "921-955",
          "snippet": "static void\nprint_help()\n{\n    fprintf (stderr, \"\\n\"\n\t     \"Usage: %s [GenericOpts] Client [ClientOpts] Server [Generic ServerOpts] \"\n\t     \"[Specific ServerOpts]\\n\",\n\t     progname);\n\n    fprintf (stderr,\n\t     \"GenericOptions are:\\n\"\n\t     \"    -l | --logfile LogFile    : Set logfile\\n\"\n\t     \"    -c | --logconf ConfFile   : Configure logging\\n\"\n\t     \"    -n Namespace=Component    : Override component for namespace\\n\"\n\t     \"    -I Path                   : Add include search path\\n\"\n\t     \"    -M Path                   : Add module search path\\n\"\n\t     \"    --debugger                : Start local debugger\\n\"\n\t     \"    --debugger-remote         : Start remote debugger\\n\"\n\t     \"ClientOptions are:\\n\"\n\t     \"    -s                        : Get options as one YCPList from stdin\\n\"\n\t     \"    -f FileName               : Get YCPValue(s) from file\\n\"\n\t     \"    -S                        : Parameters are strings, not YCP to be parsed\\n\"\n\t     \"    '(any YCPValue)...'       : Parameter _IS_ a YCPValue\\n\"\n\t     \"                                -S '(t1)' '(\\\\t2)' is equivalent to '(\\\"t1\\\")' '(\\\"\\\\\\\\t2\\\")'\\n\"\n\t     \"Generic ServerOptions are:\\n\"\n\t     \"    -p FileName               : Evaluate YCPValue(s) from file (preload)\\n\"\n\t     \"    '(any YCPValue)'          : Parameter _IS_ a YCPValue to be evaluated\\n\"\n\t     \"Specific ServerOptions are any options passed on unevaluated.\\n\\n\"\n\t     \"Examples:\\n\"\n\t     \"y2base installation qt\\n\"\n\t     \"    Start binary y2base with intallation.ycp as client and qt as server\\n\"\n\t     \"y2base installation '(\\\"test\\\")' qt\\n\"\n\t     \"    Provide YCPValue '\\\"test\\\"' as parameter for client installation\\n\"\n\t     \"y2base installation qt -geometry 800x600\\n\"\n\t     \"    Provide geometry information as specific server options\\n\");\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *progname = \"genericfrontend\";",
            "static void print_help ();",
            "bool debugger = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic const char *progname = \"genericfrontend\";\nstatic void print_help ();\nbool debugger = false;\n\nstatic void\nprint_help()\n{\n    fprintf (stderr, \"\\n\"\n\t     \"Usage: %s [GenericOpts] Client [ClientOpts] Server [Generic ServerOpts] \"\n\t     \"[Specific ServerOpts]\\n\",\n\t     progname);\n\n    fprintf (stderr,\n\t     \"GenericOptions are:\\n\"\n\t     \"    -l | --logfile LogFile    : Set logfile\\n\"\n\t     \"    -c | --logconf ConfFile   : Configure logging\\n\"\n\t     \"    -n Namespace=Component    : Override component for namespace\\n\"\n\t     \"    -I Path                   : Add include search path\\n\"\n\t     \"    -M Path                   : Add module search path\\n\"\n\t     \"    --debugger                : Start local debugger\\n\"\n\t     \"    --debugger-remote         : Start remote debugger\\n\"\n\t     \"ClientOptions are:\\n\"\n\t     \"    -s                        : Get options as one YCPList from stdin\\n\"\n\t     \"    -f FileName               : Get YCPValue(s) from file\\n\"\n\t     \"    -S                        : Parameters are strings, not YCP to be parsed\\n\"\n\t     \"    '(any YCPValue)...'       : Parameter _IS_ a YCPValue\\n\"\n\t     \"                                -S '(t1)' '(\\\\t2)' is equivalent to '(\\\"t1\\\")' '(\\\"\\\\\\\\t2\\\")'\\n\"\n\t     \"Generic ServerOptions are:\\n\"\n\t     \"    -p FileName               : Evaluate YCPValue(s) from file (preload)\\n\"\n\t     \"    '(any YCPValue)'          : Parameter _IS_ a YCPValue to be evaluated\\n\"\n\t     \"Specific ServerOptions are any options passed on unevaluated.\\n\\n\"\n\t     \"Examples:\\n\"\n\t     \"y2base installation qt\\n\"\n\t     \"    Start binary y2base with intallation.ycp as client and qt as server\\n\"\n\t     \"y2base installation '(\\\"test\\\")' qt\\n\"\n\t     \"    Provide YCPValue '\\\"test\\\"' as parameter for client installation\\n\"\n\t     \"y2base installation qt -geometry 800x600\\n\"\n\t     \"    Provide geometry information as specific server options\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"--help\""
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"-h\""
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "YAST_FEWARGUMENTS"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nToo few arguments\""
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "signal_handler"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "signal_log_to_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "136-161",
          "snippet": "static\nvoid\nsignal_log_to_fd (int fd, const char * cs)\n{\n    ssize_t n = strlen (cs);\n    while (true) {\n       ssize_t w = write(fd, cs, n);\n       if (w == n)\n\t   break;              // success\n       else if (w == -1) {\n\t   if (errno == EINTR) {\n\t       // perror(\"gotcha\"); // bnc#470645\n\t   }\n\t   else {\n\t       perror(\"write\"); // other cases\n\t       break;\n\t   }\n       }\n       else {\n\t   errno = 0;\n\t   cs += w;\n\t   n -= w;\n       }\n    }\n\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic\nvoid\nsignal_log_to_fd (int fd, const char * cs)\n{\n    ssize_t n = strlen (cs);\n    while (true) {\n       ssize_t w = write(fd, cs, n);\n       if (w == n)\n\t   break;              // success\n       else if (w == -1) {\n\t   if (errno == EINTR) {\n\t       // perror(\"gotcha\"); // bnc#470645\n\t   }\n\t   else {\n\t       perror(\"write\"); // other cases\n\t       break;\n\t   }\n       }\n       else {\n\t   errno = 0;\n\t   cs += w;\n\t   n -= w;\n       }\n    }\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "basename",
          "args": [
            "argv[0]"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "basename",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/Pathname.cc",
          "lines": "220-233",
          "snippet": "string Pathname::basename( const Pathname & name_tv )\n{\n  if ( name_tv.empty() )\n    return \"\";\n\n  string ret_t( name_tv.asString() );\n  ret_t.erase( 0, name_tv.prfx_i );\n  string::size_type idx = ret_t.find_last_of( '/' );\n  if ( idx != string::npos ) {\n    ret_t.erase( 0, idx+1 );\n  }\n\n  return ret_t;\n}",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <iostream>\n\nPathname {\n  string Pathname::basename( const Pathname & name_tv )\n  {\n    if ( name_tv.empty() )\n      return \"\";\n  \n    string ret_t( name_tv.asString() );\n    ret_t.erase( 0, name_tv.prfx_i );\n    string::size_type idx = ret_t.find_last_of( '/' );\n    if ( idx != string::npos ) {\n      ret_t.erase( 0, idx+1 );\n    }\n  \n    return ret_t;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "YAST_OPTIONERROR"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Missing argv[0]. It is a NULL pointer.\""
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\n#define MAX_YCP_ERROR_EXIT_SYMBOLS\t2\n\nconst char* ycp_error_exit_symbols[MAX_YCP_ERROR_EXIT_SYMBOLS] = { \n    \"abort\",\n    \"cancel\"\n};\nDebugger *debugger_instance;\nstatic const char *progname = \"genericfrontend\";\nstatic void print_usage ();\nstatic void print_help ();\nstatic bool has_parens (const char* arg);\nbool debugger = false;\nbool debugger_remote = false;\n\nint\nmain (int argc, char **argv)\n{\n    if (!argv[0])\n    {\n\tfprintf (stderr, \"Missing argv[0]. It is a NULL pointer.\");\n\texit (YAST_OPTIONERROR);\n    }\n\n    progname = basename (argv[0]);\t// get program name\n\n    // Ignore SIGPIPE. No use in signals. Signals can't be assigned to\n    // components\n    signal(SIGPIPE, SIG_IGN);\n\n    // Give some output for the SIGSEGV\n    // and other signals too, #238172\n    // Note that USR1 and USR2 are handled by the logger.\n    signal (SIGHUP,  signal_handler);\n    signal (SIGINT,  signal_handler);\n    signal (SIGQUIT, signal_handler);\n    signal (SIGILL , signal_handler);\n    signal (SIGABRT, signal_handler);\n    signal (SIGFPE,  signal_handler);\n    signal (SIGSEGV, signal_handler);\n    signal (SIGTERM, signal_handler);\n\n    if (argc < 2) {\n\tfprintf (stderr, \"\\nToo few arguments\");\n\tprint_usage();\n\texit (YAST_FEWARGUMENTS);\n    }\n\n    if (!strcmp (argv[1], \"-h\") || !strcmp (argv[1], \"--help\")) {\n\tprint_help ();\n\texit (YAST_OK);\n    }\n\n    // client _AND_ server must be given\n    if (argc < 3)\n    {\n\tfprintf (stderr, \"\\nPlease give client and server as arguments\");\n\tprint_usage();\n\texit(5);\n    }\n\n    // Scan all options for -l/--logfile. They must be honored BEFORE\n    // the logger is used the first time.\n    for (int arg = 1; arg < argc; arg++)\n    {\n\tif (!strcmp(argv[arg], \"-l\") || !strcmp(argv[arg], \"--logfile\"))\n\t{\n\t    arg++;   // switch to filename\n\n\t    if (arg >= argc)\n\t    {\n\t\tprint_error (\"Option %s is missing an argument\", argv[arg-1]);\n\t\texit(5);\n\t    }\n\n\t    set_log_filename( argv[arg] );   // set logfile given in command line\n\t}\n\tif (!strcmp(argv[arg], \"-c\") || !strcmp(argv[arg], \"--logconf\"))\n\t{\n\t    arg++;   // switch to filename\n\n\t    if (arg >= argc)\n\t    {\n\t\tprint_error (\"Option %s is missing an argument\", argv[arg-1]);\n\t\texit(5);\n\t    }\n\n\t    set_log_conf( argv[arg] );\n\t}\n    }\n\n    // set a defined umask\n    umask (0022);\n\n    YCPPathSearch::initialize();\n\n    ostringstream argdump;\n    for (int arg = 1; arg < argc; arg++)\n    {\n\targdump << \" '\" << argv[arg] << \"'\";\n    }\n\n    y2milestone (\"Launched YaST2 component '%s'%s\", progname, argdump.str().c_str());\n\n    // Now evaluate command line options in sequence\n\n    int arg = 1;\n\n    // The first argument might be the log option or MUST be the client name\n    if (!strcmp(argv[arg], \"-l\") || !strcmp(argv[arg], \"--logfile\"))\n    {\n\t// Logfile already done at program start --> ignore here\n\targ+=2;\t  // skip over logfilename\n    }\n    if (!strcmp(argv[arg], \"-c\") || !strcmp(argv[arg], \"--logconf\"))\n    {\n\t// Logfile already done at program start --> ignore here\n\targ+=2;\t  // skip over logfilename\n    }\n    // The first argument might be the log option or MUST be the client name\n    if (!strcmp(argv[arg], \"-l\") || !strcmp(argv[arg], \"--logfile\"))\n    {\n\t// Logfile already done at program start --> ignore here\n\targ+=2;\t  // skip over logfilename\n    }\n\n\n    // Check for namespace exceptions registration\n    while (!strcmp(argv[arg], \"-n\"))\n    {\n\targ++;\n\tchar *pos = index (argv[arg], '=');\n\tif (pos == NULL)\n\t{\n\t    print_error (\"Option %s argument must be in format namespace=component\", argv[arg-1]);\n\t    exit (YAST_OPTIONERROR);\n\t}\n\t*pos = 0;\n\tY2ComponentBroker::registerNamespaceException (argv[arg], pos+1);\n\t*pos = '=';\n\targ++;\n    }\n\n// FIXME the whole option parsing sucks **** !\n\n    // Check, if debugger should be enabled\n    if (!strcmp(argv[arg], \"--debugger\"))\n    {\n\t// set the flag\n\tdebugger = true;\n\targ+=1;\n    }\n    \n    if (!strcmp(argv[arg], \"--debugger-remote\"))\n    {\n\t// set the flag\n\tdebugger = true;\n\tdebugger_remote = true;\n\targ+=1;\n    }\n    \n    // also handle environment variable\n    if( getenv (\"Y2DEBUGGER\") )\n    {\n\tif (strcmp (getenv (\"Y2DEBUGGER\"), \"1\")==0 )\n\t    debugger = true;\n\telse if (strcmp (getenv (\"Y2DEBUGGER\"), \"2\")==0 )\n\t{\n\t    debugger = true;\n\t    debugger_remote = true;\n\t}\n    }\n\n    if (debugger)\n    {\n\t// initialize the Debugger instance\n\tdebugger_instance = new Debugger ();\n\tdebugger_instance->initialize (debugger_remote);\n    }\n\n\n    // list of -I / -M pathes\n    //   will be pushed to YCPPathSearch later to keep correct order\n    //   (the last added path to YCPPathSearch will be searched first)\n    std::list<std::string> modpaths;\n    std::list<std::string> incpaths;\n\n    // include paths\n    while (!strcmp(argv[arg], \"-I\"))\n    {\n\targ++;\n\tincpaths.push_front (string (argv[arg])); // push to front so first one is last in list\n\targ++;\n    }\n\n    while (!strcmp(argv[arg], \"-M\"))\n    {\n\targ++;\n\tmodpaths.push_front (string (argv[arg])); // push to front so first one is last in list\n\targ++;\n    }\n\n    // add include and module pathes to YCPPathSearch so that the argument order is kept\n\n    std::list<std::string>::iterator pathit;\n    for (pathit = incpaths.begin(); pathit != incpaths.end(); pathit++)\n    {\n\tYCPPathSearch::addPath (YCPPathSearch::Include, pathit->c_str());\n    }\n    for (pathit = modpaths.begin(); pathit != modpaths.end(); pathit++)\n    {\n\tYCPPathSearch::addPath (YCPPathSearch::Module, pathit->c_str());\n    }\n\n    // \"arg\" and these two are output params\n    char * client_name;\n    YCPList arglist;\n    parse_client_and_options (argc, argv, arg, client_name, arglist);\n    // add debugger information if needed\n    if (debugger)\n\targlist->add ( YCPSymbol(\"debugger\") );\n\n    // \"arg\" and these two are output params\n    char * server_name;\n    YCPList preload;\t\t       // prepare preload files from option -p\n    parse_server_and_options (argc, argv, arg, server_name, preload);\n\n    // now create server\n\n#if 0\n    Y2ComponentBroker::registerNamespaceException (\"UI\", server_name);\n#endif\n    Y2ComponentBroker::getNamespaceComponent( \"UI\" );\n    y2debug( \"Creating server \\\"%s\\\"\", server_name );\n    Y2Component *server = Y2ComponentBroker::createServer( server_name );\n    if (!server) {\n\tprint_error (\"No such server module %s\", server_name);\n\tprint_usage();\n\texit(5);\n    }\n\n    // Put argument into a nice new array and give them to the server\n    char **server_argv = new char *[argc-arg+2];\n    server_argv[0] = strdup (server_name);\n    for (int i = arg; i < argc; i++)\n\tserver_argv[i-arg+1] = argv[i];\n    argv[argc] = NULL;\n\n    // set the server options directly\n    server->setServerOptions(argc-arg+1, server_argv);\n\n    // Preload server with scripts from -p and directly given YCPValues\n    for (int i = 0; i < preload->size(); i++)\n    {\n\tserver->evaluate(preload->value(i));\n    }\n\n    // now create client\n\n    Y2Component *client = Y2ComponentBroker::createClient (client_name);\n    if (!client)\n    {\n\tprint_error (\"No such client module %s\", client_name);\n\n\tstd::list<string>::const_iterator\n\t    i = YCPPathSearch::searchListBegin(YCPPathSearch::Client),\n\t    e = YCPPathSearch::searchListEnd(YCPPathSearch::Client);\n\tfprintf (stderr, \"The search path follows. It does not include the current directory.\\n\");\n\tfor (; i != e; ++i)\n\t    fprintf (stderr, \"  %s\\n\", i->c_str());\n\n\tprint_usage ();\n\texit (YAST_OPTIONERROR);\n    }\n    if (dynamic_cast<Y2ErrorComponent *>(client))\n    {\n\tprint_error (\"Error while creating client module %s\", client_name);\n\texit (YAST_OPTIONERROR);\n    }\n\n\n    // The environment variable YAST_IS_RUNNING is checked in rpm\n    // post install scripts. Might be useful for other scripts as\n    // well.\n    if (strcmp (client_name, \"live-installer\") == 0 // bnc#389099\n\t|| (strcmp (client_name, \"installation\") == 0\n\t    && arglist->contains (YCPString (\"initial\"))))\n    {\n\tsetenv (\"YAST_IS_RUNNING\", \"instsys\", 1);\n    }\n    else\n    {\n\tsetenv (\"YAST_IS_RUNNING\", \"yes\", 1);\n    }\n\n    y2milestone (\"YAST_IS_RUNNING is %s\", getenv (\"YAST_IS_RUNNING\"));\n\n\n    YCPValue result = YCPVoid();\n    // Now start communication\n    result = client->doActualWork(arglist, server);   // give arglist collected above\n\n    // get result\n    server->result(result);\n\n    // Cleanup\n    delete server;\n    delete[] server_argv;\n    delete client;\n\n    // might be useful in tracking segmentation faults\n    y2milestone (\"Finished YaST2 component '%s'\", progname);\n\n    if( result.isNull () )\n\texit (YAST_OK);\n\n    y2milestone( \"Exiting with client return value '%s'\", result->toString ().c_str ());\n\n    if( result->isBoolean () )\n    {\n\texit( result->asBoolean()->value() ? YAST_OK : YAST_CLIENTRESULT );\n    }\n\t\n    if( result->isInteger () )\n\texit( YAST_CLIENTRESULT + result->asInteger ()->value () );\n\n    // if it is one of error symbols, return it as error\n    if( result->isSymbol () )\n    {\n\tstring symbol = result->asSymbol()->symbol();\n\tfor( int i = 0 ; i < MAX_YCP_ERROR_EXIT_SYMBOLS; i++ )\n\t    if( symbol == ycp_error_exit_symbols[i] )\n\t\texit( YAST_CLIENTRESULT );\n    }\n    \n    // all other values\n    exit (YAST_OK);\n}"
  },
  {
    "function_name": "parse_server_and_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "497-586",
    "snippet": "void\nparse_server_and_options (int argc, char ** argv, int& arg, char *& server_name, YCPList& preload)\n{\n    if (arg >= argc)\n    {\n\tfprintf(stderr, \"No server module given\\n\");\n\tprint_usage ();\n\texit (YAST_OPTIONERROR);\n    }\n\n    // now create server\n    if (!argv[arg]) {\n\tprint_usage ();\n\texit (YAST_FEWARGUMENTS);\n    }\n\n    server_name = argv[arg];\n    arg++;   // next argument (first server option)\n\n    // Prepare server and general options\n\n    while (arg < argc)\n    {\n\tif (!strcmp(argv[arg], \"-l\") || !strcmp(argv[arg], \"--logfile\"))\n\t{\n\t    // Logfile already done at program start --> ignore here\n\t    arg++;   // skip filename\n\t}\n\telse if (!strcmp(argv[arg], \"-p\"))   // preload\n\t{\n\t    arg++;   // switch to filename\n\n\t    if (arg >= argc)\n\t    {\n\t\tprint_error (\"Server option -p is missing an argument\");\n\t\tprint_usage();\n\t\texit(5);\n\t    }\n\n\t    FILE *file = fopen (argv[arg], \"r\");\n\t    if (!file)\n\t    {\n\t\tprint_error (\"Client option -p: Couldn't open %s for reading\", argv[arg]);\n\t\texit(5);\n\t    }\n\n\t    bool one_value_parsed = false;\n\n\t    while (!feof(file))\t  // Parse all values until EOF\n\t    {\n\t\tParser parser(file, argv[arg]);   // set parser to file\n\n\t\tYCodePtr pc = parser.parse ();\n\n\t\tif (pc)\n\t\t{\n\t\t    preload->add(pc->evaluate (true));   // add to preload list\n\t\t    one_value_parsed = true;\n\t\t}\n\t    }\n\n\t    fclose (file);\n\n\t    if (!one_value_parsed)\n\t    {\n\t\tprint_error (\"Server option -p: Couldn't parse a valid YCP value from file %s\",\n\t\t\t     argv[arg]);\n\t\texit(5);\n\t    }\n\t}\n\telse if (has_parens (argv[arg]))\t// option is a YCP value -> parse it directly\n\t{\n\t    Parser parser (argv[arg]);\t// set parser to option\n\n\t    YCodePtr pc = parser.parse ();\n\n\t    if (!pc)\n\t    {\n\t\tprint_error (\"Server option %s is not a valid YCP value\", argv[arg]);\n\t\texit(5);\n\t    }\n\n\t    preload->add (pc->evaluate (true));\t// add to preload list\n\t}\n\telse break; // specific server options\n\n\targ++;\t    // switch to next argument\n    }\t// parsing server options\n\n}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void print_usage ();",
      "static bool has_parens (const char* arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preload->add",
          "args": [
            "pc->evaluate (true)"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pc->evaluate",
          "args": [
            "true"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "69-138",
          "snippet": "YCPValue Y2ProgramComponent::evaluate(const YCPValue& command)\n{\n    if (pid == -1)   // server component not yet started --> do it\n    {\n\tif (is_non_y2)   // this is a nony2 program like a shell and such like\n\t{\n\t    // Prepare options: argv[0] must be server component name,\n\t    // argv[1] must _NOT_ be 'stdio' like for real Y2 components (see below).\n\t    // If no options have been set so far via setServerOptions(),\n\t    // fill in argv[0] correctly.\n\n\t    int l_argc = 1 + (argc > 0 ? argc - 1 : 0);\n\t    char **l_argv = new char *[l_argc + 1];\n\n\t    l_argv[0] = (argc >= 1) ? argv[0] : strdup(name().c_str()); // component name\n\t    for (int arg = 1; arg < argc; arg++) l_argv[arg] = argv[arg];\n\t    l_argv[l_argc] = 0; // Terminate array\n\n\t    // launch program\n\t    launchExternalProgram(l_argv);\n\n\t    // NonY2 servers will not send arguments to the client (me).\n\t    // Therefore it is not necessary to receive something in this case.\n\n\t    if (argc < 1) free (l_argv[0]);\n\t    if (l_argv) delete[] l_argv;  // free l_argv\n\t}\n\telse   // this is a real liby2 component\n\t{\n\t    // Prepare options: argv[0] must be server component name,\n\t    // argv[1] must be 'stdio' in order to make the gf of the\n\t    // called component communicate via stdio, argv[2...] contains\n\t    // all further options. If no options have been set so far\n\t    // via setServerOptions(), fill in argv[0] correctly.\n\n\t    int l_argc = 3 + (argc > 0 ? argc - 1 : 0);\n\t    char **l_argv = new char *[l_argc + 1];\n\n\t    l_argv[0] = argc >= 1 ? argv[0] : strdup(name().c_str()); // component name\n\t    l_argv[1] = \"stdio\"; // I will speak to the server via his stdio\n\t    l_argv[2] = strdup(name().c_str());\n\t    for (int arg = 1; arg < argc; arg++) l_argv[arg+2] = argv[arg];\n\t    l_argv[l_argc] = 0; // Terminate array\n\n\t    // launch program\n\t    launchExternalProgram(l_argv);\n\n\t    // I am myself a module in this context. Therefore the server\n\t    // will send me my arguments. Since I initiated the session\n\t    // myself, I am not interested in these arguments.\n\n\t    if (receiveFromExternal().isNull())\n\t    {\n\t\ty2error (\"Couldn't launch external server %s\", name().c_str ());\n\t\treturn YCPNull ();\n\t    }\n\n\t    if (argc < 1) free (l_argv[0]);\n\t    free (l_argv[2]);\n\t    delete[] l_argv;  // free l_argv\n\t}\n    }\n\n    // send command\n    sendToExternal (command);\n\n    // get answer\n    YCPValue retval = receiveFromExternal();\n    return !retval.isNull() ? retval : YCPVoid();\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  YCPValue Y2ProgramComponent::evaluate(const YCPValue& command)\n  {\n      if (pid == -1)   // server component not yet started --> do it\n      {\n  \tif (is_non_y2)   // this is a nony2 program like a shell and such like\n  \t{\n  \t    // Prepare options: argv[0] must be server component name,\n  \t    // argv[1] must _NOT_ be 'stdio' like for real Y2 components (see below).\n  \t    // If no options have been set so far via setServerOptions(),\n  \t    // fill in argv[0] correctly.\n  \n  \t    int l_argc = 1 + (argc > 0 ? argc - 1 : 0);\n  \t    char **l_argv = new char *[l_argc + 1];\n  \n  \t    l_argv[0] = (argc >= 1) ? argv[0] : strdup(name().c_str()); // component name\n  \t    for (int arg = 1; arg < argc; arg++) l_argv[arg] = argv[arg];\n  \t    l_argv[l_argc] = 0; // Terminate array\n  \n  \t    // launch program\n  \t    launchExternalProgram(l_argv);\n  \n  \t    // NonY2 servers will not send arguments to the client (me).\n  \t    // Therefore it is not necessary to receive something in this case.\n  \n  \t    if (argc < 1) free (l_argv[0]);\n  \t    if (l_argv) delete[] l_argv;  // free l_argv\n  \t}\n  \telse   // this is a real liby2 component\n  \t{\n  \t    // Prepare options: argv[0] must be server component name,\n  \t    // argv[1] must be 'stdio' in order to make the gf of the\n  \t    // called component communicate via stdio, argv[2...] contains\n  \t    // all further options. If no options have been set so far\n  \t    // via setServerOptions(), fill in argv[0] correctly.\n  \n  \t    int l_argc = 3 + (argc > 0 ? argc - 1 : 0);\n  \t    char **l_argv = new char *[l_argc + 1];\n  \n  \t    l_argv[0] = argc >= 1 ? argv[0] : strdup(name().c_str()); // component name\n  \t    l_argv[1] = \"stdio\"; // I will speak to the server via his stdio\n  \t    l_argv[2] = strdup(name().c_str());\n  \t    for (int arg = 1; arg < argc; arg++) l_argv[arg+2] = argv[arg];\n  \t    l_argv[l_argc] = 0; // Terminate array\n  \n  \t    // launch program\n  \t    launchExternalProgram(l_argv);\n  \n  \t    // I am myself a module in this context. Therefore the server\n  \t    // will send me my arguments. Since I initiated the session\n  \t    // myself, I am not interested in these arguments.\n  \n  \t    if (receiveFromExternal().isNull())\n  \t    {\n  \t\ty2error (\"Couldn't launch external server %s\", name().c_str ());\n  \t\treturn YCPNull ();\n  \t    }\n  \n  \t    if (argc < 1) free (l_argv[0]);\n  \t    free (l_argv[2]);\n  \t    delete[] l_argv;  // free l_argv\n  \t}\n      }\n  \n      // send command\n      sendToExternal (command);\n  \n      // get answer\n      YCPValue retval = receiveFromExternal();\n      return !retval.isNull() ? retval : YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "5"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_error",
          "args": [
            "\"Server option %s is not a valid YCP value\"",
            "argv[arg]"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser.parse",
          "args": [],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "484-562",
          "snippet": "int IniParser::parse()\n{\n    if (multiple_files)\n    {\n\tglob_t do_files;\n\tint len = files.size ();\n\tint flags = 0;\n\tfor (int i = 0;i<len;i++)\n\t{\n\t    glob (files[i].c_str (),flags, NULL, &do_files);\n\t    flags = GLOB_APPEND;\n\t}\n\tchar**f = do_files.gl_pathv;\n\tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n\t{\n\t    int section_index = -1;\n\t    string section_name = *f;\n\t    //FIXME: create function out of it.\n\t    // do we have name rewrite rules?\n\t    for (size_t j = 0; j < rewrites.size (); j++)\n\t\t{\n\t\t    RegexMatch m (rewrites[j].rx, section_name);\n\t\t    if (m)\n\t\t    {\n\t\t\tsection_index = j;\n\t\t\tsection_name = m[1];\n\t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    // do we know about the file?\n\t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n\t    if (ff == multi_files.end())\n\t    {\n\t\t// new file\n\t\tif (scanner_start (*f))\n\t\t    y2error (\"Cannot open %s.\", *f);\n\t\telse\n\t\t{\n\t\t    FileDescr fdsc (*f);\n\t\t    multi_files[*f] = fdsc;\n\t\t    inifile.initSection (section_name, \"\", -1, section_index);\n\t\t    parse_helper(inifile.getSection(section_name.c_str()));\n\t\t    scanner_stop();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif ((*ff).second.changed ())\n\t\t{\n\t\t    if (scanner_start (*f))\n\t\t\ty2error (\"Cannot open %s.\", *f);\n\t\t    else\n\t\t    {\n\t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n\t\t\tFileDescr fdsc (*f);\n\t\t\tmulti_files [*f] = fdsc;\n\t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n\t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n\t\t\tscanner_stop();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tif (scanner_start (file.c_str()))\n\t    {\n\t\ty2error (\"Can not open %s.\", file.c_str());\n\t\treturn -1;\n\t    }\n\tparse_helper(inifile);\n\tscanner_stop();\n\ttimestamp = getTimeStamp ();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse()\n  {\n      if (multiple_files)\n      {\n  \tglob_t do_files;\n  \tint len = files.size ();\n  \tint flags = 0;\n  \tfor (int i = 0;i<len;i++)\n  \t{\n  \t    glob (files[i].c_str (),flags, NULL, &do_files);\n  \t    flags = GLOB_APPEND;\n  \t}\n  \tchar**f = do_files.gl_pathv;\n  \tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n  \t{\n  \t    int section_index = -1;\n  \t    string section_name = *f;\n  \t    //FIXME: create function out of it.\n  \t    // do we have name rewrite rules?\n  \t    for (size_t j = 0; j < rewrites.size (); j++)\n  \t\t{\n  \t\t    RegexMatch m (rewrites[j].rx, section_name);\n  \t\t    if (m)\n  \t\t    {\n  \t\t\tsection_index = j;\n  \t\t\tsection_name = m[1];\n  \t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \n  \t    // do we know about the file?\n  \t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n  \t    if (ff == multi_files.end())\n  \t    {\n  \t\t// new file\n  \t\tif (scanner_start (*f))\n  \t\t    y2error (\"Cannot open %s.\", *f);\n  \t\telse\n  \t\t{\n  \t\t    FileDescr fdsc (*f);\n  \t\t    multi_files[*f] = fdsc;\n  \t\t    inifile.initSection (section_name, \"\", -1, section_index);\n  \t\t    parse_helper(inifile.getSection(section_name.c_str()));\n  \t\t    scanner_stop();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif ((*ff).second.changed ())\n  \t\t{\n  \t\t    if (scanner_start (*f))\n  \t\t\ty2error (\"Cannot open %s.\", *f);\n  \t\t    else\n  \t\t    {\n  \t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n  \t\t\tFileDescr fdsc (*f);\n  \t\t\tmulti_files [*f] = fdsc;\n  \t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n  \t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n  \t\t\tscanner_stop();\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n      else\n      {\n  \tif (scanner_start (file.c_str()))\n  \t    {\n  \t\ty2error (\"Can not open %s.\", file.c_str());\n  \t\treturn -1;\n  \t    }\n  \tparse_helper(inifile);\n  \tscanner_stop();\n  \ttimestamp = getTimeStamp ();\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_parens",
          "args": [
            "argv[arg]"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "has_parens",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "975-979",
          "snippet": "static bool\nhas_parens (const char* arg)\n{\n    return arg[0] == '(' && arg[strlen (arg) - 1] == ')';\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool has_parens (const char* arg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic bool has_parens (const char* arg);\n\nstatic bool\nhas_parens (const char* arg)\n{\n    return arg[0] == '(' && arg[strlen (arg) - 1] == ')';\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "5"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_error",
          "args": [
            "\"Server option -p: Couldn't parse a valid YCP value from file %s\"",
            "argv[arg]"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "file"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "feof",
          "args": [
            "file"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "5"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_error",
          "args": [
            "\"Client option -p: Couldn't open %s for reading\"",
            "argv[arg]"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "argv[arg]",
            "\"r\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "5"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_usage",
          "args": [],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "913-918",
          "snippet": "static void\nprint_usage()\n{\n    fprintf (stderr,\n\t     \"\\nRun 'yast2 -h' for help on usage\\n\");\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void print_usage ();"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic void print_usage ();\n\nstatic void\nprint_usage()\n{\n    fprintf (stderr,\n\t     \"\\nRun 'yast2 -h' for help on usage\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_error",
          "args": [
            "\"Server option -p is missing an argument\""
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "print_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "958-972",
          "snippet": "static void\nprint_error (const char* format, ...)\n{\n    char* msg;\n\n    va_list ap;\n    va_start (ap, format);\n    vasprintf (&msg, format, ap);\n    va_end (ap);\n\n    fprintf (stderr, \"%s\\n\", msg);\n    y2error (\"%s\", msg);\n\n    free (msg);\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic void\nprint_error (const char* format, ...)\n{\n    char* msg;\n\n    va_list ap;\n    va_start (ap, format);\n    vasprintf (&msg, format, ap);\n    va_end (ap);\n\n    fprintf (stderr, \"%s\\n\", msg);\n    y2error (\"%s\", msg);\n\n    free (msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"-p\""
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"--logfile\""
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"-l\""
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "YAST_FEWARGUMENTS"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "YAST_OPTIONERROR"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"No server module given\\n\""
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic void print_usage ();\nstatic bool has_parens (const char* arg);\n\nvoid\nparse_server_and_options (int argc, char ** argv, int& arg, char *& server_name, YCPList& preload)\n{\n    if (arg >= argc)\n    {\n\tfprintf(stderr, \"No server module given\\n\");\n\tprint_usage ();\n\texit (YAST_OPTIONERROR);\n    }\n\n    // now create server\n    if (!argv[arg]) {\n\tprint_usage ();\n\texit (YAST_FEWARGUMENTS);\n    }\n\n    server_name = argv[arg];\n    arg++;   // next argument (first server option)\n\n    // Prepare server and general options\n\n    while (arg < argc)\n    {\n\tif (!strcmp(argv[arg], \"-l\") || !strcmp(argv[arg], \"--logfile\"))\n\t{\n\t    // Logfile already done at program start --> ignore here\n\t    arg++;   // skip filename\n\t}\n\telse if (!strcmp(argv[arg], \"-p\"))   // preload\n\t{\n\t    arg++;   // switch to filename\n\n\t    if (arg >= argc)\n\t    {\n\t\tprint_error (\"Server option -p is missing an argument\");\n\t\tprint_usage();\n\t\texit(5);\n\t    }\n\n\t    FILE *file = fopen (argv[arg], \"r\");\n\t    if (!file)\n\t    {\n\t\tprint_error (\"Client option -p: Couldn't open %s for reading\", argv[arg]);\n\t\texit(5);\n\t    }\n\n\t    bool one_value_parsed = false;\n\n\t    while (!feof(file))\t  // Parse all values until EOF\n\t    {\n\t\tParser parser(file, argv[arg]);   // set parser to file\n\n\t\tYCodePtr pc = parser.parse ();\n\n\t\tif (pc)\n\t\t{\n\t\t    preload->add(pc->evaluate (true));   // add to preload list\n\t\t    one_value_parsed = true;\n\t\t}\n\t    }\n\n\t    fclose (file);\n\n\t    if (!one_value_parsed)\n\t    {\n\t\tprint_error (\"Server option -p: Couldn't parse a valid YCP value from file %s\",\n\t\t\t     argv[arg]);\n\t\texit(5);\n\t    }\n\t}\n\telse if (has_parens (argv[arg]))\t// option is a YCP value -> parse it directly\n\t{\n\t    Parser parser (argv[arg]);\t// set parser to option\n\n\t    YCodePtr pc = parser.parse ();\n\n\t    if (!pc)\n\t    {\n\t\tprint_error (\"Server option %s is not a valid YCP value\", argv[arg]);\n\t\texit(5);\n\t    }\n\n\t    preload->add (pc->evaluate (true));\t// add to preload list\n\t}\n\telse break; // specific server options\n\n\targ++;\t    // switch to next argument\n    }\t// parsing server options\n\n}"
  },
  {
    "function_name": "parse_client_and_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "372-495",
    "snippet": "void\nparse_client_and_options (int argc, char ** argv, int& arg, char  *& client_name, YCPList& arglist)\n{\n    bool args_are_ycp = true;\n\n    if (!argv[arg]) {\n\tprint_usage ();\n\texit (YAST_FEWARGUMENTS);\n    }\n\n    client_name = argv[arg];\n    arg++;   // next argument (first client option)\n\n    // Prepare client options\n    while (arg < argc)\n    {\n\tif (!strcmp(argv[arg], \"-l\") || !strcmp(argv[arg], \"--logfile\"))\n\t{\n\t    // Logfile already done at program start --> ignore here\n\t    arg++;   // skip filename\n\t}\n\telse if (!strcmp(argv[arg], \"-c\") || !strcmp(argv[arg], \"--logconf\"))\n\t{\n\t    // Logfile already done at program start --> ignore here\n\t    arg++;   // skip filename\n\t}\n\telse if (!strcmp(argv[arg], \"-S\"))\n\t{\n\t    args_are_ycp = false;\n\t}\n\telse if (!strcmp(argv[arg], \"-s\"))\t// Parse one value (YCPList of options) from stdin\n\t{\n\t    Parser parser (0, \"<stdin>\");\t// set parser to stdin\n\t    YCodePtr pc = parser.parse ();\n\n\t    YCPValue option = YCPNull ();\n\t    if (pc)\n\t    {\n\t\toption = pc->evaluate(true);\t// get one value (should be a YCPList)\n\t    }\n\n\t    if (option.isNull())\n\t    {\n\t\tprint_error (\"Client option -s: Couldn't parse valid YCP value from stdin\");\n\t\texit (YAST_OPTIONERROR);\n\t    }\n\n\t    if (!option->isList())\n\t    {\n\t\tprint_error (\"Client option -s: Parsed YCP value is NOT a YCPList\");\n\t\texit (YAST_OPTIONERROR);\n\t    }\n\n\t    arglist = option->asList();\t  // the option read _IS_ arglist\n\t}\n\telse if (!strcmp(argv[arg], \"-f\"))\t// Parse values from file\n\t{\n\t    arg++;   // switch to filename\n\n\t    if (arg >= argc)\n\t    {\n\t\tprint_error (\"Client option -f is missing an argument\");\n\t\tprint_usage();\n\t\texit(5);\n\t    }\n\n\t    FILE *file = fopen (argv[arg], \"r\");\n\t    if (!file)\n\t    {\n\t\tprint_error (\"Client option -f: Couldn't open %s for reading\", argv[arg]);\n\t\texit(5);\n\t    }\n\n\t    bool one_value_parsed = false;\n\n\t    while (!feof(file))\t  // Parse all values until EOF\n\t    {\n\t\tParser parser(file, argv[arg]);   // set parser to file\n\n\t\tYCodePtr pc = parser.parse ();\n\n\t\tif ( pc )\n\t\t{\n\t\t    arglist->add( pc->evaluate(true) );\n\t\t    one_value_parsed = true;\n\t\t}\n\t    }\n\n\t    fclose (file);\n\n\t    if (!one_value_parsed)\n\t    {\n\t\tprint_error (\"Client option -f: Couldn't parse valid YCP value from file %s\",\n\t\t\t     argv[arg]);\n\t\texit(5);\n\t    }\n\t}\n\telse if (has_parens (argv[arg]))\t// client args\n\t{\n\t  if (args_are_ycp)\t// bnc#382883\n\t  {\n\t    Parser parser (argv[arg]);\t// set parser to option\n\n\t    YCodePtr pc = parser.parse ();\n\n\t    if (!pc )\n\t    {\n\t\tprint_error (\"Client option %s is not a valid YCP value\", argv[arg]);\n\t\texit(5);\n\t    }\n\n\t    arglist->add( pc->evaluate (true));   // add to arglist\n\t  }\n\t  else\n\t  {\n\t      string value(argv[arg] + 1, strlen (argv[arg]) - 2);\n\t      arglist->add (YCPString (value));\n\t  }\n\t}\n\telse break;   // must be server name\n\n\targ++;\t      // switch to next argument\n    } // Parsing client options\n}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void print_usage ();",
      "static bool has_parens (const char* arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arglist->add",
          "args": [
            "YCPString (value)"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "value"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[arg]"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc->evaluate",
          "args": [
            "true"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "69-138",
          "snippet": "YCPValue Y2ProgramComponent::evaluate(const YCPValue& command)\n{\n    if (pid == -1)   // server component not yet started --> do it\n    {\n\tif (is_non_y2)   // this is a nony2 program like a shell and such like\n\t{\n\t    // Prepare options: argv[0] must be server component name,\n\t    // argv[1] must _NOT_ be 'stdio' like for real Y2 components (see below).\n\t    // If no options have been set so far via setServerOptions(),\n\t    // fill in argv[0] correctly.\n\n\t    int l_argc = 1 + (argc > 0 ? argc - 1 : 0);\n\t    char **l_argv = new char *[l_argc + 1];\n\n\t    l_argv[0] = (argc >= 1) ? argv[0] : strdup(name().c_str()); // component name\n\t    for (int arg = 1; arg < argc; arg++) l_argv[arg] = argv[arg];\n\t    l_argv[l_argc] = 0; // Terminate array\n\n\t    // launch program\n\t    launchExternalProgram(l_argv);\n\n\t    // NonY2 servers will not send arguments to the client (me).\n\t    // Therefore it is not necessary to receive something in this case.\n\n\t    if (argc < 1) free (l_argv[0]);\n\t    if (l_argv) delete[] l_argv;  // free l_argv\n\t}\n\telse   // this is a real liby2 component\n\t{\n\t    // Prepare options: argv[0] must be server component name,\n\t    // argv[1] must be 'stdio' in order to make the gf of the\n\t    // called component communicate via stdio, argv[2...] contains\n\t    // all further options. If no options have been set so far\n\t    // via setServerOptions(), fill in argv[0] correctly.\n\n\t    int l_argc = 3 + (argc > 0 ? argc - 1 : 0);\n\t    char **l_argv = new char *[l_argc + 1];\n\n\t    l_argv[0] = argc >= 1 ? argv[0] : strdup(name().c_str()); // component name\n\t    l_argv[1] = \"stdio\"; // I will speak to the server via his stdio\n\t    l_argv[2] = strdup(name().c_str());\n\t    for (int arg = 1; arg < argc; arg++) l_argv[arg+2] = argv[arg];\n\t    l_argv[l_argc] = 0; // Terminate array\n\n\t    // launch program\n\t    launchExternalProgram(l_argv);\n\n\t    // I am myself a module in this context. Therefore the server\n\t    // will send me my arguments. Since I initiated the session\n\t    // myself, I am not interested in these arguments.\n\n\t    if (receiveFromExternal().isNull())\n\t    {\n\t\ty2error (\"Couldn't launch external server %s\", name().c_str ());\n\t\treturn YCPNull ();\n\t    }\n\n\t    if (argc < 1) free (l_argv[0]);\n\t    free (l_argv[2]);\n\t    delete[] l_argv;  // free l_argv\n\t}\n    }\n\n    // send command\n    sendToExternal (command);\n\n    // get answer\n    YCPValue retval = receiveFromExternal();\n    return !retval.isNull() ? retval : YCPVoid();\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  YCPValue Y2ProgramComponent::evaluate(const YCPValue& command)\n  {\n      if (pid == -1)   // server component not yet started --> do it\n      {\n  \tif (is_non_y2)   // this is a nony2 program like a shell and such like\n  \t{\n  \t    // Prepare options: argv[0] must be server component name,\n  \t    // argv[1] must _NOT_ be 'stdio' like for real Y2 components (see below).\n  \t    // If no options have been set so far via setServerOptions(),\n  \t    // fill in argv[0] correctly.\n  \n  \t    int l_argc = 1 + (argc > 0 ? argc - 1 : 0);\n  \t    char **l_argv = new char *[l_argc + 1];\n  \n  \t    l_argv[0] = (argc >= 1) ? argv[0] : strdup(name().c_str()); // component name\n  \t    for (int arg = 1; arg < argc; arg++) l_argv[arg] = argv[arg];\n  \t    l_argv[l_argc] = 0; // Terminate array\n  \n  \t    // launch program\n  \t    launchExternalProgram(l_argv);\n  \n  \t    // NonY2 servers will not send arguments to the client (me).\n  \t    // Therefore it is not necessary to receive something in this case.\n  \n  \t    if (argc < 1) free (l_argv[0]);\n  \t    if (l_argv) delete[] l_argv;  // free l_argv\n  \t}\n  \telse   // this is a real liby2 component\n  \t{\n  \t    // Prepare options: argv[0] must be server component name,\n  \t    // argv[1] must be 'stdio' in order to make the gf of the\n  \t    // called component communicate via stdio, argv[2...] contains\n  \t    // all further options. If no options have been set so far\n  \t    // via setServerOptions(), fill in argv[0] correctly.\n  \n  \t    int l_argc = 3 + (argc > 0 ? argc - 1 : 0);\n  \t    char **l_argv = new char *[l_argc + 1];\n  \n  \t    l_argv[0] = argc >= 1 ? argv[0] : strdup(name().c_str()); // component name\n  \t    l_argv[1] = \"stdio\"; // I will speak to the server via his stdio\n  \t    l_argv[2] = strdup(name().c_str());\n  \t    for (int arg = 1; arg < argc; arg++) l_argv[arg+2] = argv[arg];\n  \t    l_argv[l_argc] = 0; // Terminate array\n  \n  \t    // launch program\n  \t    launchExternalProgram(l_argv);\n  \n  \t    // I am myself a module in this context. Therefore the server\n  \t    // will send me my arguments. Since I initiated the session\n  \t    // myself, I am not interested in these arguments.\n  \n  \t    if (receiveFromExternal().isNull())\n  \t    {\n  \t\ty2error (\"Couldn't launch external server %s\", name().c_str ());\n  \t\treturn YCPNull ();\n  \t    }\n  \n  \t    if (argc < 1) free (l_argv[0]);\n  \t    free (l_argv[2]);\n  \t    delete[] l_argv;  // free l_argv\n  \t}\n      }\n  \n      // send command\n      sendToExternal (command);\n  \n      // get answer\n      YCPValue retval = receiveFromExternal();\n      return !retval.isNull() ? retval : YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "5"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_error",
          "args": [
            "\"Client option %s is not a valid YCP value\"",
            "argv[arg]"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser.parse",
          "args": [],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "484-562",
          "snippet": "int IniParser::parse()\n{\n    if (multiple_files)\n    {\n\tglob_t do_files;\n\tint len = files.size ();\n\tint flags = 0;\n\tfor (int i = 0;i<len;i++)\n\t{\n\t    glob (files[i].c_str (),flags, NULL, &do_files);\n\t    flags = GLOB_APPEND;\n\t}\n\tchar**f = do_files.gl_pathv;\n\tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n\t{\n\t    int section_index = -1;\n\t    string section_name = *f;\n\t    //FIXME: create function out of it.\n\t    // do we have name rewrite rules?\n\t    for (size_t j = 0; j < rewrites.size (); j++)\n\t\t{\n\t\t    RegexMatch m (rewrites[j].rx, section_name);\n\t\t    if (m)\n\t\t    {\n\t\t\tsection_index = j;\n\t\t\tsection_name = m[1];\n\t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    // do we know about the file?\n\t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n\t    if (ff == multi_files.end())\n\t    {\n\t\t// new file\n\t\tif (scanner_start (*f))\n\t\t    y2error (\"Cannot open %s.\", *f);\n\t\telse\n\t\t{\n\t\t    FileDescr fdsc (*f);\n\t\t    multi_files[*f] = fdsc;\n\t\t    inifile.initSection (section_name, \"\", -1, section_index);\n\t\t    parse_helper(inifile.getSection(section_name.c_str()));\n\t\t    scanner_stop();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif ((*ff).second.changed ())\n\t\t{\n\t\t    if (scanner_start (*f))\n\t\t\ty2error (\"Cannot open %s.\", *f);\n\t\t    else\n\t\t    {\n\t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n\t\t\tFileDescr fdsc (*f);\n\t\t\tmulti_files [*f] = fdsc;\n\t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n\t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n\t\t\tscanner_stop();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tif (scanner_start (file.c_str()))\n\t    {\n\t\ty2error (\"Can not open %s.\", file.c_str());\n\t\treturn -1;\n\t    }\n\tparse_helper(inifile);\n\tscanner_stop();\n\ttimestamp = getTimeStamp ();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse()\n  {\n      if (multiple_files)\n      {\n  \tglob_t do_files;\n  \tint len = files.size ();\n  \tint flags = 0;\n  \tfor (int i = 0;i<len;i++)\n  \t{\n  \t    glob (files[i].c_str (),flags, NULL, &do_files);\n  \t    flags = GLOB_APPEND;\n  \t}\n  \tchar**f = do_files.gl_pathv;\n  \tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n  \t{\n  \t    int section_index = -1;\n  \t    string section_name = *f;\n  \t    //FIXME: create function out of it.\n  \t    // do we have name rewrite rules?\n  \t    for (size_t j = 0; j < rewrites.size (); j++)\n  \t\t{\n  \t\t    RegexMatch m (rewrites[j].rx, section_name);\n  \t\t    if (m)\n  \t\t    {\n  \t\t\tsection_index = j;\n  \t\t\tsection_name = m[1];\n  \t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \n  \t    // do we know about the file?\n  \t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n  \t    if (ff == multi_files.end())\n  \t    {\n  \t\t// new file\n  \t\tif (scanner_start (*f))\n  \t\t    y2error (\"Cannot open %s.\", *f);\n  \t\telse\n  \t\t{\n  \t\t    FileDescr fdsc (*f);\n  \t\t    multi_files[*f] = fdsc;\n  \t\t    inifile.initSection (section_name, \"\", -1, section_index);\n  \t\t    parse_helper(inifile.getSection(section_name.c_str()));\n  \t\t    scanner_stop();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif ((*ff).second.changed ())\n  \t\t{\n  \t\t    if (scanner_start (*f))\n  \t\t\ty2error (\"Cannot open %s.\", *f);\n  \t\t    else\n  \t\t    {\n  \t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n  \t\t\tFileDescr fdsc (*f);\n  \t\t\tmulti_files [*f] = fdsc;\n  \t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n  \t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n  \t\t\tscanner_stop();\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n      else\n      {\n  \tif (scanner_start (file.c_str()))\n  \t    {\n  \t\ty2error (\"Can not open %s.\", file.c_str());\n  \t\treturn -1;\n  \t    }\n  \tparse_helper(inifile);\n  \tscanner_stop();\n  \ttimestamp = getTimeStamp ();\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_parens",
          "args": [
            "argv[arg]"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "has_parens",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "975-979",
          "snippet": "static bool\nhas_parens (const char* arg)\n{\n    return arg[0] == '(' && arg[strlen (arg) - 1] == ')';\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool has_parens (const char* arg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic bool has_parens (const char* arg);\n\nstatic bool\nhas_parens (const char* arg)\n{\n    return arg[0] == '(' && arg[strlen (arg) - 1] == ')';\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "5"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_error",
          "args": [
            "\"Client option -f: Couldn't parse valid YCP value from file %s\"",
            "argv[arg]"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "file"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "feof",
          "args": [
            "file"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "5"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_error",
          "args": [
            "\"Client option -f: Couldn't open %s for reading\"",
            "argv[arg]"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "argv[arg]",
            "\"r\""
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "5"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_usage",
          "args": [],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "913-918",
          "snippet": "static void\nprint_usage()\n{\n    fprintf (stderr,\n\t     \"\\nRun 'yast2 -h' for help on usage\\n\");\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void print_usage ();"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic void print_usage ();\n\nstatic void\nprint_usage()\n{\n    fprintf (stderr,\n\t     \"\\nRun 'yast2 -h' for help on usage\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_error",
          "args": [
            "\"Client option -f is missing an argument\""
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "print_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "958-972",
          "snippet": "static void\nprint_error (const char* format, ...)\n{\n    char* msg;\n\n    va_list ap;\n    va_start (ap, format);\n    vasprintf (&msg, format, ap);\n    va_end (ap);\n\n    fprintf (stderr, \"%s\\n\", msg);\n    y2error (\"%s\", msg);\n\n    free (msg);\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic void\nprint_error (const char* format, ...)\n{\n    char* msg;\n\n    va_list ap;\n    va_start (ap, format);\n    vasprintf (&msg, format, ap);\n    va_end (ap);\n\n    fprintf (stderr, \"%s\\n\", msg);\n    y2error (\"%s\", msg);\n\n    free (msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"-f\""
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "option->asList",
          "args": [],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "YAST_OPTIONERROR"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "option->isList",
          "args": [],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "YAST_OPTIONERROR"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "option.isNull",
          "args": [],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"-s\""
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"-S\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"--logconf\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"-c\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"--logfile\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[arg]",
            "\"-l\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "YAST_FEWARGUMENTS"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic void print_usage ();\nstatic bool has_parens (const char* arg);\n\nvoid\nparse_client_and_options (int argc, char ** argv, int& arg, char  *& client_name, YCPList& arglist)\n{\n    bool args_are_ycp = true;\n\n    if (!argv[arg]) {\n\tprint_usage ();\n\texit (YAST_FEWARGUMENTS);\n    }\n\n    client_name = argv[arg];\n    arg++;   // next argument (first client option)\n\n    // Prepare client options\n    while (arg < argc)\n    {\n\tif (!strcmp(argv[arg], \"-l\") || !strcmp(argv[arg], \"--logfile\"))\n\t{\n\t    // Logfile already done at program start --> ignore here\n\t    arg++;   // skip filename\n\t}\n\telse if (!strcmp(argv[arg], \"-c\") || !strcmp(argv[arg], \"--logconf\"))\n\t{\n\t    // Logfile already done at program start --> ignore here\n\t    arg++;   // skip filename\n\t}\n\telse if (!strcmp(argv[arg], \"-S\"))\n\t{\n\t    args_are_ycp = false;\n\t}\n\telse if (!strcmp(argv[arg], \"-s\"))\t// Parse one value (YCPList of options) from stdin\n\t{\n\t    Parser parser (0, \"<stdin>\");\t// set parser to stdin\n\t    YCodePtr pc = parser.parse ();\n\n\t    YCPValue option = YCPNull ();\n\t    if (pc)\n\t    {\n\t\toption = pc->evaluate(true);\t// get one value (should be a YCPList)\n\t    }\n\n\t    if (option.isNull())\n\t    {\n\t\tprint_error (\"Client option -s: Couldn't parse valid YCP value from stdin\");\n\t\texit (YAST_OPTIONERROR);\n\t    }\n\n\t    if (!option->isList())\n\t    {\n\t\tprint_error (\"Client option -s: Parsed YCP value is NOT a YCPList\");\n\t\texit (YAST_OPTIONERROR);\n\t    }\n\n\t    arglist = option->asList();\t  // the option read _IS_ arglist\n\t}\n\telse if (!strcmp(argv[arg], \"-f\"))\t// Parse values from file\n\t{\n\t    arg++;   // switch to filename\n\n\t    if (arg >= argc)\n\t    {\n\t\tprint_error (\"Client option -f is missing an argument\");\n\t\tprint_usage();\n\t\texit(5);\n\t    }\n\n\t    FILE *file = fopen (argv[arg], \"r\");\n\t    if (!file)\n\t    {\n\t\tprint_error (\"Client option -f: Couldn't open %s for reading\", argv[arg]);\n\t\texit(5);\n\t    }\n\n\t    bool one_value_parsed = false;\n\n\t    while (!feof(file))\t  // Parse all values until EOF\n\t    {\n\t\tParser parser(file, argv[arg]);   // set parser to file\n\n\t\tYCodePtr pc = parser.parse ();\n\n\t\tif ( pc )\n\t\t{\n\t\t    arglist->add( pc->evaluate(true) );\n\t\t    one_value_parsed = true;\n\t\t}\n\t    }\n\n\t    fclose (file);\n\n\t    if (!one_value_parsed)\n\t    {\n\t\tprint_error (\"Client option -f: Couldn't parse valid YCP value from file %s\",\n\t\t\t     argv[arg]);\n\t\texit(5);\n\t    }\n\t}\n\telse if (has_parens (argv[arg]))\t// client args\n\t{\n\t  if (args_are_ycp)\t// bnc#382883\n\t  {\n\t    Parser parser (argv[arg]);\t// set parser to option\n\n\t    YCodePtr pc = parser.parse ();\n\n\t    if (!pc )\n\t    {\n\t\tprint_error (\"Client option %s is not a valid YCP value\", argv[arg]);\n\t\texit(5);\n\t    }\n\n\t    arglist->add( pc->evaluate (true));   // add to arglist\n\t  }\n\t  else\n\t  {\n\t      string value(argv[arg] + 1, strlen (argv[arg]) - 2);\n\t      arglist->add (YCPString (value));\n\t  }\n\t}\n\telse break;   // must be server name\n\n\targ++;\t      // switch to next argument\n    } // Parsing client options\n}"
  },
  {
    "function_name": "logger_initializer",
    "container": "logger_initializer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "357-368",
    "snippet": "logger_initializer()\n\t{\n#if BLOCXX_LIBRARY_VERSION >= 5\n\t\tblocxx::LogAppender::setDefaultLogAppender(\n\t\t\tblocxx::LogAppenderRef(new YaSTLogger())\n\t\t);\n#else\n\t\tblocxx::Logger::setDefaultLogger(\n\t\t\tblocxx::LoggerRef(new YaSTLogger())\n\t\t);\n#endif\n\t}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocxx::Logger::setDefaultLogger",
          "args": [
            "blocxx::LoggerRef(new YaSTLogger())"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blocxx::LoggerRef",
          "args": [
            "new YaSTLogger()"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blocxx::LogAppender::setDefaultLogAppender",
          "args": [
            "blocxx::LogAppenderRef(new YaSTLogger())"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blocxx::LogAppenderRef",
          "args": [
            "new YaSTLogger()"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nlogger_initializer {\n  logger_initializer()\n  \t{\n  #if BLOCXX_LIBRARY_VERSION >= 5\n  \t\tblocxx::LogAppender::setDefaultLogAppender(\n  \t\t\tblocxx::LogAppenderRef(new YaSTLogger())\n  \t\t);\n  #else\n  \t\tblocxx::Logger::setDefaultLogger(\n  \t\t\tblocxx::LoggerRef(new YaSTLogger())\n  \t\t);\n  #endif\n  \t}\n}"
  },
  {
    "function_name": "doClone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "347-350",
    "snippet": "virtual blocxx::LoggerRef doClone() const\n\t{\n    \t    return blocxx::LoggerRef(new YaSTLogger(*this));\n\t}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocxx::LoggerRef",
          "args": [
            "new YaSTLogger(*this)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nvirtual blocxx::LoggerRef doClone() const\n\t{\n    \t    return blocxx::LoggerRef(new YaSTLogger(*this));\n\t}"
  },
  {
    "function_name": "doProcessLogMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "321-341",
    "snippet": "virtual void doProcessLogMessage(const blocxx::LogMessage& m) const\n#endif\n\t{\n\t    loglevel_t level = LOG_DEBUG;\n\t    if (m.category == blocxx::Logger::STR_FATAL_CATEGORY\n\t\t|| m.category == blocxx::Logger::STR_ERROR_CATEGORY)\n\t    {\n\t\tlevel = LOG_ERROR;\n#if BLOCXX_LIBRARY_VERSION >= 5\n\t    } else if (m.category == blocxx::Logger::STR_WARNING_CATEGORY)\n\t    {\n\t\tlevel = LOG_WARNING;\n#endif\n\t    } else if (m.category == blocxx::Logger::STR_INFO_CATEGORY)\n\t    {\n\t\tlevel = LOG_MILESTONE;\n\t    }\n\n\t    y2_logger(level,m.component.c_str ()\n\t\t,m.filename,m.fileline,m.methodname,\"%s\", m.message.c_str ());\n\t}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2_logger",
          "args": [
            "level",
            "m.component.c_str ()",
            "m.filename",
            "m.fileline",
            "m.methodname",
            "\"%s\"",
            "m.message.c_str ()"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m.message.c_str",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m.component.c_str",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nvirtual void doProcessLogMessage(const blocxx::LogMessage& m) const\n#endif\n\t{\n\t    loglevel_t level = LOG_DEBUG;\n\t    if (m.category == blocxx::Logger::STR_FATAL_CATEGORY\n\t\t|| m.category == blocxx::Logger::STR_ERROR_CATEGORY)\n\t    {\n\t\tlevel = LOG_ERROR;\n#if BLOCXX_LIBRARY_VERSION >= 5\n\t    } else if (m.category == blocxx::Logger::STR_WARNING_CATEGORY)\n\t    {\n\t\tlevel = LOG_WARNING;\n#endif\n\t    } else if (m.category == blocxx::Logger::STR_INFO_CATEGORY)\n\t    {\n\t\tlevel = LOG_MILESTONE;\n\t    }\n\n\t    y2_logger(level,m.component.c_str ()\n\t\t,m.filename,m.fileline,m.methodname,\"%s\", m.message.c_str ());\n\t}"
  },
  {
    "function_name": "YaSTLogger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "306-306",
    "snippet": "YaSTLogger() : blocxx::Logger (\"YaST\",blocxx::E_ALL_LEVEL) {}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nYaSTLogger() : blocxx::Logger (\"YaST\",blocxx::E_ALL_LEVEL) {}"
  },
  {
    "function_name": "YaSTLogger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "299-304",
    "snippet": "YaSTLogger() : blocxx::LogAppender(\n\t\t\tblocxx::LogAppender::ALL_COMPONENTS,\n\t\t\tblocxx::LogAppender::ALL_CATEGORIES,\n\t\t\tblocxx::LogAppender::STR_TTCC_MESSAGE_FORMAT\n\t\t)\n\t{}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nYaSTLogger() : blocxx::LogAppender(\n\t\t\tblocxx::LogAppender::ALL_COMPONENTS,\n\t\t\tblocxx::LogAppender::ALL_CATEGORIES,\n\t\t\tblocxx::LogAppender::STR_TTCC_MESSAGE_FORMAT\n\t\t)\n\t{}"
  },
  {
    "function_name": "signal_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "236-269",
    "snippet": "void\nsignal_handler (int sig)\n{\n    signal (sig, SIG_IGN);\n\n    // bnc#493152#c19 only signal-safe functions are allowed\n    char buffer[200];\n    int n = snprintf (buffer, sizeof(buffer),\n\t\t      \"YaST got signal %d at YCP file %s:%d\\n\",\n\t\t      sig, ee.filename ().c_str (), ee.linenumber ());\n    if (n >= (int)sizeof(buffer) || n < 0)\n\tstrcpy (buffer, \"YaST got a signal.\\n\");\n    signal_log_to_fd (STDERR_FILENO, buffer);\n\n    signal_log_open ();\n    if (signal_log_fd == -1)\n    {\n\tsignal_log_to_fd (STDERR_FILENO, \"Could not open log file.\\n\");\n    }\n    else\n    {\n\tsignal_log_timestamp ();\n\tsignal_log (buffer);\n\tsignal_log_stored_debug ();\n\tsignal_log_backtrace ();\n\n\tif (close (signal_log_fd) == -1)\n\t    perror (\"log close\");\n    }\n\n    // bye\n    signal (sig, SIG_DFL);\n    kill ( getpid (), sig);\n}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ExecutionEnvironment ee;",
      "int signal_log_fd;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "getpid ()",
            "sig"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "getpid",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/ExternalProgram.h",
          "lines": "109-109",
          "snippet": "pid_t getpid() { return pid; }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <y2util/ExternalDataSource.h>",
            "#include <string>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <y2util/ExternalDataSource.h>\n#include <string>\n#include <map>\n\nExternalProgram {\n  pid_t getpid() { return pid; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "sig",
            "SIG_DFL"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "signal_log_to_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "136-161",
          "snippet": "static\nvoid\nsignal_log_to_fd (int fd, const char * cs)\n{\n    ssize_t n = strlen (cs);\n    while (true) {\n       ssize_t w = write(fd, cs, n);\n       if (w == n)\n\t   break;              // success\n       else if (w == -1) {\n\t   if (errno == EINTR) {\n\t       // perror(\"gotcha\"); // bnc#470645\n\t   }\n\t   else {\n\t       perror(\"write\"); // other cases\n\t       break;\n\t   }\n       }\n       else {\n\t   errno = 0;\n\t   cs += w;\n\t   n -= w;\n       }\n    }\n\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic\nvoid\nsignal_log_to_fd (int fd, const char * cs)\n{\n    ssize_t n = strlen (cs);\n    while (true) {\n       ssize_t w = write(fd, cs, n);\n       if (w == n)\n\t   break;              // success\n       else if (w == -1) {\n\t   if (errno == EINTR) {\n\t       // perror(\"gotcha\"); // bnc#470645\n\t   }\n\t   else {\n\t       perror(\"write\"); // other cases\n\t       break;\n\t   }\n       }\n       else {\n\t   errno = 0;\n\t   cs += w;\n\t   n -= w;\n       }\n    }\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"log close\""
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "signal_log_fd"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_log_backtrace",
          "args": [],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "signal_log_backtrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "206-215",
          "snippet": "void\nsignal_log_backtrace ()\n{\n    static const int N = 100;\n    void *frames[N];\n    size_t size = backtrace (frames, N);\n    // demangling is not signal safe\n    signal_log (\"Backtrace: (use c++filt to demangle)\\n\");\n    backtrace_symbols_fd (frames, size, signal_log_fd);\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int signal_log_fd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nint signal_log_fd;\n\nvoid\nsignal_log_backtrace ()\n{\n    static const int N = 100;\n    void *frames[N];\n    size_t size = backtrace (frames, N);\n    // demangling is not signal safe\n    signal_log (\"Backtrace: (use c++filt to demangle)\\n\");\n    backtrace_symbols_fd (frames, size, signal_log_fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_log_stored_debug",
          "args": [],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "signal_log_stored_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "197-203",
          "snippet": "static\nvoid signal_log_stored_debug ()\n{\n    signal_log (\"Liberating suppressed debugging messages:\\n\");\n    blanik.for_each (signal_log_ss);\n    signal_log (\"End of suppressed debugging messages\\n\");\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic\nvoid signal_log_stored_debug ()\n{\n    signal_log (\"Liberating suppressed debugging messages:\\n\");\n    blanik.for_each (signal_log_ss);\n    signal_log (\"End of suppressed debugging messages\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_log",
          "args": [
            "buffer"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "signal_log_ss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "170-176",
          "snippet": "static\nbool\nsignal_log_ss (const string & s)\n{\n    signal_log (s.c_str ());\n    return true;\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic\nbool\nsignal_log_ss (const string & s)\n{\n    signal_log (s.c_str ());\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_log_timestamp",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "signal_log_timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "179-194",
          "snippet": "static\nvoid\nsignal_log_timestamp ()\n{\n    char buffer[200];\n    time_t time_time;\n    struct tm tm_time;\n\n    time_time = time(NULL);\n    localtime_r (&time_time, &tm_time);\n\n    if (strftime(buffer, sizeof(buffer), \"=== %F %T %z ===\\n\", &tm_time) != 0)\n    {\n\tsignal_log (buffer);\n    }\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic\nvoid\nsignal_log_timestamp ()\n{\n    char buffer[200];\n    time_t time_time;\n    struct tm tm_time;\n\n    time_time = time(NULL);\n    localtime_r (&time_time, &tm_time);\n\n    if (strftime(buffer, sizeof(buffer), \"=== %F %T %z ===\\n\", &tm_time) != 0)\n    {\n\tsignal_log (buffer);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_log_open",
          "args": [],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "signal_log_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "217-234",
          "snippet": "void\nsignal_log_open ()\n{\n    signal_log_fd = -1;\n\n    const char * logfns[] = {\n\t\"/var/log/YaST2/signal\",\n\t\"y2signal.log\",\n\tNULL,\t\t\t// sentinel\n    };\n\n    for (const char ** logfn_p = &logfns[0]; *logfn_p != NULL; ++logfn_p)\n    {\n\tsignal_log_fd = open (*logfn_p, O_WRONLY | O_CREAT | O_APPEND, 0600);\n\tif (signal_log_fd != -1)\n\t    break;\n    }\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int signal_log_fd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nint signal_log_fd;\n\nvoid\nsignal_log_open ()\n{\n    signal_log_fd = -1;\n\n    const char * logfns[] = {\n\t\"/var/log/YaST2/signal\",\n\t\"y2signal.log\",\n\tNULL,\t\t\t// sentinel\n    };\n\n    for (const char ** logfn_p = &logfns[0]; *logfn_p != NULL; ++logfn_p)\n    {\n\tsignal_log_fd = open (*logfn_p, O_WRONLY | O_CREAT | O_APPEND, 0600);\n\tif (signal_log_fd != -1)\n\t    break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "\"YaST got a signal.\\n\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"YaST got signal %d at YCP file %s:%d\\n\"",
            "sig",
            "ee.filename ().c_str ()",
            "ee.linenumber ()"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee.linenumber",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "linenumber",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "41-45",
          "snippet": "int\nExecutionEnvironment::linenumber () const\n{\n    return m_linenumber;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  int\n  ExecutionEnvironment::linenumber () const\n  {\n      return m_linenumber;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.filename",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "filename",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "335-339",
          "snippet": "string\nScanner::filename () const\n{\n    return m_filename;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  string\n  Scanner::filename () const\n  {\n      return m_filename;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nExecutionEnvironment ee;\nint signal_log_fd;\n\nvoid\nsignal_handler (int sig)\n{\n    signal (sig, SIG_IGN);\n\n    // bnc#493152#c19 only signal-safe functions are allowed\n    char buffer[200];\n    int n = snprintf (buffer, sizeof(buffer),\n\t\t      \"YaST got signal %d at YCP file %s:%d\\n\",\n\t\t      sig, ee.filename ().c_str (), ee.linenumber ());\n    if (n >= (int)sizeof(buffer) || n < 0)\n\tstrcpy (buffer, \"YaST got a signal.\\n\");\n    signal_log_to_fd (STDERR_FILENO, buffer);\n\n    signal_log_open ();\n    if (signal_log_fd == -1)\n    {\n\tsignal_log_to_fd (STDERR_FILENO, \"Could not open log file.\\n\");\n    }\n    else\n    {\n\tsignal_log_timestamp ();\n\tsignal_log (buffer);\n\tsignal_log_stored_debug ();\n\tsignal_log_backtrace ();\n\n\tif (close (signal_log_fd) == -1)\n\t    perror (\"log close\");\n    }\n\n    // bye\n    signal (sig, SIG_DFL);\n    kill ( getpid (), sig);\n}"
  },
  {
    "function_name": "signal_log_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "217-234",
    "snippet": "void\nsignal_log_open ()\n{\n    signal_log_fd = -1;\n\n    const char * logfns[] = {\n\t\"/var/log/YaST2/signal\",\n\t\"y2signal.log\",\n\tNULL,\t\t\t// sentinel\n    };\n\n    for (const char ** logfn_p = &logfns[0]; *logfn_p != NULL; ++logfn_p)\n    {\n\tsignal_log_fd = open (*logfn_p, O_WRONLY | O_CREAT | O_APPEND, 0600);\n\tif (signal_log_fd != -1)\n\t    break;\n    }\n}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int signal_log_fd;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "open",
          "args": [
            "*logfn_p",
            "O_WRONLY | O_CREAT | O_APPEND",
            "0600"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nint signal_log_fd;\n\nvoid\nsignal_log_open ()\n{\n    signal_log_fd = -1;\n\n    const char * logfns[] = {\n\t\"/var/log/YaST2/signal\",\n\t\"y2signal.log\",\n\tNULL,\t\t\t// sentinel\n    };\n\n    for (const char ** logfn_p = &logfns[0]; *logfn_p != NULL; ++logfn_p)\n    {\n\tsignal_log_fd = open (*logfn_p, O_WRONLY | O_CREAT | O_APPEND, 0600);\n\tif (signal_log_fd != -1)\n\t    break;\n    }\n}"
  },
  {
    "function_name": "signal_log_backtrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "206-215",
    "snippet": "void\nsignal_log_backtrace ()\n{\n    static const int N = 100;\n    void *frames[N];\n    size_t size = backtrace (frames, N);\n    // demangling is not signal safe\n    signal_log (\"Backtrace: (use c++filt to demangle)\\n\");\n    backtrace_symbols_fd (frames, size, signal_log_fd);\n}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int signal_log_fd;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "backtrace_symbols_fd",
          "args": [
            "frames",
            "size",
            "signal_log_fd"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_log",
          "args": [
            "\"Backtrace: (use c++filt to demangle)\\n\""
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "signal_log_ss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "170-176",
          "snippet": "static\nbool\nsignal_log_ss (const string & s)\n{\n    signal_log (s.c_str ());\n    return true;\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic\nbool\nsignal_log_ss (const string & s)\n{\n    signal_log (s.c_str ());\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "backtrace",
          "args": [
            "frames",
            "N"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "backtrace",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "123-142",
          "snippet": "void\nExecutionEnvironment::backtrace (loglevel_t level, uint omit) const\n{\n    if (m_backtrace.empty ())\n\treturn;\n\t\n    // FIXME: omit\n    CallStack::const_reverse_iterator it = m_backtrace.rbegin();\n\n    y2logger(level, \"------------- Backtrace begin -------------\");\n    \n    while (it != m_backtrace.rend())\n    {\n\tycp2log (level, (*it)->filename.c_str (), (*it)->linenumber\n\t\t , \"\", \"%s\", (*it)->function->entry()->toString().c_str());\n\t++it;\n    };\n\n    y2logger(level, \"------------- Backtrace end ---------------\");\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  void\n  ExecutionEnvironment::backtrace (loglevel_t level, uint omit) const\n  {\n      if (m_backtrace.empty ())\n  \treturn;\n  \t\n      // FIXME: omit\n      CallStack::const_reverse_iterator it = m_backtrace.rbegin();\n  \n      y2logger(level, \"------------- Backtrace begin -------------\");\n      \n      while (it != m_backtrace.rend())\n      {\n  \tycp2log (level, (*it)->filename.c_str (), (*it)->linenumber\n  \t\t , \"\", \"%s\", (*it)->function->entry()->toString().c_str());\n  \t++it;\n      };\n  \n      y2logger(level, \"------------- Backtrace end ---------------\");\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nint signal_log_fd;\n\nvoid\nsignal_log_backtrace ()\n{\n    static const int N = 100;\n    void *frames[N];\n    size_t size = backtrace (frames, N);\n    // demangling is not signal safe\n    signal_log (\"Backtrace: (use c++filt to demangle)\\n\");\n    backtrace_symbols_fd (frames, size, signal_log_fd);\n}"
  },
  {
    "function_name": "signal_log_stored_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "197-203",
    "snippet": "static\nvoid signal_log_stored_debug ()\n{\n    signal_log (\"Liberating suppressed debugging messages:\\n\");\n    blanik.for_each (signal_log_ss);\n    signal_log (\"End of suppressed debugging messages\\n\");\n}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_log",
          "args": [
            "\"End of suppressed debugging messages\\n\""
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "signal_log_ss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "170-176",
          "snippet": "static\nbool\nsignal_log_ss (const string & s)\n{\n    signal_log (s.c_str ());\n    return true;\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic\nbool\nsignal_log_ss (const string & s)\n{\n    signal_log (s.c_str ());\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blanik.for_each",
          "args": [
            "signal_log_ss"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "for_each",
          "container": "LogTail",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "653-656",
          "snippet": "void LogTail::for_each (LogTail::Consumer c)\n{\n    m_impl->for_each (c);\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nLogTail {\n  void LogTail::for_each (LogTail::Consumer c)\n  {\n      m_impl->for_each (c);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic\nvoid signal_log_stored_debug ()\n{\n    signal_log (\"Liberating suppressed debugging messages:\\n\");\n    blanik.for_each (signal_log_ss);\n    signal_log (\"End of suppressed debugging messages\\n\");\n}"
  },
  {
    "function_name": "signal_log_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "179-194",
    "snippet": "static\nvoid\nsignal_log_timestamp ()\n{\n    char buffer[200];\n    time_t time_time;\n    struct tm tm_time;\n\n    time_time = time(NULL);\n    localtime_r (&time_time, &tm_time);\n\n    if (strftime(buffer, sizeof(buffer), \"=== %F %T %z ===\\n\", &tm_time) != 0)\n    {\n\tsignal_log (buffer);\n    }\n}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_log",
          "args": [
            "buffer"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "signal_log_ss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "170-176",
          "snippet": "static\nbool\nsignal_log_ss (const string & s)\n{\n    signal_log (s.c_str ());\n    return true;\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic\nbool\nsignal_log_ss (const string & s)\n{\n    signal_log (s.c_str ());\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strftime",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"=== %F %T %z ===\\n\"",
            "&tm_time"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localtime_r",
          "args": [
            "&time_time",
            "&tm_time"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic\nvoid\nsignal_log_timestamp ()\n{\n    char buffer[200];\n    time_t time_time;\n    struct tm tm_time;\n\n    time_time = time(NULL);\n    localtime_r (&time_time, &tm_time);\n\n    if (strftime(buffer, sizeof(buffer), \"=== %F %T %z ===\\n\", &tm_time) != 0)\n    {\n\tsignal_log (buffer);\n    }\n}"
  },
  {
    "function_name": "signal_log_ss",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "170-176",
    "snippet": "static\nbool\nsignal_log_ss (const string & s)\n{\n    signal_log (s.c_str ());\n    return true;\n}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_log",
          "args": [
            "s.c_str ()"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "signal_log_ss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "170-176",
          "snippet": "static\nbool\nsignal_log_ss (const string & s)\n{\n    signal_log (s.c_str ());\n    return true;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "s.c_str",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic\nbool\nsignal_log_ss (const string & s)\n{\n    signal_log (s.c_str ());\n    return true;\n}"
  },
  {
    "function_name": "signal_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "163-168",
    "snippet": "static\nvoid\nsignal_log (const char * cs)\n{\n    signal_log_to_fd (signal_log_fd, cs);\n}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int signal_log_fd;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_log_to_fd",
          "args": [
            "signal_log_fd",
            "cs"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "signal_log_to_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
          "lines": "136-161",
          "snippet": "static\nvoid\nsignal_log_to_fd (int fd, const char * cs)\n{\n    ssize_t n = strlen (cs);\n    while (true) {\n       ssize_t w = write(fd, cs, n);\n       if (w == n)\n\t   break;              // success\n       else if (w == -1) {\n\t   if (errno == EINTR) {\n\t       // perror(\"gotcha\"); // bnc#470645\n\t   }\n\t   else {\n\t       perror(\"write\"); // other cases\n\t       break;\n\t   }\n       }\n       else {\n\t   errno = 0;\n\t   cs += w;\n\t   n -= w;\n       }\n    }\n\n}",
          "includes": [
            "#include <blocxx/LogConfig.hpp>",
            "#include <blocxx/LogAppender.hpp>",
            "#include <blocxx/LogMessage.hpp>",
            "#include <blocxx/Logger.hpp>",
            "#include <blocxx/BLOCXX_config.h>",
            "#include <debugger/Debugger.h>",
            "#include \"exitcodes.h\"",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/Parser.h>",
            "#include <YCP.h>",
            "#include \"Y2ComponentBroker.h\"",
            "#include \"Y2ErrorComponent.h\"",
            "#include \"Y2Component.h\"",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <string>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic\nvoid\nsignal_log_to_fd (int fd, const char * cs)\n{\n    ssize_t n = strlen (cs);\n    while (true) {\n       ssize_t w = write(fd, cs, n);\n       if (w == n)\n\t   break;              // success\n       else if (w == -1) {\n\t   if (errno == EINTR) {\n\t       // perror(\"gotcha\"); // bnc#470645\n\t   }\n\t   else {\n\t       perror(\"write\"); // other cases\n\t       break;\n\t   }\n       }\n       else {\n\t   errno = 0;\n\t   cs += w;\n\t   n -= w;\n       }\n    }\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nint signal_log_fd;\n\nstatic\nvoid\nsignal_log (const char * cs)\n{\n    signal_log_to_fd (signal_log_fd, cs);\n}"
  },
  {
    "function_name": "signal_log_to_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/genericfrontend.cc",
    "lines": "136-161",
    "snippet": "static\nvoid\nsignal_log_to_fd (int fd, const char * cs)\n{\n    ssize_t n = strlen (cs);\n    while (true) {\n       ssize_t w = write(fd, cs, n);\n       if (w == n)\n\t   break;              // success\n       else if (w == -1) {\n\t   if (errno == EINTR) {\n\t       // perror(\"gotcha\"); // bnc#470645\n\t   }\n\t   else {\n\t       perror(\"write\"); // other cases\n\t       break;\n\t   }\n       }\n       else {\n\t   errno = 0;\n\t   cs += w;\n\t   n -= w;\n       }\n    }\n\n}",
    "includes": [
      "#include <blocxx/LogConfig.hpp>",
      "#include <blocxx/LogAppender.hpp>",
      "#include <blocxx/LogMessage.hpp>",
      "#include <blocxx/Logger.hpp>",
      "#include <blocxx/BLOCXX_config.h>",
      "#include <debugger/Debugger.h>",
      "#include \"exitcodes.h\"",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/Parser.h>",
      "#include <YCP.h>",
      "#include \"Y2ComponentBroker.h\"",
      "#include \"Y2ErrorComponent.h\"",
      "#include \"Y2Component.h\"",
      "#include <ycp/ExecutionEnvironment.h>",
      "#include <ycp/y2log.h>",
      "#include <string>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"write\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "cs",
            "n"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "write_helper",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "1018-1077",
          "snippet": "int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n{\n    char * out_buffer;\n    string indent;\n    string indent2;\n    int readby = ini.getReadBy ();\n    if (!subindent.empty ())\n    {\n\tfor (int ii = 0; ii<depth - 1;ii++)\n\t    indent = indent + subindent;\n\tif (depth)\n\t    indent2 = indent + subindent;\n    }\n\n    if (ini.getComment ()[0])\n        of << ini.getComment();\n    if (readby>=0 && readby < (int)sections.size ())\n\t{\n\t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free (out_buffer);\n\t}\n    \n    IniIterator\n\tci = ini.getContainerBegin (),\n\tce = ini.getContainerEnd ();\n\n    for (;ci != ce; ++ci)\n\t{\n\t    if (ci->t () == SECTION)\n\t\t{\n\t\t    write_helper (ci->s (), of, depth + 1);\n\t\t    ci->s ().clean();\n\t\t}\n\t    else\n\t\t{\n\t\t    IniEntry&e = ci->e ();\n\t\t    if (e.getComment ()[0])\n\t\t\tof << e.getComment();\n\t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n\t\t\t// bnc#492859, a fixed buffer is too small\n\t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n\t\t\tof << indent2 << out_buffer << \"\\n\";\n\t\t\tfree(out_buffer);\n\t\t    }\n\t\t    e.clean();\n\t\t}\n\t}\n\n    if (ini.getEndComment ()[0])\n        of << indent << ini.getEndComment();\n    if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n\t{\n\t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free(out_buffer);\n\t}\n    ini.clean();\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n  {\n      char * out_buffer;\n      string indent;\n      string indent2;\n      int readby = ini.getReadBy ();\n      if (!subindent.empty ())\n      {\n  \tfor (int ii = 0; ii<depth - 1;ii++)\n  \t    indent = indent + subindent;\n  \tif (depth)\n  \t    indent2 = indent + subindent;\n      }\n  \n      if (ini.getComment ()[0])\n          of << ini.getComment();\n      if (readby>=0 && readby < (int)sections.size ())\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free (out_buffer);\n  \t}\n      \n      IniIterator\n  \tci = ini.getContainerBegin (),\n  \tce = ini.getContainerEnd ();\n  \n      for (;ci != ce; ++ci)\n  \t{\n  \t    if (ci->t () == SECTION)\n  \t\t{\n  \t\t    write_helper (ci->s (), of, depth + 1);\n  \t\t    ci->s ().clean();\n  \t\t}\n  \t    else\n  \t\t{\n  \t\t    IniEntry&e = ci->e ();\n  \t\t    if (e.getComment ()[0])\n  \t\t\tof << e.getComment();\n  \t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n  \t\t\t// bnc#492859, a fixed buffer is too small\n  \t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n  \t\t\tof << indent2 << out_buffer << \"\\n\";\n  \t\t\tfree(out_buffer);\n  \t\t    }\n  \t\t    e.clean();\n  \t\t}\n  \t}\n  \n      if (ini.getEndComment ()[0])\n          of << indent << ini.getEndComment();\n      if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free(out_buffer);\n  \t}\n      ini.clean();\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cs"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <blocxx/LogConfig.hpp>\n#include <blocxx/LogAppender.hpp>\n#include <blocxx/LogMessage.hpp>\n#include <blocxx/Logger.hpp>\n#include <blocxx/BLOCXX_config.h>\n#include <debugger/Debugger.h>\n#include \"exitcodes.h\"\n#include <ycp/pathsearch.h>\n#include <ycp/Parser.h>\n#include <YCP.h>\n#include \"Y2ComponentBroker.h\"\n#include \"Y2ErrorComponent.h\"\n#include \"Y2Component.h\"\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdarg.h>\n\nstatic\nvoid\nsignal_log_to_fd (int fd, const char * cs)\n{\n    ssize_t n = strlen (cs);\n    while (true) {\n       ssize_t w = write(fd, cs, n);\n       if (w == n)\n\t   break;              // success\n       else if (w == -1) {\n\t   if (errno == EINTR) {\n\t       // perror(\"gotcha\"); // bnc#470645\n\t   }\n\t   else {\n\t       perror(\"write\"); // other cases\n\t       break;\n\t   }\n       }\n       else {\n\t   errno = 0;\n\t   cs += w;\n\t   n -= w;\n       }\n    }\n\n}"
  }
]