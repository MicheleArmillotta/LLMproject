[
  {
    "function_name": "setType",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "1224-1227",
    "snippet": "void YBlock::setType (constTypePtr type)\n{\n    m_type = type;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  void YBlock::setType (constTypePtr type)\n  {\n      m_type = type;\n  }\n}"
  },
  {
    "function_name": "addIncluded",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "1155-1167",
    "snippet": "void\nYBlock::addIncluded (string includefile)\n{\n    if (! m_includes)\n    {\n\tm_includes = new stringlist_t;\n    }\n    \n    if (find (m_includes->begin (), m_includes->end (), includefile) == m_includes->end ())\n    {\n\tm_includes->push_back (includefile);\n    }\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_includes->push_back",
          "args": [
            "includefile"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_includes->end",
          "args": [],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "find",
          "args": [
            "m_includes->begin ()",
            "m_includes->end ()",
            "includefile"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "l_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
          "lines": "45-101",
          "snippet": "static YCPValue\nl_find (const YCPSymbol &symbol, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin find\n     * @id find-list\n     * @short Searches for the first occurence of a certain element in a list\n     * @param any VAR\n     * @param list LIST\n     * @param block EXPR\n     *\n     * @description\n     * Searches for a certain item in the list. It applies the expression\n     * <tt>EXPR</tt> to each element in the list and returns the first element\n     * the makes the expression evaluate to true, if <tt>VAR</tt> is bound to\n     * that element.\n     *\n     * @return any Returns nil, if nothing is found.\n     * @usage find (integer n, [3,5,6,4], ``(n >= 5)) -> 5\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPValue ret = YCPNull ();\n\n    SymbolEntryPtr s = symbol->asEntry()->entry();\n\n    for (YCPList::const_iterator it = list->begin(); it != list->end(); ++it)\n    {\n\ts->setValue(*it);\n\n\tYCPValue v = expr->evaluate ();\n\n\tif (v.isNull ())\n\t{\n\t    ycp2error (\"Bad find expression %s\", expr->toString ().c_str ());\n\t    break;\n\t}\n\t// nil == false\n\tif (v->isVoid ())\n\t{\n\t    ycp2error (\"The expression for 'find' returned 'nil'\");\n\t    continue;\n\t}\n\n\tif (v->asBoolean ()->value ())\n\t{\n\t    ret = *it;\n\t    break;\n\t}\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPBuiltinList.h\"",
            "#include <algorithm>\t\t// sort",
            "#include <set>\t\t\t// for toset"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_find (const YCPSymbol &symbol, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin find\n     * @id find-list\n     * @short Searches for the first occurence of a certain element in a list\n     * @param any VAR\n     * @param list LIST\n     * @param block EXPR\n     *\n     * @description\n     * Searches for a certain item in the list. It applies the expression\n     * <tt>EXPR</tt> to each element in the list and returns the first element\n     * the makes the expression evaluate to true, if <tt>VAR</tt> is bound to\n     * that element.\n     *\n     * @return any Returns nil, if nothing is found.\n     * @usage find (integer n, [3,5,6,4], ``(n >= 5)) -> 5\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPValue ret = YCPNull ();\n\n    SymbolEntryPtr s = symbol->asEntry()->entry();\n\n    for (YCPList::const_iterator it = list->begin(); it != list->end(); ++it)\n    {\n\ts->setValue(*it);\n\n\tYCPValue v = expr->evaluate ();\n\n\tif (v.isNull ())\n\t{\n\t    ycp2error (\"Bad find expression %s\", expr->toString ().c_str ());\n\t    break;\n\t}\n\t// nil == false\n\tif (v->isVoid ())\n\t{\n\t    ycp2error (\"The expression for 'find' returned 'nil'\");\n\t    continue;\n\t}\n\n\tif (v->asBoolean ()->value ())\n\t{\n\t    ret = *it;\n\t    break;\n\t}\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_includes->begin",
          "args": [],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  void\n  YBlock::addIncluded (string includefile)\n  {\n      if (! m_includes)\n      {\n  \tm_includes = new stringlist_t;\n      }\n      \n      if (find (m_includes->begin (), m_includes->end (), includefile) == m_includes->end ())\n      {\n  \tm_includes->push_back (includefile);\n      }\n  }\n}"
  },
  {
    "function_name": "isIncluded",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "1145-1152",
    "snippet": "bool\nYBlock::isIncluded (string includefile) const\n{\n    if (! m_includes)\n\treturn false;\n\n    return find (m_includes->begin (), m_includes->end (), includefile) != m_includes->end ();\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_includes->end",
          "args": [],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "find",
          "args": [
            "m_includes->begin ()",
            "m_includes->end ()",
            "includefile"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "l_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
          "lines": "45-101",
          "snippet": "static YCPValue\nl_find (const YCPSymbol &symbol, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin find\n     * @id find-list\n     * @short Searches for the first occurence of a certain element in a list\n     * @param any VAR\n     * @param list LIST\n     * @param block EXPR\n     *\n     * @description\n     * Searches for a certain item in the list. It applies the expression\n     * <tt>EXPR</tt> to each element in the list and returns the first element\n     * the makes the expression evaluate to true, if <tt>VAR</tt> is bound to\n     * that element.\n     *\n     * @return any Returns nil, if nothing is found.\n     * @usage find (integer n, [3,5,6,4], ``(n >= 5)) -> 5\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPValue ret = YCPNull ();\n\n    SymbolEntryPtr s = symbol->asEntry()->entry();\n\n    for (YCPList::const_iterator it = list->begin(); it != list->end(); ++it)\n    {\n\ts->setValue(*it);\n\n\tYCPValue v = expr->evaluate ();\n\n\tif (v.isNull ())\n\t{\n\t    ycp2error (\"Bad find expression %s\", expr->toString ().c_str ());\n\t    break;\n\t}\n\t// nil == false\n\tif (v->isVoid ())\n\t{\n\t    ycp2error (\"The expression for 'find' returned 'nil'\");\n\t    continue;\n\t}\n\n\tif (v->asBoolean ()->value ())\n\t{\n\t    ret = *it;\n\t    break;\n\t}\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPBuiltinList.h\"",
            "#include <algorithm>\t\t// sort",
            "#include <set>\t\t\t// for toset"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_find (const YCPSymbol &symbol, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin find\n     * @id find-list\n     * @short Searches for the first occurence of a certain element in a list\n     * @param any VAR\n     * @param list LIST\n     * @param block EXPR\n     *\n     * @description\n     * Searches for a certain item in the list. It applies the expression\n     * <tt>EXPR</tt> to each element in the list and returns the first element\n     * the makes the expression evaluate to true, if <tt>VAR</tt> is bound to\n     * that element.\n     *\n     * @return any Returns nil, if nothing is found.\n     * @usage find (integer n, [3,5,6,4], ``(n >= 5)) -> 5\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPValue ret = YCPNull ();\n\n    SymbolEntryPtr s = symbol->asEntry()->entry();\n\n    for (YCPList::const_iterator it = list->begin(); it != list->end(); ++it)\n    {\n\ts->setValue(*it);\n\n\tYCPValue v = expr->evaluate ();\n\n\tif (v.isNull ())\n\t{\n\t    ycp2error (\"Bad find expression %s\", expr->toString ().c_str ());\n\t    break;\n\t}\n\t// nil == false\n\tif (v->isVoid ())\n\t{\n\t    ycp2error (\"The expression for 'find' returned 'nil'\");\n\t    continue;\n\t}\n\n\tif (v->asBoolean ()->value ())\n\t{\n\t    ret = *it;\n\t    break;\n\t}\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_includes->begin",
          "args": [],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  bool\n  YBlock::isIncluded (string includefile) const\n  {\n      if (! m_includes)\n  \treturn false;\n  \n      return find (m_includes->begin (), m_includes->end (), includefile) != m_includes->end ();\n  }\n}"
  },
  {
    "function_name": "YBlock",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "843-976",
    "snippet": "YBlock::YBlock (bytecodeistream & str)\n    : YCode ()\n    , m_kind (b_unknown)\n    , m_name (\"\")\n    , m_tenvironment (0)\n    , m_last_tparm (0)\n    , m_point (0)\n    , m_statements (0)\n    , m_last_statement (0)\n    , m_includes (0)\n    , m_running (false)\n{\n    Bytecode::readString (str, m_name);\t\t// read name\n\n    m_kind = (blockkind_t)Bytecode::readInt32 (str);\n\n    Bytecode::pushNamespace (nameSpace());\n\n    unsigned int scount = Bytecode::readInt32 (str);\t// read Y2Namespace::m_symbols\n\n#if DO_DEBUG\n    y2debug(\"YBlock::fromStream (%p:\\\"%s\\\", %d entries, kind %d)\", this, m_name.c_str(), scount, m_kind);\n#endif\n\n    // read all symbol entries belonging to this block\n\n    if (scount > 0)\n    {\n\tfor (unsigned int i = 0; i < scount; i++)\n\t{\n\t    SymbolEntryPtr sentry = new YSymbolEntry (str, nameSpace());\n\t    addSymbol (sentry);\n\t}\n\n\tif (m_kind == b_module)\t\t\t// if its a module, re-construct the table\n\t{\n\t    int tcount = Bytecode::readInt32 (str);\n#if DO_DEBUG\n\t    y2debug (\"Module with %d table entries\", tcount);\n#endif\n\n\t    if (tcount > 0\n\t\t&& m_table == 0)\n\t    {\n\t\tm_table = new SymbolTable (-1);\n\t    }\n\n\t    // HACK ahead: Y2ALLGLOBAL should make all\n\t    // symbols visible. It works now, but as a trade-off,\n\t    // line numbers are lost also for globals.\n\t    while (tcount-- > 0)\n\t    {\n\t\tif (getenv(\"Y2ALLGLOBAL\") != NULL)\n\t\t{\n\t\t    TableEntry t(str);\t\t\t\t// FIXME: this object is temporary and unused\n\t\t}\n\t\telse\n\t\t{\n\t\t    TableEntry *tentry = new TableEntry (str);\n\t\t    attachEntry (tentry);\n\t\t    m_table->enter (tentry);\n\t\t}\n\t    }\n\n\t    if (getenv(\"Y2ALLGLOBAL\") != NULL)\n\t    {\n\t\tdelete m_table; // FIXME: memory leak\n\t\tm_table = new SymbolTable(-1);\n\t\tm_table->openXRefs ();\n\t\tfor (unsigned int i = 0 ; i < scount ; i++)\n\t\t{\n\t\t    SymbolEntryPtr sentry = symbolEntry (i);\n\t\t    if (!sentry->isModule()\t\t\t\t// don't re-export imported modules\n\t\t\t&& !sentry->isNamespace())\t\t\t//   or predefined namespaces\n\t\t    {\n\t\t\tTableEntry* tentry = m_table->enter(sentry->name (), sentry, 0);\n\t\t\tattachEntry (tentry);\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    m_point = new Point (str);\n\n    u_int32_t count = Bytecode::readInt32 (str);\n#if DO_DEBUG\n    y2debug (\"YBlock::fromStream (%p:\\\"%s\\\", %d statements)\", this, m_name.c_str(), count);\n#endif\n\n    stmtlist_t *stmt;\n    for (u_int32_t i = 0; i < count; i++)\n    {\n\tstmt = new stmtlist_t;\n\n\tYCodePtr code = Bytecode::readCode (str);\n\tif (code == 0)\n\t{\n\t    throw Bytecode::Invalid();\n\t}\n\tif (!code->isStatement())\t\t\t// code must be statement\n\t{\n\t    y2error (\"Code is no statement: %d\", code->kind());\n\t    throw Bytecode::Invalid();\n\t}\n\n\tstmt->stmt = (YStatementPtr)code;\n\tstmt->next = 0;\n\tif (stmt->stmt == 0)\n\t{\n\t    break;\n\t}\n\tif (m_statements == 0)\n\t{\n\t    m_statements = stmt;\n\t}\n\telse\n\t{\n\t    m_last_statement->next = stmt;\n\t}\n\tm_last_statement = stmt;\n    }\n\n    Bytecode::popUptoNamespace (this);\n    \n    // for modules ensure symbol table\n    if (isModule ())\n    {\n\tcreateTable ();\n    }\n#if DO_DEBUG\n    y2debug (\"done\");\n#endif\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"done\""
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "createTable",
          "args": [],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "createTable",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "286-293",
          "snippet": "void\nY2Namespace::createTable ()\n{\n    if (m_table == 0)\n    {\n\tm_table = new SymbolTable (-1);\n    }\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  void\n  Y2Namespace::createTable ()\n  {\n      if (m_table == 0)\n      {\n  \tm_table = new SymbolTable (-1);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isModule",
          "args": [],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "isModule",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YBlock.h",
          "lines": "205-205",
          "snippet": "bool isModule () const\t{ return (m_kind == b_module); }",
          "includes": [
            "#include \"ycp/YStatement.h\"",
            "#include <y2/Y2Namespace.h>",
            "#include <y2util/Ustring.h>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YStatement.h\"\n#include <y2/Y2Namespace.h>\n#include <y2util/Ustring.h>\n#include <list>\n#include <string>\n\nYBlock {\n  bool isModule () const\t{ return (m_kind == b_module); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::popUptoNamespace",
          "args": [
            "this"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "popUptoNamespace",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "683-710",
          "snippet": "void\nBytecode::popUptoNamespace (const Y2Namespace *name_space)\n{\n#if DO_DEBUG\n    y2debug (\"Bytecode::popUptoNamespace (%p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n#endif\n    if (name_space == 0)\n    {\n\ty2error (\"Bytecode::popUptoNamespace (%p) NULL\", name_space);\n\treturn;\n    }\n\n    while (m_namespace_nesting_level >= m_namespace_tare_level)\n    {\n\tconst Y2Namespace *top_space = m_namespace_nesting_array[m_namespace_nesting_level].name_space;\n\tif (m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs)\n\t{\n\t    top_space->table()->closeXRefs();\n\t}\n\tm_namespace_nesting_level--;\n\tif (top_space == name_space)\n\t{\n\t    return;\n\t}\n    }\n    y2error (\"Bytecode::popUptoNamespace (%p) empty stack\", name_space);\n    return;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "int Bytecode::m_namespace_nesting_level = -1;",
            "int Bytecode::m_namespace_nesting_array_size = 0;",
            "int Bytecode::m_namespace_tare_level = 0;",
            "Bytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nint Bytecode::m_namespace_nesting_level = -1;\nint Bytecode::m_namespace_nesting_array_size = 0;\nint Bytecode::m_namespace_tare_level = 0;\nBytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;\n\nBytecode {\n  void\n  Bytecode::popUptoNamespace (const Y2Namespace *name_space)\n  {\n  #if DO_DEBUG\n      y2debug (\"Bytecode::popUptoNamespace (%p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n  #endif\n      if (name_space == 0)\n      {\n  \ty2error (\"Bytecode::popUptoNamespace (%p) NULL\", name_space);\n  \treturn;\n      }\n  \n      while (m_namespace_nesting_level >= m_namespace_tare_level)\n      {\n  \tconst Y2Namespace *top_space = m_namespace_nesting_array[m_namespace_nesting_level].name_space;\n  \tif (m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs)\n  \t{\n  \t    top_space->table()->closeXRefs();\n  \t}\n  \tm_namespace_nesting_level--;\n  \tif (top_space == name_space)\n  \t{\n  \t    return;\n  \t}\n      }\n      y2error (\"Bytecode::popUptoNamespace (%p) empty stack\", name_space);\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::Invalid",
          "args": [],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Code is no statement: %d\"",
            "code->kind()"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "code->kind",
          "args": [],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YBlock.h",
          "lines": "149-149",
          "snippet": "virtual ykind kind () const { return yeBlock; }",
          "includes": [
            "#include \"ycp/YStatement.h\"",
            "#include <y2/Y2Namespace.h>",
            "#include <y2util/Ustring.h>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YStatement.h\"\n#include <y2/Y2Namespace.h>\n#include <y2util/Ustring.h>\n#include <list>\n#include <string>\n\nYBlock {\n  virtual ykind kind () const { return yeBlock; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "code->isStatement",
          "args": [],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "isStatement",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YBlock.h",
          "lines": "207-207",
          "snippet": "bool isStatement () const\t{ return (m_kind == b_statement); }",
          "includes": [
            "#include \"ycp/YStatement.h\"",
            "#include <y2/Y2Namespace.h>",
            "#include <y2util/Ustring.h>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YStatement.h\"\n#include <y2/Y2Namespace.h>\n#include <y2util/Ustring.h>\n#include <list>\n#include <string>\n\nYBlock {\n  bool isStatement () const\t{ return (m_kind == b_statement); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::Invalid",
          "args": [],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock::fromStream (%p:\\\"%s\\\", %d statements)\"",
            "this",
            "m_name.c_str()",
            "count"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name.c_str",
          "args": [],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readInt32",
          "args": [
            "str"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "attachEntry",
          "args": [
            "tentry"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "attachEntry",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "205-231",
          "snippet": "void\nYBlock::attachEntry (TableEntry *tentry)\n{\n#if DO_DEBUG\n    y2debug (\"YBlock[%p]::attachEntry (%p)\", this, tentry/*->toString().c_str()*/);\n#endif\n\n    yTElist_t *newt = new (yTElist_t);\n    newt->tentry = tentry;\n    newt->next = 0;\n\n    if (m_tenvironment == 0)\n    {\n\tm_tenvironment = newt;\n\tm_last_tparm = m_tenvironment;\n    }\n    else if (m_last_tparm == 0)\n    {\n\ty2error (\"YBlock::attachEntry after detach_environemt !\");\n    }\n    else\n    {\n\tm_last_tparm->next = newt;\n\tm_last_tparm = newt;\n    }\n    return;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  void\n  YBlock::attachEntry (TableEntry *tentry)\n  {\n  #if DO_DEBUG\n      y2debug (\"YBlock[%p]::attachEntry (%p)\", this, tentry/*->toString().c_str()*/);\n  #endif\n  \n      yTElist_t *newt = new (yTElist_t);\n      newt->tentry = tentry;\n      newt->next = 0;\n  \n      if (m_tenvironment == 0)\n      {\n  \tm_tenvironment = newt;\n  \tm_last_tparm = m_tenvironment;\n      }\n      else if (m_last_tparm == 0)\n      {\n  \ty2error (\"YBlock::attachEntry after detach_environemt !\");\n      }\n      else\n      {\n  \tm_last_tparm->next = newt;\n  \tm_last_tparm = newt;\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_table->enter",
          "args": [
            "sentry->name ()",
            "sentry",
            "0"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sentry->name",
          "args": [],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "382-386",
          "snippet": "const string \nYBlock::name () const\n{\n    return m_name;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  const string \n  YBlock::name () const\n  {\n      return m_name;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sentry->isNamespace",
          "args": [],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "isNamespace",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YBlock.h",
          "lines": "210-210",
          "snippet": "bool isNamespace () const\t{ return (m_kind == b_namespace); }",
          "includes": [
            "#include \"ycp/YStatement.h\"",
            "#include <y2/Y2Namespace.h>",
            "#include <y2util/Ustring.h>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YStatement.h\"\n#include <y2/Y2Namespace.h>\n#include <y2util/Ustring.h>\n#include <list>\n#include <string>\n\nYBlock {\n  bool isNamespace () const\t{ return (m_kind == b_namespace); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "symbolEntry",
          "args": [
            "i"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "symbolEntry",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "118-126",
          "snippet": "SymbolEntryPtr \nY2Namespace::symbolEntry (unsigned int position) const\n{\n    if (position >= m_symbolcount)\n    {\n\treturn 0;\n    }\n    return m_symbols[position];\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  SymbolEntryPtr \n  Y2Namespace::symbolEntry (unsigned int position) const\n  {\n      if (position >= m_symbolcount)\n      {\n  \treturn 0;\n      }\n      return m_symbols[position];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_table->openXRefs",
          "args": [],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "openXRefs",
          "container": "SymbolTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "333-347",
          "snippet": "void\nSymbolTable::openXRefs ()\n{\n#if DO_DEBUG\n    y2debug (\"SymbolTable[%p]::openXRefs()\", this);\n#endif\n    if (! m_xrefs)\n    {\n\tm_xrefs = new xrefs_t;\n    }\n\n    m_xrefs->push (new (std::vector<TableEntry *>));\n\n    return;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\n#define DO_DEBUG 0\n\nSymbolTable {\n  void\n  SymbolTable::openXRefs ()\n  {\n  #if DO_DEBUG\n      y2debug (\"SymbolTable[%p]::openXRefs()\", this);\n  #endif\n      if (! m_xrefs)\n      {\n  \tm_xrefs = new xrefs_t;\n      }\n  \n      m_xrefs->push (new (std::vector<TableEntry *>));\n  \n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"Y2ALLGLOBAL\""
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_table->enter",
          "args": [
            "tentry"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"Y2ALLGLOBAL\""
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Module with %d table entries\"",
            "tcount"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addSymbol",
          "args": [
            "sentry"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "addSymbol",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "133-141",
          "snippet": "unsigned int\nY2Namespace::addSymbol (SymbolEntryPtr sentry)\n{\n#if DO_DEBUG\n    y2debug (\"addSymbol #%d:'%s'\", m_symbolcount, sentry->toString().c_str());\n#endif\n    m_symbols.push_back(sentry);\n    return m_symbolcount++;\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\n#define DO_DEBUG 0\n\nY2Namespace {\n  unsigned int\n  Y2Namespace::addSymbol (SymbolEntryPtr sentry)\n  {\n  #if DO_DEBUG\n      y2debug (\"addSymbol #%d:'%s'\", m_symbolcount, sentry->toString().c_str());\n  #endif\n      m_symbols.push_back(sentry);\n      return m_symbolcount++;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nameSpace",
          "args": [],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock::fromStream (%p:\\\"%s\\\", %d entries, kind %d)\"",
            "this",
            "m_name.c_str()",
            "scount",
            "m_kind"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name.c_str",
          "args": [],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::pushNamespace",
          "args": [
            "nameSpace()"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nameSpace",
          "args": [],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readString",
          "args": [
            "str",
            "m_name"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "readString",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "229-247",
          "snippet": "bool\nBytecode::readString (bytecodeistream & streamref, string & stringref)\n{\n    bool ret = false;\n    stringref.erase();\n    u_int32_t len = readInt32 (streamref);\n    if (len > 0)\n    {\n\tchar *buf = new char [len+1];\n\tif (streamref.read (buf, len))\n\t{\n\t    buf[len] = 0;\n\t    stringref = string (buf);\n\t    ret = true;\n\t}\n\tdelete [] buf;\n    }\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  bool\n  Bytecode::readString (bytecodeistream & streamref, string & stringref)\n  {\n      bool ret = false;\n      stringref.erase();\n      u_int32_t len = readInt32 (streamref);\n      if (len > 0)\n      {\n  \tchar *buf = new char [len+1];\n  \tif (streamref.read (buf, len))\n  \t{\n  \t    buf[len] = 0;\n  \t    stringref = string (buf);\n  \t    ret = true;\n  \t}\n  \tdelete [] buf;\n      }\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  YBlock::YBlock (bytecodeistream & str)\n      : YCode ()\n      , m_kind (b_unknown)\n      , m_name (\"\")\n      , m_tenvironment (0)\n      , m_last_tparm (0)\n      , m_point (0)\n      , m_statements (0)\n      , m_last_statement (0)\n      , m_includes (0)\n      , m_running (false)\n  {\n      Bytecode::readString (str, m_name);\t\t// read name\n  \n      m_kind = (blockkind_t)Bytecode::readInt32 (str);\n  \n      Bytecode::pushNamespace (nameSpace());\n  \n      unsigned int scount = Bytecode::readInt32 (str);\t// read Y2Namespace::m_symbols\n  \n  #if DO_DEBUG\n      y2debug(\"YBlock::fromStream (%p:\\\"%s\\\", %d entries, kind %d)\", this, m_name.c_str(), scount, m_kind);\n  #endif\n  \n      // read all symbol entries belonging to this block\n  \n      if (scount > 0)\n      {\n  \tfor (unsigned int i = 0; i < scount; i++)\n  \t{\n  \t    SymbolEntryPtr sentry = new YSymbolEntry (str, nameSpace());\n  \t    addSymbol (sentry);\n  \t}\n  \n  \tif (m_kind == b_module)\t\t\t// if its a module, re-construct the table\n  \t{\n  \t    int tcount = Bytecode::readInt32 (str);\n  #if DO_DEBUG\n  \t    y2debug (\"Module with %d table entries\", tcount);\n  #endif\n  \n  \t    if (tcount > 0\n  \t\t&& m_table == 0)\n  \t    {\n  \t\tm_table = new SymbolTable (-1);\n  \t    }\n  \n  \t    // HACK ahead: Y2ALLGLOBAL should make all\n  \t    // symbols visible. It works now, but as a trade-off,\n  \t    // line numbers are lost also for globals.\n  \t    while (tcount-- > 0)\n  \t    {\n  \t\tif (getenv(\"Y2ALLGLOBAL\") != NULL)\n  \t\t{\n  \t\t    TableEntry t(str);\t\t\t\t// FIXME: this object is temporary and unused\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t    TableEntry *tentry = new TableEntry (str);\n  \t\t    attachEntry (tentry);\n  \t\t    m_table->enter (tentry);\n  \t\t}\n  \t    }\n  \n  \t    if (getenv(\"Y2ALLGLOBAL\") != NULL)\n  \t    {\n  \t\tdelete m_table; // FIXME: memory leak\n  \t\tm_table = new SymbolTable(-1);\n  \t\tm_table->openXRefs ();\n  \t\tfor (unsigned int i = 0 ; i < scount ; i++)\n  \t\t{\n  \t\t    SymbolEntryPtr sentry = symbolEntry (i);\n  \t\t    if (!sentry->isModule()\t\t\t\t// don't re-export imported modules\n  \t\t\t&& !sentry->isNamespace())\t\t\t//   or predefined namespaces\n  \t\t    {\n  \t\t\tTableEntry* tentry = m_table->enter(sentry->name (), sentry, 0);\n  \t\t\tattachEntry (tentry);\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n  \n      m_point = new Point (str);\n  \n      u_int32_t count = Bytecode::readInt32 (str);\n  #if DO_DEBUG\n      y2debug (\"YBlock::fromStream (%p:\\\"%s\\\", %d statements)\", this, m_name.c_str(), count);\n  #endif\n  \n      stmtlist_t *stmt;\n      for (u_int32_t i = 0; i < count; i++)\n      {\n  \tstmt = new stmtlist_t;\n  \n  \tYCodePtr code = Bytecode::readCode (str);\n  \tif (code == 0)\n  \t{\n  \t    throw Bytecode::Invalid();\n  \t}\n  \tif (!code->isStatement())\t\t\t// code must be statement\n  \t{\n  \t    y2error (\"Code is no statement: %d\", code->kind());\n  \t    throw Bytecode::Invalid();\n  \t}\n  \n  \tstmt->stmt = (YStatementPtr)code;\n  \tstmt->next = 0;\n  \tif (stmt->stmt == 0)\n  \t{\n  \t    break;\n  \t}\n  \tif (m_statements == 0)\n  \t{\n  \t    m_statements = stmt;\n  \t}\n  \telse\n  \t{\n  \t    m_last_statement->next = stmt;\n  \t}\n  \tm_last_statement = stmt;\n      }\n  \n      Bytecode::popUptoNamespace (this);\n      \n      // for modules ensure symbol table\n      if (isModule ())\n      {\n  \tcreateTable ();\n      }\n  #if DO_DEBUG\n      y2debug (\"done\");\n  #endif\n  }\n}"
  },
  {
    "function_name": "statementCount",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "824-837",
    "snippet": "int\nYBlock::statementCount () const\n{\n    int res = 0;\n    stmtlist_t *stmt = m_statements;\n\n    while (stmt)\n    {\n\tstmt = stmt->next;\n\tres++;\n    }\n    \n    return res;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  int\n  YBlock::statementCount () const\n  {\n      int res = 0;\n      stmtlist_t *stmt = m_statements;\n  \n      while (stmt)\n      {\n  \tstmt = stmt->next;\n  \tres++;\n      }\n      \n      return res;\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "783-821",
    "snippet": "YCPValue\nYBlock::evaluate (int statement_index, bool skip_initial_imports)\n{\n#if DO_DEBUG\n    y2debug(\"YBlock::evaluate(#%d)\\n\", statement_index);\n#endif\n    \n    stmtlist_t *stmt = m_statements;\n    YCPValue value = YCPVoid ();\n\n    while (skip_initial_imports\n\t   && stmt\n\t   && stmt->stmt->kind() == YCode::ysImport)\n    {\n\tstmt =stmt->next;\n    }\n    \n    while (stmt && statement_index > 0)\n    {\n\tstmt = stmt->next;\n\tstatement_index--;\n    }\n\n    if (!stmt)\n    {\n\t// we are at the end\n\treturn YCPNull ();\n    }\n    \n    y2milestone(\"YBlock::evaluating:\\n%s\", stmt->stmt->toString ().c_str());\n\n    value = stmt->stmt->evaluate ();\n    \n#if DO_DEBUG\n    y2debug(\"YBlock::evaluate statement done (value '%s')\\n\", value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n\n    return value;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock::evaluate statement done (value '%s')\\n\"",
            "value.isNull() ? \"NULL\" : value->toString().c_str()"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "445-477",
          "snippet": "string\nYBlock::toString () const\n{\n    string s;\n    if (m_kind == b_using)\n    {\n\ts = (m_name + \"::\");\n    }\n    s += \"{\";\n\n    if (isModule())\n    {\n\ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n    }\n\n    s += environmentToString ();\n    if (isModule()\n\t|| isFile())\n    {\n\ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n    }\n\n    stmtlist_t *stmt = m_statements;\n    while (stmt)\n    {\n\ts += \"\\n    \";\n\ts += stmt->stmt->toString();\n\tstmt = stmt->next;\n    }\n\n    s += \"\\n}\\n\";\n    return s;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::toString () const\n  {\n      string s;\n      if (m_kind == b_using)\n      {\n  \ts = (m_name + \"::\");\n      }\n      s += \"{\";\n  \n      if (isModule())\n      {\n  \ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n      }\n  \n      s += environmentToString ();\n      if (isModule()\n  \t|| isFile())\n      {\n  \ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n      }\n  \n      stmtlist_t *stmt = m_statements;\n      while (stmt)\n      {\n  \ts += \"\\n    \";\n  \ts += stmt->stmt->toString();\n  \tstmt = stmt->next;\n      }\n  \n      s += \"\\n}\\n\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stmt->stmt->evaluate",
          "args": [],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2milestone",
          "args": [
            "\"YBlock::evaluating:\\n%s\"",
            "stmt->stmt->toString ().c_str()"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stmt->stmt->kind",
          "args": [],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YBlock.h",
          "lines": "149-149",
          "snippet": "virtual ykind kind () const { return yeBlock; }",
          "includes": [
            "#include \"ycp/YStatement.h\"",
            "#include <y2/Y2Namespace.h>",
            "#include <y2util/Ustring.h>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YStatement.h\"\n#include <y2/Y2Namespace.h>\n#include <y2util/Ustring.h>\n#include <list>\n#include <string>\n\nYBlock {\n  virtual ykind kind () const { return yeBlock; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock::evaluate(#%d)\\n\"",
            "statement_index"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  YCPValue\n  YBlock::evaluate (int statement_index, bool skip_initial_imports)\n  {\n  #if DO_DEBUG\n      y2debug(\"YBlock::evaluate(#%d)\\n\", statement_index);\n  #endif\n      \n      stmtlist_t *stmt = m_statements;\n      YCPValue value = YCPVoid ();\n  \n      while (skip_initial_imports\n  \t   && stmt\n  \t   && stmt->stmt->kind() == YCode::ysImport)\n      {\n  \tstmt =stmt->next;\n      }\n      \n      while (stmt && statement_index > 0)\n      {\n  \tstmt = stmt->next;\n  \tstatement_index--;\n      }\n  \n      if (!stmt)\n      {\n  \t// we are at the end\n  \treturn YCPNull ();\n      }\n      \n      y2milestone(\"YBlock::evaluating:\\n%s\", stmt->stmt->toString ().c_str());\n  \n      value = stmt->stmt->evaluate ();\n      \n  #if DO_DEBUG\n      y2debug(\"YBlock::evaluate statement done (value '%s')\\n\", value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n  \n      return value;\n  }\n}"
  },
  {
    "function_name": "evaluateFrom",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "695-780",
    "snippet": "YCPValue\nYBlock::evaluateFrom (int statement_index)\n{\n#if DO_DEBUG\n    y2debug (\"YBlock::evaluate from statement([%d]%s)\\n\", (int)m_kind, toString().c_str());\n#endif\n\n    // recursion handling - not used for modules\n    if (m_running)\n    {\n\tpushToStack ();\n    }\n    \n    bool old_m_running = m_running;\n    m_running = true;\n\n    string restore_name;\n    if (!filename().empty())\n    {\n\trestore_name = ee.filename ();\n\tee.setFilename (filename());\n    }\n\n    stmtlist_t *stmt = m_statements;\n    YCPValue value = YCPVoid ();\n    \n    // skip statements until index\n    while (stmt && statement_index > 0)\n    {\n\tstmt = stmt->next;\n\tstatement_index--;\n    }\n    \n    // execute the rest of statements\n    while (stmt)\n    {\n\tYStatementPtr statement = stmt->stmt;\n\t\n#if DO_DEBUG\n\ty2debug (\"%d: %s\", statement->line (), statement->toString ().c_str ());\n#endif\n\n\tee.setStatement (statement);\n\tvalue = statement->evaluate ();\n\n\tif (!value.isNull())\n\t{\n#if DO_DEBUG\n\t    y2debug (\"Block exit (%s)\", value->toString().c_str());\n#endif\n\t    break;\n\t}\n\n\tstmt = stmt->next;\n    }\n    if (!restore_name.empty())\n    {\n\tee.setFilename (restore_name);\n    }\n    \n    m_running = old_m_running;\n    \n    // recursion handling - not used for modules\n    if (! isModule () && m_running)\n    {\n\tpopFromStack ();\n    }\n\n#if DO_DEBUG\n    y2debug (\"YBlock::evaluate done (stmt %p, kind %d, value '%s')\\n\", stmt, m_kind, value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n\n    // if stmt==0 we're at the end of the block. If the block is evaluated as a statement,\n    //   it returns NULL, else it returns Void\n    if (stmt == 0)\n    {\n\tif (m_kind == b_statement)\n\t{\n\t    return YCPNull();\n\t}\n\treturn YCPVoid();\n    }\n\n    // if stmt!=0 we just evaluated a break or return statement. A 'return;' evaluates to YCPReturn\n    return value;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "extern ExecutionEnvironment ee;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock::evaluate done (stmt %p, kind %d, value '%s')\\n\"",
            "stmt",
            "m_kind",
            "value.isNull() ? \"NULL\" : value->toString().c_str()"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "445-477",
          "snippet": "string\nYBlock::toString () const\n{\n    string s;\n    if (m_kind == b_using)\n    {\n\ts = (m_name + \"::\");\n    }\n    s += \"{\";\n\n    if (isModule())\n    {\n\ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n    }\n\n    s += environmentToString ();\n    if (isModule()\n\t|| isFile())\n    {\n\ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n    }\n\n    stmtlist_t *stmt = m_statements;\n    while (stmt)\n    {\n\ts += \"\\n    \";\n\ts += stmt->stmt->toString();\n\tstmt = stmt->next;\n    }\n\n    s += \"\\n}\\n\";\n    return s;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::toString () const\n  {\n      string s;\n      if (m_kind == b_using)\n      {\n  \ts = (m_name + \"::\");\n      }\n      s += \"{\";\n  \n      if (isModule())\n      {\n  \ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n      }\n  \n      s += environmentToString ();\n      if (isModule()\n  \t|| isFile())\n      {\n  \ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n      }\n  \n      stmtlist_t *stmt = m_statements;\n      while (stmt)\n      {\n  \ts += \"\\n    \";\n  \ts += stmt->stmt->toString();\n  \tstmt = stmt->next;\n      }\n  \n      s += \"\\n}\\n\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popFromStack",
          "args": [],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "popFromStack",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "267-277",
          "snippet": "void\nY2Namespace::popFromStack ()\n{\n    for (unsigned int p = 0; p < m_symbolcount; p++)\n    {\n\tif ( m_symbols[p] && m_symbols[p]->isVariable() )\n        {\n            m_symbols[p]->pop ();\n        }\n    }\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  void\n  Y2Namespace::popFromStack ()\n  {\n      for (unsigned int p = 0; p < m_symbolcount; p++)\n      {\n  \tif ( m_symbols[p] && m_symbols[p]->isVariable() )\n          {\n              m_symbols[p]->pop ();\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isModule",
          "args": [],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "isModule",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YBlock.h",
          "lines": "205-205",
          "snippet": "bool isModule () const\t{ return (m_kind == b_module); }",
          "includes": [
            "#include \"ycp/YStatement.h\"",
            "#include <y2/Y2Namespace.h>",
            "#include <y2util/Ustring.h>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YStatement.h\"\n#include <y2/Y2Namespace.h>\n#include <y2util/Ustring.h>\n#include <list>\n#include <string>\n\nYBlock {\n  bool isModule () const\t{ return (m_kind == b_module); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.setFilename",
          "args": [
            "restore_name"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "setFilename",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "87-96",
          "snippet": "void\nYCPDebugger::setFilename (const char *filename)\n{\n    y2debug (\"setFilename (%s)\\n\", filename);\n    if (filename)\n    {\n\tm_filename = filename;\n    }\n    return;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::setFilename (const char *filename)\n  {\n      y2debug (\"setFilename (%s)\\n\", filename);\n      if (filename)\n      {\n  \tm_filename = filename;\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_name.empty",
          "args": [],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Block exit (%s)\"",
            "value->toString().c_str()"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement->evaluate",
          "args": [],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee.setStatement",
          "args": [
            "statement"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "setStatement",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "78-89",
          "snippet": "void\nExecutionEnvironment::setStatement (YStatementPtr s)\n{\n    m_statement = s;\n    \n    if (s != NULL)\n    {\n\tm_linenumber = s->line ();\n    }\n    \n    return;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  void\n  ExecutionEnvironment::setStatement (YStatementPtr s)\n  {\n      m_statement = s;\n      \n      if (s != NULL)\n      {\n  \tm_linenumber = s->line ();\n      }\n      \n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"%d: %s\"",
            "statement->line ()",
            "statement->toString ().c_str ()"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement->line",
          "args": [],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "line",
          "container": "YStatement",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YStatement.h",
          "lines": "78-78",
          "snippet": "int line () const { return m_line; }",
          "includes": [
            "#include \"ycp/ycpless.h\"",
            "#include \"ycp/Import.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ycpless.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YCode.h\"\n#include <string>\n\nYStatement {\n  int line () const { return m_line; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "filename",
          "args": [],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "filename",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "131-135",
          "snippet": "const std::string \nYBlock::filename () const\n{\n    return m_point->filename();\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  const std::string \n  YBlock::filename () const\n  {\n      return m_point->filename();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushToStack",
          "args": [],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "pushToStack",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "254-264",
          "snippet": "void\nY2Namespace::pushToStack ()\n{\n    for (unsigned int p = 0; p < m_symbolcount; p++)\n    {\n\tif ( m_symbols[p] && m_symbols[p]->isVariable() )\n        {\n            m_symbols[p]->push ();\n        }\n    }\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  void\n  Y2Namespace::pushToStack ()\n  {\n      for (unsigned int p = 0; p < m_symbolcount; p++)\n      {\n  \tif ( m_symbols[p] && m_symbols[p]->isVariable() )\n          {\n              m_symbols[p]->push ();\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock::evaluate from statement([%d]%s)\\n\"",
            "(int)m_kind",
            "toString().c_str()"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nextern ExecutionEnvironment ee;\n\nYBlock {\n  YCPValue\n  YBlock::evaluateFrom (int statement_index)\n  {\n  #if DO_DEBUG\n      y2debug (\"YBlock::evaluate from statement([%d]%s)\\n\", (int)m_kind, toString().c_str());\n  #endif\n  \n      // recursion handling - not used for modules\n      if (m_running)\n      {\n  \tpushToStack ();\n      }\n      \n      bool old_m_running = m_running;\n      m_running = true;\n  \n      string restore_name;\n      if (!filename().empty())\n      {\n  \trestore_name = ee.filename ();\n  \tee.setFilename (filename());\n      }\n  \n      stmtlist_t *stmt = m_statements;\n      YCPValue value = YCPVoid ();\n      \n      // skip statements until index\n      while (stmt && statement_index > 0)\n      {\n  \tstmt = stmt->next;\n  \tstatement_index--;\n      }\n      \n      // execute the rest of statements\n      while (stmt)\n      {\n  \tYStatementPtr statement = stmt->stmt;\n  \t\n  #if DO_DEBUG\n  \ty2debug (\"%d: %s\", statement->line (), statement->toString ().c_str ());\n  #endif\n  \n  \tee.setStatement (statement);\n  \tvalue = statement->evaluate ();\n  \n  \tif (!value.isNull())\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"Block exit (%s)\", value->toString().c_str());\n  #endif\n  \t    break;\n  \t}\n  \n  \tstmt = stmt->next;\n      }\n      if (!restore_name.empty())\n      {\n  \tee.setFilename (restore_name);\n      }\n      \n      m_running = old_m_running;\n      \n      // recursion handling - not used for modules\n      if (! isModule () && m_running)\n      {\n  \tpopFromStack ();\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"YBlock::evaluate done (stmt %p, kind %d, value '%s')\\n\", stmt, m_kind, value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n  \n      // if stmt==0 we're at the end of the block. If the block is evaluated as a statement,\n      //   it returns NULL, else it returns Void\n      if (stmt == 0)\n      {\n  \tif (m_kind == b_statement)\n  \t{\n  \t    return YCPNull();\n  \t}\n  \treturn YCPVoid();\n      }\n  \n      // if stmt!=0 we just evaluated a break or return statement. A 'return;' evaluates to YCPReturn\n      return value;\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "569-692",
    "snippet": "YCPValue\nYBlock::evaluate (bool cse)\n{\n    if (cse)\n    {\n\treturn YCPNull();\n    }\n\n#if DO_DEBUG\n    y2debug (\"YBlock::evaluate([%d]%s)\\n\", (int)m_kind, toString().c_str());\n#endif\n\n    bool m_debug = false;\n\n    if (debugger_instance)\n    {\n\tm_debug = debugger_instance->tracing();\n\t\n\tdebugger_instance->pushBlock (this, m_debug);\n    }\n\n    // recursion handling - not used for modules\n    if (! isModule () && m_running)\n    {\n\tpushToStack ();\n    }\n    \n    bool old_m_running = m_running;\n    m_running = true;\n\n    string restore_name;\n    if (!filename().empty())\n    {\n\trestore_name = ee.filename ();\n\tee.setFilename (filename());\n    }\n\n    stmtlist_t *stmt = m_statements;\n    YCPValue value = YCPVoid ();\n    while (stmt)\n    {\n\tbool next_hit = false;\n\tYStatementPtr statement = stmt->stmt;\n\t\n#if DO_DEBUG\n\ty2debug (\"%d: %s\", statement->line (), statement->toString ().c_str ());\n#endif\n\tee.setStatement (statement);\n\n\tif (m_debug && statement->kind() != ysFunction )\n\t{\n\t    Debugger::command_t command;\n\t    std::list<std::string> args;\n\t    if (debugger_instance->processInput (command, args) && command==Debugger::c_continue)\n\t    {\n\t\tm_debug = false;\n\t\tdebugger_instance->setTracing (false);\n\t    }\n\t    else if (command == Debugger::c_next)\n\t    {\n\t\tnext_hit = true;\n\t\tdebugger_instance->setTracing (false);\n\t    }\n\t}\n\t\n\n\tvalue = statement->evaluate ();\n\t\n\t// If we get continue from inner evaluation, we have to respect it\n        if (debugger_instance)\n        {\n    \t    if (m_debug)\n    \t    {\n\t\tm_debug = debugger_instance->lastCommand() != Debugger::c_continue;\n\t\tdebugger_instance->setTracing (m_debug);\n\t    }\n\t    else\n\t\tm_debug = debugger_instance->tracing ();\n\t}\n\n\tif (!value.isNull())\n\t{\n#if DO_DEBUG\n\t    y2debug (\"Block exit (%s)\", value->toString().c_str());\n#endif\n\t    break;\n\t}\n\n\tstmt = stmt->next;\n    }\n    if (!restore_name.empty())\n    {\n\tee.setFilename (restore_name);\n    }\n    \n    m_running = old_m_running;\n    \n    // recursion handling - not used for modules\n    if (! isModule () && m_running)\n    {\n\tpopFromStack ();\n    }\n    \n    if (debugger_instance)\n\tdebugger_instance->popBlock ();\n\n#if DO_DEBUG\n    y2debug (\"YBlock::evaluate done (stmt %p, kind %d, value '%s')\\n\", stmt, m_kind, value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n\n    // if stmt==0 we're at the end of the block. If the block is evaluated as a statement,\n    //   it returns NULL, else it returns Void\n    if (stmt == 0)\n    {\n\tif (m_kind == b_statement)\n\t{\n\t    return YCPNull();\n\t}\n\treturn YCPVoid();\n    }\n\n    // if stmt!=0 we just evaluated a break or return statement. A 'return;' evaluates to YCPReturn\n    return value;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "extern ExecutionEnvironment ee;",
      "extern Debugger* debugger_instance;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock::evaluate done (stmt %p, kind %d, value '%s')\\n\"",
            "stmt",
            "m_kind",
            "value.isNull() ? \"NULL\" : value->toString().c_str()"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "445-477",
          "snippet": "string\nYBlock::toString () const\n{\n    string s;\n    if (m_kind == b_using)\n    {\n\ts = (m_name + \"::\");\n    }\n    s += \"{\";\n\n    if (isModule())\n    {\n\ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n    }\n\n    s += environmentToString ();\n    if (isModule()\n\t|| isFile())\n    {\n\ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n    }\n\n    stmtlist_t *stmt = m_statements;\n    while (stmt)\n    {\n\ts += \"\\n    \";\n\ts += stmt->stmt->toString();\n\tstmt = stmt->next;\n    }\n\n    s += \"\\n}\\n\";\n    return s;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::toString () const\n  {\n      string s;\n      if (m_kind == b_using)\n      {\n  \ts = (m_name + \"::\");\n      }\n      s += \"{\";\n  \n      if (isModule())\n      {\n  \ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n      }\n  \n      s += environmentToString ();\n      if (isModule()\n  \t|| isFile())\n      {\n  \ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n      }\n  \n      stmtlist_t *stmt = m_statements;\n      while (stmt)\n      {\n  \ts += \"\\n    \";\n  \ts += stmt->stmt->toString();\n  \tstmt = stmt->next;\n      }\n  \n      s += \"\\n}\\n\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugger_instance->popBlock",
          "args": [],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "popBlock",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "555-558",
          "snippet": "void Debugger::popBlock ()\n{\n    m_blockstack.pop_front ();\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::popBlock ()\n  {\n      m_blockstack.pop_front ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "popFromStack",
          "args": [],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "popFromStack",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "267-277",
          "snippet": "void\nY2Namespace::popFromStack ()\n{\n    for (unsigned int p = 0; p < m_symbolcount; p++)\n    {\n\tif ( m_symbols[p] && m_symbols[p]->isVariable() )\n        {\n            m_symbols[p]->pop ();\n        }\n    }\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  void\n  Y2Namespace::popFromStack ()\n  {\n      for (unsigned int p = 0; p < m_symbolcount; p++)\n      {\n  \tif ( m_symbols[p] && m_symbols[p]->isVariable() )\n          {\n              m_symbols[p]->pop ();\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isModule",
          "args": [],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "isModule",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YBlock.h",
          "lines": "205-205",
          "snippet": "bool isModule () const\t{ return (m_kind == b_module); }",
          "includes": [
            "#include \"ycp/YStatement.h\"",
            "#include <y2/Y2Namespace.h>",
            "#include <y2util/Ustring.h>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YStatement.h\"\n#include <y2/Y2Namespace.h>\n#include <y2util/Ustring.h>\n#include <list>\n#include <string>\n\nYBlock {\n  bool isModule () const\t{ return (m_kind == b_module); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.setFilename",
          "args": [
            "restore_name"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "setFilename",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "87-96",
          "snippet": "void\nYCPDebugger::setFilename (const char *filename)\n{\n    y2debug (\"setFilename (%s)\\n\", filename);\n    if (filename)\n    {\n\tm_filename = filename;\n    }\n    return;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::setFilename (const char *filename)\n  {\n      y2debug (\"setFilename (%s)\\n\", filename);\n      if (filename)\n      {\n  \tm_filename = filename;\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_name.empty",
          "args": [],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Block exit (%s)\"",
            "value->toString().c_str()"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugger_instance->tracing",
          "args": [],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "tracing",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "560-563",
          "snippet": "bool Debugger::tracing () const\n{\n    return m_tracing;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  bool Debugger::tracing () const\n  {\n      return m_tracing;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugger_instance->setTracing",
          "args": [
            "m_debug"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "setTracing",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "565-568",
          "snippet": "void Debugger::setTracing (bool enable)\n{\n    m_tracing = enable;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::setTracing (bool enable)\n  {\n      m_tracing = enable;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugger_instance->lastCommand",
          "args": [],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "lastCommand",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.h",
          "lines": "92-92",
          "snippet": "command_t lastCommand () const { return m_last_command; }",
          "includes": [
            "#include <y2/SymbolEntry.h>",
            "#include <string>",
            "#include <list>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2/SymbolEntry.h>\n#include <string>\n#include <list>\n#include <stdio.h>\n\nDebugger {\n  command_t lastCommand () const { return m_last_command; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "statement->evaluate",
          "args": [],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugger_instance->processInput",
          "args": [
            "command",
            "args"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "processInput",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "387-505",
          "snippet": "bool Debugger::processInput (command_t &command, std::list<std::string> &arguments)\n{\n    char c;\n    std::string s;\n    std::list<std::string> args;\n\n    // FIXME: use flex\n    if (m_descriptor == NULL)\n\treturn false;\n\t\n    // First, send the current context\n    YStatementPtr statement = ee.statement ();\n    \nafter_internal:\n    if (statement)\n\tsendOutput (ee.filename() + \":\" + stringutil::numstring(ee.linenumber()) + \" >>> \" + statement->toString ());\n    else\n\tsendOutput (\"no code\");\n    \n    // clean up for next command\n    s = \"\";\n    args.clear();\n\n    while ((c = fgetc (m_descriptor)) != EOF)\n    {\n\tif (c == '\\n')\n\t{\n\t    break;\n\t}\n\ts += c;\n    }\n    \n    if (s.empty ())\n    {\n\ty2error (\"Communication with debugging UI closed\");\n\tclose (m_socket);\n\t\n\tif (m_remote)\n\t    unlink (ADDRESS);\n\n\tm_socket = -1;\n\tm_descriptor = NULL;\n\treturn false;\n    }\n    \n    command = c_unknown;\n    // FIXME: I said flex!\n    if (s == \"c\")\n    {\n\tcommand = Debugger::c_continue;\n    }\n    else if (s == \"n\")\n    {\n\tcommand = Debugger::c_next;\n    }\n    else if (s == \"s\")\n    {\n\tcommand = Debugger::c_step;\n    }\n    else if (s == \"bt\")\n    {\n\tcommand = Debugger::c_backtrace;\n    }\n    else if (s[0] == 'v')\n    {\n\tcommand = Debugger::c_setvalue;\n\targs.push_back(s.substr(2));\n    }\n    else if ( s[0] == 'b' )\n    {\n\tcommand = Debugger::c_breakpoint;\n\targs.push_back(s.substr(2));\n    }\n    else if ( s[0] == 'r' && s[1] == 'b')\n    {\n\tcommand = Debugger::c_removebreakpoint;\n\targs.push_back(s.substr(3));\n    }\n    else if (s[0] == 'p')\n    {\n\tcommand = Debugger::c_print;\n\targs.push_back(s.substr(2));\n    }\n    \n    if (command == Debugger::c_print)\n    {\n\tprintVariable (args.front () );\n\tgoto after_internal;\n    }\n    \n    if (command == Debugger::c_breakpoint)\n    {\n\tsetBreakpoint (args);\n\tgoto after_internal;\n    }\n\n    if (command == Debugger::c_removebreakpoint)\n    {\n\tremoveBreakpoint (args);\n\tgoto after_internal;\n    }\n\n    if (command == Debugger::c_backtrace)\n    {\n\tgenerateBacktrace ();\n\tgoto after_internal;\n    }\n    \n    if (command == Debugger::c_setvalue)\n    {\n\tsetVariable (args.front () );\n\tgoto after_internal;\n    }\n    \n    arguments = args;\n    m_last_command = command;\n\n    return true;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [
            "#define ADDRESS     \"/tmp/yast.socket\""
          ],
          "globals_used": [
            "extern ExecutionEnvironment ee;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\n#define ADDRESS     \"/tmp/yast.socket\"\n\nextern ExecutionEnvironment ee;\n\nDebugger {\n  bool Debugger::processInput (command_t &command, std::list<std::string> &arguments)\n  {\n      char c;\n      std::string s;\n      std::list<std::string> args;\n  \n      // FIXME: use flex\n      if (m_descriptor == NULL)\n  \treturn false;\n  \t\n      // First, send the current context\n      YStatementPtr statement = ee.statement ();\n      \n  after_internal:\n      if (statement)\n  \tsendOutput (ee.filename() + \":\" + stringutil::numstring(ee.linenumber()) + \" >>> \" + statement->toString ());\n      else\n  \tsendOutput (\"no code\");\n      \n      // clean up for next command\n      s = \"\";\n      args.clear();\n  \n      while ((c = fgetc (m_descriptor)) != EOF)\n      {\n  \tif (c == '\\n')\n  \t{\n  \t    break;\n  \t}\n  \ts += c;\n      }\n      \n      if (s.empty ())\n      {\n  \ty2error (\"Communication with debugging UI closed\");\n  \tclose (m_socket);\n  \t\n  \tif (m_remote)\n  \t    unlink (ADDRESS);\n  \n  \tm_socket = -1;\n  \tm_descriptor = NULL;\n  \treturn false;\n      }\n      \n      command = c_unknown;\n      // FIXME: I said flex!\n      if (s == \"c\")\n      {\n  \tcommand = Debugger::c_continue;\n      }\n      else if (s == \"n\")\n      {\n  \tcommand = Debugger::c_next;\n      }\n      else if (s == \"s\")\n      {\n  \tcommand = Debugger::c_step;\n      }\n      else if (s == \"bt\")\n      {\n  \tcommand = Debugger::c_backtrace;\n      }\n      else if (s[0] == 'v')\n      {\n  \tcommand = Debugger::c_setvalue;\n  \targs.push_back(s.substr(2));\n      }\n      else if ( s[0] == 'b' )\n      {\n  \tcommand = Debugger::c_breakpoint;\n  \targs.push_back(s.substr(2));\n      }\n      else if ( s[0] == 'r' && s[1] == 'b')\n      {\n  \tcommand = Debugger::c_removebreakpoint;\n  \targs.push_back(s.substr(3));\n      }\n      else if (s[0] == 'p')\n      {\n  \tcommand = Debugger::c_print;\n  \targs.push_back(s.substr(2));\n      }\n      \n      if (command == Debugger::c_print)\n      {\n  \tprintVariable (args.front () );\n  \tgoto after_internal;\n      }\n      \n      if (command == Debugger::c_breakpoint)\n      {\n  \tsetBreakpoint (args);\n  \tgoto after_internal;\n      }\n  \n      if (command == Debugger::c_removebreakpoint)\n      {\n  \tremoveBreakpoint (args);\n  \tgoto after_internal;\n      }\n  \n      if (command == Debugger::c_backtrace)\n      {\n  \tgenerateBacktrace ();\n  \tgoto after_internal;\n      }\n      \n      if (command == Debugger::c_setvalue)\n      {\n  \tsetVariable (args.front () );\n  \tgoto after_internal;\n      }\n      \n      arguments = args;\n      m_last_command = command;\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "statement->kind",
          "args": [],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YBlock.h",
          "lines": "149-149",
          "snippet": "virtual ykind kind () const { return yeBlock; }",
          "includes": [
            "#include \"ycp/YStatement.h\"",
            "#include <y2/Y2Namespace.h>",
            "#include <y2util/Ustring.h>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YStatement.h\"\n#include <y2/Y2Namespace.h>\n#include <y2util/Ustring.h>\n#include <list>\n#include <string>\n\nYBlock {\n  virtual ykind kind () const { return yeBlock; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.setStatement",
          "args": [
            "statement"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "setStatement",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "78-89",
          "snippet": "void\nExecutionEnvironment::setStatement (YStatementPtr s)\n{\n    m_statement = s;\n    \n    if (s != NULL)\n    {\n\tm_linenumber = s->line ();\n    }\n    \n    return;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  void\n  ExecutionEnvironment::setStatement (YStatementPtr s)\n  {\n      m_statement = s;\n      \n      if (s != NULL)\n      {\n  \tm_linenumber = s->line ();\n      }\n      \n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"%d: %s\"",
            "statement->line ()",
            "statement->toString ().c_str ()"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement->line",
          "args": [],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "line",
          "container": "YStatement",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YStatement.h",
          "lines": "78-78",
          "snippet": "int line () const { return m_line; }",
          "includes": [
            "#include \"ycp/ycpless.h\"",
            "#include \"ycp/Import.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ycpless.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YCode.h\"\n#include <string>\n\nYStatement {\n  int line () const { return m_line; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "filename",
          "args": [],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "filename",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "131-135",
          "snippet": "const std::string \nYBlock::filename () const\n{\n    return m_point->filename();\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  const std::string \n  YBlock::filename () const\n  {\n      return m_point->filename();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushToStack",
          "args": [],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "pushToStack",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "254-264",
          "snippet": "void\nY2Namespace::pushToStack ()\n{\n    for (unsigned int p = 0; p < m_symbolcount; p++)\n    {\n\tif ( m_symbols[p] && m_symbols[p]->isVariable() )\n        {\n            m_symbols[p]->push ();\n        }\n    }\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  void\n  Y2Namespace::pushToStack ()\n  {\n      for (unsigned int p = 0; p < m_symbolcount; p++)\n      {\n  \tif ( m_symbols[p] && m_symbols[p]->isVariable() )\n          {\n              m_symbols[p]->push ();\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugger_instance->pushBlock",
          "args": [
            "this",
            "m_debug"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "pushBlock",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "546-553",
          "snippet": "void Debugger::pushBlock (Y2Namespace* block, bool tracing)\n{\n    stackitem_t si;\n    si.ns = block;\n    si.tracing = tracing;\n    \n    m_blockstack.push_front (si);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nDebugger {\n  void Debugger::pushBlock (Y2Namespace* block, bool tracing)\n  {\n      stackitem_t si;\n      si.ns = block;\n      si.tracing = tracing;\n      \n      m_blockstack.push_front (si);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock::evaluate([%d]%s)\\n\"",
            "(int)m_kind",
            "toString().c_str()"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nextern ExecutionEnvironment ee;\nextern Debugger* debugger_instance;\n\nYBlock {\n  YCPValue\n  YBlock::evaluate (bool cse)\n  {\n      if (cse)\n      {\n  \treturn YCPNull();\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"YBlock::evaluate([%d]%s)\\n\", (int)m_kind, toString().c_str());\n  #endif\n  \n      bool m_debug = false;\n  \n      if (debugger_instance)\n      {\n  \tm_debug = debugger_instance->tracing();\n  \t\n  \tdebugger_instance->pushBlock (this, m_debug);\n      }\n  \n      // recursion handling - not used for modules\n      if (! isModule () && m_running)\n      {\n  \tpushToStack ();\n      }\n      \n      bool old_m_running = m_running;\n      m_running = true;\n  \n      string restore_name;\n      if (!filename().empty())\n      {\n  \trestore_name = ee.filename ();\n  \tee.setFilename (filename());\n      }\n  \n      stmtlist_t *stmt = m_statements;\n      YCPValue value = YCPVoid ();\n      while (stmt)\n      {\n  \tbool next_hit = false;\n  \tYStatementPtr statement = stmt->stmt;\n  \t\n  #if DO_DEBUG\n  \ty2debug (\"%d: %s\", statement->line (), statement->toString ().c_str ());\n  #endif\n  \tee.setStatement (statement);\n  \n  \tif (m_debug && statement->kind() != ysFunction )\n  \t{\n  \t    Debugger::command_t command;\n  \t    std::list<std::string> args;\n  \t    if (debugger_instance->processInput (command, args) && command==Debugger::c_continue)\n  \t    {\n  \t\tm_debug = false;\n  \t\tdebugger_instance->setTracing (false);\n  \t    }\n  \t    else if (command == Debugger::c_next)\n  \t    {\n  \t\tnext_hit = true;\n  \t\tdebugger_instance->setTracing (false);\n  \t    }\n  \t}\n  \t\n  \n  \tvalue = statement->evaluate ();\n  \t\n  \t// If we get continue from inner evaluation, we have to respect it\n          if (debugger_instance)\n          {\n      \t    if (m_debug)\n      \t    {\n  \t\tm_debug = debugger_instance->lastCommand() != Debugger::c_continue;\n  \t\tdebugger_instance->setTracing (m_debug);\n  \t    }\n  \t    else\n  \t\tm_debug = debugger_instance->tracing ();\n  \t}\n  \n  \tif (!value.isNull())\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"Block exit (%s)\", value->toString().c_str());\n  #endif\n  \t    break;\n  \t}\n  \n  \tstmt = stmt->next;\n      }\n      if (!restore_name.empty())\n      {\n  \tee.setFilename (restore_name);\n      }\n      \n      m_running = old_m_running;\n      \n      // recursion handling - not used for modules\n      if (! isModule () && m_running)\n      {\n  \tpopFromStack ();\n      }\n      \n      if (debugger_instance)\n  \tdebugger_instance->popBlock ();\n  \n  #if DO_DEBUG\n      y2debug (\"YBlock::evaluate done (stmt %p, kind %d, value '%s')\\n\", stmt, m_kind, value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n  \n      // if stmt==0 we're at the end of the block. If the block is evaluated as a statement,\n      //   it returns NULL, else it returns Void\n      if (stmt == 0)\n      {\n  \tif (m_kind == b_statement)\n  \t{\n  \t    return YCPNull();\n  \t}\n  \treturn YCPVoid();\n      }\n  \n      // if stmt!=0 we just evaluated a break or return statement. A 'return;' evaluates to YCPReturn\n      return value;\n  }\n}"
  },
  {
    "function_name": "toStringSwitch",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "480-521",
    "snippet": "string\nYBlock::toStringSwitch (map<YCPValue, int, ycp_less> cases, int defaultcase) const\n{\n    // first, create reverse map of cases\n    int statementcount = statementCount ();\n    YCPValue values[statementcount];\n    \n    for (int i = 0; i < statementcount; i++)\n\tvalues[i] = YCPNull ();\n\t\n    for (map<YCPValue, int, ycp_less>::iterator it = cases.begin ();\n\tit != cases.end (); it++ )\n    {\n\tvalues[ it->second ] = it->first;\n    }\n    \n    // create string output\n    string s = \"{\";\n\n    s += environmentToString ();\n\n    stmtlist_t *stmt = m_statements;\n    int index = 0;\n    while (stmt)\n    {\n\ts += \"\\n    \";\n\tif (index == defaultcase)\n\t{\n\t    s += \"default:\\n    \";\n\t}\n\telse if (! values[index].isNull ())\n\t{\n\t    s += \"case \" + values[index]->toString ()+\":\\n    \";\n\t}\n\ts += stmt->stmt->toString();\n\tstmt = stmt->next;\n\tindex++;\n    }\n\n    s += \"\\n}\\n\";\n    return s;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stmt->stmt->toString",
          "args": [],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "445-477",
          "snippet": "string\nYBlock::toString () const\n{\n    string s;\n    if (m_kind == b_using)\n    {\n\ts = (m_name + \"::\");\n    }\n    s += \"{\";\n\n    if (isModule())\n    {\n\ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n    }\n\n    s += environmentToString ();\n    if (isModule()\n\t|| isFile())\n    {\n\ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n    }\n\n    stmtlist_t *stmt = m_statements;\n    while (stmt)\n    {\n\ts += \"\\n    \";\n\ts += stmt->stmt->toString();\n\tstmt = stmt->next;\n    }\n\n    s += \"\\n}\\n\";\n    return s;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::toString () const\n  {\n      string s;\n      if (m_kind == b_using)\n      {\n  \ts = (m_name + \"::\");\n      }\n      s += \"{\";\n  \n      if (isModule())\n      {\n  \ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n      }\n  \n      s += environmentToString ();\n      if (isModule()\n  \t|| isFile())\n      {\n  \ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n      }\n  \n      stmtlist_t *stmt = m_statements;\n      while (stmt)\n      {\n  \ts += \"\\n    \";\n  \ts += stmt->stmt->toString();\n  \tstmt = stmt->next;\n      }\n  \n      s += \"\\n}\\n\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "values[index].isNull",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "environmentToString",
          "args": [],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "environmentToString",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "423-442",
          "snippet": "string\nYBlock::environmentToString () const\n{\n    string s;\n\n    yTElist_t *tp = m_tenvironment;\n    while (tp)\n    {\n\tif (!tp->tentry->sentry()->isFilename())\n\t{\n\t    s += \"\\n    //T: \";\n\t    s += tp->tentry->toString();\n\t}\n\ttp = tp->next;\n    }\n\n    s += symbolsToString();\n\n    return s;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::environmentToString () const\n  {\n      string s;\n  \n      yTElist_t *tp = m_tenvironment;\n      while (tp)\n      {\n  \tif (!tp->tentry->sentry()->isFilename())\n  \t{\n  \t    s += \"\\n    //T: \";\n  \t    s += tp->tentry->toString();\n  \t}\n  \ttp = tp->next;\n      }\n  \n      s += symbolsToString();\n  \n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cases.end",
          "args": [],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cases.begin",
          "args": [],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statementCount",
          "args": [],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "statementCount",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "824-837",
          "snippet": "int\nYBlock::statementCount () const\n{\n    int res = 0;\n    stmtlist_t *stmt = m_statements;\n\n    while (stmt)\n    {\n\tstmt = stmt->next;\n\tres++;\n    }\n    \n    return res;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  int\n  YBlock::statementCount () const\n  {\n      int res = 0;\n      stmtlist_t *stmt = m_statements;\n  \n      while (stmt)\n      {\n  \tstmt = stmt->next;\n  \tres++;\n      }\n      \n      return res;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::toStringSwitch (map<YCPValue, int, ycp_less> cases, int defaultcase) const\n  {\n      // first, create reverse map of cases\n      int statementcount = statementCount ();\n      YCPValue values[statementcount];\n      \n      for (int i = 0; i < statementcount; i++)\n  \tvalues[i] = YCPNull ();\n  \t\n      for (map<YCPValue, int, ycp_less>::iterator it = cases.begin ();\n  \tit != cases.end (); it++ )\n      {\n  \tvalues[ it->second ] = it->first;\n      }\n      \n      // create string output\n      string s = \"{\";\n  \n      s += environmentToString ();\n  \n      stmtlist_t *stmt = m_statements;\n      int index = 0;\n      while (stmt)\n      {\n  \ts += \"\\n    \";\n  \tif (index == defaultcase)\n  \t{\n  \t    s += \"default:\\n    \";\n  \t}\n  \telse if (! values[index].isNull ())\n  \t{\n  \t    s += \"case \" + values[index]->toString ()+\":\\n    \";\n  \t}\n  \ts += stmt->stmt->toString();\n  \tstmt = stmt->next;\n  \tindex++;\n      }\n  \n      s += \"\\n}\\n\";\n      return s;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "445-477",
    "snippet": "string\nYBlock::toString () const\n{\n    string s;\n    if (m_kind == b_using)\n    {\n\ts = (m_name + \"::\");\n    }\n    s += \"{\";\n\n    if (isModule())\n    {\n\ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n    }\n\n    s += environmentToString ();\n    if (isModule()\n\t|| isFile())\n    {\n\ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n    }\n\n    stmtlist_t *stmt = m_statements;\n    while (stmt)\n    {\n\ts += \"\\n    \";\n\ts += stmt->stmt->toString();\n\tstmt = stmt->next;\n    }\n\n    s += \"\\n}\\n\";\n    return s;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stmt->stmt->toString",
          "args": [],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "445-477",
          "snippet": "string\nYBlock::toString () const\n{\n    string s;\n    if (m_kind == b_using)\n    {\n\ts = (m_name + \"::\");\n    }\n    s += \"{\";\n\n    if (isModule())\n    {\n\ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n    }\n\n    s += environmentToString ();\n    if (isModule()\n\t|| isFile())\n    {\n\ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n    }\n\n    stmtlist_t *stmt = m_statements;\n    while (stmt)\n    {\n\ts += \"\\n    \";\n\ts += stmt->stmt->toString();\n\tstmt = stmt->next;\n    }\n\n    s += \"\\n}\\n\";\n    return s;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "filename",
          "args": [],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "filename",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "131-135",
          "snippet": "const std::string \nYBlock::filename () const\n{\n    return m_point->filename();\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  const std::string \n  YBlock::filename () const\n  {\n      return m_point->filename();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isFile",
          "args": [],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "isFile",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YBlock.h",
          "lines": "206-206",
          "snippet": "bool isFile () const\t{ return (m_kind == b_file); }",
          "includes": [
            "#include \"ycp/YStatement.h\"",
            "#include <y2/Y2Namespace.h>",
            "#include <y2util/Ustring.h>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YStatement.h\"\n#include <y2/Y2Namespace.h>\n#include <y2util/Ustring.h>\n#include <list>\n#include <string>\n\nYBlock {\n  bool isFile () const\t{ return (m_kind == b_file); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isModule",
          "args": [],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "isModule",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YBlock.h",
          "lines": "205-205",
          "snippet": "bool isModule () const\t{ return (m_kind == b_module); }",
          "includes": [
            "#include \"ycp/YStatement.h\"",
            "#include <y2/Y2Namespace.h>",
            "#include <y2util/Ustring.h>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YStatement.h\"\n#include <y2/Y2Namespace.h>\n#include <y2util/Ustring.h>\n#include <list>\n#include <string>\n\nYBlock {\n  bool isModule () const\t{ return (m_kind == b_module); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "environmentToString",
          "args": [],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "environmentToString",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "423-442",
          "snippet": "string\nYBlock::environmentToString () const\n{\n    string s;\n\n    yTElist_t *tp = m_tenvironment;\n    while (tp)\n    {\n\tif (!tp->tentry->sentry()->isFilename())\n\t{\n\t    s += \"\\n    //T: \";\n\t    s += tp->tentry->toString();\n\t}\n\ttp = tp->next;\n    }\n\n    s += symbolsToString();\n\n    return s;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::environmentToString () const\n  {\n      string s;\n  \n      yTElist_t *tp = m_tenvironment;\n      while (tp)\n      {\n  \tif (!tp->tentry->sentry()->isFilename())\n  \t{\n  \t    s += \"\\n    //T: \";\n  \t    s += tp->tentry->toString();\n  \t}\n  \ttp = tp->next;\n      }\n  \n      s += symbolsToString();\n  \n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::toString () const\n  {\n      string s;\n      if (m_kind == b_using)\n      {\n  \ts = (m_name + \"::\");\n      }\n      s += \"{\";\n  \n      if (isModule())\n      {\n  \ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n      }\n  \n      s += environmentToString ();\n      if (isModule()\n  \t|| isFile())\n      {\n  \ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n      }\n  \n      stmtlist_t *stmt = m_statements;\n      while (stmt)\n      {\n  \ts += \"\\n    \";\n  \ts += stmt->stmt->toString();\n  \tstmt = stmt->next;\n      }\n  \n      s += \"\\n}\\n\";\n      return s;\n  }\n}"
  },
  {
    "function_name": "environmentToString",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "423-442",
    "snippet": "string\nYBlock::environmentToString () const\n{\n    string s;\n\n    yTElist_t *tp = m_tenvironment;\n    while (tp)\n    {\n\tif (!tp->tentry->sentry()->isFilename())\n\t{\n\t    s += \"\\n    //T: \";\n\t    s += tp->tentry->toString();\n\t}\n\ttp = tp->next;\n    }\n\n    s += symbolsToString();\n\n    return s;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "symbolsToString",
          "args": [],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "symbolsToString",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "91-115",
          "snippet": "string\nY2Namespace::symbolsToString () const\n{\n    string s;\n\n    symbols_t::const_iterator it;\n    for (unsigned int p = 0; p < m_symbolcount; p++)\n    {\n\tif ( m_symbols[p] )\n\t{\n\t    if (!m_symbols[p]->isFilename ())\n\t    {\n\t\ts += \"\\n    // \";\n\t\ts += m_symbols[p]->toString();\n\t    }\n\t}\n\telse\n\t{\n\t    s += \"\\n    // \";\n\t    s += \"<released>\";\n\t}\n    }\n\n    return s;\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  string\n  Y2Namespace::symbolsToString () const\n  {\n      string s;\n  \n      symbols_t::const_iterator it;\n      for (unsigned int p = 0; p < m_symbolcount; p++)\n      {\n  \tif ( m_symbols[p] )\n  \t{\n  \t    if (!m_symbols[p]->isFilename ())\n  \t    {\n  \t\ts += \"\\n    // \";\n  \t\ts += m_symbols[p]->toString();\n  \t    }\n  \t}\n  \telse\n  \t{\n  \t    s += \"\\n    // \";\n  \t    s += \"<released>\";\n  \t}\n      }\n  \n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp->tentry->toString",
          "args": [],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "445-477",
          "snippet": "string\nYBlock::toString () const\n{\n    string s;\n    if (m_kind == b_using)\n    {\n\ts = (m_name + \"::\");\n    }\n    s += \"{\";\n\n    if (isModule())\n    {\n\ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n    }\n\n    s += environmentToString ();\n    if (isModule()\n\t|| isFile())\n    {\n\ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n    }\n\n    stmtlist_t *stmt = m_statements;\n    while (stmt)\n    {\n\ts += \"\\n    \";\n\ts += stmt->stmt->toString();\n\tstmt = stmt->next;\n    }\n\n    s += \"\\n}\\n\";\n    return s;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::toString () const\n  {\n      string s;\n      if (m_kind == b_using)\n      {\n  \ts = (m_name + \"::\");\n      }\n      s += \"{\";\n  \n      if (isModule())\n      {\n  \ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n      }\n  \n      s += environmentToString ();\n      if (isModule()\n  \t|| isFile())\n      {\n  \ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n      }\n  \n      stmtlist_t *stmt = m_statements;\n      while (stmt)\n      {\n  \ts += \"\\n    \";\n  \ts += stmt->stmt->toString();\n  \tstmt = stmt->next;\n      }\n  \n      s += \"\\n}\\n\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp->tentry->sentry",
          "args": [],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "sentry",
          "container": "TableEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "97-101",
          "snippet": "SymbolEntryPtr \nTableEntry::sentry() const\n{\n    return m_entry;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  SymbolEntryPtr \n  TableEntry::sentry() const\n  {\n      return m_entry;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::environmentToString () const\n  {\n      string s;\n  \n      yTElist_t *tp = m_tenvironment;\n      while (tp)\n      {\n  \tif (!tp->tentry->sentry()->isFilename())\n  \t{\n  \t    s += \"\\n    //T: \";\n  \t    s += tp->tentry->toString();\n  \t}\n  \ttp = tp->next;\n      }\n  \n      s += symbolsToString();\n  \n      return s;\n  }\n}"
  },
  {
    "function_name": "endInclude",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "404-420",
    "snippet": "void\nYBlock::endInclude ()\n{\n    const Point *point = m_point->point();\n    if (point == 0)\n    {\n\ty2error (\"YBlock::endInclude() with empty chain (%s)\", m_point->toString().c_str());\n    }\n    else\n    {\n#if DO_DEBUG\n\ty2debug (\"YBlock::endInclude(%s)\", m_point->toString().c_str());\n#endif\n\tm_point = point;\n    }\n    return;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock::endInclude(%s)\"",
            "m_point->toString().c_str()"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_point->toString",
          "args": [],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "445-477",
          "snippet": "string\nYBlock::toString () const\n{\n    string s;\n    if (m_kind == b_using)\n    {\n\ts = (m_name + \"::\");\n    }\n    s += \"{\";\n\n    if (isModule())\n    {\n\ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n    }\n\n    s += environmentToString ();\n    if (isModule()\n\t|| isFile())\n    {\n\ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n    }\n\n    stmtlist_t *stmt = m_statements;\n    while (stmt)\n    {\n\ts += \"\\n    \";\n\ts += stmt->stmt->toString();\n\tstmt = stmt->next;\n    }\n\n    s += \"\\n}\\n\";\n    return s;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::toString () const\n  {\n      string s;\n      if (m_kind == b_using)\n      {\n  \ts = (m_name + \"::\");\n      }\n      s += \"{\";\n  \n      if (isModule())\n      {\n  \ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n      }\n  \n      s += environmentToString ();\n      if (isModule()\n  \t|| isFile())\n      {\n  \ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n      }\n  \n      stmtlist_t *stmt = m_statements;\n      while (stmt)\n      {\n  \ts += \"\\n    \";\n  \ts += stmt->stmt->toString();\n  \tstmt = stmt->next;\n      }\n  \n      s += \"\\n}\\n\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"YBlock::endInclude() with empty chain (%s)\"",
            "m_point->toString().c_str()"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_point->point",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  void\n  YBlock::endInclude ()\n  {\n      const Point *point = m_point->point();\n      if (point == 0)\n      {\n  \ty2error (\"YBlock::endInclude() with empty chain (%s)\", m_point->toString().c_str());\n      }\n      else\n      {\n  #if DO_DEBUG\n  \ty2debug (\"YBlock::endInclude(%s)\", m_point->toString().c_str());\n  #endif\n  \tm_point = point;\n      }\n      return;\n  }\n}"
  },
  {
    "function_name": "setName",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "389-394",
    "snippet": "void\nYBlock::setName (const string &name)\n{\n    m_name = name;\n    return;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  void\n  YBlock::setName (const string &name)\n  {\n      m_name = name;\n      return;\n  }\n}"
  },
  {
    "function_name": "name",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "382-386",
    "snippet": "const string \nYBlock::name () const\n{\n    return m_name;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  const string \n  YBlock::name () const\n  {\n      return m_name;\n  }\n}"
  },
  {
    "function_name": "justReturn",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "367-379",
    "snippet": "YSReturnPtr\nYBlock::justReturn () const\n{\n    if (m_statements != 0)\n    {\n\tYStatementPtr stmt = m_statements->stmt;\n\tif (stmt->kind() == YCode::ysReturn)\n\t{\n\t    return (YSReturnPtr)stmt;\n\t}\n    }\n    return 0;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stmt->kind",
          "args": [],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YBlock.h",
          "lines": "149-149",
          "snippet": "virtual ykind kind () const { return yeBlock; }",
          "includes": [
            "#include \"ycp/YStatement.h\"",
            "#include <y2/Y2Namespace.h>",
            "#include <y2util/Ustring.h>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YStatement.h\"\n#include <y2/Y2Namespace.h>\n#include <y2util/Ustring.h>\n#include <list>\n#include <string>\n\nYBlock {\n  virtual ykind kind () const { return yeBlock; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  YSReturnPtr\n  YBlock::justReturn () const\n  {\n      if (m_statements != 0)\n      {\n  \tYStatementPtr stmt = m_statements->stmt;\n  \tif (stmt->kind() == YCode::ysReturn)\n  \t{\n  \t    return (YSReturnPtr)stmt;\n  \t}\n      }\n      return 0;\n  }\n}"
  },
  {
    "function_name": "bkind",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "360-364",
    "snippet": "YBlock::blockkind_t\nYBlock::bkind () const\n{\n    return m_kind;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  YBlock::blockkind_t\n  YBlock::bkind () const\n  {\n      return m_kind;\n  }\n}"
  },
  {
    "function_name": "setKind",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "349-357",
    "snippet": "void\nYBlock::setKind (YBlock::blockkind_t kind)\n{\n#if DO_DEBUG\n    y2debug (\"YBlock::setKind %p: %d\", this, (int)kind);\n#endif\n    m_kind = kind;\n    return;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock::setKind %p: %d\"",
            "this",
            "(int)kind"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  void\n  YBlock::setKind (YBlock::blockkind_t kind)\n  {\n  #if DO_DEBUG\n      y2debug (\"YBlock::setKind %p: %d\", this, (int)kind);\n  #endif\n      m_kind = kind;\n      return;\n  }\n}"
  },
  {
    "function_name": "detachEnvironment",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "300-346",
    "snippet": "void\nYBlock::detachEnvironment (SymbolTable *table)\n{\n#if DO_DEBUG\n    y2debug (\"YBlock::detachEnvironment of %p (%s) from %s\", this, environmentToString().c_str(), table->toString().c_str());\n#endif\n\n    // unlink table entries belonging to table (usually, these are the local symbols)\n\n    yTElist_t *tp = m_tenvironment;\n    yTElist_t *prev = 0;\n    while (tp)\n    {\n\tyTElist_t *next = tp->next;\n\n\tif (tp->tentry\n\t    && tp->tentry->table() == table)\n\t{\n#if DO_DEBUG\n\t    y2debug (\"Remove %s\", tp->tentry->toString().c_str());\n#endif\n\t    table->remove (tp->tentry);\t\t\t// remove the TableEntry\n\t    delete tp;\n\t    if (prev != 0)\n\t    {\n\t\tprev->next = next;\n\t    }\n\t    else\n\t    {\n\t\tm_tenvironment = next;\n\t    }\n\t}\n\telse\n\t{\n\t    prev = tp;\n\t}\n\ttp = next;\n    }\n\n    if (prev == 0)\t\t\t// all removed\n    {\n\tm_tenvironment = 0;\n    }\n    m_last_tparm = 0;\n\n    return;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "table->remove",
          "args": [
            "tp->tentry"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "remove",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "104-113",
          "snippet": "void YCPMapRep::remove(const YCPValue& key)\n{\n    if (!key->isString() && !key->isInteger() && !key->isSymbol())\n    {\n        ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n        return;\n    }\n\n    stl_map.erase (key);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void YCPMapRep::remove(const YCPValue& key)\n  {\n      if (!key->isString() && !key->isInteger() && !key->isSymbol())\n      {\n          ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n          return;\n      }\n  \n      stl_map.erase (key);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Remove %s\"",
            "tp->tentry->toString().c_str()"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp->tentry->toString",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "445-477",
          "snippet": "string\nYBlock::toString () const\n{\n    string s;\n    if (m_kind == b_using)\n    {\n\ts = (m_name + \"::\");\n    }\n    s += \"{\";\n\n    if (isModule())\n    {\n\ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n    }\n\n    s += environmentToString ();\n    if (isModule()\n\t|| isFile())\n    {\n\ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n    }\n\n    stmtlist_t *stmt = m_statements;\n    while (stmt)\n    {\n\ts += \"\\n    \";\n\ts += stmt->stmt->toString();\n\tstmt = stmt->next;\n    }\n\n    s += \"\\n}\\n\";\n    return s;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::toString () const\n  {\n      string s;\n      if (m_kind == b_using)\n      {\n  \ts = (m_name + \"::\");\n      }\n      s += \"{\";\n  \n      if (isModule())\n      {\n  \ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n      }\n  \n      s += environmentToString ();\n      if (isModule()\n  \t|| isFile())\n      {\n  \ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n      }\n  \n      stmtlist_t *stmt = m_statements;\n      while (stmt)\n      {\n  \ts += \"\\n    \";\n  \ts += stmt->stmt->toString();\n  \tstmt = stmt->next;\n      }\n  \n      s += \"\\n}\\n\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp->tentry->table",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock::detachEnvironment of %p (%s) from %s\"",
            "this",
            "environmentToString().c_str()",
            "table->toString().c_str()"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "environmentToString",
          "args": [],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "environmentToString",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "423-442",
          "snippet": "string\nYBlock::environmentToString () const\n{\n    string s;\n\n    yTElist_t *tp = m_tenvironment;\n    while (tp)\n    {\n\tif (!tp->tentry->sentry()->isFilename())\n\t{\n\t    s += \"\\n    //T: \";\n\t    s += tp->tentry->toString();\n\t}\n\ttp = tp->next;\n    }\n\n    s += symbolsToString();\n\n    return s;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::environmentToString () const\n  {\n      string s;\n  \n      yTElist_t *tp = m_tenvironment;\n      while (tp)\n      {\n  \tif (!tp->tentry->sentry()->isFilename())\n  \t{\n  \t    s += \"\\n    //T: \";\n  \t    s += tp->tentry->toString();\n  \t}\n  \ttp = tp->next;\n      }\n  \n      s += symbolsToString();\n  \n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  void\n  YBlock::detachEnvironment (SymbolTable *table)\n  {\n  #if DO_DEBUG\n      y2debug (\"YBlock::detachEnvironment of %p (%s) from %s\", this, environmentToString().c_str(), table->toString().c_str());\n  #endif\n  \n      // unlink table entries belonging to table (usually, these are the local symbols)\n  \n      yTElist_t *tp = m_tenvironment;\n      yTElist_t *prev = 0;\n      while (tp)\n      {\n  \tyTElist_t *next = tp->next;\n  \n  \tif (tp->tentry\n  \t    && tp->tentry->table() == table)\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"Remove %s\", tp->tentry->toString().c_str());\n  #endif\n  \t    table->remove (tp->tentry);\t\t\t// remove the TableEntry\n  \t    delete tp;\n  \t    if (prev != 0)\n  \t    {\n  \t\tprev->next = next;\n  \t    }\n  \t    else\n  \t    {\n  \t\tm_tenvironment = next;\n  \t    }\n  \t}\n  \telse\n  \t{\n  \t    prev = tp;\n  \t}\n  \ttp = next;\n      }\n  \n      if (prev == 0)\t\t\t// all removed\n      {\n  \tm_tenvironment = 0;\n      }\n      m_last_tparm = 0;\n  \n      return;\n  }\n}"
  },
  {
    "function_name": "pretachStatement",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "262-275",
    "snippet": "void\nYBlock::pretachStatement (YStatementPtr statement)\n{\n#if DO_DEBUG\n    y2debug (\"YBlock[%p]::pretachStatement (%s)\", this, statement->toString().c_str());\n#endif\n\n    stmtlist_t *newstmt = new (stmtlist_t);\n    newstmt->stmt = statement;\n    newstmt->next = m_statements;\n    m_statements = newstmt;\n\n    return;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock[%p]::pretachStatement (%s)\"",
            "this",
            "statement->toString().c_str()"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement->toString",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "445-477",
          "snippet": "string\nYBlock::toString () const\n{\n    string s;\n    if (m_kind == b_using)\n    {\n\ts = (m_name + \"::\");\n    }\n    s += \"{\";\n\n    if (isModule())\n    {\n\ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n    }\n\n    s += environmentToString ();\n    if (isModule()\n\t|| isFile())\n    {\n\ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n    }\n\n    stmtlist_t *stmt = m_statements;\n    while (stmt)\n    {\n\ts += \"\\n    \";\n\ts += stmt->stmt->toString();\n\tstmt = stmt->next;\n    }\n\n    s += \"\\n}\\n\";\n    return s;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::toString () const\n  {\n      string s;\n      if (m_kind == b_using)\n      {\n  \ts = (m_name + \"::\");\n      }\n      s += \"{\";\n  \n      if (isModule())\n      {\n  \ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n      }\n  \n      s += environmentToString ();\n      if (isModule()\n  \t|| isFile())\n      {\n  \ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n      }\n  \n      stmtlist_t *stmt = m_statements;\n      while (stmt)\n      {\n  \ts += \"\\n    \";\n  \ts += stmt->stmt->toString();\n  \tstmt = stmt->next;\n      }\n  \n      s += \"\\n}\\n\";\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  void\n  YBlock::pretachStatement (YStatementPtr statement)\n  {\n  #if DO_DEBUG\n      y2debug (\"YBlock[%p]::pretachStatement (%s)\", this, statement->toString().c_str());\n  #endif\n  \n      stmtlist_t *newstmt = new (stmtlist_t);\n      newstmt->stmt = statement;\n      newstmt->next = m_statements;\n      m_statements = newstmt;\n  \n      return;\n  }\n}"
  },
  {
    "function_name": "attachStatement",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "234-259",
    "snippet": "void\nYBlock::attachStatement (YStatementPtr statement)\n{\n#if DO_DEBUG\n    y2debug (\"YBlock[%p]::attachStatement (%s)\", this, statement ? statement->toString().c_str() : \"<NULL>\");\n#endif\n    if (statement == 0)\n    {\n\treturn;\n    }\n    stmtlist_t *newstmt = new (stmtlist_t);\n    newstmt->stmt = statement;\n    newstmt->next = 0;\n    if (m_statements == 0)\n    {\n\tm_statements = newstmt;\n\tm_last_statement = m_statements;\n    }\n    else\n    {\n\tm_last_statement->next = newstmt;\n        m_last_statement = newstmt;\n    }\n    \n    return;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock[%p]::attachStatement (%s)\"",
            "this",
            "statement ? statement->toString().c_str() : \"<NULL>\""
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement->toString",
          "args": [],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "445-477",
          "snippet": "string\nYBlock::toString () const\n{\n    string s;\n    if (m_kind == b_using)\n    {\n\ts = (m_name + \"::\");\n    }\n    s += \"{\";\n\n    if (isModule())\n    {\n\ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n    }\n\n    s += environmentToString ();\n    if (isModule()\n\t|| isFile())\n    {\n\ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n    }\n\n    stmtlist_t *stmt = m_statements;\n    while (stmt)\n    {\n\ts += \"\\n    \";\n\ts += stmt->stmt->toString();\n\tstmt = stmt->next;\n    }\n\n    s += \"\\n}\\n\";\n    return s;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::toString () const\n  {\n      string s;\n      if (m_kind == b_using)\n      {\n  \ts = (m_name + \"::\");\n      }\n      s += \"{\";\n  \n      if (isModule())\n      {\n  \ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n      }\n  \n      s += environmentToString ();\n      if (isModule()\n  \t|| isFile())\n      {\n  \ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n      }\n  \n      stmtlist_t *stmt = m_statements;\n      while (stmt)\n      {\n  \ts += \"\\n    \";\n  \ts += stmt->stmt->toString();\n  \tstmt = stmt->next;\n      }\n  \n      s += \"\\n}\\n\";\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  void\n  YBlock::attachStatement (YStatementPtr statement)\n  {\n  #if DO_DEBUG\n      y2debug (\"YBlock[%p]::attachStatement (%s)\", this, statement ? statement->toString().c_str() : \"<NULL>\");\n  #endif\n      if (statement == 0)\n      {\n  \treturn;\n      }\n      stmtlist_t *newstmt = new (stmtlist_t);\n      newstmt->stmt = statement;\n      newstmt->next = 0;\n      if (m_statements == 0)\n      {\n  \tm_statements = newstmt;\n  \tm_last_statement = m_statements;\n      }\n      else\n      {\n  \tm_last_statement->next = newstmt;\n          m_last_statement = newstmt;\n      }\n      \n      return;\n  }\n}"
  },
  {
    "function_name": "attachEntry",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "205-231",
    "snippet": "void\nYBlock::attachEntry (TableEntry *tentry)\n{\n#if DO_DEBUG\n    y2debug (\"YBlock[%p]::attachEntry (%p)\", this, tentry/*->toString().c_str()*/);\n#endif\n\n    yTElist_t *newt = new (yTElist_t);\n    newt->tentry = tentry;\n    newt->next = 0;\n\n    if (m_tenvironment == 0)\n    {\n\tm_tenvironment = newt;\n\tm_last_tparm = m_tenvironment;\n    }\n    else if (m_last_tparm == 0)\n    {\n\ty2error (\"YBlock::attachEntry after detach_environemt !\");\n    }\n    else\n    {\n\tm_last_tparm->next = newt;\n\tm_last_tparm = newt;\n    }\n    return;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"YBlock::attachEntry after detach_environemt !\""
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock[%p]::attachEntry (%p)\"",
            "this",
            "tentry/*->toString().c_str()*/"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  void\n  YBlock::attachEntry (TableEntry *tentry)\n  {\n  #if DO_DEBUG\n      y2debug (\"YBlock[%p]::attachEntry (%p)\", this, tentry/*->toString().c_str()*/);\n  #endif\n  \n      yTElist_t *newt = new (yTElist_t);\n      newt->tentry = tentry;\n      newt->next = 0;\n  \n      if (m_tenvironment == 0)\n      {\n  \tm_tenvironment = newt;\n  \tm_last_tparm = m_tenvironment;\n      }\n      else if (m_last_tparm == 0)\n      {\n  \ty2error (\"YBlock::attachEntry after detach_environemt !\");\n      }\n      else\n      {\n  \tm_last_tparm->next = newt;\n  \tm_last_tparm = newt;\n      }\n      return;\n  }\n}"
  },
  {
    "function_name": "newValue",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "141-153",
    "snippet": "unsigned int\nYBlock::newValue (constTypePtr type, YCodePtr code)\n{\n    static char name[8];\n    snprintf (name, 8, \"_%d\", symbolCount());\t\t// create 'fake' name\n\n#if DO_DEBUG\n    y2debug (\"YBlock::newValue (%s %s)\", type->toString().c_str(), name);\n#endif\n\n// FIXME: check duplicates\n    return addSymbol (new YSymbolEntry (nameSpace(), symbolCount(), name, SymbolEntry::c_const, type, code));\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addSymbol",
          "args": [
            "new YSymbolEntry (nameSpace(), symbolCount(), name, SymbolEntry::c_const, type, code)"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "addSymbol",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "133-141",
          "snippet": "unsigned int\nY2Namespace::addSymbol (SymbolEntryPtr sentry)\n{\n#if DO_DEBUG\n    y2debug (\"addSymbol #%d:'%s'\", m_symbolcount, sentry->toString().c_str());\n#endif\n    m_symbols.push_back(sentry);\n    return m_symbolcount++;\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\n#define DO_DEBUG 0\n\nY2Namespace {\n  unsigned int\n  Y2Namespace::addSymbol (SymbolEntryPtr sentry)\n  {\n  #if DO_DEBUG\n      y2debug (\"addSymbol #%d:'%s'\", m_symbolcount, sentry->toString().c_str());\n  #endif\n      m_symbols.push_back(sentry);\n      return m_symbolcount++;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "symbolCount",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "symbolCount",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "69-73",
          "snippet": "unsigned int\nY2Namespace::symbolCount () const\n{\n    return m_symbols.size();\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  unsigned int\n  Y2Namespace::symbolCount () const\n  {\n      return m_symbols.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nameSpace",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock::newValue (%s %s)\"",
            "type->toString().c_str()",
            "name"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "445-477",
          "snippet": "string\nYBlock::toString () const\n{\n    string s;\n    if (m_kind == b_using)\n    {\n\ts = (m_name + \"::\");\n    }\n    s += \"{\";\n\n    if (isModule())\n    {\n\ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n    }\n\n    s += environmentToString ();\n    if (isModule()\n\t|| isFile())\n    {\n\ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n    }\n\n    stmtlist_t *stmt = m_statements;\n    while (stmt)\n    {\n\ts += \"\\n    \";\n\ts += stmt->stmt->toString();\n\tstmt = stmt->next;\n    }\n\n    s += \"\\n}\\n\";\n    return s;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  string\n  YBlock::toString () const\n  {\n      string s;\n      if (m_kind == b_using)\n      {\n  \ts = (m_name + \"::\");\n      }\n      s += \"{\";\n  \n      if (isModule())\n      {\n  \ts += \"\\n    module \\\"\" + m_name + \"\\\";\\n\";\n      }\n  \n      s += environmentToString ();\n      if (isModule()\n  \t|| isFile())\n      {\n  \ts += \"\\n    // filename: \\\"\" + filename() + \"\\\"\";\n      }\n  \n      stmtlist_t *stmt = m_statements;\n      while (stmt)\n      {\n  \ts += \"\\n    \";\n  \ts += stmt->stmt->toString();\n  \tstmt = stmt->next;\n      }\n  \n      s += \"\\n}\\n\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "8",
            "\"_%d\"",
            "symbolCount()"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  unsigned int\n  YBlock::newValue (constTypePtr type, YCodePtr code)\n  {\n      static char name[8];\n      snprintf (name, 8, \"_%d\", symbolCount());\t\t// create 'fake' name\n  \n  #if DO_DEBUG\n      y2debug (\"YBlock::newValue (%s %s)\", type->toString().c_str(), name);\n  #endif\n  \n  // FIXME: check duplicates\n      return addSymbol (new YSymbolEntry (nameSpace(), symbolCount(), name, SymbolEntry::c_const, type, code));\n  }\n}"
  },
  {
    "function_name": "filename",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "131-135",
    "snippet": "const std::string \nYBlock::filename () const\n{\n    return m_point->filename();\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_point->filename",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "filename",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "131-135",
          "snippet": "const std::string \nYBlock::filename () const\n{\n    return m_point->filename();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  const std::string \n  YBlock::filename () const\n  {\n      return m_point->filename();\n  }\n}"
  },
  {
    "function_name": "~YBlock",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "99-128",
    "snippet": "YBlock::~YBlock ()\n{\n#if DO_DEBUG\n    y2debug (\"YBlock::~YBlock [%p]\", this);\n#endif\n    stmtlist_t *stmt = m_statements;\n    while (stmt)\n    {\n\tstmtlist_t *nexts = stmt->next;\n\tdelete stmt;\n\tstmt = nexts;\n    }\n\n    if (m_kind == b_file)\t\t\t// point belongs to file kind block\n    {\n\tif (m_point)\n\t    delete m_point;\n    }\n\n    yTElist_t *tp = m_tenvironment;\n    while (tp)\n    {\n\tyTElist_t *next = tp->next;\n\tdelete tp;\n\ttp = next;\n    }\n    \n    if (m_includes)\n\tdelete m_includes;\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock::~YBlock [%p]\"",
            "this"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  YBlock::~YBlock ()\n  {\n  #if DO_DEBUG\n      y2debug (\"YBlock::~YBlock [%p]\", this);\n  #endif\n      stmtlist_t *stmt = m_statements;\n      while (stmt)\n      {\n  \tstmtlist_t *nexts = stmt->next;\n  \tdelete stmt;\n  \tstmt = nexts;\n      }\n  \n      if (m_kind == b_file)\t\t\t// point belongs to file kind block\n      {\n  \tif (m_point)\n  \t    delete m_point;\n      }\n  \n      yTElist_t *tp = m_tenvironment;\n      while (tp)\n      {\n  \tyTElist_t *next = tp->next;\n  \tdelete tp;\n  \ttp = next;\n      }\n      \n      if (m_includes)\n  \tdelete m_includes;\n  }\n}"
  },
  {
    "function_name": "YBlock",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "83-96",
    "snippet": "YBlock::YBlock (const Point *point)\n    : YCode ()\n    , m_kind (b_unknown)\n    , m_name (\"\")\n    , m_tenvironment (0)\n    , m_last_tparm (0)\n    , m_point (point)\n    , m_statements (0)\n    , m_last_statement (0)\n    , m_includes (0)\n    , m_type (Type::Unspec)\n    , m_running (false)\n{\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\nYBlock {\n  YBlock::YBlock (const Point *point)\n      : YCode ()\n      , m_kind (b_unknown)\n      , m_name (\"\")\n      , m_tenvironment (0)\n      , m_last_tparm (0)\n      , m_point (point)\n      , m_statements (0)\n      , m_last_statement (0)\n      , m_includes (0)\n      , m_type (Type::Unspec)\n      , m_running (false)\n  {\n  }\n}"
  },
  {
    "function_name": "YBlock",
    "container": "YBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
    "lines": "58-79",
    "snippet": "YBlock::YBlock (const std::string & filename, YBlock::blockkind_t kind)\n    : YCode ()\n    , m_kind (kind)\n    , m_name (\"\")\n    , m_tenvironment (0)\n    , m_last_tparm (0)\n    , m_point (0)\n    , m_statements (0)\n    , m_last_statement (0)\n    , m_includes (0)\n    , m_type (Type::Unspec)\n    , m_running (false)\n{\n#if DO_DEBUG\n    y2debug (\"YBlock::YBlock [%p] (%s)\", this, filename.c_str());\n#endif\n    // add filename as SymbolEntry:c_filename\n    SymbolEntryPtr sentry = new YSymbolEntry (nameSpace(), 0, filename.c_str(), SymbolEntry::c_filename, Type::Unspec);\n    addSymbol (sentry);\n\n    m_point = new Point (sentry);\n}",
    "includes": [
      "#include <Debugger.h>",
      "#include \"ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/Scanner.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Point.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YSymbolEntry.h\"",
      "#include <algorithm>",
      "#include <stack>",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/Type.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addSymbol",
          "args": [
            "sentry"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "addSymbol",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "133-141",
          "snippet": "unsigned int\nY2Namespace::addSymbol (SymbolEntryPtr sentry)\n{\n#if DO_DEBUG\n    y2debug (\"addSymbol #%d:'%s'\", m_symbolcount, sentry->toString().c_str());\n#endif\n    m_symbols.push_back(sentry);\n    return m_symbolcount++;\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\n#define DO_DEBUG 0\n\nY2Namespace {\n  unsigned int\n  Y2Namespace::addSymbol (SymbolEntryPtr sentry)\n  {\n  #if DO_DEBUG\n      y2debug (\"addSymbol #%d:'%s'\", m_symbolcount, sentry->toString().c_str());\n  #endif\n      m_symbols.push_back(sentry);\n      return m_symbolcount++;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nameSpace",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YBlock::YBlock [%p] (%s)\"",
            "this",
            "filename.c_str()"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  YBlock::YBlock (const std::string & filename, YBlock::blockkind_t kind)\n      : YCode ()\n      , m_kind (kind)\n      , m_name (\"\")\n      , m_tenvironment (0)\n      , m_last_tparm (0)\n      , m_point (0)\n      , m_statements (0)\n      , m_last_statement (0)\n      , m_includes (0)\n      , m_type (Type::Unspec)\n      , m_running (false)\n  {\n  #if DO_DEBUG\n      y2debug (\"YBlock::YBlock [%p] (%s)\", this, filename.c_str());\n  #endif\n      // add filename as SymbolEntry:c_filename\n      SymbolEntryPtr sentry = new YSymbolEntry (nameSpace(), 0, filename.c_str(), SymbolEntry::c_filename, Type::Unspec);\n      addSymbol (sentry);\n  \n      m_point = new Point (sentry);\n  }\n}"
  }
]