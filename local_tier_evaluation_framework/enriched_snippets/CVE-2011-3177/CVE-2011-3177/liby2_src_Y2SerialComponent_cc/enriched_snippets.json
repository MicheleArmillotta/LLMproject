[
  {
    "function_name": "receiveFromSerial",
    "container": "Y2SerialComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
    "lines": "384-387",
    "snippet": "YCPValue Y2SerialComponent::receiveFromSerial()\n{\n   return YCPCode (parser.parse ());  // set to the serial line in initializeConnection()\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2SerialComponent.h\"",
      "#include <time.h>     // nanosleep",
      "#include <sys/time.h> // timeval",
      "#include <linux/serial.h>",
      "#include <linux/types.h>",
      "#include <termios.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPCode",
          "args": [
            "parser.parse ()"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "YCPCode",
          "container": "YCPCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "103-107",
          "snippet": "YCPCode::YCPCode (bytecodeistream & str)\n    : YCPValue (YCPCode())\n{\n    (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPCode {\n  YCPCode::YCPCode (bytecodeistream & str)\n      : YCPValue (YCPCode())\n  {\n      (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.parse",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "484-562",
          "snippet": "int IniParser::parse()\n{\n    if (multiple_files)\n    {\n\tglob_t do_files;\n\tint len = files.size ();\n\tint flags = 0;\n\tfor (int i = 0;i<len;i++)\n\t{\n\t    glob (files[i].c_str (),flags, NULL, &do_files);\n\t    flags = GLOB_APPEND;\n\t}\n\tchar**f = do_files.gl_pathv;\n\tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n\t{\n\t    int section_index = -1;\n\t    string section_name = *f;\n\t    //FIXME: create function out of it.\n\t    // do we have name rewrite rules?\n\t    for (size_t j = 0; j < rewrites.size (); j++)\n\t\t{\n\t\t    RegexMatch m (rewrites[j].rx, section_name);\n\t\t    if (m)\n\t\t    {\n\t\t\tsection_index = j;\n\t\t\tsection_name = m[1];\n\t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    // do we know about the file?\n\t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n\t    if (ff == multi_files.end())\n\t    {\n\t\t// new file\n\t\tif (scanner_start (*f))\n\t\t    y2error (\"Cannot open %s.\", *f);\n\t\telse\n\t\t{\n\t\t    FileDescr fdsc (*f);\n\t\t    multi_files[*f] = fdsc;\n\t\t    inifile.initSection (section_name, \"\", -1, section_index);\n\t\t    parse_helper(inifile.getSection(section_name.c_str()));\n\t\t    scanner_stop();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif ((*ff).second.changed ())\n\t\t{\n\t\t    if (scanner_start (*f))\n\t\t\ty2error (\"Cannot open %s.\", *f);\n\t\t    else\n\t\t    {\n\t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n\t\t\tFileDescr fdsc (*f);\n\t\t\tmulti_files [*f] = fdsc;\n\t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n\t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n\t\t\tscanner_stop();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tif (scanner_start (file.c_str()))\n\t    {\n\t\ty2error (\"Can not open %s.\", file.c_str());\n\t\treturn -1;\n\t    }\n\tparse_helper(inifile);\n\tscanner_stop();\n\ttimestamp = getTimeStamp ();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse()\n  {\n      if (multiple_files)\n      {\n  \tglob_t do_files;\n  \tint len = files.size ();\n  \tint flags = 0;\n  \tfor (int i = 0;i<len;i++)\n  \t{\n  \t    glob (files[i].c_str (),flags, NULL, &do_files);\n  \t    flags = GLOB_APPEND;\n  \t}\n  \tchar**f = do_files.gl_pathv;\n  \tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n  \t{\n  \t    int section_index = -1;\n  \t    string section_name = *f;\n  \t    //FIXME: create function out of it.\n  \t    // do we have name rewrite rules?\n  \t    for (size_t j = 0; j < rewrites.size (); j++)\n  \t\t{\n  \t\t    RegexMatch m (rewrites[j].rx, section_name);\n  \t\t    if (m)\n  \t\t    {\n  \t\t\tsection_index = j;\n  \t\t\tsection_name = m[1];\n  \t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \n  \t    // do we know about the file?\n  \t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n  \t    if (ff == multi_files.end())\n  \t    {\n  \t\t// new file\n  \t\tif (scanner_start (*f))\n  \t\t    y2error (\"Cannot open %s.\", *f);\n  \t\telse\n  \t\t{\n  \t\t    FileDescr fdsc (*f);\n  \t\t    multi_files[*f] = fdsc;\n  \t\t    inifile.initSection (section_name, \"\", -1, section_index);\n  \t\t    parse_helper(inifile.getSection(section_name.c_str()));\n  \t\t    scanner_stop();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif ((*ff).second.changed ())\n  \t\t{\n  \t\t    if (scanner_start (*f))\n  \t\t\ty2error (\"Cannot open %s.\", *f);\n  \t\t    else\n  \t\t    {\n  \t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n  \t\t\tFileDescr fdsc (*f);\n  \t\t\tmulti_files [*f] = fdsc;\n  \t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n  \t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n  \t\t\tscanner_stop();\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n      else\n      {\n  \tif (scanner_start (file.c_str()))\n  \t    {\n  \t\ty2error (\"Can not open %s.\", file.c_str());\n  \t\treturn -1;\n  \t    }\n  \tparse_helper(inifile);\n  \tscanner_stop();\n  \ttimestamp = getTimeStamp ();\n      }\n      return 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  YCPValue Y2SerialComponent::receiveFromSerial()\n  {\n     return YCPCode (parser.parse ());  // set to the serial line in initializeConnection()\n  }\n}"
  },
  {
    "function_name": "sendToSerial",
    "container": "Y2SerialComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
    "lines": "377-382",
    "snippet": "void Y2SerialComponent::sendToSerial(const YCPValue& v)\n{\n    string s  = \"(\" + v->toString() + \")\\n\";    // store string in string variable ..\n    const char *cs = s.c_str();        \t\t// c_str is valid als long as s\n    write(fd_serial, cs, strlen(cs));\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2SerialComponent.h\"",
      "#include <time.h>     // nanosleep",
      "#include <sys/time.h> // timeval",
      "#include <linux/serial.h>",
      "#include <linux/types.h>",
      "#include <termios.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd_serial",
            "cs",
            "strlen(cs)"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "write_helper",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "1018-1077",
          "snippet": "int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n{\n    char * out_buffer;\n    string indent;\n    string indent2;\n    int readby = ini.getReadBy ();\n    if (!subindent.empty ())\n    {\n\tfor (int ii = 0; ii<depth - 1;ii++)\n\t    indent = indent + subindent;\n\tif (depth)\n\t    indent2 = indent + subindent;\n    }\n\n    if (ini.getComment ()[0])\n        of << ini.getComment();\n    if (readby>=0 && readby < (int)sections.size ())\n\t{\n\t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free (out_buffer);\n\t}\n    \n    IniIterator\n\tci = ini.getContainerBegin (),\n\tce = ini.getContainerEnd ();\n\n    for (;ci != ce; ++ci)\n\t{\n\t    if (ci->t () == SECTION)\n\t\t{\n\t\t    write_helper (ci->s (), of, depth + 1);\n\t\t    ci->s ().clean();\n\t\t}\n\t    else\n\t\t{\n\t\t    IniEntry&e = ci->e ();\n\t\t    if (e.getComment ()[0])\n\t\t\tof << e.getComment();\n\t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n\t\t\t// bnc#492859, a fixed buffer is too small\n\t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n\t\t\tof << indent2 << out_buffer << \"\\n\";\n\t\t\tfree(out_buffer);\n\t\t    }\n\t\t    e.clean();\n\t\t}\n\t}\n\n    if (ini.getEndComment ()[0])\n        of << indent << ini.getEndComment();\n    if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n\t{\n\t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free(out_buffer);\n\t}\n    ini.clean();\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n  {\n      char * out_buffer;\n      string indent;\n      string indent2;\n      int readby = ini.getReadBy ();\n      if (!subindent.empty ())\n      {\n  \tfor (int ii = 0; ii<depth - 1;ii++)\n  \t    indent = indent + subindent;\n  \tif (depth)\n  \t    indent2 = indent + subindent;\n      }\n  \n      if (ini.getComment ()[0])\n          of << ini.getComment();\n      if (readby>=0 && readby < (int)sections.size ())\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free (out_buffer);\n  \t}\n      \n      IniIterator\n  \tci = ini.getContainerBegin (),\n  \tce = ini.getContainerEnd ();\n  \n      for (;ci != ce; ++ci)\n  \t{\n  \t    if (ci->t () == SECTION)\n  \t\t{\n  \t\t    write_helper (ci->s (), of, depth + 1);\n  \t\t    ci->s ().clean();\n  \t\t}\n  \t    else\n  \t\t{\n  \t\t    IniEntry&e = ci->e ();\n  \t\t    if (e.getComment ()[0])\n  \t\t\tof << e.getComment();\n  \t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n  \t\t\t// bnc#492859, a fixed buffer is too small\n  \t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n  \t\t\tof << indent2 << out_buffer << \"\\n\";\n  \t\t\tfree(out_buffer);\n  \t\t    }\n  \t\t    e.clean();\n  \t\t}\n  \t}\n  \n      if (ini.getEndComment ()[0])\n          of << indent << ini.getEndComment();\n      if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free(out_buffer);\n  \t}\n      ini.clean();\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cs"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.c_str",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->toString",
          "args": [],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "76-88",
          "snippet": "string\nY2Namespace::toString () const\n{\n    if (m_table == 0)\n    {\n\treturn \"<empty>\";\n    }\n\n    SymbolTable* t = m_table;\n    string s = t->toString ();\n\n    return s + symbolsToString ();\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  string\n  Y2Namespace::toString () const\n  {\n      if (m_table == 0)\n      {\n  \treturn \"<empty>\";\n      }\n  \n      SymbolTable* t = m_table;\n      string s = t->toString ();\n  \n      return s + symbolsToString ();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  void Y2SerialComponent::sendToSerial(const YCPValue& v)\n  {\n      string s  = \"(\" + v->toString() + \")\\n\";    // store string in string variable ..\n      const char *cs = s.c_str();        \t\t// c_str is valid als long as s\n      write(fd_serial, cs, strlen(cs));\n  }\n}"
  },
  {
    "function_name": "initializeConnection",
    "container": "Y2SerialComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
    "lines": "310-374",
    "snippet": "bool Y2SerialComponent::initializeConnection()\n{\n   if (fd_serial >= 0) return true;             // already established\n   \n   int ret = open_tty();                        // logs for itself\n\n   if (ret >= 0) ret = setup_serial_device();   // logs for itself\n\n   if (ret >= 0) ret = make_raw();              // logs for itself\n\n   if (ret >= 0) ret = set_fixed_line_speed(baud_rate);   // logs for itself\n\n   if (ret >= 0)   // everything OK up to now\n   {\n       time_t begin_time = time(0);\n\n      int spaces_read = 0;\n      char space_buf[2*NUMSPACES];\n\n      memset(space_buf, ' ', 2 * NUMSPACES);\n\n      // to start communication we want to read NUMSPACES spaces in sequence\n      while (spaces_read < NUMSPACES)\n      {\n\t  time_t now = time(0);\n\t  if (timeout_seconds >= 0 && now - begin_time > timeout_seconds)\n\t  {\n\t      y2error (\"Couldn't establish serial connection for %d seconds. Aborting.\",\n\t\t    timeout_seconds);\n\t      close(fd_serial);\n\t      exit(13); // This exit code is used by general/YaST2. Try to find a better solution, if you want.\n\t  }\n\n\t char buf[2];\n      \n\t // first write one space so the other side gets\n\t // fullfilled its necessities\n\t write(fd_serial, space_buf, 1);\n\n\t // now wait for a space to be read\n\t // (the other side has the same behaviour)\n\t if (await_readable(TIMEOUT))\n\t {\n\t    read(fd_serial, buf, 1);\t            // read one byte\n\n\t    if (buf[0] == ' ') spaces_read++;       // was a space\n\t    else               spaces_read = 0;     // trash read --> reset\n\t }\n      }\n\n      // now that we've got our NUMSPACES spaces write 2 * NUMSPACES spaces to\n      // the other side to avoid syncing problems. the remote parser will kindly\n      // ignore them.\n      write(fd_serial, space_buf, 2 * NUMSPACES);\n\n      // now set our parser to the serial line to start communication\n      parser.setInput(fd_serial, device_name.c_str());\n\n      return true;\n   }\n\n   close_tty();   // cleanup, connection NOT established\n   \n   return false;\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2SerialComponent.h\"",
      "#include <time.h>     // nanosleep",
      "#include <sys/time.h> // timeval",
      "#include <linux/serial.h>",
      "#include <linux/types.h>",
      "#include <termios.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define TIMEOUT\t\t1000\t// microseconds",
      "#define NUMSPACES \t16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close_tty",
          "args": [],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "close_tty",
          "container": "Y2SerialComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
          "lines": "184-188",
          "snippet": "void Y2SerialComponent::close_tty()\n{\n   if (fd_serial >= 0) close(fd_serial);\n   fd_serial = -1;\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2SerialComponent.h\"",
            "#include <time.h>     // nanosleep",
            "#include <sys/time.h> // timeval",
            "#include <linux/serial.h>",
            "#include <linux/types.h>",
            "#include <termios.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  void Y2SerialComponent::close_tty()\n  {\n     if (fd_serial >= 0) close(fd_serial);\n     fd_serial = -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.setInput",
          "args": [
            "fd_serial",
            "device_name.c_str()"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "setInput",
          "container": "Parser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Parser.cc",
          "lines": "108-115",
          "snippet": "void\nParser::setInput(int fd, const char *filename)\n{\n    if (m_scanner) delete m_scanner;\n    m_scanner = new Scanner (fd, filename);\n    if (m_buffered) m_scanner->setBuffered ();\n    m_at_eof = false;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Parser.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Parser.h\"\n#include <stdlib.h>\n\nParser {\n  void\n  Parser::setInput(int fd, const char *filename)\n  {\n      if (m_scanner) delete m_scanner;\n      m_scanner = new Scanner (fd, filename);\n      if (m_buffered) m_scanner->setBuffered ();\n      m_at_eof = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_name.c_str",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd_serial",
            "space_buf",
            "2 * NUMSPACES"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "write_helper",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "1018-1077",
          "snippet": "int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n{\n    char * out_buffer;\n    string indent;\n    string indent2;\n    int readby = ini.getReadBy ();\n    if (!subindent.empty ())\n    {\n\tfor (int ii = 0; ii<depth - 1;ii++)\n\t    indent = indent + subindent;\n\tif (depth)\n\t    indent2 = indent + subindent;\n    }\n\n    if (ini.getComment ()[0])\n        of << ini.getComment();\n    if (readby>=0 && readby < (int)sections.size ())\n\t{\n\t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free (out_buffer);\n\t}\n    \n    IniIterator\n\tci = ini.getContainerBegin (),\n\tce = ini.getContainerEnd ();\n\n    for (;ci != ce; ++ci)\n\t{\n\t    if (ci->t () == SECTION)\n\t\t{\n\t\t    write_helper (ci->s (), of, depth + 1);\n\t\t    ci->s ().clean();\n\t\t}\n\t    else\n\t\t{\n\t\t    IniEntry&e = ci->e ();\n\t\t    if (e.getComment ()[0])\n\t\t\tof << e.getComment();\n\t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n\t\t\t// bnc#492859, a fixed buffer is too small\n\t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n\t\t\tof << indent2 << out_buffer << \"\\n\";\n\t\t\tfree(out_buffer);\n\t\t    }\n\t\t    e.clean();\n\t\t}\n\t}\n\n    if (ini.getEndComment ()[0])\n        of << indent << ini.getEndComment();\n    if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n\t{\n\t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free(out_buffer);\n\t}\n    ini.clean();\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n  {\n      char * out_buffer;\n      string indent;\n      string indent2;\n      int readby = ini.getReadBy ();\n      if (!subindent.empty ())\n      {\n  \tfor (int ii = 0; ii<depth - 1;ii++)\n  \t    indent = indent + subindent;\n  \tif (depth)\n  \t    indent2 = indent + subindent;\n      }\n  \n      if (ini.getComment ()[0])\n          of << ini.getComment();\n      if (readby>=0 && readby < (int)sections.size ())\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free (out_buffer);\n  \t}\n      \n      IniIterator\n  \tci = ini.getContainerBegin (),\n  \tce = ini.getContainerEnd ();\n  \n      for (;ci != ce; ++ci)\n  \t{\n  \t    if (ci->t () == SECTION)\n  \t\t{\n  \t\t    write_helper (ci->s (), of, depth + 1);\n  \t\t    ci->s ().clean();\n  \t\t}\n  \t    else\n  \t\t{\n  \t\t    IniEntry&e = ci->e ();\n  \t\t    if (e.getComment ()[0])\n  \t\t\tof << e.getComment();\n  \t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n  \t\t\t// bnc#492859, a fixed buffer is too small\n  \t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n  \t\t\tof << indent2 << out_buffer << \"\\n\";\n  \t\t\tfree(out_buffer);\n  \t\t    }\n  \t\t    e.clean();\n  \t\t}\n  \t}\n  \n      if (ini.getEndComment ()[0])\n          of << indent << ini.getEndComment();\n      if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free(out_buffer);\n  \t}\n      ini.clean();\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd_serial",
            "buf",
            "1"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "read_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2crypt.cc",
          "lines": "25-50",
          "snippet": "static int\nread_loop (int fd, char* buffer, int count)\n{\n    int offset, block;\n\n    offset = 0;\n    while (count > 0)\n    {\n\tblock = read (fd, &buffer[offset], count);\n\n\tif (block < 0)\n\t{\n\t    if (errno == EINTR)\n\t\tcontinue;\n\t    return block;\n\t}\n\n\tif (!block)\n\t    return offset;\n\n\toffset += block;\n\tcount -= block;\n    }\n\n    return offset;\n}",
          "includes": [
            "#include \"y2crypt.h\"",
            "#include \"y2log.h\"",
            "#include <xcrypt.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2crypt.h\"\n#include \"y2log.h\"\n#include <xcrypt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int\nread_loop (int fd, char* buffer, int count)\n{\n    int offset, block;\n\n    offset = 0;\n    while (count > 0)\n    {\n\tblock = read (fd, &buffer[offset], count);\n\n\tif (block < 0)\n\t{\n\t    if (errno == EINTR)\n\t\tcontinue;\n\t    return block;\n\t}\n\n\tif (!block)\n\t    return offset;\n\n\toffset += block;\n\tcount -= block;\n    }\n\n    return offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "await_readable",
          "args": [
            "TIMEOUT"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "await_readable",
          "container": "Y2SerialComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
          "lines": "297-307",
          "snippet": "bool Y2SerialComponent::await_readable(long timeout)\n{\n    fd_set set;\n    FD_ZERO(&set);\n    FD_SET(fd_serial, &set);\n\n    struct timeval tv;\n    tv.tv_sec = timeout / 1000000;\n    tv.tv_usec = timeout % 1000000;\n    return (select(fd_serial+1, &set, NULL, NULL, &tv) > 0);\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2SerialComponent.h\"",
            "#include <time.h>     // nanosleep",
            "#include <sys/time.h> // timeval",
            "#include <linux/serial.h>",
            "#include <linux/types.h>",
            "#include <termios.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  bool Y2SerialComponent::await_readable(long timeout)\n  {\n      fd_set set;\n      FD_ZERO(&set);\n      FD_SET(fd_serial, &set);\n  \n      struct timeval tv;\n      tv.tv_sec = timeout / 1000000;\n      tv.tv_usec = timeout % 1000000;\n      return (select(fd_serial+1, &set, NULL, NULL, &tv) > 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "13"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd_serial"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Couldn't establish serial connection for %d seconds. Aborting.\"",
            "timeout_seconds"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "0"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "space_buf",
            "' '",
            "2 * NUMSPACES"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "0"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fixed_line_speed",
          "args": [
            "baud_rate"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "set_fixed_line_speed",
          "container": "Y2SerialComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
          "lines": "244-294",
          "snippet": "int Y2SerialComponent::set_fixed_line_speed(long speed) // returns 0 on success\n{\n    static struct { int mask; long speed; } \n    a_speed[] =\n    {\n\t{ B50,         50L }, { B75,       75L }, { B110,     110L }, { B134,     134L },\n\t{ B150,       150L }, { B200,     200L }, { B300,     300L }, { B600,     600L },\n\t{ B1200,     1200L }, { B1800,   1800L }, { B2400,   2400L }, { B4800,   4800L },\n\t{ B9600,     9600L }, { B19200, 19200L }, { B38400, 38400L }, { B57600, 57600L },\n\t{ B115200, 115200L }, { 0,         -1L }\n    };\n\n    for (int i=0; a_speed[i].speed >= 0L; i++)\n    {\n\tif (a_speed[i].speed == speed)\n\t{\n\t    struct termios tty;\n\t    int ret = tcgetattr(fd_serial, &tty);   // get attributes\n\t    \n\t    if (ret >= 0)\n\t    {\n\t\tcfsetispeed(&tty, a_speed[i].mask);\n\t\tcfsetospeed(&tty, a_speed[i].mask);\n\t\t\n\t\tret = tcsetattr(fd_serial, 0 , &tty);   // set attributes\n\n\t\tif (ret < 0)\n\t\t{\n\t\t   y2error (\"Couldn't set speed to %ld baud for: %s\",\n\t\t\t speed, device_name.c_str());\n\t\t}\n\t\treturn ret;\n\t    }\n\t    else\n\t    {\n\t       y2error (\"Couldn't get attributes for: %s\", device_name.c_str());\n\t       return ret;\n\t    }\n\t}\n    }\n\n    y2error (\"No fixed standard line speed of %ld baud supported by %s.\",\n\t  speed, device_name.c_str());\n    \n    y2error (\"Allowed speeds are:\");\n    \n    for (int i=0; a_speed[i].speed >= 0; i++)\n       y2error (\"Baud: %ld\", a_speed[i].speed);\n    \n    return -1; // No such fixed speed\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2SerialComponent.h\"",
            "#include <time.h>     // nanosleep",
            "#include <sys/time.h> // timeval",
            "#include <linux/serial.h>",
            "#include <linux/types.h>",
            "#include <termios.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  int Y2SerialComponent::set_fixed_line_speed(long speed) // returns 0 on success\n  {\n      static struct { int mask; long speed; } \n      a_speed[] =\n      {\n  \t{ B50,         50L }, { B75,       75L }, { B110,     110L }, { B134,     134L },\n  \t{ B150,       150L }, { B200,     200L }, { B300,     300L }, { B600,     600L },\n  \t{ B1200,     1200L }, { B1800,   1800L }, { B2400,   2400L }, { B4800,   4800L },\n  \t{ B9600,     9600L }, { B19200, 19200L }, { B38400, 38400L }, { B57600, 57600L },\n  \t{ B115200, 115200L }, { 0,         -1L }\n      };\n  \n      for (int i=0; a_speed[i].speed >= 0L; i++)\n      {\n  \tif (a_speed[i].speed == speed)\n  \t{\n  \t    struct termios tty;\n  \t    int ret = tcgetattr(fd_serial, &tty);   // get attributes\n  \t    \n  \t    if (ret >= 0)\n  \t    {\n  \t\tcfsetispeed(&tty, a_speed[i].mask);\n  \t\tcfsetospeed(&tty, a_speed[i].mask);\n  \t\t\n  \t\tret = tcsetattr(fd_serial, 0 , &tty);   // set attributes\n  \n  \t\tif (ret < 0)\n  \t\t{\n  \t\t   y2error (\"Couldn't set speed to %ld baud for: %s\",\n  \t\t\t speed, device_name.c_str());\n  \t\t}\n  \t\treturn ret;\n  \t    }\n  \t    else\n  \t    {\n  \t       y2error (\"Couldn't get attributes for: %s\", device_name.c_str());\n  \t       return ret;\n  \t    }\n  \t}\n      }\n  \n      y2error (\"No fixed standard line speed of %ld baud supported by %s.\",\n  \t  speed, device_name.c_str());\n      \n      y2error (\"Allowed speeds are:\");\n      \n      for (int i=0; a_speed[i].speed >= 0; i++)\n         y2error (\"Baud: %ld\", a_speed[i].speed);\n      \n      return -1; // No such fixed speed\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_raw",
          "args": [],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "make_raw",
          "container": "Y2SerialComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
          "lines": "217-241",
          "snippet": "int Y2SerialComponent::make_raw()\n{\n    struct termios tty;\n    int ret = tcgetattr(fd_serial, &tty);   // get attributes\n\n    if (ret >= 0)\n    {\n       cfmakeraw(&tty);\n       tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8; // 8 data bits\n       tty.c_cflag &= ~CSTOPB;                     // only one stop bit.\n       tty.c_cflag &= ~PARENB;                     // no parenty generation / checking\n       \n       ret =  tcsetattr(fd_serial, 0 , &tty);      // set attributes\n       \n       if (ret < 0)\n       {\n\t  y2error (\"Couldn't set raw mode for: %s\", device_name.c_str());\n       }\n       return ret;\n    }\n\n    y2error (\"Couldn't get attributes for: %s\", device_name.c_str());\n\n    return ret;\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2SerialComponent.h\"",
            "#include <time.h>     // nanosleep",
            "#include <sys/time.h> // timeval",
            "#include <linux/serial.h>",
            "#include <linux/types.h>",
            "#include <termios.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  int Y2SerialComponent::make_raw()\n  {\n      struct termios tty;\n      int ret = tcgetattr(fd_serial, &tty);   // get attributes\n  \n      if (ret >= 0)\n      {\n         cfmakeraw(&tty);\n         tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8; // 8 data bits\n         tty.c_cflag &= ~CSTOPB;                     // only one stop bit.\n         tty.c_cflag &= ~PARENB;                     // no parenty generation / checking\n         \n         ret =  tcsetattr(fd_serial, 0 , &tty);      // set attributes\n         \n         if (ret < 0)\n         {\n  \t  y2error (\"Couldn't set raw mode for: %s\", device_name.c_str());\n         }\n         return ret;\n      }\n  \n      y2error (\"Couldn't get attributes for: %s\", device_name.c_str());\n  \n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_serial_device",
          "args": [],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "setup_serial_device",
          "container": "Y2SerialComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
          "lines": "191-214",
          "snippet": "int Y2SerialComponent::setup_serial_device()\n{\n    struct serial_struct info;\n    int ret = ioctl(fd_serial, TIOCGSERIAL, &info);   // get serial info\n    \n    if (ret >= 0)\n    {\n       info.flags |=  ASYNC_CTS_FLOW;\t// set RTS/CTS flow control\n       info.custom_divisor = 0;\t        // clear custom divisor\n       info.flags &= ~ASYNC_SPD_MASK;   // clear custom divisor\n\n       ret = ioctl(fd_serial, TIOCSSERIAL, &info);   // set serial info\n\n       if (ret < 0)\n       {\n\t  y2error (\"Couldn't set flow control for: %s\", device_name.c_str());\n       }\n       return ret;\n    }\n\n    y2error (\"Couldn't get serial info for: %s\", device_name.c_str());\n\n    return ret;\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2SerialComponent.h\"",
            "#include <time.h>     // nanosleep",
            "#include <sys/time.h> // timeval",
            "#include <linux/serial.h>",
            "#include <linux/types.h>",
            "#include <termios.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  int Y2SerialComponent::setup_serial_device()\n  {\n      struct serial_struct info;\n      int ret = ioctl(fd_serial, TIOCGSERIAL, &info);   // get serial info\n      \n      if (ret >= 0)\n      {\n         info.flags |=  ASYNC_CTS_FLOW;\t// set RTS/CTS flow control\n         info.custom_divisor = 0;\t        // clear custom divisor\n         info.flags &= ~ASYNC_SPD_MASK;   // clear custom divisor\n  \n         ret = ioctl(fd_serial, TIOCSSERIAL, &info);   // set serial info\n  \n         if (ret < 0)\n         {\n  \t  y2error (\"Couldn't set flow control for: %s\", device_name.c_str());\n         }\n         return ret;\n      }\n  \n      y2error (\"Couldn't get serial info for: %s\", device_name.c_str());\n  \n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_tty",
          "args": [],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "open_tty",
          "container": "Y2SerialComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
          "lines": "171-181",
          "snippet": "int Y2SerialComponent::open_tty()\n{\n    fd_serial = open(device_name.c_str(), O_RDWR | O_NOCTTY);\n    \n    if (fd_serial < 0)\n    {\n       y2error (\"Couldn't open device: %s\", device_name.c_str());\n    }\n    \n    return fd_serial;   // success?\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2SerialComponent.h\"",
            "#include <time.h>     // nanosleep",
            "#include <sys/time.h> // timeval",
            "#include <linux/serial.h>",
            "#include <linux/types.h>",
            "#include <termios.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  int Y2SerialComponent::open_tty()\n  {\n      fd_serial = open(device_name.c_str(), O_RDWR | O_NOCTTY);\n      \n      if (fd_serial < 0)\n      {\n         y2error (\"Couldn't open device: %s\", device_name.c_str());\n      }\n      \n      return fd_serial;   // success?\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\n#define TIMEOUT\t\t1000\t// microseconds\n#define NUMSPACES \t16\n\nY2SerialComponent {\n  bool Y2SerialComponent::initializeConnection()\n  {\n     if (fd_serial >= 0) return true;             // already established\n     \n     int ret = open_tty();                        // logs for itself\n  \n     if (ret >= 0) ret = setup_serial_device();   // logs for itself\n  \n     if (ret >= 0) ret = make_raw();              // logs for itself\n  \n     if (ret >= 0) ret = set_fixed_line_speed(baud_rate);   // logs for itself\n  \n     if (ret >= 0)   // everything OK up to now\n     {\n         time_t begin_time = time(0);\n  \n        int spaces_read = 0;\n        char space_buf[2*NUMSPACES];\n  \n        memset(space_buf, ' ', 2 * NUMSPACES);\n  \n        // to start communication we want to read NUMSPACES spaces in sequence\n        while (spaces_read < NUMSPACES)\n        {\n  \t  time_t now = time(0);\n  \t  if (timeout_seconds >= 0 && now - begin_time > timeout_seconds)\n  \t  {\n  \t      y2error (\"Couldn't establish serial connection for %d seconds. Aborting.\",\n  \t\t    timeout_seconds);\n  \t      close(fd_serial);\n  \t      exit(13); // This exit code is used by general/YaST2. Try to find a better solution, if you want.\n  \t  }\n  \n  \t char buf[2];\n        \n  \t // first write one space so the other side gets\n  \t // fullfilled its necessities\n  \t write(fd_serial, space_buf, 1);\n  \n  \t // now wait for a space to be read\n  \t // (the other side has the same behaviour)\n  \t if (await_readable(TIMEOUT))\n  \t {\n  \t    read(fd_serial, buf, 1);\t            // read one byte\n  \n  \t    if (buf[0] == ' ') spaces_read++;       // was a space\n  \t    else               spaces_read = 0;     // trash read --> reset\n  \t }\n        }\n  \n        // now that we've got our NUMSPACES spaces write 2 * NUMSPACES spaces to\n        // the other side to avoid syncing problems. the remote parser will kindly\n        // ignore them.\n        write(fd_serial, space_buf, 2 * NUMSPACES);\n  \n        // now set our parser to the serial line to start communication\n        parser.setInput(fd_serial, device_name.c_str());\n  \n        return true;\n     }\n  \n     close_tty();   // cleanup, connection NOT established\n     \n     return false;\n  }\n}"
  },
  {
    "function_name": "await_readable",
    "container": "Y2SerialComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
    "lines": "297-307",
    "snippet": "bool Y2SerialComponent::await_readable(long timeout)\n{\n    fd_set set;\n    FD_ZERO(&set);\n    FD_SET(fd_serial, &set);\n\n    struct timeval tv;\n    tv.tv_sec = timeout / 1000000;\n    tv.tv_usec = timeout % 1000000;\n    return (select(fd_serial+1, &set, NULL, NULL, &tv) > 0);\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2SerialComponent.h\"",
      "#include <time.h>     // nanosleep",
      "#include <sys/time.h> // timeval",
      "#include <linux/serial.h>",
      "#include <linux/types.h>",
      "#include <termios.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "select",
          "args": [
            "fd_serial+1",
            "&set",
            "NULL",
            "NULL",
            "&tv"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "fd_serial",
            "&set"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&set"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  bool Y2SerialComponent::await_readable(long timeout)\n  {\n      fd_set set;\n      FD_ZERO(&set);\n      FD_SET(fd_serial, &set);\n  \n      struct timeval tv;\n      tv.tv_sec = timeout / 1000000;\n      tv.tv_usec = timeout % 1000000;\n      return (select(fd_serial+1, &set, NULL, NULL, &tv) > 0);\n  }\n}"
  },
  {
    "function_name": "set_fixed_line_speed",
    "container": "Y2SerialComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
    "lines": "244-294",
    "snippet": "int Y2SerialComponent::set_fixed_line_speed(long speed) // returns 0 on success\n{\n    static struct { int mask; long speed; } \n    a_speed[] =\n    {\n\t{ B50,         50L }, { B75,       75L }, { B110,     110L }, { B134,     134L },\n\t{ B150,       150L }, { B200,     200L }, { B300,     300L }, { B600,     600L },\n\t{ B1200,     1200L }, { B1800,   1800L }, { B2400,   2400L }, { B4800,   4800L },\n\t{ B9600,     9600L }, { B19200, 19200L }, { B38400, 38400L }, { B57600, 57600L },\n\t{ B115200, 115200L }, { 0,         -1L }\n    };\n\n    for (int i=0; a_speed[i].speed >= 0L; i++)\n    {\n\tif (a_speed[i].speed == speed)\n\t{\n\t    struct termios tty;\n\t    int ret = tcgetattr(fd_serial, &tty);   // get attributes\n\t    \n\t    if (ret >= 0)\n\t    {\n\t\tcfsetispeed(&tty, a_speed[i].mask);\n\t\tcfsetospeed(&tty, a_speed[i].mask);\n\t\t\n\t\tret = tcsetattr(fd_serial, 0 , &tty);   // set attributes\n\n\t\tif (ret < 0)\n\t\t{\n\t\t   y2error (\"Couldn't set speed to %ld baud for: %s\",\n\t\t\t speed, device_name.c_str());\n\t\t}\n\t\treturn ret;\n\t    }\n\t    else\n\t    {\n\t       y2error (\"Couldn't get attributes for: %s\", device_name.c_str());\n\t       return ret;\n\t    }\n\t}\n    }\n\n    y2error (\"No fixed standard line speed of %ld baud supported by %s.\",\n\t  speed, device_name.c_str());\n    \n    y2error (\"Allowed speeds are:\");\n    \n    for (int i=0; a_speed[i].speed >= 0; i++)\n       y2error (\"Baud: %ld\", a_speed[i].speed);\n    \n    return -1; // No such fixed speed\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2SerialComponent.h\"",
      "#include <time.h>     // nanosleep",
      "#include <sys/time.h> // timeval",
      "#include <linux/serial.h>",
      "#include <linux/types.h>",
      "#include <termios.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Baud: %ld\"",
            "a_speed[i].speed"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Allowed speeds are:\""
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"No fixed standard line speed of %ld baud supported by %s.\"",
            "speed",
            "device_name.c_str()"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_name.c_str",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Couldn't get attributes for: %s\"",
            "device_name.c_str()"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_name.c_str",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Couldn't set speed to %ld baud for: %s\"",
            "speed",
            "device_name.c_str()"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_name.c_str",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "fd_serial",
            "0",
            "&tty"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cfsetospeed",
          "args": [
            "&tty",
            "a_speed[i].mask"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cfsetispeed",
          "args": [
            "&tty",
            "a_speed[i].mask"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcgetattr",
          "args": [
            "fd_serial",
            "&tty"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  int Y2SerialComponent::set_fixed_line_speed(long speed) // returns 0 on success\n  {\n      static struct { int mask; long speed; } \n      a_speed[] =\n      {\n  \t{ B50,         50L }, { B75,       75L }, { B110,     110L }, { B134,     134L },\n  \t{ B150,       150L }, { B200,     200L }, { B300,     300L }, { B600,     600L },\n  \t{ B1200,     1200L }, { B1800,   1800L }, { B2400,   2400L }, { B4800,   4800L },\n  \t{ B9600,     9600L }, { B19200, 19200L }, { B38400, 38400L }, { B57600, 57600L },\n  \t{ B115200, 115200L }, { 0,         -1L }\n      };\n  \n      for (int i=0; a_speed[i].speed >= 0L; i++)\n      {\n  \tif (a_speed[i].speed == speed)\n  \t{\n  \t    struct termios tty;\n  \t    int ret = tcgetattr(fd_serial, &tty);   // get attributes\n  \t    \n  \t    if (ret >= 0)\n  \t    {\n  \t\tcfsetispeed(&tty, a_speed[i].mask);\n  \t\tcfsetospeed(&tty, a_speed[i].mask);\n  \t\t\n  \t\tret = tcsetattr(fd_serial, 0 , &tty);   // set attributes\n  \n  \t\tif (ret < 0)\n  \t\t{\n  \t\t   y2error (\"Couldn't set speed to %ld baud for: %s\",\n  \t\t\t speed, device_name.c_str());\n  \t\t}\n  \t\treturn ret;\n  \t    }\n  \t    else\n  \t    {\n  \t       y2error (\"Couldn't get attributes for: %s\", device_name.c_str());\n  \t       return ret;\n  \t    }\n  \t}\n      }\n  \n      y2error (\"No fixed standard line speed of %ld baud supported by %s.\",\n  \t  speed, device_name.c_str());\n      \n      y2error (\"Allowed speeds are:\");\n      \n      for (int i=0; a_speed[i].speed >= 0; i++)\n         y2error (\"Baud: %ld\", a_speed[i].speed);\n      \n      return -1; // No such fixed speed\n  }\n}"
  },
  {
    "function_name": "make_raw",
    "container": "Y2SerialComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
    "lines": "217-241",
    "snippet": "int Y2SerialComponent::make_raw()\n{\n    struct termios tty;\n    int ret = tcgetattr(fd_serial, &tty);   // get attributes\n\n    if (ret >= 0)\n    {\n       cfmakeraw(&tty);\n       tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8; // 8 data bits\n       tty.c_cflag &= ~CSTOPB;                     // only one stop bit.\n       tty.c_cflag &= ~PARENB;                     // no parenty generation / checking\n       \n       ret =  tcsetattr(fd_serial, 0 , &tty);      // set attributes\n       \n       if (ret < 0)\n       {\n\t  y2error (\"Couldn't set raw mode for: %s\", device_name.c_str());\n       }\n       return ret;\n    }\n\n    y2error (\"Couldn't get attributes for: %s\", device_name.c_str());\n\n    return ret;\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2SerialComponent.h\"",
      "#include <time.h>     // nanosleep",
      "#include <sys/time.h> // timeval",
      "#include <linux/serial.h>",
      "#include <linux/types.h>",
      "#include <termios.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Couldn't get attributes for: %s\"",
            "device_name.c_str()"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_name.c_str",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Couldn't set raw mode for: %s\"",
            "device_name.c_str()"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_name.c_str",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "fd_serial",
            "0",
            "&tty"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cfmakeraw",
          "args": [
            "&tty"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcgetattr",
          "args": [
            "fd_serial",
            "&tty"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  int Y2SerialComponent::make_raw()\n  {\n      struct termios tty;\n      int ret = tcgetattr(fd_serial, &tty);   // get attributes\n  \n      if (ret >= 0)\n      {\n         cfmakeraw(&tty);\n         tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8; // 8 data bits\n         tty.c_cflag &= ~CSTOPB;                     // only one stop bit.\n         tty.c_cflag &= ~PARENB;                     // no parenty generation / checking\n         \n         ret =  tcsetattr(fd_serial, 0 , &tty);      // set attributes\n         \n         if (ret < 0)\n         {\n  \t  y2error (\"Couldn't set raw mode for: %s\", device_name.c_str());\n         }\n         return ret;\n      }\n  \n      y2error (\"Couldn't get attributes for: %s\", device_name.c_str());\n  \n      return ret;\n  }\n}"
  },
  {
    "function_name": "setup_serial_device",
    "container": "Y2SerialComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
    "lines": "191-214",
    "snippet": "int Y2SerialComponent::setup_serial_device()\n{\n    struct serial_struct info;\n    int ret = ioctl(fd_serial, TIOCGSERIAL, &info);   // get serial info\n    \n    if (ret >= 0)\n    {\n       info.flags |=  ASYNC_CTS_FLOW;\t// set RTS/CTS flow control\n       info.custom_divisor = 0;\t        // clear custom divisor\n       info.flags &= ~ASYNC_SPD_MASK;   // clear custom divisor\n\n       ret = ioctl(fd_serial, TIOCSSERIAL, &info);   // set serial info\n\n       if (ret < 0)\n       {\n\t  y2error (\"Couldn't set flow control for: %s\", device_name.c_str());\n       }\n       return ret;\n    }\n\n    y2error (\"Couldn't get serial info for: %s\", device_name.c_str());\n\n    return ret;\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2SerialComponent.h\"",
      "#include <time.h>     // nanosleep",
      "#include <sys/time.h> // timeval",
      "#include <linux/serial.h>",
      "#include <linux/types.h>",
      "#include <termios.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Couldn't get serial info for: %s\"",
            "device_name.c_str()"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_name.c_str",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Couldn't set flow control for: %s\"",
            "device_name.c_str()"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_name.c_str",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd_serial",
            "TIOCSSERIAL",
            "&info"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd_serial",
            "TIOCGSERIAL",
            "&info"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  int Y2SerialComponent::setup_serial_device()\n  {\n      struct serial_struct info;\n      int ret = ioctl(fd_serial, TIOCGSERIAL, &info);   // get serial info\n      \n      if (ret >= 0)\n      {\n         info.flags |=  ASYNC_CTS_FLOW;\t// set RTS/CTS flow control\n         info.custom_divisor = 0;\t        // clear custom divisor\n         info.flags &= ~ASYNC_SPD_MASK;   // clear custom divisor\n  \n         ret = ioctl(fd_serial, TIOCSSERIAL, &info);   // set serial info\n  \n         if (ret < 0)\n         {\n  \t  y2error (\"Couldn't set flow control for: %s\", device_name.c_str());\n         }\n         return ret;\n      }\n  \n      y2error (\"Couldn't get serial info for: %s\", device_name.c_str());\n  \n      return ret;\n  }\n}"
  },
  {
    "function_name": "close_tty",
    "container": "Y2SerialComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
    "lines": "184-188",
    "snippet": "void Y2SerialComponent::close_tty()\n{\n   if (fd_serial >= 0) close(fd_serial);\n   fd_serial = -1;\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2SerialComponent.h\"",
      "#include <time.h>     // nanosleep",
      "#include <sys/time.h> // timeval",
      "#include <linux/serial.h>",
      "#include <linux/types.h>",
      "#include <termios.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd_serial"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  void Y2SerialComponent::close_tty()\n  {\n     if (fd_serial >= 0) close(fd_serial);\n     fd_serial = -1;\n  }\n}"
  },
  {
    "function_name": "open_tty",
    "container": "Y2SerialComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
    "lines": "171-181",
    "snippet": "int Y2SerialComponent::open_tty()\n{\n    fd_serial = open(device_name.c_str(), O_RDWR | O_NOCTTY);\n    \n    if (fd_serial < 0)\n    {\n       y2error (\"Couldn't open device: %s\", device_name.c_str());\n    }\n    \n    return fd_serial;   // success?\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2SerialComponent.h\"",
      "#include <time.h>     // nanosleep",
      "#include <sys/time.h> // timeval",
      "#include <linux/serial.h>",
      "#include <linux/types.h>",
      "#include <termios.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Couldn't open device: %s\"",
            "device_name.c_str()"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_name.c_str",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "device_name.c_str()",
            "O_RDWR | O_NOCTTY"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_name.c_str",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  int Y2SerialComponent::open_tty()\n  {\n      fd_serial = open(device_name.c_str(), O_RDWR | O_NOCTTY);\n      \n      if (fd_serial < 0)\n      {\n         y2error (\"Couldn't open device: %s\", device_name.c_str());\n      }\n      \n      return fd_serial;   // success?\n  }\n}"
  },
  {
    "function_name": "doActualWork",
    "container": "Y2SerialComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
    "lines": "138-168",
    "snippet": "YCPValue Y2SerialComponent::doActualWork(const YCPList& arglist, Y2Component *user_interface)\n{\n   if (!initializeConnection()) return YCPVoid();\n    \n   // We do NOT send the arglist to our partner on the other side!\n   // The YaST2 serial protocol defines, that the client is set up\n   // by the remote side and is given its arguments also there.\n   // The client arguments are just ignored here!\n\n   if (arglist->size() > 0)\n   {\n      y2warning (\"The %ld arguments are ignored. Remote side provides client arguments\",\n\t    (long)arglist->size());\n   }\n   \n   YCPValue value = YCPNull();\n\n   while (!(value = receiveFromSerial()).isNull())\n   {\n      if (value->isTerm() \n\t  && value->asTerm()->size() == 1 \n\t  && value->asTerm()->name ()==\"result\")\n      {\n\t close_tty();\n\t return value; \n      }\n      sendToSerial(user_interface->evaluate(value));\n   }\n   y2warning (\"Communication ended prior to result() message\");\n   return YCPVoid();\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2SerialComponent.h\"",
      "#include <time.h>     // nanosleep",
      "#include <sys/time.h> // timeval",
      "#include <linux/serial.h>",
      "#include <linux/types.h>",
      "#include <termios.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"Communication ended prior to result() message\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendToSerial",
          "args": [
            "user_interface->evaluate(value)"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "sendToSerial",
          "container": "Y2SerialComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
          "lines": "377-382",
          "snippet": "void Y2SerialComponent::sendToSerial(const YCPValue& v)\n{\n    string s  = \"(\" + v->toString() + \")\\n\";    // store string in string variable ..\n    const char *cs = s.c_str();        \t\t// c_str is valid als long as s\n    write(fd_serial, cs, strlen(cs));\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2SerialComponent.h\"",
            "#include <time.h>     // nanosleep",
            "#include <sys/time.h> // timeval",
            "#include <linux/serial.h>",
            "#include <linux/types.h>",
            "#include <termios.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  void Y2SerialComponent::sendToSerial(const YCPValue& v)\n  {\n      string s  = \"(\" + v->toString() + \")\\n\";    // store string in string variable ..\n      const char *cs = s.c_str();        \t\t// c_str is valid als long as s\n      write(fd_serial, cs, strlen(cs));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_interface->evaluate",
          "args": [
            "value"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2SerialComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
          "lines": "75-93",
          "snippet": "YCPValue Y2SerialComponent::evaluate(const YCPValue& command)\n{\n   if (fd_serial < 0)   // not yet initialized\n   { \n      if (! initializeConnection()) return YCPVoid();\n   }\n\n   sendToSerial(command);\n\n   YCPValue ret = receiveFromSerial();\n\n   if (ret.isNull())\n   {\n      y2error (\"Couldn't get value from serial: %s\", device_name.c_str());\n      return YCPVoid();\n   }\n\n   return ret;\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2SerialComponent.h\"",
            "#include <time.h>     // nanosleep",
            "#include <sys/time.h> // timeval",
            "#include <linux/serial.h>",
            "#include <linux/types.h>",
            "#include <termios.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  YCPValue Y2SerialComponent::evaluate(const YCPValue& command)\n  {\n     if (fd_serial < 0)   // not yet initialized\n     { \n        if (! initializeConnection()) return YCPVoid();\n     }\n  \n     sendToSerial(command);\n  \n     YCPValue ret = receiveFromSerial();\n  \n     if (ret.isNull())\n     {\n        y2error (\"Couldn't get value from serial: %s\", device_name.c_str());\n        return YCPVoid();\n     }\n  \n     return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close_tty",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "close_tty",
          "container": "Y2SerialComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
          "lines": "184-188",
          "snippet": "void Y2SerialComponent::close_tty()\n{\n   if (fd_serial >= 0) close(fd_serial);\n   fd_serial = -1;\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2SerialComponent.h\"",
            "#include <time.h>     // nanosleep",
            "#include <sys/time.h> // timeval",
            "#include <linux/serial.h>",
            "#include <linux/types.h>",
            "#include <termios.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  void Y2SerialComponent::close_tty()\n  {\n     if (fd_serial >= 0) close(fd_serial);\n     fd_serial = -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asTerm",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->isTerm",
          "args": [],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "isTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "70-70",
          "snippet": "bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiveFromSerial",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "receiveFromSerial",
          "container": "Y2SerialComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
          "lines": "384-387",
          "snippet": "YCPValue Y2SerialComponent::receiveFromSerial()\n{\n   return YCPCode (parser.parse ());  // set to the serial line in initializeConnection()\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2SerialComponent.h\"",
            "#include <time.h>     // nanosleep",
            "#include <sys/time.h> // timeval",
            "#include <linux/serial.h>",
            "#include <linux/types.h>",
            "#include <termios.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  YCPValue Y2SerialComponent::receiveFromSerial()\n  {\n     return YCPCode (parser.parse ());  // set to the serial line in initializeConnection()\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"The %ld arguments are ignored. Remote side provides client arguments\"",
            "(long)arglist->size()"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arglist->size",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "initializeConnection",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "initializeConnection",
          "container": "Y2SerialComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
          "lines": "310-374",
          "snippet": "bool Y2SerialComponent::initializeConnection()\n{\n   if (fd_serial >= 0) return true;             // already established\n   \n   int ret = open_tty();                        // logs for itself\n\n   if (ret >= 0) ret = setup_serial_device();   // logs for itself\n\n   if (ret >= 0) ret = make_raw();              // logs for itself\n\n   if (ret >= 0) ret = set_fixed_line_speed(baud_rate);   // logs for itself\n\n   if (ret >= 0)   // everything OK up to now\n   {\n       time_t begin_time = time(0);\n\n      int spaces_read = 0;\n      char space_buf[2*NUMSPACES];\n\n      memset(space_buf, ' ', 2 * NUMSPACES);\n\n      // to start communication we want to read NUMSPACES spaces in sequence\n      while (spaces_read < NUMSPACES)\n      {\n\t  time_t now = time(0);\n\t  if (timeout_seconds >= 0 && now - begin_time > timeout_seconds)\n\t  {\n\t      y2error (\"Couldn't establish serial connection for %d seconds. Aborting.\",\n\t\t    timeout_seconds);\n\t      close(fd_serial);\n\t      exit(13); // This exit code is used by general/YaST2. Try to find a better solution, if you want.\n\t  }\n\n\t char buf[2];\n      \n\t // first write one space so the other side gets\n\t // fullfilled its necessities\n\t write(fd_serial, space_buf, 1);\n\n\t // now wait for a space to be read\n\t // (the other side has the same behaviour)\n\t if (await_readable(TIMEOUT))\n\t {\n\t    read(fd_serial, buf, 1);\t            // read one byte\n\n\t    if (buf[0] == ' ') spaces_read++;       // was a space\n\t    else               spaces_read = 0;     // trash read --> reset\n\t }\n      }\n\n      // now that we've got our NUMSPACES spaces write 2 * NUMSPACES spaces to\n      // the other side to avoid syncing problems. the remote parser will kindly\n      // ignore them.\n      write(fd_serial, space_buf, 2 * NUMSPACES);\n\n      // now set our parser to the serial line to start communication\n      parser.setInput(fd_serial, device_name.c_str());\n\n      return true;\n   }\n\n   close_tty();   // cleanup, connection NOT established\n   \n   return false;\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2SerialComponent.h\"",
            "#include <time.h>     // nanosleep",
            "#include <sys/time.h> // timeval",
            "#include <linux/serial.h>",
            "#include <linux/types.h>",
            "#include <termios.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define TIMEOUT\t\t1000\t// microseconds",
            "#define NUMSPACES \t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\n#define TIMEOUT\t\t1000\t// microseconds\n#define NUMSPACES \t16\n\nY2SerialComponent {\n  bool Y2SerialComponent::initializeConnection()\n  {\n     if (fd_serial >= 0) return true;             // already established\n     \n     int ret = open_tty();                        // logs for itself\n  \n     if (ret >= 0) ret = setup_serial_device();   // logs for itself\n  \n     if (ret >= 0) ret = make_raw();              // logs for itself\n  \n     if (ret >= 0) ret = set_fixed_line_speed(baud_rate);   // logs for itself\n  \n     if (ret >= 0)   // everything OK up to now\n     {\n         time_t begin_time = time(0);\n  \n        int spaces_read = 0;\n        char space_buf[2*NUMSPACES];\n  \n        memset(space_buf, ' ', 2 * NUMSPACES);\n  \n        // to start communication we want to read NUMSPACES spaces in sequence\n        while (spaces_read < NUMSPACES)\n        {\n  \t  time_t now = time(0);\n  \t  if (timeout_seconds >= 0 && now - begin_time > timeout_seconds)\n  \t  {\n  \t      y2error (\"Couldn't establish serial connection for %d seconds. Aborting.\",\n  \t\t    timeout_seconds);\n  \t      close(fd_serial);\n  \t      exit(13); // This exit code is used by general/YaST2. Try to find a better solution, if you want.\n  \t  }\n  \n  \t char buf[2];\n        \n  \t // first write one space so the other side gets\n  \t // fullfilled its necessities\n  \t write(fd_serial, space_buf, 1);\n  \n  \t // now wait for a space to be read\n  \t // (the other side has the same behaviour)\n  \t if (await_readable(TIMEOUT))\n  \t {\n  \t    read(fd_serial, buf, 1);\t            // read one byte\n  \n  \t    if (buf[0] == ' ') spaces_read++;       // was a space\n  \t    else               spaces_read = 0;     // trash read --> reset\n  \t }\n        }\n  \n        // now that we've got our NUMSPACES spaces write 2 * NUMSPACES spaces to\n        // the other side to avoid syncing problems. the remote parser will kindly\n        // ignore them.\n        write(fd_serial, space_buf, 2 * NUMSPACES);\n  \n        // now set our parser to the serial line to start communication\n        parser.setInput(fd_serial, device_name.c_str());\n  \n        return true;\n     }\n  \n     close_tty();   // cleanup, connection NOT established\n     \n     return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  YCPValue Y2SerialComponent::doActualWork(const YCPList& arglist, Y2Component *user_interface)\n  {\n     if (!initializeConnection()) return YCPVoid();\n      \n     // We do NOT send the arglist to our partner on the other side!\n     // The YaST2 serial protocol defines, that the client is set up\n     // by the remote side and is given its arguments also there.\n     // The client arguments are just ignored here!\n  \n     if (arglist->size() > 0)\n     {\n        y2warning (\"The %ld arguments are ignored. Remote side provides client arguments\",\n  \t    (long)arglist->size());\n     }\n     \n     YCPValue value = YCPNull();\n  \n     while (!(value = receiveFromSerial()).isNull())\n     {\n        if (value->isTerm() \n  \t  && value->asTerm()->size() == 1 \n  \t  && value->asTerm()->name ()==\"result\")\n        {\n  \t close_tty();\n  \t return value; \n        }\n        sendToSerial(user_interface->evaluate(value));\n     }\n     y2warning (\"Communication ended prior to result() message\");\n     return YCPVoid();\n  }\n}"
  },
  {
    "function_name": "setServerOptions",
    "container": "Y2SerialComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
    "lines": "105-135",
    "snippet": "void Y2SerialComponent::setServerOptions(int argc, char **argv)\n{\n    for (int i=1; i<argc; i++)\n    {\n\tif (!strcmp(argv[i], \"--timeout\"))\n\t{   \n\t    if (i+1 <argc) {\n\t\ti ++;\n\t\tint newtimeout_seconds = atoi(argv[i]);\n\t\tif (newtimeout_seconds >= 0)\n\t\t{\n\t\t    timeout_seconds = newtimeout_seconds;\n\t\t    y2milestone (\"Setting timeout to %d seconds\", timeout_seconds);\n\t\t}\n\t\telse\n\t\t{\n\t\t    y2warning (\"Invalid timeout value %s. Using no timeout\",\n\t\t\t  argv[i]);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ty2warning (\"--timeout option missing argument\");\n\t    }\n\t}\n\telse\n\t{\n\t    y2warning (\"Ignoring invalid option %s\", argv[i]);\n\t}\n    }\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2SerialComponent.h\"",
      "#include <time.h>     // nanosleep",
      "#include <sys/time.h> // timeval",
      "#include <linux/serial.h>",
      "#include <linux/types.h>",
      "#include <termios.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"Ignoring invalid option %s\"",
            "argv[i]"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"--timeout option missing argument\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"Invalid timeout value %s. Using no timeout\"",
            "argv[i]"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2milestone",
          "args": [
            "\"Setting timeout to %d seconds\"",
            "timeout_seconds"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[i]"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--timeout\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  void Y2SerialComponent::setServerOptions(int argc, char **argv)\n  {\n      for (int i=1; i<argc; i++)\n      {\n  \tif (!strcmp(argv[i], \"--timeout\"))\n  \t{   \n  \t    if (i+1 <argc) {\n  \t\ti ++;\n  \t\tint newtimeout_seconds = atoi(argv[i]);\n  \t\tif (newtimeout_seconds >= 0)\n  \t\t{\n  \t\t    timeout_seconds = newtimeout_seconds;\n  \t\t    y2milestone (\"Setting timeout to %d seconds\", timeout_seconds);\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t    y2warning (\"Invalid timeout value %s. Using no timeout\",\n  \t\t\t  argv[i]);\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\ty2warning (\"--timeout option missing argument\");\n  \t    }\n  \t}\n  \telse\n  \t{\n  \t    y2warning (\"Ignoring invalid option %s\", argv[i]);\n  \t}\n      }\n  }\n}"
  },
  {
    "function_name": "result",
    "container": "Y2SerialComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
    "lines": "96-102",
    "snippet": "void Y2SerialComponent::result(const YCPValue& result)\n{\n   YCPTerm resultterm(\"result\");\n   resultterm->add(result);\n   sendToSerial(resultterm);\n   close_tty();\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2SerialComponent.h\"",
      "#include <time.h>     // nanosleep",
      "#include <sys/time.h> // timeval",
      "#include <linux/serial.h>",
      "#include <linux/types.h>",
      "#include <termios.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close_tty",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "close_tty",
          "container": "Y2SerialComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
          "lines": "184-188",
          "snippet": "void Y2SerialComponent::close_tty()\n{\n   if (fd_serial >= 0) close(fd_serial);\n   fd_serial = -1;\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2SerialComponent.h\"",
            "#include <time.h>     // nanosleep",
            "#include <sys/time.h> // timeval",
            "#include <linux/serial.h>",
            "#include <linux/types.h>",
            "#include <termios.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  void Y2SerialComponent::close_tty()\n  {\n     if (fd_serial >= 0) close(fd_serial);\n     fd_serial = -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sendToSerial",
          "args": [
            "resultterm"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "sendToSerial",
          "container": "Y2SerialComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
          "lines": "377-382",
          "snippet": "void Y2SerialComponent::sendToSerial(const YCPValue& v)\n{\n    string s  = \"(\" + v->toString() + \")\\n\";    // store string in string variable ..\n    const char *cs = s.c_str();        \t\t// c_str is valid als long as s\n    write(fd_serial, cs, strlen(cs));\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2SerialComponent.h\"",
            "#include <time.h>     // nanosleep",
            "#include <sys/time.h> // timeval",
            "#include <linux/serial.h>",
            "#include <linux/types.h>",
            "#include <termios.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  void Y2SerialComponent::sendToSerial(const YCPValue& v)\n  {\n      string s  = \"(\" + v->toString() + \")\\n\";    // store string in string variable ..\n      const char *cs = s.c_str();        \t\t// c_str is valid als long as s\n      write(fd_serial, cs, strlen(cs));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "resultterm->add",
          "args": [
            "result"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  void Y2SerialComponent::result(const YCPValue& result)\n  {\n     YCPTerm resultterm(\"result\");\n     resultterm->add(result);\n     sendToSerial(resultterm);\n     close_tty();\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "Y2SerialComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
    "lines": "75-93",
    "snippet": "YCPValue Y2SerialComponent::evaluate(const YCPValue& command)\n{\n   if (fd_serial < 0)   // not yet initialized\n   { \n      if (! initializeConnection()) return YCPVoid();\n   }\n\n   sendToSerial(command);\n\n   YCPValue ret = receiveFromSerial();\n\n   if (ret.isNull())\n   {\n      y2error (\"Couldn't get value from serial: %s\", device_name.c_str());\n      return YCPVoid();\n   }\n\n   return ret;\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2SerialComponent.h\"",
      "#include <time.h>     // nanosleep",
      "#include <sys/time.h> // timeval",
      "#include <linux/serial.h>",
      "#include <linux/types.h>",
      "#include <termios.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Couldn't get value from serial: %s\"",
            "device_name.c_str()"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_name.c_str",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret.isNull",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiveFromSerial",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "receiveFromSerial",
          "container": "Y2SerialComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
          "lines": "384-387",
          "snippet": "YCPValue Y2SerialComponent::receiveFromSerial()\n{\n   return YCPCode (parser.parse ());  // set to the serial line in initializeConnection()\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2SerialComponent.h\"",
            "#include <time.h>     // nanosleep",
            "#include <sys/time.h> // timeval",
            "#include <linux/serial.h>",
            "#include <linux/types.h>",
            "#include <termios.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  YCPValue Y2SerialComponent::receiveFromSerial()\n  {\n     return YCPCode (parser.parse ());  // set to the serial line in initializeConnection()\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sendToSerial",
          "args": [
            "command"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "sendToSerial",
          "container": "Y2SerialComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
          "lines": "377-382",
          "snippet": "void Y2SerialComponent::sendToSerial(const YCPValue& v)\n{\n    string s  = \"(\" + v->toString() + \")\\n\";    // store string in string variable ..\n    const char *cs = s.c_str();        \t\t// c_str is valid als long as s\n    write(fd_serial, cs, strlen(cs));\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2SerialComponent.h\"",
            "#include <time.h>     // nanosleep",
            "#include <sys/time.h> // timeval",
            "#include <linux/serial.h>",
            "#include <linux/types.h>",
            "#include <termios.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  void Y2SerialComponent::sendToSerial(const YCPValue& v)\n  {\n      string s  = \"(\" + v->toString() + \")\\n\";    // store string in string variable ..\n      const char *cs = s.c_str();        \t\t// c_str is valid als long as s\n      write(fd_serial, cs, strlen(cs));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "initializeConnection",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "initializeConnection",
          "container": "Y2SerialComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
          "lines": "310-374",
          "snippet": "bool Y2SerialComponent::initializeConnection()\n{\n   if (fd_serial >= 0) return true;             // already established\n   \n   int ret = open_tty();                        // logs for itself\n\n   if (ret >= 0) ret = setup_serial_device();   // logs for itself\n\n   if (ret >= 0) ret = make_raw();              // logs for itself\n\n   if (ret >= 0) ret = set_fixed_line_speed(baud_rate);   // logs for itself\n\n   if (ret >= 0)   // everything OK up to now\n   {\n       time_t begin_time = time(0);\n\n      int spaces_read = 0;\n      char space_buf[2*NUMSPACES];\n\n      memset(space_buf, ' ', 2 * NUMSPACES);\n\n      // to start communication we want to read NUMSPACES spaces in sequence\n      while (spaces_read < NUMSPACES)\n      {\n\t  time_t now = time(0);\n\t  if (timeout_seconds >= 0 && now - begin_time > timeout_seconds)\n\t  {\n\t      y2error (\"Couldn't establish serial connection for %d seconds. Aborting.\",\n\t\t    timeout_seconds);\n\t      close(fd_serial);\n\t      exit(13); // This exit code is used by general/YaST2. Try to find a better solution, if you want.\n\t  }\n\n\t char buf[2];\n      \n\t // first write one space so the other side gets\n\t // fullfilled its necessities\n\t write(fd_serial, space_buf, 1);\n\n\t // now wait for a space to be read\n\t // (the other side has the same behaviour)\n\t if (await_readable(TIMEOUT))\n\t {\n\t    read(fd_serial, buf, 1);\t            // read one byte\n\n\t    if (buf[0] == ' ') spaces_read++;       // was a space\n\t    else               spaces_read = 0;     // trash read --> reset\n\t }\n      }\n\n      // now that we've got our NUMSPACES spaces write 2 * NUMSPACES spaces to\n      // the other side to avoid syncing problems. the remote parser will kindly\n      // ignore them.\n      write(fd_serial, space_buf, 2 * NUMSPACES);\n\n      // now set our parser to the serial line to start communication\n      parser.setInput(fd_serial, device_name.c_str());\n\n      return true;\n   }\n\n   close_tty();   // cleanup, connection NOT established\n   \n   return false;\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2SerialComponent.h\"",
            "#include <time.h>     // nanosleep",
            "#include <sys/time.h> // timeval",
            "#include <linux/serial.h>",
            "#include <linux/types.h>",
            "#include <termios.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define TIMEOUT\t\t1000\t// microseconds",
            "#define NUMSPACES \t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\n#define TIMEOUT\t\t1000\t// microseconds\n#define NUMSPACES \t16\n\nY2SerialComponent {\n  bool Y2SerialComponent::initializeConnection()\n  {\n     if (fd_serial >= 0) return true;             // already established\n     \n     int ret = open_tty();                        // logs for itself\n  \n     if (ret >= 0) ret = setup_serial_device();   // logs for itself\n  \n     if (ret >= 0) ret = make_raw();              // logs for itself\n  \n     if (ret >= 0) ret = set_fixed_line_speed(baud_rate);   // logs for itself\n  \n     if (ret >= 0)   // everything OK up to now\n     {\n         time_t begin_time = time(0);\n  \n        int spaces_read = 0;\n        char space_buf[2*NUMSPACES];\n  \n        memset(space_buf, ' ', 2 * NUMSPACES);\n  \n        // to start communication we want to read NUMSPACES spaces in sequence\n        while (spaces_read < NUMSPACES)\n        {\n  \t  time_t now = time(0);\n  \t  if (timeout_seconds >= 0 && now - begin_time > timeout_seconds)\n  \t  {\n  \t      y2error (\"Couldn't establish serial connection for %d seconds. Aborting.\",\n  \t\t    timeout_seconds);\n  \t      close(fd_serial);\n  \t      exit(13); // This exit code is used by general/YaST2. Try to find a better solution, if you want.\n  \t  }\n  \n  \t char buf[2];\n        \n  \t // first write one space so the other side gets\n  \t // fullfilled its necessities\n  \t write(fd_serial, space_buf, 1);\n  \n  \t // now wait for a space to be read\n  \t // (the other side has the same behaviour)\n  \t if (await_readable(TIMEOUT))\n  \t {\n  \t    read(fd_serial, buf, 1);\t            // read one byte\n  \n  \t    if (buf[0] == ' ') spaces_read++;       // was a space\n  \t    else               spaces_read = 0;     // trash read --> reset\n  \t }\n        }\n  \n        // now that we've got our NUMSPACES spaces write 2 * NUMSPACES spaces to\n        // the other side to avoid syncing problems. the remote parser will kindly\n        // ignore them.\n        write(fd_serial, space_buf, 2 * NUMSPACES);\n  \n        // now set our parser to the serial line to start communication\n        parser.setInput(fd_serial, device_name.c_str());\n  \n        return true;\n     }\n  \n     close_tty();   // cleanup, connection NOT established\n     \n     return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  YCPValue Y2SerialComponent::evaluate(const YCPValue& command)\n  {\n     if (fd_serial < 0)   // not yet initialized\n     { \n        if (! initializeConnection()) return YCPVoid();\n     }\n  \n     sendToSerial(command);\n  \n     YCPValue ret = receiveFromSerial();\n  \n     if (ret.isNull())\n     {\n        y2error (\"Couldn't get value from serial: %s\", device_name.c_str());\n        return YCPVoid();\n     }\n  \n     return ret;\n  }\n}"
  },
  {
    "function_name": "name",
    "container": "Y2SerialComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
    "lines": "69-72",
    "snippet": "string Y2SerialComponent::name() const\n{\n   return full_name;\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2SerialComponent.h\"",
      "#include <time.h>     // nanosleep",
      "#include <sys/time.h> // timeval",
      "#include <linux/serial.h>",
      "#include <linux/types.h>",
      "#include <termios.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  string Y2SerialComponent::name() const\n  {\n     return full_name;\n  }\n}"
  },
  {
    "function_name": "~Y2SerialComponent",
    "container": "Y2SerialComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
    "lines": "64-66",
    "snippet": "Y2SerialComponent::~Y2SerialComponent()\n{\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2SerialComponent.h\"",
      "#include <time.h>     // nanosleep",
      "#include <sys/time.h> // timeval",
      "#include <linux/serial.h>",
      "#include <linux/types.h>",
      "#include <termios.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  Y2SerialComponent::~Y2SerialComponent()\n  {\n  }\n}"
  },
  {
    "function_name": "Y2SerialComponent",
    "container": "Y2SerialComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2SerialComponent.cc",
    "lines": "51-60",
    "snippet": "Y2SerialComponent::Y2SerialComponent(string device_name, long baud_rate)\n    : device_name(device_name)\n    , baud_rate(baud_rate)\n    , fd_serial(-1)\n    , timeout_seconds(-1)\n{\n   char buf[50];\n   snprintf(buf, 50, \"%ld\", baud_rate);\n   full_name = \"serial(\" + string(buf) + \"):\" + device_name;\n}",
    "includes": [
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2SerialComponent.h\"",
      "#include <time.h>     // nanosleep",
      "#include <sys/time.h> // timeval",
      "#include <linux/serial.h>",
      "#include <linux/types.h>",
      "#include <termios.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "string",
          "args": [
            "buf"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "50",
            "\"%ld\"",
            "baud_rate"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2SerialComponent.h\"\n#include <time.h>     // nanosleep\n#include <sys/time.h> // timeval\n#include <linux/serial.h>\n#include <linux/types.h>\n#include <termios.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2SerialComponent {\n  Y2SerialComponent::Y2SerialComponent(string device_name, long baud_rate)\n      : device_name(device_name)\n      , baud_rate(baud_rate)\n      , fd_serial(-1)\n      , timeout_seconds(-1)\n  {\n     char buf[50];\n     snprintf(buf, 50, \"%ld\", baud_rate);\n     full_name = \"serial(\" + string(buf) + \"):\" + device_name;\n  }\n}"
  }
]