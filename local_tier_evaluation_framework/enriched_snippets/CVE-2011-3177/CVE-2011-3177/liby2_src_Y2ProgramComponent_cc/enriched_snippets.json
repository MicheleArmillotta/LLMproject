[
  {
    "function_name": "remote",
    "container": "Y2ProgramComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
    "lines": "437-440",
    "snippet": "bool Y2ProgramComponent::remote() const\n{\n    return true;\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2ProgramComponent.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  bool Y2ProgramComponent::remote() const\n  {\n      return true;\n  }\n}"
  },
  {
    "function_name": "externalProgramOK",
    "container": "Y2ProgramComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
    "lines": "430-434",
    "snippet": "bool Y2ProgramComponent::externalProgramOK() const\n{\n    if (pid == -1) return false;\n    else return kill(pid, 0) == 0;\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2ProgramComponent.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pid",
            "0"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  bool Y2ProgramComponent::externalProgramOK() const\n  {\n      if (pid == -1) return false;\n      else return kill(pid, 0) == 0;\n  }\n}"
  },
  {
    "function_name": "sendToExternal",
    "container": "Y2ProgramComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
    "lines": "392-427",
    "snippet": "void Y2ProgramComponent::sendToExternal(const string& value)\n{\n    if (!externalProgramOK())\n    {\n\ty2error (\"External program %s died unexpectedly\", bin_file.c_str());\n    }\n\n    char *v = NULL;\n\n    if (is_non_y2)  v = strdup(value.c_str());   // no brackets\n    else            v = strdup((\"(\" + value + \")\").c_str());\n\n    bool error = (write(to_external[1], v, strlen(v)) < 0);\n    if (error)\n    {\n\ty2debug (\"Error writing to external program %s: Couldn't send %s (%s)\", bin_file.c_str(), v, strerror (errno));\n\tterminateExternalProgram();\n    }\n    free(v);\n\n    // We send an additional linefeed. This makes it more conveniant for non\n    // Y2 programs, for example that shell can do a read to get one value. For\n    // Y2 programs it increases the readability if you want to dump and debug\n    // the whole stream.\n\n    // We MUST NOT trigger an error, if the sending of the linefeed is not\n    // successful. This sporadically happens after we send a module the last\n    // return just before the module has done its work and terminates. It then\n    // justs sends the result(..) message, and closes down without reading the\n    // linefeed. The pipe breaks down and the sending fails. But as long as we\n    // don't collect the process by calling wait4, we can still read the\n    // result (..) from the input pipe, which is very important. Otherwise the\n    // result value would be dropped.\n\n    write(to_external[1], \"\\n\", 1);\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2ProgramComponent.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "to_external[1]",
            "\"\\n\"",
            "1"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "write_helper",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "1018-1077",
          "snippet": "int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n{\n    char * out_buffer;\n    string indent;\n    string indent2;\n    int readby = ini.getReadBy ();\n    if (!subindent.empty ())\n    {\n\tfor (int ii = 0; ii<depth - 1;ii++)\n\t    indent = indent + subindent;\n\tif (depth)\n\t    indent2 = indent + subindent;\n    }\n\n    if (ini.getComment ()[0])\n        of << ini.getComment();\n    if (readby>=0 && readby < (int)sections.size ())\n\t{\n\t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free (out_buffer);\n\t}\n    \n    IniIterator\n\tci = ini.getContainerBegin (),\n\tce = ini.getContainerEnd ();\n\n    for (;ci != ce; ++ci)\n\t{\n\t    if (ci->t () == SECTION)\n\t\t{\n\t\t    write_helper (ci->s (), of, depth + 1);\n\t\t    ci->s ().clean();\n\t\t}\n\t    else\n\t\t{\n\t\t    IniEntry&e = ci->e ();\n\t\t    if (e.getComment ()[0])\n\t\t\tof << e.getComment();\n\t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n\t\t\t// bnc#492859, a fixed buffer is too small\n\t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n\t\t\tof << indent2 << out_buffer << \"\\n\";\n\t\t\tfree(out_buffer);\n\t\t    }\n\t\t    e.clean();\n\t\t}\n\t}\n\n    if (ini.getEndComment ()[0])\n        of << indent << ini.getEndComment();\n    if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n\t{\n\t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free(out_buffer);\n\t}\n    ini.clean();\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n  {\n      char * out_buffer;\n      string indent;\n      string indent2;\n      int readby = ini.getReadBy ();\n      if (!subindent.empty ())\n      {\n  \tfor (int ii = 0; ii<depth - 1;ii++)\n  \t    indent = indent + subindent;\n  \tif (depth)\n  \t    indent2 = indent + subindent;\n      }\n  \n      if (ini.getComment ()[0])\n          of << ini.getComment();\n      if (readby>=0 && readby < (int)sections.size ())\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free (out_buffer);\n  \t}\n      \n      IniIterator\n  \tci = ini.getContainerBegin (),\n  \tce = ini.getContainerEnd ();\n  \n      for (;ci != ce; ++ci)\n  \t{\n  \t    if (ci->t () == SECTION)\n  \t\t{\n  \t\t    write_helper (ci->s (), of, depth + 1);\n  \t\t    ci->s ().clean();\n  \t\t}\n  \t    else\n  \t\t{\n  \t\t    IniEntry&e = ci->e ();\n  \t\t    if (e.getComment ()[0])\n  \t\t\tof << e.getComment();\n  \t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n  \t\t\t// bnc#492859, a fixed buffer is too small\n  \t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n  \t\t\tof << indent2 << out_buffer << \"\\n\";\n  \t\t\tfree(out_buffer);\n  \t\t    }\n  \t\t    e.clean();\n  \t\t}\n  \t}\n  \n      if (ini.getEndComment ()[0])\n          of << indent << ini.getEndComment();\n      if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free(out_buffer);\n  \t}\n      ini.clean();\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "v"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "terminateExternalProgram",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "terminateExternalProgram",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "335-352",
          "snippet": "void Y2ProgramComponent::terminateExternalProgram()\n{\n    // We do not really kill the program here. We assume\n    // that it is shut down gracefully and just close the\n    // pipes and collect the zombie process. The real termination\n    // thing is done by result() for server components and\n    // automatically in doActualWork() for client components.\n\n    if (pid >= 0)\n    {\n\tclose(to_external[1]);\n\tclose(from_external[0]);\n\n\t// FIXME: this does not really wait in case of signals\n\twaitpid(pid, 0, 0); // Wait for child to exit\n    }\n    pid = -1;\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::terminateExternalProgram()\n  {\n      // We do not really kill the program here. We assume\n      // that it is shut down gracefully and just close the\n      // pipes and collect the zombie process. The real termination\n      // thing is done by result() for server components and\n      // automatically in doActualWork() for client components.\n  \n      if (pid >= 0)\n      {\n  \tclose(to_external[1]);\n  \tclose(from_external[0]);\n  \n  \t// FIXME: this does not really wait in case of signals\n  \twaitpid(pid, 0, 0); // Wait for child to exit\n      }\n      pid = -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Error writing to external program %s: Couldn't send %s (%s)\"",
            "bin_file.c_str()",
            "v",
            "strerror (errno)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin_file.c_str",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "v"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "(\"(\" + value + \")\").c_str()"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "value.c_str()"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.c_str",
          "args": [],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"External program %s died unexpectedly\"",
            "bin_file.c_str()"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin_file.c_str",
          "args": [],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "externalProgramOK",
          "args": [],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "externalProgramOK",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "430-434",
          "snippet": "bool Y2ProgramComponent::externalProgramOK() const\n{\n    if (pid == -1) return false;\n    else return kill(pid, 0) == 0;\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  bool Y2ProgramComponent::externalProgramOK() const\n  {\n      if (pid == -1) return false;\n      else return kill(pid, 0) == 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::sendToExternal(const string& value)\n  {\n      if (!externalProgramOK())\n      {\n  \ty2error (\"External program %s died unexpectedly\", bin_file.c_str());\n      }\n  \n      char *v = NULL;\n  \n      if (is_non_y2)  v = strdup(value.c_str());   // no brackets\n      else            v = strdup((\"(\" + value + \")\").c_str());\n  \n      bool error = (write(to_external[1], v, strlen(v)) < 0);\n      if (error)\n      {\n  \ty2debug (\"Error writing to external program %s: Couldn't send %s (%s)\", bin_file.c_str(), v, strerror (errno));\n  \tterminateExternalProgram();\n      }\n      free(v);\n  \n      // We send an additional linefeed. This makes it more conveniant for non\n      // Y2 programs, for example that shell can do a read to get one value. For\n      // Y2 programs it increases the readability if you want to dump and debug\n      // the whole stream.\n  \n      // We MUST NOT trigger an error, if the sending of the linefeed is not\n      // successful. This sporadically happens after we send a module the last\n      // return just before the module has done its work and terminates. It then\n      // justs sends the result(..) message, and closes down without reading the\n      // linefeed. The pipe breaks down and the sending fails. But as long as we\n      // don't collect the process by calling wait4, we can still read the\n      // result (..) from the input pipe, which is very important. Otherwise the\n      // result value would be dropped.\n  \n      write(to_external[1], \"\\n\", 1);\n  }\n}"
  },
  {
    "function_name": "sendToExternal",
    "container": "Y2ProgramComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
    "lines": "386-389",
    "snippet": "void Y2ProgramComponent::sendToExternal(const YCPValue& value)\n{\n    sendToExternal(value->toString());\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2ProgramComponent.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendToExternal",
          "args": [
            "value->toString()"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "sendToExternal",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "392-427",
          "snippet": "void Y2ProgramComponent::sendToExternal(const string& value)\n{\n    if (!externalProgramOK())\n    {\n\ty2error (\"External program %s died unexpectedly\", bin_file.c_str());\n    }\n\n    char *v = NULL;\n\n    if (is_non_y2)  v = strdup(value.c_str());   // no brackets\n    else            v = strdup((\"(\" + value + \")\").c_str());\n\n    bool error = (write(to_external[1], v, strlen(v)) < 0);\n    if (error)\n    {\n\ty2debug (\"Error writing to external program %s: Couldn't send %s (%s)\", bin_file.c_str(), v, strerror (errno));\n\tterminateExternalProgram();\n    }\n    free(v);\n\n    // We send an additional linefeed. This makes it more conveniant for non\n    // Y2 programs, for example that shell can do a read to get one value. For\n    // Y2 programs it increases the readability if you want to dump and debug\n    // the whole stream.\n\n    // We MUST NOT trigger an error, if the sending of the linefeed is not\n    // successful. This sporadically happens after we send a module the last\n    // return just before the module has done its work and terminates. It then\n    // justs sends the result(..) message, and closes down without reading the\n    // linefeed. The pipe breaks down and the sending fails. But as long as we\n    // don't collect the process by calling wait4, we can still read the\n    // result (..) from the input pipe, which is very important. Otherwise the\n    // result value would be dropped.\n\n    write(to_external[1], \"\\n\", 1);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "76-88",
          "snippet": "string\nY2Namespace::toString () const\n{\n    if (m_table == 0)\n    {\n\treturn \"<empty>\";\n    }\n\n    SymbolTable* t = m_table;\n    string s = t->toString ();\n\n    return s + symbolsToString ();\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  string\n  Y2Namespace::toString () const\n  {\n      if (m_table == 0)\n      {\n  \treturn \"<empty>\";\n      }\n  \n      SymbolTable* t = m_table;\n      string s = t->toString ();\n  \n      return s + symbolsToString ();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::sendToExternal(const YCPValue& value)\n  {\n      sendToExternal(value->toString());\n  }\n}"
  },
  {
    "function_name": "receiveFromExternal",
    "container": "Y2ProgramComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
    "lines": "355-383",
    "snippet": "YCPValue Y2ProgramComponent::receiveFromExternal ()\n{\n    while (true)\n    {\n\tif (!externalProgramOK ())\n\t{\n\t    y2error (\"External program %s died unexpectedly\", bin_file.c_str ());\n\t    return YCPNull ();\n\t}\n\n\tYCodePtr c = parser.parse ();\n\t\n\tif (c == NULL || c->isError())\n\t{\n\t    y2error (\"External program %s returned invalid data. (No other error means no data at all)\", bin_file.c_str ());\n\t    return YCPNull ();\n\t}\n\t\n\t// evaluate, but not as constant\n\tYCPValue ret = c->evaluate (true);\n\tif (ret.isNull ())\n\t{\n\t    y2milestone (\"External program returned executable code, executing\");\n\t    ret = c->evaluate (false);\n\t}\n\n\treturn ret;\n    }\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2ProgramComponent.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->evaluate",
          "args": [
            "false"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "69-138",
          "snippet": "YCPValue Y2ProgramComponent::evaluate(const YCPValue& command)\n{\n    if (pid == -1)   // server component not yet started --> do it\n    {\n\tif (is_non_y2)   // this is a nony2 program like a shell and such like\n\t{\n\t    // Prepare options: argv[0] must be server component name,\n\t    // argv[1] must _NOT_ be 'stdio' like for real Y2 components (see below).\n\t    // If no options have been set so far via setServerOptions(),\n\t    // fill in argv[0] correctly.\n\n\t    int l_argc = 1 + (argc > 0 ? argc - 1 : 0);\n\t    char **l_argv = new char *[l_argc + 1];\n\n\t    l_argv[0] = (argc >= 1) ? argv[0] : strdup(name().c_str()); // component name\n\t    for (int arg = 1; arg < argc; arg++) l_argv[arg] = argv[arg];\n\t    l_argv[l_argc] = 0; // Terminate array\n\n\t    // launch program\n\t    launchExternalProgram(l_argv);\n\n\t    // NonY2 servers will not send arguments to the client (me).\n\t    // Therefore it is not necessary to receive something in this case.\n\n\t    if (argc < 1) free (l_argv[0]);\n\t    if (l_argv) delete[] l_argv;  // free l_argv\n\t}\n\telse   // this is a real liby2 component\n\t{\n\t    // Prepare options: argv[0] must be server component name,\n\t    // argv[1] must be 'stdio' in order to make the gf of the\n\t    // called component communicate via stdio, argv[2...] contains\n\t    // all further options. If no options have been set so far\n\t    // via setServerOptions(), fill in argv[0] correctly.\n\n\t    int l_argc = 3 + (argc > 0 ? argc - 1 : 0);\n\t    char **l_argv = new char *[l_argc + 1];\n\n\t    l_argv[0] = argc >= 1 ? argv[0] : strdup(name().c_str()); // component name\n\t    l_argv[1] = \"stdio\"; // I will speak to the server via his stdio\n\t    l_argv[2] = strdup(name().c_str());\n\t    for (int arg = 1; arg < argc; arg++) l_argv[arg+2] = argv[arg];\n\t    l_argv[l_argc] = 0; // Terminate array\n\n\t    // launch program\n\t    launchExternalProgram(l_argv);\n\n\t    // I am myself a module in this context. Therefore the server\n\t    // will send me my arguments. Since I initiated the session\n\t    // myself, I am not interested in these arguments.\n\n\t    if (receiveFromExternal().isNull())\n\t    {\n\t\ty2error (\"Couldn't launch external server %s\", name().c_str ());\n\t\treturn YCPNull ();\n\t    }\n\n\t    if (argc < 1) free (l_argv[0]);\n\t    free (l_argv[2]);\n\t    delete[] l_argv;  // free l_argv\n\t}\n    }\n\n    // send command\n    sendToExternal (command);\n\n    // get answer\n    YCPValue retval = receiveFromExternal();\n    return !retval.isNull() ? retval : YCPVoid();\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  YCPValue Y2ProgramComponent::evaluate(const YCPValue& command)\n  {\n      if (pid == -1)   // server component not yet started --> do it\n      {\n  \tif (is_non_y2)   // this is a nony2 program like a shell and such like\n  \t{\n  \t    // Prepare options: argv[0] must be server component name,\n  \t    // argv[1] must _NOT_ be 'stdio' like for real Y2 components (see below).\n  \t    // If no options have been set so far via setServerOptions(),\n  \t    // fill in argv[0] correctly.\n  \n  \t    int l_argc = 1 + (argc > 0 ? argc - 1 : 0);\n  \t    char **l_argv = new char *[l_argc + 1];\n  \n  \t    l_argv[0] = (argc >= 1) ? argv[0] : strdup(name().c_str()); // component name\n  \t    for (int arg = 1; arg < argc; arg++) l_argv[arg] = argv[arg];\n  \t    l_argv[l_argc] = 0; // Terminate array\n  \n  \t    // launch program\n  \t    launchExternalProgram(l_argv);\n  \n  \t    // NonY2 servers will not send arguments to the client (me).\n  \t    // Therefore it is not necessary to receive something in this case.\n  \n  \t    if (argc < 1) free (l_argv[0]);\n  \t    if (l_argv) delete[] l_argv;  // free l_argv\n  \t}\n  \telse   // this is a real liby2 component\n  \t{\n  \t    // Prepare options: argv[0] must be server component name,\n  \t    // argv[1] must be 'stdio' in order to make the gf of the\n  \t    // called component communicate via stdio, argv[2...] contains\n  \t    // all further options. If no options have been set so far\n  \t    // via setServerOptions(), fill in argv[0] correctly.\n  \n  \t    int l_argc = 3 + (argc > 0 ? argc - 1 : 0);\n  \t    char **l_argv = new char *[l_argc + 1];\n  \n  \t    l_argv[0] = argc >= 1 ? argv[0] : strdup(name().c_str()); // component name\n  \t    l_argv[1] = \"stdio\"; // I will speak to the server via his stdio\n  \t    l_argv[2] = strdup(name().c_str());\n  \t    for (int arg = 1; arg < argc; arg++) l_argv[arg+2] = argv[arg];\n  \t    l_argv[l_argc] = 0; // Terminate array\n  \n  \t    // launch program\n  \t    launchExternalProgram(l_argv);\n  \n  \t    // I am myself a module in this context. Therefore the server\n  \t    // will send me my arguments. Since I initiated the session\n  \t    // myself, I am not interested in these arguments.\n  \n  \t    if (receiveFromExternal().isNull())\n  \t    {\n  \t\ty2error (\"Couldn't launch external server %s\", name().c_str ());\n  \t\treturn YCPNull ();\n  \t    }\n  \n  \t    if (argc < 1) free (l_argv[0]);\n  \t    free (l_argv[2]);\n  \t    delete[] l_argv;  // free l_argv\n  \t}\n      }\n  \n      // send command\n      sendToExternal (command);\n  \n      // get answer\n      YCPValue retval = receiveFromExternal();\n      return !retval.isNull() ? retval : YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2milestone",
          "args": [
            "\"External program returned executable code, executing\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret.isNull",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"External program %s returned invalid data. (No other error means no data at all)\"",
            "bin_file.c_str ()"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin_file.c_str",
          "args": [],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->isError",
          "args": [],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "isError",
          "container": "YCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "76-80",
          "snippet": "bool\nYCode::isError() const\n{\n    return false; \t\t// TODO unused in practice?\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  bool\n  YCode::isError() const\n  {\n      return false; \t\t// TODO unused in practice?\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.parse",
          "args": [],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "484-562",
          "snippet": "int IniParser::parse()\n{\n    if (multiple_files)\n    {\n\tglob_t do_files;\n\tint len = files.size ();\n\tint flags = 0;\n\tfor (int i = 0;i<len;i++)\n\t{\n\t    glob (files[i].c_str (),flags, NULL, &do_files);\n\t    flags = GLOB_APPEND;\n\t}\n\tchar**f = do_files.gl_pathv;\n\tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n\t{\n\t    int section_index = -1;\n\t    string section_name = *f;\n\t    //FIXME: create function out of it.\n\t    // do we have name rewrite rules?\n\t    for (size_t j = 0; j < rewrites.size (); j++)\n\t\t{\n\t\t    RegexMatch m (rewrites[j].rx, section_name);\n\t\t    if (m)\n\t\t    {\n\t\t\tsection_index = j;\n\t\t\tsection_name = m[1];\n\t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    // do we know about the file?\n\t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n\t    if (ff == multi_files.end())\n\t    {\n\t\t// new file\n\t\tif (scanner_start (*f))\n\t\t    y2error (\"Cannot open %s.\", *f);\n\t\telse\n\t\t{\n\t\t    FileDescr fdsc (*f);\n\t\t    multi_files[*f] = fdsc;\n\t\t    inifile.initSection (section_name, \"\", -1, section_index);\n\t\t    parse_helper(inifile.getSection(section_name.c_str()));\n\t\t    scanner_stop();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif ((*ff).second.changed ())\n\t\t{\n\t\t    if (scanner_start (*f))\n\t\t\ty2error (\"Cannot open %s.\", *f);\n\t\t    else\n\t\t    {\n\t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n\t\t\tFileDescr fdsc (*f);\n\t\t\tmulti_files [*f] = fdsc;\n\t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n\t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n\t\t\tscanner_stop();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tif (scanner_start (file.c_str()))\n\t    {\n\t\ty2error (\"Can not open %s.\", file.c_str());\n\t\treturn -1;\n\t    }\n\tparse_helper(inifile);\n\tscanner_stop();\n\ttimestamp = getTimeStamp ();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse()\n  {\n      if (multiple_files)\n      {\n  \tglob_t do_files;\n  \tint len = files.size ();\n  \tint flags = 0;\n  \tfor (int i = 0;i<len;i++)\n  \t{\n  \t    glob (files[i].c_str (),flags, NULL, &do_files);\n  \t    flags = GLOB_APPEND;\n  \t}\n  \tchar**f = do_files.gl_pathv;\n  \tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n  \t{\n  \t    int section_index = -1;\n  \t    string section_name = *f;\n  \t    //FIXME: create function out of it.\n  \t    // do we have name rewrite rules?\n  \t    for (size_t j = 0; j < rewrites.size (); j++)\n  \t\t{\n  \t\t    RegexMatch m (rewrites[j].rx, section_name);\n  \t\t    if (m)\n  \t\t    {\n  \t\t\tsection_index = j;\n  \t\t\tsection_name = m[1];\n  \t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \n  \t    // do we know about the file?\n  \t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n  \t    if (ff == multi_files.end())\n  \t    {\n  \t\t// new file\n  \t\tif (scanner_start (*f))\n  \t\t    y2error (\"Cannot open %s.\", *f);\n  \t\telse\n  \t\t{\n  \t\t    FileDescr fdsc (*f);\n  \t\t    multi_files[*f] = fdsc;\n  \t\t    inifile.initSection (section_name, \"\", -1, section_index);\n  \t\t    parse_helper(inifile.getSection(section_name.c_str()));\n  \t\t    scanner_stop();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif ((*ff).second.changed ())\n  \t\t{\n  \t\t    if (scanner_start (*f))\n  \t\t\ty2error (\"Cannot open %s.\", *f);\n  \t\t    else\n  \t\t    {\n  \t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n  \t\t\tFileDescr fdsc (*f);\n  \t\t\tmulti_files [*f] = fdsc;\n  \t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n  \t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n  \t\t\tscanner_stop();\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n      else\n      {\n  \tif (scanner_start (file.c_str()))\n  \t    {\n  \t\ty2error (\"Can not open %s.\", file.c_str());\n  \t\treturn -1;\n  \t    }\n  \tparse_helper(inifile);\n  \tscanner_stop();\n  \ttimestamp = getTimeStamp ();\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"External program %s died unexpectedly\"",
            "bin_file.c_str ()"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin_file.c_str",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "externalProgramOK",
          "args": [],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "externalProgramOK",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "430-434",
          "snippet": "bool Y2ProgramComponent::externalProgramOK() const\n{\n    if (pid == -1) return false;\n    else return kill(pid, 0) == 0;\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  bool Y2ProgramComponent::externalProgramOK() const\n  {\n      if (pid == -1) return false;\n      else return kill(pid, 0) == 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  YCPValue Y2ProgramComponent::receiveFromExternal ()\n  {\n      while (true)\n      {\n  \tif (!externalProgramOK ())\n  \t{\n  \t    y2error (\"External program %s died unexpectedly\", bin_file.c_str ());\n  \t    return YCPNull ();\n  \t}\n  \n  \tYCodePtr c = parser.parse ();\n  \t\n  \tif (c == NULL || c->isError())\n  \t{\n  \t    y2error (\"External program %s returned invalid data. (No other error means no data at all)\", bin_file.c_str ());\n  \t    return YCPNull ();\n  \t}\n  \t\n  \t// evaluate, but not as constant\n  \tYCPValue ret = c->evaluate (true);\n  \tif (ret.isNull ())\n  \t{\n  \t    y2milestone (\"External program returned executable code, executing\");\n  \t    ret = c->evaluate (false);\n  \t}\n  \n  \treturn ret;\n      }\n  }\n}"
  },
  {
    "function_name": "terminateExternalProgram",
    "container": "Y2ProgramComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
    "lines": "335-352",
    "snippet": "void Y2ProgramComponent::terminateExternalProgram()\n{\n    // We do not really kill the program here. We assume\n    // that it is shut down gracefully and just close the\n    // pipes and collect the zombie process. The real termination\n    // thing is done by result() for server components and\n    // automatically in doActualWork() for client components.\n\n    if (pid >= 0)\n    {\n\tclose(to_external[1]);\n\tclose(from_external[0]);\n\n\t// FIXME: this does not really wait in case of signals\n\twaitpid(pid, 0, 0); // Wait for child to exit\n    }\n    pid = -1;\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2ProgramComponent.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "0",
            "0"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "from_external[0]"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "to_external[1]"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::terminateExternalProgram()\n  {\n      // We do not really kill the program here. We assume\n      // that it is shut down gracefully and just close the\n      // pipes and collect the zombie process. The real termination\n      // thing is done by result() for server components and\n      // automatically in doActualWork() for client components.\n  \n      if (pid >= 0)\n      {\n  \tclose(to_external[1]);\n  \tclose(from_external[0]);\n  \n  \t// FIXME: this does not really wait in case of signals\n  \twaitpid(pid, 0, 0); // Wait for child to exit\n      }\n      pid = -1;\n  }\n}"
  },
  {
    "function_name": "launchExternalProgram",
    "container": "Y2ProgramComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
    "lines": "264-332",
    "snippet": "void Y2ProgramComponent::launchExternalProgram (char **argv)\n{\n    y2debug (\"launchExternalProgram (%s, %s, ...)\", argv[0], argv[1]);\n    // Create socket-pair\n    int err;\n    err = pipe(to_external);\n    if (err != 0)\n\ty2error(\"pipe failed: %s\", strerror (errno));\n    err = pipe(from_external);\n    if (err != 0)\n\ty2error(\"pipe failed: %s\", strerror (errno));\n\n    // Create module process\n\n    if (0 == (pid = fork()))   // child process\n    {\n\n\t// Set component level for new program\n\tchar levelstring[32];\n\tsnprintf(levelstring, 32, \"%d\", level);\n\tsetenv(\"Y2LEVEL\", levelstring, 1); // 1: overwrite, if variable exists\n\n\t// child input\n\tExternalProgram::renumber_fd (to_external[0], 0); // set reading end to stdin\n\tclose(to_external[1]);     // writing end belongs to father process\n\n\t// child output\n        ExternalProgram::renumber_fd (from_external[1], 1); // set writing end to stdout\n\tclose(from_external[0]);   // reading end belongs to father process\n\n\t// Depending on whether it is a server or a client component\n\t// I prepare the arguments on a different way.\n\n\t// Call chroot if desired.\n\tif (chroot_path == \"\" || chroot_path == \"/\") {\n\t    //bnc#493152#c24\n\t    //y2debug (\"Going to execute %s\", bin_file.c_str ());\n\t} else {\n\t    /*y2debug (\"Going to execute %s with chroot %s\", bin_file.c_str (),\n\t\t     chroot_path.c_str ());*/\n\t    if (chroot (chroot_path.c_str ()) != 0) {\n\t\t/*y2error (\"Cannot chroot to %s: %s\", chroot_path.c_str (),\n\t\t\t strerror (errno));*/\n\t\t_exit (5);\n\t    }\n\n\t    chdir (\"/\");\n\t}\n\n\t// close all filedescriptors above stderr, bnc#501758\n\tfor (int i = getdtablesize () - 1; i > 2; --i) {\n\t    close (i);\n\t}\n\n\texecv (bin_file.c_str (), argv);\t// execute program\n\n\t// this code is only reached if exec failed\n\t//y2error (\"Cannot execute external program %s\", bin_file.c_str ());\n\t_exit (5); // No sense in returning! I am forked away!!\n    }\n\n    // father process\n\n    close(to_external[0]);   // reading end belongs to child process\n    close(from_external[1]); // writing end belongs to child process\n\n    // Prepare parser\n    parser.setInput(from_external[0], argv[0]);  // set parser input to child output\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2ProgramComponent.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parser.setInput",
          "args": [
            "from_external[0]",
            "argv[0]"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "setInput",
          "container": "Parser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Parser.cc",
          "lines": "108-115",
          "snippet": "void\nParser::setInput(int fd, const char *filename)\n{\n    if (m_scanner) delete m_scanner;\n    m_scanner = new Scanner (fd, filename);\n    if (m_buffered) m_scanner->setBuffered ();\n    m_at_eof = false;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Parser.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Parser.h\"\n#include <stdlib.h>\n\nParser {\n  void\n  Parser::setInput(int fd, const char *filename)\n  {\n      if (m_scanner) delete m_scanner;\n      m_scanner = new Scanner (fd, filename);\n      if (m_buffered) m_scanner->setBuffered ();\n      m_at_eof = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "from_external[1]"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "to_external[0]"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "5"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execv",
          "args": [
            "bin_file.c_str ()",
            "argv"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin_file.c_str",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "i"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getdtablesize",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "5"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chroot",
          "args": [
            "chroot_path.c_str ()"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chroot_path.c_str",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "from_external[0]"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExternalProgram::renumber_fd",
          "args": [
            "from_external[1]",
            "1"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "renumber_fd",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "425-435",
          "snippet": "void ExternalProgram::renumber_fd (int origfd, int newfd)\n{\n    // It may happen that origfd is already the one we want\n    // (Although in our circumstances, that would mean somebody has closed\n    // our stdin or stdout... weird but has appened to Cray, #49797)\n    if (origfd != newfd)\n    {\n\tdup2 (origfd, newfd);\n\t::close (origfd);\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  void ExternalProgram::renumber_fd (int origfd, int newfd)\n  {\n      // It may happen that origfd is already the one we want\n      // (Although in our circumstances, that would mean somebody has closed\n      // our stdin or stdout... weird but has appened to Cray, #49797)\n      if (origfd != newfd)\n      {\n  \tdup2 (origfd, newfd);\n  \t::close (origfd);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "to_external[1]"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"Y2LEVEL\"",
            "levelstring",
            "1"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "levelstring",
            "32",
            "\"%d\"",
            "level"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"pipe failed: %s\"",
            "strerror (errno)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "from_external"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"pipe failed: %s\"",
            "strerror (errno)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "to_external"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"launchExternalProgram (%s, %s, ...)\"",
            "argv[0]",
            "argv[1]"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::launchExternalProgram (char **argv)\n  {\n      y2debug (\"launchExternalProgram (%s, %s, ...)\", argv[0], argv[1]);\n      // Create socket-pair\n      int err;\n      err = pipe(to_external);\n      if (err != 0)\n  \ty2error(\"pipe failed: %s\", strerror (errno));\n      err = pipe(from_external);\n      if (err != 0)\n  \ty2error(\"pipe failed: %s\", strerror (errno));\n  \n      // Create module process\n  \n      if (0 == (pid = fork()))   // child process\n      {\n  \n  \t// Set component level for new program\n  \tchar levelstring[32];\n  \tsnprintf(levelstring, 32, \"%d\", level);\n  \tsetenv(\"Y2LEVEL\", levelstring, 1); // 1: overwrite, if variable exists\n  \n  \t// child input\n  \tExternalProgram::renumber_fd (to_external[0], 0); // set reading end to stdin\n  \tclose(to_external[1]);     // writing end belongs to father process\n  \n  \t// child output\n          ExternalProgram::renumber_fd (from_external[1], 1); // set writing end to stdout\n  \tclose(from_external[0]);   // reading end belongs to father process\n  \n  \t// Depending on whether it is a server or a client component\n  \t// I prepare the arguments on a different way.\n  \n  \t// Call chroot if desired.\n  \tif (chroot_path == \"\" || chroot_path == \"/\") {\n  \t    //bnc#493152#c24\n  \t    //y2debug (\"Going to execute %s\", bin_file.c_str ());\n  \t} else {\n  \t    /*y2debug (\"Going to execute %s with chroot %s\", bin_file.c_str (),\n  \t\t     chroot_path.c_str ());*/\n  \t    if (chroot (chroot_path.c_str ()) != 0) {\n  \t\t/*y2error (\"Cannot chroot to %s: %s\", chroot_path.c_str (),\n  \t\t\t strerror (errno));*/\n  \t\t_exit (5);\n  \t    }\n  \n  \t    chdir (\"/\");\n  \t}\n  \n  \t// close all filedescriptors above stderr, bnc#501758\n  \tfor (int i = getdtablesize () - 1; i > 2; --i) {\n  \t    close (i);\n  \t}\n  \n  \texecv (bin_file.c_str (), argv);\t// execute program\n  \n  \t// this code is only reached if exec failed\n  \t//y2error (\"Cannot execute external program %s\", bin_file.c_str ());\n  \t_exit (5); // No sense in returning! I am forked away!!\n      }\n  \n      // father process\n  \n      close(to_external[0]);   // reading end belongs to child process\n      close(from_external[1]); // writing end belongs to child process\n  \n      // Prepare parser\n      parser.setInput(from_external[0], argv[0]);  // set parser input to child output\n  }\n}"
  },
  {
    "function_name": "doActualWork",
    "container": "Y2ProgramComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
    "lines": "172-261",
    "snippet": "YCPValue Y2ProgramComponent::doActualWork(const YCPList& arglist, Y2Component *user_interface)\n{\n    int argc;      // this shadows the corresponding member variables for servers\n    char **argv;\n\n    if (is_non_y2)   // this is a nony2 program like a shell and such like\n    {\n\tint arg = 0;\n\n\t// Prepare arguments as command line parameters for program being called\n\targc = !arglist.isNull() ? arglist->size() + 1 : 1;\n\targv = new char *[argc+1];\n\targv[0] = strdup((name().c_str()));\n\targv[argc] = NULL;\n\n\tfor (arg = 1; arg < argc; arg++)\n\t{\n\t    YCPValue a = arglist->value(arg-1);\n\t    if (a->isString())\n\t    {\n\t\targv[arg] = strdup(a->asString()->value().c_str());\n\t    }\n\t    else\n\t    {\n\t\targv[arg] = strdup(a->toString().c_str());\n\t    }\n\t}\n\n\t// launch component if not yet done\n\tif (pid == -1) launchExternalProgram(argv);\n\n\tif (argv)\n\t{\n\t    for (arg = 0; arg < argc; arg++)\n\t    {\n\t\tif (argv[arg])\n\t\t{\n\t\t    free(argv[arg]);\n\t\t}\n\t    }\n\t    delete[] argv;\n\t}\n    }\n    else   // this is a real liby2 component\n    {\n\t// send arguments via stdio\n\targc = 4;   // name, -s\n\targv = new char *[argc+1];\n\targv[0] = strdup(name().c_str());\n\targv[1] = argv[0];\n\targv[2] = \"-s\";    // get arguments on stdin\n\targv[3] = \"stdio\"; // communicate via stdio\n\targv[argc] = NULL;\n\n\t// launch component if not yet done\n\tif (pid == -1) launchExternalProgram(argv);\n\n\tsendToExternal(arglist);   // now send arguments\n\n\tif (argv)\n\t{\n\t    if (argv[0]) free(argv[0]);\n\t    delete[] argv;\n\t}\n    }\n\n    // Communication loop with module. Module sends 'result(...)',\n    // when finished\n    YCPValue retval = YCPNull();\n    YCPValue value = YCPNull();\n\n    while (!(value = receiveFromExternal()).isNull())\n    {\n\tif (value->isTerm()\n\t    && value->asTerm()->size() == 1\n\t    && value->asTerm()->name() == \"result\")\n\t{\n\t    retval = value->asTerm()->value(0);\n\t    y2debug (\"Got result from client component %s: %s\", name().c_str(), retval->toString().c_str());\n\t    break;\n\t}\n\telse\n\t{\n\t    // Send this to the UI and get UI answer\n\t    sendToExternal(user_interface->evaluate(value));\n\t}\n    }\n\n    return !retval.isNull() ? retval : YCPVoid();\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2ProgramComponent.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "retval.isNull",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendToExternal",
          "args": [
            "user_interface->evaluate(value)"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "sendToExternal",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "392-427",
          "snippet": "void Y2ProgramComponent::sendToExternal(const string& value)\n{\n    if (!externalProgramOK())\n    {\n\ty2error (\"External program %s died unexpectedly\", bin_file.c_str());\n    }\n\n    char *v = NULL;\n\n    if (is_non_y2)  v = strdup(value.c_str());   // no brackets\n    else            v = strdup((\"(\" + value + \")\").c_str());\n\n    bool error = (write(to_external[1], v, strlen(v)) < 0);\n    if (error)\n    {\n\ty2debug (\"Error writing to external program %s: Couldn't send %s (%s)\", bin_file.c_str(), v, strerror (errno));\n\tterminateExternalProgram();\n    }\n    free(v);\n\n    // We send an additional linefeed. This makes it more conveniant for non\n    // Y2 programs, for example that shell can do a read to get one value. For\n    // Y2 programs it increases the readability if you want to dump and debug\n    // the whole stream.\n\n    // We MUST NOT trigger an error, if the sending of the linefeed is not\n    // successful. This sporadically happens after we send a module the last\n    // return just before the module has done its work and terminates. It then\n    // justs sends the result(..) message, and closes down without reading the\n    // linefeed. The pipe breaks down and the sending fails. But as long as we\n    // don't collect the process by calling wait4, we can still read the\n    // result (..) from the input pipe, which is very important. Otherwise the\n    // result value would be dropped.\n\n    write(to_external[1], \"\\n\", 1);\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::sendToExternal(const string& value)\n  {\n      if (!externalProgramOK())\n      {\n  \ty2error (\"External program %s died unexpectedly\", bin_file.c_str());\n      }\n  \n      char *v = NULL;\n  \n      if (is_non_y2)  v = strdup(value.c_str());   // no brackets\n      else            v = strdup((\"(\" + value + \")\").c_str());\n  \n      bool error = (write(to_external[1], v, strlen(v)) < 0);\n      if (error)\n      {\n  \ty2debug (\"Error writing to external program %s: Couldn't send %s (%s)\", bin_file.c_str(), v, strerror (errno));\n  \tterminateExternalProgram();\n      }\n      free(v);\n  \n      // We send an additional linefeed. This makes it more conveniant for non\n      // Y2 programs, for example that shell can do a read to get one value. For\n      // Y2 programs it increases the readability if you want to dump and debug\n      // the whole stream.\n  \n      // We MUST NOT trigger an error, if the sending of the linefeed is not\n      // successful. This sporadically happens after we send a module the last\n      // return just before the module has done its work and terminates. It then\n      // justs sends the result(..) message, and closes down without reading the\n      // linefeed. The pipe breaks down and the sending fails. But as long as we\n      // don't collect the process by calling wait4, we can still read the\n      // result (..) from the input pipe, which is very important. Otherwise the\n      // result value would be dropped.\n  \n      write(to_external[1], \"\\n\", 1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_interface->evaluate",
          "args": [
            "value"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "69-138",
          "snippet": "YCPValue Y2ProgramComponent::evaluate(const YCPValue& command)\n{\n    if (pid == -1)   // server component not yet started --> do it\n    {\n\tif (is_non_y2)   // this is a nony2 program like a shell and such like\n\t{\n\t    // Prepare options: argv[0] must be server component name,\n\t    // argv[1] must _NOT_ be 'stdio' like for real Y2 components (see below).\n\t    // If no options have been set so far via setServerOptions(),\n\t    // fill in argv[0] correctly.\n\n\t    int l_argc = 1 + (argc > 0 ? argc - 1 : 0);\n\t    char **l_argv = new char *[l_argc + 1];\n\n\t    l_argv[0] = (argc >= 1) ? argv[0] : strdup(name().c_str()); // component name\n\t    for (int arg = 1; arg < argc; arg++) l_argv[arg] = argv[arg];\n\t    l_argv[l_argc] = 0; // Terminate array\n\n\t    // launch program\n\t    launchExternalProgram(l_argv);\n\n\t    // NonY2 servers will not send arguments to the client (me).\n\t    // Therefore it is not necessary to receive something in this case.\n\n\t    if (argc < 1) free (l_argv[0]);\n\t    if (l_argv) delete[] l_argv;  // free l_argv\n\t}\n\telse   // this is a real liby2 component\n\t{\n\t    // Prepare options: argv[0] must be server component name,\n\t    // argv[1] must be 'stdio' in order to make the gf of the\n\t    // called component communicate via stdio, argv[2...] contains\n\t    // all further options. If no options have been set so far\n\t    // via setServerOptions(), fill in argv[0] correctly.\n\n\t    int l_argc = 3 + (argc > 0 ? argc - 1 : 0);\n\t    char **l_argv = new char *[l_argc + 1];\n\n\t    l_argv[0] = argc >= 1 ? argv[0] : strdup(name().c_str()); // component name\n\t    l_argv[1] = \"stdio\"; // I will speak to the server via his stdio\n\t    l_argv[2] = strdup(name().c_str());\n\t    for (int arg = 1; arg < argc; arg++) l_argv[arg+2] = argv[arg];\n\t    l_argv[l_argc] = 0; // Terminate array\n\n\t    // launch program\n\t    launchExternalProgram(l_argv);\n\n\t    // I am myself a module in this context. Therefore the server\n\t    // will send me my arguments. Since I initiated the session\n\t    // myself, I am not interested in these arguments.\n\n\t    if (receiveFromExternal().isNull())\n\t    {\n\t\ty2error (\"Couldn't launch external server %s\", name().c_str ());\n\t\treturn YCPNull ();\n\t    }\n\n\t    if (argc < 1) free (l_argv[0]);\n\t    free (l_argv[2]);\n\t    delete[] l_argv;  // free l_argv\n\t}\n    }\n\n    // send command\n    sendToExternal (command);\n\n    // get answer\n    YCPValue retval = receiveFromExternal();\n    return !retval.isNull() ? retval : YCPVoid();\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  YCPValue Y2ProgramComponent::evaluate(const YCPValue& command)\n  {\n      if (pid == -1)   // server component not yet started --> do it\n      {\n  \tif (is_non_y2)   // this is a nony2 program like a shell and such like\n  \t{\n  \t    // Prepare options: argv[0] must be server component name,\n  \t    // argv[1] must _NOT_ be 'stdio' like for real Y2 components (see below).\n  \t    // If no options have been set so far via setServerOptions(),\n  \t    // fill in argv[0] correctly.\n  \n  \t    int l_argc = 1 + (argc > 0 ? argc - 1 : 0);\n  \t    char **l_argv = new char *[l_argc + 1];\n  \n  \t    l_argv[0] = (argc >= 1) ? argv[0] : strdup(name().c_str()); // component name\n  \t    for (int arg = 1; arg < argc; arg++) l_argv[arg] = argv[arg];\n  \t    l_argv[l_argc] = 0; // Terminate array\n  \n  \t    // launch program\n  \t    launchExternalProgram(l_argv);\n  \n  \t    // NonY2 servers will not send arguments to the client (me).\n  \t    // Therefore it is not necessary to receive something in this case.\n  \n  \t    if (argc < 1) free (l_argv[0]);\n  \t    if (l_argv) delete[] l_argv;  // free l_argv\n  \t}\n  \telse   // this is a real liby2 component\n  \t{\n  \t    // Prepare options: argv[0] must be server component name,\n  \t    // argv[1] must be 'stdio' in order to make the gf of the\n  \t    // called component communicate via stdio, argv[2...] contains\n  \t    // all further options. If no options have been set so far\n  \t    // via setServerOptions(), fill in argv[0] correctly.\n  \n  \t    int l_argc = 3 + (argc > 0 ? argc - 1 : 0);\n  \t    char **l_argv = new char *[l_argc + 1];\n  \n  \t    l_argv[0] = argc >= 1 ? argv[0] : strdup(name().c_str()); // component name\n  \t    l_argv[1] = \"stdio\"; // I will speak to the server via his stdio\n  \t    l_argv[2] = strdup(name().c_str());\n  \t    for (int arg = 1; arg < argc; arg++) l_argv[arg+2] = argv[arg];\n  \t    l_argv[l_argc] = 0; // Terminate array\n  \n  \t    // launch program\n  \t    launchExternalProgram(l_argv);\n  \n  \t    // I am myself a module in this context. Therefore the server\n  \t    // will send me my arguments. Since I initiated the session\n  \t    // myself, I am not interested in these arguments.\n  \n  \t    if (receiveFromExternal().isNull())\n  \t    {\n  \t\ty2error (\"Couldn't launch external server %s\", name().c_str ());\n  \t\treturn YCPNull ();\n  \t    }\n  \n  \t    if (argc < 1) free (l_argv[0]);\n  \t    free (l_argv[2]);\n  \t    delete[] l_argv;  // free l_argv\n  \t}\n      }\n  \n      // send command\n      sendToExternal (command);\n  \n      // get answer\n      YCPValue retval = receiveFromExternal();\n      return !retval.isNull() ? retval : YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Got result from client component %s: %s\"",
            "name().c_str()",
            "retval->toString().c_str()"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retval->toString",
          "args": [],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "76-88",
          "snippet": "string\nY2Namespace::toString () const\n{\n    if (m_table == 0)\n    {\n\treturn \"<empty>\";\n    }\n\n    SymbolTable* t = m_table;\n    string s = t->toString ();\n\n    return s + symbolsToString ();\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  string\n  Y2Namespace::toString () const\n  {\n      if (m_table == 0)\n      {\n  \treturn \"<empty>\";\n      }\n  \n      SymbolTable* t = m_table;\n      string s = t->toString ();\n  \n      return s + symbolsToString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "166-169",
          "snippet": "string Y2ProgramComponent::name() const\n{\n    return component_name;\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  string Y2ProgramComponent::name() const\n  {\n      return component_name;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asTerm",
          "args": [
            "0"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->asTerm",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->isTerm",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "isTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "70-70",
          "snippet": "bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiveFromExternal",
          "args": [],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "receiveFromExternal",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "355-383",
          "snippet": "YCPValue Y2ProgramComponent::receiveFromExternal ()\n{\n    while (true)\n    {\n\tif (!externalProgramOK ())\n\t{\n\t    y2error (\"External program %s died unexpectedly\", bin_file.c_str ());\n\t    return YCPNull ();\n\t}\n\n\tYCodePtr c = parser.parse ();\n\t\n\tif (c == NULL || c->isError())\n\t{\n\t    y2error (\"External program %s returned invalid data. (No other error means no data at all)\", bin_file.c_str ());\n\t    return YCPNull ();\n\t}\n\t\n\t// evaluate, but not as constant\n\tYCPValue ret = c->evaluate (true);\n\tif (ret.isNull ())\n\t{\n\t    y2milestone (\"External program returned executable code, executing\");\n\t    ret = c->evaluate (false);\n\t}\n\n\treturn ret;\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  YCPValue Y2ProgramComponent::receiveFromExternal ()\n  {\n      while (true)\n      {\n  \tif (!externalProgramOK ())\n  \t{\n  \t    y2error (\"External program %s died unexpectedly\", bin_file.c_str ());\n  \t    return YCPNull ();\n  \t}\n  \n  \tYCodePtr c = parser.parse ();\n  \t\n  \tif (c == NULL || c->isError())\n  \t{\n  \t    y2error (\"External program %s returned invalid data. (No other error means no data at all)\", bin_file.c_str ());\n  \t    return YCPNull ();\n  \t}\n  \t\n  \t// evaluate, but not as constant\n  \tYCPValue ret = c->evaluate (true);\n  \tif (ret.isNull ())\n  \t{\n  \t    y2milestone (\"External program returned executable code, executing\");\n  \t    ret = c->evaluate (false);\n  \t}\n  \n  \treturn ret;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "argv[0]"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "launchExternalProgram",
          "args": [
            "argv"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "launchExternalProgram",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "264-332",
          "snippet": "void Y2ProgramComponent::launchExternalProgram (char **argv)\n{\n    y2debug (\"launchExternalProgram (%s, %s, ...)\", argv[0], argv[1]);\n    // Create socket-pair\n    int err;\n    err = pipe(to_external);\n    if (err != 0)\n\ty2error(\"pipe failed: %s\", strerror (errno));\n    err = pipe(from_external);\n    if (err != 0)\n\ty2error(\"pipe failed: %s\", strerror (errno));\n\n    // Create module process\n\n    if (0 == (pid = fork()))   // child process\n    {\n\n\t// Set component level for new program\n\tchar levelstring[32];\n\tsnprintf(levelstring, 32, \"%d\", level);\n\tsetenv(\"Y2LEVEL\", levelstring, 1); // 1: overwrite, if variable exists\n\n\t// child input\n\tExternalProgram::renumber_fd (to_external[0], 0); // set reading end to stdin\n\tclose(to_external[1]);     // writing end belongs to father process\n\n\t// child output\n        ExternalProgram::renumber_fd (from_external[1], 1); // set writing end to stdout\n\tclose(from_external[0]);   // reading end belongs to father process\n\n\t// Depending on whether it is a server or a client component\n\t// I prepare the arguments on a different way.\n\n\t// Call chroot if desired.\n\tif (chroot_path == \"\" || chroot_path == \"/\") {\n\t    //bnc#493152#c24\n\t    //y2debug (\"Going to execute %s\", bin_file.c_str ());\n\t} else {\n\t    /*y2debug (\"Going to execute %s with chroot %s\", bin_file.c_str (),\n\t\t     chroot_path.c_str ());*/\n\t    if (chroot (chroot_path.c_str ()) != 0) {\n\t\t/*y2error (\"Cannot chroot to %s: %s\", chroot_path.c_str (),\n\t\t\t strerror (errno));*/\n\t\t_exit (5);\n\t    }\n\n\t    chdir (\"/\");\n\t}\n\n\t// close all filedescriptors above stderr, bnc#501758\n\tfor (int i = getdtablesize () - 1; i > 2; --i) {\n\t    close (i);\n\t}\n\n\texecv (bin_file.c_str (), argv);\t// execute program\n\n\t// this code is only reached if exec failed\n\t//y2error (\"Cannot execute external program %s\", bin_file.c_str ());\n\t_exit (5); // No sense in returning! I am forked away!!\n    }\n\n    // father process\n\n    close(to_external[0]);   // reading end belongs to child process\n    close(from_external[1]); // writing end belongs to child process\n\n    // Prepare parser\n    parser.setInput(from_external[0], argv[0]);  // set parser input to child output\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::launchExternalProgram (char **argv)\n  {\n      y2debug (\"launchExternalProgram (%s, %s, ...)\", argv[0], argv[1]);\n      // Create socket-pair\n      int err;\n      err = pipe(to_external);\n      if (err != 0)\n  \ty2error(\"pipe failed: %s\", strerror (errno));\n      err = pipe(from_external);\n      if (err != 0)\n  \ty2error(\"pipe failed: %s\", strerror (errno));\n  \n      // Create module process\n  \n      if (0 == (pid = fork()))   // child process\n      {\n  \n  \t// Set component level for new program\n  \tchar levelstring[32];\n  \tsnprintf(levelstring, 32, \"%d\", level);\n  \tsetenv(\"Y2LEVEL\", levelstring, 1); // 1: overwrite, if variable exists\n  \n  \t// child input\n  \tExternalProgram::renumber_fd (to_external[0], 0); // set reading end to stdin\n  \tclose(to_external[1]);     // writing end belongs to father process\n  \n  \t// child output\n          ExternalProgram::renumber_fd (from_external[1], 1); // set writing end to stdout\n  \tclose(from_external[0]);   // reading end belongs to father process\n  \n  \t// Depending on whether it is a server or a client component\n  \t// I prepare the arguments on a different way.\n  \n  \t// Call chroot if desired.\n  \tif (chroot_path == \"\" || chroot_path == \"/\") {\n  \t    //bnc#493152#c24\n  \t    //y2debug (\"Going to execute %s\", bin_file.c_str ());\n  \t} else {\n  \t    /*y2debug (\"Going to execute %s with chroot %s\", bin_file.c_str (),\n  \t\t     chroot_path.c_str ());*/\n  \t    if (chroot (chroot_path.c_str ()) != 0) {\n  \t\t/*y2error (\"Cannot chroot to %s: %s\", chroot_path.c_str (),\n  \t\t\t strerror (errno));*/\n  \t\t_exit (5);\n  \t    }\n  \n  \t    chdir (\"/\");\n  \t}\n  \n  \t// close all filedescriptors above stderr, bnc#501758\n  \tfor (int i = getdtablesize () - 1; i > 2; --i) {\n  \t    close (i);\n  \t}\n  \n  \texecv (bin_file.c_str (), argv);\t// execute program\n  \n  \t// this code is only reached if exec failed\n  \t//y2error (\"Cannot execute external program %s\", bin_file.c_str ());\n  \t_exit (5); // No sense in returning! I am forked away!!\n      }\n  \n      // father process\n  \n      close(to_external[0]);   // reading end belongs to child process\n      close(from_external[1]); // writing end belongs to child process\n  \n      // Prepare parser\n      parser.setInput(from_external[0], argv[0]);  // set parser input to child output\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name().c_str()"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "argv[arg]"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "a->toString().c_str()"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "a->asString()->value().c_str()"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a->asString",
          "args": [],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "a->isString",
          "args": [],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arglist->value",
          "args": [
            "arg-1"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "(name().c_str())"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arglist->size",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arglist.isNull",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  YCPValue Y2ProgramComponent::doActualWork(const YCPList& arglist, Y2Component *user_interface)\n  {\n      int argc;      // this shadows the corresponding member variables for servers\n      char **argv;\n  \n      if (is_non_y2)   // this is a nony2 program like a shell and such like\n      {\n  \tint arg = 0;\n  \n  \t// Prepare arguments as command line parameters for program being called\n  \targc = !arglist.isNull() ? arglist->size() + 1 : 1;\n  \targv = new char *[argc+1];\n  \targv[0] = strdup((name().c_str()));\n  \targv[argc] = NULL;\n  \n  \tfor (arg = 1; arg < argc; arg++)\n  \t{\n  \t    YCPValue a = arglist->value(arg-1);\n  \t    if (a->isString())\n  \t    {\n  \t\targv[arg] = strdup(a->asString()->value().c_str());\n  \t    }\n  \t    else\n  \t    {\n  \t\targv[arg] = strdup(a->toString().c_str());\n  \t    }\n  \t}\n  \n  \t// launch component if not yet done\n  \tif (pid == -1) launchExternalProgram(argv);\n  \n  \tif (argv)\n  \t{\n  \t    for (arg = 0; arg < argc; arg++)\n  \t    {\n  \t\tif (argv[arg])\n  \t\t{\n  \t\t    free(argv[arg]);\n  \t\t}\n  \t    }\n  \t    delete[] argv;\n  \t}\n      }\n      else   // this is a real liby2 component\n      {\n  \t// send arguments via stdio\n  \targc = 4;   // name, -s\n  \targv = new char *[argc+1];\n  \targv[0] = strdup(name().c_str());\n  \targv[1] = argv[0];\n  \targv[2] = \"-s\";    // get arguments on stdin\n  \targv[3] = \"stdio\"; // communicate via stdio\n  \targv[argc] = NULL;\n  \n  \t// launch component if not yet done\n  \tif (pid == -1) launchExternalProgram(argv);\n  \n  \tsendToExternal(arglist);   // now send arguments\n  \n  \tif (argv)\n  \t{\n  \t    if (argv[0]) free(argv[0]);\n  \t    delete[] argv;\n  \t}\n      }\n  \n      // Communication loop with module. Module sends 'result(...)',\n      // when finished\n      YCPValue retval = YCPNull();\n      YCPValue value = YCPNull();\n  \n      while (!(value = receiveFromExternal()).isNull())\n      {\n  \tif (value->isTerm()\n  \t    && value->asTerm()->size() == 1\n  \t    && value->asTerm()->name() == \"result\")\n  \t{\n  \t    retval = value->asTerm()->value(0);\n  \t    y2debug (\"Got result from client component %s: %s\", name().c_str(), retval->toString().c_str());\n  \t    break;\n  \t}\n  \telse\n  \t{\n  \t    // Send this to the UI and get UI answer\n  \t    sendToExternal(user_interface->evaluate(value));\n  \t}\n      }\n  \n      return !retval.isNull() ? retval : YCPVoid();\n  }\n}"
  },
  {
    "function_name": "name",
    "container": "Y2ProgramComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
    "lines": "166-169",
    "snippet": "string Y2ProgramComponent::name() const\n{\n    return component_name;\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2ProgramComponent.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  string Y2ProgramComponent::name() const\n  {\n      return component_name;\n  }\n}"
  },
  {
    "function_name": "result",
    "container": "Y2ProgramComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
    "lines": "141-163",
    "snippet": "void Y2ProgramComponent::result(const YCPValue& result)\n{\n    // It may be, that no evaluate() call has been issued at all\n    // before the call to this function(). This is likely to happen\n    // in the context of the SCR. For each MountAgent() all it\n    // creates the component that handles the certain path. But\n    // if it may well be that some paths are not used in one\n    // run of YaST2. In that case no evaluate() for that agent\n    // has been issued. Therefore at this point the external\n    // program may not have been started after all. So we need\n    // to check, if it's running.\n    \n    if (pid != -1)\n    {\n\tYCPTerm resultterm(\"result\");\n\tresultterm->add(result);\n\tsendToExternal(resultterm);\n\n        y2milestone (\"Sending result: %s\", resultterm->toString ().c_str ());\n\n\tterminateExternalProgram();\n    }\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2ProgramComponent.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "terminateExternalProgram",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "terminateExternalProgram",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "335-352",
          "snippet": "void Y2ProgramComponent::terminateExternalProgram()\n{\n    // We do not really kill the program here. We assume\n    // that it is shut down gracefully and just close the\n    // pipes and collect the zombie process. The real termination\n    // thing is done by result() for server components and\n    // automatically in doActualWork() for client components.\n\n    if (pid >= 0)\n    {\n\tclose(to_external[1]);\n\tclose(from_external[0]);\n\n\t// FIXME: this does not really wait in case of signals\n\twaitpid(pid, 0, 0); // Wait for child to exit\n    }\n    pid = -1;\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::terminateExternalProgram()\n  {\n      // We do not really kill the program here. We assume\n      // that it is shut down gracefully and just close the\n      // pipes and collect the zombie process. The real termination\n      // thing is done by result() for server components and\n      // automatically in doActualWork() for client components.\n  \n      if (pid >= 0)\n      {\n  \tclose(to_external[1]);\n  \tclose(from_external[0]);\n  \n  \t// FIXME: this does not really wait in case of signals\n  \twaitpid(pid, 0, 0); // Wait for child to exit\n      }\n      pid = -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2milestone",
          "args": [
            "\"Sending result: %s\"",
            "resultterm->toString ().c_str ()"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resultterm->toString",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "76-88",
          "snippet": "string\nY2Namespace::toString () const\n{\n    if (m_table == 0)\n    {\n\treturn \"<empty>\";\n    }\n\n    SymbolTable* t = m_table;\n    string s = t->toString ();\n\n    return s + symbolsToString ();\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  string\n  Y2Namespace::toString () const\n  {\n      if (m_table == 0)\n      {\n  \treturn \"<empty>\";\n      }\n  \n      SymbolTable* t = m_table;\n      string s = t->toString ();\n  \n      return s + symbolsToString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sendToExternal",
          "args": [
            "resultterm"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "sendToExternal",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "392-427",
          "snippet": "void Y2ProgramComponent::sendToExternal(const string& value)\n{\n    if (!externalProgramOK())\n    {\n\ty2error (\"External program %s died unexpectedly\", bin_file.c_str());\n    }\n\n    char *v = NULL;\n\n    if (is_non_y2)  v = strdup(value.c_str());   // no brackets\n    else            v = strdup((\"(\" + value + \")\").c_str());\n\n    bool error = (write(to_external[1], v, strlen(v)) < 0);\n    if (error)\n    {\n\ty2debug (\"Error writing to external program %s: Couldn't send %s (%s)\", bin_file.c_str(), v, strerror (errno));\n\tterminateExternalProgram();\n    }\n    free(v);\n\n    // We send an additional linefeed. This makes it more conveniant for non\n    // Y2 programs, for example that shell can do a read to get one value. For\n    // Y2 programs it increases the readability if you want to dump and debug\n    // the whole stream.\n\n    // We MUST NOT trigger an error, if the sending of the linefeed is not\n    // successful. This sporadically happens after we send a module the last\n    // return just before the module has done its work and terminates. It then\n    // justs sends the result(..) message, and closes down without reading the\n    // linefeed. The pipe breaks down and the sending fails. But as long as we\n    // don't collect the process by calling wait4, we can still read the\n    // result (..) from the input pipe, which is very important. Otherwise the\n    // result value would be dropped.\n\n    write(to_external[1], \"\\n\", 1);\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::sendToExternal(const string& value)\n  {\n      if (!externalProgramOK())\n      {\n  \ty2error (\"External program %s died unexpectedly\", bin_file.c_str());\n      }\n  \n      char *v = NULL;\n  \n      if (is_non_y2)  v = strdup(value.c_str());   // no brackets\n      else            v = strdup((\"(\" + value + \")\").c_str());\n  \n      bool error = (write(to_external[1], v, strlen(v)) < 0);\n      if (error)\n      {\n  \ty2debug (\"Error writing to external program %s: Couldn't send %s (%s)\", bin_file.c_str(), v, strerror (errno));\n  \tterminateExternalProgram();\n      }\n      free(v);\n  \n      // We send an additional linefeed. This makes it more conveniant for non\n      // Y2 programs, for example that shell can do a read to get one value. For\n      // Y2 programs it increases the readability if you want to dump and debug\n      // the whole stream.\n  \n      // We MUST NOT trigger an error, if the sending of the linefeed is not\n      // successful. This sporadically happens after we send a module the last\n      // return just before the module has done its work and terminates. It then\n      // justs sends the result(..) message, and closes down without reading the\n      // linefeed. The pipe breaks down and the sending fails. But as long as we\n      // don't collect the process by calling wait4, we can still read the\n      // result (..) from the input pipe, which is very important. Otherwise the\n      // result value would be dropped.\n  \n      write(to_external[1], \"\\n\", 1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "resultterm->add",
          "args": [
            "result"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::result(const YCPValue& result)\n  {\n      // It may be, that no evaluate() call has been issued at all\n      // before the call to this function(). This is likely to happen\n      // in the context of the SCR. For each MountAgent() all it\n      // creates the component that handles the certain path. But\n      // if it may well be that some paths are not used in one\n      // run of YaST2. In that case no evaluate() for that agent\n      // has been issued. Therefore at this point the external\n      // program may not have been started after all. So we need\n      // to check, if it's running.\n      \n      if (pid != -1)\n      {\n  \tYCPTerm resultterm(\"result\");\n  \tresultterm->add(result);\n  \tsendToExternal(resultterm);\n  \n          y2milestone (\"Sending result: %s\", resultterm->toString ().c_str ());\n  \n  \tterminateExternalProgram();\n      }\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "Y2ProgramComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
    "lines": "69-138",
    "snippet": "YCPValue Y2ProgramComponent::evaluate(const YCPValue& command)\n{\n    if (pid == -1)   // server component not yet started --> do it\n    {\n\tif (is_non_y2)   // this is a nony2 program like a shell and such like\n\t{\n\t    // Prepare options: argv[0] must be server component name,\n\t    // argv[1] must _NOT_ be 'stdio' like for real Y2 components (see below).\n\t    // If no options have been set so far via setServerOptions(),\n\t    // fill in argv[0] correctly.\n\n\t    int l_argc = 1 + (argc > 0 ? argc - 1 : 0);\n\t    char **l_argv = new char *[l_argc + 1];\n\n\t    l_argv[0] = (argc >= 1) ? argv[0] : strdup(name().c_str()); // component name\n\t    for (int arg = 1; arg < argc; arg++) l_argv[arg] = argv[arg];\n\t    l_argv[l_argc] = 0; // Terminate array\n\n\t    // launch program\n\t    launchExternalProgram(l_argv);\n\n\t    // NonY2 servers will not send arguments to the client (me).\n\t    // Therefore it is not necessary to receive something in this case.\n\n\t    if (argc < 1) free (l_argv[0]);\n\t    if (l_argv) delete[] l_argv;  // free l_argv\n\t}\n\telse   // this is a real liby2 component\n\t{\n\t    // Prepare options: argv[0] must be server component name,\n\t    // argv[1] must be 'stdio' in order to make the gf of the\n\t    // called component communicate via stdio, argv[2...] contains\n\t    // all further options. If no options have been set so far\n\t    // via setServerOptions(), fill in argv[0] correctly.\n\n\t    int l_argc = 3 + (argc > 0 ? argc - 1 : 0);\n\t    char **l_argv = new char *[l_argc + 1];\n\n\t    l_argv[0] = argc >= 1 ? argv[0] : strdup(name().c_str()); // component name\n\t    l_argv[1] = \"stdio\"; // I will speak to the server via his stdio\n\t    l_argv[2] = strdup(name().c_str());\n\t    for (int arg = 1; arg < argc; arg++) l_argv[arg+2] = argv[arg];\n\t    l_argv[l_argc] = 0; // Terminate array\n\n\t    // launch program\n\t    launchExternalProgram(l_argv);\n\n\t    // I am myself a module in this context. Therefore the server\n\t    // will send me my arguments. Since I initiated the session\n\t    // myself, I am not interested in these arguments.\n\n\t    if (receiveFromExternal().isNull())\n\t    {\n\t\ty2error (\"Couldn't launch external server %s\", name().c_str ());\n\t\treturn YCPNull ();\n\t    }\n\n\t    if (argc < 1) free (l_argv[0]);\n\t    free (l_argv[2]);\n\t    delete[] l_argv;  // free l_argv\n\t}\n    }\n\n    // send command\n    sendToExternal (command);\n\n    // get answer\n    YCPValue retval = receiveFromExternal();\n    return !retval.isNull() ? retval : YCPVoid();\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2ProgramComponent.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "retval.isNull",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiveFromExternal",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "receiveFromExternal",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "355-383",
          "snippet": "YCPValue Y2ProgramComponent::receiveFromExternal ()\n{\n    while (true)\n    {\n\tif (!externalProgramOK ())\n\t{\n\t    y2error (\"External program %s died unexpectedly\", bin_file.c_str ());\n\t    return YCPNull ();\n\t}\n\n\tYCodePtr c = parser.parse ();\n\t\n\tif (c == NULL || c->isError())\n\t{\n\t    y2error (\"External program %s returned invalid data. (No other error means no data at all)\", bin_file.c_str ());\n\t    return YCPNull ();\n\t}\n\t\n\t// evaluate, but not as constant\n\tYCPValue ret = c->evaluate (true);\n\tif (ret.isNull ())\n\t{\n\t    y2milestone (\"External program returned executable code, executing\");\n\t    ret = c->evaluate (false);\n\t}\n\n\treturn ret;\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  YCPValue Y2ProgramComponent::receiveFromExternal ()\n  {\n      while (true)\n      {\n  \tif (!externalProgramOK ())\n  \t{\n  \t    y2error (\"External program %s died unexpectedly\", bin_file.c_str ());\n  \t    return YCPNull ();\n  \t}\n  \n  \tYCodePtr c = parser.parse ();\n  \t\n  \tif (c == NULL || c->isError())\n  \t{\n  \t    y2error (\"External program %s returned invalid data. (No other error means no data at all)\", bin_file.c_str ());\n  \t    return YCPNull ();\n  \t}\n  \t\n  \t// evaluate, but not as constant\n  \tYCPValue ret = c->evaluate (true);\n  \tif (ret.isNull ())\n  \t{\n  \t    y2milestone (\"External program returned executable code, executing\");\n  \t    ret = c->evaluate (false);\n  \t}\n  \n  \treturn ret;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sendToExternal",
          "args": [
            "command"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "sendToExternal",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "392-427",
          "snippet": "void Y2ProgramComponent::sendToExternal(const string& value)\n{\n    if (!externalProgramOK())\n    {\n\ty2error (\"External program %s died unexpectedly\", bin_file.c_str());\n    }\n\n    char *v = NULL;\n\n    if (is_non_y2)  v = strdup(value.c_str());   // no brackets\n    else            v = strdup((\"(\" + value + \")\").c_str());\n\n    bool error = (write(to_external[1], v, strlen(v)) < 0);\n    if (error)\n    {\n\ty2debug (\"Error writing to external program %s: Couldn't send %s (%s)\", bin_file.c_str(), v, strerror (errno));\n\tterminateExternalProgram();\n    }\n    free(v);\n\n    // We send an additional linefeed. This makes it more conveniant for non\n    // Y2 programs, for example that shell can do a read to get one value. For\n    // Y2 programs it increases the readability if you want to dump and debug\n    // the whole stream.\n\n    // We MUST NOT trigger an error, if the sending of the linefeed is not\n    // successful. This sporadically happens after we send a module the last\n    // return just before the module has done its work and terminates. It then\n    // justs sends the result(..) message, and closes down without reading the\n    // linefeed. The pipe breaks down and the sending fails. But as long as we\n    // don't collect the process by calling wait4, we can still read the\n    // result (..) from the input pipe, which is very important. Otherwise the\n    // result value would be dropped.\n\n    write(to_external[1], \"\\n\", 1);\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::sendToExternal(const string& value)\n  {\n      if (!externalProgramOK())\n      {\n  \ty2error (\"External program %s died unexpectedly\", bin_file.c_str());\n      }\n  \n      char *v = NULL;\n  \n      if (is_non_y2)  v = strdup(value.c_str());   // no brackets\n      else            v = strdup((\"(\" + value + \")\").c_str());\n  \n      bool error = (write(to_external[1], v, strlen(v)) < 0);\n      if (error)\n      {\n  \ty2debug (\"Error writing to external program %s: Couldn't send %s (%s)\", bin_file.c_str(), v, strerror (errno));\n  \tterminateExternalProgram();\n      }\n      free(v);\n  \n      // We send an additional linefeed. This makes it more conveniant for non\n      // Y2 programs, for example that shell can do a read to get one value. For\n      // Y2 programs it increases the readability if you want to dump and debug\n      // the whole stream.\n  \n      // We MUST NOT trigger an error, if the sending of the linefeed is not\n      // successful. This sporadically happens after we send a module the last\n      // return just before the module has done its work and terminates. It then\n      // justs sends the result(..) message, and closes down without reading the\n      // linefeed. The pipe breaks down and the sending fails. But as long as we\n      // don't collect the process by calling wait4, we can still read the\n      // result (..) from the input pipe, which is very important. Otherwise the\n      // result value would be dropped.\n  \n      write(to_external[1], \"\\n\", 1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "l_argv[2]"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "l_argv[0]"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Couldn't launch external server %s\"",
            "name().c_str ()"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "166-169",
          "snippet": "string Y2ProgramComponent::name() const\n{\n    return component_name;\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  string Y2ProgramComponent::name() const\n  {\n      return component_name;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "launchExternalProgram",
          "args": [
            "l_argv"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "launchExternalProgram",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "264-332",
          "snippet": "void Y2ProgramComponent::launchExternalProgram (char **argv)\n{\n    y2debug (\"launchExternalProgram (%s, %s, ...)\", argv[0], argv[1]);\n    // Create socket-pair\n    int err;\n    err = pipe(to_external);\n    if (err != 0)\n\ty2error(\"pipe failed: %s\", strerror (errno));\n    err = pipe(from_external);\n    if (err != 0)\n\ty2error(\"pipe failed: %s\", strerror (errno));\n\n    // Create module process\n\n    if (0 == (pid = fork()))   // child process\n    {\n\n\t// Set component level for new program\n\tchar levelstring[32];\n\tsnprintf(levelstring, 32, \"%d\", level);\n\tsetenv(\"Y2LEVEL\", levelstring, 1); // 1: overwrite, if variable exists\n\n\t// child input\n\tExternalProgram::renumber_fd (to_external[0], 0); // set reading end to stdin\n\tclose(to_external[1]);     // writing end belongs to father process\n\n\t// child output\n        ExternalProgram::renumber_fd (from_external[1], 1); // set writing end to stdout\n\tclose(from_external[0]);   // reading end belongs to father process\n\n\t// Depending on whether it is a server or a client component\n\t// I prepare the arguments on a different way.\n\n\t// Call chroot if desired.\n\tif (chroot_path == \"\" || chroot_path == \"/\") {\n\t    //bnc#493152#c24\n\t    //y2debug (\"Going to execute %s\", bin_file.c_str ());\n\t} else {\n\t    /*y2debug (\"Going to execute %s with chroot %s\", bin_file.c_str (),\n\t\t     chroot_path.c_str ());*/\n\t    if (chroot (chroot_path.c_str ()) != 0) {\n\t\t/*y2error (\"Cannot chroot to %s: %s\", chroot_path.c_str (),\n\t\t\t strerror (errno));*/\n\t\t_exit (5);\n\t    }\n\n\t    chdir (\"/\");\n\t}\n\n\t// close all filedescriptors above stderr, bnc#501758\n\tfor (int i = getdtablesize () - 1; i > 2; --i) {\n\t    close (i);\n\t}\n\n\texecv (bin_file.c_str (), argv);\t// execute program\n\n\t// this code is only reached if exec failed\n\t//y2error (\"Cannot execute external program %s\", bin_file.c_str ());\n\t_exit (5); // No sense in returning! I am forked away!!\n    }\n\n    // father process\n\n    close(to_external[0]);   // reading end belongs to child process\n    close(from_external[1]); // writing end belongs to child process\n\n    // Prepare parser\n    parser.setInput(from_external[0], argv[0]);  // set parser input to child output\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::launchExternalProgram (char **argv)\n  {\n      y2debug (\"launchExternalProgram (%s, %s, ...)\", argv[0], argv[1]);\n      // Create socket-pair\n      int err;\n      err = pipe(to_external);\n      if (err != 0)\n  \ty2error(\"pipe failed: %s\", strerror (errno));\n      err = pipe(from_external);\n      if (err != 0)\n  \ty2error(\"pipe failed: %s\", strerror (errno));\n  \n      // Create module process\n  \n      if (0 == (pid = fork()))   // child process\n      {\n  \n  \t// Set component level for new program\n  \tchar levelstring[32];\n  \tsnprintf(levelstring, 32, \"%d\", level);\n  \tsetenv(\"Y2LEVEL\", levelstring, 1); // 1: overwrite, if variable exists\n  \n  \t// child input\n  \tExternalProgram::renumber_fd (to_external[0], 0); // set reading end to stdin\n  \tclose(to_external[1]);     // writing end belongs to father process\n  \n  \t// child output\n          ExternalProgram::renumber_fd (from_external[1], 1); // set writing end to stdout\n  \tclose(from_external[0]);   // reading end belongs to father process\n  \n  \t// Depending on whether it is a server or a client component\n  \t// I prepare the arguments on a different way.\n  \n  \t// Call chroot if desired.\n  \tif (chroot_path == \"\" || chroot_path == \"/\") {\n  \t    //bnc#493152#c24\n  \t    //y2debug (\"Going to execute %s\", bin_file.c_str ());\n  \t} else {\n  \t    /*y2debug (\"Going to execute %s with chroot %s\", bin_file.c_str (),\n  \t\t     chroot_path.c_str ());*/\n  \t    if (chroot (chroot_path.c_str ()) != 0) {\n  \t\t/*y2error (\"Cannot chroot to %s: %s\", chroot_path.c_str (),\n  \t\t\t strerror (errno));*/\n  \t\t_exit (5);\n  \t    }\n  \n  \t    chdir (\"/\");\n  \t}\n  \n  \t// close all filedescriptors above stderr, bnc#501758\n  \tfor (int i = getdtablesize () - 1; i > 2; --i) {\n  \t    close (i);\n  \t}\n  \n  \texecv (bin_file.c_str (), argv);\t// execute program\n  \n  \t// this code is only reached if exec failed\n  \t//y2error (\"Cannot execute external program %s\", bin_file.c_str ());\n  \t_exit (5); // No sense in returning! I am forked away!!\n      }\n  \n      // father process\n  \n      close(to_external[0]);   // reading end belongs to child process\n      close(from_external[1]); // writing end belongs to child process\n  \n      // Prepare parser\n      parser.setInput(from_external[0], argv[0]);  // set parser input to child output\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name().c_str()"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name().c_str()"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "l_argv[0]"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name().c_str()"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  YCPValue Y2ProgramComponent::evaluate(const YCPValue& command)\n  {\n      if (pid == -1)   // server component not yet started --> do it\n      {\n  \tif (is_non_y2)   // this is a nony2 program like a shell and such like\n  \t{\n  \t    // Prepare options: argv[0] must be server component name,\n  \t    // argv[1] must _NOT_ be 'stdio' like for real Y2 components (see below).\n  \t    // If no options have been set so far via setServerOptions(),\n  \t    // fill in argv[0] correctly.\n  \n  \t    int l_argc = 1 + (argc > 0 ? argc - 1 : 0);\n  \t    char **l_argv = new char *[l_argc + 1];\n  \n  \t    l_argv[0] = (argc >= 1) ? argv[0] : strdup(name().c_str()); // component name\n  \t    for (int arg = 1; arg < argc; arg++) l_argv[arg] = argv[arg];\n  \t    l_argv[l_argc] = 0; // Terminate array\n  \n  \t    // launch program\n  \t    launchExternalProgram(l_argv);\n  \n  \t    // NonY2 servers will not send arguments to the client (me).\n  \t    // Therefore it is not necessary to receive something in this case.\n  \n  \t    if (argc < 1) free (l_argv[0]);\n  \t    if (l_argv) delete[] l_argv;  // free l_argv\n  \t}\n  \telse   // this is a real liby2 component\n  \t{\n  \t    // Prepare options: argv[0] must be server component name,\n  \t    // argv[1] must be 'stdio' in order to make the gf of the\n  \t    // called component communicate via stdio, argv[2...] contains\n  \t    // all further options. If no options have been set so far\n  \t    // via setServerOptions(), fill in argv[0] correctly.\n  \n  \t    int l_argc = 3 + (argc > 0 ? argc - 1 : 0);\n  \t    char **l_argv = new char *[l_argc + 1];\n  \n  \t    l_argv[0] = argc >= 1 ? argv[0] : strdup(name().c_str()); // component name\n  \t    l_argv[1] = \"stdio\"; // I will speak to the server via his stdio\n  \t    l_argv[2] = strdup(name().c_str());\n  \t    for (int arg = 1; arg < argc; arg++) l_argv[arg+2] = argv[arg];\n  \t    l_argv[l_argc] = 0; // Terminate array\n  \n  \t    // launch program\n  \t    launchExternalProgram(l_argv);\n  \n  \t    // I am myself a module in this context. Therefore the server\n  \t    // will send me my arguments. Since I initiated the session\n  \t    // myself, I am not interested in these arguments.\n  \n  \t    if (receiveFromExternal().isNull())\n  \t    {\n  \t\ty2error (\"Couldn't launch external server %s\", name().c_str ());\n  \t\treturn YCPNull ();\n  \t    }\n  \n  \t    if (argc < 1) free (l_argv[0]);\n  \t    free (l_argv[2]);\n  \t    delete[] l_argv;  // free l_argv\n  \t}\n      }\n  \n      // send command\n      sendToExternal (command);\n  \n      // get answer\n      YCPValue retval = receiveFromExternal();\n      return !retval.isNull() ? retval : YCPVoid();\n  }\n}"
  },
  {
    "function_name": "setServerOptions",
    "container": "Y2ProgramComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
    "lines": "62-66",
    "snippet": "void Y2ProgramComponent::setServerOptions (int argc, char **argv)\n{\n    this->argc = argc;\n    this->argv = argv;\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2ProgramComponent.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::setServerOptions (int argc, char **argv)\n  {\n      this->argc = argc;\n      this->argv = argv;\n  }\n}"
  },
  {
    "function_name": "~Y2ProgramComponent",
    "container": "Y2ProgramComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
    "lines": "55-59",
    "snippet": "Y2ProgramComponent::~Y2ProgramComponent ()\n{\n    if (pid >= 0)\n\tterminateExternalProgram();\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2ProgramComponent.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "terminateExternalProgram",
          "args": [],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "terminateExternalProgram",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "335-352",
          "snippet": "void Y2ProgramComponent::terminateExternalProgram()\n{\n    // We do not really kill the program here. We assume\n    // that it is shut down gracefully and just close the\n    // pipes and collect the zombie process. The real termination\n    // thing is done by result() for server components and\n    // automatically in doActualWork() for client components.\n\n    if (pid >= 0)\n    {\n\tclose(to_external[1]);\n\tclose(from_external[0]);\n\n\t// FIXME: this does not really wait in case of signals\n\twaitpid(pid, 0, 0); // Wait for child to exit\n    }\n    pid = -1;\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::terminateExternalProgram()\n  {\n      // We do not really kill the program here. We assume\n      // that it is shut down gracefully and just close the\n      // pipes and collect the zombie process. The real termination\n      // thing is done by result() for server components and\n      // automatically in doActualWork() for client components.\n  \n      if (pid >= 0)\n      {\n  \tclose(to_external[1]);\n  \tclose(from_external[0]);\n  \n  \t// FIXME: this does not really wait in case of signals\n  \twaitpid(pid, 0, 0); // Wait for child to exit\n      }\n      pid = -1;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  Y2ProgramComponent::~Y2ProgramComponent ()\n  {\n      if (pid >= 0)\n  \tterminateExternalProgram();\n  }\n}"
  },
  {
    "function_name": "Y2ProgramComponent",
    "container": "Y2ProgramComponent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
    "lines": "40-52",
    "snippet": "Y2ProgramComponent::Y2ProgramComponent (string chroot_path, string bin_file,\n\t\t\t\t\tconst char *component_name, bool non_y2,\n\t\t\t\t\tint level)\n    : chroot_path (chroot_path),\n      bin_file (bin_file),\n      is_non_y2 (non_y2),\n      component_name (component_name),\n      argc (0),\n      argv (0),\n      pid (-1),\n      level (level)\n{\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <ycp/YCPCode.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPTerm.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include \"Y2ProgramComponent.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  Y2ProgramComponent::Y2ProgramComponent (string chroot_path, string bin_file,\n  \t\t\t\t\tconst char *component_name, bool non_y2,\n  \t\t\t\t\tint level)\n      : chroot_path (chroot_path),\n        bin_file (bin_file),\n        is_non_y2 (non_y2),\n        component_name (component_name),\n        argc (0),\n        argv (0),\n        pid (-1),\n        level (level)\n  {\n  }\n}"
  }
]