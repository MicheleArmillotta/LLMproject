[
  {
    "function_name": "PBuiltinString ()\n{\n    // must be",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "1572-1624",
    "snippet": "PBuiltinString ()\n{\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n#define ETC 0, NULL, constTypePtr(), NULL\n#define ETCf   NULL, constTypePtr(), NULL\n\t{ \"+\",\t\t   \"string (string, string)\",\t\t(void *)s_plus1,                         ETC },\n\t{ \"+\",\t\t   \"string (string, integer)\",\t\t(void *)s_plus2,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, path)\",\t\t(void *)s_plus3,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, symbol)\",\t\t(void *)s_plus4,\t\t\t ETC },\n\t{ \"issubstring\",   \"boolean (string, string)\",\t\t(void *)s_issubstring,\t\t\t ETC },\n\t{ \"tostring\",\t   \"string (any)\",\t\t\t(void *)s_tostring,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer)\",\t\t\t(void *)s_tohexstring1,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer, integer)\",\t\t(void *)s_tohexstring2,                  ETC },\n\t{ \"isempty\",\t   \"boolean (string)\",\t\t\t(void *)s_isempty,\t\t\t ETC },\n\t{ \"size\",\t   \"integer (string)\",\t\t\t(void *)s_size,\t\t\t\t ETC },\n\t{ \"find\",\t   \"integer (string, string)\",\t\t(void *)s_find,\tDECL_DEPRECATED,        ETCf },\n\t{ \"search\",\t   \"integer (string, string)\",\t\t(void *)s_search,\t\t\t ETC },\n\t{ \"tolower\",\t   \"string (string)\",\t\t\t(void *)s_tolower,\t\t\t ETC },\n\t{ \"toupper\",\t   \"string (string)\",\t\t\t(void *)s_toupper,\t\t\t ETC },\n\t{ \"toascii\",\t   \"string (string)\",\t\t\t(void *)s_toascii,                       ETC },\n\t{ \"deletechars\",   \"string (string, string)\",\t\t(void *)s_removechars,\t\t\t ETC },\n\t{ \"filterchars\",   \"string (string, string)\",\t\t(void *)s_filterchars,\t\t\t ETC },\n\t{ \"findfirstnotof\",\"integer (string, string)\",\t\t(void *)s_findfirstnotof,\t\t ETC },\n\t{ \"findfirstof\",   \"integer (string, string)\",\t\t(void *)s_findfirstof,\t\t\t ETC },\n\t{ \"findlastof\",\t   \"integer (string, string)\",\t\t(void *)s_findlastof,\t\t\t ETC },\n\t{ \"findlastnotof\", \"integer (string, string)\",\t\t(void *)s_findlastnotof,\t\t ETC },\n\t{ \"substring\",\t   \"string (string, integer)\",\t\t(void *)s_substring1,                    ETC },\n\t{ \"substring\",\t   \"string (string, integer, integer)\",\t(void *)s_substring2,\t\t\t ETC },\n\t{ \"timestring\",\t   \"string (string, integer, boolean)\",\t(void *)s_timestring,\t\t\t ETC },\n\t{ \"mergestring\",   \"string (const list <string>, string)\", (void *)s_mergestring,\t\t ETC },\n\t{ \"crypt\",\t   \"string (string)\",\t\t\t(void *)s_crypt,\t\t\t ETC },\n\t{ \"cryptmd5\",\t   \"string (string)\",\t\t\t(void *)s_cryptmd5,\t\t\t ETC },\n\t{ \"cryptbigcrypt\", \"string (string)\",\t\t\t(void *)s_cryptbigcrypt,\t\t ETC },\n\t{ \"cryptblowfish\", \"string (string)\",\t\t\t(void *)s_cryptblowfish,                 ETC },\n\t{ \"cryptsha256\",   \"string (string)\",\t\t\t(void *)s_cryptsha256,                   ETC },\n\t{ \"cryptsha512\",   \"string (string)\",\t\t\t(void *)s_cryptsha512,                   ETC },\n\t{ \"regexpmatch\",   \"boolean (string, string)\",\t\t(void *)s_regexpmatch,\t\t\t ETC },\n\t{ \"regexppos\",\t   \"list<integer> (string, string)\",\t(void *)s_regexppos,\t\t\t ETC },\n\t{ \"regexpsub\",\t   \"string (string, string, string)\",\t(void *)s_regexpsub,\t\t\t ETC },\n\t{ \"regexptokenize\",\"list <string> (string, string)\",\t(void *)s_regexptokenize,\t\t ETC },\n\t{ \"dgettext\",\t   \"string (string, string)\",\t\t(void *)s_dgettext,\t\t\t ETC },\n\t{ \"dngettext\",\t   \"string (string, string, string, integer)\",\t(void *)s_dngettext,\t\t ETC },\n\t{ \"dpgettext\",\t   \"string (string, string, string)\",\t(void *)s_dpgettext,                     ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer)\",\t\t(void *)s_lsubstring1,                   ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer, integer)\",\t(void *)s_lsubstring2,                   ETC },\n\t{ NULL, NULL, NULL, ETC }\n#undef ETC\n#undef ETCf\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinString\", declarations);\n}",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern StaticDeclaration static_declarations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "registerDeclarations",
          "args": [
            "declarations);\n}"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nextern StaticDeclaration static_declarations;\n\nPBuiltinString ()\n{\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n#define ETC 0, NULL, constTypePtr(), NULL\n#define ETCf   NULL, constTypePtr(), NULL\n\t{ \"+\",\t\t   \"string (string, string)\",\t\t(void *)s_plus1,                         ETC },\n\t{ \"+\",\t\t   \"string (string, integer)\",\t\t(void *)s_plus2,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, path)\",\t\t(void *)s_plus3,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, symbol)\",\t\t(void *)s_plus4,\t\t\t ETC },\n\t{ \"issubstring\",   \"boolean (string, string)\",\t\t(void *)s_issubstring,\t\t\t ETC },\n\t{ \"tostring\",\t   \"string (any)\",\t\t\t(void *)s_tostring,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer)\",\t\t\t(void *)s_tohexstring1,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer, integer)\",\t\t(void *)s_tohexstring2,                  ETC },\n\t{ \"isempty\",\t   \"boolean (string)\",\t\t\t(void *)s_isempty,\t\t\t ETC },\n\t{ \"size\",\t   \"integer (string)\",\t\t\t(void *)s_size,\t\t\t\t ETC },\n\t{ \"find\",\t   \"integer (string, string)\",\t\t(void *)s_find,\tDECL_DEPRECATED,        ETCf },\n\t{ \"search\",\t   \"integer (string, string)\",\t\t(void *)s_search,\t\t\t ETC },\n\t{ \"tolower\",\t   \"string (string)\",\t\t\t(void *)s_tolower,\t\t\t ETC },\n\t{ \"toupper\",\t   \"string (string)\",\t\t\t(void *)s_toupper,\t\t\t ETC },\n\t{ \"toascii\",\t   \"string (string)\",\t\t\t(void *)s_toascii,                       ETC },\n\t{ \"deletechars\",   \"string (string, string)\",\t\t(void *)s_removechars,\t\t\t ETC },\n\t{ \"filterchars\",   \"string (string, string)\",\t\t(void *)s_filterchars,\t\t\t ETC },\n\t{ \"findfirstnotof\",\"integer (string, string)\",\t\t(void *)s_findfirstnotof,\t\t ETC },\n\t{ \"findfirstof\",   \"integer (string, string)\",\t\t(void *)s_findfirstof,\t\t\t ETC },\n\t{ \"findlastof\",\t   \"integer (string, string)\",\t\t(void *)s_findlastof,\t\t\t ETC },\n\t{ \"findlastnotof\", \"integer (string, string)\",\t\t(void *)s_findlastnotof,\t\t ETC },\n\t{ \"substring\",\t   \"string (string, integer)\",\t\t(void *)s_substring1,                    ETC },\n\t{ \"substring\",\t   \"string (string, integer, integer)\",\t(void *)s_substring2,\t\t\t ETC },\n\t{ \"timestring\",\t   \"string (string, integer, boolean)\",\t(void *)s_timestring,\t\t\t ETC },\n\t{ \"mergestring\",   \"string (const list <string>, string)\", (void *)s_mergestring,\t\t ETC },\n\t{ \"crypt\",\t   \"string (string)\",\t\t\t(void *)s_crypt,\t\t\t ETC },\n\t{ \"cryptmd5\",\t   \"string (string)\",\t\t\t(void *)s_cryptmd5,\t\t\t ETC },\n\t{ \"cryptbigcrypt\", \"string (string)\",\t\t\t(void *)s_cryptbigcrypt,\t\t ETC },\n\t{ \"cryptblowfish\", \"string (string)\",\t\t\t(void *)s_cryptblowfish,                 ETC },\n\t{ \"cryptsha256\",   \"string (string)\",\t\t\t(void *)s_cryptsha256,                   ETC },\n\t{ \"cryptsha512\",   \"string (string)\",\t\t\t(void *)s_cryptsha512,                   ETC },\n\t{ \"regexpmatch\",   \"boolean (string, string)\",\t\t(void *)s_regexpmatch,\t\t\t ETC },\n\t{ \"regexppos\",\t   \"list<integer> (string, string)\",\t(void *)s_regexppos,\t\t\t ETC },\n\t{ \"regexpsub\",\t   \"string (string, string, string)\",\t(void *)s_regexpsub,\t\t\t ETC },\n\t{ \"regexptokenize\",\"list <string> (string, string)\",\t(void *)s_regexptokenize,\t\t ETC },\n\t{ \"dgettext\",\t   \"string (string, string)\",\t\t(void *)s_dgettext,\t\t\t ETC },\n\t{ \"dngettext\",\t   \"string (string, string, string, integer)\",\t(void *)s_dngettext,\t\t ETC },\n\t{ \"dpgettext\",\t   \"string (string, string, string)\",\t(void *)s_dpgettext,                     ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer)\",\t\t(void *)s_lsubstring1,                   ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer, integer)\",\t(void *)s_lsubstring2,                   ETC },\n\t{ NULL, NULL, NULL, ETC }\n#undef ETC\n#undef ETCf\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinString\", declarations);\n}"
  },
  {
    "function_name": "CPString& d",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "1521-1567",
    "snippet": "gettext (const YCPString& domain, const YCPString& domain_path, const YCPString& text)\n{\n    /**\n     * @builtin dpgettext\n     * @short Translates the text using the given text domain and path\n     * @description\n     * Translates the text using the given text domain into\n     * the current language and path of localization .\n     * Path of localization is same than dirname in function bindtextdomain()\n     *\n     * This is a special case builtin not intended for general use.\n     * See _() instead.\n     *\n     * @param string textdomain\n     * @param string dirname\n     * @param string text\n     * @return string\n     * @usage dpgettext (\"base\", \"/texdomain/path\", \"No\") -> \"Nie\"\n     */\n\n    if ((domain.isNull () || domain->isVoid ()) ||\n\t(domain_path.isNull () || domain_path->isVoid ()) ||\n\t(text.isNull () || text->isVoid ())) \n    {\n\treturn YCPNull ();\n    }\n\n    // initialize text domain if not done so\n    string dom = domain->value ();\n    string dom_path = domain_path->value ();\n\n    // check if domain exist\n    // it is important to bind domain back (LOCALEDIR) \n    // if it is already binded\n    bool known_domain = false;\n    if (YLocale::findDomain(dom))\n\tknown_domain = true;\n\n    YLocale::bindDomainDir (dom, dom_path);\n    string result = dgettext (dom.c_str(), text->value().c_str());\n    // if it is known domain bind it back to LOCALEDIR\n    if (known_domain)\n\tYLocale::bindDomainDir (dom, LOCALEDIR);\n\n    return YCPString (result);\n}\n\n\n\n\nYCPBuiltinStrin",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\n\n\n\nYCP",
          "args": [
            "iltinS"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir (dom, LOCALEDIR);",
          "args": [
            "r",
            "urn YCPSt"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "), text-",
          "args": [
            "alue().c_st",
            "));\n    // if it is k"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "));\n    // if it is",
          "args": [],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "));\n    //",
          "args": [],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue",
          "args": [],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "asValue",
          "container": "YCPElementRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPElement.cc",
          "lines": "54-58",
          "snippet": "YCPValue\nYCPElementRep::asValue() const\n{\n    return YCPValue(static_cast<const YCPValueRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPValue.h\"",
            "#include \"ycp/YCPElement.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPValue.h\"\n#include \"ycp/YCPElement.h\"\n#include \"ycp/y2log.h\"\n\nYCPElementRep {\n  YCPValue\n  YCPElementRep::asValue() const\n  {\n      return YCPValue(static_cast<const YCPValueRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ir (dom, dom_path);",
          "args": [
            "str",
            "g result"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dom))\n\tknown_domain",
          "args": [
            "= t"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\n    // check i",
          "args": [],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string dom_",
          "args": [],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "// i",
          "args": [],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n\treturn",
          "args": [],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xt->isVoid",
          "args": [],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") || domain_path->",
          "args": [],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "|",
          "args": [],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain->isVoi",
          "args": [],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\ngettext (const YCPString& domain, const YCPString& domain_path, const YCPString& text)\n{\n    /**\n     * @builtin dpgettext\n     * @short Translates the text using the given text domain and path\n     * @description\n     * Translates the text using the given text domain into\n     * the current language and path of localization .\n     * Path of localization is same than dirname in function bindtextdomain()\n     *\n     * This is a special case builtin not intended for general use.\n     * See _() instead.\n     *\n     * @param string textdomain\n     * @param string dirname\n     * @param string text\n     * @return string\n     * @usage dpgettext (\"base\", \"/texdomain/path\", \"No\") -> \"Nie\"\n     */\n\n    if ((domain.isNull () || domain->isVoid ()) ||\n\t(domain_path.isNull () || domain_path->isVoid ()) ||\n\t(text.isNull () || text->isVoid ())) \n    {\n\treturn YCPNull ();\n    }\n\n    // initialize text domain if not done so\n    string dom = domain->value ();\n    string dom_path = domain_path->value ();\n\n    // check if domain exist\n    // it is important to bind domain back (LOCALEDIR) \n    // if it is already binded\n    bool known_domain = false;\n    if (YLocale::findDomain(dom))\n\tknown_domain = true;\n\n    YLocale::bindDomainDir (dom, dom_path);\n    string result = dgettext (dom.c_str(), text->value().c_str());\n    // if it is known domain bind it back to LOCALEDIR\n    if (known_domain)\n\tYLocale::bindDomainDir (dom, LOCALEDIR);\n\n    return YCPString (result);\n}\n\n\n\n\nYCPBuiltinStrin"
  },
  {
    "function_name": "CPString& d",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "1466-1518",
    "snippet": "gettext (const YCPString& domain, const YCPString& singular, const YCPString& plural, const YCPInteger& count)\n{\n    /**\n     * @operator _(string singular, string plural, integer value) -> string\n     * Translates the text using a locale-aware plural form handling and the \n     * current textdomain. The chosen form of the translation depends \n     * on the <tt>value</tt>.\n     *\n     * Example <pre>\n     * _(\"%1 File\", \"%1 Files\", 2) -> \"%1 soubory\"\n     * </pre>\n     */\n\n    /**\n     * @builtin dngettext\n     * @short Translates the text using a locale-aware plural form handling\n     * @description\n     * Translates the text using a locale-aware plural form handling using\n     * the given textdomain.\n     *\n     * The chosen form of the translation depend on the <tt>value</tt>.\n     *\n     * This is a special case builtin not intended for general use.\n     * See _() instead.\n     *\n     * @param string textdomain\n     * @param string singular\n     * @param string plural\n     * @param integer value\n     * @return string\n     *\n     * @usage dngettext (\"base\", \"%1 File\", \"%1 Files\", 2) -> \"%1 soubory\"\n     */\n\n    if (domain.isNull () || domain->isVoid ()) \n    {\n\treturn YCPNull ();\n    }\n\n    // initialize text domain if not done so\n    string dom = domain->value ();    \n    YLocale::ensureBindDomain (dom);\n    \n    if (singular.isNull () || singular->isVoid ()\n\t|| plural.isNull () || plural->isVoid ()\n\t|| count.isNull () || count->isVoid ())\n    {\n\treturn YCPNull ();\n    }\n    \n    return YCPString (dngettext (domain->value().c_str(), singular->value().c_str(), plural->value().c_str(), count->value()));\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(domain-",
          "args": [
            "alue().c_str(), singular->value().c_str(), plural->value().c_str(), count->value()));\n}\n\n\nstatic YCPVal"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue().c_",
          "args": [
            "r(), singular->value().",
            "str(), plural->value().c_",
            "r(), count->value()));",
            "static YCPVa"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static YCP",
          "args": [],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r",
          "args": [],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "PBuiltinString ()\n{\n    // must be",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "1572-1624",
          "snippet": "PBuiltinString ()\n{\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n#define ETC 0, NULL, constTypePtr(), NULL\n#define ETCf   NULL, constTypePtr(), NULL\n\t{ \"+\",\t\t   \"string (string, string)\",\t\t(void *)s_plus1,                         ETC },\n\t{ \"+\",\t\t   \"string (string, integer)\",\t\t(void *)s_plus2,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, path)\",\t\t(void *)s_plus3,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, symbol)\",\t\t(void *)s_plus4,\t\t\t ETC },\n\t{ \"issubstring\",   \"boolean (string, string)\",\t\t(void *)s_issubstring,\t\t\t ETC },\n\t{ \"tostring\",\t   \"string (any)\",\t\t\t(void *)s_tostring,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer)\",\t\t\t(void *)s_tohexstring1,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer, integer)\",\t\t(void *)s_tohexstring2,                  ETC },\n\t{ \"isempty\",\t   \"boolean (string)\",\t\t\t(void *)s_isempty,\t\t\t ETC },\n\t{ \"size\",\t   \"integer (string)\",\t\t\t(void *)s_size,\t\t\t\t ETC },\n\t{ \"find\",\t   \"integer (string, string)\",\t\t(void *)s_find,\tDECL_DEPRECATED,        ETCf },\n\t{ \"search\",\t   \"integer (string, string)\",\t\t(void *)s_search,\t\t\t ETC },\n\t{ \"tolower\",\t   \"string (string)\",\t\t\t(void *)s_tolower,\t\t\t ETC },\n\t{ \"toupper\",\t   \"string (string)\",\t\t\t(void *)s_toupper,\t\t\t ETC },\n\t{ \"toascii\",\t   \"string (string)\",\t\t\t(void *)s_toascii,                       ETC },\n\t{ \"deletechars\",   \"string (string, string)\",\t\t(void *)s_removechars,\t\t\t ETC },\n\t{ \"filterchars\",   \"string (string, string)\",\t\t(void *)s_filterchars,\t\t\t ETC },\n\t{ \"findfirstnotof\",\"integer (string, string)\",\t\t(void *)s_findfirstnotof,\t\t ETC },\n\t{ \"findfirstof\",   \"integer (string, string)\",\t\t(void *)s_findfirstof,\t\t\t ETC },\n\t{ \"findlastof\",\t   \"integer (string, string)\",\t\t(void *)s_findlastof,\t\t\t ETC },\n\t{ \"findlastnotof\", \"integer (string, string)\",\t\t(void *)s_findlastnotof,\t\t ETC },\n\t{ \"substring\",\t   \"string (string, integer)\",\t\t(void *)s_substring1,                    ETC },\n\t{ \"substring\",\t   \"string (string, integer, integer)\",\t(void *)s_substring2,\t\t\t ETC },\n\t{ \"timestring\",\t   \"string (string, integer, boolean)\",\t(void *)s_timestring,\t\t\t ETC },\n\t{ \"mergestring\",   \"string (const list <string>, string)\", (void *)s_mergestring,\t\t ETC },\n\t{ \"crypt\",\t   \"string (string)\",\t\t\t(void *)s_crypt,\t\t\t ETC },\n\t{ \"cryptmd5\",\t   \"string (string)\",\t\t\t(void *)s_cryptmd5,\t\t\t ETC },\n\t{ \"cryptbigcrypt\", \"string (string)\",\t\t\t(void *)s_cryptbigcrypt,\t\t ETC },\n\t{ \"cryptblowfish\", \"string (string)\",\t\t\t(void *)s_cryptblowfish,                 ETC },\n\t{ \"cryptsha256\",   \"string (string)\",\t\t\t(void *)s_cryptsha256,                   ETC },\n\t{ \"cryptsha512\",   \"string (string)\",\t\t\t(void *)s_cryptsha512,                   ETC },\n\t{ \"regexpmatch\",   \"boolean (string, string)\",\t\t(void *)s_regexpmatch,\t\t\t ETC },\n\t{ \"regexppos\",\t   \"list<integer> (string, string)\",\t(void *)s_regexppos,\t\t\t ETC },\n\t{ \"regexpsub\",\t   \"string (string, string, string)\",\t(void *)s_regexpsub,\t\t\t ETC },\n\t{ \"regexptokenize\",\"list <string> (string, string)\",\t(void *)s_regexptokenize,\t\t ETC },\n\t{ \"dgettext\",\t   \"string (string, string)\",\t\t(void *)s_dgettext,\t\t\t ETC },\n\t{ \"dngettext\",\t   \"string (string, string, string, integer)\",\t(void *)s_dngettext,\t\t ETC },\n\t{ \"dpgettext\",\t   \"string (string, string, string)\",\t(void *)s_dpgettext,                     ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer)\",\t\t(void *)s_lsubstring1,                   ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer, integer)\",\t(void *)s_lsubstring2,                   ETC },\n\t{ NULL, NULL, NULL, ETC }\n#undef ETC\n#undef ETCf\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinString\", declarations);\n}",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern StaticDeclaration static_declarations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nextern StaticDeclaration static_declarations;\n\nPBuiltinString ()\n{\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n#define ETC 0, NULL, constTypePtr(), NULL\n#define ETCf   NULL, constTypePtr(), NULL\n\t{ \"+\",\t\t   \"string (string, string)\",\t\t(void *)s_plus1,                         ETC },\n\t{ \"+\",\t\t   \"string (string, integer)\",\t\t(void *)s_plus2,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, path)\",\t\t(void *)s_plus3,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, symbol)\",\t\t(void *)s_plus4,\t\t\t ETC },\n\t{ \"issubstring\",   \"boolean (string, string)\",\t\t(void *)s_issubstring,\t\t\t ETC },\n\t{ \"tostring\",\t   \"string (any)\",\t\t\t(void *)s_tostring,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer)\",\t\t\t(void *)s_tohexstring1,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer, integer)\",\t\t(void *)s_tohexstring2,                  ETC },\n\t{ \"isempty\",\t   \"boolean (string)\",\t\t\t(void *)s_isempty,\t\t\t ETC },\n\t{ \"size\",\t   \"integer (string)\",\t\t\t(void *)s_size,\t\t\t\t ETC },\n\t{ \"find\",\t   \"integer (string, string)\",\t\t(void *)s_find,\tDECL_DEPRECATED,        ETCf },\n\t{ \"search\",\t   \"integer (string, string)\",\t\t(void *)s_search,\t\t\t ETC },\n\t{ \"tolower\",\t   \"string (string)\",\t\t\t(void *)s_tolower,\t\t\t ETC },\n\t{ \"toupper\",\t   \"string (string)\",\t\t\t(void *)s_toupper,\t\t\t ETC },\n\t{ \"toascii\",\t   \"string (string)\",\t\t\t(void *)s_toascii,                       ETC },\n\t{ \"deletechars\",   \"string (string, string)\",\t\t(void *)s_removechars,\t\t\t ETC },\n\t{ \"filterchars\",   \"string (string, string)\",\t\t(void *)s_filterchars,\t\t\t ETC },\n\t{ \"findfirstnotof\",\"integer (string, string)\",\t\t(void *)s_findfirstnotof,\t\t ETC },\n\t{ \"findfirstof\",   \"integer (string, string)\",\t\t(void *)s_findfirstof,\t\t\t ETC },\n\t{ \"findlastof\",\t   \"integer (string, string)\",\t\t(void *)s_findlastof,\t\t\t ETC },\n\t{ \"findlastnotof\", \"integer (string, string)\",\t\t(void *)s_findlastnotof,\t\t ETC },\n\t{ \"substring\",\t   \"string (string, integer)\",\t\t(void *)s_substring1,                    ETC },\n\t{ \"substring\",\t   \"string (string, integer, integer)\",\t(void *)s_substring2,\t\t\t ETC },\n\t{ \"timestring\",\t   \"string (string, integer, boolean)\",\t(void *)s_timestring,\t\t\t ETC },\n\t{ \"mergestring\",   \"string (const list <string>, string)\", (void *)s_mergestring,\t\t ETC },\n\t{ \"crypt\",\t   \"string (string)\",\t\t\t(void *)s_crypt,\t\t\t ETC },\n\t{ \"cryptmd5\",\t   \"string (string)\",\t\t\t(void *)s_cryptmd5,\t\t\t ETC },\n\t{ \"cryptbigcrypt\", \"string (string)\",\t\t\t(void *)s_cryptbigcrypt,\t\t ETC },\n\t{ \"cryptblowfish\", \"string (string)\",\t\t\t(void *)s_cryptblowfish,                 ETC },\n\t{ \"cryptsha256\",   \"string (string)\",\t\t\t(void *)s_cryptsha256,                   ETC },\n\t{ \"cryptsha512\",   \"string (string)\",\t\t\t(void *)s_cryptsha512,                   ETC },\n\t{ \"regexpmatch\",   \"boolean (string, string)\",\t\t(void *)s_regexpmatch,\t\t\t ETC },\n\t{ \"regexppos\",\t   \"list<integer> (string, string)\",\t(void *)s_regexppos,\t\t\t ETC },\n\t{ \"regexpsub\",\t   \"string (string, string, string)\",\t(void *)s_regexpsub,\t\t\t ETC },\n\t{ \"regexptokenize\",\"list <string> (string, string)\",\t(void *)s_regexptokenize,\t\t ETC },\n\t{ \"dgettext\",\t   \"string (string, string)\",\t\t(void *)s_dgettext,\t\t\t ETC },\n\t{ \"dngettext\",\t   \"string (string, string, string, integer)\",\t(void *)s_dngettext,\t\t ETC },\n\t{ \"dpgettext\",\t   \"string (string, string, string)\",\t(void *)s_dpgettext,                     ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer)\",\t\t(void *)s_lsubstring1,                   ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer, integer)\",\t(void *)s_lsubstring2,                   ETC },\n\t{ NULL, NULL, NULL, ETC }\n#undef ETC\n#undef ETCf\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinString\", declarations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "destroy",
          "container": "YCPElementRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPElement.cc",
          "lines": "37-45",
          "snippet": "void\nYCPElementRep::destroy() const\n{\n    reference_counter--;\n    if (reference_counter == 0)\n\tdelete this;\n    else if (reference_counter < 0)\n\ty2internal(\"Negative reference counter\");\n}",
          "includes": [
            "#include \"ycp/YCPValue.h\"",
            "#include \"ycp/YCPElement.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPValue.h\"\n#include \"ycp/YCPElement.h\"\n#include \"ycp/y2log.h\"\n\nYCPElementRep {\n  void\n  YCPElementRep::destroy() const\n  {\n      reference_counter--;\n      if (reference_counter == 0)\n  \tdelete this;\n      else if (reference_counter < 0)\n  \ty2internal(\"Negative reference counter\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n\treturn Y",
          "args": [],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ount->isVoid",
          "args": [],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "| count.isNull",
          "args": [],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plural->isVoi",
          "args": [],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "|| plural.isNul",
          "args": [],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "| singular->isV",
          "args": [],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omain (dom);\n    \n    if",
          "args": [
            "ing"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YLocale",
          "args": [],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YLocale",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "519-523",
          "snippet": "string\nYLocale::toString() const\n{\n    return \"_(\\\"\" + string (m_locale) + \"\\\")\";\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYLocale {\n  string\n  YLocale::toString() const\n  {\n      return \"_(\\\"\" + string (m_locale) + \"\\\")\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "// i",
          "args": [],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n\treturn",
          "args": [],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain->isVoi",
          "args": [],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\ngettext (const YCPString& domain, const YCPString& singular, const YCPString& plural, const YCPInteger& count)\n{\n    /**\n     * @operator _(string singular, string plural, integer value) -> string\n     * Translates the text using a locale-aware plural form handling and the \n     * current textdomain. The chosen form of the translation depends \n     * on the <tt>value</tt>.\n     *\n     * Example <pre>\n     * _(\"%1 File\", \"%1 Files\", 2) -> \"%1 soubory\"\n     * </pre>\n     */\n\n    /**\n     * @builtin dngettext\n     * @short Translates the text using a locale-aware plural form handling\n     * @description\n     * Translates the text using a locale-aware plural form handling using\n     * the given textdomain.\n     *\n     * The chosen form of the translation depend on the <tt>value</tt>.\n     *\n     * This is a special case builtin not intended for general use.\n     * See _() instead.\n     *\n     * @param string textdomain\n     * @param string singular\n     * @param string plural\n     * @param integer value\n     * @return string\n     *\n     * @usage dngettext (\"base\", \"%1 File\", \"%1 Files\", 2) -> \"%1 soubory\"\n     */\n\n    if (domain.isNull () || domain->isVoid ()) \n    {\n\treturn YCPNull ();\n    }\n\n    // initialize text domain if not done so\n    string dom = domain->value ();    \n    YLocale::ensureBindDomain (dom);\n    \n    if (singular.isNull () || singular->isVoid ()\n\t|| plural.isNull () || plural->isVoid ()\n\t|| count.isNull () || count->isVoid ())\n    {\n\treturn YCPNull ();\n    }\n    \n    return YCPString (dngettext (domain->value().c_str(), singular->value().c_str(), plural->value().c_str(), count->value()));\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "PString& d",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "1420-1463",
    "snippet": "ettext (const YCPString& domain, const YCPString& text)\n{\n    /**\n     * @operator _(string text) -> string\n     * Translates the text using the current textdomain. \n     *\n     * Example <pre>\n     * _(\"File\") -> \"Soubor\"\n     * </pre>\n     */\n\n    /**\n     * @builtin dgettext\n     * @short Translates the text using the given text domain\n     * @description\n     * Translates the text using the given text domain into\n     * the current language.\n     *\n     * This is a special case builtin not intended for general use.\n     * See _() instead.\n     *\n     * @param string textdomain\n     * @param string text\n     * @return string\n     * @usage dgettext (\"base\", \"No\") -> \"Nie\"\n     */\n\n    if (domain.isNull () || domain->isVoid ()) \n    {\n\treturn YCPNull ();\n    }\n\n    // initialize text domain if not done so\n    string dom = domain->value ();    \n    YLocale::ensureBindDomain (dom);\n    \n    if (text.isNull () || text->isVoid ())\n    {\n\treturn YCPNull ();\n    }\n    \n    return YCPString (dgettext (dom.c_str(), text->value().c_str()));\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(dom.c_st",
          "args": [
            "), text->value().c_str()));\n}\n\n\nstatic YCPVal"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "), text-",
          "args": [
            "alue().c_st",
            ")));\n}\n\n\nstatic YCPVa"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")));\n}\n\n\nstatic YCP",
          "args": [],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")));\n}\n\n\nst",
          "args": [],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue",
          "args": [],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "asValue",
          "container": "YCPElementRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPElement.cc",
          "lines": "54-58",
          "snippet": "YCPValue\nYCPElementRep::asValue() const\n{\n    return YCPValue(static_cast<const YCPValueRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPValue.h\"",
            "#include \"ycp/YCPElement.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPValue.h\"\n#include \"ycp/YCPElement.h\"\n#include \"ycp/y2log.h\"\n\nYCPElementRep {\n  YCPValue\n  YCPElementRep::asValue() const\n  {\n      return YCPValue(static_cast<const YCPValueRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n\treturn Y",
          "args": [],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xt->isVoid",
          "args": [],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "omain (dom);\n    \n    if",
          "args": [
            "ext"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YLocale",
          "args": [],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YLocale",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "519-523",
          "snippet": "string\nYLocale::toString() const\n{\n    return \"_(\\\"\" + string (m_locale) + \"\\\")\";\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYLocale {\n  string\n  YLocale::toString() const\n  {\n      return \"_(\\\"\" + string (m_locale) + \"\\\")\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "// i",
          "args": [],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n\treturn",
          "args": [],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain->isVoi",
          "args": [],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nettext (const YCPString& domain, const YCPString& text)\n{\n    /**\n     * @operator _(string text) -> string\n     * Translates the text using the current textdomain. \n     *\n     * Example <pre>\n     * _(\"File\") -> \"Soubor\"\n     * </pre>\n     */\n\n    /**\n     * @builtin dgettext\n     * @short Translates the text using the given text domain\n     * @description\n     * Translates the text using the given text domain into\n     * the current language.\n     *\n     * This is a special case builtin not intended for general use.\n     * See _() instead.\n     *\n     * @param string textdomain\n     * @param string text\n     * @return string\n     * @usage dgettext (\"base\", \"No\") -> \"Nie\"\n     */\n\n    if (domain.isNull () || domain->isVoid ()) \n    {\n\treturn YCPNull ();\n    }\n\n    // initialize text domain if not done so\n    string dom = domain->value ();    \n    YLocale::ensureBindDomain (dom);\n    \n    if (text.isNull () || text->isVoid ())\n    {\n\treturn YCPNull ();\n    }\n    \n    return YCPString (dgettext (dom.c_str(), text->value().c_str()));\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "YCPString& or",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "1389-1417",
    "snippet": "yptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stati",
          "args": [],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on using",
          "args": [
            "a512 failed\");\n        return YC"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n    el",
          "args": [
            "{\n\ty"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ted, SHA51",
          "args": [
            "&encrypted",
            "return YC"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string encry",
          "args": [],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing une",
          "args": [],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return YCPNull",
          "args": [],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nyptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "YCPString& or",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "1358-1386",
    "snippet": "yptsha256(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha256\n     * @short Encrypts a string with sha256\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha256\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha256 (\"readable\") -> \"$5$keev8D8I$kZdbw1WYM7XJtn4cpl1S3QtoKXnxIIFVSqwadMAGLE3\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA256, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha256 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stati",
          "args": [],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on using",
          "args": [
            "a256 failed\");\n        return YC"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n    el",
          "args": [
            "{\n\ty"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ted, SHA25",
          "args": [
            "&encrypted",
            "return YC"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string encry",
          "args": [],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing une",
          "args": [],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return YCPNull",
          "args": [],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nyptsha256(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha256\n     * @short Encrypts a string with sha256\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha256\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha256 (\"readable\") -> \"$5$keev8D8I$kZdbw1WYM7XJtn4cpl1S3QtoKXnxIIFVSqwadMAGLE3\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA256, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha256 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "t YCPString& or",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "1327-1355",
    "snippet": "ryptblowfish(const YCPString& original)\n{\n    /**\n     * @builtin cryptblowfish\n     * @short Encrypts a string with blowfish\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using blowfish\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptblowfish (\"readable\") -> \"$2a$05$B3lAUExB.Bqpy8Pq0TpZt.s7EydrmxJRuhOZR04YG01ptwOUR147C\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, BLOWFISH, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using blowfish failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stati",
          "args": [],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on using",
          "args": [
            "owfish failed\");\n        return YC"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n    el",
          "args": [
            "{\n\ty"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ted, BLOWF",
          "args": [
            "H, &encrypt",
            "))",
            "return YC"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string encry",
          "args": [],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing une",
          "args": [],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return YCPNull",
          "args": [],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nryptblowfish(const YCPString& original)\n{\n    /**\n     * @builtin cryptblowfish\n     * @short Encrypts a string with blowfish\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using blowfish\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptblowfish (\"readable\") -> \"$2a$05$B3lAUExB.Bqpy8Pq0TpZt.s7EydrmxJRuhOZR04YG01ptwOUR147C\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, BLOWFISH, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using blowfish failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "t YCPString& or",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "1296-1324",
    "snippet": "ryptbigcrypt(const YCPString& original)\n{\n    /**\n     * @builtin cryptbigcrypt\n     * @short Encrypts a string using bigcrypt\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using bigcrypt\n     * password encryption. The password is not truncated.\n     * @param string UNENCRYPTED\n     * @return string\n     *\n     * @usage cryptbigcrypt (\"readable\") -> \"d4brTQmcVbtNg\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, BIGCRYPT, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using bigcrypt failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stati",
          "args": [],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on using",
          "args": [
            "gcrypt failed\");\n        return YC"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n    el",
          "args": [
            "{\n\ty"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ted, BIGCR",
          "args": [
            "T, &encrypt",
            "))",
            "return YC"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string encry",
          "args": [],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing une",
          "args": [],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return YCPNull",
          "args": [],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nryptbigcrypt(const YCPString& original)\n{\n    /**\n     * @builtin cryptbigcrypt\n     * @short Encrypts a string using bigcrypt\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using bigcrypt\n     * password encryption. The password is not truncated.\n     * @param string UNENCRYPTED\n     * @return string\n     *\n     * @usage cryptbigcrypt (\"readable\") -> \"d4brTQmcVbtNg\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, BIGCRYPT, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using bigcrypt failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue"
  },
  {
    "function_name": "PString &s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "1265-1293",
    "snippet": "yptmd5 (const YCPString &s)\n{\n    /**\n     * @builtin cryptmd5\n     * @short Encrypts a string using md5\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using MD5\n     * password encryption.\n     * @param string  UNENCRYPTED\n     * @return string\n     *\n     * @usage cryptmd5 (\"readable\") -> \"$1$BBtzrzzz$zc2vEB7XnA3Iq7pOgDsxD0\"\n     */\n\n    if (s.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = s->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, MD5, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using MD5 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stati",
          "args": [],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on using",
          "args": [
            "5 failed\");\n        return YC"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n    el",
          "args": [
            "{\n\ty"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ted, MD5,",
          "args": [
            "ncrypted))",
            "return YC"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ng encry",
          "args": [],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing une",
          "args": [],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nyptmd5 (const YCPString &s)\n{\n    /**\n     * @builtin cryptmd5\n     * @short Encrypts a string using md5\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using MD5\n     * password encryption.\n     * @param string  UNENCRYPTED\n     * @return string\n     *\n     * @usage cryptmd5 (\"readable\") -> \"$1$BBtzrzzz$zc2vEB7XnA3Iq7pOgDsxD0\"\n     */\n\n    if (s.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = s->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, MD5, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using MD5 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue"
  },
  {
    "function_name": "ring &s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "1234-1262",
    "snippet": "ypt (const YCPString &s)\n{\n    /**\n     * @builtin crypt\n     * @short Encrypts a string\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using the standard\n     * password encryption provided by the system.\n     * @param string UNENCRYPTED\n     * @return string \n     *\n     * @usage crypt (\"readable\") -> \"Y2PEyAiaeaFy6\"\n     */\n\n    if (s.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = s->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, CRYPT, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using crypt failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stati",
          "args": [],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on using",
          "args": [
            "ypt failed\");\n        return YC"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n    el",
          "args": [
            "{\n\ty"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ted, CRYPT",
          "args": [
            "&encrypted)",
            "return YC"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ng encry",
          "args": [],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing une",
          "args": [],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nypt (const YCPString &s)\n{\n    /**\n     * @builtin crypt\n     * @short Encrypts a string\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using the standard\n     * password encryption provided by the system.\n     * @param string UNENCRYPTED\n     * @return string \n     *\n     * @usage crypt (\"readable\") -> \"Y2PEyAiaeaFy6\"\n     */\n\n    if (s.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = s->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, CRYPT, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using crypt failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "YCPString &f",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "1201-1232",
    "snippet": "mestring (const YCPString &fmt, const YCPInteger &time, const YCPBoolean &utc_flag)\n{\n   /**\n     * @builtin timestring\n     * @short Returns time string\n     * @description\n     * Combination of standard libc functions gmtime or localtime and strftime.\n     *\n     * @param string FORMAT\n     * @param integer TIME\n     * @param boolean UTC\n     * @return string\n     *\n     * @usage timestring (\"%F %T %Z\", time (), false) -> \"2004-08-24 14:55:05 CEST\"\n     */\n\n    if (fmt.isNull () || time.isNull () || utc_flag.isNull ())\n\treturn YCPNull ();\n\n    string format = fmt->value();\n    time_t t = time->value();\n    bool utc = utc_flag->value();\n\n    struct tm* tm = utc ? gmtime (&t) : localtime (&t);\n\n    const size_t size = 100;\n    char buffer[size];\n    strftime (buffer, size, format.c_str (), tm);\n\n    return YCPString (buffer);\n}\n\nstatic YCPValue\ns_",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\nstatic",
          "args": [
            "CPValu"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ze, form",
          "args": [
            ".c_str",
            "), t",
            ";\n\n    return Y",
            "St"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n    retur",
          "args": [],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const si",
          "args": [
            "_t"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ime (&",
          "args": [
            ";"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct tm*",
          "args": [],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ool utc = u",
          "args": [],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "me_t t = t",
          "args": [],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing for",
          "args": [],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return YCPNull",
          "args": [],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c_flag.isNu",
          "args": [],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.isNull",
          "args": [],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nmestring (const YCPString &fmt, const YCPInteger &time, const YCPBoolean &utc_flag)\n{\n   /**\n     * @builtin timestring\n     * @short Returns time string\n     * @description\n     * Combination of standard libc functions gmtime or localtime and strftime.\n     *\n     * @param string FORMAT\n     * @param integer TIME\n     * @param boolean UTC\n     * @return string\n     *\n     * @usage timestring (\"%F %T %Z\", time (), false) -> \"2004-08-24 14:55:05 CEST\"\n     */\n\n    if (fmt.isNull () || time.isNull () || utc_flag.isNull ())\n\treturn YCPNull ();\n\n    string format = fmt->value();\n    time_t t = time->value();\n    bool utc = utc_flag->value();\n\n    struct tm* tm = utc ? gmtime (&t) : localtime (&t);\n\n    const size_t size = 100;\n    char buffer[size];\n    strftime (buffer, size, format.c_str (), tm);\n\n    return YCPString (buffer);\n}\n\nstatic YCPValue\ns_"
  },
  {
    "function_name": "PValue &v)",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "1172-1198",
    "snippet": "string (const YCPValue &v)\n{\n    /**\n     * @builtin tostring \n     * @id tostring-any\n     * @short Converts a value to a string.\n     *\n     * @param any VALUE\n     * @return string\n     *\n     * @usage tostring(.path) -> \".path\"\n     * @usage tostring([1,2,3]) -> \"[1, 2, 3]\"\n     * @usage tostring($[1:1,2:2,3:3]) -> \"$[1:1, 2:2, 3:3]\"\n     * @usage tostring(`Empty()) -> \"`Empty ()\"\n     */\n\n    if (v.isNull())\n    {\n\treturn v;\n    }\n    if (v->valuetype() == YT_STRING)\n    {\n\treturn v->asString();\n    }\n    return YCPString(v->toString());\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g());\n}",
          "args": [
            "static YCPVal"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static YCPV",
          "args": [],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return",
          "args": [],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "returnType",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "513-513",
          "snippet": "constTypePtr returnType () const { return m_returntype; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nFunctionType {\n  constTypePtr returnType () const { return m_returntype; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_STRING)",
          "args": [],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eturn v;",
          "args": [],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstring (const YCPValue &v)\n{\n    /**\n     * @builtin tostring \n     * @id tostring-any\n     * @short Converts a value to a string.\n     *\n     * @param any VALUE\n     * @return string\n     *\n     * @usage tostring(.path) -> \".path\"\n     * @usage tostring([1,2,3]) -> \"[1, 2, 3]\"\n     * @usage tostring($[1:1,2:2,3:3]) -> \"$[1:1, 2:2, 3:3]\"\n     * @usage tostring(`Empty()) -> \"`Empty ()\"\n     */\n\n    if (v.isNull())\n    {\n\treturn v;\n    }\n    if (v->valuetype() == YT_STRING)\n    {\n\treturn v->asString();\n    }\n    return YCPString(v->toString());\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "nst YCPString &i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "1108-1169",
    "snippet": "gexptokenize (const YCPString &i, const YCPString &p)\n{\n    /**\n     * @builtin regexptokenize\n     * @short Regex tokenize\n     * @param string INPUT\n     * @param string PATTERN\n     * @return list\n     *\n     * @see regex(7).\n     * @description\n     * Searches a string for a POSIX Extended Regular Expression match\n     * and returns a list of the matched subexpressions\n     *\n     * If the pattern does not match, the list is empty.\n     * Otherwise the list contains then matchted subexpressions for each pair\n     * of parenthesize in pattern.\n     *\n     * If the pattern is invalid, 'nil' is returned.\n     *\n     * @usage\n     * Examples: \n     * // e ==  [ \"aaabbB\" ]\n     * list e = regexptokenize (\"aaabbBb\", \"(.*[A-Z]).*\");\n     *\n     * // h == [ \"aaab\", \"bb\" ]\n     * list h = regexptokenize (\"aaabbb\", \"(.*ab)(.*)\");\n     *\n     * // h == []\n     * list h = regexptokenize (\"aaabbb\", \"(.*ba).*\");\n     *\n     * // h == nil\n     * list h = regexptokenize (\"aaabbb\", \"(.*ba).*(\");\n     */\n    // \")\n\n    if (i.isNull () || p.isNull ())\n\treturn YCPNull ();\n\n    const char *input = i->value ().c_str ();\n    const char *pattern = p->value ().c_str ();\n\n    Reg_Ret result = solve_regular_expression (input, pattern, \"\");\n\n    if (result.error)\n    {\n\tycp2error (\"Error in regexp %s %s: %s\", input, pattern, result.error_str.c_str ());\n\treturn YCPNull ();\n    }\n\n    YCPList list;\n\n    if (result.solved)\n    {\n\tfor (int i = 1; i <= result.match_nb; i++)\n\t{\n\t    list->add (YCPString (result.match_str[i]));\n\t}\n    }\n    return list;\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "tch_str[i]));\n\t}\n    }\n    retu"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tch_str[i",
          "args": [
            ");\n\t}\n    }\n    ret"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPL",
          "args": [],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "commaList",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "254-265",
          "snippet": "string\nYCPListRep::commaList() const\n{\n    string ret;\n\n    for (unsigned index = 0; index < elements.size(); index++)\n    {\n\tif (index != 0) ret += \", \";\n\tret += elements[index].isNull() ? \"(null)\" : elements[index]->toString();\n    }\n    return ret;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  string\n  YCPListRep::commaList() const\n  {\n      string ret;\n  \n      for (unsigned index = 0; index < elements.size(); index++)\n      {\n  \tif (index != 0) ret += \", \";\n  \tret += elements[index].isNull() ? \"(null)\" : elements[index]->toString();\n      }\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "regexp %",
          "args": [
            "%s: %s\", input, pattern, re",
            "lt.er",
            "r_str.c",
            "tr ());\n\treturn YCPNull ("
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr",
          "args": [],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "PBuiltinString ()\n{\n    // must be",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "1572-1624",
          "snippet": "PBuiltinString ()\n{\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n#define ETC 0, NULL, constTypePtr(), NULL\n#define ETCf   NULL, constTypePtr(), NULL\n\t{ \"+\",\t\t   \"string (string, string)\",\t\t(void *)s_plus1,                         ETC },\n\t{ \"+\",\t\t   \"string (string, integer)\",\t\t(void *)s_plus2,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, path)\",\t\t(void *)s_plus3,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, symbol)\",\t\t(void *)s_plus4,\t\t\t ETC },\n\t{ \"issubstring\",   \"boolean (string, string)\",\t\t(void *)s_issubstring,\t\t\t ETC },\n\t{ \"tostring\",\t   \"string (any)\",\t\t\t(void *)s_tostring,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer)\",\t\t\t(void *)s_tohexstring1,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer, integer)\",\t\t(void *)s_tohexstring2,                  ETC },\n\t{ \"isempty\",\t   \"boolean (string)\",\t\t\t(void *)s_isempty,\t\t\t ETC },\n\t{ \"size\",\t   \"integer (string)\",\t\t\t(void *)s_size,\t\t\t\t ETC },\n\t{ \"find\",\t   \"integer (string, string)\",\t\t(void *)s_find,\tDECL_DEPRECATED,        ETCf },\n\t{ \"search\",\t   \"integer (string, string)\",\t\t(void *)s_search,\t\t\t ETC },\n\t{ \"tolower\",\t   \"string (string)\",\t\t\t(void *)s_tolower,\t\t\t ETC },\n\t{ \"toupper\",\t   \"string (string)\",\t\t\t(void *)s_toupper,\t\t\t ETC },\n\t{ \"toascii\",\t   \"string (string)\",\t\t\t(void *)s_toascii,                       ETC },\n\t{ \"deletechars\",   \"string (string, string)\",\t\t(void *)s_removechars,\t\t\t ETC },\n\t{ \"filterchars\",   \"string (string, string)\",\t\t(void *)s_filterchars,\t\t\t ETC },\n\t{ \"findfirstnotof\",\"integer (string, string)\",\t\t(void *)s_findfirstnotof,\t\t ETC },\n\t{ \"findfirstof\",   \"integer (string, string)\",\t\t(void *)s_findfirstof,\t\t\t ETC },\n\t{ \"findlastof\",\t   \"integer (string, string)\",\t\t(void *)s_findlastof,\t\t\t ETC },\n\t{ \"findlastnotof\", \"integer (string, string)\",\t\t(void *)s_findlastnotof,\t\t ETC },\n\t{ \"substring\",\t   \"string (string, integer)\",\t\t(void *)s_substring1,                    ETC },\n\t{ \"substring\",\t   \"string (string, integer, integer)\",\t(void *)s_substring2,\t\t\t ETC },\n\t{ \"timestring\",\t   \"string (string, integer, boolean)\",\t(void *)s_timestring,\t\t\t ETC },\n\t{ \"mergestring\",   \"string (const list <string>, string)\", (void *)s_mergestring,\t\t ETC },\n\t{ \"crypt\",\t   \"string (string)\",\t\t\t(void *)s_crypt,\t\t\t ETC },\n\t{ \"cryptmd5\",\t   \"string (string)\",\t\t\t(void *)s_cryptmd5,\t\t\t ETC },\n\t{ \"cryptbigcrypt\", \"string (string)\",\t\t\t(void *)s_cryptbigcrypt,\t\t ETC },\n\t{ \"cryptblowfish\", \"string (string)\",\t\t\t(void *)s_cryptblowfish,                 ETC },\n\t{ \"cryptsha256\",   \"string (string)\",\t\t\t(void *)s_cryptsha256,                   ETC },\n\t{ \"cryptsha512\",   \"string (string)\",\t\t\t(void *)s_cryptsha512,                   ETC },\n\t{ \"regexpmatch\",   \"boolean (string, string)\",\t\t(void *)s_regexpmatch,\t\t\t ETC },\n\t{ \"regexppos\",\t   \"list<integer> (string, string)\",\t(void *)s_regexppos,\t\t\t ETC },\n\t{ \"regexpsub\",\t   \"string (string, string, string)\",\t(void *)s_regexpsub,\t\t\t ETC },\n\t{ \"regexptokenize\",\"list <string> (string, string)\",\t(void *)s_regexptokenize,\t\t ETC },\n\t{ \"dgettext\",\t   \"string (string, string)\",\t\t(void *)s_dgettext,\t\t\t ETC },\n\t{ \"dngettext\",\t   \"string (string, string, string, integer)\",\t(void *)s_dngettext,\t\t ETC },\n\t{ \"dpgettext\",\t   \"string (string, string, string)\",\t(void *)s_dpgettext,                     ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer)\",\t\t(void *)s_lsubstring1,                   ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer, integer)\",\t(void *)s_lsubstring2,                   ETC },\n\t{ NULL, NULL, NULL, ETC }\n#undef ETC\n#undef ETCf\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinString\", declarations);\n}",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern StaticDeclaration static_declarations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nextern StaticDeclaration static_declarations;\n\nPBuiltinString ()\n{\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n#define ETC 0, NULL, constTypePtr(), NULL\n#define ETCf   NULL, constTypePtr(), NULL\n\t{ \"+\",\t\t   \"string (string, string)\",\t\t(void *)s_plus1,                         ETC },\n\t{ \"+\",\t\t   \"string (string, integer)\",\t\t(void *)s_plus2,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, path)\",\t\t(void *)s_plus3,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, symbol)\",\t\t(void *)s_plus4,\t\t\t ETC },\n\t{ \"issubstring\",   \"boolean (string, string)\",\t\t(void *)s_issubstring,\t\t\t ETC },\n\t{ \"tostring\",\t   \"string (any)\",\t\t\t(void *)s_tostring,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer)\",\t\t\t(void *)s_tohexstring1,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer, integer)\",\t\t(void *)s_tohexstring2,                  ETC },\n\t{ \"isempty\",\t   \"boolean (string)\",\t\t\t(void *)s_isempty,\t\t\t ETC },\n\t{ \"size\",\t   \"integer (string)\",\t\t\t(void *)s_size,\t\t\t\t ETC },\n\t{ \"find\",\t   \"integer (string, string)\",\t\t(void *)s_find,\tDECL_DEPRECATED,        ETCf },\n\t{ \"search\",\t   \"integer (string, string)\",\t\t(void *)s_search,\t\t\t ETC },\n\t{ \"tolower\",\t   \"string (string)\",\t\t\t(void *)s_tolower,\t\t\t ETC },\n\t{ \"toupper\",\t   \"string (string)\",\t\t\t(void *)s_toupper,\t\t\t ETC },\n\t{ \"toascii\",\t   \"string (string)\",\t\t\t(void *)s_toascii,                       ETC },\n\t{ \"deletechars\",   \"string (string, string)\",\t\t(void *)s_removechars,\t\t\t ETC },\n\t{ \"filterchars\",   \"string (string, string)\",\t\t(void *)s_filterchars,\t\t\t ETC },\n\t{ \"findfirstnotof\",\"integer (string, string)\",\t\t(void *)s_findfirstnotof,\t\t ETC },\n\t{ \"findfirstof\",   \"integer (string, string)\",\t\t(void *)s_findfirstof,\t\t\t ETC },\n\t{ \"findlastof\",\t   \"integer (string, string)\",\t\t(void *)s_findlastof,\t\t\t ETC },\n\t{ \"findlastnotof\", \"integer (string, string)\",\t\t(void *)s_findlastnotof,\t\t ETC },\n\t{ \"substring\",\t   \"string (string, integer)\",\t\t(void *)s_substring1,                    ETC },\n\t{ \"substring\",\t   \"string (string, integer, integer)\",\t(void *)s_substring2,\t\t\t ETC },\n\t{ \"timestring\",\t   \"string (string, integer, boolean)\",\t(void *)s_timestring,\t\t\t ETC },\n\t{ \"mergestring\",   \"string (const list <string>, string)\", (void *)s_mergestring,\t\t ETC },\n\t{ \"crypt\",\t   \"string (string)\",\t\t\t(void *)s_crypt,\t\t\t ETC },\n\t{ \"cryptmd5\",\t   \"string (string)\",\t\t\t(void *)s_cryptmd5,\t\t\t ETC },\n\t{ \"cryptbigcrypt\", \"string (string)\",\t\t\t(void *)s_cryptbigcrypt,\t\t ETC },\n\t{ \"cryptblowfish\", \"string (string)\",\t\t\t(void *)s_cryptblowfish,                 ETC },\n\t{ \"cryptsha256\",   \"string (string)\",\t\t\t(void *)s_cryptsha256,                   ETC },\n\t{ \"cryptsha512\",   \"string (string)\",\t\t\t(void *)s_cryptsha512,                   ETC },\n\t{ \"regexpmatch\",   \"boolean (string, string)\",\t\t(void *)s_regexpmatch,\t\t\t ETC },\n\t{ \"regexppos\",\t   \"list<integer> (string, string)\",\t(void *)s_regexppos,\t\t\t ETC },\n\t{ \"regexpsub\",\t   \"string (string, string, string)\",\t(void *)s_regexpsub,\t\t\t ETC },\n\t{ \"regexptokenize\",\"list <string> (string, string)\",\t(void *)s_regexptokenize,\t\t ETC },\n\t{ \"dgettext\",\t   \"string (string, string)\",\t\t(void *)s_dgettext,\t\t\t ETC },\n\t{ \"dngettext\",\t   \"string (string, string, string, integer)\",\t(void *)s_dngettext,\t\t ETC },\n\t{ \"dpgettext\",\t   \"string (string, string, string)\",\t(void *)s_dpgettext,                     ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer)\",\t\t(void *)s_lsubstring1,                   ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer, integer)\",\t(void *)s_lsubstring2,                   ETC },\n\t{ NULL, NULL, NULL, ETC }\n#undef ETC\n#undef ETCf\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinString\", declarations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sion (input, pattern, \"\"",
          "args": [
            "f (resu",
            ".e"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n    Reg_Ret re",
          "args": [],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n    R",
          "args": [],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n    const char",
          "args": [],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n    co",
          "args": [],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st char",
          "args": [],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ull",
          "args": [],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\ngexptokenize (const YCPString &i, const YCPString &p)\n{\n    /**\n     * @builtin regexptokenize\n     * @short Regex tokenize\n     * @param string INPUT\n     * @param string PATTERN\n     * @return list\n     *\n     * @see regex(7).\n     * @description\n     * Searches a string for a POSIX Extended Regular Expression match\n     * and returns a list of the matched subexpressions\n     *\n     * If the pattern does not match, the list is empty.\n     * Otherwise the list contains then matchted subexpressions for each pair\n     * of parenthesize in pattern.\n     *\n     * If the pattern is invalid, 'nil' is returned.\n     *\n     * @usage\n     * Examples: \n     * // e ==  [ \"aaabbB\" ]\n     * list e = regexptokenize (\"aaabbBb\", \"(.*[A-Z]).*\");\n     *\n     * // h == [ \"aaab\", \"bb\" ]\n     * list h = regexptokenize (\"aaabbb\", \"(.*ab)(.*)\");\n     *\n     * // h == []\n     * list h = regexptokenize (\"aaabbb\", \"(.*ba).*\");\n     *\n     * // h == nil\n     * list h = regexptokenize (\"aaabbb\", \"(.*ba).*(\");\n     */\n    // \")\n\n    if (i.isNull () || p.isNull ())\n\treturn YCPNull ();\n\n    const char *input = i->value ().c_str ();\n    const char *pattern = p->value ().c_str ();\n\n    Reg_Ret result = solve_regular_expression (input, pattern, \"\");\n\n    if (result.error)\n    {\n\tycp2error (\"Error in regexp %s %s: %s\", input, pattern, result.error_str.c_str ());\n\treturn YCPNull ();\n    }\n\n    YCPList list;\n\n    if (result.solved)\n    {\n\tfor (int i = 1; i <= result.match_nb; i++)\n\t{\n\t    list->add (YCPString (result.match_str[i]));\n\t}\n    }\n    return list;\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "CPString &i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "1064-1105",
    "snippet": "gexpsub (const YCPString &i, const YCPString &p, const YCPString &m)\n{\n    /**\n     * @builtin regexpsub\n     * @short Regex Substitution\n     * @param string INPUT\n     * @param string PATTERN\n     * @param string OUTPUT\n     * @return string\n     *\n     * @description\n     * Searches a string for a POSIX Extended Regular Expression match\n     * and returns <i>OUTPUT</i> with the matched subexpressions\n     * substituted or <b>nil</b> if no match was found.\n     *\n     * @see regex(7)\n     *\n     * @usage regexpsub (\"aaabbb\", \"(.*ab)\", \"s_\\\\1_e\") -> \"s_aaab_e\"\n     * @usage regexpsub (\"aaabbb\", \"(.*ba)\", \"s_\\\\1_e\") -> nil\n     */\n\n    if (i.isNull () || p.isNull () || m.isNull ())\n\treturn YCPNull ();\n\n    const char *input = i->value ().c_str ();\n    const char *pattern = p->value ().c_str ();\n    const char *match = m->value ().c_str ();\n\n    Reg_Ret result = solve_regular_expression (input, pattern, match);\n\n    if (result.error)\n    {\n\tycp2error (\"Error in regexp %s %s %s: %s\", input, pattern, match, result.error_str.c_str ());\n\treturn YCPNull ();\n    }\n\n    if (result.solved)\n\treturn YCPString (result.result_str.c_str ());\n\n    return YCPNull ();\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ic YCPV",
          "args": [],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sult_str.",
          "args": [
            "str ());\n\n    return YCPNu"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "destroy",
          "container": "YCPElementRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPElement.cc",
          "lines": "37-45",
          "snippet": "void\nYCPElementRep::destroy() const\n{\n    reference_counter--;\n    if (reference_counter == 0)\n\tdelete this;\n    else if (reference_counter < 0)\n\ty2internal(\"Negative reference counter\");\n}",
          "includes": [
            "#include \"ycp/YCPValue.h\"",
            "#include \"ycp/YCPElement.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPValue.h\"\n#include \"ycp/YCPElement.h\"\n#include \"ycp/y2log.h\"\n\nYCPElementRep {\n  void\n  YCPElementRep::destroy() const\n  {\n      reference_counter--;\n      if (reference_counter == 0)\n  \tdelete this;\n      else if (reference_counter < 0)\n  \ty2internal(\"Negative reference counter\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "if (",
          "args": [],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regexp %",
          "args": [
            "%s %s: %s\", input, pattern, ma",
            "h, re",
            "lt.erro",
            "str.c",
            "tr ());\n\treturn YCPNull ("
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr",
          "args": [],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "PBuiltinString ()\n{\n    // must be",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "1572-1624",
          "snippet": "PBuiltinString ()\n{\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n#define ETC 0, NULL, constTypePtr(), NULL\n#define ETCf   NULL, constTypePtr(), NULL\n\t{ \"+\",\t\t   \"string (string, string)\",\t\t(void *)s_plus1,                         ETC },\n\t{ \"+\",\t\t   \"string (string, integer)\",\t\t(void *)s_plus2,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, path)\",\t\t(void *)s_plus3,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, symbol)\",\t\t(void *)s_plus4,\t\t\t ETC },\n\t{ \"issubstring\",   \"boolean (string, string)\",\t\t(void *)s_issubstring,\t\t\t ETC },\n\t{ \"tostring\",\t   \"string (any)\",\t\t\t(void *)s_tostring,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer)\",\t\t\t(void *)s_tohexstring1,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer, integer)\",\t\t(void *)s_tohexstring2,                  ETC },\n\t{ \"isempty\",\t   \"boolean (string)\",\t\t\t(void *)s_isempty,\t\t\t ETC },\n\t{ \"size\",\t   \"integer (string)\",\t\t\t(void *)s_size,\t\t\t\t ETC },\n\t{ \"find\",\t   \"integer (string, string)\",\t\t(void *)s_find,\tDECL_DEPRECATED,        ETCf },\n\t{ \"search\",\t   \"integer (string, string)\",\t\t(void *)s_search,\t\t\t ETC },\n\t{ \"tolower\",\t   \"string (string)\",\t\t\t(void *)s_tolower,\t\t\t ETC },\n\t{ \"toupper\",\t   \"string (string)\",\t\t\t(void *)s_toupper,\t\t\t ETC },\n\t{ \"toascii\",\t   \"string (string)\",\t\t\t(void *)s_toascii,                       ETC },\n\t{ \"deletechars\",   \"string (string, string)\",\t\t(void *)s_removechars,\t\t\t ETC },\n\t{ \"filterchars\",   \"string (string, string)\",\t\t(void *)s_filterchars,\t\t\t ETC },\n\t{ \"findfirstnotof\",\"integer (string, string)\",\t\t(void *)s_findfirstnotof,\t\t ETC },\n\t{ \"findfirstof\",   \"integer (string, string)\",\t\t(void *)s_findfirstof,\t\t\t ETC },\n\t{ \"findlastof\",\t   \"integer (string, string)\",\t\t(void *)s_findlastof,\t\t\t ETC },\n\t{ \"findlastnotof\", \"integer (string, string)\",\t\t(void *)s_findlastnotof,\t\t ETC },\n\t{ \"substring\",\t   \"string (string, integer)\",\t\t(void *)s_substring1,                    ETC },\n\t{ \"substring\",\t   \"string (string, integer, integer)\",\t(void *)s_substring2,\t\t\t ETC },\n\t{ \"timestring\",\t   \"string (string, integer, boolean)\",\t(void *)s_timestring,\t\t\t ETC },\n\t{ \"mergestring\",   \"string (const list <string>, string)\", (void *)s_mergestring,\t\t ETC },\n\t{ \"crypt\",\t   \"string (string)\",\t\t\t(void *)s_crypt,\t\t\t ETC },\n\t{ \"cryptmd5\",\t   \"string (string)\",\t\t\t(void *)s_cryptmd5,\t\t\t ETC },\n\t{ \"cryptbigcrypt\", \"string (string)\",\t\t\t(void *)s_cryptbigcrypt,\t\t ETC },\n\t{ \"cryptblowfish\", \"string (string)\",\t\t\t(void *)s_cryptblowfish,                 ETC },\n\t{ \"cryptsha256\",   \"string (string)\",\t\t\t(void *)s_cryptsha256,                   ETC },\n\t{ \"cryptsha512\",   \"string (string)\",\t\t\t(void *)s_cryptsha512,                   ETC },\n\t{ \"regexpmatch\",   \"boolean (string, string)\",\t\t(void *)s_regexpmatch,\t\t\t ETC },\n\t{ \"regexppos\",\t   \"list<integer> (string, string)\",\t(void *)s_regexppos,\t\t\t ETC },\n\t{ \"regexpsub\",\t   \"string (string, string, string)\",\t(void *)s_regexpsub,\t\t\t ETC },\n\t{ \"regexptokenize\",\"list <string> (string, string)\",\t(void *)s_regexptokenize,\t\t ETC },\n\t{ \"dgettext\",\t   \"string (string, string)\",\t\t(void *)s_dgettext,\t\t\t ETC },\n\t{ \"dngettext\",\t   \"string (string, string, string, integer)\",\t(void *)s_dngettext,\t\t ETC },\n\t{ \"dpgettext\",\t   \"string (string, string, string)\",\t(void *)s_dpgettext,                     ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer)\",\t\t(void *)s_lsubstring1,                   ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer, integer)\",\t(void *)s_lsubstring2,                   ETC },\n\t{ NULL, NULL, NULL, ETC }\n#undef ETC\n#undef ETCf\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinString\", declarations);\n}",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern StaticDeclaration static_declarations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nextern StaticDeclaration static_declarations;\n\nPBuiltinString ()\n{\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n#define ETC 0, NULL, constTypePtr(), NULL\n#define ETCf   NULL, constTypePtr(), NULL\n\t{ \"+\",\t\t   \"string (string, string)\",\t\t(void *)s_plus1,                         ETC },\n\t{ \"+\",\t\t   \"string (string, integer)\",\t\t(void *)s_plus2,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, path)\",\t\t(void *)s_plus3,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, symbol)\",\t\t(void *)s_plus4,\t\t\t ETC },\n\t{ \"issubstring\",   \"boolean (string, string)\",\t\t(void *)s_issubstring,\t\t\t ETC },\n\t{ \"tostring\",\t   \"string (any)\",\t\t\t(void *)s_tostring,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer)\",\t\t\t(void *)s_tohexstring1,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer, integer)\",\t\t(void *)s_tohexstring2,                  ETC },\n\t{ \"isempty\",\t   \"boolean (string)\",\t\t\t(void *)s_isempty,\t\t\t ETC },\n\t{ \"size\",\t   \"integer (string)\",\t\t\t(void *)s_size,\t\t\t\t ETC },\n\t{ \"find\",\t   \"integer (string, string)\",\t\t(void *)s_find,\tDECL_DEPRECATED,        ETCf },\n\t{ \"search\",\t   \"integer (string, string)\",\t\t(void *)s_search,\t\t\t ETC },\n\t{ \"tolower\",\t   \"string (string)\",\t\t\t(void *)s_tolower,\t\t\t ETC },\n\t{ \"toupper\",\t   \"string (string)\",\t\t\t(void *)s_toupper,\t\t\t ETC },\n\t{ \"toascii\",\t   \"string (string)\",\t\t\t(void *)s_toascii,                       ETC },\n\t{ \"deletechars\",   \"string (string, string)\",\t\t(void *)s_removechars,\t\t\t ETC },\n\t{ \"filterchars\",   \"string (string, string)\",\t\t(void *)s_filterchars,\t\t\t ETC },\n\t{ \"findfirstnotof\",\"integer (string, string)\",\t\t(void *)s_findfirstnotof,\t\t ETC },\n\t{ \"findfirstof\",   \"integer (string, string)\",\t\t(void *)s_findfirstof,\t\t\t ETC },\n\t{ \"findlastof\",\t   \"integer (string, string)\",\t\t(void *)s_findlastof,\t\t\t ETC },\n\t{ \"findlastnotof\", \"integer (string, string)\",\t\t(void *)s_findlastnotof,\t\t ETC },\n\t{ \"substring\",\t   \"string (string, integer)\",\t\t(void *)s_substring1,                    ETC },\n\t{ \"substring\",\t   \"string (string, integer, integer)\",\t(void *)s_substring2,\t\t\t ETC },\n\t{ \"timestring\",\t   \"string (string, integer, boolean)\",\t(void *)s_timestring,\t\t\t ETC },\n\t{ \"mergestring\",   \"string (const list <string>, string)\", (void *)s_mergestring,\t\t ETC },\n\t{ \"crypt\",\t   \"string (string)\",\t\t\t(void *)s_crypt,\t\t\t ETC },\n\t{ \"cryptmd5\",\t   \"string (string)\",\t\t\t(void *)s_cryptmd5,\t\t\t ETC },\n\t{ \"cryptbigcrypt\", \"string (string)\",\t\t\t(void *)s_cryptbigcrypt,\t\t ETC },\n\t{ \"cryptblowfish\", \"string (string)\",\t\t\t(void *)s_cryptblowfish,                 ETC },\n\t{ \"cryptsha256\",   \"string (string)\",\t\t\t(void *)s_cryptsha256,                   ETC },\n\t{ \"cryptsha512\",   \"string (string)\",\t\t\t(void *)s_cryptsha512,                   ETC },\n\t{ \"regexpmatch\",   \"boolean (string, string)\",\t\t(void *)s_regexpmatch,\t\t\t ETC },\n\t{ \"regexppos\",\t   \"list<integer> (string, string)\",\t(void *)s_regexppos,\t\t\t ETC },\n\t{ \"regexpsub\",\t   \"string (string, string, string)\",\t(void *)s_regexpsub,\t\t\t ETC },\n\t{ \"regexptokenize\",\"list <string> (string, string)\",\t(void *)s_regexptokenize,\t\t ETC },\n\t{ \"dgettext\",\t   \"string (string, string)\",\t\t(void *)s_dgettext,\t\t\t ETC },\n\t{ \"dngettext\",\t   \"string (string, string, string, integer)\",\t(void *)s_dngettext,\t\t ETC },\n\t{ \"dpgettext\",\t   \"string (string, string, string)\",\t(void *)s_dpgettext,                     ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer)\",\t\t(void *)s_lsubstring1,                   ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer, integer)\",\t(void *)s_lsubstring2,                   ETC },\n\t{ NULL, NULL, NULL, ETC }\n#undef ETC\n#undef ETCf\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinString\", declarations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sion (input, pattern, ma",
          "args": [
            "h);",
            "if (r",
            "ult.e"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n    Reg_Ret re",
          "args": [],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n    R",
          "args": [],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n    const char",
          "args": [],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n    co",
          "args": [],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n    const char",
          "args": [],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n    co",
          "args": [],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st char",
          "args": [],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ull",
          "args": [],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ull",
          "args": [],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\ngexpsub (const YCPString &i, const YCPString &p, const YCPString &m)\n{\n    /**\n     * @builtin regexpsub\n     * @short Regex Substitution\n     * @param string INPUT\n     * @param string PATTERN\n     * @param string OUTPUT\n     * @return string\n     *\n     * @description\n     * Searches a string for a POSIX Extended Regular Expression match\n     * and returns <i>OUTPUT</i> with the matched subexpressions\n     * substituted or <b>nil</b> if no match was found.\n     *\n     * @see regex(7)\n     *\n     * @usage regexpsub (\"aaabbb\", \"(.*ab)\", \"s_\\\\1_e\") -> \"s_aaab_e\"\n     * @usage regexpsub (\"aaabbb\", \"(.*ba)\", \"s_\\\\1_e\") -> nil\n     */\n\n    if (i.isNull () || p.isNull () || m.isNull ())\n\treturn YCPNull ();\n\n    const char *input = i->value ().c_str ();\n    const char *pattern = p->value ().c_str ();\n    const char *match = m->value ().c_str ();\n\n    Reg_Ret result = solve_regular_expression (input, pattern, match);\n\n    if (result.error)\n    {\n\tycp2error (\"Error in regexp %s %s %s: %s\", input, pattern, match, result.error_str.c_str ());\n\treturn YCPNull ();\n    }\n\n    if (result.solved)\n\treturn YCPString (result.result_str.c_str ());\n\n    return YCPNull ();\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "PString& in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "1022-1061",
    "snippet": "egexppos(const YCPString& inp, const YCPString& pat)\n{\n    /**\n     * @builtin regexppos \n     * @short  Returns a pair with position and length of the first match.\n     * @param string INPUT\n     * @param string PATTERN\n     * @return list\n     *\n     * @description\n     * If no match is found it returns an empty list.\n     *\n     * @see  regex(7).\n     *\n     * @usage regexppos (\"abcd012efgh345\", \"[0-9]+\") -> [4, 3]\n     * @usage (\"aaabbb\", \"[0-9]+\") -> []\n     */\n\n    if (inp.isNull () || pat.isNull ())\n\treturn YCPNull ();\n\n    const char *input   = inp->value ().c_str ();\n    const char *pattern = pat->value ().c_str ();\n\n    Reg_Ret result = solve_regular_expression (input, pattern, \"\");\n\n    if (result.error) {\n        ycp2error (\"Error in regexp <%s> <%s>: %s\", input, pattern, result.error_str.c_str ());\n        return YCPNull ();\n    }\n\n    YCPList list;\n    if (result.solved) {\n        list->add ( YCPInteger(inp->value ().find (result.match_str[0])));\n        list->add ( YCPInteger(result.match_str[0].length ()));\n    }\n\n    return list;\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "er",
          "args": [
            "tch_str[0].length ()));\n    }\n\n    return"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "s_tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "540-564",
          "snippet": "static YCPValue\ns_tolower (const YCPString &s)\n{\n    /**\n     * @builtin tolower\n     * @short Makes a string lowercase\n     * @param string s String\n     * @return string String in lower case\n     *\n     * @description\n     * Returns string with all alphabetic characters converted to lowercase.\n     * Notice: national characters are left unchanged.\n     *\n     * @usage tolower (\"aBcDeF\") -> \"abcdef\"\n     * @usage tolower (\"ABC\") -> \"abc\"\n     */\n\n    if (s.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    for (unsigned i = 0; i < ss.size (); i++)\n\tss[i] = tolower (ss[i]);\n    return YCPString (ss);\n}\n\n\nstati",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_tolower (const YCPString &s)\n{\n    /**\n     * @builtin tolower\n     * @short Makes a string lowercase\n     * @param string s String\n     * @return string String in lower case\n     *\n     * @description\n     * Returns string with all alphabetic characters converted to lowercase.\n     * Notice: national characters are left unchanged.\n     *\n     * @usage tolower (\"aBcDeF\") -> \"abcdef\"\n     * @usage tolower (\"ABC\") -> \"abc\"\n     */\n\n    if (s.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    for (unsigned i = 0; i < ss.size (); i++)\n\tss[i] = tolower (ss[i]);\n    return YCPString (ss);\n}\n\n\nstati"
        }
      },
      {
        "call_info": {
          "callee": "tch_str[0]",
          "args": [
            "length ()));\n    }\n\n    retur"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "length",
          "args": [],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "e ().find",
          "args": [
            "result.match_str[0])));\n        list->ad"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.match_str[0",
          "args": [
            "));\n        list->a"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.mat",
          "args": [],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPL",
          "args": [],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "commaList",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "254-265",
          "snippet": "string\nYCPListRep::commaList() const\n{\n    string ret;\n\n    for (unsigned index = 0; index < elements.size(); index++)\n    {\n\tif (index != 0) ret += \", \";\n\tret += elements[index].isNull() ? \"(null)\" : elements[index]->toString();\n    }\n    return ret;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  string\n  YCPListRep::commaList() const\n  {\n      string ret;\n  \n      for (unsigned index = 0; index < elements.size(); index++)\n      {\n  \tif (index != 0) ret += \", \";\n  \tret += elements[index].isNull() ? \"(null)\" : elements[index]->toString();\n      }\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "regexp <",
          "args": [
            "> <%s>: %s\", input, pattern, re",
            "lt.er",
            "r_str.c",
            "tr ());\n        return YC"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr",
          "args": [],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "PBuiltinString ()\n{\n    // must be",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "1572-1624",
          "snippet": "PBuiltinString ()\n{\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n#define ETC 0, NULL, constTypePtr(), NULL\n#define ETCf   NULL, constTypePtr(), NULL\n\t{ \"+\",\t\t   \"string (string, string)\",\t\t(void *)s_plus1,                         ETC },\n\t{ \"+\",\t\t   \"string (string, integer)\",\t\t(void *)s_plus2,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, path)\",\t\t(void *)s_plus3,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, symbol)\",\t\t(void *)s_plus4,\t\t\t ETC },\n\t{ \"issubstring\",   \"boolean (string, string)\",\t\t(void *)s_issubstring,\t\t\t ETC },\n\t{ \"tostring\",\t   \"string (any)\",\t\t\t(void *)s_tostring,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer)\",\t\t\t(void *)s_tohexstring1,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer, integer)\",\t\t(void *)s_tohexstring2,                  ETC },\n\t{ \"isempty\",\t   \"boolean (string)\",\t\t\t(void *)s_isempty,\t\t\t ETC },\n\t{ \"size\",\t   \"integer (string)\",\t\t\t(void *)s_size,\t\t\t\t ETC },\n\t{ \"find\",\t   \"integer (string, string)\",\t\t(void *)s_find,\tDECL_DEPRECATED,        ETCf },\n\t{ \"search\",\t   \"integer (string, string)\",\t\t(void *)s_search,\t\t\t ETC },\n\t{ \"tolower\",\t   \"string (string)\",\t\t\t(void *)s_tolower,\t\t\t ETC },\n\t{ \"toupper\",\t   \"string (string)\",\t\t\t(void *)s_toupper,\t\t\t ETC },\n\t{ \"toascii\",\t   \"string (string)\",\t\t\t(void *)s_toascii,                       ETC },\n\t{ \"deletechars\",   \"string (string, string)\",\t\t(void *)s_removechars,\t\t\t ETC },\n\t{ \"filterchars\",   \"string (string, string)\",\t\t(void *)s_filterchars,\t\t\t ETC },\n\t{ \"findfirstnotof\",\"integer (string, string)\",\t\t(void *)s_findfirstnotof,\t\t ETC },\n\t{ \"findfirstof\",   \"integer (string, string)\",\t\t(void *)s_findfirstof,\t\t\t ETC },\n\t{ \"findlastof\",\t   \"integer (string, string)\",\t\t(void *)s_findlastof,\t\t\t ETC },\n\t{ \"findlastnotof\", \"integer (string, string)\",\t\t(void *)s_findlastnotof,\t\t ETC },\n\t{ \"substring\",\t   \"string (string, integer)\",\t\t(void *)s_substring1,                    ETC },\n\t{ \"substring\",\t   \"string (string, integer, integer)\",\t(void *)s_substring2,\t\t\t ETC },\n\t{ \"timestring\",\t   \"string (string, integer, boolean)\",\t(void *)s_timestring,\t\t\t ETC },\n\t{ \"mergestring\",   \"string (const list <string>, string)\", (void *)s_mergestring,\t\t ETC },\n\t{ \"crypt\",\t   \"string (string)\",\t\t\t(void *)s_crypt,\t\t\t ETC },\n\t{ \"cryptmd5\",\t   \"string (string)\",\t\t\t(void *)s_cryptmd5,\t\t\t ETC },\n\t{ \"cryptbigcrypt\", \"string (string)\",\t\t\t(void *)s_cryptbigcrypt,\t\t ETC },\n\t{ \"cryptblowfish\", \"string (string)\",\t\t\t(void *)s_cryptblowfish,                 ETC },\n\t{ \"cryptsha256\",   \"string (string)\",\t\t\t(void *)s_cryptsha256,                   ETC },\n\t{ \"cryptsha512\",   \"string (string)\",\t\t\t(void *)s_cryptsha512,                   ETC },\n\t{ \"regexpmatch\",   \"boolean (string, string)\",\t\t(void *)s_regexpmatch,\t\t\t ETC },\n\t{ \"regexppos\",\t   \"list<integer> (string, string)\",\t(void *)s_regexppos,\t\t\t ETC },\n\t{ \"regexpsub\",\t   \"string (string, string, string)\",\t(void *)s_regexpsub,\t\t\t ETC },\n\t{ \"regexptokenize\",\"list <string> (string, string)\",\t(void *)s_regexptokenize,\t\t ETC },\n\t{ \"dgettext\",\t   \"string (string, string)\",\t\t(void *)s_dgettext,\t\t\t ETC },\n\t{ \"dngettext\",\t   \"string (string, string, string, integer)\",\t(void *)s_dngettext,\t\t ETC },\n\t{ \"dpgettext\",\t   \"string (string, string, string)\",\t(void *)s_dpgettext,                     ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer)\",\t\t(void *)s_lsubstring1,                   ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer, integer)\",\t(void *)s_lsubstring2,                   ETC },\n\t{ NULL, NULL, NULL, ETC }\n#undef ETC\n#undef ETCf\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinString\", declarations);\n}",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern StaticDeclaration static_declarations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nextern StaticDeclaration static_declarations;\n\nPBuiltinString ()\n{\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n#define ETC 0, NULL, constTypePtr(), NULL\n#define ETCf   NULL, constTypePtr(), NULL\n\t{ \"+\",\t\t   \"string (string, string)\",\t\t(void *)s_plus1,                         ETC },\n\t{ \"+\",\t\t   \"string (string, integer)\",\t\t(void *)s_plus2,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, path)\",\t\t(void *)s_plus3,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, symbol)\",\t\t(void *)s_plus4,\t\t\t ETC },\n\t{ \"issubstring\",   \"boolean (string, string)\",\t\t(void *)s_issubstring,\t\t\t ETC },\n\t{ \"tostring\",\t   \"string (any)\",\t\t\t(void *)s_tostring,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer)\",\t\t\t(void *)s_tohexstring1,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer, integer)\",\t\t(void *)s_tohexstring2,                  ETC },\n\t{ \"isempty\",\t   \"boolean (string)\",\t\t\t(void *)s_isempty,\t\t\t ETC },\n\t{ \"size\",\t   \"integer (string)\",\t\t\t(void *)s_size,\t\t\t\t ETC },\n\t{ \"find\",\t   \"integer (string, string)\",\t\t(void *)s_find,\tDECL_DEPRECATED,        ETCf },\n\t{ \"search\",\t   \"integer (string, string)\",\t\t(void *)s_search,\t\t\t ETC },\n\t{ \"tolower\",\t   \"string (string)\",\t\t\t(void *)s_tolower,\t\t\t ETC },\n\t{ \"toupper\",\t   \"string (string)\",\t\t\t(void *)s_toupper,\t\t\t ETC },\n\t{ \"toascii\",\t   \"string (string)\",\t\t\t(void *)s_toascii,                       ETC },\n\t{ \"deletechars\",   \"string (string, string)\",\t\t(void *)s_removechars,\t\t\t ETC },\n\t{ \"filterchars\",   \"string (string, string)\",\t\t(void *)s_filterchars,\t\t\t ETC },\n\t{ \"findfirstnotof\",\"integer (string, string)\",\t\t(void *)s_findfirstnotof,\t\t ETC },\n\t{ \"findfirstof\",   \"integer (string, string)\",\t\t(void *)s_findfirstof,\t\t\t ETC },\n\t{ \"findlastof\",\t   \"integer (string, string)\",\t\t(void *)s_findlastof,\t\t\t ETC },\n\t{ \"findlastnotof\", \"integer (string, string)\",\t\t(void *)s_findlastnotof,\t\t ETC },\n\t{ \"substring\",\t   \"string (string, integer)\",\t\t(void *)s_substring1,                    ETC },\n\t{ \"substring\",\t   \"string (string, integer, integer)\",\t(void *)s_substring2,\t\t\t ETC },\n\t{ \"timestring\",\t   \"string (string, integer, boolean)\",\t(void *)s_timestring,\t\t\t ETC },\n\t{ \"mergestring\",   \"string (const list <string>, string)\", (void *)s_mergestring,\t\t ETC },\n\t{ \"crypt\",\t   \"string (string)\",\t\t\t(void *)s_crypt,\t\t\t ETC },\n\t{ \"cryptmd5\",\t   \"string (string)\",\t\t\t(void *)s_cryptmd5,\t\t\t ETC },\n\t{ \"cryptbigcrypt\", \"string (string)\",\t\t\t(void *)s_cryptbigcrypt,\t\t ETC },\n\t{ \"cryptblowfish\", \"string (string)\",\t\t\t(void *)s_cryptblowfish,                 ETC },\n\t{ \"cryptsha256\",   \"string (string)\",\t\t\t(void *)s_cryptsha256,                   ETC },\n\t{ \"cryptsha512\",   \"string (string)\",\t\t\t(void *)s_cryptsha512,                   ETC },\n\t{ \"regexpmatch\",   \"boolean (string, string)\",\t\t(void *)s_regexpmatch,\t\t\t ETC },\n\t{ \"regexppos\",\t   \"list<integer> (string, string)\",\t(void *)s_regexppos,\t\t\t ETC },\n\t{ \"regexpsub\",\t   \"string (string, string, string)\",\t(void *)s_regexpsub,\t\t\t ETC },\n\t{ \"regexptokenize\",\"list <string> (string, string)\",\t(void *)s_regexptokenize,\t\t ETC },\n\t{ \"dgettext\",\t   \"string (string, string)\",\t\t(void *)s_dgettext,\t\t\t ETC },\n\t{ \"dngettext\",\t   \"string (string, string, string, integer)\",\t(void *)s_dngettext,\t\t ETC },\n\t{ \"dpgettext\",\t   \"string (string, string, string)\",\t(void *)s_dpgettext,                     ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer)\",\t\t(void *)s_lsubstring1,                   ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer, integer)\",\t(void *)s_lsubstring2,                   ETC },\n\t{ NULL, NULL, NULL, ETC }\n#undef ETC\n#undef ETCf\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinString\", declarations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sion (input, pattern, \"\"",
          "args": [
            "f (resu",
            ".e"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st char",
          "args": [],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rn YCPNull",
          "args": [],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".isNull",
          "args": [],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\negexppos(const YCPString& inp, const YCPString& pat)\n{\n    /**\n     * @builtin regexppos \n     * @short  Returns a pair with position and length of the first match.\n     * @param string INPUT\n     * @param string PATTERN\n     * @return list\n     *\n     * @description\n     * If no match is found it returns an empty list.\n     *\n     * @see  regex(7).\n     *\n     * @usage regexppos (\"abcd012efgh345\", \"[0-9]+\") -> [4, 3]\n     * @usage (\"aaabbb\", \"[0-9]+\") -> []\n     */\n\n    if (inp.isNull () || pat.isNull ())\n\treturn YCPNull ();\n\n    const char *input   = inp->value ().c_str ();\n    const char *pattern = pat->value ().c_str ();\n\n    Reg_Ret result = solve_regular_expression (input, pattern, \"\");\n\n    if (result.error) {\n        ycp2error (\"Error in regexp <%s> <%s>: %s\", input, pattern, result.error_str.c_str ());\n        return YCPNull ();\n    }\n\n    YCPList list;\n    if (result.solved) {\n        list->add ( YCPInteger(inp->value ().find (result.match_str[0])));\n        list->add ( YCPInteger(result.match_str[0].length ()));\n    }\n\n    return list;\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "YCPString &i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "986-1020",
    "snippet": "gexpmatch (const YCPString &i, const YCPString &p)\n{\n    /**\n     * @builtin regexpmatch\n     *\n     * @short Searches a string for a POSIX Extended Regular Expression match.\n     * @param string INPUT\n     * @param string PATTERN\n     * @return boolean\n     *\n     * @see regex(7)\n     *\n     * @usage regexpmatch (\"aaabbbccc\", \"ab\") -> true\n     * @usage regexpmatch (\"aaabbbccc\", \"^ab\") -> false\n     * @usage regexpmatch (\"aaabbbccc\", \"ab+c\") -> true\n     * @usage regexpmatch (\"aaa(bbb)ccc\", \"\\\\(.*\\\\)\") -> true     \n     */\n\n    if (i.isNull () || p.isNull ())\n\treturn YCPNull ();\n\n    const char *input = i->value ().c_str ();\n    const char *pattern = p->value ().c_str ();\n\n    Reg_Ret result = solve_regular_expression (input, pattern, \"\");\n\n    if (result.error)\n    {\n\tycp2error (\"Error in regexpmatch %s %s: %s\", input, pattern, result.error_str.c_str ());\n\treturn YCPNull ();\n    }\n\n    return YCPBoolean (result.solved);\n}\n\nstatic YCPValue \ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "olved);\n}",
          "args": [
            "tatic YCPValu"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retu",
          "args": [],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "returnType",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "513-513",
          "snippet": "constTypePtr returnType () const { return m_returntype; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nFunctionType {\n  constTypePtr returnType () const { return m_returntype; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "regexpma",
          "args": [
            "h %s %s: %s\", input, pattern, re",
            "lt.er",
            "r_str.c",
            "tr ());\n\treturn YCPNull ("
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr",
          "args": [],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "PBuiltinString ()\n{\n    // must be",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "1572-1624",
          "snippet": "PBuiltinString ()\n{\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n#define ETC 0, NULL, constTypePtr(), NULL\n#define ETCf   NULL, constTypePtr(), NULL\n\t{ \"+\",\t\t   \"string (string, string)\",\t\t(void *)s_plus1,                         ETC },\n\t{ \"+\",\t\t   \"string (string, integer)\",\t\t(void *)s_plus2,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, path)\",\t\t(void *)s_plus3,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, symbol)\",\t\t(void *)s_plus4,\t\t\t ETC },\n\t{ \"issubstring\",   \"boolean (string, string)\",\t\t(void *)s_issubstring,\t\t\t ETC },\n\t{ \"tostring\",\t   \"string (any)\",\t\t\t(void *)s_tostring,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer)\",\t\t\t(void *)s_tohexstring1,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer, integer)\",\t\t(void *)s_tohexstring2,                  ETC },\n\t{ \"isempty\",\t   \"boolean (string)\",\t\t\t(void *)s_isempty,\t\t\t ETC },\n\t{ \"size\",\t   \"integer (string)\",\t\t\t(void *)s_size,\t\t\t\t ETC },\n\t{ \"find\",\t   \"integer (string, string)\",\t\t(void *)s_find,\tDECL_DEPRECATED,        ETCf },\n\t{ \"search\",\t   \"integer (string, string)\",\t\t(void *)s_search,\t\t\t ETC },\n\t{ \"tolower\",\t   \"string (string)\",\t\t\t(void *)s_tolower,\t\t\t ETC },\n\t{ \"toupper\",\t   \"string (string)\",\t\t\t(void *)s_toupper,\t\t\t ETC },\n\t{ \"toascii\",\t   \"string (string)\",\t\t\t(void *)s_toascii,                       ETC },\n\t{ \"deletechars\",   \"string (string, string)\",\t\t(void *)s_removechars,\t\t\t ETC },\n\t{ \"filterchars\",   \"string (string, string)\",\t\t(void *)s_filterchars,\t\t\t ETC },\n\t{ \"findfirstnotof\",\"integer (string, string)\",\t\t(void *)s_findfirstnotof,\t\t ETC },\n\t{ \"findfirstof\",   \"integer (string, string)\",\t\t(void *)s_findfirstof,\t\t\t ETC },\n\t{ \"findlastof\",\t   \"integer (string, string)\",\t\t(void *)s_findlastof,\t\t\t ETC },\n\t{ \"findlastnotof\", \"integer (string, string)\",\t\t(void *)s_findlastnotof,\t\t ETC },\n\t{ \"substring\",\t   \"string (string, integer)\",\t\t(void *)s_substring1,                    ETC },\n\t{ \"substring\",\t   \"string (string, integer, integer)\",\t(void *)s_substring2,\t\t\t ETC },\n\t{ \"timestring\",\t   \"string (string, integer, boolean)\",\t(void *)s_timestring,\t\t\t ETC },\n\t{ \"mergestring\",   \"string (const list <string>, string)\", (void *)s_mergestring,\t\t ETC },\n\t{ \"crypt\",\t   \"string (string)\",\t\t\t(void *)s_crypt,\t\t\t ETC },\n\t{ \"cryptmd5\",\t   \"string (string)\",\t\t\t(void *)s_cryptmd5,\t\t\t ETC },\n\t{ \"cryptbigcrypt\", \"string (string)\",\t\t\t(void *)s_cryptbigcrypt,\t\t ETC },\n\t{ \"cryptblowfish\", \"string (string)\",\t\t\t(void *)s_cryptblowfish,                 ETC },\n\t{ \"cryptsha256\",   \"string (string)\",\t\t\t(void *)s_cryptsha256,                   ETC },\n\t{ \"cryptsha512\",   \"string (string)\",\t\t\t(void *)s_cryptsha512,                   ETC },\n\t{ \"regexpmatch\",   \"boolean (string, string)\",\t\t(void *)s_regexpmatch,\t\t\t ETC },\n\t{ \"regexppos\",\t   \"list<integer> (string, string)\",\t(void *)s_regexppos,\t\t\t ETC },\n\t{ \"regexpsub\",\t   \"string (string, string, string)\",\t(void *)s_regexpsub,\t\t\t ETC },\n\t{ \"regexptokenize\",\"list <string> (string, string)\",\t(void *)s_regexptokenize,\t\t ETC },\n\t{ \"dgettext\",\t   \"string (string, string)\",\t\t(void *)s_dgettext,\t\t\t ETC },\n\t{ \"dngettext\",\t   \"string (string, string, string, integer)\",\t(void *)s_dngettext,\t\t ETC },\n\t{ \"dpgettext\",\t   \"string (string, string, string)\",\t(void *)s_dpgettext,                     ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer)\",\t\t(void *)s_lsubstring1,                   ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer, integer)\",\t(void *)s_lsubstring2,                   ETC },\n\t{ NULL, NULL, NULL, ETC }\n#undef ETC\n#undef ETCf\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinString\", declarations);\n}",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern StaticDeclaration static_declarations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nextern StaticDeclaration static_declarations;\n\nPBuiltinString ()\n{\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n#define ETC 0, NULL, constTypePtr(), NULL\n#define ETCf   NULL, constTypePtr(), NULL\n\t{ \"+\",\t\t   \"string (string, string)\",\t\t(void *)s_plus1,                         ETC },\n\t{ \"+\",\t\t   \"string (string, integer)\",\t\t(void *)s_plus2,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, path)\",\t\t(void *)s_plus3,\t\t\t ETC },\n\t{ \"+\",\t\t   \"string (string, symbol)\",\t\t(void *)s_plus4,\t\t\t ETC },\n\t{ \"issubstring\",   \"boolean (string, string)\",\t\t(void *)s_issubstring,\t\t\t ETC },\n\t{ \"tostring\",\t   \"string (any)\",\t\t\t(void *)s_tostring,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer)\",\t\t\t(void *)s_tohexstring1,\t\t\t ETC },\n\t{ \"tohexstring\",   \"string (integer, integer)\",\t\t(void *)s_tohexstring2,                  ETC },\n\t{ \"isempty\",\t   \"boolean (string)\",\t\t\t(void *)s_isempty,\t\t\t ETC },\n\t{ \"size\",\t   \"integer (string)\",\t\t\t(void *)s_size,\t\t\t\t ETC },\n\t{ \"find\",\t   \"integer (string, string)\",\t\t(void *)s_find,\tDECL_DEPRECATED,        ETCf },\n\t{ \"search\",\t   \"integer (string, string)\",\t\t(void *)s_search,\t\t\t ETC },\n\t{ \"tolower\",\t   \"string (string)\",\t\t\t(void *)s_tolower,\t\t\t ETC },\n\t{ \"toupper\",\t   \"string (string)\",\t\t\t(void *)s_toupper,\t\t\t ETC },\n\t{ \"toascii\",\t   \"string (string)\",\t\t\t(void *)s_toascii,                       ETC },\n\t{ \"deletechars\",   \"string (string, string)\",\t\t(void *)s_removechars,\t\t\t ETC },\n\t{ \"filterchars\",   \"string (string, string)\",\t\t(void *)s_filterchars,\t\t\t ETC },\n\t{ \"findfirstnotof\",\"integer (string, string)\",\t\t(void *)s_findfirstnotof,\t\t ETC },\n\t{ \"findfirstof\",   \"integer (string, string)\",\t\t(void *)s_findfirstof,\t\t\t ETC },\n\t{ \"findlastof\",\t   \"integer (string, string)\",\t\t(void *)s_findlastof,\t\t\t ETC },\n\t{ \"findlastnotof\", \"integer (string, string)\",\t\t(void *)s_findlastnotof,\t\t ETC },\n\t{ \"substring\",\t   \"string (string, integer)\",\t\t(void *)s_substring1,                    ETC },\n\t{ \"substring\",\t   \"string (string, integer, integer)\",\t(void *)s_substring2,\t\t\t ETC },\n\t{ \"timestring\",\t   \"string (string, integer, boolean)\",\t(void *)s_timestring,\t\t\t ETC },\n\t{ \"mergestring\",   \"string (const list <string>, string)\", (void *)s_mergestring,\t\t ETC },\n\t{ \"crypt\",\t   \"string (string)\",\t\t\t(void *)s_crypt,\t\t\t ETC },\n\t{ \"cryptmd5\",\t   \"string (string)\",\t\t\t(void *)s_cryptmd5,\t\t\t ETC },\n\t{ \"cryptbigcrypt\", \"string (string)\",\t\t\t(void *)s_cryptbigcrypt,\t\t ETC },\n\t{ \"cryptblowfish\", \"string (string)\",\t\t\t(void *)s_cryptblowfish,                 ETC },\n\t{ \"cryptsha256\",   \"string (string)\",\t\t\t(void *)s_cryptsha256,                   ETC },\n\t{ \"cryptsha512\",   \"string (string)\",\t\t\t(void *)s_cryptsha512,                   ETC },\n\t{ \"regexpmatch\",   \"boolean (string, string)\",\t\t(void *)s_regexpmatch,\t\t\t ETC },\n\t{ \"regexppos\",\t   \"list<integer> (string, string)\",\t(void *)s_regexppos,\t\t\t ETC },\n\t{ \"regexpsub\",\t   \"string (string, string, string)\",\t(void *)s_regexpsub,\t\t\t ETC },\n\t{ \"regexptokenize\",\"list <string> (string, string)\",\t(void *)s_regexptokenize,\t\t ETC },\n\t{ \"dgettext\",\t   \"string (string, string)\",\t\t(void *)s_dgettext,\t\t\t ETC },\n\t{ \"dngettext\",\t   \"string (string, string, string, integer)\",\t(void *)s_dngettext,\t\t ETC },\n\t{ \"dpgettext\",\t   \"string (string, string, string)\",\t(void *)s_dpgettext,                     ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer)\",\t\t(void *)s_lsubstring1,                   ETC },\n\t{ \"lsubstring\",\t   \"string (string, integer, integer)\",\t(void *)s_lsubstring2,                   ETC },\n\t{ NULL, NULL, NULL, ETC }\n#undef ETC\n#undef ETCf\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinString\", declarations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sion (input, pattern, \"\"",
          "args": [
            "f (resu",
            ".e"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n    Reg_Ret re",
          "args": [],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n    R",
          "args": [],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n    const char",
          "args": [],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n    co",
          "args": [],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st char",
          "args": [],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ull",
          "args": [],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\ngexpmatch (const YCPString &i, const YCPString &p)\n{\n    /**\n     * @builtin regexpmatch\n     *\n     * @short Searches a string for a POSIX Extended Regular Expression match.\n     * @param string INPUT\n     * @param string PATTERN\n     * @return boolean\n     *\n     * @see regex(7)\n     *\n     * @usage regexpmatch (\"aaabbbccc\", \"ab\") -> true\n     * @usage regexpmatch (\"aaabbbccc\", \"^ab\") -> false\n     * @usage regexpmatch (\"aaabbbccc\", \"ab+c\") -> true\n     * @usage regexpmatch (\"aaa(bbb)ccc\", \"\\\\(.*\\\\)\") -> true     \n     */\n\n    if (i.isNull () || p.isNull ())\n\treturn YCPNull ();\n\n    const char *input = i->value ().c_str ();\n    const char *pattern = p->value ().c_str ();\n\n    Reg_Ret result = solve_regular_expression (input, pattern, \"\");\n\n    if (result.error)\n    {\n\tycp2error (\"Error in regexpmatch %s %s: %s\", input, pattern, result.error_str.c_str ());\n\treturn YCPNull ();\n    }\n\n    return YCPBoolean (result.solved);\n}\n\nstatic YCPValue \ns"
  },
  {
    "function_name": "sion (const char *input,",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "908-983",
    "snippet": "r_expression (const char *input, const char *pattern,\n\t\t\t\t  const char *result)\n{\n    int status;\n    char error[ERR_MAX + 1];\n\n    regex_t compiled;\n    regmatch_t matchptr[SUB_MAX + 1];\n\n    Reg_Ret reg_ret;\n    reg_ret.match_nb = 0;\n    reg_ret.error = true;\n    reg_ret.error_str = \"\";\n\n    status = regcomp (&compiled, pattern, REG_EXTENDED);\n    if (status)\n    {\n\tregerror (status, &compiled, error, ERR_MAX);\n\treg_ret.error_str = string (error);\n\treturn reg_ret;\n    }\n\n    if (compiled.re_nsub > SUB_MAX)\n    {\n\tsnprintf (error, ERR_MAX, \"too many subexpresions: %zu\", compiled.re_nsub);\n\treg_ret.error_str = string (error);\n\tregfree (&compiled);\n\treturn reg_ret;\n    }\n\n    status = regexec (&compiled, input, compiled.re_nsub + 1, matchptr, 0);\n    reg_ret.solved = !status;\n    reg_ret.error = false;\n\n    if (status)\n    {\n\tregfree (&compiled);\n\treturn reg_ret;\n    }\n\n    string input_str (input);\n\n    for (unsigned int i=0; (i <= compiled.re_nsub) && (i <= SUB_MAX); i++) {\n        reg_ret.match_str[i] = matchptr[i].rm_so >= 0 ? input_str.substr(matchptr[i].rm_so, matchptr[i].rm_eo - matchptr[i].rm_so) : \"\";\n        reg_ret.match_nb = i;\n    }\n\n\n    string result_str;\n    const char * done = result;\t// text before 'done' has been dealt with\n    const char * bspos = result;\n\n\n    while (1) {\n      bspos = strchr (bspos, '\\\\');\n      if (bspos == NULL) // not found\n\tbreak;\n\n      // STATE: \\ seen\n      ++bspos;\n\n      if (*bspos >= '1' && *bspos <= '9') {\n\t// copy non-backslash text\n\tresult_str.append (done, bspos - 1 - done);\n\t// copy replacement string\n\tresult_str += reg_ret.match_str[*bspos - '0'];\n\tdone = bspos = bspos + 1;\n      }\n    }\n    // copy the rest\n    result_str += done;\n      \n    reg_ret.result_str = result_str;\n    regfree (&compiled);\n    return reg_ret;\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [
      "#define SUB_MAX 10\t\t// for regexp",
      "#define ERR_MAX 80\t\t// for regexp"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "re",
          "args": [
            "rn reg_re"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "setEnabled",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "146-150",
          "snippet": "void\nYBreakpoint::setEnabled (bool enable) \n{\n    m_enabled = enable;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  void\n  YBreakpoint::setEnabled (bool enable) \n  {\n      m_enabled = enable;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "one, bspos - 1 -",
          "args": [
            "ne);",
            "// copy replacem"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";",
          "args": [
            "if (b",
            "os ="
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chptr[i].rm_so,",
          "args": [
            "atchptr[i].rm_eo",
            "matchptr[i].rm_so) : \"\";\n        reg_"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "reg_ret;"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "return_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
          "lines": "47-57",
          "snippet": "static int return_one (const struct dirent *entry)\n{\n    if ('.' == entry->d_name[0])\n    {\n\tif ('\\0' == entry->d_name[1])\n\t    return 0;\n\tif ('.' == entry->d_name[1] && '\\0' == entry->d_name[2])\n\t    return 0;\n    }\n    return 1;\n}",
          "includes": [
            "#include \"ShellCommand.h\"",
            "#include \"SystemAgent.h\"",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/pathsearch.h>",
            "#include <YCP.h>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <string>",
            "#include <linux/lp.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <resolv.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int return_one (const struct dirent *entry)\n{\n    if ('.' == entry->d_name[0])\n    {\n\tif ('\\0' == entry->d_name[1])\n\t    return 0;\n\tif ('.' == entry->d_name[1] && '\\0' == entry->d_name[2])\n\t    return 0;\n    }\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "input,",
          "args": [
            "mpiled.re",
            "sub +",
            ", matchptr, 0);",
            "g_ret.so",
            "e"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free (",
          "args": [
            "ompil"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_MAX, \"t",
          "args": [
            "many",
            "ubexpre",
            "ons: %zu\", compiled.re_nsub);",
            "reg_ret.error_st"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urn re",
          "args": [
            "ret;"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ompiled,",
          "args": [
            "rror,",
            "R_MAX);",
            "g_ret",
            "rror_st"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pattern",
          "args": [
            "REG_EXTEN",
            "D);",
            "f (status)"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\n#define SUB_MAX 10\t\t// for regexp\n#define ERR_MAX 80\t\t// for regexp\n\nr_expression (const char *input, const char *pattern,\n\t\t\t\t  const char *result)\n{\n    int status;\n    char error[ERR_MAX + 1];\n\n    regex_t compiled;\n    regmatch_t matchptr[SUB_MAX + 1];\n\n    Reg_Ret reg_ret;\n    reg_ret.match_nb = 0;\n    reg_ret.error = true;\n    reg_ret.error_str = \"\";\n\n    status = regcomp (&compiled, pattern, REG_EXTENDED);\n    if (status)\n    {\n\tregerror (status, &compiled, error, ERR_MAX);\n\treg_ret.error_str = string (error);\n\treturn reg_ret;\n    }\n\n    if (compiled.re_nsub > SUB_MAX)\n    {\n\tsnprintf (error, ERR_MAX, \"too many subexpresions: %zu\", compiled.re_nsub);\n\treg_ret.error_str = string (error);\n\tregfree (&compiled);\n\treturn reg_ret;\n    }\n\n    status = regexec (&compiled, input, compiled.re_nsub + 1, matchptr, 0);\n    reg_ret.solved = !status;\n    reg_ret.error = false;\n\n    if (status)\n    {\n\tregfree (&compiled);\n\treturn reg_ret;\n    }\n\n    string input_str (input);\n\n    for (unsigned int i=0; (i <= compiled.re_nsub) && (i <= SUB_MAX); i++) {\n        reg_ret.match_str[i] = matchptr[i].rm_so >= 0 ? input_str.substr(matchptr[i].rm_so, matchptr[i].rm_eo - matchptr[i].rm_so) : \"\";\n        reg_ret.match_nb = i;\n    }\n\n\n    string result_str;\n    const char * done = result;\t// text before 'done' has been dealt with\n    const char * bspos = result;\n\n\n    while (1) {\n      bspos = strchr (bspos, '\\\\');\n      if (bspos == NULL) // not found\n\tbreak;\n\n      // STATE: \\ seen\n      ++bspos;\n\n      if (*bspos >= '1' && *bspos <= '9') {\n\t// copy non-backslash text\n\tresult_str.append (done, bspos - 1 - done);\n\t// copy replacement string\n\tresult_str += reg_ret.match_str[*bspos - '0'];\n\tdone = bspos = bspos + 1;\n      }\n    }\n    // copy the rest\n    result_str += done;\n      \n    reg_ret.result_str = result_str;\n    regfree (&compiled);\n    return reg_ret;\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "st YCPString &s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "860-889",
    "snippet": "ndlastnotof (const YCPString &s1, const YCPString &s2)\n{\n    /**\n     * @builtin findlastnotof\n     * @short Searches the last element of string that doesn't match\n     * @param string STRING\n     * @param string CHARS Characters\n     * @description The `findlastnotof' function searches the last element of\n     * string that doesn't match any character stored in chars and returns its\n     * position.\n     *\n     * If no match is found the function returns `nil'.\n     * \n     * @return integer The position of the last character in <tt>STRING</tt> that is\n     * NOT contained in <tt>CHARS</tt>.\n     *\n     * @see findfirstnotof\n     * @usage findlastnotof( \"abcdefghi\", \"abcefghi\" ) -> 3 ('d')\n     * @usage findlastnotof(\"aaaaa\", \"a\") -> nil\n     */\n\n    if (s1.isNull () || s2.isNull ())\n\treturn YCPNull ();\n\n    string::size_type pos = s1->value ().find_last_not_of( s2->value () );\n\n    if ( pos == string::npos ) return YCPVoid();    // not found\n    else return YCPInteger( pos );                  // found\n}\n\n/// (regexp builti",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "found",
          "args": [],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_not_of",
          "args": [
            "if ( pos =="
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if",
          "args": [],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "qualifiedName",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3482-3489",
          "snippet": "string\nY2YCPFunction::qualifiedName () const\n{\n    string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n\t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n\t\"\";\n    return n + m_sentry->name ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  string\n  Y2YCPFunction::qualifiedName () const\n  {\n      string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n  \t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n  \t\"\";\n      return n + m_sentry->name ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "st_not_of",
          "args": [],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing::si",
          "args": [],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n YCPNull",
          "args": [],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sNull",
          "args": [],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nndlastnotof (const YCPString &s1, const YCPString &s2)\n{\n    /**\n     * @builtin findlastnotof\n     * @short Searches the last element of string that doesn't match\n     * @param string STRING\n     * @param string CHARS Characters\n     * @description The `findlastnotof' function searches the last element of\n     * string that doesn't match any character stored in chars and returns its\n     * position.\n     *\n     * If no match is found the function returns `nil'.\n     * \n     * @return integer The position of the last character in <tt>STRING</tt> that is\n     * NOT contained in <tt>CHARS</tt>.\n     *\n     * @see findfirstnotof\n     * @usage findlastnotof( \"abcdefghi\", \"abcefghi\" ) -> 3 ('d')\n     * @usage findlastnotof(\"aaaaa\", \"a\") -> nil\n     */\n\n    if (s1.isNull () || s2.isNull ())\n\treturn YCPNull ();\n\n    string::size_type pos = s1->value ().find_last_not_of( s2->value () );\n\n    if ( pos == string::npos ) return YCPVoid();    // not found\n    else return YCPInteger( pos );                  // found\n}\n\n/// (regexp builti"
  },
  {
    "function_name": "YCPString &s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "827-858",
    "snippet": "ndlastof (const YCPString &s1, const YCPString &s2)\n{\n    /**\n     * @builtin findlastof \n     * @short Searches string for the last match\n     * @description\n     * The `findlastof' function searches string for the last match of any\n     * character stored in chars and returns its position.\n     *\n     * @param string STRING String\n     * @param string CHARS Characters to find\n     *\n     * @return integer the position of the last character in <tt>STRING</tt> that is\n     * contained in <tt>CHARS</tt>.\n     *\n     * @see findfirstof\n     * @usage findlastof (\"abcdecfghi\", \"cxdv\") -> 5\n     * @usage findlastof (\"aaaaa\", \"z\") -> nil\n     */\n\n    if (s1.isNull () || s2.isNull ())\n\treturn YCPNull ();\n\n    string ss1 = s1->value ();\n    string::size_type pos = ss1.find_last_of (s2->value ());\n\n    if (pos == string::npos)\n\treturn YCPVoid ();\t\t// not found\n    else\n\treturn YCPInteger (pos);\t// found\n}\n\nstatic YCPValue\ns_",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "found\n}",
          "args": [
            "ati"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "found",
          "args": [],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->value",
          "args": [
            "if (pos == s"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "if",
          "args": [],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "qualifiedName",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3482-3489",
          "snippet": "string\nY2YCPFunction::qualifiedName () const\n{\n    string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n\t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n\t\"\";\n    return n + m_sentry->name ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  string\n  Y2YCPFunction::qualifiedName () const\n  {\n      string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n  \t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n  \t\"\";\n      return n + m_sentry->name ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring::siz",
          "args": [],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing ss1",
          "args": [],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n YCPNull",
          "args": [],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sNull",
          "args": [],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nndlastof (const YCPString &s1, const YCPString &s2)\n{\n    /**\n     * @builtin findlastof \n     * @short Searches string for the last match\n     * @description\n     * The `findlastof' function searches string for the last match of any\n     * character stored in chars and returns its position.\n     *\n     * @param string STRING String\n     * @param string CHARS Characters to find\n     *\n     * @return integer the position of the last character in <tt>STRING</tt> that is\n     * contained in <tt>CHARS</tt>.\n     *\n     * @see findfirstof\n     * @usage findlastof (\"abcdecfghi\", \"cxdv\") -> 5\n     * @usage findlastof (\"aaaaa\", \"z\") -> nil\n     */\n\n    if (s1.isNull () || s2.isNull ())\n\treturn YCPNull ();\n\n    string ss1 = s1->value ();\n    string::size_type pos = ss1.find_last_of (s2->value ());\n\n    if (pos == string::npos)\n\treturn YCPVoid ();\t\t// not found\n    else\n\treturn YCPInteger (pos);\t// found\n}\n\nstatic YCPValue\ns_"
  },
  {
    "function_name": "YCPString &s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "790-824",
    "snippet": "ndfirstof (const YCPString &s1, const YCPString &s2)\n{\n    /**\n     * @builtin findfirstof\n     * @short Finds position of the first matching characters in string\n     * @param string STRING\n     * @param string CHARS Characters to find\n     *\n     * @description\n     * The <tt>findfirstof</tt> function searches string for the first match of any\n     * character stored in chars and returns its position. \n     *\n     * If no match is found findfirstof returns `nil'. \n     * \n     * @return integer the position of the first character in <tt>STRING</tt> that is\n     * contained in <tt>CHARS</tt>.\n     *\n     * @see findfirstnotof\n     * @see find\n     * @usage findfirstof (\"abcdefghi\", \"cxdv\") -> 2\n     * @usage findfirstof (\"aaaaa\", \"z\") -> nil\n     */\n\n    if (s1.isNull () || s2.isNull ())\n\treturn YCPNull ();\n\n    string ss1 = s1->value ();\n    string::size_type pos = ss1.find_first_of (s2->value ());\n\n    if (pos == string::npos)\n\treturn YCPVoid ();\t\t// not found\n    else\n\treturn YCPInteger (pos);\t// found\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "found\n}",
          "args": [
            "tat"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "found",
          "args": [],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2->value",
          "args": [
            "if (pos == s"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "if",
          "args": [],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "qualifiedName",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3482-3489",
          "snippet": "string\nY2YCPFunction::qualifiedName () const\n{\n    string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n\t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n\t\"\";\n    return n + m_sentry->name ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  string\n  Y2YCPFunction::qualifiedName () const\n  {\n      string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n  \t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n  \t\"\";\n      return n + m_sentry->name ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring::siz",
          "args": [],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing ss1",
          "args": [],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n YCPNull",
          "args": [],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sNull",
          "args": [],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nndfirstof (const YCPString &s1, const YCPString &s2)\n{\n    /**\n     * @builtin findfirstof\n     * @short Finds position of the first matching characters in string\n     * @param string STRING\n     * @param string CHARS Characters to find\n     *\n     * @description\n     * The <tt>findfirstof</tt> function searches string for the first match of any\n     * character stored in chars and returns its position. \n     *\n     * If no match is found findfirstof returns `nil'. \n     * \n     * @return integer the position of the first character in <tt>STRING</tt> that is\n     * contained in <tt>CHARS</tt>.\n     *\n     * @see findfirstnotof\n     * @see find\n     * @usage findfirstof (\"abcdefghi\", \"cxdv\") -> 2\n     * @usage findfirstof (\"aaaaa\", \"z\") -> nil\n     */\n\n    if (s1.isNull () || s2.isNull ())\n\treturn YCPNull ();\n\n    string ss1 = s1->value ();\n    string::size_type pos = ss1.find_first_of (s2->value ());\n\n    if (pos == string::npos)\n\treturn YCPVoid ();\t\t// not found\n    else\n\treturn YCPInteger (pos);\t// found\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "nst YCPString &s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "751-787",
    "snippet": "ndfirstnotof (const YCPString &s1, const YCPString &s2)\n{\n    /**\n     * @builtin findfirstnotof\n     * @short Searches string for the first non matching chars\n     * @param string STRING\n     * @param string CHARS\n     *\n     * @description\n     * The <tt>findfirstnotof</tt> function searches the first element of string that\n     * doesn't match any character stored in chars and returns its position.\n     *\n     * @return integer the position of the first character in <tt>STRING</tt> that is\n     * not contained in <tt>CHARS</tt>.\n     *\n     * @see findfirstof\n     * @see find\n     * @usage findfirstnotof (\"abcdefghi\", \"abcefghi\") -> 3\n     * @usage findfirstnotof (\"aaaaa\", \"a\") -> nil\n     */\n     \n    if (s1.isNull () || s2.isNull ())\n\treturn YCPNull ();\n\n    // this is needed on gcc 3.0. gcc 2.95 was wrong.\n    if (s1->value ().empty ())\n\treturn YCPInteger ((long long int) 0);\n\n    string ss1 = s1->value ();\n    string::size_type pos = ss1.find_first_not_of (s2->value ());\n\n    if (pos == string::npos)\n\treturn YCPVoid ();\t\t// not found\n    else\n\treturn YCPInteger (pos);\t// found\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "found\n}",
          "args": [
            "tat"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "found",
          "args": [],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f",
          "args": [
            "if (pos == s"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "fromStream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "95-101",
          "snippet": "static string\nfromStream (bytecodeistream & str)\n{\n    string s;\n    Bytecode::readString (str, s);\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nstatic string\nfromStream (bytecodeistream & str)\n{\n    string s;\n    Bytecode::readString (str, s);\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "if",
          "args": [],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "qualifiedName",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3482-3489",
          "snippet": "string\nY2YCPFunction::qualifiedName () const\n{\n    string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n\t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n\t\"\";\n    return n + m_sentry->name ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  string\n  Y2YCPFunction::qualifiedName () const\n  {\n      string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n  \t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n  \t\"\";\n      return n + m_sentry->name ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring::siz",
          "args": [],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ng int) 0)",
          "args": [
            "string ss1 ="
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "))\n\treturn YCPInte",
          "args": [],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "))\n\tretur",
          "args": [],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this is",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n YCPNull",
          "args": [],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sNull",
          "args": [],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nndfirstnotof (const YCPString &s1, const YCPString &s2)\n{\n    /**\n     * @builtin findfirstnotof\n     * @short Searches string for the first non matching chars\n     * @param string STRING\n     * @param string CHARS\n     *\n     * @description\n     * The <tt>findfirstnotof</tt> function searches the first element of string that\n     * doesn't match any character stored in chars and returns its position.\n     *\n     * @return integer the position of the first character in <tt>STRING</tt> that is\n     * not contained in <tt>CHARS</tt>.\n     *\n     * @see findfirstof\n     * @see find\n     * @usage findfirstnotof (\"abcdefghi\", \"abcefghi\") -> 3\n     * @usage findfirstnotof (\"aaaaa\", \"a\") -> nil\n     */\n     \n    if (s1.isNull () || s2.isNull ())\n\treturn YCPNull ();\n\n    // this is needed on gcc 3.0. gcc 2.95 was wrong.\n    if (s1->value ().empty ())\n\treturn YCPInteger ((long long int) 0);\n\n    string ss1 = s1->value ();\n    string::size_type pos = ss1.find_first_not_of (s2->value ());\n\n    if (pos == string::npos)\n\treturn YCPVoid ();\t\t// not found\n    else\n\treturn YCPInteger (pos);\t// found\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "YCPList &l,",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "690-748",
    "snippet": "rgestring (const YCPList &l, const YCPString &s)\n{\n    /**\n     * @builtin mergestring \n     * @short Joins list elements with a string\n     * @param list<string> PIECES A List of strings\n     * @param string GLUE\n     * @return string \n     * @description\n     *\n     * Returns a string containing a string representation of all the list\n     * elements in the same order, with the glue string between each element.\n     * \n     * List elements which are not of type strings are ignored.\n     *\n     * @see splitstring\n     *\n     * @usage mergestring ([\"\", \"abc\", \"dev\", \"ghi\"], \"/\") -> \"/abc/dev/ghi\"\n     * @usage mergestring ([\"abc\", \"dev\", \"ghi\", \"\"], \"/\") -> \"abc/dev/ghi/\"\n     * @usage mergestring ([1, \"a\", 3], \".\") -> \"a\"\n     * @usage mergestring ([], \".\") -> \"\"\n     * @usage mergestring ([\"abc\", \"dev\", \"ghi\"], \"\") -> \"abcdevghi\"\n     * @usage mergestring ([\"abc\", \"dev\", \"ghi\"], \"123\") -> \"abc123dev123ghi\"\n     */\n     \n    if (l.isNull ())\n\treturn YCPNull ();\n\t\n    if (s.isNull ())\n    {\n\tycp2error (\"Can't merge string using 'nil'\");\n\treturn YCPNull ();\n    }\n\n    string ret;\n\n    if (l->isEmpty ())\t\t// empty list -> empty result\n\treturn YCPString (ret);\n\n    string c = s->value ();\n\n    // loop through list\n\n    for (int i = 0; i < l->size (); i++)\n    {\n\tYCPValue vv = l->value (i);\n\tif (!vv->isString ())\t// skip non-string elements\n\t    continue;\n\tstring vs = vv->asString ()->value ();\n\n\tif (i != 0)\t\t// insert c *between* strings\n\t    ret += c;\n\n\tret += vs;\t\t// add string to result\n    }\n\n    return YCPString (ret);\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static Y",
          "args": [
            "Val"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ue",
          "args": [],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "asValue",
          "container": "YCPElementRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPElement.cc",
          "lines": "54-58",
          "snippet": "YCPValue\nYCPElementRep::asValue() const\n{\n    return YCPValue(static_cast<const YCPValueRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPValue.h\"",
            "#include \"ycp/YCPElement.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPValue.h\"\n#include \"ycp/YCPElement.h\"\n#include \"ycp/y2log.h\"\n\nYCPElementRep {\n  YCPValue\n  YCPElementRep::asValue() const\n  {\n      return YCPValue(static_cast<const YCPValueRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip non-str",
          "args": [],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vv->isSt",
          "args": [
            "n"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n\tYCP",
          "args": [],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loop th",
          "args": [],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "= s"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "s_tohexstring1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "224-245",
          "snippet": "static YCPValue\ns_tohexstring1 (const YCPInteger &i)\n{\n    /**\n     * @builtin tohexstring\n     * @id tohexstring-1\n     * @short Converts an integer to a hexadecimal string.\n     * @param integer number Number\n     * @return string number in Hex\n     *\n     * @description\n     *\n     * @usage tohexstring (31) -> \"0x1f\"\n     */\n\n    if (i.isNull ())\n\treturn YCPNull ();\n\n    char buffer[64 + 3];\n    snprintf (buffer, 64 + 3, \"0x%llx\", i->value ());\n    return YCPString (buffer);\n}",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_tohexstring1 (const YCPInteger &i)\n{\n    /**\n     * @builtin tohexstring\n     * @id tohexstring-1\n     * @short Converts an integer to a hexadecimal string.\n     * @param integer number Number\n     * @return string number in Hex\n     *\n     * @description\n     *\n     * @usage tohexstring (31) -> \"0x1f\"\n     */\n\n    if (i.isNull ())\n\treturn YCPNull ();\n\n    char buffer[64 + 3];\n    snprintf (buffer, 64 + 3, \"0x%llx\", i->value ());\n    return YCPString (buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpty list",
          "args": [],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stri",
          "args": [],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rge strin",
          "args": [
            "using 'nil'\");\n\treturn YCPNull ("
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2erro",
          "args": [],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(s.isN",
          "args": [],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nrgestring (const YCPList &l, const YCPString &s)\n{\n    /**\n     * @builtin mergestring \n     * @short Joins list elements with a string\n     * @param list<string> PIECES A List of strings\n     * @param string GLUE\n     * @return string \n     * @description\n     *\n     * Returns a string containing a string representation of all the list\n     * elements in the same order, with the glue string between each element.\n     * \n     * List elements which are not of type strings are ignored.\n     *\n     * @see splitstring\n     *\n     * @usage mergestring ([\"\", \"abc\", \"dev\", \"ghi\"], \"/\") -> \"/abc/dev/ghi\"\n     * @usage mergestring ([\"abc\", \"dev\", \"ghi\", \"\"], \"/\") -> \"abc/dev/ghi/\"\n     * @usage mergestring ([1, \"a\", 3], \".\") -> \"a\"\n     * @usage mergestring ([], \".\") -> \"\"\n     * @usage mergestring ([\"abc\", \"dev\", \"ghi\"], \"\") -> \"abcdevghi\"\n     * @usage mergestring ([\"abc\", \"dev\", \"ghi\"], \"123\") -> \"abc123dev123ghi\"\n     */\n     \n    if (l.isNull ())\n\treturn YCPNull ();\n\t\n    if (s.isNull ())\n    {\n\tycp2error (\"Can't merge string using 'nil'\");\n\treturn YCPNull ();\n    }\n\n    string ret;\n\n    if (l->isEmpty ())\t\t// empty list -> empty result\n\treturn YCPString (ret);\n\n    string c = s->value ();\n\n    // loop through list\n\n    for (int i = 0; i < l->size (); i++)\n    {\n\tYCPValue vv = l->value (i);\n\tif (!vv->isString ())\t// skip non-string elements\n\t    continue;\n\tstring vs = vv->asString ()->value ();\n\n\tif (i != 0)\t\t// insert c *between* strings\n\t    ret += c;\n\n\tret += vs;\t\t// add string to result\n    }\n\n    return YCPString (ret);\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "YCPString &s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "657-687",
    "snippet": "lterchars (const YCPString &s, const YCPString &i)\n{\n    /**\n     * @builtin filterchars\n     * @short Filters characters out of a String\n     * @param string STRING\n     * @param string CHARS chars to be included\n     * @return string\n     *\n     * @description\n     * Returns a string that results from string <tt>STRING</tt> by removing\n     * all characters that do not occur in <tt>CHARS</tt>.\n     *\n     * @see deletechars\n     * @usage filterchars (\"a\", \"abcdefghijklmnopqrstuvwxyz\") -> \"a\"\n     * @usage filterchars (\"abc\",\"cde\") -> \"c\"\n     */\n\n    if (s.isNull () || i.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    string include = i->value ();\n    string::size_type pos = 0;\n\n    while (pos = ss.find_first_not_of (include, pos), pos != string::npos)\n\tss.erase (pos, ss.find_first_of (include, pos) - pos);\n\n    return YCPString (ss);\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static YC",
          "args": [
            "al"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_first",
          "args": [
            "f (",
            "clude, pos) - pos);\n\n    return YCPSt"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clude, pos) - po",
          "args": [
            ";",
            "tur"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "= strin",
            ":np"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing::siz",
          "args": [],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing incl",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing ss",
          "args": [],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ull",
          "args": [],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nlterchars (const YCPString &s, const YCPString &i)\n{\n    /**\n     * @builtin filterchars\n     * @short Filters characters out of a String\n     * @param string STRING\n     * @param string CHARS chars to be included\n     * @return string\n     *\n     * @description\n     * Returns a string that results from string <tt>STRING</tt> by removing\n     * all characters that do not occur in <tt>CHARS</tt>.\n     *\n     * @see deletechars\n     * @usage filterchars (\"a\", \"abcdefghijklmnopqrstuvwxyz\") -> \"a\"\n     * @usage filterchars (\"abc\",\"cde\") -> \"c\"\n     */\n\n    if (s.isNull () || i.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    string include = i->value ();\n    string::size_type pos = 0;\n\n    while (pos = ss.find_first_not_of (include, pos), pos != string::npos)\n\tss.erase (pos, ss.find_first_of (include, pos) - pos);\n\n    return YCPString (ss);\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "YCPString &s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "622-654",
    "snippet": "movechars (const YCPString &s, YCPString &r)\n{\n    /**\n     * @builtin deletechars\n     *\n     * @short Removes all characters from a string\n     * @param string STRING\n     * @param string REMOVE Characters to be removed from <tt>STRING</tt>\n     * @return string\n     *\n     * @description\n     * Returns a string that results from string <tt>STRING</tt> by removing\n     * all characters that occur in string <tt>REMOVE</tt>.\n     *\n     * @see filterchars\n     * @usage deletechars (\"a\", \"abcdefghijklmnopqrstuvwxyz\") -> \"\"\n     * @usage deletechars (\"abc\",\"cde\") -> \"ab\"\n     */\n\n    if (s.isNull () || r.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    string include = r->value ();\n    string::size_type pos = 0;\n\n    while (pos = ss.find_first_of (include, pos), pos != string::npos)\n    {\n\tss.erase (pos, ss.find_first_not_of (include, pos) - pos);\n    }\n    return YCPString (ss);\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static YC",
          "args": [
            "al"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_first",
          "args": [
            "ot_",
            "(include, pos) - pos);\n    }\n    return"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            ";\n    }"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clude, pos), pos",
          "args": [
            "= strin",
            ":np"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing::siz",
          "args": [],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing incl",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing ss",
          "args": [],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ull",
          "args": [],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nmovechars (const YCPString &s, YCPString &r)\n{\n    /**\n     * @builtin deletechars\n     *\n     * @short Removes all characters from a string\n     * @param string STRING\n     * @param string REMOVE Characters to be removed from <tt>STRING</tt>\n     * @return string\n     *\n     * @description\n     * Returns a string that results from string <tt>STRING</tt> by removing\n     * all characters that occur in string <tt>REMOVE</tt>.\n     *\n     * @see filterchars\n     * @usage deletechars (\"a\", \"abcdefghijklmnopqrstuvwxyz\") -> \"\"\n     * @usage deletechars (\"abc\",\"cde\") -> \"ab\"\n     */\n\n    if (s.isNull () || r.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    string include = r->value ();\n    string::size_type pos = 0;\n\n    while (pos = ss.find_first_of (include, pos), pos != string::npos)\n    {\n\tss.erase (pos, ss.find_first_not_of (include, pos) - pos);\n    }\n    return YCPString (ss);\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "YCPStrin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "593-619",
    "snippet": "s_toascii (const YCPString &s)\n{\n    /**\n     * @builtin toascii \n     * @short Returns characters below 0x7F included in <tt>STRING</tt>\n     * @param string STRING\n     * @return string\n     *\n     * @description\n     * Returns a string that results from string <tt>STRING</tt> by\n     * copying each character that is below 0x7F (127).\n     *\n     * @usage toascii (\"aB\") -> \"aB\"\n     * @usage toascii (\"123+-abcABC\") -> \"123+-abcABC\"\n     */\n\n    if (s.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    unsigned int w = 0;\n    for (unsigned int i = 0; i < ss.size (); i++)\n\tif (isascii (ss[i]))\n\t    ss[w++] = ss[i];\n    return YCPString (ss.substr (0, w));\n}\n\n\nstatic YCPValue\ns",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(0, w));",
          "args": [
            "static YCPVal"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static",
          "args": [
            "C",
            "a"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss[w+",
          "args": [
            "= ss"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igned in",
          "args": [],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing ss",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\ns_toascii (const YCPString &s)\n{\n    /**\n     * @builtin toascii \n     * @short Returns characters below 0x7F included in <tt>STRING</tt>\n     * @param string STRING\n     * @return string\n     *\n     * @description\n     * Returns a string that results from string <tt>STRING</tt> by\n     * copying each character that is below 0x7F (127).\n     *\n     * @usage toascii (\"aB\") -> \"aB\"\n     * @usage toascii (\"123+-abcABC\") -> \"123+-abcABC\"\n     */\n\n    if (s.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    unsigned int w = 0;\n    for (unsigned int i = 0; i < ss.size (); i++)\n\tif (isascii (ss[i]))\n\t    ss[w++] = ss[i];\n    return YCPString (ss.substr (0, w));\n}\n\n\nstatic YCPValue\ns"
  },
  {
    "function_name": "r (const",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "567-590",
    "snippet": "CPValue\ns_toupper (const YCPString &s)\n{\n    /**\n     * @builtin toupper\n     * @short  Makes a string uppercase\n     *\n     * @description \n     * Returns string with all alphabetic characters converted to\n     * uppercase.\n     \n     * @see toupper\n     * @usage tolower (\"aBcDeF\") -> \"ABCDEF\"\n     * @usage toupper (\"abc\") -> \"ABC\"\n     */\n\n    if (s.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    for (unsigned i = 0; i < ss.size (); i++)\n\tss[i] = toupper (ss[i]);\n    return YCPString (ss);\n}\n\n\nstatic YCPVal",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\n\nstati",
          "args": [
            "YC"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "re",
          "args": [
            "rn YC"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "setEnabled",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "146-150",
          "snippet": "void\nYBreakpoint::setEnabled (bool enable) \n{\n    m_enabled = enable;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  void\n  YBreakpoint::setEnabled (bool enable) \n  {\n      m_enabled = enable;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss[i]",
          "args": [],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for",
          "args": [],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "turn YCP",
          "args": [],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nCPValue\ns_toupper (const YCPString &s)\n{\n    /**\n     * @builtin toupper\n     * @short  Makes a string uppercase\n     *\n     * @description \n     * Returns string with all alphabetic characters converted to\n     * uppercase.\n     \n     * @see toupper\n     * @usage tolower (\"aBcDeF\") -> \"ABCDEF\"\n     * @usage toupper (\"abc\") -> \"ABC\"\n     */\n\n    if (s.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    for (unsigned i = 0; i < ss.size (); i++)\n\tss[i] = toupper (ss[i]);\n    return YCPString (ss);\n}\n\n\nstatic YCPVal"
  },
  {
    "function_name": "s_tolower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "540-564",
    "snippet": "static YCPValue\ns_tolower (const YCPString &s)\n{\n    /**\n     * @builtin tolower\n     * @short Makes a string lowercase\n     * @param string s String\n     * @return string String in lower case\n     *\n     * @description\n     * Returns string with all alphabetic characters converted to lowercase.\n     * Notice: national characters are left unchanged.\n     *\n     * @usage tolower (\"aBcDeF\") -> \"abcdef\"\n     * @usage tolower (\"ABC\") -> \"abc\"\n     */\n\n    if (s.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    for (unsigned i = 0; i < ss.size (); i++)\n\tss[i] = tolower (ss[i]);\n    return YCPString (ss);\n}\n\n\nstati",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g (ss);\n}",
          "args": [
            "s"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(ss[i])",
          "args": [
            "r"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "();",
          "args": [],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_tolower (const YCPString &s)\n{\n    /**\n     * @builtin tolower\n     * @short Makes a string lowercase\n     * @param string s String\n     * @return string String in lower case\n     *\n     * @description\n     * Returns string with all alphabetic characters converted to lowercase.\n     * Notice: national characters are left unchanged.\n     *\n     * @usage tolower (\"aBcDeF\") -> \"abcdef\"\n     * @usage tolower (\"ABC\") -> \"abc\"\n     */\n\n    if (s.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    for (unsigned i = 0; i < ss.size (); i++)\n\tss[i] = tolower (ss[i]);\n    return YCPString (ss);\n}\n\n\nstati"
  },
  {
    "function_name": "s_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "502-537",
    "snippet": "static YCPValue\ns_find (const YCPString &s1, const YCPString &s2)\n{\n    /**\n     * @builtin find\n     * @id find-string\n     * @short Returns position of a substring\n     * @param string STRING1 String\n     * @param string STRING2 Substring\n     * @return integer OFFSET\n     * If substring is not found find returns `-1'.\n     *\n     * @description\n     *\n     * The <tt>find</tt> function searches string for the first occurency of\n     * a specified substring (possibly a single character) and returns its\n     * starting position.\n     * \n     * Returns the first position in <tt>STRING1</tt> where the\n     * string <tt>STRING2</tt> is contained in <tt>STRING1</tt>.\n     * <tt>OFFSET</tt> starts with 0.\n     *\n     * @deprecated Use search() instead\n     * @see findfirstof\n     * @see findfirstnotof\n     * @see search\n     * @usage find (\"abcdefghi\", \"efg\") -> 4\n     * @usage find (\"aaaaa\", \"z\") -> -1\n     */\n\n    YCPValue ret = s_search (s1, s2);\n    if (!ret.isNull () && ret->isVoid ())\n\tret = YCPInteger (-1);\n\n    return ret;\n}",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPInteger",
          "args": [
            "-1"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "YCPInteger",
          "container": "YCPInteger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPInteger.cc",
          "lines": "142-145",
          "snippet": "YCPInteger::YCPInteger (bytecodeistream & str)\n    : YCPValue (new YCPIntegerRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/y2log.h\"\n\nYCPInteger {\n  YCPInteger::YCPInteger (bytecodeistream & str)\n      : YCPValue (new YCPIntegerRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ret->isVoid",
          "args": [],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ret.isNull",
          "args": [],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_search",
          "args": [
            "s1",
            "s2"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "s_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "461-499",
          "snippet": "static YCPValue\ns_search (const YCPString &s1, const YCPString &s2)\n{\n    /**\n     * @builtin search\n     * @short Returns position of a substring\n     * @param string STRING1 String\n     * @param string STRING2 Substring\n     * @return integer OFFSET\n     * If substring is not found search returns `nil'.\n     *\n     * @description\n     *\n     * The <tt>search</tt> function searches string for the first occurency of\n     * a specified substring (possibly a single character) and returns its\n     * starting position.\n     * \n     * Returns the first position in <tt>STRING1</tt> where the\n     * string <tt>STRING2</tt> is contained in <tt>STRING1</tt>.\n     * <tt>OFFSET</tt> starts with 0.\n     *\n     * @see findfirstof\n     * @see findfirstnotof\n     * @see find\n     * @usage search (\"abcdefghi\", \"efg\") -> 4\n     * @usage search (\"aaaaa\", \"z\") -> nil\n     */\n\n    if (s1.isNull () || s2.isNull ())\n\treturn YCPNull ();\n\n    string ss1 = s1->value ();\n    string::size_type pos = ss1.find (s2->value ());\n\n    if (pos == string::npos)\n\treturn YCPVoid ();\t\t// not found\n    else\n\treturn YCPInteger (pos);\t// found\n}",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_search (const YCPString &s1, const YCPString &s2)\n{\n    /**\n     * @builtin search\n     * @short Returns position of a substring\n     * @param string STRING1 String\n     * @param string STRING2 Substring\n     * @return integer OFFSET\n     * If substring is not found search returns `nil'.\n     *\n     * @description\n     *\n     * The <tt>search</tt> function searches string for the first occurency of\n     * a specified substring (possibly a single character) and returns its\n     * starting position.\n     * \n     * Returns the first position in <tt>STRING1</tt> where the\n     * string <tt>STRING2</tt> is contained in <tt>STRING1</tt>.\n     * <tt>OFFSET</tt> starts with 0.\n     *\n     * @see findfirstof\n     * @see findfirstnotof\n     * @see find\n     * @usage search (\"abcdefghi\", \"efg\") -> 4\n     * @usage search (\"aaaaa\", \"z\") -> nil\n     */\n\n    if (s1.isNull () || s2.isNull ())\n\treturn YCPNull ();\n\n    string ss1 = s1->value ();\n    string::size_type pos = ss1.find (s2->value ());\n\n    if (pos == string::npos)\n\treturn YCPVoid ();\t\t// not found\n    else\n\treturn YCPInteger (pos);\t// found\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_find (const YCPString &s1, const YCPString &s2)\n{\n    /**\n     * @builtin find\n     * @id find-string\n     * @short Returns position of a substring\n     * @param string STRING1 String\n     * @param string STRING2 Substring\n     * @return integer OFFSET\n     * If substring is not found find returns `-1'.\n     *\n     * @description\n     *\n     * The <tt>find</tt> function searches string for the first occurency of\n     * a specified substring (possibly a single character) and returns its\n     * starting position.\n     * \n     * Returns the first position in <tt>STRING1</tt> where the\n     * string <tt>STRING2</tt> is contained in <tt>STRING1</tt>.\n     * <tt>OFFSET</tt> starts with 0.\n     *\n     * @deprecated Use search() instead\n     * @see findfirstof\n     * @see findfirstnotof\n     * @see search\n     * @usage find (\"abcdefghi\", \"efg\") -> 4\n     * @usage find (\"aaaaa\", \"z\") -> -1\n     */\n\n    YCPValue ret = s_search (s1, s2);\n    if (!ret.isNull () && ret->isVoid ())\n\tret = YCPInteger (-1);\n\n    return ret;\n}"
  },
  {
    "function_name": "s_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "461-499",
    "snippet": "static YCPValue\ns_search (const YCPString &s1, const YCPString &s2)\n{\n    /**\n     * @builtin search\n     * @short Returns position of a substring\n     * @param string STRING1 String\n     * @param string STRING2 Substring\n     * @return integer OFFSET\n     * If substring is not found search returns `nil'.\n     *\n     * @description\n     *\n     * The <tt>search</tt> function searches string for the first occurency of\n     * a specified substring (possibly a single character) and returns its\n     * starting position.\n     * \n     * Returns the first position in <tt>STRING1</tt> where the\n     * string <tt>STRING2</tt> is contained in <tt>STRING1</tt>.\n     * <tt>OFFSET</tt> starts with 0.\n     *\n     * @see findfirstof\n     * @see findfirstnotof\n     * @see find\n     * @usage search (\"abcdefghi\", \"efg\") -> 4\n     * @usage search (\"aaaaa\", \"z\") -> nil\n     */\n\n    if (s1.isNull () || s2.isNull ())\n\treturn YCPNull ();\n\n    string ss1 = s1->value ();\n    string::size_type pos = ss1.find (s2->value ());\n\n    if (pos == string::npos)\n\treturn YCPVoid ();\t\t// not found\n    else\n\treturn YCPInteger (pos);\t// found\n}",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPInteger",
          "args": [
            "pos"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "YCPInteger",
          "container": "YCPInteger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPInteger.cc",
          "lines": "142-145",
          "snippet": "YCPInteger::YCPInteger (bytecodeistream & str)\n    : YCPValue (new YCPIntegerRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/y2log.h\"\n\nYCPInteger {\n  YCPInteger::YCPInteger (bytecodeistream & str)\n      : YCPValue (new YCPIntegerRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss1.find",
          "args": [
            "s2->value ()"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2->value",
          "args": [],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2.isNull",
          "args": [],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.isNull",
          "args": [],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_search (const YCPString &s1, const YCPString &s2)\n{\n    /**\n     * @builtin search\n     * @short Returns position of a substring\n     * @param string STRING1 String\n     * @param string STRING2 Substring\n     * @return integer OFFSET\n     * If substring is not found search returns `nil'.\n     *\n     * @description\n     *\n     * The <tt>search</tt> function searches string for the first occurency of\n     * a specified substring (possibly a single character) and returns its\n     * starting position.\n     * \n     * Returns the first position in <tt>STRING1</tt> where the\n     * string <tt>STRING2</tt> is contained in <tt>STRING1</tt>.\n     * <tt>OFFSET</tt> starts with 0.\n     *\n     * @see findfirstof\n     * @see findfirstnotof\n     * @see find\n     * @usage search (\"abcdefghi\", \"efg\") -> 4\n     * @usage search (\"aaaaa\", \"z\") -> nil\n     */\n\n    if (s1.isNull () || s2.isNull ())\n\treturn YCPNull ();\n\n    string ss1 = s1->value ();\n    string::size_type pos = ss1.find (s2->value ());\n\n    if (pos == string::npos)\n\treturn YCPVoid ();\t\t// not found\n    else\n\treturn YCPInteger (pos);\t// found\n}"
  },
  {
    "function_name": "s_lsubstring2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "406-458",
    "snippet": "static YCPValue\ns_lsubstring2 (const YCPString &s, const YCPInteger &i1, const YCPInteger &i2)\n{\n    /**\n     * @builtin lsubstring\n     * @id lsubstring-length\n     * @short Extracts a substring in UTF-8 encoded string\n     *\n     * @description\n     * Extracts a substring of the string <tt>STRING</tt>, starting at\n     * <tt>OFFSET</tt> after the first one with length of at most\n     * <tt>LENGTH</tt>. <tt>OFFSET</tt> starts with 0. This method uses UTF-8 encoding.\n     *\n     * @param string STRING\n     * @param integer OFFSET\n     * @param integer LENGTH\n     * @return string\n     * @usage lsubstring (\"some text\", 5, 2) -> \"te\"\n     * @usage lsubstring (\"some text\", 42, 2) -> \"\"\n     * @usage lsubstring(\"123456789\", 2, 3) -> \"345\"\n     */\n\n    if (s.isNull () || i1.isNull() || i2.isNull ())\n\treturn YCPNull ();\n\n    string lss = s->value ();\n    wstring ss;\n    \n    if( ! utf82wchar( lss, &ss ) )\n    {\n\ty2error( \"Unable to recode string '%s' to UTF-8\", lss.c_str() );\n\treturn YCPNull ();\n    }\n    \n    string::size_type start = i1->value ();\n    string::size_type length = i2->value ();\n\n    if (start > ss.size ())\n    {\n\tycp2error (\"Substring index out of range\");\n\treturn YCPString (\"\");\n    }\n\n    ss = ss.substr (start, length);\n    \n    if( !wchar2utf8( ss, &lss ) )\n    {\n\ty2error( \"Unable to recode result string '%ls' from UTF-8\", ss.c_str() );\n\treturn YCPNull ();\n    }\n    \n    return YCPString(lss);\n}",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "lss"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "YCPString& or",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "1389-1417",
          "snippet": "yptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nyptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unable to recode result string '%ls' from UTF-8\"",
            "ss.c_str()"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss.c_str",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wchar2utf8",
          "args": [
            "ss",
            "&lss"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "wchar2utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
          "lines": "117-142",
          "snippet": "bool\nwchar2utf8 (const std::wstring& in, std::string* out)\n{\n    static iconv_t cd = (iconv_t)(-1);\n\n    if (cd == (iconv_t)(-1))\n    {\n\tcd = iconv_open (\"UTF-8\", \"WCHAR_T\");\n\n\t// TODO: also call iconv_close somewhere, perhaps use\n\t// pthread_key_create et.al.\n\n\tif (cd == (iconv_t)(-1))\n\t{\n\t    static bool shown_once = false;\n\t    if (!shown_once) {\n\t\ty2error (\"iconv_open: %m\");\n\t\tshown_once = true;\n\t    }\n\n\t    return false;\n\t}\n    }\n\n    return recode (cd, in, out);\n}",
          "includes": [
            "#include \"y2string.h\"",
            "#include \"y2log.h\"",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nwchar2utf8 (const std::wstring& in, std::string* out)\n{\n    static iconv_t cd = (iconv_t)(-1);\n\n    if (cd == (iconv_t)(-1))\n    {\n\tcd = iconv_open (\"UTF-8\", \"WCHAR_T\");\n\n\t// TODO: also call iconv_close somewhere, perhaps use\n\t// pthread_key_create et.al.\n\n\tif (cd == (iconv_t)(-1))\n\t{\n\t    static bool shown_once = false;\n\t    if (!shown_once) {\n\t\ty2error (\"iconv_open: %m\");\n\t\tshown_once = true;\n\t    }\n\n\t    return false;\n\t}\n    }\n\n    return recode (cd, in, out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss.substr",
          "args": [
            "start",
            "length"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Substring index out of range\""
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss.size",
          "args": [],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2->value",
          "args": [],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unable to recode string '%s' to UTF-8\"",
            "lss.c_str()"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lss.c_str",
          "args": [],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utf82wchar",
          "args": [
            "lss",
            "&ss"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "utf82wchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
          "lines": "89-114",
          "snippet": "bool\nutf82wchar (const std::string& in, std::wstring* out)\n{\n    static iconv_t cd = (iconv_t)(-1);\n\n    if (cd == (iconv_t)(-1))\n    {\n\tcd = iconv_open (\"WCHAR_T\", \"UTF-8\");\n\n\t// TODO: also call iconv_close somewhere, perhaps use\n\t// pthread_key_create et.al.\n\n\tif (cd == (iconv_t)(-1))\n\t{\n\t    static bool shown_once = false;\n\t    if (!shown_once) {\n\t\ty2error (\"iconv_open: %m\");\n\t\tshown_once = true;\n\t    }\n\n\t    return false;\n\t}\n    }\n\n    return recode (cd, in, out);\n}",
          "includes": [
            "#include \"y2string.h\"",
            "#include \"y2log.h\"",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nutf82wchar (const std::string& in, std::wstring* out)\n{\n    static iconv_t cd = (iconv_t)(-1);\n\n    if (cd == (iconv_t)(-1))\n    {\n\tcd = iconv_open (\"WCHAR_T\", \"UTF-8\");\n\n\t// TODO: also call iconv_close somewhere, perhaps use\n\t// pthread_key_create et.al.\n\n\tif (cd == (iconv_t)(-1))\n\t{\n\t    static bool shown_once = false;\n\t    if (!shown_once) {\n\t\ty2error (\"iconv_open: %m\");\n\t\tshown_once = true;\n\t    }\n\n\t    return false;\n\t}\n    }\n\n    return recode (cd, in, out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "s->value",
          "args": [],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YConst",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "342-346",
          "snippet": "YCPValue\nYConst::value() const\n{\n    return m_value;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYConst {\n  YCPValue\n  YConst::value() const\n  {\n      return m_value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i2.isNull",
          "args": [],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i1.isNull",
          "args": [],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.isNull",
          "args": [],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_lsubstring2 (const YCPString &s, const YCPInteger &i1, const YCPInteger &i2)\n{\n    /**\n     * @builtin lsubstring\n     * @id lsubstring-length\n     * @short Extracts a substring in UTF-8 encoded string\n     *\n     * @description\n     * Extracts a substring of the string <tt>STRING</tt>, starting at\n     * <tt>OFFSET</tt> after the first one with length of at most\n     * <tt>LENGTH</tt>. <tt>OFFSET</tt> starts with 0. This method uses UTF-8 encoding.\n     *\n     * @param string STRING\n     * @param integer OFFSET\n     * @param integer LENGTH\n     * @return string\n     * @usage lsubstring (\"some text\", 5, 2) -> \"te\"\n     * @usage lsubstring (\"some text\", 42, 2) -> \"\"\n     * @usage lsubstring(\"123456789\", 2, 3) -> \"345\"\n     */\n\n    if (s.isNull () || i1.isNull() || i2.isNull ())\n\treturn YCPNull ();\n\n    string lss = s->value ();\n    wstring ss;\n    \n    if( ! utf82wchar( lss, &ss ) )\n    {\n\ty2error( \"Unable to recode string '%s' to UTF-8\", lss.c_str() );\n\treturn YCPNull ();\n    }\n    \n    string::size_type start = i1->value ();\n    string::size_type length = i2->value ();\n\n    if (start > ss.size ())\n    {\n\tycp2error (\"Substring index out of range\");\n\treturn YCPString (\"\");\n    }\n\n    ss = ss.substr (start, length);\n    \n    if( !wchar2utf8( ss, &lss ) )\n    {\n\ty2error( \"Unable to recode result string '%ls' from UTF-8\", ss.c_str() );\n\treturn YCPNull ();\n    }\n    \n    return YCPString(lss);\n}"
  },
  {
    "function_name": "s_lsubstring1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "353-403",
    "snippet": "static YCPValue\ns_lsubstring1 (const YCPString &s, const YCPInteger &i1)\n{\n    /**\n     * @builtin lsubstring\n     * @id lsubstring-rest\n     * @short Extracts a substring in UTF-8 encoded string\n     *\n     * @description\n     * Extracts a substring of the string <tt>STRING</tt>, starting at\n     * <tt>OFFSET</tt> after the first one with length of at most\n     * <tt>LENGTH</tt>. <tt>OFFSET</tt> starts with 0. This method uses UTF-8 encoding.\n     *\n     * @param string STRING\n     * @param integer OFFSET\n     * @param integer LENGTH\n     * @return string\n     * @usage substring (\"some text\", 5) -> \"text\"\n     * @usage substring (\"some text\", 42) -> \"\"\n     */\n\n    if (s.isNull () || i1.isNull())\n\treturn YCPNull ();\n\n    string lss = s->value ();\n    wstring ss;\n    \n    if( ! utf82wchar( lss, &ss ) )\n    {\n\ty2error( \"Unable to recode string '%s' to UTF-8\", lss.c_str() );\n\treturn YCPNull ();\n    }\n    \n    string::size_type start = i1->value ();\n\n    if (start > ss.size ())\n    {\n\tycp2error (\"Substring index out of range\");\n\treturn YCPString (\"\");\n    }\n\n    ss = ss.substr ((wstring::size_type) start, wstring::npos);\n    \n    if( !wchar2utf8( ss, &lss ) )\n    {\n\ty2error( \"Unable to recode result string '%ls' from UTF-8\", ss.c_str() );\n\treturn YCPNull ();\n    }\n    \n    return YCPString(lss);\n}",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "lss"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "YCPString& or",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "1389-1417",
          "snippet": "yptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nyptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unable to recode result string '%ls' from UTF-8\"",
            "ss.c_str()"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss.c_str",
          "args": [],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wchar2utf8",
          "args": [
            "ss",
            "&lss"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "wchar2utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
          "lines": "117-142",
          "snippet": "bool\nwchar2utf8 (const std::wstring& in, std::string* out)\n{\n    static iconv_t cd = (iconv_t)(-1);\n\n    if (cd == (iconv_t)(-1))\n    {\n\tcd = iconv_open (\"UTF-8\", \"WCHAR_T\");\n\n\t// TODO: also call iconv_close somewhere, perhaps use\n\t// pthread_key_create et.al.\n\n\tif (cd == (iconv_t)(-1))\n\t{\n\t    static bool shown_once = false;\n\t    if (!shown_once) {\n\t\ty2error (\"iconv_open: %m\");\n\t\tshown_once = true;\n\t    }\n\n\t    return false;\n\t}\n    }\n\n    return recode (cd, in, out);\n}",
          "includes": [
            "#include \"y2string.h\"",
            "#include \"y2log.h\"",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nwchar2utf8 (const std::wstring& in, std::string* out)\n{\n    static iconv_t cd = (iconv_t)(-1);\n\n    if (cd == (iconv_t)(-1))\n    {\n\tcd = iconv_open (\"UTF-8\", \"WCHAR_T\");\n\n\t// TODO: also call iconv_close somewhere, perhaps use\n\t// pthread_key_create et.al.\n\n\tif (cd == (iconv_t)(-1))\n\t{\n\t    static bool shown_once = false;\n\t    if (!shown_once) {\n\t\ty2error (\"iconv_open: %m\");\n\t\tshown_once = true;\n\t    }\n\n\t    return false;\n\t}\n    }\n\n    return recode (cd, in, out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss.substr",
          "args": [
            "(wstring::size_type) start",
            "wstring::npos"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Substring index out of range\""
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss.size",
          "args": [],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "i1->value",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unable to recode string '%s' to UTF-8\"",
            "lss.c_str()"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lss.c_str",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utf82wchar",
          "args": [
            "lss",
            "&ss"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "utf82wchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
          "lines": "89-114",
          "snippet": "bool\nutf82wchar (const std::string& in, std::wstring* out)\n{\n    static iconv_t cd = (iconv_t)(-1);\n\n    if (cd == (iconv_t)(-1))\n    {\n\tcd = iconv_open (\"WCHAR_T\", \"UTF-8\");\n\n\t// TODO: also call iconv_close somewhere, perhaps use\n\t// pthread_key_create et.al.\n\n\tif (cd == (iconv_t)(-1))\n\t{\n\t    static bool shown_once = false;\n\t    if (!shown_once) {\n\t\ty2error (\"iconv_open: %m\");\n\t\tshown_once = true;\n\t    }\n\n\t    return false;\n\t}\n    }\n\n    return recode (cd, in, out);\n}",
          "includes": [
            "#include \"y2string.h\"",
            "#include \"y2log.h\"",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nutf82wchar (const std::string& in, std::wstring* out)\n{\n    static iconv_t cd = (iconv_t)(-1);\n\n    if (cd == (iconv_t)(-1))\n    {\n\tcd = iconv_open (\"WCHAR_T\", \"UTF-8\");\n\n\t// TODO: also call iconv_close somewhere, perhaps use\n\t// pthread_key_create et.al.\n\n\tif (cd == (iconv_t)(-1))\n\t{\n\t    static bool shown_once = false;\n\t    if (!shown_once) {\n\t\ty2error (\"iconv_open: %m\");\n\t\tshown_once = true;\n\t    }\n\n\t    return false;\n\t}\n    }\n\n    return recode (cd, in, out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "s->value",
          "args": [],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YConst",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "342-346",
          "snippet": "YCPValue\nYConst::value() const\n{\n    return m_value;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYConst {\n  YCPValue\n  YConst::value() const\n  {\n      return m_value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i1.isNull",
          "args": [],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.isNull",
          "args": [],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_lsubstring1 (const YCPString &s, const YCPInteger &i1)\n{\n    /**\n     * @builtin lsubstring\n     * @id lsubstring-rest\n     * @short Extracts a substring in UTF-8 encoded string\n     *\n     * @description\n     * Extracts a substring of the string <tt>STRING</tt>, starting at\n     * <tt>OFFSET</tt> after the first one with length of at most\n     * <tt>LENGTH</tt>. <tt>OFFSET</tt> starts with 0. This method uses UTF-8 encoding.\n     *\n     * @param string STRING\n     * @param integer OFFSET\n     * @param integer LENGTH\n     * @return string\n     * @usage substring (\"some text\", 5) -> \"text\"\n     * @usage substring (\"some text\", 42) -> \"\"\n     */\n\n    if (s.isNull () || i1.isNull())\n\treturn YCPNull ();\n\n    string lss = s->value ();\n    wstring ss;\n    \n    if( ! utf82wchar( lss, &ss ) )\n    {\n\ty2error( \"Unable to recode string '%s' to UTF-8\", lss.c_str() );\n\treturn YCPNull ();\n    }\n    \n    string::size_type start = i1->value ();\n\n    if (start > ss.size ())\n    {\n\tycp2error (\"Substring index out of range\");\n\treturn YCPString (\"\");\n    }\n\n    ss = ss.substr ((wstring::size_type) start, wstring::npos);\n    \n    if( !wchar2utf8( ss, &lss ) )\n    {\n\ty2error( \"Unable to recode result string '%ls' from UTF-8\", ss.c_str() );\n\treturn YCPNull ();\n    }\n    \n    return YCPString(lss);\n}"
  },
  {
    "function_name": "s_substring2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "314-350",
    "snippet": "static YCPValue\ns_substring2 (const YCPString &s, const YCPInteger &i1, const YCPInteger &i2)\n{\n    /**\n     * @builtin substring\n     * @id substring-length\n     * @short Extracts a substring\n     *\n     * @description\n     * Extracts a substring of the string <tt>STRING</tt>, starting at\n     * <tt>OFFSET</tt> after the first one with length of at most\n     * <tt>LENGTH</tt>. <tt>OFFSET</tt> starts with 0.\n     *\n     * @param string STRING\n     * @param integer OFFSET\n     * @param integer LENGTH\n     * @return string\n     * @usage substring (\"some text\", 5, 2) -> \"te\"\n     * @usage substring (\"some text\", 42, 2) -> \"\"\n     * @usage substring(\"123456789\", 2, 3) -> \"345\"\n     */\n\n    if (s.isNull () || i1.isNull() || i2.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    string::size_type start = i1->value ();\n    string::size_type length = i2->value ();\n\n    if (start > ss.size ())\n    {\n\tycp2error (\"Substring index out of range\");\n\treturn YCPString (\"\");\n    }\n\n    return YCPString (ss.substr (start, length));\n}",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "ss.substr (start, length)"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "YCPString& or",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "1389-1417",
          "snippet": "yptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nyptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns"
        }
      },
      {
        "call_info": {
          "callee": "ss.substr",
          "args": [
            "start",
            "length"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Substring index out of range\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss.size",
          "args": [],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2->value",
          "args": [],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s->value",
          "args": [],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YConst",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "342-346",
          "snippet": "YCPValue\nYConst::value() const\n{\n    return m_value;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYConst {\n  YCPValue\n  YConst::value() const\n  {\n      return m_value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i2.isNull",
          "args": [],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i1.isNull",
          "args": [],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.isNull",
          "args": [],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_substring2 (const YCPString &s, const YCPInteger &i1, const YCPInteger &i2)\n{\n    /**\n     * @builtin substring\n     * @id substring-length\n     * @short Extracts a substring\n     *\n     * @description\n     * Extracts a substring of the string <tt>STRING</tt>, starting at\n     * <tt>OFFSET</tt> after the first one with length of at most\n     * <tt>LENGTH</tt>. <tt>OFFSET</tt> starts with 0.\n     *\n     * @param string STRING\n     * @param integer OFFSET\n     * @param integer LENGTH\n     * @return string\n     * @usage substring (\"some text\", 5, 2) -> \"te\"\n     * @usage substring (\"some text\", 42, 2) -> \"\"\n     * @usage substring(\"123456789\", 2, 3) -> \"345\"\n     */\n\n    if (s.isNull () || i1.isNull() || i2.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    string::size_type start = i1->value ();\n    string::size_type length = i2->value ();\n\n    if (start > ss.size ())\n    {\n\tycp2error (\"Substring index out of range\");\n\treturn YCPString (\"\");\n    }\n\n    return YCPString (ss.substr (start, length));\n}"
  },
  {
    "function_name": "s_substring1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "274-311",
    "snippet": "static YCPValue\ns_substring1 (const YCPString &s, const YCPInteger &i1)\n{\n    /**\n     * @builtin substring\n     * @id substring-rest\n     * @short Returns part of a string\n     * @param string STRING Original String\n     * @param integer OFFSET Start position\n     * @optarg integer LENGTH Length of new string\n     * @return string \n     * @description\n     *\n     * Returns the portion of <tt>STRING</tt>  specified by the <tt>OFFSET</tt>\n     * and <tt>LENGHT</tt> parameters. <tt>OFFSET</tt> starts with 0.\n     *\n     * @usage substring (\"some text\", 5) -> \"text\"\n     * @usage substring (\"some text\", 42) -> \"\"\n     * @usage substring (\"some text\", 5, 2) -> \"te\"\n     * @usage substring (\"some text\", 42, 2) -> \"\"\n     * @usage substring(\"123456789\", 2, 3) -> \"345\"\n     */\n\n    if (s.isNull () || i1.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    int start = i1->value ();\n\n    if ((start < 0)\n\t|| ((size_t)start > ss.size ()))\n    {\n\tycp2error(\"Substring index out of range\");\n\treturn YCPString (\"\");\n    }\n\n    return YCPString (ss.substr ((string::size_type) start, string::npos));\n}",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "ss.substr ((string::size_type) start, string::npos)"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "YCPString& or",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "1389-1417",
          "snippet": "yptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nyptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns"
        }
      },
      {
        "call_info": {
          "callee": "ss.substr",
          "args": [
            "(string::size_type) start",
            "string::npos"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Substring index out of range\""
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss.size",
          "args": [],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "i1->value",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s->value",
          "args": [],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YConst",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "342-346",
          "snippet": "YCPValue\nYConst::value() const\n{\n    return m_value;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYConst {\n  YCPValue\n  YConst::value() const\n  {\n      return m_value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i1.isNull",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.isNull",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_substring1 (const YCPString &s, const YCPInteger &i1)\n{\n    /**\n     * @builtin substring\n     * @id substring-rest\n     * @short Returns part of a string\n     * @param string STRING Original String\n     * @param integer OFFSET Start position\n     * @optarg integer LENGTH Length of new string\n     * @return string \n     * @description\n     *\n     * Returns the portion of <tt>STRING</tt>  specified by the <tt>OFFSET</tt>\n     * and <tt>LENGHT</tt> parameters. <tt>OFFSET</tt> starts with 0.\n     *\n     * @usage substring (\"some text\", 5) -> \"text\"\n     * @usage substring (\"some text\", 42) -> \"\"\n     * @usage substring (\"some text\", 5, 2) -> \"te\"\n     * @usage substring (\"some text\", 42, 2) -> \"\"\n     * @usage substring(\"123456789\", 2, 3) -> \"345\"\n     */\n\n    if (s.isNull () || i1.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    int start = i1->value ();\n\n    if ((start < 0)\n\t|| ((size_t)start > ss.size ()))\n    {\n\tycp2error(\"Substring index out of range\");\n\treturn YCPString (\"\");\n    }\n\n    return YCPString (ss.substr ((string::size_type) start, string::npos));\n}"
  },
  {
    "function_name": "s_tohexstring2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "248-271",
    "snippet": "static YCPValue\ns_tohexstring2 (const YCPInteger &i, const YCPInteger &w)\n{\n    /**\n     * @builtin tohexstring\n     * @id tohexstring-2\n     * @short Converts an integer to a hexadecimal string.\n     * @param integer number Number\n     * @param integer width Width\n     * @return string number in Hex\n     *\n     * @description\n     *\n     * @usage tohexstring (31, 1) -> \"0x1f\"\n     * @usage tohexstring (31, 4) -> \"0x001f\"\n     */\n\n    if (i.isNull () || w.isNull())\n\treturn YCPNull ();\n\n    char buffer[64 + 3];\n    snprintf (buffer, 64 + 3, \"0x%0*llx\", (int) w->value(), i->value ());\n    return YCPString (buffer);\n}",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "buffer"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "YCPString& or",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "1389-1417",
          "snippet": "yptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nyptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "64 + 3",
            "\"0x%0*llx\"",
            "(int) w->value()",
            "i->value ()"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->value",
          "args": [],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "w.isNull",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.isNull",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_tohexstring2 (const YCPInteger &i, const YCPInteger &w)\n{\n    /**\n     * @builtin tohexstring\n     * @id tohexstring-2\n     * @short Converts an integer to a hexadecimal string.\n     * @param integer number Number\n     * @param integer width Width\n     * @return string number in Hex\n     *\n     * @description\n     *\n     * @usage tohexstring (31, 1) -> \"0x1f\"\n     * @usage tohexstring (31, 4) -> \"0x001f\"\n     */\n\n    if (i.isNull () || w.isNull())\n\treturn YCPNull ();\n\n    char buffer[64 + 3];\n    snprintf (buffer, 64 + 3, \"0x%0*llx\", (int) w->value(), i->value ());\n    return YCPString (buffer);\n}"
  },
  {
    "function_name": "s_tohexstring1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "224-245",
    "snippet": "static YCPValue\ns_tohexstring1 (const YCPInteger &i)\n{\n    /**\n     * @builtin tohexstring\n     * @id tohexstring-1\n     * @short Converts an integer to a hexadecimal string.\n     * @param integer number Number\n     * @return string number in Hex\n     *\n     * @description\n     *\n     * @usage tohexstring (31) -> \"0x1f\"\n     */\n\n    if (i.isNull ())\n\treturn YCPNull ();\n\n    char buffer[64 + 3];\n    snprintf (buffer, 64 + 3, \"0x%llx\", i->value ());\n    return YCPString (buffer);\n}",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "buffer"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "YCPString& or",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "1389-1417",
          "snippet": "yptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nyptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "64 + 3",
            "\"0x%llx\"",
            "i->value ()"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->value",
          "args": [],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.isNull",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_tohexstring1 (const YCPInteger &i)\n{\n    /**\n     * @builtin tohexstring\n     * @id tohexstring-1\n     * @short Converts an integer to a hexadecimal string.\n     * @param integer number Number\n     * @return string number in Hex\n     *\n     * @description\n     *\n     * @usage tohexstring (31) -> \"0x1f\"\n     */\n\n    if (i.isNull ())\n\treturn YCPNull ();\n\n    char buffer[64 + 3];\n    snprintf (buffer, 64 + 3, \"0x%llx\", i->value ());\n    return YCPString (buffer);\n}"
  },
  {
    "function_name": "s_issubstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "199-221",
    "snippet": "static YCPValue\ns_issubstring (const YCPString &target, const YCPString &sub)\n{\n    /**\n     * @builtin issubstring\n     * @short searches for a specific string within another string\n     * @param string s String to be searched\n     * @param string substring Pattern to be searched for\n     * @return boolean\n     * @description \n     * Return true, if <tt>substring</tt> is a substring of <tt>s</tt>.\n     *\n     * @usage issubstring (\"some text\", \"tex\") -> true\n     */\n\n    if (target.isNull () || sub.isNull ())\n\treturn YCPNull ();\n\n    string s = target->value ();\n    string substring = sub->value ();\n\t//y2milestone (\"'%s' '%s' %p\", s.c_str(), substring.c_str(), (void *)(s.find (substring)));\n    return YCPBoolean (s.find (substring) != string::npos);\n}",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "s.find (substring) != string::npos"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.find",
          "args": [
            "substring"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sub->value",
          "args": [],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sub.isNull",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.isNull",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_issubstring (const YCPString &target, const YCPString &sub)\n{\n    /**\n     * @builtin issubstring\n     * @short searches for a specific string within another string\n     * @param string s String to be searched\n     * @param string substring Pattern to be searched for\n     * @return boolean\n     * @description \n     * Return true, if <tt>substring</tt> is a substring of <tt>s</tt>.\n     *\n     * @usage issubstring (\"some text\", \"tex\") -> true\n     */\n\n    if (target.isNull () || sub.isNull ())\n\treturn YCPNull ();\n\n    string s = target->value ();\n    string substring = sub->value ();\n\t//y2milestone (\"'%s' '%s' %p\", s.c_str(), substring.c_str(), (void *)(s.find (substring)));\n    return YCPBoolean (s.find (substring) != string::npos);\n}"
  },
  {
    "function_name": "s_plus4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "174-196",
    "snippet": "static YCPValue\ns_plus4 (const YCPString &s1, const YCPSymbol &s2)\n{\n    /**\n     * @operator string s1 + symbol s2 -> string\n     * @short String and symbol Concatenation\n     *\n     * @description\n     * Returns concatenation of <tt>s1</tt> and <tt>s2</tt> after\n     * transforming <tt>s2</tt> to a string AND stripping the leading\n     * backquote.\n     *\n     * Example: \n     * <code>\n     * \"YaST\" + `two -> \"YaSTtwo\"\n     * </code>\n     */\n\n    if (s1.isNull () || s2.isNull ())\n\treturn YCPNull ();\n\n    return YCPString (s1->value () + s2->symbol());\n}",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "s1->value () + s2->symbol()"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "YCPString& or",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "1389-1417",
          "snippet": "yptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nyptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns"
        }
      },
      {
        "call_info": {
          "callee": "s2->symbol",
          "args": [],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "symbol",
          "container": "YCPSymbolRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "40-44",
          "snippet": "string\nYCPSymbolRep::symbol() const\n{\n    return v.asString();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbolRep {\n  string\n  YCPSymbolRep::symbol() const\n  {\n      return v.asString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s1->value",
          "args": [],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2.isNull",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.isNull",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_plus4 (const YCPString &s1, const YCPSymbol &s2)\n{\n    /**\n     * @operator string s1 + symbol s2 -> string\n     * @short String and symbol Concatenation\n     *\n     * @description\n     * Returns concatenation of <tt>s1</tt> and <tt>s2</tt> after\n     * transforming <tt>s2</tt> to a string AND stripping the leading\n     * backquote.\n     *\n     * Example: \n     * <code>\n     * \"YaST\" + `two -> \"YaSTtwo\"\n     * </code>\n     */\n\n    if (s1.isNull () || s2.isNull ())\n\treturn YCPNull ();\n\n    return YCPString (s1->value () + s2->symbol());\n}"
  },
  {
    "function_name": "s_plus3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "151-171",
    "snippet": "static YCPValue\ns_plus3 (const YCPString &s1, const YCPPath &p2)\n{\n    /**\n     * @operator string s1 + path p2 -> string\n     * @short String and path Concatenation\n     * @description\n     * Returns concatenation of <tt>s1</tt> and <tt>p2</tt> after\n     * transforming <tt>p2</tt> to a string.\n     *\n     * Example: \n     * <code>\n     * \"YaST\" + .two -> \"YaST.two\"\n     * </code>\n     */\n\n    if (s1.isNull () || p2.isNull ())\n\treturn YCPNull ();\n\n    return YCPString (s1->value () + p2->toString ());\n}",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "s1->value () + p2->toString ()"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "YCPString& or",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "1389-1417",
          "snippet": "yptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nyptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns"
        }
      },
      {
        "call_info": {
          "callee": "p2->toString",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s1->value",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p2.isNull",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.isNull",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_plus3 (const YCPString &s1, const YCPPath &p2)\n{\n    /**\n     * @operator string s1 + path p2 -> string\n     * @short String and path Concatenation\n     * @description\n     * Returns concatenation of <tt>s1</tt> and <tt>p2</tt> after\n     * transforming <tt>p2</tt> to a string.\n     *\n     * Example: \n     * <code>\n     * \"YaST\" + .two -> \"YaST.two\"\n     * </code>\n     */\n\n    if (s1.isNull () || p2.isNull ())\n\treturn YCPNull ();\n\n    return YCPString (s1->value () + p2->toString ());\n}"
  },
  {
    "function_name": "s_plus2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "126-148",
    "snippet": "static YCPValue\ns_plus2 (const YCPString &s1, const YCPInteger &i2)\n{\n    /**\n     * @operator string s1 + integer i2 -> string\n     * @short String and integer Concatenation \n     *\n     * @description\n     * Returns concatenation of <tt>s1</tt> and <tt>i2</tt> after\n     * transforming <tt>i2</tt> to a string.\n     *\n     * Example: \n     *\n     * <code>\n     * \"YaST\" + 2 -> \"YaST2\"\n     * </code>\n     */\n\n    if (s1.isNull () || i2.isNull ())\n\treturn YCPNull ();\n\n    return YCPString (s1->value () + toString (i2->value ()));\n}",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "s1->value () + toString (i2->value ())"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "YCPString& or",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "1389-1417",
          "snippet": "yptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nyptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns"
        }
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [
            "i2->value ()"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "158-232",
          "snippet": "string \nYSymbolEntry::toString (bool with_type) const\n{\n    string s = (with_type && m_global) ? \"global \" : \"\";\n#if DO_DEBUG\n    y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n    y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n#endif\n    switch (m_category)\n    {\n\tcase c_variable:\n\tcase c_reference:\n\tcase c_function:\n#if DO_DEBUG\n\t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n#endif\n\tcase c_builtin:\n\t{\n\t    if (with_type)\n\t    {\n\t\tconstFunctionTypePtr ftype = m_type;\n\t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n\t\tif (m_global\n\t\t    && m_namespace != 0\n\t\t    && !m_namespace->name().empty())\n\t\t{\n\t\t    s += (m_namespace->name() + \"::\");\n\t\t}\n\t\ts += m_name.asString();\n\t\tif ((m_category == c_builtin)\n\t\t    && (m_payload.m_decl != 0))\n\t\t{\n\t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n\t\t}\n\t\telse if ((m_category == c_function)\n\t\t\t && (m_code != 0))\n\t\t{\n\t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n\t\t}\n\t\treturn s;\n\t    }\n\t    else\n\t    {\n\t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n\t\treturn s;\n\t    }\n\t}\n\tbreak;\n\tcase c_typedef:\n\t{\n\t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n\t}\n\tbreak;\n\tcase c_const:\n\t{\n\t    return s + m_type->toString() + \" \" + m_name.asString();\n\t}\n\tbreak;\n\tcase c_namespace:\n\tcase c_self:\n\tcase c_filename:\n\tcase c_predefined:\n\t{\n\t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    return SymbolEntry::toString (with_type);\n\t}\n\tbreak;\n    }\n\n    return \"?SymbolEntry?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\n#define DO_DEBUG 0\n\nYSymbolEntry {\n  string \n  YSymbolEntry::toString (bool with_type) const\n  {\n      string s = (with_type && m_global) ? \"global \" : \"\";\n  #if DO_DEBUG\n      y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n      y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n  #endif\n      switch (m_category)\n      {\n  \tcase c_variable:\n  \tcase c_reference:\n  \tcase c_function:\n  #if DO_DEBUG\n  \t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n  #endif\n  \tcase c_builtin:\n  \t{\n  \t    if (with_type)\n  \t    {\n  \t\tconstFunctionTypePtr ftype = m_type;\n  \t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n  \t\tif (m_global\n  \t\t    && m_namespace != 0\n  \t\t    && !m_namespace->name().empty())\n  \t\t{\n  \t\t    s += (m_namespace->name() + \"::\");\n  \t\t}\n  \t\ts += m_name.asString();\n  \t\tif ((m_category == c_builtin)\n  \t\t    && (m_payload.m_decl != 0))\n  \t\t{\n  \t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n  \t\t}\n  \t\telse if ((m_category == c_function)\n  \t\t\t && (m_code != 0))\n  \t\t{\n  \t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n  \t\t}\n  \t\treturn s;\n  \t    }\n  \t    else\n  \t    {\n  \t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n  \t\treturn s;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase c_typedef:\n  \t{\n  \t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n  \t}\n  \tbreak;\n  \tcase c_const:\n  \t{\n  \t    return s + m_type->toString() + \" \" + m_name.asString();\n  \t}\n  \tbreak;\n  \tcase c_namespace:\n  \tcase c_self:\n  \tcase c_filename:\n  \tcase c_predefined:\n  \t{\n  \t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    return SymbolEntry::toString (with_type);\n  \t}\n  \tbreak;\n      }\n  \n      return \"?SymbolEntry?\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2->value",
          "args": [],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i2.isNull",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.isNull",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_plus2 (const YCPString &s1, const YCPInteger &i2)\n{\n    /**\n     * @operator string s1 + integer i2 -> string\n     * @short String and integer Concatenation \n     *\n     * @description\n     * Returns concatenation of <tt>s1</tt> and <tt>i2</tt> after\n     * transforming <tt>i2</tt> to a string.\n     *\n     * Example: \n     *\n     * <code>\n     * \"YaST\" + 2 -> \"YaST2\"\n     * </code>\n     */\n\n    if (s1.isNull () || i2.isNull ())\n\treturn YCPNull ();\n\n    return YCPString (s1->value () + toString (i2->value ()));\n}"
  },
  {
    "function_name": "s_plus1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "107-123",
    "snippet": "static YCPValue\ns_plus1 (const YCPString &s1, const YCPString &s2)\n{\n    /**\n     * @operator string s1 + string s2 -> string\n     * Returns concatenation of <tt>s1</tt> and <tt>s2</tt>.\n     *\n     * Example: <pre>\n     * \"YaST\" + \"2\" -> \"YaST2\"\n     * </pre>\n     */\n\n    if (s1.isNull () || s2.isNull ())\n\treturn YCPNull ();\n\n    return YCPString (s1->value () + s2->value_cstr ());\n}",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "s1->value () + s2->value_cstr ()"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "YCPString& or",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "1389-1417",
          "snippet": "yptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nyptsha512(const YCPString& original)\n{\n    /**\n     * @builtin cryptsha512\n     * @short Encrypts a string with sha512\n     * @description\n     * Encrypts the string <tt>UNENCRYPTED</tt> using sha512\n     * password encryption. The password is not truncated.\n     *\n     * @param string UNENCRYPTED\n     * @return string\n     * @usage cryptsha512 (\"readable\") -> \"$6$QskPAFTK$R40N1UI047Bg.nD96ZYSGnx71mgbBgb.UEtKuR8bGGxuzYgXjCTxKIQmqXrgftBzA20m2P9ayrUKQQ2pnWzm70\"\n     */\n\n    if (original.isNull ())\n\treturn YCPNull ();\n\n    string unencrypted = original->value();\n    string encrypted;\n\n    if (crypt_pass (unencrypted, SHA512, &encrypted))\n        return YCPString (encrypted);\n    else\n    {\n\tycp2error (\"Encryption using sha512 failed\");\n        return YCPNull ();\n    }\n}\n\n\nstatic YCPValue\ns"
        }
      },
      {
        "call_info": {
          "callee": "s2->value_cstr",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1->value",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2.isNull",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.isNull",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_plus1 (const YCPString &s1, const YCPString &s2)\n{\n    /**\n     * @operator string s1 + string s2 -> string\n     * Returns concatenation of <tt>s1</tt> and <tt>s2</tt>.\n     *\n     * Example: <pre>\n     * \"YaST\" + \"2\" -> \"YaST2\"\n     * </pre>\n     */\n\n    if (s1.isNull () || s2.isNull ())\n\treturn YCPNull ();\n\n    return YCPString (s1->value () + s2->value_cstr ());\n}"
  },
  {
    "function_name": "s_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "80-104",
    "snippet": "static YCPValue\ns_size (const YCPString &s)\n{\n    /**\n     * @builtin size\n     * @id size-string\n     * @short Returns the number of characters of the string <tt>s</tt>\n     * @param string s String\n     * @return integer Size of string <tt>s</tt>\n     *\n     * @description\n     * Notice, that size(nil) -> nil\n     *\n     * @usage size(\"size\") -> 4\n     */\n     \n    if (s.isNull ())\n\treturn YCPNull ();\n\n    // UTF-8 based length\n    std::wstring out;\n    utf82wchar(s->value (), &out);\n    \n    return YCPInteger (wcslen (out.c_str()));;\n}",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPInteger",
          "args": [
            "wcslen (out.c_str())"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "YCPInteger",
          "container": "YCPInteger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPInteger.cc",
          "lines": "142-145",
          "snippet": "YCPInteger::YCPInteger (bytecodeistream & str)\n    : YCPValue (new YCPIntegerRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/y2log.h\"\n\nYCPInteger {\n  YCPInteger::YCPInteger (bytecodeistream & str)\n      : YCPValue (new YCPIntegerRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "wcslen",
          "args": [
            "out.c_str()"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.c_str",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utf82wchar",
          "args": [
            "s->value ()",
            "&out"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "utf82wchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2string.cc",
          "lines": "89-114",
          "snippet": "bool\nutf82wchar (const std::string& in, std::wstring* out)\n{\n    static iconv_t cd = (iconv_t)(-1);\n\n    if (cd == (iconv_t)(-1))\n    {\n\tcd = iconv_open (\"WCHAR_T\", \"UTF-8\");\n\n\t// TODO: also call iconv_close somewhere, perhaps use\n\t// pthread_key_create et.al.\n\n\tif (cd == (iconv_t)(-1))\n\t{\n\t    static bool shown_once = false;\n\t    if (!shown_once) {\n\t\ty2error (\"iconv_open: %m\");\n\t\tshown_once = true;\n\t    }\n\n\t    return false;\n\t}\n    }\n\n    return recode (cd, in, out);\n}",
          "includes": [
            "#include \"y2string.h\"",
            "#include \"y2log.h\"",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2string.h\"\n#include \"y2log.h\"\n#include <errno.h>\n\nbool\nutf82wchar (const std::string& in, std::wstring* out)\n{\n    static iconv_t cd = (iconv_t)(-1);\n\n    if (cd == (iconv_t)(-1))\n    {\n\tcd = iconv_open (\"WCHAR_T\", \"UTF-8\");\n\n\t// TODO: also call iconv_close somewhere, perhaps use\n\t// pthread_key_create et.al.\n\n\tif (cd == (iconv_t)(-1))\n\t{\n\t    static bool shown_once = false;\n\t    if (!shown_once) {\n\t\ty2error (\"iconv_open: %m\");\n\t\tshown_once = true;\n\t    }\n\n\t    return false;\n\t}\n    }\n\n    return recode (cd, in, out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "s->value",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YConst",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "342-346",
          "snippet": "YCPValue\nYConst::value() const\n{\n    return m_value;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYConst {\n  YCPValue\n  YConst::value() const\n  {\n      return m_value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.isNull",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_size (const YCPString &s)\n{\n    /**\n     * @builtin size\n     * @id size-string\n     * @short Returns the number of characters of the string <tt>s</tt>\n     * @param string s String\n     * @return integer Size of string <tt>s</tt>\n     *\n     * @description\n     * Notice, that size(nil) -> nil\n     *\n     * @usage size(\"size\") -> 4\n     */\n     \n    if (s.isNull ())\n\treturn YCPNull ();\n\n    // UTF-8 based length\n    std::wstring out;\n    utf82wchar(s->value (), &out);\n    \n    return YCPInteger (wcslen (out.c_str()));;\n}"
  },
  {
    "function_name": "s_isempty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
    "lines": "59-77",
    "snippet": "static YCPValue\ns_isempty(const YCPString& s)\n{\n    /**\n     * @builtin isempty \n     * @id isempty-string\n     * @short Returns whether the string <tt>s</tt> is empty.\n     * @param string s String\n     * @return boolean Emptiness of string <tt>s</tt>\n     *\n     * @description\n     * Notice that the string <tt>s</tt> must not be nil.\n     *\n     * @usage isempty(\"\") -> true\n     * @usage isempty(\"test\") -> false \n     */\n\n    return YCPBoolean(s->isEmpty());\n}",
    "includes": [
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"y2crypt.h\"",
      "#include \"y2string.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPBuiltinString.h\"",
      "#include <string>",
      "#include <libintl.h>",
      "#include <regex.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "s->isEmpty()"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s->isEmpty",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "isEmpty",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "56-60",
          "snippet": "bool\nYCPListRep::isEmpty() const\n{\n    return elements.empty();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  bool\n  YCPListRep::isEmpty() const\n  {\n      return elements.empty();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_isempty(const YCPString& s)\n{\n    /**\n     * @builtin isempty \n     * @id isempty-string\n     * @short Returns whether the string <tt>s</tt> is empty.\n     * @param string s String\n     * @return boolean Emptiness of string <tt>s</tt>\n     *\n     * @description\n     * Notice that the string <tt>s</tt> must not be nil.\n     *\n     * @usage isempty(\"\") -> true\n     * @usage isempty(\"test\") -> false \n     */\n\n    return YCPBoolean(s->isEmpty());\n}"
  }
]