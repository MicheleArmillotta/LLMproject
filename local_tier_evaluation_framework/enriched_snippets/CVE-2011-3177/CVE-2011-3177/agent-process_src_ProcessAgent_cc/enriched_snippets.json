[
  {
    "function_name": "otherCommand(",
    "container": "rocessAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-process/src/ProcessAgent.cc",
    "lines": "550-560",
    "snippet": "CPValue ProcessAgent::otherCommand(const YCPTerm& term)\n{\n    std::string sym = term->name();\n\n    if (sym == \"ProcessAgent\") {\n        /* Your initialization */\n        return YCPVoid();\n    }\n\n    return YCPVoid();\n}",
    "includes": [
      "include <y2util/ExternalProgram.h>",
      "include <y2util/Process.h>",
      "include \"ProcessAgent.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CPVoid(",
          "args": [],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPVoid(",
          "args": [],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "erm->name",
          "args": [],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "42-46",
          "snippet": "string\nYCPTermRep::name() const\n{\n    return s.asString();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  string\n  YCPTermRep::name() const\n  {\n      return s.asString();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include <y2util/ExternalProgram.h>\ninclude <y2util/Process.h>\ninclude \"ProcessAgent.h\"\n#\n\nrocessAgent {\n  CPValue ProcessAgent::otherCommand(const YCPTerm& term)\n  {\n      std::string sym = term->name();\n  \n      if (sym == \"ProcessAgent\") {\n          /* Your initialization */\n          return YCPVoid();\n      }\n  \n      return YCPVoid();\n  }\n}"
  },
  {
    "function_name": "Execute(",
    "container": "rocessAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-process/src/ProcessAgent.cc",
    "lines": "302-545",
    "snippet": "CPValue ProcessAgent::Execute(const YCPPath &path,\n    const YCPValue& value , const YCPValue& arg)\n{\n    std::string pth(path->component_str(0));\n\n    y2debug(\"Executing path: %s\", pth.c_str());\n\n    // handler for \".start_shell\" path\n    if (pth == \"start_shell\" || pth == \"start\")\n    {\n\t/**\n\t * @builtin Execute(.process.start_shell, string command, map options) -> integer\n\t * Execute the command in a shell (/bin/sh). The command can contain all shell features like\n\t * argument expansion, stdout/stderr redirection...\n\t *\n\t * The optional map can contain additional configuration: \"tty\" : boolean - run the command in terminal (instead of piped stdout/stderr), the default is false,\n\t * \"C_locale\" : boolean - use C locale (default false), \"env\" : map<string variable, string value> - set additional environment variables.\n\t *\n\t * Returns ID of the started process\n\t *\n\t * @example Execute(.process.start_shell, \"/bin/true\") -> 12345\n\t */\n\t/**\n\t * @builtin Execute(.process.start, string command, map options) -> integer\n\t * Execute the command. The string command is a path to the program, arguments are passed in the map - value of key \"args\" must be list<string> with the required arguments. For other options see .start_shell info.\n\t *\n\t * Returns ID of the started process\n\t *\n\t * @example Execute(.process.start, \"/bin/echo\", $[ \"args\" : [ \"arg1\", \"arg2\" ] ]) -> 12345\n\t */\n\n\t// check type of the argument\n\tif (!value.isNull() && value->isString())\n\t{\n\t    std::string commandline = value->asString()->value();\n\n\t    bool use_pty = false;\n\t    bool default_locale = false;\n\n\t    ExternalProgram::Environment env;\n\t    YCPList args;\n\n\t    // set optional parameters\n\t    if (!arg.isNull() && arg->isMap())\n\t    {\n\t\tYCPMap opt_map = arg->asMap();\n\n\t\t// start in a terminal?\n\t\tif( ! opt_map->value( YCPString(\"tty\")).isNull())\n\t\t{\n\t\t    if (opt_map->value(YCPString(\"tty\"))->isBoolean())\n\t\t    {\n\t\t\tuse_pty = opt_map->value(YCPString(\"tty\"))->asBoolean()->value();\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\ty2warning(\"tty option '%s' is not a boolean value\", opt_map->value(YCPString(\"tty\"))->toString().c_str());\n\t\t    }\n\t\t}\n\n\t\t// use default locale?\n\t\tif( ! opt_map->value( YCPString(\"C_locale\")).isNull() && opt_map->value(YCPString(\"C_locale\"))->isBoolean())\n\t\t{\n\t\t    default_locale = opt_map->value(YCPString(\"C_locale\"))->asBoolean()->value();\n\t\t}\n\n\t\t// add environment variables\n\t\tif( ! opt_map->value( YCPString(\"env\")).isNull() && opt_map->value(YCPString(\"env\"))->isMap())\n\t\t{\n\t\t    YCPMap envmt = opt_map->value(YCPString(\"env\"))->asMap();\n\n\t\t    for(YCPMap::const_iterator it = envmt.begin(); it != envmt.end(); it++)\n\t\t    {\n\t\t\tYCPValue key = it->first;\n\t\t\tYCPValue val = it->second;\n\n\t\t\tif (!key.isNull() && key->isString() && !val.isNull() && val->isString())\n\t\t\t{\n\t\t\t    env.insert(ExternalProgram::Environment::value_type(\n\t\t\t\tkey->asString()->value(), val->asString()->value())\n\t\t\t    );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    y2error(\"Invalid pair in env map: $[ %s : %s ], map<string,string> is required\",\n\t\t\t\tkey->toString().c_str(), val->toString().c_str());\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif( ! opt_map->value( YCPString(\"args\")).isNull() && opt_map->value(YCPString(\"args\"))->isList())\n\t\t{\n\t\t    args = opt_map->value(YCPString(\"args\"))->asList();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (!arg.isNull())\n\t\t{\n\t\t    y2error(\"Argument '%s' is not a map\", arg->toString().c_str());\n\t\t    return YCPNull();\n\t\t}\n\t    }\n\n\t    Process *p;\n\n\t    if (pth == \"start_shell\")\n\t    {\n\t\t// start using shell\n\t\tconst char *argv[4];\n\t\targv[0] = \"/bin/sh\";\n\t\targv[1] = \"-c\";\n\t\targv[2] = commandline.c_str();\n\t\targv[3] = 0;\n\n\t\tp = new Process(argv, env, use_pty, default_locale);\n\t    }\n\t    else\n\t    {\n\t\tint array_size = 1 + args->size();\n\t\tconst char *argv[array_size + 1];\n\n\t\t// store the path\n\t\targv[0] = commandline.c_str();\n\t\t\n\t\t// store arguments\n\t\tint index = 0;\n\t\tfor (; index < args->size(); index++)\n\t\t{\n\t\t    if (args->value(index)->isString())\n\t\t    {\n\t\t\targv[index + 1] = args->value(index)->asString()->value().c_str();\n\t\t    }\n\t\t}\n\n\t\t// terminate the array\n\t\targv[index + 1] = NULL;\n\n\t\tp = new Process(argv, env, use_pty, default_locale);\n    \t    }\n\n\t    // do not block reading\n\t    p->setBlocking(false);\n\n\t    pid_t pid = p->getpid();\n\n\t    if (pid > 0)\n\t    {\n\t\t// store the mapping PID->Process*\n\t\t_processes.insert(ProcessContainer::value_type(pid, p));\n\t\treturn YCPInteger(pid);\n\t    }\n\t    else\n\t    {\n\t\ty2error(\"Program NOT started!\");\n\t\treturn YCPNull();\n\t    }\n\t}\n\telse\n\t{\n\t    y2error(\"Argument '%s' is not a string\", value->toString().c_str());\n\t    return YCPNull();\n\t}\n    }\n    else\n    {\n\tif (value.isNull() || !value->isInteger())\n\t{\n\t    y2error(\"ID of the process is missing\");\n\t    return YCPNull();\n\t}\n\n\tpid_t id = value->asInteger()->value();\n\n\ty2debug(\"Requested path: %s, id: %d\", pth.c_str(), id);\n\n\tProcessContainer::iterator proc(_processes.find(id));\n\n\tif (proc == _processes.end())\n\t{\n\t    y2error(\"Process '%d' not found\", id);\n\t    return YCPNull();\n\t}\n\n\tif (pth == \"kill\")\n\t{\n\t    /**\n\t     * @builtin Execute(.process.kill, integer id, integer signal) -> boolean\n\t     * Send a signal to the process, if signal is missing then SIGKILL is sent.\n\t     *\n\t     * @example Execute(.process.kill, 12345, 15) -> true // send SIGTERM\n\t     * @example Execute(.process.kill, 12345) -> true     // send SIGKILL\n\t     */\n\t    // check the value\n\t    if (!arg.isNull() && arg->isInteger())\n\t    {\n\t\t// send the requested signal\n\t\tint sig = arg->asInteger()->value();\n\n\t\ty2milestone(\"Sending signal %d to process %d...\", sig, id);\n\t\treturn YCPBoolean(proc->second->kill(sig));\n\t    }\n\t    else\n\t    {\n\t\t// send SIGKILL\n\t\ty2milestone(\"Sending SIGKILL to process %d...\", id);\n\t\treturn YCPBoolean(proc->second->kill());\n\t    }\n\t}\n\telse if (pth == \"release\")\n\t{\n\t    /**\n\t     * @builtin Execute(.process.release, integer id) -> boolean\n\t     * Removes the process from the internal structure and releases all allocated resources (buffers).\n\t     * If the process is running then it is killed by SIGKILL at first.\n\t     *\n\t     * @example Execute(.process.release, 12345) -> true\n\t     */\n\t    y2milestone(\"Releasing Process object %d...\", id);\n\t    // relese the Process object\n\t    delete proc->second;\n\n\t    // remove the entry\n\t    _processes.erase(proc);\n\t    return YCPBoolean(true);\n\t}\n\telse if (pth == \"close\")\n\t{\n\t    /**\n\t     * @builtin Execute(.process.close, integer id) -> integer\n\t     * Close input/output of the process and wait until the process ends\n\t     *\n\t     * Returns Exit value of the process \n\t     *\n\t     * @example Execute(.process.close, 12345) -> 0\n\t     */\n\t    y2milestone(\"Closing output of %d...\", id);\n\t    return YCPInteger(proc->second->closeAll());\n\t}\n    }\n\n    y2error(\"Wrong path '%s' in Execute()\", path->toString().c_str());\n    return YCPNull();\n}",
    "includes": [
      "include <y2util/ExternalProgram.h>",
      "include <y2util/Process.h>",
      "include \"ProcessAgent.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CPNull(",
          "args": [],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2error(",
          "args": [
            "Wrong path '%s' in Execute()\",",
            "ath->toString().c_str())"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ath->toString",
          "args": [],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YCPPathRep::Component",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "278-311",
          "snippet": "string\nYCPPathRep::Component::toString() const\n{\n    if (!complex)\n\treturn component.asString();\n    string s = \"\\\"\";\n    for (const char*c = component->c_str();*c;c++)\n    {\n\tswitch (*c)\n\t{\n\t    case '\"': s+= \"\\\\\\\"\"; break;\n\t    case '\\\\':    s+= \"\\\\\\\\\";  break;\n\t    case '\\n':    s+= \"\\\\n\";   break;\n\t    case '\\t':    s+= \"\\\\t\";   break;\n\t    case '\\r':    s+= \"\\\\r\";   break;\n\t    case '\\b':    s+= \"\\\\b\";   break;\n\t    case '\\f':    s+= \"\\\\f\";   break;\n\t    default:\n\t    {\n\t\tif (isprint (*c))\n\t\t    s+= *c;\n\t\telse\n\t\t{\n\t\t    char buf[5];\n\t\t    snprintf (buf, 4, \"%02X\", *(unsigned char*)c);\n\t\t    s += \"\\\\x\";\n\t\t    s += buf;\n\t\t}\n\t    }\n\t}\n    }\n    s+= '\"';\n    return s;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  Component {\n    string\n    YCPPathRep::Component::toString() const\n    {\n        if (!complex)\n    \treturn component.asString();\n        string s = \"\\\"\";\n        for (const char*c = component->c_str();*c;c++)\n        {\n    \tswitch (*c)\n    \t{\n    \t    case '\"': s+= \"\\\\\\\"\"; break;\n    \t    case '\\\\':    s+= \"\\\\\\\\\";  break;\n    \t    case '\\n':    s+= \"\\\\n\";   break;\n    \t    case '\\t':    s+= \"\\\\t\";   break;\n    \t    case '\\r':    s+= \"\\\\r\";   break;\n    \t    case '\\b':    s+= \"\\\\b\";   break;\n    \t    case '\\f':    s+= \"\\\\f\";   break;\n    \t    default:\n    \t    {\n    \t\tif (isprint (*c))\n    \t\t    s+= *c;\n    \t\telse\n    \t\t{\n    \t\t    char buf[5];\n    \t\t    snprintf (buf, 4, \"%02X\", *(unsigned char*)c);\n    \t\t    s += \"\\\\x\";\n    \t\t    s += buf;\n    \t\t}\n    \t    }\n    \t}\n        }\n        s+= '\"';\n        return s;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPInteger(",
          "args": [
            "roc->second->closeAll())"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->second->closeAll",
          "args": [],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2milestone(",
          "args": [
            "Closing output of %d...\",",
            "d)"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPBoolean(",
          "args": [
            "rue)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "processes.erase",
          "args": [
            "roc)"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "683-695",
          "snippet": "int PathInfo::erase( const Pathname & path )\n{\n  int res = 0;\n  PathInfo p( path, LSTAT );\n  if ( p.isExist() )\n    {\n      if ( p.isDir() )\n        res = PathInfo::recursive_rmdir( path );\n      else\n        res = PathInfo::unlink( path );\n    }\n  return res;\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::erase( const Pathname & path )\n  {\n    int res = 0;\n    PathInfo p( path, LSTAT );\n    if ( p.isExist() )\n      {\n        if ( p.isDir() )\n          res = PathInfo::recursive_rmdir( path );\n        else\n          res = PathInfo::unlink( path );\n      }\n    return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "2milestone(",
          "args": [
            "Releasing Process object %d...\",",
            "d)"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPBoolean(",
          "args": [
            "roc->second->kill())"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->second->kill",
          "args": [],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "kill",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "389-398",
          "snippet": "bool\nExternalProgram::kill()\n{\n    if (pid > 0)\n    {\n\t::kill(pid, SIGKILL);\n\tclose();\n    }\n    return true;\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  bool\n  ExternalProgram::kill()\n  {\n      if (pid > 0)\n      {\n  \t::kill(pid, SIGKILL);\n  \tclose();\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "2milestone(",
          "args": [
            "Sending SIGKILL to process %d...\",",
            "d)"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPBoolean(",
          "args": [
            "roc->second->kill(sig))"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->second->kill",
          "args": [
            "ig)"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2milestone(",
          "args": [
            "Sending signal %d to process %d...\",",
            "ig,",
            "d)"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg->asInteger",
          "args": [],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "asInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "106-116",
          "snippet": "YCPInteger\nYCPValueRep::asInteger() const\n{\n    if (!isInteger())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPInteger\n  YCPValueRep::asInteger() const\n  {\n      if (!isInteger())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rg->isInteger",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "63-63",
          "snippet": "bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rg.isNull",
          "args": [],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPNull(",
          "args": [],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2error(",
          "args": [
            "Process '%d' not found\",",
            "d)"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "processes.end",
          "args": [],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "processes.find",
          "args": [
            "d)"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2debug(",
          "args": [
            "Requested path: %s, id: %d\",",
            "th.c_str(),",
            "d)"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "th.c_str",
          "args": [],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPNull(",
          "args": [],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2error(",
          "args": [
            "ID of the process is missing\")"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue.isNull",
          "args": [],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPNull(",
          "args": [],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2error(",
          "args": [
            "Argument '%s' is not a string\",",
            "alue->toString().c_str())"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue->toString",
          "args": [],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPNull(",
          "args": [],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2error(",
          "args": [
            "Program NOT started!\")"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPInteger(",
          "args": [
            "id)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "processes.insert",
          "args": [
            "rocessContainer::value_type(pid, p))"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rocessContainer::value_type(",
          "args": [
            "id,",
            ")"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->getpid",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "getpid",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/ExternalProgram.h",
          "lines": "109-109",
          "snippet": "pid_t getpid() { return pid; }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <y2util/ExternalDataSource.h>",
            "#include <string>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <y2util/ExternalDataSource.h>\n#include <string>\n#include <map>\n\nExternalProgram {\n  pid_t getpid() { return pid; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "->setBlocking",
          "args": [
            "alse)"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "setBlocking",
          "container": "ExternalDataSource",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalDataSource.cc",
          "lines": "118-141",
          "snippet": "void ExternalDataSource::setBlocking(bool mode)\n{\n    if(!inputfile) return;\n\n    int fd = ::fileno(inputfile);\n\n    if(fd == -1)\n\t{ ERR << strerror(errno) << endl; return; }\n\n    int flags = ::fcntl(fd,F_GETFL);\n\n    if(flags == -1)\n\t{ ERR << strerror(errno) << endl; return; }\n\n    if(!mode)\n\tflags = flags | O_NONBLOCK;\n    else if(flags & O_NONBLOCK)\n\tflags = flags ^ O_NONBLOCK;\n\n    flags = ::fcntl(fd,F_SETFL,flags);\n\n    if(flags == -1)\n\t{ ERR << strerror(errno) << endl; return; }\n}",
          "includes": [
            "#include <y2util/ExternalDataSource.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalDataSource.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalDataSource {\n  void ExternalDataSource::setBlocking(bool mode)\n  {\n      if(!inputfile) return;\n  \n      int fd = ::fileno(inputfile);\n  \n      if(fd == -1)\n  \t{ ERR << strerror(errno) << endl; return; }\n  \n      int flags = ::fcntl(fd,F_GETFL);\n  \n      if(flags == -1)\n  \t{ ERR << strerror(errno) << endl; return; }\n  \n      if(!mode)\n  \tflags = flags | O_NONBLOCK;\n      else if(flags & O_NONBLOCK)\n  \tflags = flags ^ O_NONBLOCK;\n  \n      flags = ::fcntl(fd,F_SETFL,flags);\n  \n      if(flags == -1)\n  \t{ ERR << strerror(errno) << endl; return; }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rgs->value",
          "args": [],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rgs->value",
          "args": [
            "ndex)"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rgs->size",
          "args": [],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommandline.c_str",
          "args": [],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommandline.c_str",
          "args": [],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPNull(",
          "args": [],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2error(",
          "args": [
            "Argument '%s' is not a map\",",
            "rg->toString().c_str())"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg.isNull",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPString(",
          "args": [
            "args\")"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPString(",
          "args": [
            "args\")"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPString(",
          "args": [
            "args\")"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2error(",
          "args": [
            "Invalid pair in env map: $[ %s : %s ], map<string,string> is required\",",
            "ey->toString().c_str(),",
            "al->toString().c_str())"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "al->toString",
          "args": [],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nv.insert",
          "args": [
            "xternalProgram::Environment::value_type(\n\t\t\t\tkey->asString()->value(), val->asString()->value())"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xternalProgram::Environment::value_type(",
          "args": [
            "ey->asString()->value(),",
            "al->asString()->value())"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "al->asString",
          "args": [],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "al->isString",
          "args": [],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "al.isNull",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey.isNull",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvmt.begin",
          "args": [],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPString(",
          "args": [
            "env\")"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPString(",
          "args": [
            "env\")"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPString(",
          "args": [
            "env\")"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPString(",
          "args": [
            "C_locale\")"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPString(",
          "args": [
            "C_locale\")"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPString(",
          "args": [
            "C_locale\")"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2warning(",
          "args": [
            "tty option '%s' is not a boolean value\",",
            "pt_map->value(YCPString(\"tty\"))->toString().c_str())"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPString(",
          "args": [
            "tty\")"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPString(",
          "args": [
            "tty\")"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPString(",
          "args": [
            "tty\")"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPString(",
          "args": [
            "tty\")"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg->asMap",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rg->isMap",
          "args": [],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "71-71",
          "snippet": "bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rg.isNull",
          "args": [],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue.isNull",
          "args": [],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2debug(",
          "args": [
            "Executing path: %s\",",
            "th.c_str())"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "th.c_str",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ath->component_str",
          "args": [
            ")"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "component_str",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "161-165",
          "snippet": "string\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  string\n  YCPPathRep::component_str(long index) const\n  {\n      return components[index].component.asString();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include <y2util/ExternalProgram.h>\ninclude <y2util/Process.h>\ninclude \"ProcessAgent.h\"\n#\n\nrocessAgent {\n  CPValue ProcessAgent::Execute(const YCPPath &path,\n      const YCPValue& value , const YCPValue& arg)\n  {\n      std::string pth(path->component_str(0));\n  \n      y2debug(\"Executing path: %s\", pth.c_str());\n  \n      // handler for \".start_shell\" path\n      if (pth == \"start_shell\" || pth == \"start\")\n      {\n  \t/**\n  \t * @builtin Execute(.process.start_shell, string command, map options) -> integer\n  \t * Execute the command in a shell (/bin/sh). The command can contain all shell features like\n  \t * argument expansion, stdout/stderr redirection...\n  \t *\n  \t * The optional map can contain additional configuration: \"tty\" : boolean - run the command in terminal (instead of piped stdout/stderr), the default is false,\n  \t * \"C_locale\" : boolean - use C locale (default false), \"env\" : map<string variable, string value> - set additional environment variables.\n  \t *\n  \t * Returns ID of the started process\n  \t *\n  \t * @example Execute(.process.start_shell, \"/bin/true\") -> 12345\n  \t */\n  \t/**\n  \t * @builtin Execute(.process.start, string command, map options) -> integer\n  \t * Execute the command. The string command is a path to the program, arguments are passed in the map - value of key \"args\" must be list<string> with the required arguments. For other options see .start_shell info.\n  \t *\n  \t * Returns ID of the started process\n  \t *\n  \t * @example Execute(.process.start, \"/bin/echo\", $[ \"args\" : [ \"arg1\", \"arg2\" ] ]) -> 12345\n  \t */\n  \n  \t// check type of the argument\n  \tif (!value.isNull() && value->isString())\n  \t{\n  \t    std::string commandline = value->asString()->value();\n  \n  \t    bool use_pty = false;\n  \t    bool default_locale = false;\n  \n  \t    ExternalProgram::Environment env;\n  \t    YCPList args;\n  \n  \t    // set optional parameters\n  \t    if (!arg.isNull() && arg->isMap())\n  \t    {\n  \t\tYCPMap opt_map = arg->asMap();\n  \n  \t\t// start in a terminal?\n  \t\tif( ! opt_map->value( YCPString(\"tty\")).isNull())\n  \t\t{\n  \t\t    if (opt_map->value(YCPString(\"tty\"))->isBoolean())\n  \t\t    {\n  \t\t\tuse_pty = opt_map->value(YCPString(\"tty\"))->asBoolean()->value();\n  \t\t    }\n  \t\t    else\n  \t\t    {\n  \t\t\ty2warning(\"tty option '%s' is not a boolean value\", opt_map->value(YCPString(\"tty\"))->toString().c_str());\n  \t\t    }\n  \t\t}\n  \n  \t\t// use default locale?\n  \t\tif( ! opt_map->value( YCPString(\"C_locale\")).isNull() && opt_map->value(YCPString(\"C_locale\"))->isBoolean())\n  \t\t{\n  \t\t    default_locale = opt_map->value(YCPString(\"C_locale\"))->asBoolean()->value();\n  \t\t}\n  \n  \t\t// add environment variables\n  \t\tif( ! opt_map->value( YCPString(\"env\")).isNull() && opt_map->value(YCPString(\"env\"))->isMap())\n  \t\t{\n  \t\t    YCPMap envmt = opt_map->value(YCPString(\"env\"))->asMap();\n  \n  \t\t    for(YCPMap::const_iterator it = envmt.begin(); it != envmt.end(); it++)\n  \t\t    {\n  \t\t\tYCPValue key = it->first;\n  \t\t\tYCPValue val = it->second;\n  \n  \t\t\tif (!key.isNull() && key->isString() && !val.isNull() && val->isString())\n  \t\t\t{\n  \t\t\t    env.insert(ExternalProgram::Environment::value_type(\n  \t\t\t\tkey->asString()->value(), val->asString()->value())\n  \t\t\t    );\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t    y2error(\"Invalid pair in env map: $[ %s : %s ], map<string,string> is required\",\n  \t\t\t\tkey->toString().c_str(), val->toString().c_str());\n  \t\t\t}\n  \t\t    }\n  \t\t}\n  \n  \t\tif( ! opt_map->value( YCPString(\"args\")).isNull() && opt_map->value(YCPString(\"args\"))->isList())\n  \t\t{\n  \t\t    args = opt_map->value(YCPString(\"args\"))->asList();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif (!arg.isNull())\n  \t\t{\n  \t\t    y2error(\"Argument '%s' is not a map\", arg->toString().c_str());\n  \t\t    return YCPNull();\n  \t\t}\n  \t    }\n  \n  \t    Process *p;\n  \n  \t    if (pth == \"start_shell\")\n  \t    {\n  \t\t// start using shell\n  \t\tconst char *argv[4];\n  \t\targv[0] = \"/bin/sh\";\n  \t\targv[1] = \"-c\";\n  \t\targv[2] = commandline.c_str();\n  \t\targv[3] = 0;\n  \n  \t\tp = new Process(argv, env, use_pty, default_locale);\n  \t    }\n  \t    else\n  \t    {\n  \t\tint array_size = 1 + args->size();\n  \t\tconst char *argv[array_size + 1];\n  \n  \t\t// store the path\n  \t\targv[0] = commandline.c_str();\n  \t\t\n  \t\t// store arguments\n  \t\tint index = 0;\n  \t\tfor (; index < args->size(); index++)\n  \t\t{\n  \t\t    if (args->value(index)->isString())\n  \t\t    {\n  \t\t\targv[index + 1] = args->value(index)->asString()->value().c_str();\n  \t\t    }\n  \t\t}\n  \n  \t\t// terminate the array\n  \t\targv[index + 1] = NULL;\n  \n  \t\tp = new Process(argv, env, use_pty, default_locale);\n      \t    }\n  \n  \t    // do not block reading\n  \t    p->setBlocking(false);\n  \n  \t    pid_t pid = p->getpid();\n  \n  \t    if (pid > 0)\n  \t    {\n  \t\t// store the mapping PID->Process*\n  \t\t_processes.insert(ProcessContainer::value_type(pid, p));\n  \t\treturn YCPInteger(pid);\n  \t    }\n  \t    else\n  \t    {\n  \t\ty2error(\"Program NOT started!\");\n  \t\treturn YCPNull();\n  \t    }\n  \t}\n  \telse\n  \t{\n  \t    y2error(\"Argument '%s' is not a string\", value->toString().c_str());\n  \t    return YCPNull();\n  \t}\n      }\n      else\n      {\n  \tif (value.isNull() || !value->isInteger())\n  \t{\n  \t    y2error(\"ID of the process is missing\");\n  \t    return YCPNull();\n  \t}\n  \n  \tpid_t id = value->asInteger()->value();\n  \n  \ty2debug(\"Requested path: %s, id: %d\", pth.c_str(), id);\n  \n  \tProcessContainer::iterator proc(_processes.find(id));\n  \n  \tif (proc == _processes.end())\n  \t{\n  \t    y2error(\"Process '%d' not found\", id);\n  \t    return YCPNull();\n  \t}\n  \n  \tif (pth == \"kill\")\n  \t{\n  \t    /**\n  \t     * @builtin Execute(.process.kill, integer id, integer signal) -> boolean\n  \t     * Send a signal to the process, if signal is missing then SIGKILL is sent.\n  \t     *\n  \t     * @example Execute(.process.kill, 12345, 15) -> true // send SIGTERM\n  \t     * @example Execute(.process.kill, 12345) -> true     // send SIGKILL\n  \t     */\n  \t    // check the value\n  \t    if (!arg.isNull() && arg->isInteger())\n  \t    {\n  \t\t// send the requested signal\n  \t\tint sig = arg->asInteger()->value();\n  \n  \t\ty2milestone(\"Sending signal %d to process %d...\", sig, id);\n  \t\treturn YCPBoolean(proc->second->kill(sig));\n  \t    }\n  \t    else\n  \t    {\n  \t\t// send SIGKILL\n  \t\ty2milestone(\"Sending SIGKILL to process %d...\", id);\n  \t\treturn YCPBoolean(proc->second->kill());\n  \t    }\n  \t}\n  \telse if (pth == \"release\")\n  \t{\n  \t    /**\n  \t     * @builtin Execute(.process.release, integer id) -> boolean\n  \t     * Removes the process from the internal structure and releases all allocated resources (buffers).\n  \t     * If the process is running then it is killed by SIGKILL at first.\n  \t     *\n  \t     * @example Execute(.process.release, 12345) -> true\n  \t     */\n  \t    y2milestone(\"Releasing Process object %d...\", id);\n  \t    // relese the Process object\n  \t    delete proc->second;\n  \n  \t    // remove the entry\n  \t    _processes.erase(proc);\n  \t    return YCPBoolean(true);\n  \t}\n  \telse if (pth == \"close\")\n  \t{\n  \t    /**\n  \t     * @builtin Execute(.process.close, integer id) -> integer\n  \t     * Close input/output of the process and wait until the process ends\n  \t     *\n  \t     * Returns Exit value of the process \n  \t     *\n  \t     * @example Execute(.process.close, 12345) -> 0\n  \t     */\n  \t    y2milestone(\"Closing output of %d...\", id);\n  \t    return YCPInteger(proc->second->closeAll());\n  \t}\n      }\n  \n      y2error(\"Wrong path '%s' in Execute()\", path->toString().c_str());\n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "Write(",
    "container": "rocessAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-process/src/ProcessAgent.cc",
    "lines": "248-297",
    "snippet": "CPBoolean ProcessAgent::Write(const YCPPath &path, const YCPValue& value,\n    const YCPValue& arg)\n{\n    if (!path->isRoot())\n    {\n\ty2error(\"Unsupported path in Write(): %s\", path->toString().c_str());\n\treturn YCPNull();\n    }\n\n    if (value.isNull() || !value->isInteger())\n    {\n\ty2error(\"ID of the process is missing\");\n\treturn YCPNull();\n    }\n\n    pid_t id = value->asInteger()->value();\n\n    y2debug(\"Writing to %d\", id);\n\n    ProcessContainer::iterator proc(_processes.find(id));\n\n    if (proc == _processes.end())\n    {\n\ty2error(\"Process '%d' not found\", id);\n\treturn YCPNull();\n    }\n\n    if (!arg.isNull() && arg->isString())\n    {\n\tif (!proc->second->running())\n\t{\n\t    y2warning(\"Process '%d' is not running, cannot write to stdin!\", id);\n\t    return YCPBoolean(false);\n\t}\n\t/**\n\t * @builtin Write(.process, integer id, input_string) -> boolean\n\t * Wrtites the input string to stdin of the process. Returns true on success.\n\t *\n\t * @example Write(.process, 12345, \"foo\") -> true\n\t */\n\n\treturn YCPBoolean(proc->second->send(arg->asString()->value()));\n    }\n    else\n    {\n\t// wrong type of the arg\n\ty2error(\"Value '%s' is not a string\", arg->toString().c_str());\n\treturn YCPBoolean(false);\n    }\n}",
    "includes": [
      "include <y2util/ExternalProgram.h>",
      "include <y2util/Process.h>",
      "include \"ProcessAgent.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CPBoolean(",
          "args": [
            "alse)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2error(",
          "args": [
            "Value '%s' is not a string\",",
            "rg->toString().c_str())"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg->toString",
          "args": [],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPBoolean(",
          "args": [
            "roc->second->send(arg->asString()->value()))"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->second->send",
          "args": [
            "rg->asString()->value())"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "Y2StdioComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2StdioComponent.cc",
          "lines": "125-132",
          "snippet": "void\nY2StdioComponent::send (const YCPValue& v) const\n{\n    string s = \"(\" + (v.isNull () ? \"(nil)\" : v->toString ()) + \")\\n\";\n    y2debug (\"send begin %s\", s.c_str ());\n    write (to_stderr ? STDERR_FILENO : STDOUT_FILENO, s.c_str (), s.length ());\n    y2debug (\"send end %s\", s.c_str ());\n}",
          "includes": [
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include \"Y2StdioComponent.h\"",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include \"Y2StdioComponent.h\"\n#include <unistd.h>\n\nY2StdioComponent {\n  void\n  Y2StdioComponent::send (const YCPValue& v) const\n  {\n      string s = \"(\" + (v.isNull () ? \"(nil)\" : v->toString ()) + \")\\n\";\n      y2debug (\"send begin %s\", s.c_str ());\n      write (to_stderr ? STDERR_FILENO : STDOUT_FILENO, s.c_str (), s.length ());\n      y2debug (\"send end %s\", s.c_str ());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rg->asString",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPBoolean(",
          "args": [
            "alse)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2warning(",
          "args": [
            "Process '%d' is not running, cannot write to stdin!\",",
            "d)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->second->running",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "running",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "401-422",
          "snippet": "bool\nExternalProgram::running()\n{\n    if ( pid < 0 ) return false;\n\n    int status = 0;\n    int p = waitpid( pid, &status, WNOHANG );\n    if ( p < 0 ) return false;\n\n    status = checkStatus( status );\n\n    if ( status == 0 )\n    {\n        return true;\n    }\n    else\n    {\n        _exitStatus = status;\n        pid = -1;\n        return false;\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  bool\n  ExternalProgram::running()\n  {\n      if ( pid < 0 ) return false;\n  \n      int status = 0;\n      int p = waitpid( pid, &status, WNOHANG );\n      if ( p < 0 ) return false;\n  \n      status = checkStatus( status );\n  \n      if ( status == 0 )\n      {\n          return true;\n      }\n      else\n      {\n          _exitStatus = status;\n          pid = -1;\n          return false;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rg->isString",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rg.isNull",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPNull(",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2error(",
          "args": [
            "Process '%d' not found\",",
            "d)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "processes.end",
          "args": [],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "processes.find",
          "args": [
            "d)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2debug(",
          "args": [
            "Writing to %d\",",
            "d)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue->asInteger",
          "args": [],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "asInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "106-116",
          "snippet": "YCPInteger\nYCPValueRep::asInteger() const\n{\n    if (!isInteger())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPInteger\n  YCPValueRep::asInteger() const\n  {\n      if (!isInteger())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPNull(",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2error(",
          "args": [
            "ID of the process is missing\")"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue->isInteger",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "63-63",
          "snippet": "bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "alue.isNull",
          "args": [],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPNull(",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2error(",
          "args": [
            "Unsupported path in Write(): %s\",",
            "ath->toString().c_str())"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ath->toString",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YCPPathRep::Component",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "278-311",
          "snippet": "string\nYCPPathRep::Component::toString() const\n{\n    if (!complex)\n\treturn component.asString();\n    string s = \"\\\"\";\n    for (const char*c = component->c_str();*c;c++)\n    {\n\tswitch (*c)\n\t{\n\t    case '\"': s+= \"\\\\\\\"\"; break;\n\t    case '\\\\':    s+= \"\\\\\\\\\";  break;\n\t    case '\\n':    s+= \"\\\\n\";   break;\n\t    case '\\t':    s+= \"\\\\t\";   break;\n\t    case '\\r':    s+= \"\\\\r\";   break;\n\t    case '\\b':    s+= \"\\\\b\";   break;\n\t    case '\\f':    s+= \"\\\\f\";   break;\n\t    default:\n\t    {\n\t\tif (isprint (*c))\n\t\t    s+= *c;\n\t\telse\n\t\t{\n\t\t    char buf[5];\n\t\t    snprintf (buf, 4, \"%02X\", *(unsigned char*)c);\n\t\t    s += \"\\\\x\";\n\t\t    s += buf;\n\t\t}\n\t    }\n\t}\n    }\n    s+= '\"';\n    return s;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  Component {\n    string\n    YCPPathRep::Component::toString() const\n    {\n        if (!complex)\n    \treturn component.asString();\n        string s = \"\\\"\";\n        for (const char*c = component->c_str();*c;c++)\n        {\n    \tswitch (*c)\n    \t{\n    \t    case '\"': s+= \"\\\\\\\"\"; break;\n    \t    case '\\\\':    s+= \"\\\\\\\\\";  break;\n    \t    case '\\n':    s+= \"\\\\n\";   break;\n    \t    case '\\t':    s+= \"\\\\t\";   break;\n    \t    case '\\r':    s+= \"\\\\r\";   break;\n    \t    case '\\b':    s+= \"\\\\b\";   break;\n    \t    case '\\f':    s+= \"\\\\f\";   break;\n    \t    default:\n    \t    {\n    \t\tif (isprint (*c))\n    \t\t    s+= *c;\n    \t\telse\n    \t\t{\n    \t\t    char buf[5];\n    \t\t    snprintf (buf, 4, \"%02X\", *(unsigned char*)c);\n    \t\t    s += \"\\\\x\";\n    \t\t    s += buf;\n    \t\t}\n    \t    }\n    \t}\n        }\n        s+= '\"';\n        return s;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ath->isRoot",
          "args": [],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "isRoot",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "83-87",
          "snippet": "bool\nYCPPathRep::isRoot() const\n{\n    return components.empty();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  bool\n  YCPPathRep::isRoot() const\n  {\n      return components.empty();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include <y2util/ExternalProgram.h>\ninclude <y2util/Process.h>\ninclude \"ProcessAgent.h\"\n#\n\nrocessAgent {\n  CPBoolean ProcessAgent::Write(const YCPPath &path, const YCPValue& value,\n      const YCPValue& arg)\n  {\n      if (!path->isRoot())\n      {\n  \ty2error(\"Unsupported path in Write(): %s\", path->toString().c_str());\n  \treturn YCPNull();\n      }\n  \n      if (value.isNull() || !value->isInteger())\n      {\n  \ty2error(\"ID of the process is missing\");\n  \treturn YCPNull();\n      }\n  \n      pid_t id = value->asInteger()->value();\n  \n      y2debug(\"Writing to %d\", id);\n  \n      ProcessContainer::iterator proc(_processes.find(id));\n  \n      if (proc == _processes.end())\n      {\n  \ty2error(\"Process '%d' not found\", id);\n  \treturn YCPNull();\n      }\n  \n      if (!arg.isNull() && arg->isString())\n      {\n  \tif (!proc->second->running())\n  \t{\n  \t    y2warning(\"Process '%d' is not running, cannot write to stdin!\", id);\n  \t    return YCPBoolean(false);\n  \t}\n  \t/**\n  \t * @builtin Write(.process, integer id, input_string) -> boolean\n  \t * Wrtites the input string to stdin of the process. Returns true on success.\n  \t *\n  \t * @example Write(.process, 12345, \"foo\") -> true\n  \t */\n  \n  \treturn YCPBoolean(proc->second->send(arg->asString()->value()));\n      }\n      else\n      {\n  \t// wrong type of the arg\n  \ty2error(\"Value '%s' is not a string\", arg->toString().c_str());\n  \treturn YCPBoolean(false);\n      }\n  }\n}"
  },
  {
    "function_name": "Read(",
    "container": "rocessAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-process/src/ProcessAgent.cc",
    "lines": "101-243",
    "snippet": "CPValue ProcessAgent::Read(const YCPPath &path, const YCPValue& arg, const YCPValue& opt)\n{\n    std::string cmd(path->component_str(0));\n\n    if (arg.isNull() || !arg->isInteger())\n    {\n\ty2error(\"ID of the process is missing\");\n\treturn YCPNull();\n    }\n\n    pid_t id = arg->asInteger()->value();\n\n    y2debug(\"Requested path: %s, id: %d\", cmd.c_str(), id);\n\n    ProcessContainer::iterator proc(_processes.find(id));\n\n    if (proc == _processes.end())\n    {\n\ty2error(\"Process '%d' not found\", id);\n\treturn YCPNull();\n    }\n\n    // handler for \"running\" path\n    if (cmd == \"running\")\n    {\n\t/**\n\t * @builtin Read (.process.running, integer id) -> boolean\n\t * Returns true if the process is running\n\t *\n\t * @example Read (.process.running, 12345) -> true\n\t */\n\n\t// read output to unblock the process\n\tproc->second->readStdoutToBuffer();\n\tproc->second->readStderrToBuffer();\n\n\treturn YCPBoolean(proc->second->running());\n    }\n    // handler for \"pid\" path\n    else if (cmd == \"pid\")\n    {\n\t/**\n\t * @builtin Read (.process.pid, integer id) -> integer\n\t * Returns the PID of a process\n\t *\n\t * @example Read (.process.pid, 12345) -> 6789\n\t */\n\treturn YCPInteger(id);\n    }\n    else if (cmd == \"read_line\")\n    {\n\t/**\n\t * @builtin Read (.process.read_line, integer id) -> string\n\t * Returns one line from stdout of the process, nil if there is no output\n\t *\n\t * @example Read (.process.read_line, 12345) -> nil\n\t */\n\tstd::string out = proc->second->readLine();\n\treturn ProcessOutput(out);\n    }\n    else if (cmd == \"read\")\n    {\n\t/**\n\t * @builtin Read (.process.read, integer id) -> string\n\t * Returns read stdout of the process, nil if there is no output.\n\t * This read function is not line-oriented, the output can contain multiple lines or just part of a line.\n\t *\n\t * @example Read (.process.read, 12345) -> nil\n\t */\n\tstd::string out(proc->second->read());\n\n\tif (out.empty())\n\t{\n\t    return YCPVoid();\n\t}\n\telse\n\t{\n\t    return YCPString(out);\n\t}\n    }\n    else if (cmd == \"read_line_stderr\")\n    {\n\t/**\n\t * @builtin Read (.process.read_line_stderr, integer id) -> string\n\t * Returns one line from stderr of the process, nil if there is no output\n\t *\n\t * @example Read (.process.read_line_stderr, 12345) -> nil\n\t */\n\tstd::string err = proc->second->readErrLine();\n\treturn ProcessOutput(err);\n    }\n    else if (cmd == \"read_stderr\")\n    {\n\t/**\n\t * @builtin Read (.process.read_stderr, integer id) -> string\n\t * Returns read stderr of the process, nil if there is no output.\n\t * This read function is not line-oriented, the output can contain multiple lines or just part of a line.\n\t *\n\t * @example Read (.process.read_stderr, 12345) -> nil\n\t */\n\tstd::string out(proc->second->readErr());\n\n\tif (out.empty())\n\t{\n\t    return YCPVoid();\n\t}\n\telse\n\t{\n\t    return YCPString(out);\n\t}\n    }\n    else if (cmd == \"status\")\n    {\n\t/**\n\t * @builtin Read (.process.status, integer id) -> integer\n\t * Returns exit status of the process, if the process is still running nil is returned.\n\t *\n\t * @example Read (.process.status, 12345) -> 0\n\t */\n\tif (proc->second->running())\n\t{\n\t    // the process is still running\n\t    return YCPVoid();\n\t}\n\telse\n\t{\n\t    return YCPInteger(proc->second->close());\n\t}\n    }\n    else if (cmd == \"buffer_empty\")\n    {\n\t/**\n\t * @builtin Read (.process.buffer_empty, integer id) -> boolean\n\t * Returns boolean whether the stdout buffer is empty, if buffer is not empty, false is returned.\n\t *\n\t * @example Read (.process.buffer_empty, 12345) -> false\n\t */\n\treturn YCPBoolean (proc->second->anyLineInStdout());\n    }\n\n    y2error(\"Wrong path '%s' in Read().\", path->toString().c_str());\n    return YCPNull();\n}",
    "includes": [
      "include <y2util/ExternalProgram.h>",
      "include <y2util/Process.h>",
      "include \"ProcessAgent.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CPNull(",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2error(",
          "args": [
            "Wrong path '%s' in Read().\",",
            "ath->toString().c_str())"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ath->toString",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YCPPathRep::Component",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "278-311",
          "snippet": "string\nYCPPathRep::Component::toString() const\n{\n    if (!complex)\n\treturn component.asString();\n    string s = \"\\\"\";\n    for (const char*c = component->c_str();*c;c++)\n    {\n\tswitch (*c)\n\t{\n\t    case '\"': s+= \"\\\\\\\"\"; break;\n\t    case '\\\\':    s+= \"\\\\\\\\\";  break;\n\t    case '\\n':    s+= \"\\\\n\";   break;\n\t    case '\\t':    s+= \"\\\\t\";   break;\n\t    case '\\r':    s+= \"\\\\r\";   break;\n\t    case '\\b':    s+= \"\\\\b\";   break;\n\t    case '\\f':    s+= \"\\\\f\";   break;\n\t    default:\n\t    {\n\t\tif (isprint (*c))\n\t\t    s+= *c;\n\t\telse\n\t\t{\n\t\t    char buf[5];\n\t\t    snprintf (buf, 4, \"%02X\", *(unsigned char*)c);\n\t\t    s += \"\\\\x\";\n\t\t    s += buf;\n\t\t}\n\t    }\n\t}\n    }\n    s+= '\"';\n    return s;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  Component {\n    string\n    YCPPathRep::Component::toString() const\n    {\n        if (!complex)\n    \treturn component.asString();\n        string s = \"\\\"\";\n        for (const char*c = component->c_str();*c;c++)\n        {\n    \tswitch (*c)\n    \t{\n    \t    case '\"': s+= \"\\\\\\\"\"; break;\n    \t    case '\\\\':    s+= \"\\\\\\\\\";  break;\n    \t    case '\\n':    s+= \"\\\\n\";   break;\n    \t    case '\\t':    s+= \"\\\\t\";   break;\n    \t    case '\\r':    s+= \"\\\\r\";   break;\n    \t    case '\\b':    s+= \"\\\\b\";   break;\n    \t    case '\\f':    s+= \"\\\\f\";   break;\n    \t    default:\n    \t    {\n    \t\tif (isprint (*c))\n    \t\t    s+= *c;\n    \t\telse\n    \t\t{\n    \t\t    char buf[5];\n    \t\t    snprintf (buf, 4, \"%02X\", *(unsigned char*)c);\n    \t\t    s += \"\\\\x\";\n    \t\t    s += buf;\n    \t\t}\n    \t    }\n    \t}\n        }\n        s+= '\"';\n        return s;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPBoolean",
          "args": [
            "roc->second->anyLineInStdout())"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "roc->second->anyLineInStdout",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPInteger(",
          "args": [
            "roc->second->close())"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->second->close",
          "args": [],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "325-351",
          "snippet": "int\nExternalProgram::close()\n{\n    if (pid > 0)\n    {\n\tExternalDataSource::close();\n\t// Wait for child to exit\n\tint ret;\n        int status = 0;\n\tdo\n\t{\n\t    ret = waitpid(pid, &status, 0);\n\t}\n\twhile (ret == -1 && errno == EINTR);\n\n\tif (ret != -1)\n\t{\n\t    status = checkStatus( status );\n\t}\n        pid = -1;\n        return status;\n    }\n    else\n    {\n        return _exitStatus;\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  int\n  ExternalProgram::close()\n  {\n      if (pid > 0)\n      {\n  \tExternalDataSource::close();\n  \t// Wait for child to exit\n  \tint ret;\n          int status = 0;\n  \tdo\n  \t{\n  \t    ret = waitpid(pid, &status, 0);\n  \t}\n  \twhile (ret == -1 && errno == EINTR);\n  \n  \tif (ret != -1)\n  \t{\n  \t    status = checkStatus( status );\n  \t}\n          pid = -1;\n          return status;\n      }\n      else\n      {\n          return _exitStatus;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPVoid(",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->second->running",
          "args": [],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "running",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "401-422",
          "snippet": "bool\nExternalProgram::running()\n{\n    if ( pid < 0 ) return false;\n\n    int status = 0;\n    int p = waitpid( pid, &status, WNOHANG );\n    if ( p < 0 ) return false;\n\n    status = checkStatus( status );\n\n    if ( status == 0 )\n    {\n        return true;\n    }\n    else\n    {\n        _exitStatus = status;\n        pid = -1;\n        return false;\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  bool\n  ExternalProgram::running()\n  {\n      if ( pid < 0 ) return false;\n  \n      int status = 0;\n      int p = waitpid( pid, &status, WNOHANG );\n      if ( p < 0 ) return false;\n  \n      status = checkStatus( status );\n  \n      if ( status == 0 )\n      {\n          return true;\n      }\n      else\n      {\n          _exitStatus = status;\n          pid = -1;\n          return false;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPString(",
          "args": [
            "ut)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPVoid(",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut.empty",
          "args": [],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "roc->second->readErr",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rocessOutput(",
          "args": [
            "rr)"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessOutput(",
          "container": "rocessAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-process/src/ProcessAgent.cc",
          "lines": "84-96",
          "snippet": "CPValue ProcessAgent::ProcessOutput(std::string &output)\n{\n    // no output, return nil\n    if (output.empty())\n    {\n\treturn YCPVoid();\n    }\n\n    // remove the trailing new line character, \"\" means empty line\n    output.erase(output.end() - 1);\n\n    return YCPString(output);\n}",
          "includes": [
            "include <y2util/ExternalProgram.h>",
            "include <y2util/Process.h>",
            "include \"ProcessAgent.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <y2util/ExternalProgram.h>\ninclude <y2util/Process.h>\ninclude \"ProcessAgent.h\"\n#\n\nrocessAgent {\n  CPValue ProcessAgent::ProcessOutput(std::string &output)\n  {\n      // no output, return nil\n      if (output.empty())\n      {\n  \treturn YCPVoid();\n      }\n  \n      // remove the trailing new line character, \"\" means empty line\n      output.erase(output.end() - 1);\n  \n      return YCPString(output);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "roc->second->readErrLine",
          "args": [],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPString(",
          "args": [
            "ut)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPVoid(",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->second->read",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->second->readLine",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPInteger(",
          "args": [
            "d)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPBoolean(",
          "args": [
            "roc->second->running())"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->second->readStderrToBuffer",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->second->readStdoutToBuffer",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPNull(",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2error(",
          "args": [
            "Process '%d' not found\",",
            "d)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "processes.end",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "processes.find",
          "args": [
            "d)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2debug(",
          "args": [
            "Requested path: %s, id: %d\",",
            "md.c_str(),",
            "d)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "md.c_str",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg->asInteger",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "asInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "106-116",
          "snippet": "YCPInteger\nYCPValueRep::asInteger() const\n{\n    if (!isInteger())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPInteger\n  YCPValueRep::asInteger() const\n  {\n      if (!isInteger())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPNull(",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2error(",
          "args": [
            "ID of the process is missing\")"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg->isInteger",
          "args": [],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "63-63",
          "snippet": "bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rg.isNull",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ath->component_str",
          "args": [
            ")"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "component_str",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "161-165",
          "snippet": "string\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  string\n  YCPPathRep::component_str(long index) const\n  {\n      return components[index].component.asString();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include <y2util/ExternalProgram.h>\ninclude <y2util/Process.h>\ninclude \"ProcessAgent.h\"\n#\n\nrocessAgent {\n  CPValue ProcessAgent::Read(const YCPPath &path, const YCPValue& arg, const YCPValue& opt)\n  {\n      std::string cmd(path->component_str(0));\n  \n      if (arg.isNull() || !arg->isInteger())\n      {\n  \ty2error(\"ID of the process is missing\");\n  \treturn YCPNull();\n      }\n  \n      pid_t id = arg->asInteger()->value();\n  \n      y2debug(\"Requested path: %s, id: %d\", cmd.c_str(), id);\n  \n      ProcessContainer::iterator proc(_processes.find(id));\n  \n      if (proc == _processes.end())\n      {\n  \ty2error(\"Process '%d' not found\", id);\n  \treturn YCPNull();\n      }\n  \n      // handler for \"running\" path\n      if (cmd == \"running\")\n      {\n  \t/**\n  \t * @builtin Read (.process.running, integer id) -> boolean\n  \t * Returns true if the process is running\n  \t *\n  \t * @example Read (.process.running, 12345) -> true\n  \t */\n  \n  \t// read output to unblock the process\n  \tproc->second->readStdoutToBuffer();\n  \tproc->second->readStderrToBuffer();\n  \n  \treturn YCPBoolean(proc->second->running());\n      }\n      // handler for \"pid\" path\n      else if (cmd == \"pid\")\n      {\n  \t/**\n  \t * @builtin Read (.process.pid, integer id) -> integer\n  \t * Returns the PID of a process\n  \t *\n  \t * @example Read (.process.pid, 12345) -> 6789\n  \t */\n  \treturn YCPInteger(id);\n      }\n      else if (cmd == \"read_line\")\n      {\n  \t/**\n  \t * @builtin Read (.process.read_line, integer id) -> string\n  \t * Returns one line from stdout of the process, nil if there is no output\n  \t *\n  \t * @example Read (.process.read_line, 12345) -> nil\n  \t */\n  \tstd::string out = proc->second->readLine();\n  \treturn ProcessOutput(out);\n      }\n      else if (cmd == \"read\")\n      {\n  \t/**\n  \t * @builtin Read (.process.read, integer id) -> string\n  \t * Returns read stdout of the process, nil if there is no output.\n  \t * This read function is not line-oriented, the output can contain multiple lines or just part of a line.\n  \t *\n  \t * @example Read (.process.read, 12345) -> nil\n  \t */\n  \tstd::string out(proc->second->read());\n  \n  \tif (out.empty())\n  \t{\n  \t    return YCPVoid();\n  \t}\n  \telse\n  \t{\n  \t    return YCPString(out);\n  \t}\n      }\n      else if (cmd == \"read_line_stderr\")\n      {\n  \t/**\n  \t * @builtin Read (.process.read_line_stderr, integer id) -> string\n  \t * Returns one line from stderr of the process, nil if there is no output\n  \t *\n  \t * @example Read (.process.read_line_stderr, 12345) -> nil\n  \t */\n  \tstd::string err = proc->second->readErrLine();\n  \treturn ProcessOutput(err);\n      }\n      else if (cmd == \"read_stderr\")\n      {\n  \t/**\n  \t * @builtin Read (.process.read_stderr, integer id) -> string\n  \t * Returns read stderr of the process, nil if there is no output.\n  \t * This read function is not line-oriented, the output can contain multiple lines or just part of a line.\n  \t *\n  \t * @example Read (.process.read_stderr, 12345) -> nil\n  \t */\n  \tstd::string out(proc->second->readErr());\n  \n  \tif (out.empty())\n  \t{\n  \t    return YCPVoid();\n  \t}\n  \telse\n  \t{\n  \t    return YCPString(out);\n  \t}\n      }\n      else if (cmd == \"status\")\n      {\n  \t/**\n  \t * @builtin Read (.process.status, integer id) -> integer\n  \t * Returns exit status of the process, if the process is still running nil is returned.\n  \t *\n  \t * @example Read (.process.status, 12345) -> 0\n  \t */\n  \tif (proc->second->running())\n  \t{\n  \t    // the process is still running\n  \t    return YCPVoid();\n  \t}\n  \telse\n  \t{\n  \t    return YCPInteger(proc->second->close());\n  \t}\n      }\n      else if (cmd == \"buffer_empty\")\n      {\n  \t/**\n  \t * @builtin Read (.process.buffer_empty, integer id) -> boolean\n  \t * Returns boolean whether the stdout buffer is empty, if buffer is not empty, false is returned.\n  \t *\n  \t * @example Read (.process.buffer_empty, 12345) -> false\n  \t */\n  \treturn YCPBoolean (proc->second->anyLineInStdout());\n      }\n  \n      y2error(\"Wrong path '%s' in Read().\", path->toString().c_str());\n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "ProcessOutput(",
    "container": "rocessAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-process/src/ProcessAgent.cc",
    "lines": "84-96",
    "snippet": "CPValue ProcessAgent::ProcessOutput(std::string &output)\n{\n    // no output, return nil\n    if (output.empty())\n    {\n\treturn YCPVoid();\n    }\n\n    // remove the trailing new line character, \"\" means empty line\n    output.erase(output.end() - 1);\n\n    return YCPString(output);\n}",
    "includes": [
      "include <y2util/ExternalProgram.h>",
      "include <y2util/Process.h>",
      "include \"ProcessAgent.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CPString(",
          "args": [
            "utput)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utput.erase",
          "args": [
            "utput.end() - 1)"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "683-695",
          "snippet": "int PathInfo::erase( const Pathname & path )\n{\n  int res = 0;\n  PathInfo p( path, LSTAT );\n  if ( p.isExist() )\n    {\n      if ( p.isDir() )\n        res = PathInfo::recursive_rmdir( path );\n      else\n        res = PathInfo::unlink( path );\n    }\n  return res;\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::erase( const Pathname & path )\n  {\n    int res = 0;\n    PathInfo p( path, LSTAT );\n    if ( p.isExist() )\n      {\n        if ( p.isDir() )\n          res = PathInfo::recursive_rmdir( path );\n        else\n          res = PathInfo::unlink( path );\n      }\n    return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "utput.end",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPVoid(",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utput.empty",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "include <y2util/ExternalProgram.h>\ninclude <y2util/Process.h>\ninclude \"ProcessAgent.h\"\n#\n\nrocessAgent {\n  CPValue ProcessAgent::ProcessOutput(std::string &output)\n  {\n      // no output, return nil\n      if (output.empty())\n      {\n  \treturn YCPVoid();\n      }\n  \n      // remove the trailing new line character, \"\" means empty line\n      output.erase(output.end() - 1);\n  \n      return YCPString(output);\n  }\n}"
  },
  {
    "function_name": "Dir(",
    "container": "rocessAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-process/src/ProcessAgent.cc",
    "lines": "59-82",
    "snippet": "CPList ProcessAgent::Dir(const YCPPath& path)\n{\n    /**\n     * @builtin Dir(.process) -> list<integer>\n     * Return list od processes (IDs) managed by the process agent.\n     *\n     * @example Dir(.process) -> [ 23568, 28896 ]\n     */\n    // return all processes\n    if (path->isRoot())\n    {\n\tYCPList ret;\n\n\tfor(ProcessContainer::const_iterator it = _processes.begin(); it != _processes.end(); it++)\n\t{\n\t    ret->add(YCPInteger(it->first));\n\t}\n\n\treturn ret;\n    }\n\n    y2error(\"Wrong path '%s' in Dir().\", path->toString().c_str());\n    return YCPNull();\n}",
    "includes": [
      "include <y2util/ExternalProgram.h>",
      "include <y2util/Process.h>",
      "include \"ProcessAgent.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CPNull(",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2error(",
          "args": [
            "Wrong path '%s' in Dir().\",",
            "ath->toString().c_str())"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ath->toString",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YCPPathRep::Component",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "278-311",
          "snippet": "string\nYCPPathRep::Component::toString() const\n{\n    if (!complex)\n\treturn component.asString();\n    string s = \"\\\"\";\n    for (const char*c = component->c_str();*c;c++)\n    {\n\tswitch (*c)\n\t{\n\t    case '\"': s+= \"\\\\\\\"\"; break;\n\t    case '\\\\':    s+= \"\\\\\\\\\";  break;\n\t    case '\\n':    s+= \"\\\\n\";   break;\n\t    case '\\t':    s+= \"\\\\t\";   break;\n\t    case '\\r':    s+= \"\\\\r\";   break;\n\t    case '\\b':    s+= \"\\\\b\";   break;\n\t    case '\\f':    s+= \"\\\\f\";   break;\n\t    default:\n\t    {\n\t\tif (isprint (*c))\n\t\t    s+= *c;\n\t\telse\n\t\t{\n\t\t    char buf[5];\n\t\t    snprintf (buf, 4, \"%02X\", *(unsigned char*)c);\n\t\t    s += \"\\\\x\";\n\t\t    s += buf;\n\t\t}\n\t    }\n\t}\n    }\n    s+= '\"';\n    return s;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  Component {\n    string\n    YCPPathRep::Component::toString() const\n    {\n        if (!complex)\n    \treturn component.asString();\n        string s = \"\\\"\";\n        for (const char*c = component->c_str();*c;c++)\n        {\n    \tswitch (*c)\n    \t{\n    \t    case '\"': s+= \"\\\\\\\"\"; break;\n    \t    case '\\\\':    s+= \"\\\\\\\\\";  break;\n    \t    case '\\n':    s+= \"\\\\n\";   break;\n    \t    case '\\t':    s+= \"\\\\t\";   break;\n    \t    case '\\r':    s+= \"\\\\r\";   break;\n    \t    case '\\b':    s+= \"\\\\b\";   break;\n    \t    case '\\f':    s+= \"\\\\f\";   break;\n    \t    default:\n    \t    {\n    \t\tif (isprint (*c))\n    \t\t    s+= *c;\n    \t\telse\n    \t\t{\n    \t\t    char buf[5];\n    \t\t    snprintf (buf, 4, \"%02X\", *(unsigned char*)c);\n    \t\t    s += \"\\\\x\";\n    \t\t    s += buf;\n    \t\t}\n    \t    }\n    \t}\n        }\n        s+= '\"';\n        return s;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "et->add",
          "args": [
            "CPInteger(it->first))"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPInteger(",
          "args": [
            "t->first)"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "processes.end",
          "args": [],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "processes.begin",
          "args": [],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ath->isRoot",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "isRoot",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "83-87",
          "snippet": "bool\nYCPPathRep::isRoot() const\n{\n    return components.empty();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  bool\n  YCPPathRep::isRoot() const\n  {\n      return components.empty();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include <y2util/ExternalProgram.h>\ninclude <y2util/Process.h>\ninclude \"ProcessAgent.h\"\n#\n\nrocessAgent {\n  CPList ProcessAgent::Dir(const YCPPath& path)\n  {\n      /**\n       * @builtin Dir(.process) -> list<integer>\n       * Return list od processes (IDs) managed by the process agent.\n       *\n       * @example Dir(.process) -> [ 23568, 28896 ]\n       */\n      // return all processes\n      if (path->isRoot())\n      {\n  \tYCPList ret;\n  \n  \tfor(ProcessContainer::const_iterator it = _processes.begin(); it != _processes.end(); it++)\n  \t{\n  \t    ret->add(YCPInteger(it->first));\n  \t}\n  \n  \treturn ret;\n      }\n  \n      y2error(\"Wrong path '%s' in Dir().\", path->toString().c_str());\n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "~ProcessAgent(",
    "container": "rocessAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-process/src/ProcessAgent.cc",
    "lines": "44-54",
    "snippet": "rocessAgent::~ProcessAgent()\n{\n    // release created objects\n    for (ProcessContainer::iterator it = _processes.begin(); it != _processes.end(); it++)\n    {\n\tdelete it->second;\n    }\n\n    // remove invalid pointers\n    _processes.clear();\n}",
    "includes": [
      "include <y2util/ExternalProgram.h>",
      "include <y2util/Process.h>",
      "include \"ProcessAgent.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "processes.clear",
          "args": [],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/PathInfo.h",
          "lines": "461-461",
          "snippet": "void clear() { _devino.clear(); }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <map>",
            "#include <set>",
            "#include <list>",
            "#include <iosfwd>",
            "#include <cerrno>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <map>\n#include <set>\n#include <list>\n#include <iosfwd>\n#include <cerrno>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid clear() { _devino.clear(); }"
        }
      },
      {
        "call_info": {
          "callee": "processes.end",
          "args": [],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "processes.begin",
          "args": [],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include <y2util/ExternalProgram.h>\ninclude <y2util/Process.h>\ninclude \"ProcessAgent.h\"\n#\n\nrocessAgent {\n  rocessAgent::~ProcessAgent()\n  {\n      // release created objects\n      for (ProcessContainer::iterator it = _processes.begin(); it != _processes.end(); it++)\n      {\n  \tdelete it->second;\n      }\n  \n      // remove invalid pointers\n      _processes.clear();\n  }\n}"
  },
  {
    "function_name": "ProcessAgent(",
    "container": "rocessAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-process/src/ProcessAgent.cc",
    "lines": "37-39",
    "snippet": "rocessAgent::ProcessAgent() : SCRAgent()\n{\n}",
    "includes": [
      "include <y2util/ExternalProgram.h>",
      "include <y2util/Process.h>",
      "include \"ProcessAgent.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include <y2util/ExternalProgram.h>\ninclude <y2util/Process.h>\ninclude \"ProcessAgent.h\"\n#\n\nrocessAgent {\n  rocessAgent::ProcessAgent() : SCRAgent()\n  {\n  }\n}"
  }
]