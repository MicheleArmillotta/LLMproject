[
  {
    "function_name": "YCPBuiltinList ()",
    "container": "uiltinList",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "1248-1300",
    "snippet": "uiltinList::YCPBuiltinList ()\n{\n#define ETC 0, NULL, constTypePtr(), NULL\n#define ETCf   NULL, constTypePtr(), NULL\n\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n\t{ \"find\",\t\"flex (variable <flex>, const list <flex>, const block <boolean>)\",\t\t\t(void *)l_find,\t\tDECL_SYMBOL|DECL_FLEX,                  ETCf },\n\t{ \"prepend\",\t\"list <flex> (const list <flex>, const flex)\",\t\t\t\t\t\t(void *)l_prepend,\tDECL_FLEX,\t\t\t\tETCf },\n\t{ \"contains\",\t\"boolean (const list <flex>, const flex)\",\t\t\t\t\t\t(void *)l_contains,\tDECL_FLEX,\t\t\t\tETCf },\n\t{ \"setcontains\",\"boolean (const list <flex>, const flex)\",\t\t\t\t\t\t(void *)l_setcontains,\tDECL_FLEX,\t\t\t\tETCf },\n\t{ \"union\",\t\"list <any> (const list <any>, const list <any>)\",\t\t\t\t\t(void *)l_unionlist,\t\t\t\t\t\t ETC },\n\t{ \"+\",\t\t\"list <flex> (const list <flex>, const list <flex>)\",\t\t\t\t\t(void *)l_unionlist,\tDECL_FLEX,\t\t\t\tETCf },\n\t{ \"merge\",\t\"list <any> (const list <any>, const list <any>)\",\t\t\t\t\t(void *)l_mergelist,\t\t\t\t\t\t ETC },\n\t{ \"sublist\",\t\"list <flex> (const list <flex>, integer)\",\t\t\t\t\t\t(void *)l_sublist1,     DECL_FLEX,                              ETCf },\n\t{ \"sublist\",\t\"list <flex> (const list <flex>, integer, integer)\",\t\t\t\t\t(void *)l_sublist2,     DECL_FLEX,\t\t\t\tETCf },\n\t{ \"filter\",\t\"list <flex> (variable <flex>, const list <flex>, const block <boolean>)\",\t\t(void *)l_filter,\tDECL_LOOP|DECL_SYMBOL|DECL_FLEX,\tETCf },\n\t{ \"maplist\",\t\"list <flex1> (variable <flex2>, const list <flex2>, const block <flex1>)\",\t\t(void *)l_maplist,\tDECL_LOOP|DECL_SYMBOL|DECL_FLEX,\tETCf },\n\t{ \"listmap\",\t\"map <flex1,flex2> (variable <flex3>, const list <flex3>, const block <map <flex1,flex2>>)\",\t(void *)l_listmap,\tDECL_LOOP|DECL_SYMBOL|DECL_FLEX,ETCf },\n\t{ \"flatten\",\t\"list <flex> (const list <list <flex>>)\",\t\t\t\t\t\t(void *)l_flatten,\tDECL_FLEX,\t\t\t\tETCf },\n\t{ \"toset\",\t\"list <flex> (const list <flex>)\",\t\t\t\t\t\t\t(void *)l_toset,\tDECL_FLEX,\t\t\t\tETCf },\n\t{ \"sort\",\t\"list <flex> (const list <flex>)\",\t\t\t\t\t\t\t(void *)l_sortlist,\tDECL_FLEX,                              ETCf },\n\t{ \"sort\",\t\"list <flex> (variable <flex>, variable <flex>, const list <flex>, const block <boolean>)\", (void *)l_sort, \tDECL_SYMBOL|DECL_FLEX,\t\t\tETCf },\n\t{ \"lsort\",\t\"list <flex> (const list <flex>)\",\t\t\t\t\t\t\t(void *)l_lsortlist,\tDECL_FLEX,\t\t\t\tETCf },\n\t{ \"splitstring\",\"list <string> (string, string)\",\t\t\t\t\t\t\t(void *)l_splitstring,\t\t\t\t\t\t ETC },\n\t{ \"change\", \t\"list <flex> (const list <flex>, const flex)\",\t\t\t\t\t\t(void *)l_changelist,\tDECL_FLEX|DECL_DEPRECATED,\t\tETCf },\n\t{ \"add\",\t\"list <flex> (const list <flex>, const flex)\",\t\t\t\t\t\t(void *)l_add,\t\tDECL_FLEX|DECL_NIL,\t\t\tETCf },\n\t{ \"+\",\t\t\"list <flex> (const list <flex>, const flex)\",\t\t\t\t\t\t(void *)l_add,\t\tDECL_FLEX,\t\t\t\tETCf },\n\t{ \"+\",\t\t\"list <any> (const list <any>, any)\",\t\t\t\t\t\t\t(void *)l_add,                                                   ETC },\n\t{ \"isempty\",\t\"boolean (const list <any>)\",\t\t\t\t\t\t\t\t(void *)l_isempty,\t\t\t\t\t\t ETC },\n\t{ \"size\",\t\"integer (const list <any>)\",\t\t\t\t\t\t\t\t(void *)l_size,\t\tDECL_NIL,\t\t\t\tETCf },\n\t{ \"remove\",\t\"list <flex> (const list <flex>, const integer)\",\t\t\t\t\t(void *)l_remove,\tDECL_FLEX,\t\t\t\tETCf },\n\t{ \"select\",\t\"flex (const list <flex>, integer, flex)\",\t\t\t\t\t\t(void *)l_select,\tDECL_NIL|DECL_FLEX,\t\t\tETCf },\n\t{ \"foreach\",    \"flex1 (variable <flex2>, const list <flex2>, const block <flex1>)\",\t\t\t(void *)l_foreach,\tDECL_LOOP|DECL_SYMBOL|DECL_FLEX,\tETCf },\n\t{ \"tolist\",\t\"list <any> (const any)\",\t\t\t\t\t\t\t\t(void *)l_tolist,\tDECL_DEPRECATED,\t\t\tETCf },\n\t{ NULL, NULL, NULL, ETC }\n    };\n\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations_ns[] = {\n\t{ \"list\",\t\"\",\t\t\t\t\t\t\t\t\t\t\tNULL,\t                DECL_NAMESPACE, ETCf },\n\t{ \"reduce\",\t\"flex1 (variable <flex1>, variable <flex1>, const list <flex1>, const block <flex1>)\",  (void *)l_reduce1, DECL_LOOP|DECL_SYMBOL|DECL_FLEX, ETCf },\n\t{ \"reduce\",\t\"flex1 (variable <flex1>, variable <flex2>, const flex1, const list <flex2>, const block <flex1>)\", (void *)l_reduce2, DECL_LOOP|DECL_SYMBOL|DECL_FLEX, ETCf },\n\t{ \"swap\",\t\"list <flex> (const list <flex>, const integer, const integer)\",\t\t\t(void *)l_swaplist,\tDECL_FLEX, ETCf },\n\t{ NULL, NULL, NULL, ETC }\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinList\", declarations);\n    static_declarations.registerDeclarations (\"YCPBuiltinList\", declarations_ns);\n\n#undef ETC\n#undef ETCf\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [
      "extern StaticDeclaration static_declarations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ic_declarations.registerDeclarations",
          "args": [
            "BuiltinList\", de",
            "arations_ns);"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "registerDeclarations",
          "container": "StaticDeclaration",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/StaticDeclaration.cc",
          "lines": "87-237",
          "snippet": "void\nStaticDeclaration::registerDeclarations (const char *filename,\n\t\t\t\t\t declaration_t *declarations)\n{\n    if (declarations == 0)\n    {\n\treturn;\n    }\n\n    SymbolTable *table = m_declTable;\n    const Y2Namespace *name_space = 0;\n    static const Point *builtin_point = new Point (\"<builtin>\");\n    const Point *namespace_point = builtin_point;\t\t// declarations default to builtin\n    declaration_t *namespace_decl = 0;\n\n    std::pair <std::string, Y2Namespace *> *track_info = 0;\n\n    while (declarations->name != 0)\n    {\n#if DO_DEBUG\n\ty2debug( \"Registering %s\", declarations->name );\n#endif\n\tconst char *name = declarations->name;\n\n\tif (*name == 0)\t\t// exit on empty name\n\t    break;\n\n\tif ((declarations->flags & (DECL_WILD|DECL_SYMBOL)) == (DECL_WILD|DECL_SYMBOL))\n\t{\n\t    y2internal (\"Declaration of %s::%s combines wildcard and symbol\\n\", filename, name);\n\t}\n\telse if ((declarations->flags & DECL_NAMESPACE) != 0)\t\t// switch namespace\n\t{\n\t    // new namespace, clear possibly old track_info\n\t    if (track_info != 0)\n\t    {\n\t\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n\t\tm_active_predefined.push_back (*track_info);\n\t\ttrack_info = 0;\n\t    }\n#if DO_DEBUG\n\t    y2debug (\"NAMESPACE (%s)\", name);\n#endif\n            declarations->name_space = namespace_decl;\n\n\t    TableEntry *tentry = table->find (name);\n\t    if (tentry != 0\t\t\t\t\t\t// name already exists\n\t\t&& tentry->sentry()->isNamespace())\t\t\t//   as namespace\n\t    {\n\t\tname_space = tentry->sentry()->nameSpace();\n\t    }\n\t    else if (*name == 0)\t\t\t\t\t// reset namespace\n\t    {\n\t\ttable = m_declTable;\n\t\tname_space = 0;\n\t\tnamespace_point = builtin_point;\n\t    }\n\t    else\t\t\t\t\t\t\t// open up new namespace\n\t    {\n\t\tbool is_predefined = false;\n\n\t\tif (tentry != 0\n\t\t    && tentry->sentry()->isPredefined())\t\t//   replace predefined\n\t\t{\n\t\t    table->remove (tentry);\n\t\t    is_predefined = true;\n\t\t}\n\n\t\t// create definition container for namespace\n\t\tYBlock *block = new YBlock (filename, YBlock::b_namespace);\n\t\tblock->setName (string (name));\n\n\t\tY2Namespace *namespaceNamespace = (Y2Namespace *)block;\n\t\tnamespaceNamespace->createTable();\n\t\tSymbolTable *namespaceTable = block->table();\n\n\t\t// create SymbolEntry::c_namespace for the namespace to be entered into the global table\n\t\tSymbolEntryPtr sentry = new YSymbolEntry (name, Type::Unspec, namespaceTable);\n\n#if DO_DEBUG\n\t\ty2debug (\"Entered Namespace '%s' (block %p) into namespaceTable %p\", name, block, namespaceTable);\n#endif\n\n\t\t// enter into global table\n\t\tnamespace_point = new Point (filename);\n\t\ttable->enter (name, sentry, namespace_point);\n\n\t\t// all further definitions go into this namespace\n\t\t//   -> make it the new global table\n\t\ttable = namespaceTable;\n\t\tnamespace_decl = declarations;\n\n\t\tif (is_predefined)\n\t\t{\n\t\t    // save tracking info, trigger 'Import' _after_ all symbols have been added\n\t\t    track_info = new std::pair<std::string, Y2Namespace *> (name, namespaceNamespace);\n\t\t}\n\t    }\n\t}\n\telse\t// normal entry, not namespace\n\t{\n\t    declarations->name_space = namespace_decl;\n\t    string signature = declarations->signature;\n\n\t    constTypePtr type = Type::fromSignature (signature);\n\t    if (type == 0\n\t\t|| type->isError()\n\t\t|| type->isUnspec()\n\t\t|| type->isWildcard())\n\t    {\n\t\ty2error (\"Invalid signature %s::%s:'%s'\\n\", filename, name, signature.c_str());\n\t\treturn;\n\t    }\n\n#if DO_DEBUG\ny2debug(\"%s sig[%s] type[%s]\", name, signature.c_str(), type->toString().c_str());\n#endif\n#if 0\n\t    if (type->hasFlex()\n\t\t&& (declarations->flags & DECL_FLEX) == 0)\n\t    {\n\t\ty2error (\"%s:'%s' without DECL_FLEX\", name, declarations->signature);\n\t\treturn;\n\t    }\n#endif\n\t    declarations->type = type;\n\n\t    SymbolEntryPtr sentry = new YSymbolEntry (name, type, declarations, name_space);\n\t    declarations->tentry = table->enter (name, sentry, new Point (sentry, 0, namespace_point));\n\n#ifdef BUILTIN_STATISTICS\n\t    FILE *fout = fopen (\"/tmp/builtin-register.txt\", \"a\");\n\t    if (fout) {\n\t\tfprintf (fout, \"%s %s\\n\", declarations->name, declarations->signature);\n\t\tfclose (fout);\n\t    }\n#endif\n\t}\n\tdeclarations++;\n    }\n\n    // clear possibly old track_info\n    if (track_info != 0)\n    {\n\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n\tm_active_predefined.push_back (*track_info);\n\ttrack_info = 0;\n    }\n\n    return;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Import.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include <map>",
            "#include <string>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "static const char *predefined[] = {\n  \"UI\", \"WFM\", \"SCR\", \"Pkg\", 0\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <unistd.h>\n\n#define DO_DEBUG 0\n\nstatic const char *predefined[] = {\n  \"UI\", \"WFM\", \"SCR\", \"Pkg\", 0\n};\n\nStaticDeclaration {\n  void\n  StaticDeclaration::registerDeclarations (const char *filename,\n  \t\t\t\t\t declaration_t *declarations)\n  {\n      if (declarations == 0)\n      {\n  \treturn;\n      }\n  \n      SymbolTable *table = m_declTable;\n      const Y2Namespace *name_space = 0;\n      static const Point *builtin_point = new Point (\"<builtin>\");\n      const Point *namespace_point = builtin_point;\t\t// declarations default to builtin\n      declaration_t *namespace_decl = 0;\n  \n      std::pair <std::string, Y2Namespace *> *track_info = 0;\n  \n      while (declarations->name != 0)\n      {\n  #if DO_DEBUG\n  \ty2debug( \"Registering %s\", declarations->name );\n  #endif\n  \tconst char *name = declarations->name;\n  \n  \tif (*name == 0)\t\t// exit on empty name\n  \t    break;\n  \n  \tif ((declarations->flags & (DECL_WILD|DECL_SYMBOL)) == (DECL_WILD|DECL_SYMBOL))\n  \t{\n  \t    y2internal (\"Declaration of %s::%s combines wildcard and symbol\\n\", filename, name);\n  \t}\n  \telse if ((declarations->flags & DECL_NAMESPACE) != 0)\t\t// switch namespace\n  \t{\n  \t    // new namespace, clear possibly old track_info\n  \t    if (track_info != 0)\n  \t    {\n  \t\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n  \t\tm_active_predefined.push_back (*track_info);\n  \t\ttrack_info = 0;\n  \t    }\n  #if DO_DEBUG\n  \t    y2debug (\"NAMESPACE (%s)\", name);\n  #endif\n              declarations->name_space = namespace_decl;\n  \n  \t    TableEntry *tentry = table->find (name);\n  \t    if (tentry != 0\t\t\t\t\t\t// name already exists\n  \t\t&& tentry->sentry()->isNamespace())\t\t\t//   as namespace\n  \t    {\n  \t\tname_space = tentry->sentry()->nameSpace();\n  \t    }\n  \t    else if (*name == 0)\t\t\t\t\t// reset namespace\n  \t    {\n  \t\ttable = m_declTable;\n  \t\tname_space = 0;\n  \t\tnamespace_point = builtin_point;\n  \t    }\n  \t    else\t\t\t\t\t\t\t// open up new namespace\n  \t    {\n  \t\tbool is_predefined = false;\n  \n  \t\tif (tentry != 0\n  \t\t    && tentry->sentry()->isPredefined())\t\t//   replace predefined\n  \t\t{\n  \t\t    table->remove (tentry);\n  \t\t    is_predefined = true;\n  \t\t}\n  \n  \t\t// create definition container for namespace\n  \t\tYBlock *block = new YBlock (filename, YBlock::b_namespace);\n  \t\tblock->setName (string (name));\n  \n  \t\tY2Namespace *namespaceNamespace = (Y2Namespace *)block;\n  \t\tnamespaceNamespace->createTable();\n  \t\tSymbolTable *namespaceTable = block->table();\n  \n  \t\t// create SymbolEntry::c_namespace for the namespace to be entered into the global table\n  \t\tSymbolEntryPtr sentry = new YSymbolEntry (name, Type::Unspec, namespaceTable);\n  \n  #if DO_DEBUG\n  \t\ty2debug (\"Entered Namespace '%s' (block %p) into namespaceTable %p\", name, block, namespaceTable);\n  #endif\n  \n  \t\t// enter into global table\n  \t\tnamespace_point = new Point (filename);\n  \t\ttable->enter (name, sentry, namespace_point);\n  \n  \t\t// all further definitions go into this namespace\n  \t\t//   -> make it the new global table\n  \t\ttable = namespaceTable;\n  \t\tnamespace_decl = declarations;\n  \n  \t\tif (is_predefined)\n  \t\t{\n  \t\t    // save tracking info, trigger 'Import' _after_ all symbols have been added\n  \t\t    track_info = new std::pair<std::string, Y2Namespace *> (name, namespaceNamespace);\n  \t\t}\n  \t    }\n  \t}\n  \telse\t// normal entry, not namespace\n  \t{\n  \t    declarations->name_space = namespace_decl;\n  \t    string signature = declarations->signature;\n  \n  \t    constTypePtr type = Type::fromSignature (signature);\n  \t    if (type == 0\n  \t\t|| type->isError()\n  \t\t|| type->isUnspec()\n  \t\t|| type->isWildcard())\n  \t    {\n  \t\ty2error (\"Invalid signature %s::%s:'%s'\\n\", filename, name, signature.c_str());\n  \t\treturn;\n  \t    }\n  \n  #if DO_DEBUG\n  y2debug(\"%s sig[%s] type[%s]\", name, signature.c_str(), type->toString().c_str());\n  #endif\n  #if 0\n  \t    if (type->hasFlex()\n  \t\t&& (declarations->flags & DECL_FLEX) == 0)\n  \t    {\n  \t\ty2error (\"%s:'%s' without DECL_FLEX\", name, declarations->signature);\n  \t\treturn;\n  \t    }\n  #endif\n  \t    declarations->type = type;\n  \n  \t    SymbolEntryPtr sentry = new YSymbolEntry (name, type, declarations, name_space);\n  \t    declarations->tentry = table->enter (name, sentry, new Point (sentry, 0, namespace_point));\n  \n  #ifdef BUILTIN_STATISTICS\n  \t    FILE *fout = fopen (\"/tmp/builtin-register.txt\", \"a\");\n  \t    if (fout) {\n  \t\tfprintf (fout, \"%s %s\\n\", declarations->name, declarations->signature);\n  \t\tfclose (fout);\n  \t    }\n  #endif\n  \t}\n  \tdeclarations++;\n      }\n  \n      // clear possibly old track_info\n      if (track_info != 0)\n      {\n  \tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n  \tm_active_predefined.push_back (*track_info);\n  \ttrack_info = 0;\n      }\n  \n      return;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nextern StaticDeclaration static_declarations;\n\nuiltinList {\n  uiltinList::YCPBuiltinList ()\n  {\n  #define ETC 0, NULL, constTypePtr(), NULL\n  #define ETCf   NULL, constTypePtr(), NULL\n  \n      // must be static, registerDeclarations saves a pointer to it!\n      static declaration_t declarations[] = {\n  \t{ \"find\",\t\"flex (variable <flex>, const list <flex>, const block <boolean>)\",\t\t\t(void *)l_find,\t\tDECL_SYMBOL|DECL_FLEX,                  ETCf },\n  \t{ \"prepend\",\t\"list <flex> (const list <flex>, const flex)\",\t\t\t\t\t\t(void *)l_prepend,\tDECL_FLEX,\t\t\t\tETCf },\n  \t{ \"contains\",\t\"boolean (const list <flex>, const flex)\",\t\t\t\t\t\t(void *)l_contains,\tDECL_FLEX,\t\t\t\tETCf },\n  \t{ \"setcontains\",\"boolean (const list <flex>, const flex)\",\t\t\t\t\t\t(void *)l_setcontains,\tDECL_FLEX,\t\t\t\tETCf },\n  \t{ \"union\",\t\"list <any> (const list <any>, const list <any>)\",\t\t\t\t\t(void *)l_unionlist,\t\t\t\t\t\t ETC },\n  \t{ \"+\",\t\t\"list <flex> (const list <flex>, const list <flex>)\",\t\t\t\t\t(void *)l_unionlist,\tDECL_FLEX,\t\t\t\tETCf },\n  \t{ \"merge\",\t\"list <any> (const list <any>, const list <any>)\",\t\t\t\t\t(void *)l_mergelist,\t\t\t\t\t\t ETC },\n  \t{ \"sublist\",\t\"list <flex> (const list <flex>, integer)\",\t\t\t\t\t\t(void *)l_sublist1,     DECL_FLEX,                              ETCf },\n  \t{ \"sublist\",\t\"list <flex> (const list <flex>, integer, integer)\",\t\t\t\t\t(void *)l_sublist2,     DECL_FLEX,\t\t\t\tETCf },\n  \t{ \"filter\",\t\"list <flex> (variable <flex>, const list <flex>, const block <boolean>)\",\t\t(void *)l_filter,\tDECL_LOOP|DECL_SYMBOL|DECL_FLEX,\tETCf },\n  \t{ \"maplist\",\t\"list <flex1> (variable <flex2>, const list <flex2>, const block <flex1>)\",\t\t(void *)l_maplist,\tDECL_LOOP|DECL_SYMBOL|DECL_FLEX,\tETCf },\n  \t{ \"listmap\",\t\"map <flex1,flex2> (variable <flex3>, const list <flex3>, const block <map <flex1,flex2>>)\",\t(void *)l_listmap,\tDECL_LOOP|DECL_SYMBOL|DECL_FLEX,ETCf },\n  \t{ \"flatten\",\t\"list <flex> (const list <list <flex>>)\",\t\t\t\t\t\t(void *)l_flatten,\tDECL_FLEX,\t\t\t\tETCf },\n  \t{ \"toset\",\t\"list <flex> (const list <flex>)\",\t\t\t\t\t\t\t(void *)l_toset,\tDECL_FLEX,\t\t\t\tETCf },\n  \t{ \"sort\",\t\"list <flex> (const list <flex>)\",\t\t\t\t\t\t\t(void *)l_sortlist,\tDECL_FLEX,                              ETCf },\n  \t{ \"sort\",\t\"list <flex> (variable <flex>, variable <flex>, const list <flex>, const block <boolean>)\", (void *)l_sort, \tDECL_SYMBOL|DECL_FLEX,\t\t\tETCf },\n  \t{ \"lsort\",\t\"list <flex> (const list <flex>)\",\t\t\t\t\t\t\t(void *)l_lsortlist,\tDECL_FLEX,\t\t\t\tETCf },\n  \t{ \"splitstring\",\"list <string> (string, string)\",\t\t\t\t\t\t\t(void *)l_splitstring,\t\t\t\t\t\t ETC },\n  \t{ \"change\", \t\"list <flex> (const list <flex>, const flex)\",\t\t\t\t\t\t(void *)l_changelist,\tDECL_FLEX|DECL_DEPRECATED,\t\tETCf },\n  \t{ \"add\",\t\"list <flex> (const list <flex>, const flex)\",\t\t\t\t\t\t(void *)l_add,\t\tDECL_FLEX|DECL_NIL,\t\t\tETCf },\n  \t{ \"+\",\t\t\"list <flex> (const list <flex>, const flex)\",\t\t\t\t\t\t(void *)l_add,\t\tDECL_FLEX,\t\t\t\tETCf },\n  \t{ \"+\",\t\t\"list <any> (const list <any>, any)\",\t\t\t\t\t\t\t(void *)l_add,                                                   ETC },\n  \t{ \"isempty\",\t\"boolean (const list <any>)\",\t\t\t\t\t\t\t\t(void *)l_isempty,\t\t\t\t\t\t ETC },\n  \t{ \"size\",\t\"integer (const list <any>)\",\t\t\t\t\t\t\t\t(void *)l_size,\t\tDECL_NIL,\t\t\t\tETCf },\n  \t{ \"remove\",\t\"list <flex> (const list <flex>, const integer)\",\t\t\t\t\t(void *)l_remove,\tDECL_FLEX,\t\t\t\tETCf },\n  \t{ \"select\",\t\"flex (const list <flex>, integer, flex)\",\t\t\t\t\t\t(void *)l_select,\tDECL_NIL|DECL_FLEX,\t\t\tETCf },\n  \t{ \"foreach\",    \"flex1 (variable <flex2>, const list <flex2>, const block <flex1>)\",\t\t\t(void *)l_foreach,\tDECL_LOOP|DECL_SYMBOL|DECL_FLEX,\tETCf },\n  \t{ \"tolist\",\t\"list <any> (const any)\",\t\t\t\t\t\t\t\t(void *)l_tolist,\tDECL_DEPRECATED,\t\t\tETCf },\n  \t{ NULL, NULL, NULL, ETC }\n      };\n  \n      // must be static, registerDeclarations saves a pointer to it!\n      static declaration_t declarations_ns[] = {\n  \t{ \"list\",\t\"\",\t\t\t\t\t\t\t\t\t\t\tNULL,\t                DECL_NAMESPACE, ETCf },\n  \t{ \"reduce\",\t\"flex1 (variable <flex1>, variable <flex1>, const list <flex1>, const block <flex1>)\",  (void *)l_reduce1, DECL_LOOP|DECL_SYMBOL|DECL_FLEX, ETCf },\n  \t{ \"reduce\",\t\"flex1 (variable <flex1>, variable <flex2>, const flex1, const list <flex2>, const block <flex1>)\", (void *)l_reduce2, DECL_LOOP|DECL_SYMBOL|DECL_FLEX, ETCf },\n  \t{ \"swap\",\t\"list <flex> (const list <flex>, const integer, const integer)\",\t\t\t(void *)l_swaplist,\tDECL_FLEX, ETCf },\n  \t{ NULL, NULL, NULL, ETC }\n      };\n  \n      static_declarations.registerDeclarations (\"YCPBuiltinList\", declarations);\n      static_declarations.registerDeclarations (\"YCPBuiltinList\", declarations_ns);\n  \n  #undef ETC\n  #undef ETCf\n  }\n}"
  },
  {
    "function_name": "list (co",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "1221-1245",
    "snippet": "ic YCPValue\nl_tolist (const YCPValue &v)\n{\n    /**\n     * @builtin tolist\n     * @short Converts a value to a list (deprecated, use (list)VAR).\n     * @param any VAR\n     * @return list\n     *\n     * @description\n     * If the value can't be converted to a list, nillist is returned.\n     * Functionality replaced by retyping: <code>any l_1 = [1, 2, 3];\n     * list <integer> l_2 = (list<integer>) l_1;</code>\n     */\n\n    if (v.isNull())\n    {\n\treturn v;\n    }\n    if (v->valuetype() == YT_LIST)\n    {\n\treturn v->asList();\n    }\n    return YCPNull();\n}\n\n\nY",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ull();",
          "args": [],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sList",
          "args": [],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "aluetype",
          "args": [],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "YCPSymbolRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "69-73",
          "snippet": "YCPValueType\nYCPSymbolRep::valuetype() const\n{\n    return YT_SYMBOL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbolRep {\n  YCPValueType\n  YCPSymbolRep::valuetype() const\n  {\n      return YT_SYMBOL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Null",
          "args": [],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nic YCPValue\nl_tolist (const YCPValue &v)\n{\n    /**\n     * @builtin tolist\n     * @short Converts a value to a list (deprecated, use (list)VAR).\n     * @param any VAR\n     * @return list\n     *\n     * @description\n     * If the value can't be converted to a list, nillist is returned.\n     * Functionality replaced by retyping: <code>any l_1 = [1, 2, 3];\n     * list <integer> l_2 = (list<integer>) l_1;</code>\n     */\n\n    if (v.isNull())\n    {\n\treturn v;\n    }\n    if (v->valuetype() == YT_LIST)\n    {\n\treturn v->asList();\n    }\n    return YCPNull();\n}\n\n\nY"
  },
  {
    "function_name": "aplist (co",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "1171-1219",
    "snippet": "ic YCPValue\nl_swaplist (const YCPList &v, YCPInteger &i1, YCPInteger &i2){\n    /**\n     * @builtin list::swap\n     * @id list.swap\n     * @short Creates new list with swaped elemetns at offset i1 and i2.\n     * @param list<flex1> v list\n     * @param integer i1 index of first element\n     * @param integer i2 index of second element\n     * @return New list. Changed if offset is correct, otherwise return unchanged list \n     *\n     * @description\n     * Creates new list with swaped elemetns at offset i1 and i2. Return nil if list or\n     * any offset is nil. Return unchanged list if any offset is out of bounds.\n     *\n     * @usage list::swap ([0,1,2,3],0,2) -> [2,1,0,3]\n     * @usage list::swap ([0,1,2,3],1,3) -> [0,3,2,1]\n     * @usage list::swap ([0,1,2,3],0,4) -> [0,1,2,3]\n     */\n    if (v.isNull ())\n    {\n\tycp2error (\"Cannot swap 'nil' list\");\n\treturn YCPNull ();\n    }\n\n    if (i1.isNull () || i2.isNull())\n    {\n\tycp2error (\"Cannot swap item at index 'nil'\");\n\treturn YCPNull ();\n    }\n\n    int it1 = i1->value();\n    int it2 = i2->value();\n    int siz = v->size();\n    YCPList ret = v;\n    if (it1< 0 || it1>= siz)\n    {\n \tycp2error(\"Index 'i1' is out of bounds for 'swap'\");\n\treturn ret;\n    }\n    if (it2< 0 || it2>= siz)\n    {\n \tycp2error(\"Index 'i2' is out of bounds for 'swap'\");\n\treturn ret;\n    }\n    \n    ret->swap(it1,it2);\n    return ret;\n}\n\nst",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ">swap",
          "args": [
            "it2",
            ";"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error(\"In",
          "args": [
            "ex 'i2' is out of bounds for 'swap'\");"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error(\"In",
          "args": [
            "ex 'i1' is out of bounds for 'swap'\");"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ize",
          "args": [],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value",
          "args": [],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "YCPSymbolRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "69-73",
          "snippet": "YCPValueType\nYCPSymbolRep::valuetype() const\n{\n    return YT_SYMBOL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbolRep {\n  YCPValueType\n  YCPSymbolRep::valuetype() const\n  {\n      return YT_SYMBOL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ull ();",
          "args": [],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error (\"C",
          "args": [
            "not swap item at index 'nil'\");"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sNull",
          "args": [],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sNull",
          "args": [],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ull ();",
          "args": [],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error (\"C",
          "args": [
            "not swap 'nil' list\");"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Null",
          "args": [],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nic YCPValue\nl_swaplist (const YCPList &v, YCPInteger &i1, YCPInteger &i2){\n    /**\n     * @builtin list::swap\n     * @id list.swap\n     * @short Creates new list with swaped elemetns at offset i1 and i2.\n     * @param list<flex1> v list\n     * @param integer i1 index of first element\n     * @param integer i2 index of second element\n     * @return New list. Changed if offset is correct, otherwise return unchanged list \n     *\n     * @description\n     * Creates new list with swaped elemetns at offset i1 and i2. Return nil if list or\n     * any offset is nil. Return unchanged list if any offset is out of bounds.\n     *\n     * @usage list::swap ([0,1,2,3],0,2) -> [2,1,0,3]\n     * @usage list::swap ([0,1,2,3],1,3) -> [0,3,2,1]\n     * @usage list::swap ([0,1,2,3],0,4) -> [0,1,2,3]\n     */\n    if (v.isNull ())\n    {\n\tycp2error (\"Cannot swap 'nil' list\");\n\treturn YCPNull ();\n    }\n\n    if (i1.isNull () || i2.isNull())\n    {\n\tycp2error (\"Cannot swap item at index 'nil'\");\n\treturn YCPNull ();\n    }\n\n    int it1 = i1->value();\n    int it2 = i2->value();\n    int siz = v->size();\n    YCPList ret = v;\n    if (it1< 0 || it1>= siz)\n    {\n \tycp2error(\"Index 'i1' is out of bounds for 'swap'\");\n\treturn ret;\n    }\n    if (it2< 0 || it2>= siz)\n    {\n \tycp2error(\"Index 'i2' is out of bounds for 'swap'\");\n\treturn ret;\n    }\n    \n    ret->swap(it1,it2);\n    return ret;\n}\n\nst"
  },
  {
    "function_name": "duce2 (co",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "1135-1169",
    "snippet": "ic YCPValue\nl_reduce2 (const YCPSymbol &x, const YCPSymbol &y, const YCPValue &initial, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin list::reduce\n     * @id list.reduce-external\n     * @short Reduces a list to a single value.\n     * @param flex1 x\n     * @param flex2 y\n     * @param flex1 value\n     * @param list<flex2> list\n     * @param block<flex1> expression\n     * @return flex1\n     *\n     * @description\n     * Apply expression cumulatively to the values of the list, from left to\n     * right, to reduce the list to a single value. See\n     * http://en.wikipedia.org/wiki/Reduce_(higher-order_function) for a\n     * detailed explanation.\n     *\n     * In this version the initial value is explicitly provided. Thus the list\n     * can be empty. Also the return type can be different from the type of\n     * the list.\n     *\n     * @usage list::reduce (integer x, integer y, 0, [2, 4, 6], { return x + y; }) -> 12\n     * @usage list::reduce (integer x, integer y, 1, [2, 4, 6], { return x * y; }) -> 48\n     *\n     * @usage list::reduce (term t, float f, `item(`id(`dummy)), [3.14, 2.71], { return add(t, tostring(f)); }) -> `item (`id (`dummy), \"3.14\", \"2.71\")\n     */\n\n    const YCPList::const_iterator first = list->begin();\n    const YCPList::const_iterator last = list->end();\n\n    return l_reduce_helper(x, y, initial, first, last, expr);\n}\n\nst",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "duce_helper(x,",
          "args": [
            ",",
            "n",
            "ial, fi",
            "t, la",
            ", ex",
            ");\n}"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->end",
          "args": [],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "endInclude",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "404-420",
          "snippet": "void\nYBlock::endInclude ()\n{\n    const Point *point = m_point->point();\n    if (point == 0)\n    {\n\ty2error (\"YBlock::endInclude() with empty chain (%s)\", m_point->toString().c_str());\n    }\n    else\n    {\n#if DO_DEBUG\n\ty2debug (\"YBlock::endInclude(%s)\", m_point->toString().c_str());\n#endif\n\tm_point = point;\n    }\n    return;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  void\n  YBlock::endInclude ()\n  {\n      const Point *point = m_point->point();\n      if (point == 0)\n      {\n  \ty2error (\"YBlock::endInclude() with empty chain (%s)\", m_point->toString().c_str());\n      }\n      else\n      {\n  #if DO_DEBUG\n  \ty2debug (\"YBlock::endInclude(%s)\", m_point->toString().c_str());\n  #endif\n  \tm_point = point;\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "->begin",
          "args": [],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nic YCPValue\nl_reduce2 (const YCPSymbol &x, const YCPSymbol &y, const YCPValue &initial, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin list::reduce\n     * @id list.reduce-external\n     * @short Reduces a list to a single value.\n     * @param flex1 x\n     * @param flex2 y\n     * @param flex1 value\n     * @param list<flex2> list\n     * @param block<flex1> expression\n     * @return flex1\n     *\n     * @description\n     * Apply expression cumulatively to the values of the list, from left to\n     * right, to reduce the list to a single value. See\n     * http://en.wikipedia.org/wiki/Reduce_(higher-order_function) for a\n     * detailed explanation.\n     *\n     * In this version the initial value is explicitly provided. Thus the list\n     * can be empty. Also the return type can be different from the type of\n     * the list.\n     *\n     * @usage list::reduce (integer x, integer y, 0, [2, 4, 6], { return x + y; }) -> 12\n     * @usage list::reduce (integer x, integer y, 1, [2, 4, 6], { return x * y; }) -> 48\n     *\n     * @usage list::reduce (term t, float f, `item(`id(`dummy)), [3.14, 2.71], { return add(t, tostring(f)); }) -> `item (`id (`dummy), \"3.14\", \"2.71\")\n     */\n\n    const YCPList::const_iterator first = list->begin();\n    const YCPList::const_iterator last = list->end();\n\n    return l_reduce_helper(x, y, initial, first, last, expr);\n}\n\nst"
  },
  {
    "function_name": "duce1 (co",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "1095-1132",
    "snippet": "ic YCPValue\nl_reduce1 (const YCPSymbol &x, const YCPSymbol &y, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin list::reduce\n     * @id list.reduce-internal\n     * @short Reduces a list to a single value.\n     * @param flex1 x\n     * @param flex1 y\n     * @param list<flex1> list\n     * @param block<flex1> expression\n     * @return flex1\n     *\n     * @description\n     * Apply expression cumulatively to the values of the list, from left to\n     * right, to reduce the list to a single value. See\n     * http://en.wikipedia.org/wiki/Reduce_(higher-order_function) for a\n     * detailed explanation.\n     *\n     * In this version the initial value is the first value of the list. Thus\n     * the list must not be empty.\n     *\n     * @usage list::reduce (integer x, integer y, [2, 4, 6], { return x < y ? x : y; }) -> 2\n     * @usage list::reduce (integer x, integer y, [2, 4, 6], { return x > y ? x : y; }) -> 6\n     */\n\n    if (list->isEmpty())\n    {\n \tycp2error(\"Empty list for 'reduce'\");\n\treturn YCPNull();\n    }\n\n    const YCPList::const_iterator initial = list->begin();\n    const YCPList::const_iterator first = initial + 1;\n    const YCPList::const_iterator last = list->end();\n\n    return l_reduce_helper(x, y, *initial, first, last, expr);\n}\n\n\ns",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "duce_helper(x,",
          "args": [
            ",",
            "i",
            "tial, fi",
            "t, la",
            ", ex",
            ");\n}"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->end",
          "args": [],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "endInclude",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "404-420",
          "snippet": "void\nYBlock::endInclude ()\n{\n    const Point *point = m_point->point();\n    if (point == 0)\n    {\n\ty2error (\"YBlock::endInclude() with empty chain (%s)\", m_point->toString().c_str());\n    }\n    else\n    {\n#if DO_DEBUG\n\ty2debug (\"YBlock::endInclude(%s)\", m_point->toString().c_str());\n#endif\n\tm_point = point;\n    }\n    return;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  void\n  YBlock::endInclude ()\n  {\n      const Point *point = m_point->point();\n      if (point == 0)\n      {\n  \ty2error (\"YBlock::endInclude() with empty chain (%s)\", m_point->toString().c_str());\n      }\n      else\n      {\n  #if DO_DEBUG\n  \ty2debug (\"YBlock::endInclude(%s)\", m_point->toString().c_str());\n  #endif\n  \tm_point = point;\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "->begin",
          "args": [],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ull();",
          "args": [],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error(\"Em",
          "args": [
            "ty list for 'reduce'\");"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->isEmpty",
          "args": [],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "isEmpty",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "101-105",
          "snippet": "bool\nYCPTermRep::isEmpty() const\n{\n  return l->isEmpty();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  bool\n  YCPTermRep::isEmpty() const\n  {\n    return l->isEmpty();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nic YCPValue\nl_reduce1 (const YCPSymbol &x, const YCPSymbol &y, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin list::reduce\n     * @id list.reduce-internal\n     * @short Reduces a list to a single value.\n     * @param flex1 x\n     * @param flex1 y\n     * @param list<flex1> list\n     * @param block<flex1> expression\n     * @return flex1\n     *\n     * @description\n     * Apply expression cumulatively to the values of the list, from left to\n     * right, to reduce the list to a single value. See\n     * http://en.wikipedia.org/wiki/Reduce_(higher-order_function) for a\n     * detailed explanation.\n     *\n     * In this version the initial value is the first value of the list. Thus\n     * the list must not be empty.\n     *\n     * @usage list::reduce (integer x, integer y, [2, 4, 6], { return x < y ? x : y; }) -> 2\n     * @usage list::reduce (integer x, integer y, [2, 4, 6], { return x > y ? x : y; }) -> 6\n     */\n\n    if (list->isEmpty())\n    {\n \tycp2error(\"Empty list for 'reduce'\");\n\treturn YCPNull();\n    }\n\n    const YCPList::const_iterator initial = list->begin();\n    const YCPList::const_iterator first = initial + 1;\n    const YCPList::const_iterator last = list->end();\n\n    return l_reduce_helper(x, y, *initial, first, last, expr);\n}\n\n\ns"
  },
  {
    "function_name": "duce_helper(con",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "1057-1092",
    "snippet": "ic YCPValue\nl_reduce_helper(const YCPSymbol &x, const YCPSymbol &y, const YCPValue &initial,\n\t\tconst YCPList::const_iterator &first, const YCPList::const_iterator &last,\n\t\tconst YCPCode &expr)\n{\n    SymbolEntryPtr xs = x->asEntry()->entry();\n    SymbolEntryPtr ys = y->asEntry()->entry();\n\n    YCPValue ret = initial;\n\n    for (YCPList::const_iterator it = first; it != last; ++it)\n    {\n\txs->setValue(ret);\n\tys->setValue(*it);\n\n\tYCPValue tmp = expr->evaluate();\n\tif (tmp.isNull())\n\t{\n\t    ycp2error(\"Bad 'reduce' expression %s\", expr->toString().c_str());\n\t    continue;\n\t}\n\tif (tmp->isVoid())\n\t{\n\t    ycp2error(\"The expression for 'reduce' returned 'nil'\");\n\t    continue;\n\t}\n\tif (tmp->isBreak())\n\t{\n\t    break;\n\t}\n\n\tret = tmp;\n    }\n\n    return ret;\n}\n\n\ns",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ">isBreak",
          "args": [],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error(\"Th",
          "args": [
            "expression for 'reduce' returned 'nil'\");"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">isVoid",
          "args": [],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error(\"Ba",
          "args": [
            "'reduce' expression %s\", ex",
            "->toString().c_str());"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->toString",
          "args": [],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isNull",
          "args": [],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->evaluate",
          "args": [],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "evaluateCall",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3306-3388",
          "snippet": "YCPValue\nY2YCPFunction::evaluateCall ()\n{\n#if DO_DEBUG\n//    y2debug (\"Y2YCPFunction::evaluateCall (%s)\\n\", toString().c_str());\n#endif\n\n    YFunctionPtr func = (YFunctionPtr)(m_sentry->code());\n\n    // push parameter values for recursion\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tfunc->parameter (p)->push ();\n    }\n\n    // push also local parameters\n    YCodePtr definition = func->definition ();\n\n    if (definition == 0)\n    {\n\tycp2error (\"Function '%s' is only declared, but not defined yet.\", m_sentry->toString().c_str());\n\treturn YCPNull();\n    }\n\n    if (definition->isBlock())\n    {\n//       ((YBlockPtr)definition)->pushToStack ();\n    }\n\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tYCPValue value = m_parameters[p];\n\n\tif (value.isNull())\n\t{\n\t    ycp2error (\"Parameter not specified (%d)\", p);\n\n\t    // cleanup: pop parameter values for recursion\n\t    for (unsigned int p = 0; p < func->parameterCount(); p++)\n\t    {\n\t\tfunc->parameter (p)->pop ();\n\t    }\n\n\t    return value;\n\t}\n\t\n\tSymbolEntryPtr formalp = func->parameter (p);\n#if DO_DEBUG\n\ty2debug (\"formalp (%s) = (%s)\", formalp->toString().c_str(), value->toString().c_str());\n#endif\n\n\tformalp->setValue (value);\n    }\n    \n    extern ExecutionEnvironment ee;\n\n    // save the context info\n    int linenumber = ee.linenumber ();\n    string filename = ee.filename ();\n\n    YCPValue value = definition->evaluate ();\n\n    if (definition->isBlock())\n    {\n       // pop also local parameters\n//       ((YBlockPtr)definition)->popFromStack ();\n    }\n\n    // restore the context info\n    ee.setLinenumber (linenumber);\n    ee.setFilename (filename);\n\n    // pop parameter values for recursion\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tfunc->parameter (p)->pop ();\n    }\n\n#if DO_DEBUG\n    y2debug(\"evaluate done (%s) = '%s'\", definition->toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n    return value;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nY2YCPFunction {\n  YCPValue\n  Y2YCPFunction::evaluateCall ()\n  {\n  #if DO_DEBUG\n  //    y2debug (\"Y2YCPFunction::evaluateCall (%s)\\n\", toString().c_str());\n  #endif\n  \n      YFunctionPtr func = (YFunctionPtr)(m_sentry->code());\n  \n      // push parameter values for recursion\n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tfunc->parameter (p)->push ();\n      }\n  \n      // push also local parameters\n      YCodePtr definition = func->definition ();\n  \n      if (definition == 0)\n      {\n  \tycp2error (\"Function '%s' is only declared, but not defined yet.\", m_sentry->toString().c_str());\n  \treturn YCPNull();\n      }\n  \n      if (definition->isBlock())\n      {\n  //       ((YBlockPtr)definition)->pushToStack ();\n      }\n  \n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tYCPValue value = m_parameters[p];\n  \n  \tif (value.isNull())\n  \t{\n  \t    ycp2error (\"Parameter not specified (%d)\", p);\n  \n  \t    // cleanup: pop parameter values for recursion\n  \t    for (unsigned int p = 0; p < func->parameterCount(); p++)\n  \t    {\n  \t\tfunc->parameter (p)->pop ();\n  \t    }\n  \n  \t    return value;\n  \t}\n  \t\n  \tSymbolEntryPtr formalp = func->parameter (p);\n  #if DO_DEBUG\n  \ty2debug (\"formalp (%s) = (%s)\", formalp->toString().c_str(), value->toString().c_str());\n  #endif\n  \n  \tformalp->setValue (value);\n      }\n      \n      extern ExecutionEnvironment ee;\n  \n      // save the context info\n      int linenumber = ee.linenumber ();\n      string filename = ee.filename ();\n  \n      YCPValue value = definition->evaluate ();\n  \n      if (definition->isBlock())\n      {\n         // pop also local parameters\n  //       ((YBlockPtr)definition)->popFromStack ();\n      }\n  \n      // restore the context info\n      ee.setLinenumber (linenumber);\n      ee.setFilename (filename);\n  \n      // pop parameter values for recursion\n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tfunc->parameter (p)->pop ();\n      }\n  \n  #if DO_DEBUG\n      y2debug(\"evaluate done (%s) = '%s'\", definition->toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setValue",
          "args": [
            ";"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "IniEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "155-155",
          "snippet": "void setValue(const string&c)   { dirty = true; val = c;     }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniEntry {\n  void setValue(const string&c)   { dirty = true; val = c;     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sEntry",
          "args": [],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "asEntry",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "227-237",
          "snippet": "YCPEntry\nYCPValueRep::asEntry() const\n{\n    if (!isEntry())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPEntry (static_cast<const YCPEntryRep*>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPEntry\n  YCPValueRep::asEntry() const\n  {\n      if (!isEntry())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPEntry (static_cast<const YCPEntryRep*>(this));\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nic YCPValue\nl_reduce_helper(const YCPSymbol &x, const YCPSymbol &y, const YCPValue &initial,\n\t\tconst YCPList::const_iterator &first, const YCPList::const_iterator &last,\n\t\tconst YCPCode &expr)\n{\n    SymbolEntryPtr xs = x->asEntry()->entry();\n    SymbolEntryPtr ys = y->asEntry()->entry();\n\n    YCPValue ret = initial;\n\n    for (YCPList::const_iterator it = first; it != last; ++it)\n    {\n\txs->setValue(ret);\n\tys->setValue(*it);\n\n\tYCPValue tmp = expr->evaluate();\n\tif (tmp.isNull())\n\t{\n\t    ycp2error(\"Bad 'reduce' expression %s\", expr->toString().c_str());\n\t    continue;\n\t}\n\tif (tmp->isVoid())\n\t{\n\t    ycp2error(\"The expression for 'reduce' returned 'nil'\");\n\t    continue;\n\t}\n\tif (tmp->isBreak())\n\t{\n\t    break;\n\t}\n\n\tret = tmp;\n    }\n\n    return ret;\n}\n\n\ns"
  },
  {
    "function_name": "reach (co",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "1008-1054",
    "snippet": "ic YCPValue\nl_foreach (const YCPValue &sym, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin foreach\n     * @id foreach-list\n     * @short Processes the content of a list\n     * @param any VAR\n     * @param list LIST\n     * @param block EXPR\n     *\n     * @description\n     * For each element of the list <tt>LIST</tt> the expression <tt>EXPR</tt>\n     * is executed in a new context, where the variable <tt>VAR</tt> is\n     * assigned to that value. The return value of the last execution of\n     * <tt>EXPR</tt> is the value of the <tt>foreach</tt> construct.\n     *\n     * @return any return value of last execution of EXPR\n     * @usage foreach (integer v, [1,2,3], { return v + 10; }) -> 13\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    SymbolEntryPtr s = sym->asEntry()->entry();\n    YCPValue ret = YCPVoid();\n\n    for (YCPList::const_iterator it = list->begin(); it != list->end(); ++it)\n    {\n\ts->setValue(*it);\n\n\tret = expr->evaluate ();\n\tif (ret.isNull())\n\t{\n\t    ycp2error (\"Bad foreach expression %s\", expr->toString ().c_str ());\n\t    continue;\n\t}\n\telse if (ret->isBreak())\n\t{\n\t    ret = YCPVoid();\n\t    break;\n\t}\n    }\n    return ret;\n}\n\n\ns",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oid();",
          "args": [],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">isBreak",
          "args": [],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error (\"B",
          "args": [
            "foreach expression %s\", ex",
            "->toString ().c_str ());"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->toString",
          "args": [],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isNull",
          "args": [],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->evaluate",
          "args": [],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "evaluateCall",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3306-3388",
          "snippet": "YCPValue\nY2YCPFunction::evaluateCall ()\n{\n#if DO_DEBUG\n//    y2debug (\"Y2YCPFunction::evaluateCall (%s)\\n\", toString().c_str());\n#endif\n\n    YFunctionPtr func = (YFunctionPtr)(m_sentry->code());\n\n    // push parameter values for recursion\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tfunc->parameter (p)->push ();\n    }\n\n    // push also local parameters\n    YCodePtr definition = func->definition ();\n\n    if (definition == 0)\n    {\n\tycp2error (\"Function '%s' is only declared, but not defined yet.\", m_sentry->toString().c_str());\n\treturn YCPNull();\n    }\n\n    if (definition->isBlock())\n    {\n//       ((YBlockPtr)definition)->pushToStack ();\n    }\n\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tYCPValue value = m_parameters[p];\n\n\tif (value.isNull())\n\t{\n\t    ycp2error (\"Parameter not specified (%d)\", p);\n\n\t    // cleanup: pop parameter values for recursion\n\t    for (unsigned int p = 0; p < func->parameterCount(); p++)\n\t    {\n\t\tfunc->parameter (p)->pop ();\n\t    }\n\n\t    return value;\n\t}\n\t\n\tSymbolEntryPtr formalp = func->parameter (p);\n#if DO_DEBUG\n\ty2debug (\"formalp (%s) = (%s)\", formalp->toString().c_str(), value->toString().c_str());\n#endif\n\n\tformalp->setValue (value);\n    }\n    \n    extern ExecutionEnvironment ee;\n\n    // save the context info\n    int linenumber = ee.linenumber ();\n    string filename = ee.filename ();\n\n    YCPValue value = definition->evaluate ();\n\n    if (definition->isBlock())\n    {\n       // pop also local parameters\n//       ((YBlockPtr)definition)->popFromStack ();\n    }\n\n    // restore the context info\n    ee.setLinenumber (linenumber);\n    ee.setFilename (filename);\n\n    // pop parameter values for recursion\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tfunc->parameter (p)->pop ();\n    }\n\n#if DO_DEBUG\n    y2debug(\"evaluate done (%s) = '%s'\", definition->toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n    return value;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nY2YCPFunction {\n  YCPValue\n  Y2YCPFunction::evaluateCall ()\n  {\n  #if DO_DEBUG\n  //    y2debug (\"Y2YCPFunction::evaluateCall (%s)\\n\", toString().c_str());\n  #endif\n  \n      YFunctionPtr func = (YFunctionPtr)(m_sentry->code());\n  \n      // push parameter values for recursion\n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tfunc->parameter (p)->push ();\n      }\n  \n      // push also local parameters\n      YCodePtr definition = func->definition ();\n  \n      if (definition == 0)\n      {\n  \tycp2error (\"Function '%s' is only declared, but not defined yet.\", m_sentry->toString().c_str());\n  \treturn YCPNull();\n      }\n  \n      if (definition->isBlock())\n      {\n  //       ((YBlockPtr)definition)->pushToStack ();\n      }\n  \n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tYCPValue value = m_parameters[p];\n  \n  \tif (value.isNull())\n  \t{\n  \t    ycp2error (\"Parameter not specified (%d)\", p);\n  \n  \t    // cleanup: pop parameter values for recursion\n  \t    for (unsigned int p = 0; p < func->parameterCount(); p++)\n  \t    {\n  \t\tfunc->parameter (p)->pop ();\n  \t    }\n  \n  \t    return value;\n  \t}\n  \t\n  \tSymbolEntryPtr formalp = func->parameter (p);\n  #if DO_DEBUG\n  \ty2debug (\"formalp (%s) = (%s)\", formalp->toString().c_str(), value->toString().c_str());\n  #endif\n  \n  \tformalp->setValue (value);\n      }\n      \n      extern ExecutionEnvironment ee;\n  \n      // save the context info\n      int linenumber = ee.linenumber ();\n      string filename = ee.filename ();\n  \n      YCPValue value = definition->evaluate ();\n  \n      if (definition->isBlock())\n      {\n         // pop also local parameters\n  //       ((YBlockPtr)definition)->popFromStack ();\n      }\n  \n      // restore the context info\n      ee.setLinenumber (linenumber);\n      ee.setFilename (filename);\n  \n      // pop parameter values for recursion\n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tfunc->parameter (p)->pop ();\n      }\n  \n  #if DO_DEBUG\n      y2debug(\"evaluate done (%s) = '%s'\", definition->toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "etValue",
          "args": [
            ";"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "IniEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "155-155",
          "snippet": "void setValue(const string&c)   { dirty = true; val = c;     }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniEntry {\n  void setValue(const string&c)   { dirty = true; val = c;     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "->end",
          "args": [],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "endInclude",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBlock.cc",
          "lines": "404-420",
          "snippet": "void\nYBlock::endInclude ()\n{\n    const Point *point = m_point->point();\n    if (point == 0)\n    {\n\ty2error (\"YBlock::endInclude() with empty chain (%s)\", m_point->toString().c_str());\n    }\n    else\n    {\n#if DO_DEBUG\n\ty2debug (\"YBlock::endInclude(%s)\", m_point->toString().c_str());\n#endif\n\tm_point = point;\n    }\n    return;\n}",
          "includes": [
            "#include <Debugger.h>",
            "#include \"ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include <algorithm>",
            "#include <stack>",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Type.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Debugger.h>\n#include \"ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include <algorithm>\n#include <stack>\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Type.h\"\n\n#define DO_DEBUG 0\n\nYBlock {\n  void\n  YBlock::endInclude ()\n  {\n      const Point *point = m_point->point();\n      if (point == 0)\n      {\n  \ty2error (\"YBlock::endInclude() with empty chain (%s)\", m_point->toString().c_str());\n      }\n      else\n      {\n  #if DO_DEBUG\n  \ty2debug (\"YBlock::endInclude(%s)\", m_point->toString().c_str());\n  #endif\n  \tm_point = point;\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "->begin",
          "args": [],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "oid();",
          "args": [],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">asEntry",
          "args": [],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">asEntry",
          "args": [],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ull ();",
          "args": [],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".isNull",
          "args": [],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nic YCPValue\nl_foreach (const YCPValue &sym, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin foreach\n     * @id foreach-list\n     * @short Processes the content of a list\n     * @param any VAR\n     * @param list LIST\n     * @param block EXPR\n     *\n     * @description\n     * For each element of the list <tt>LIST</tt> the expression <tt>EXPR</tt>\n     * is executed in a new context, where the variable <tt>VAR</tt> is\n     * assigned to that value. The return value of the last execution of\n     * <tt>EXPR</tt> is the value of the <tt>foreach</tt> construct.\n     *\n     * @return any return value of last execution of EXPR\n     * @usage foreach (integer v, [1,2,3], { return v + 10; }) -> 13\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    SymbolEntryPtr s = sym->asEntry()->entry();\n    YCPValue ret = YCPVoid();\n\n    for (YCPList::const_iterator it = list->begin(); it != list->end(); ++it)\n    {\n\ts->setValue(*it);\n\n\tret = expr->evaluate ();\n\tif (ret.isNull())\n\t{\n\t    ycp2error (\"Bad foreach expression %s\", expr->toString ().c_str ());\n\t    continue;\n\t}\n\telse if (ret->isBreak())\n\t{\n\t    ret = YCPVoid();\n\t    break;\n\t}\n    }\n    return ret;\n}\n\n\ns"
  },
  {
    "function_name": "lect (co",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "949-1005",
    "snippet": "ic YCPValue\nl_select (const YCPValue &list, const YCPValue &i, const YCPValue &def)\n{\n    /**\n     * @builtin select\n     * @id select-list\n     * @short Selects a list element (deprecated, use LIST[INDEX]:DEFAULT)\n     * @param list LIST\n     * @param integer INDEX\n     * @param any  DEFAULT\n     * @return any\n     *\n     * @description\n     * Gets the <tt>INDEX</tt>'th value of a list. The first value has the\n     * index 0. The call select([1,2,3], 1) thus returns 2. Returns <tt>DEFAULT</tt>\n     * if the index is invalid or if the found entry has a different type\n     * than the default value.\n     * Functionality replaced by syntax: <code>list numbers = [1, 2, 3, 4];\n     * numbers[2]:nil -> 3\n     * numbers[8]:5   -> 5</code>\n     *\n     * @usage select ([1, 2], 22, 0) -> 0\n     * @usage select ([1, \"two\"], 0, \"no\") -> \"no\"\n     */\n\n    if (list.isNull()\n\t|| !list->isList()\n\t|| i.isNull()\n\t|| !i->isInteger())\n    {\n\treturn def;\n    }\n    long idx = i->asInteger()->value ();\n    if (idx < 0 || idx >= list->asList()->size ())\n    {\n\treturn def;\n    }\n\n    // FIXME: runtime type check, because of the term variant of select\n    // ensure, that it is really a list\n    YCPValue tmp = list;\n    if ( ! tmp->isList ())\n    {\n\t// for term, call the other builtin\n\tif ( tmp->isTerm ())\n\t{\n\t    extern YCPValue t_select (const YCPValue &list, const YCPValue &i, const YCPValue &def);\n\t    return t_select (tmp->asTerm (), i->asInteger(), def);\n\t}\n\tycp2error (\"Incorrect builtin called, %s is not a list\", tmp->toString ().c_str ());\n\treturn def;\n    }\n\n    YCPValue v = list->asList()->value (idx);\n\n    return v;\n}\n\n\ns",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "->asList",
          "args": [
            ";"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->asList",
          "args": [],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error (\"I",
          "args": [
            "orrect builtin called, %s is not a list\", tm",
            ">toString ().c_str ());"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">toString",
          "args": [],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">toString",
          "args": [],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lect (tm",
          "args": [
            ">asTerm (), i-",
            "sInteger(), de",
            ";"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sInteger",
          "args": [],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "asInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "106-116",
          "snippet": "YCPInteger\nYCPValueRep::asInteger() const\n{\n    if (!isInteger())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPInteger\n  YCPValueRep::asInteger() const\n  {\n      if (!isInteger())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": ">asTerm",
          "args": [],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">isTerm",
          "args": [],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">isList",
          "args": [],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Null",
          "args": [],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->isList",
          "args": [],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": ".isNull",
          "args": [],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nic YCPValue\nl_select (const YCPValue &list, const YCPValue &i, const YCPValue &def)\n{\n    /**\n     * @builtin select\n     * @id select-list\n     * @short Selects a list element (deprecated, use LIST[INDEX]:DEFAULT)\n     * @param list LIST\n     * @param integer INDEX\n     * @param any  DEFAULT\n     * @return any\n     *\n     * @description\n     * Gets the <tt>INDEX</tt>'th value of a list. The first value has the\n     * index 0. The call select([1,2,3], 1) thus returns 2. Returns <tt>DEFAULT</tt>\n     * if the index is invalid or if the found entry has a different type\n     * than the default value.\n     * Functionality replaced by syntax: <code>list numbers = [1, 2, 3, 4];\n     * numbers[2]:nil -> 3\n     * numbers[8]:5   -> 5</code>\n     *\n     * @usage select ([1, 2], 22, 0) -> 0\n     * @usage select ([1, \"two\"], 0, \"no\") -> \"no\"\n     */\n\n    if (list.isNull()\n\t|| !list->isList()\n\t|| i.isNull()\n\t|| !i->isInteger())\n    {\n\treturn def;\n    }\n    long idx = i->asInteger()->value ();\n    if (idx < 0 || idx >= list->asList()->size ())\n    {\n\treturn def;\n    }\n\n    // FIXME: runtime type check, because of the term variant of select\n    // ensure, that it is really a list\n    YCPValue tmp = list;\n    if ( ! tmp->isList ())\n    {\n\t// for term, call the other builtin\n\tif ( tmp->isTerm ())\n\t{\n\t    extern YCPValue t_select (const YCPValue &list, const YCPValue &i, const YCPValue &def);\n\t    return t_select (tmp->asTerm (), i->asInteger(), def);\n\t}\n\tycp2error (\"Incorrect builtin called, %s is not a list\", tmp->toString ().c_str ());\n\treturn def;\n    }\n\n    YCPValue v = list->asList()->value (idx);\n\n    return v;\n}\n\n\ns"
  },
  {
    "function_name": "move (co",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "902-945",
    "snippet": "ic YCPValue\nl_remove (const YCPList &list, const YCPInteger &i)\n{\n    /**\n     * @builtin remove\n     * @id remove-list\n     * @short Removes element from a list\n     * @param list LIST\n     * @param integer e element index\n     * @return list Returns unchanged list if the index is invalid.\n     * @description\n     * Removes the <tt>i</tt>'th value from a list. The first value has the\n     * index 0. The call remove ([1,2,3], 1) thus returns [1,3].\n     *\n     * The yast2-core version < 2.17.16 returns nil if the key is invalid. This behavior\n     * has changed in version 2.17.16 to return unchanged list.\n     *\n     * @usage remove ([1, 2], 0) -> [2]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    if (i.isNull ())\n    {\n\tycp2error (\"Cannot remove item at index 'nil'\");\n\treturn YCPNull ();\n    }\n\n    long idx = i->value ();\n\n    YCPList ret = list;\n\n    if (idx < 0 || idx >= ret->size ())\n    {\n\tycp2error (\"Index %s for remove () out of range\", toString (idx).c_str ());\n\treturn ret;\n    }\n\n    ret->remove (idx);\n    return ret;\n}\n\n\n/",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ">remove",
          "args": [
            ";"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error (\"I",
          "args": [
            "ex %s for remove () out of range\", to",
            "ring (idx).c_str ());"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring",
          "args": [],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring (id",
          "args": [
            ".c_"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">size",
          "args": [],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue",
          "args": [],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "asValue",
          "container": "YCPElementRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPElement.cc",
          "lines": "54-58",
          "snippet": "YCPValue\nYCPElementRep::asValue() const\n{\n    return YCPValue(static_cast<const YCPValueRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPValue.h\"",
            "#include \"ycp/YCPElement.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPValue.h\"\n#include \"ycp/YCPElement.h\"\n#include \"ycp/y2log.h\"\n\nYCPElementRep {\n  YCPValue\n  YCPElementRep::asValue() const\n  {\n      return YCPValue(static_cast<const YCPValueRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ull ();",
          "args": [],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error (\"C",
          "args": [
            "not remove item at index 'nil'\");"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Null",
          "args": [],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ull ();",
          "args": [],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".isNull",
          "args": [],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nic YCPValue\nl_remove (const YCPList &list, const YCPInteger &i)\n{\n    /**\n     * @builtin remove\n     * @id remove-list\n     * @short Removes element from a list\n     * @param list LIST\n     * @param integer e element index\n     * @return list Returns unchanged list if the index is invalid.\n     * @description\n     * Removes the <tt>i</tt>'th value from a list. The first value has the\n     * index 0. The call remove ([1,2,3], 1) thus returns [1,3].\n     *\n     * The yast2-core version < 2.17.16 returns nil if the key is invalid. This behavior\n     * has changed in version 2.17.16 to return unchanged list.\n     *\n     * @usage remove ([1, 2], 0) -> [2]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    if (i.isNull ())\n    {\n\tycp2error (\"Cannot remove item at index 'nil'\");\n\treturn YCPNull ();\n    }\n\n    long idx = i->value ();\n\n    YCPList ret = list;\n\n    if (idx < 0 || idx >= ret->size ())\n    {\n\tycp2error (\"Index %s for remove () out of range\", toString (idx).c_str ());\n\treturn ret;\n    }\n\n    ret->remove (idx);\n    return ret;\n}\n\n\n/"
  },
  {
    "function_name": "ze (co",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "877-899",
    "snippet": "ic YCPValue\nl_size (const YCPValue &list)\n{\n    /**\n     * @builtin size\n     * @id size-list\n     * @short Returns size of list\n     * @param list LIST\n     * @return integer size of the list\n     *\n     * @description\n     * Returns the number of elements of the list <tt>LIST</tt>\n     *\n     * @usage size([\"A\", 1, true, \"3\", false]) -> 5\n     */\n\n    if (list.isNull ()\n\t|| !list->isList ())\n    {\n\treturn YCPInteger (0LL);\n    }\n    return YCPInteger (list->asList()->size ());\n}\n\n\ns",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nteger (li",
          "args": [
            "->asList()->size ());\n}"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->asList",
          "args": [],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nteger (0L",
          "args": [
            ";"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->isList",
          "args": [],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": ".isNull",
          "args": [],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nic YCPValue\nl_size (const YCPValue &list)\n{\n    /**\n     * @builtin size\n     * @id size-list\n     * @short Returns size of list\n     * @param list LIST\n     * @return integer size of the list\n     *\n     * @description\n     * Returns the number of elements of the list <tt>LIST</tt>\n     *\n     * @usage size([\"A\", 1, true, \"3\", false]) -> 5\n     */\n\n    if (list.isNull ()\n\t|| !list->isList ())\n    {\n\treturn YCPInteger (0LL);\n    }\n    return YCPInteger (list->asList()->size ());\n}\n\n\ns"
  },
  {
    "function_name": "empty(con",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "855-873",
    "snippet": "ic YCPValue\nl_isempty(const YCPList& l)\n{\n    /**\n     * @builtin isempty\n     * @id isempty-list\n     * @short Returns whether the list <tt>l</tt> is empty.\n     * @param list l List\n     * @return boolean Emptiness of list <tt>l</tt>\n     *\n     * @description\n     * Notice that the list <tt>l</tt> must not be nil.\n     *\n     * @usage isempty([]) -> true\n     * @usage isempty([19, 29]) -> false\n     */\n\n    return YCPBoolean(l->isEmpty());\n}\n\n\n/",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oolean(l->",
          "args": [
            "sEmpty());\n}"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sEmpty",
          "args": [],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "isEmpty",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "101-105",
          "snippet": "bool\nYCPTermRep::isEmpty() const\n{\n  return l->isEmpty();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  bool\n  YCPTermRep::isEmpty() const\n  {\n    return l->isEmpty();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nic YCPValue\nl_isempty(const YCPList& l)\n{\n    /**\n     * @builtin isempty\n     * @id isempty-list\n     * @short Returns whether the list <tt>l</tt> is empty.\n     * @param list l List\n     * @return boolean Emptiness of list <tt>l</tt>\n     *\n     * @description\n     * Notice that the list <tt>l</tt> must not be nil.\n     *\n     * @usage isempty([]) -> true\n     * @usage isempty([19, 29]) -> false\n     */\n\n    return YCPBoolean(l->isEmpty());\n}\n\n\n/"
  },
  {
    "function_name": "d (co",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "828-852",
    "snippet": "ic YCPValue\nl_add (const YCPValue &list, const YCPValue &value)\n{\n    /**\n     * @builtin add\n     * @id add-list\n     * @short Create a new list with a new element\n     * @param list LIST\n     * @param any VAR\n     * @return list The new list\n     * @description\n     * Creates a new list that is identical to the list <tt>LIST</tt> but has\n     * the value <tt>VAR</tt> appended as additional element.\n     *\n     * @usage add ([1, 4], 8) -> [1, 4, 8]\n     */\n\n    if (list.isNull () || !list->isList())\n    {\n\tycp2error (\"Adding to a nil list\");\n\treturn YCPNull ();\n    }\n\n    return list->asList()->functionalAdd (value);\n}\n\n\ns",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "->asList",
          "args": [
            "e);\n}"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->asList",
          "args": [],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ull ();",
          "args": [],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error (\"A",
          "args": [
            "ing to a nil list\");"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->isList",
          "args": [],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": ".isNull",
          "args": [],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nic YCPValue\nl_add (const YCPValue &list, const YCPValue &value)\n{\n    /**\n     * @builtin add\n     * @id add-list\n     * @short Create a new list with a new element\n     * @param list LIST\n     * @param any VAR\n     * @return list The new list\n     * @description\n     * Creates a new list that is identical to the list <tt>LIST</tt> but has\n     * the value <tt>VAR</tt> appended as additional element.\n     *\n     * @usage add ([1, 4], 8) -> [1, 4, 8]\n     */\n\n    if (list.isNull () || !list->isList())\n    {\n\tycp2error (\"Adding to a nil list\");\n\treturn YCPNull ();\n    }\n\n    return list->asList()->functionalAdd (value);\n}\n\n\ns"
  },
  {
    "function_name": "angelist (YC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "797-825",
    "snippet": "ic YCPValue\nl_changelist (YCPList &list, const YCPValue &value)\n{\n    /**\n     * @builtin change\n     * @id change-list\n     * @short Changes a list. Deprecated, use LIST[size(LIST)] = value.\n     * @param list LIST\n     * @param any value\n     * @return list\n     *\n     * @description\n     * Before Code 9, this was used to change a list directly\n     * without creating a copy. Now it is a synonym for add.\n     *\n     * @see add\n     * @usage change ([1, 4], 8) -> [1, 4, 8]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    ycpinternal (\"Change does not work as expected! The argument is not passed by reference.\");\n\n    list->add (value);\n    return list;\n}\n\n\ns",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "->add",
          "args": [
            "e);"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nternal (\"C",
          "args": [
            "nge does not work as expected! The argument is not passed by reference.\");"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ull ();",
          "args": [],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".isNull",
          "args": [],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nic YCPValue\nl_changelist (YCPList &list, const YCPValue &value)\n{\n    /**\n     * @builtin change\n     * @id change-list\n     * @short Changes a list. Deprecated, use LIST[size(LIST)] = value.\n     * @param list LIST\n     * @param any value\n     * @return list\n     *\n     * @description\n     * Before Code 9, this was used to change a list directly\n     * without creating a copy. Now it is a synonym for add.\n     *\n     * @see add\n     * @usage change ([1, 4], 8) -> [1, 4, 8]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    ycpinternal (\"Change does not work as expected! The argument is not passed by reference.\");\n\n    list->add (value);\n    return list;\n}\n\n\ns"
  },
  {
    "function_name": "litstring (co",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "722-794",
    "snippet": "ic YCPValue\nl_splitstring (const YCPString &s, const YCPString &c)\n{\n    /**\n     * @builtin splitstring\n     * @short Split a string by delimiter\n     * @param string STR\n     * @param string DELIM\n     * @return list<string>\n     *\n     * @description\n     * Splits <tt>STR</tt> into sub-strings at delimiter chars <tt>DELIM</tt>.\n     * the resulting pieces do not contain <tt>DELIM</tt>\n     *\n     * If <tt>STR</tt> starts with <tt>DELIM</tt>, the first string in the result list is empty\n     * If <tt>STR</tt> ends with <tt>DELIM</tt>, the last string in the result list is empty.\n     * If <tt>STR</tt> does not contain <tt>DELIM</tt>, the result is a singleton list with <tt>STR</tt>.\n     *\n     * @see mergestring\n     * @usage splitstring (\"/abc/dev/ghi\", \"/\") -> [\"\", \"abc\", \"dev\", \"ghi\" ]\n     * @usage splitstring (\"abc/dev/ghi/\", \"/\") -> [\"abc\", \"dev\", \"ghi\", \"\" ]\n     * @usage splitstring (\"abc/dev/ghi/\", \".\") -> [\"abc/dev/ghi/\" ]\n     * @usage splitstring (\"text/with:different/separators\", \"/:\") -> [\"text\", \"with\", \"different\", \"separators\"]\n     */\n\n    if (s.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    if (c.isNull ())\n    {\n\tycp2error (\"Cannot split string using 'nil'\");\n\treturn YCPNull ();\n    }\n\n    YCPList ret;\n\n    string ss = s->value ();\n    string sc = c->value ();\n\n    if (ss.empty () || sc.empty ())\n\treturn ret;\n\n    string::size_type spos = 0;\t\t\t// start pos\n    string::size_type epos = 0;\t\t\t// end pos\n\n    while (true)\n    {\n\tepos = ss.find_first_of (sc, spos);\n\n\tif (epos == string::npos)\t// break if not found\n\t{\n\t    ret->add (YCPString (string (ss, spos)));\n\t    break;\n\t}\n\n\tif (spos == epos)\n\t    ret->add (YCPString (\"\"));\n\telse\n\t    ret->add (YCPString (string (ss, spos, epos - spos)));\t// string piece w/o delimiter\n\n\tspos = epos + 1;\t// skip c in s\n\n\tif (spos == ss.size ())\t// c was last char\n\t{\n\t    ret->add (YCPString (\"\"));\t// add \"\" and break\n\t    break;\n\t}\n    }\n\n    return ret;\n}\n\n\ns",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ">add",
          "args": [
            "tring (\"\"));\t/"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring (\"\"",
          "args": [
            ";"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ize",
          "args": [],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": ">add",
          "args": [
            "tring (string (ss, spos, epos - spos)));\t/"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring (st",
          "args": [
            "ng (ss, spos, epos - spos)));"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ng (ss",
          "args": [
            "sp",
            ", ep",
            "- spos)));"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">add",
          "args": [
            "tring (\"\"));"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring (\"\"",
          "args": [
            ";"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">add",
          "args": [
            "tring (string (ss, spos)));"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring (st",
          "args": [
            "ng (ss, spos)));"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ng (ss",
          "args": [
            "sp",
            ")));"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ind_first_of",
          "args": [
            "sp",
            ");"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpty",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "isEmpty",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "101-105",
          "snippet": "bool\nYCPTermRep::isEmpty() const\n{\n  return l->isEmpty();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  bool\n  YCPTermRep::isEmpty() const\n  {\n    return l->isEmpty();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "alue",
          "args": [],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "asValue",
          "container": "YCPElementRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPElement.cc",
          "lines": "54-58",
          "snippet": "YCPValue\nYCPElementRep::asValue() const\n{\n    return YCPValue(static_cast<const YCPValueRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPValue.h\"",
            "#include \"ycp/YCPElement.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPValue.h\"\n#include \"ycp/YCPElement.h\"\n#include \"ycp/y2log.h\"\n\nYCPElementRep {\n  YCPValue\n  YCPElementRep::asValue() const\n  {\n      return YCPValue(static_cast<const YCPValueRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ull ();",
          "args": [],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error (\"C",
          "args": [
            "not split string using 'nil'\");"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Null",
          "args": [],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ull ();",
          "args": [],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Null",
          "args": [],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nic YCPValue\nl_splitstring (const YCPString &s, const YCPString &c)\n{\n    /**\n     * @builtin splitstring\n     * @short Split a string by delimiter\n     * @param string STR\n     * @param string DELIM\n     * @return list<string>\n     *\n     * @description\n     * Splits <tt>STR</tt> into sub-strings at delimiter chars <tt>DELIM</tt>.\n     * the resulting pieces do not contain <tt>DELIM</tt>\n     *\n     * If <tt>STR</tt> starts with <tt>DELIM</tt>, the first string in the result list is empty\n     * If <tt>STR</tt> ends with <tt>DELIM</tt>, the last string in the result list is empty.\n     * If <tt>STR</tt> does not contain <tt>DELIM</tt>, the result is a singleton list with <tt>STR</tt>.\n     *\n     * @see mergestring\n     * @usage splitstring (\"/abc/dev/ghi\", \"/\") -> [\"\", \"abc\", \"dev\", \"ghi\" ]\n     * @usage splitstring (\"abc/dev/ghi/\", \"/\") -> [\"abc\", \"dev\", \"ghi\", \"\" ]\n     * @usage splitstring (\"abc/dev/ghi/\", \".\") -> [\"abc/dev/ghi/\" ]\n     * @usage splitstring (\"text/with:different/separators\", \"/:\") -> [\"text\", \"with\", \"different\", \"separators\"]\n     */\n\n    if (s.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    if (c.isNull ())\n    {\n\tycp2error (\"Cannot split string using 'nil'\");\n\treturn YCPNull ();\n    }\n\n    YCPList ret;\n\n    string ss = s->value ();\n    string sc = c->value ();\n\n    if (ss.empty () || sc.empty ())\n\treturn ret;\n\n    string::size_type spos = 0;\t\t\t// start pos\n    string::size_type epos = 0;\t\t\t// end pos\n\n    while (true)\n    {\n\tepos = ss.find_first_of (sc, spos);\n\n\tif (epos == string::npos)\t// break if not found\n\t{\n\t    ret->add (YCPString (string (ss, spos)));\n\t    break;\n\t}\n\n\tif (spos == epos)\n\t    ret->add (YCPString (\"\"));\n\telse\n\t    ret->add (YCPString (string (ss, spos, epos - spos)));\t// string piece w/o delimiter\n\n\tspos = epos + 1;\t// skip c in s\n\n\tif (spos == ss.size ())\t// c was last char\n\t{\n\t    ret->add (YCPString (\"\"));\t// add \"\" and break\n\t    break;\n\t}\n    }\n\n    return ret;\n}\n\n\ns"
  },
  {
    "function_name": "l_lsortlist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "693-719",
    "snippet": "static YCPValue\nl_lsortlist (const YCPList &list)\n{\n    /**\n     * @builtin lsort\n     * @short Sort A List respecting locale\n     * @param list LIST\n     * @return list Sorted list\n     * @description\n     * Sort the list LIST according to the YCP builtin predicate\n     * <b>></b>.\n     * Strings are compared using the current locale.\n     * Duplicates are not removed.\n     *\n     * @usage lsort ([\"esky\", \"slovensky\", \"nmecky\", 2, 1]) -> [1,\n     * 2, \"esky\", \"nmecky\", \"slovensky\"]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPList ret = list;\n    ret->lsortlist ();\n    return ret;\n}\n\n\ns",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ">lsortlist",
          "args": [],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ull ();",
          "args": [],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".isNull",
          "args": [],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_lsortlist (const YCPList &list)\n{\n    /**\n     * @builtin lsort\n     * @short Sort A List respecting locale\n     * @param list LIST\n     * @return list Sorted list\n     * @description\n     * Sort the list LIST according to the YCP builtin predicate\n     * <b>></b>.\n     * Strings are compared using the current locale.\n     * Duplicates are not removed.\n     *\n     * @usage lsort ([\"esky\", \"slovensky\", \"nmecky\", 2, 1]) -> [1,\n     * 2, \"esky\", \"nmecky\", \"slovensky\"]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPList ret = list;\n    ret->lsortlist ();\n    return ret;\n}\n\n\ns"
  },
  {
    "function_name": "l_sort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "647-690",
    "snippet": "static YCPValue\nl_sort (const YCPValue &sym1, const YCPValue &sym2,\n\t const YCPList &list, const YCPCode &order)\n{\n    /**\n     * @builtin sort\n     * @id sort-expr\n     * @short Sort list using an expression\n     * @param any x\n     * @param any y\n     * @param list LIST\n     * @param block EXPR\n     * @return list\n     * @description\n     *\n     * Sorts the list <tt>LIST</tt>. You have to specify an order on the\n     * list elements by naming formal variables <tt>x</tt> and <tt>y</tt> and\n     * specify an expression <tt>EXPR</tt> that evaluates to a boolean\n     * value depending on <tt>x</tt> and <tt>y</tt>.\n     * Return true if <tt>x</tt>><tt>y</tt> to\n     * sort the list ascending.\n     *\n     * The comparison must be an irreflexive one,\n     * that is \">\" instead of \">=\".\n     *\n     * It is because we no longer use bubblesort (yuck) but <b>std::sort</b>\n     * which requires a\n     * <ulink url=\"href=\"http://www.sgi.com/tech/stl/StrictWeakOrdering.html\">strict\n     * weak ordering</ulink>.\n     *\n     * @usage sort (integer x, integer y, [ 3,6,2,8 ], ``(x < y)) -> [ 2, 3, 6, 8 ]\n     * @usage sort (string x, string y, [ \"A\",\"C\",\"B\" ], ``(x > y)) -> [\"C\", \"B\", \"A\"]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPList result = list;\n    result->fsortlist (YCPCodeCompare (sym1, sym2, order));\n\n    return result;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result->fsortlist",
          "args": [
            "YCPCodeCompare (sym1, sym2, order)"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "fsortlist",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "131-135",
          "snippet": "void\nYCPListRep::fsortlist(const YCPCodeCompare& cmp)\n{\n    std::sort (elements.begin (), elements.end (), cmp);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::fsortlist(const YCPCodeCompare& cmp)\n  {\n      std::sort (elements.begin (), elements.end (), cmp);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPCodeCompare",
          "args": [
            "sym1",
            "sym2",
            "order"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "YCPCodeCompare",
          "container": "YCPCodeCompare",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YCPCodeCompare.h",
          "lines": "39-45",
          "snippet": "YCPCodeCompare (const YCPValue &asym1, const YCPValue &asym2,\n\t\t    const YCPCode &aorder)\n\t:   se1 (asym1->asEntry ()->entry ())\n\t  , se2 (asym2->asEntry ()->entry ())\n\t  , order (aorder)\n\t{\n\t}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"y2/SymbolEntry.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPCode.h\"\n#include \"y2/SymbolEntry.h\"\n\nYCPCodeCompare {\n  YCPCodeCompare (const YCPValue &asym1, const YCPValue &asym2,\n  \t\t    const YCPCode &aorder)\n  \t:   se1 (asym1->asEntry ()->entry ())\n  \t  , se2 (asym2->asEntry ()->entry ())\n  \t  , order (aorder)\n  \t{\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list.isNull",
          "args": [],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_sort (const YCPValue &sym1, const YCPValue &sym2,\n\t const YCPList &list, const YCPCode &order)\n{\n    /**\n     * @builtin sort\n     * @id sort-expr\n     * @short Sort list using an expression\n     * @param any x\n     * @param any y\n     * @param list LIST\n     * @param block EXPR\n     * @return list\n     * @description\n     *\n     * Sorts the list <tt>LIST</tt>. You have to specify an order on the\n     * list elements by naming formal variables <tt>x</tt> and <tt>y</tt> and\n     * specify an expression <tt>EXPR</tt> that evaluates to a boolean\n     * value depending on <tt>x</tt> and <tt>y</tt>.\n     * Return true if <tt>x</tt>><tt>y</tt> to\n     * sort the list ascending.\n     *\n     * The comparison must be an irreflexive one,\n     * that is \">\" instead of \">=\".\n     *\n     * It is because we no longer use bubblesort (yuck) but <b>std::sort</b>\n     * which requires a\n     * <ulink url=\"href=\"http://www.sgi.com/tech/stl/StrictWeakOrdering.html\">strict\n     * weak ordering</ulink>.\n     *\n     * @usage sort (integer x, integer y, [ 3,6,2,8 ], ``(x < y)) -> [ 2, 3, 6, 8 ]\n     * @usage sort (string x, string y, [ \"A\",\"C\",\"B\" ], ``(x > y)) -> [\"C\", \"B\", \"A\"]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPList result = list;\n    result->fsortlist (YCPCodeCompare (sym1, sym2, order));\n\n    return result;\n}"
  },
  {
    "function_name": "l_sortlist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "620-645",
    "snippet": "static YCPValue\nl_sortlist (const YCPList &list)\n{\n    /**\n     * @builtin sort\n     * @id sort-lt\n     * @short Sorts a List according to the YCP builtin predicate\n     * @param list LIST\n     * @return list Sorted list\n     *\n     * @description\n     * Sorts the list LIST according to the YCP builtin predicate.\n     * Duplicates are not removed.\n     *\n     * @usage sort ([2, 1, true, 1]) -> [true, 1, 1, 2]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPList ret = list;\n    ret->sortlist ();\n    return ret;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret->sortlist",
          "args": [],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "sortlist",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "117-121",
          "snippet": "void\nYCPListRep::sortlist()\n{\n    std::sort(elements.begin(), elements.end(), ycp_less());\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::sortlist()\n  {\n      std::sort(elements.begin(), elements.end(), ycp_less());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list.isNull",
          "args": [],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_sortlist (const YCPList &list)\n{\n    /**\n     * @builtin sort\n     * @id sort-lt\n     * @short Sorts a List according to the YCP builtin predicate\n     * @param list LIST\n     * @return list Sorted list\n     *\n     * @description\n     * Sorts the list LIST according to the YCP builtin predicate.\n     * Duplicates are not removed.\n     *\n     * @usage sort ([2, 1, true, 1]) -> [true, 1, 1, 2]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPList ret = list;\n    ret->sortlist ();\n    return ret;\n}"
  },
  {
    "function_name": "l_toset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "594-617",
    "snippet": "static YCPValue\nl_toset (const YCPList &list)\n{\n    /**\n     * @builtin toset\n     * @short Sorts list and removes duplicates\n     * @param list LIST\n     * @return list Sorted list with unique items\n     * @description\n     * Scans a list for duplicates, removes them and sorts the list.\n     *\n     * @usage toset ([1, 5, 3, 2, 3, true, false, true]) -> [false, true, 1, 2, 3, 5]\n     */\n\n    set<YCPValue, ycp_less> newset(list->begin(), list->end());\n\n    YCPList setlist;\n    for (set <YCPValue, ycp_less>::const_iterator it = newset.begin ();\n\t it != newset.end (); ++it)\n    {\n\tsetlist->add (*it);\n    }\n    return setlist;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setlist->add",
          "args": [
            "*it"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "newset.end",
          "args": [],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "newset.begin",
          "args": [],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_toset (const YCPList &list)\n{\n    /**\n     * @builtin toset\n     * @short Sorts list and removes duplicates\n     * @param list LIST\n     * @return list Sorted list with unique items\n     * @description\n     * Scans a list for duplicates, removes them and sorts the list.\n     *\n     * @usage toset ([1, 5, 3, 2, 3, true, false, true]) -> [false, true, 1, 2, 3, 5]\n     */\n\n    set<YCPValue, ycp_less> newset(list->begin(), list->end());\n\n    YCPList setlist;\n    for (set <YCPValue, ycp_less>::const_iterator it = newset.begin ();\n\t it != newset.end (); ++it)\n    {\n\tsetlist->add (*it);\n    }\n    return setlist;\n}"
  },
  {
    "function_name": "l_flatten",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "551-591",
    "snippet": "static YCPValue\nl_flatten (const YCPList &list)\n{\n    /**\n     * @builtin flatten\n     * @short Flattens List\n     * @param list<list> LIST\n     * @return list\n     *\n     * @description\n     * Gets a list  of lists <tt>LIST</tt> and creates a single list that is\n     * the concatenation of those lists in <tt>LIST</tt>.\n     *\n     * @usage flatten ([ [1, 2], [3, 4] ]) -> [1, 2, 3, 4]\n     * @usage flatten ([ [1, 2], [6, 7], [3, 4] ]) -> [1, 2, 6, 7, 3, 4]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPList ret;\n\n    for (int i = 0; i < list->size (); i++)\n    {\n\tif (!list->value (i)->isList ())\n\t{\n\t    ycp2error(\"%s is not a list. Flatten expects a list of lists\", list->value (i)->toString ().c_str ());\n\t    return YCPNull ();\n\t}\n\n\tYCPList sublist = list->value (i)->asList ();\n\tfor (int j = 0; j < sublist->size (); j++)\n\t{\n\t    ret->add (sublist->value (j));\n\t}\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret->add",
          "args": [
            "sublist->value (j)"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sublist->value",
          "args": [
            "j"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sublist->size",
          "args": [],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->value",
          "args": [],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"%s is not a list. Flatten expects a list of lists\"",
            "list->value (i)->toString ().c_str ()"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list.isNull",
          "args": [],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_flatten (const YCPList &list)\n{\n    /**\n     * @builtin flatten\n     * @short Flattens List\n     * @param list<list> LIST\n     * @return list\n     *\n     * @description\n     * Gets a list  of lists <tt>LIST</tt> and creates a single list that is\n     * the concatenation of those lists in <tt>LIST</tt>.\n     *\n     * @usage flatten ([ [1, 2], [3, 4] ]) -> [1, 2, 3, 4]\n     * @usage flatten ([ [1, 2], [6, 7], [3, 4] ]) -> [1, 2, 6, 7, 3, 4]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPList ret;\n\n    for (int i = 0; i < list->size (); i++)\n    {\n\tif (!list->value (i)->isList ())\n\t{\n\t    ycp2error(\"%s is not a list. Flatten expects a list of lists\", list->value (i)->toString ().c_str ());\n\t    return YCPNull ();\n\t}\n\n\tYCPList sublist = list->value (i)->asList ();\n\tfor (int j = 0; j < sublist->size (); j++)\n\t{\n\t    ret->add (sublist->value (j));\n\t}\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "l_listmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "473-548",
    "snippet": "static YCPValue\nl_listmap (const YCPSymbol &symbol, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin listmap\n     * @short Maps an operation onto all elements of a list and thus creates a map.\n     * @param any VAR\n     * @param list LIST\n     * @param block EXPR\n     * @return map\n     *\n     * @description\n     * For each element <tt>VAR</tt> of the list <tt>LIST</tt> in the expression\n     * <tt>EXPR</tt> is evaluated in a new block. The result is the map of\n     * those evaluations.\n     *\n     * The result of each evaluation <i>must</i> be\n     * a map with a single entry which will be added to the result map.\n     *\n     * @usage listmap (integer k, [1,2,3], { return $[k:\"xy\"]; })  -> $[1:\"xy\", 2:\"xy\"]\n     * @usage listmap (integer k, [1,2,3], { integer a = k+10;  any b = sformat (\"x%1\", k); return $[a:b]; }) -> $[11:\"x1\", 12:\"x2\", 13:\"x3\"]\n     */\n\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    SymbolEntryPtr key = symbol->asEntry()->entry();\n\n    YCPMap ret;\n    YCPList curr_list;\n    YCPMap curr_map;\n\n    for (YCPList::const_iterator it = list->begin(); it != list->end(); ++it)\n    {\n\tkey->setValue(*it);\n\n\tYCPValue curr_value = expr->evaluate ();\n\n\tif (curr_value.isNull ())\n\t{\n\t    ycp2error (\"Bad listmap expression %s\", expr->toString ().c_str ());\n\t    return YCPNull ();\n\t}\n\telse if (curr_value->isBreak())\n\t{\n\t    break;\n\t}\n\telse if (! curr_value ->isMap () )\n\t{\n            ycp2error(\"listmap() expression has to deliver a single entry map! You have produced the following value: %s\",\n                curr_value->toString().c_str());\n\t    return YCPNull ();\n\t}\n        else\n        {\n            curr_map = curr_value->asMap();\n            if ( curr_map->size() == 1 )\n            {\n\t\tYCPMap::const_iterator it = curr_map->begin();\n\t\tret->add(it->first, it->second);\n            }\n            else\n            {\n                ycp2error(\"listmap() expression has to deliver a single entry map! You have produced the following value: %s\",\n                    curr_map->toString().c_str());\n\t        return YCPNull ();\n            }\n        }\n\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"listmap() expression has to deliver a single entry map! You have produced the following value: %s\"",
            "curr_map->toString().c_str()"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curr_map->toString",
          "args": [],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ret->add",
          "args": [
            "it->first",
            "it->second"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "50-76",
          "snippet": "void\nYCPMapRep::add (const YCPValue& key, const YCPValue& value)\n{\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn;\n    }\n\n    // Note: 'stl_map[key] = value' would create a temporary object using the\n    // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n    // 24.\n\n    YCPMap::iterator pos = stl_map.lower_bound(key);\n    if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n    {\n\tpos->second = value;\n    }\n    else\n    {\n\t// pos is just a hint but can avoid a second search through the map\n\tstl_map.insert(pos, YCPMap::value_type(key, value));\n    }\n\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void\n  YCPMapRep::add (const YCPValue& key, const YCPValue& value)\n  {\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn;\n      }\n  \n      // Note: 'stl_map[key] = value' would create a temporary object using the\n      // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n      // 24.\n  \n      YCPMap::iterator pos = stl_map.lower_bound(key);\n      if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n      {\n  \tpos->second = value;\n      }\n      else\n      {\n  \t// pos is just a hint but can avoid a second search through the map\n  \tstl_map.insert(pos, YCPMap::value_type(key, value));\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "curr_map->begin",
          "args": [],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "curr_map->size",
          "args": [],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "curr_value->asMap",
          "args": [],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"listmap() expression has to deliver a single entry map! You have produced the following value: %s\"",
            "curr_value->toString().c_str()"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curr_value ->isMap",
          "args": [],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "71-71",
          "snippet": "bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "curr_value->isBreak",
          "args": [],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "isBreak",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "73-73",
          "snippet": "bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad listmap expression %s\"",
            "expr->toString ().c_str ()"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curr_value.isNull",
          "args": [],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->evaluate",
          "args": [],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key->setValue",
          "args": [
            "*it"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "IniEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "155-155",
          "snippet": "void setValue(const string&c)   { dirty = true; val = c;     }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniEntry {\n  void setValue(const string&c)   { dirty = true; val = c;     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->end",
          "args": [],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "symbol->asEntry",
          "args": [],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "asEntry",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "227-237",
          "snippet": "YCPEntry\nYCPValueRep::asEntry() const\n{\n    if (!isEntry())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPEntry (static_cast<const YCPEntryRep*>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPEntry\n  YCPValueRep::asEntry() const\n  {\n      if (!isEntry())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPEntry (static_cast<const YCPEntryRep*>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list.isNull",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_listmap (const YCPSymbol &symbol, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin listmap\n     * @short Maps an operation onto all elements of a list and thus creates a map.\n     * @param any VAR\n     * @param list LIST\n     * @param block EXPR\n     * @return map\n     *\n     * @description\n     * For each element <tt>VAR</tt> of the list <tt>LIST</tt> in the expression\n     * <tt>EXPR</tt> is evaluated in a new block. The result is the map of\n     * those evaluations.\n     *\n     * The result of each evaluation <i>must</i> be\n     * a map with a single entry which will be added to the result map.\n     *\n     * @usage listmap (integer k, [1,2,3], { return $[k:\"xy\"]; })  -> $[1:\"xy\", 2:\"xy\"]\n     * @usage listmap (integer k, [1,2,3], { integer a = k+10;  any b = sformat (\"x%1\", k); return $[a:b]; }) -> $[11:\"x1\", 12:\"x2\", 13:\"x3\"]\n     */\n\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    SymbolEntryPtr key = symbol->asEntry()->entry();\n\n    YCPMap ret;\n    YCPList curr_list;\n    YCPMap curr_map;\n\n    for (YCPList::const_iterator it = list->begin(); it != list->end(); ++it)\n    {\n\tkey->setValue(*it);\n\n\tYCPValue curr_value = expr->evaluate ();\n\n\tif (curr_value.isNull ())\n\t{\n\t    ycp2error (\"Bad listmap expression %s\", expr->toString ().c_str ());\n\t    return YCPNull ();\n\t}\n\telse if (curr_value->isBreak())\n\t{\n\t    break;\n\t}\n\telse if (! curr_value ->isMap () )\n\t{\n            ycp2error(\"listmap() expression has to deliver a single entry map! You have produced the following value: %s\",\n                curr_value->toString().c_str());\n\t    return YCPNull ();\n\t}\n        else\n        {\n            curr_map = curr_value->asMap();\n            if ( curr_map->size() == 1 )\n            {\n\t\tYCPMap::const_iterator it = curr_map->begin();\n\t\tret->add(it->first, it->second);\n            }\n            else\n            {\n                ycp2error(\"listmap() expression has to deliver a single entry map! You have produced the following value: %s\",\n                    curr_map->toString().c_str());\n\t        return YCPNull ();\n            }\n        }\n\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "l_maplist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "422-470",
    "snippet": "static YCPValue\nl_maplist (const YCPSymbol &symbol, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin maplist\n     * @id maplist-list\n     * @short Maps an operation onto all elements of a list and thus creates a new list.\n     * @param any VAR\n     * @param list<any> LIST\n     * @param block EXPR\n     * @return list<any>\n     *\n     * @description\n     * For each element of the list <tt>LIST</tt> the expression <tt>EXPR</tt>\n     * is evaluated in a new block, where the variable <tt>VAR</tt>\n     * is assigned to that value. The result is the list of those\n     * evaluations.\n     *\n     * @usage maplist (integer v, [1, 2, 3, 5], { return (v + 1); }) -> [2, 3, 4, 6]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPList ret;\n    SymbolEntryPtr s = symbol->asEntry()->entry();\n\n    for (YCPList::const_iterator it = list->begin(); it != list->end(); ++it)\n    {\n\ts->setValue(*it);\n\n\tYCPValue v = expr->evaluate ();\n\n\tif (v.isNull ())\n\t{\n\t    ycp2error (\"Bad maplist expression %s\", expr->toString ().c_str ());\n\t    return YCPNull ();\n\t}\n\tif (v->isBreak())\n\t{\n\t    break;\n\t}\n\tret->add (v);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret->add",
          "args": [
            "v"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->isBreak",
          "args": [],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "isBreak",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "73-73",
          "snippet": "bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad maplist expression %s\"",
            "expr->toString ().c_str ()"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->toString",
          "args": [],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->evaluate",
          "args": [],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s->setValue",
          "args": [
            "*it"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "IniEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "155-155",
          "snippet": "void setValue(const string&c)   { dirty = true; val = c;     }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniEntry {\n  void setValue(const string&c)   { dirty = true; val = c;     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->end",
          "args": [],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->begin",
          "args": [],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "symbol->asEntry",
          "args": [],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "asEntry",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "227-237",
          "snippet": "YCPEntry\nYCPValueRep::asEntry() const\n{\n    if (!isEntry())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPEntry (static_cast<const YCPEntryRep*>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPEntry\n  YCPValueRep::asEntry() const\n  {\n      if (!isEntry())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPEntry (static_cast<const YCPEntryRep*>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list.isNull",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_maplist (const YCPSymbol &symbol, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin maplist\n     * @id maplist-list\n     * @short Maps an operation onto all elements of a list and thus creates a new list.\n     * @param any VAR\n     * @param list<any> LIST\n     * @param block EXPR\n     * @return list<any>\n     *\n     * @description\n     * For each element of the list <tt>LIST</tt> the expression <tt>EXPR</tt>\n     * is evaluated in a new block, where the variable <tt>VAR</tt>\n     * is assigned to that value. The result is the list of those\n     * evaluations.\n     *\n     * @usage maplist (integer v, [1, 2, 3, 5], { return (v + 1); }) -> [2, 3, 4, 6]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPList ret;\n    SymbolEntryPtr s = symbol->asEntry()->entry();\n\n    for (YCPList::const_iterator it = list->begin(); it != list->end(); ++it)\n    {\n\ts->setValue(*it);\n\n\tYCPValue v = expr->evaluate ();\n\n\tif (v.isNull ())\n\t{\n\t    ycp2error (\"Bad maplist expression %s\", expr->toString ().c_str ());\n\t    return YCPNull ();\n\t}\n\tif (v->isBreak())\n\t{\n\t    break;\n\t}\n\tret->add (v);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "l_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "362-419",
    "snippet": "static YCPValue\nl_filter (const YCPSymbol &symbol, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin filter\n     * @id filter-list\n     * @short Filters a List\n     * @param any VAR Variable\n     * @param list LIST List to be filtered\n     * @param block<boolean> EXPR Block\n     * @return list\n     * @description\n     * For each element of the list <tt>LIST</tt> the expression <tt>expr</tt>\n     * is executed in a new block, where the variable <tt>VAR</tt>\n     * is assigned to that value. If the expression evaluates to true under\n     * this circumstances, the value is appended to the result list.\n     *\n     * @usage filter (integer v, [1, 2, 3, 5], { return (v > 2); }) -> [3, 5]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPList ret;\n\n    SymbolEntryPtr s = symbol->asEntry()->entry();\n\n    for (YCPList::const_iterator it = list->begin(); it != list->end(); ++it)\n    {\n\ts->setValue(*it);\n\n\tYCPValue v = expr->evaluate ();\n\n\tif (v.isNull ())\n\t{\n\t    ycp2error (\"Bad filter expression %s\", expr->toString ().c_str ());\n\t    return YCPNull ();\n\t}\n\t// nil == false\n\tif (v->isVoid ())\n\t{\n\t    ycp2error (\"The expression for 'filter' returned 'nil'\");\n\t    continue;\n\t}\n\tif (v->isBreak())\n\t{\n\t    break;\n\t}\n\tif (v->asBoolean ()->value ())\n\t{\n\t    ret->add(*it);\n\t}\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret->add",
          "args": [
            "*it"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->asBoolean",
          "args": [],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "asBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "94-104",
          "snippet": "YCPBoolean\nYCPValueRep::asBoolean() const\n{\n    if (!isBoolean())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPBoolean\n  YCPValueRep::asBoolean() const\n  {\n      if (!isBoolean())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->isBreak",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "isBreak",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "73-73",
          "snippet": "bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"The expression for 'filter' returned 'nil'\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->isVoid",
          "args": [],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad filter expression %s\"",
            "expr->toString ().c_str ()"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->toString",
          "args": [],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->evaluate",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s->setValue",
          "args": [
            "*it"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "IniEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "155-155",
          "snippet": "void setValue(const string&c)   { dirty = true; val = c;     }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniEntry {\n  void setValue(const string&c)   { dirty = true; val = c;     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->end",
          "args": [],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->begin",
          "args": [],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "symbol->asEntry",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "asEntry",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "227-237",
          "snippet": "YCPEntry\nYCPValueRep::asEntry() const\n{\n    if (!isEntry())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPEntry (static_cast<const YCPEntryRep*>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPEntry\n  YCPValueRep::asEntry() const\n  {\n      if (!isEntry())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPEntry (static_cast<const YCPEntryRep*>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list.isNull",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_filter (const YCPSymbol &symbol, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin filter\n     * @id filter-list\n     * @short Filters a List\n     * @param any VAR Variable\n     * @param list LIST List to be filtered\n     * @param block<boolean> EXPR Block\n     * @return list\n     * @description\n     * For each element of the list <tt>LIST</tt> the expression <tt>expr</tt>\n     * is executed in a new block, where the variable <tt>VAR</tt>\n     * is assigned to that value. If the expression evaluates to true under\n     * this circumstances, the value is appended to the result list.\n     *\n     * @usage filter (integer v, [1, 2, 3, 5], { return (v > 2); }) -> [3, 5]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPList ret;\n\n    SymbolEntryPtr s = symbol->asEntry()->entry();\n\n    for (YCPList::const_iterator it = list->begin(); it != list->end(); ++it)\n    {\n\ts->setValue(*it);\n\n\tYCPValue v = expr->evaluate ();\n\n\tif (v.isNull ())\n\t{\n\t    ycp2error (\"Bad filter expression %s\", expr->toString ().c_str ());\n\t    return YCPNull ();\n\t}\n\t// nil == false\n\tif (v->isVoid ())\n\t{\n\t    ycp2error (\"The expression for 'filter' returned 'nil'\");\n\t    continue;\n\t}\n\tif (v->isBreak())\n\t{\n\t    break;\n\t}\n\tif (v->asBoolean ()->value ())\n\t{\n\t    ret->add(*it);\n\t}\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "l_sublist2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "311-359",
    "snippet": "static YCPValue\nl_sublist2(const YCPList &list, const YCPInteger &offset, const YCPInteger &length)\n{\n    /**\n     * @builtin sublist\n     * @id sublist-length\n     * @short Extracts a sublist\n     *\n     * @description\n     * Extracts a sublist of the list <tt>LIST</tt> starting at\n     * <tt>OFFSET</tt> with length <tt>LENGTH</tt>. The <tt>OFFSET</tt>\n     * starts with 0.\n     *\n     * @param list LIST\n     * @param integer OFFSET\n     * @param integer LENGTH\n     * @return list\n     *\n     * @usage sublist ([ \"a\", \"b\", \"c\"], 0, 2) -> [ \"a\", \"b\" ]\n     * @usage sublist ([ \"a\", \"b\", \"c\"], 1, 1) -> [ \"b\" ]\n     */\n\n    if (list.isNull () || offset.isNull() || length.isNull ())\n\treturn YCPNull ();\n\n    int i1 = offset->value();\n    int i2 = i1 + length->value();\n\n    if (i1 < 0 || i1 >= list->size ())\n    {\n\tycp2error (\"Offset %s for sublist () out of range\", toString (i1).c_str ());\n\treturn YCPNull ();\n    }\n\n    if (i2 < i1 || i2 > list->size ())\n    {\n\tycp2error (\"Length %s for sublist () out of range\", toString (i2).c_str ());\n\treturn YCPNull ();\n    }\n\n    YCPList newlist;\n\n    for (int i = i1; i < i2; i++)\n    {\n\tnewlist->add (list->value(i));\n    }\n\n    return newlist;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "newlist->add",
          "args": [
            "list->value(i)"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->value",
          "args": [
            "i"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Length %s for sublist () out of range\"",
            "toString (i2).c_str ()"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [
            "i2"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "158-232",
          "snippet": "string \nYSymbolEntry::toString (bool with_type) const\n{\n    string s = (with_type && m_global) ? \"global \" : \"\";\n#if DO_DEBUG\n    y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n    y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n#endif\n    switch (m_category)\n    {\n\tcase c_variable:\n\tcase c_reference:\n\tcase c_function:\n#if DO_DEBUG\n\t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n#endif\n\tcase c_builtin:\n\t{\n\t    if (with_type)\n\t    {\n\t\tconstFunctionTypePtr ftype = m_type;\n\t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n\t\tif (m_global\n\t\t    && m_namespace != 0\n\t\t    && !m_namespace->name().empty())\n\t\t{\n\t\t    s += (m_namespace->name() + \"::\");\n\t\t}\n\t\ts += m_name.asString();\n\t\tif ((m_category == c_builtin)\n\t\t    && (m_payload.m_decl != 0))\n\t\t{\n\t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n\t\t}\n\t\telse if ((m_category == c_function)\n\t\t\t && (m_code != 0))\n\t\t{\n\t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n\t\t}\n\t\treturn s;\n\t    }\n\t    else\n\t    {\n\t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n\t\treturn s;\n\t    }\n\t}\n\tbreak;\n\tcase c_typedef:\n\t{\n\t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n\t}\n\tbreak;\n\tcase c_const:\n\t{\n\t    return s + m_type->toString() + \" \" + m_name.asString();\n\t}\n\tbreak;\n\tcase c_namespace:\n\tcase c_self:\n\tcase c_filename:\n\tcase c_predefined:\n\t{\n\t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    return SymbolEntry::toString (with_type);\n\t}\n\tbreak;\n    }\n\n    return \"?SymbolEntry?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\n#define DO_DEBUG 0\n\nYSymbolEntry {\n  string \n  YSymbolEntry::toString (bool with_type) const\n  {\n      string s = (with_type && m_global) ? \"global \" : \"\";\n  #if DO_DEBUG\n      y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n      y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n  #endif\n      switch (m_category)\n      {\n  \tcase c_variable:\n  \tcase c_reference:\n  \tcase c_function:\n  #if DO_DEBUG\n  \t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n  #endif\n  \tcase c_builtin:\n  \t{\n  \t    if (with_type)\n  \t    {\n  \t\tconstFunctionTypePtr ftype = m_type;\n  \t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n  \t\tif (m_global\n  \t\t    && m_namespace != 0\n  \t\t    && !m_namespace->name().empty())\n  \t\t{\n  \t\t    s += (m_namespace->name() + \"::\");\n  \t\t}\n  \t\ts += m_name.asString();\n  \t\tif ((m_category == c_builtin)\n  \t\t    && (m_payload.m_decl != 0))\n  \t\t{\n  \t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n  \t\t}\n  \t\telse if ((m_category == c_function)\n  \t\t\t && (m_code != 0))\n  \t\t{\n  \t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n  \t\t}\n  \t\treturn s;\n  \t    }\n  \t    else\n  \t    {\n  \t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n  \t\treturn s;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase c_typedef:\n  \t{\n  \t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n  \t}\n  \tbreak;\n  \tcase c_const:\n  \t{\n  \t    return s + m_type->toString() + \" \" + m_name.asString();\n  \t}\n  \tbreak;\n  \tcase c_namespace:\n  \tcase c_self:\n  \tcase c_filename:\n  \tcase c_predefined:\n  \t{\n  \t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    return SymbolEntry::toString (with_type);\n  \t}\n  \tbreak;\n      }\n  \n      return \"?SymbolEntry?\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->size",
          "args": [],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Offset %s for sublist () out of range\"",
            "toString (i1).c_str ()"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "length->value",
          "args": [],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "length.isNull",
          "args": [],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset.isNull",
          "args": [],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list.isNull",
          "args": [],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_sublist2(const YCPList &list, const YCPInteger &offset, const YCPInteger &length)\n{\n    /**\n     * @builtin sublist\n     * @id sublist-length\n     * @short Extracts a sublist\n     *\n     * @description\n     * Extracts a sublist of the list <tt>LIST</tt> starting at\n     * <tt>OFFSET</tt> with length <tt>LENGTH</tt>. The <tt>OFFSET</tt>\n     * starts with 0.\n     *\n     * @param list LIST\n     * @param integer OFFSET\n     * @param integer LENGTH\n     * @return list\n     *\n     * @usage sublist ([ \"a\", \"b\", \"c\"], 0, 2) -> [ \"a\", \"b\" ]\n     * @usage sublist ([ \"a\", \"b\", \"c\"], 1, 1) -> [ \"b\" ]\n     */\n\n    if (list.isNull () || offset.isNull() || length.isNull ())\n\treturn YCPNull ();\n\n    int i1 = offset->value();\n    int i2 = i1 + length->value();\n\n    if (i1 < 0 || i1 >= list->size ())\n    {\n\tycp2error (\"Offset %s for sublist () out of range\", toString (i1).c_str ());\n\treturn YCPNull ();\n    }\n\n    if (i2 < i1 || i2 > list->size ())\n    {\n\tycp2error (\"Length %s for sublist () out of range\", toString (i2).c_str ());\n\treturn YCPNull ();\n    }\n\n    YCPList newlist;\n\n    for (int i = i1; i < i2; i++)\n    {\n\tnewlist->add (list->value(i));\n    }\n\n    return newlist;\n}"
  },
  {
    "function_name": "l_sublist1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "268-308",
    "snippet": "static YCPValue\nl_sublist1(const YCPList &list, const YCPInteger &offset)\n{\n   /**\n     * @builtin sublist\n     * @id sublist-rest\n     * @short Extracts a sublist\n     *\n     * @description\n     * Extracts a sublist of the list <tt>LIST</tt> starting at\n     * <tt>OFFSET</tt>. The <tt>OFFSET</tt> starts with 0.\n     *\n     * @param list LIST\n     * @param integer OFFSET\n     * @return list\n     *\n     * @usage sublist ([ \"a\", \"b\", \"c\"], 0) -> [ \"a\", \"b\", \"c\" ]\n     * @usage sublist ([ \"a\", \"b\", \"c\"], 2) -> [ \"c\" ]\n     */\n\n    if (list.isNull () || offset.isNull())\n\treturn YCPNull ();\n\n    int i1 = offset->value();\n    int i2 = list->size();\n\n    if (i1 < 0 || i1 >= list->size ())\n    {\n\tycp2error (\"Offset %s for sublist () out of range\", toString (i1).c_str ());\n\treturn YCPNull ();\n    }\n\n    YCPList newlist;\n\n    for (int i = i1; i < i2; i++)\n    {\n\tnewlist->add (list->value(i));\n    }\n\n    return newlist;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "newlist->add",
          "args": [
            "list->value(i)"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->value",
          "args": [
            "i"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Offset %s for sublist () out of range\"",
            "toString (i1).c_str ()"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [
            "i1"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "158-232",
          "snippet": "string \nYSymbolEntry::toString (bool with_type) const\n{\n    string s = (with_type && m_global) ? \"global \" : \"\";\n#if DO_DEBUG\n    y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n    y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n#endif\n    switch (m_category)\n    {\n\tcase c_variable:\n\tcase c_reference:\n\tcase c_function:\n#if DO_DEBUG\n\t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n#endif\n\tcase c_builtin:\n\t{\n\t    if (with_type)\n\t    {\n\t\tconstFunctionTypePtr ftype = m_type;\n\t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n\t\tif (m_global\n\t\t    && m_namespace != 0\n\t\t    && !m_namespace->name().empty())\n\t\t{\n\t\t    s += (m_namespace->name() + \"::\");\n\t\t}\n\t\ts += m_name.asString();\n\t\tif ((m_category == c_builtin)\n\t\t    && (m_payload.m_decl != 0))\n\t\t{\n\t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n\t\t}\n\t\telse if ((m_category == c_function)\n\t\t\t && (m_code != 0))\n\t\t{\n\t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n\t\t}\n\t\treturn s;\n\t    }\n\t    else\n\t    {\n\t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n\t\treturn s;\n\t    }\n\t}\n\tbreak;\n\tcase c_typedef:\n\t{\n\t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n\t}\n\tbreak;\n\tcase c_const:\n\t{\n\t    return s + m_type->toString() + \" \" + m_name.asString();\n\t}\n\tbreak;\n\tcase c_namespace:\n\tcase c_self:\n\tcase c_filename:\n\tcase c_predefined:\n\t{\n\t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    return SymbolEntry::toString (with_type);\n\t}\n\tbreak;\n    }\n\n    return \"?SymbolEntry?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\n#define DO_DEBUG 0\n\nYSymbolEntry {\n  string \n  YSymbolEntry::toString (bool with_type) const\n  {\n      string s = (with_type && m_global) ? \"global \" : \"\";\n  #if DO_DEBUG\n      y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n      y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n  #endif\n      switch (m_category)\n      {\n  \tcase c_variable:\n  \tcase c_reference:\n  \tcase c_function:\n  #if DO_DEBUG\n  \t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n  #endif\n  \tcase c_builtin:\n  \t{\n  \t    if (with_type)\n  \t    {\n  \t\tconstFunctionTypePtr ftype = m_type;\n  \t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n  \t\tif (m_global\n  \t\t    && m_namespace != 0\n  \t\t    && !m_namespace->name().empty())\n  \t\t{\n  \t\t    s += (m_namespace->name() + \"::\");\n  \t\t}\n  \t\ts += m_name.asString();\n  \t\tif ((m_category == c_builtin)\n  \t\t    && (m_payload.m_decl != 0))\n  \t\t{\n  \t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n  \t\t}\n  \t\telse if ((m_category == c_function)\n  \t\t\t && (m_code != 0))\n  \t\t{\n  \t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n  \t\t}\n  \t\treturn s;\n  \t    }\n  \t    else\n  \t    {\n  \t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n  \t\treturn s;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase c_typedef:\n  \t{\n  \t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n  \t}\n  \tbreak;\n  \tcase c_const:\n  \t{\n  \t    return s + m_type->toString() + \" \" + m_name.asString();\n  \t}\n  \tbreak;\n  \tcase c_namespace:\n  \tcase c_self:\n  \tcase c_filename:\n  \tcase c_predefined:\n  \t{\n  \t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    return SymbolEntry::toString (with_type);\n  \t}\n  \tbreak;\n      }\n  \n      return \"?SymbolEntry?\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->size",
          "args": [],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset->value",
          "args": [],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset.isNull",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list.isNull",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_sublist1(const YCPList &list, const YCPInteger &offset)\n{\n   /**\n     * @builtin sublist\n     * @id sublist-rest\n     * @short Extracts a sublist\n     *\n     * @description\n     * Extracts a sublist of the list <tt>LIST</tt> starting at\n     * <tt>OFFSET</tt>. The <tt>OFFSET</tt> starts with 0.\n     *\n     * @param list LIST\n     * @param integer OFFSET\n     * @return list\n     *\n     * @usage sublist ([ \"a\", \"b\", \"c\"], 0) -> [ \"a\", \"b\", \"c\" ]\n     * @usage sublist ([ \"a\", \"b\", \"c\"], 2) -> [ \"c\" ]\n     */\n\n    if (list.isNull () || offset.isNull())\n\treturn YCPNull ();\n\n    int i1 = offset->value();\n    int i2 = list->size();\n\n    if (i1 < 0 || i1 >= list->size ())\n    {\n\tycp2error (\"Offset %s for sublist () out of range\", toString (i1).c_str ());\n\treturn YCPNull ();\n    }\n\n    YCPList newlist;\n\n    for (int i = i1; i < i2; i++)\n    {\n\tnewlist->add (list->value(i));\n    }\n\n    return newlist;\n}"
  },
  {
    "function_name": "l_mergelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "225-265",
    "snippet": "static YCPValue\nl_mergelist (const YCPList &list1, const YCPList &list2)\n{\n    /**\n     * @builtin merge\n     * @short Merges two lists into one\n     * @param list LIST1 First List\n     * @param list LIST2 Second List\n     * @return list\n     *\n     * @description\n     * Interprets two lists as sets and returns a new list that has\n     * all elements of the first list and all of the second list. Identical\n     * elements are preserved. The order of the elements in the new list is\n     * preserved. Elements of <tt>l1</tt> are prior to elements from <tt>l2</tt>.\n     * <tt>nil</tt> as either argument makes the result <tt>nil</tt> too.\n     *\n     * @see union\n     * @usage merge ([1, 2], [3, 4]) -> [1, 2, 3, 4]\n     * @usage merge ([1, 2, 3], [2, 3, 4]) -> [1, 2, 3, 2, 3, 4]\n     */\n\n    if (list1.isNull () || list2.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPList newlist;\n\n    for (int l = 0; l < 2; l++)\n    {\n\tYCPList list = (l == 0 ? list1 : list2);\n\n\tfor (int e = 0; e < list->size (); e++)\n\t{\n\t    newlist->add (list->value (e));\n\t}\n    }\n\n    return newlist;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "newlist->add",
          "args": [
            "list->value (e)"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->value",
          "args": [
            "e"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->size",
          "args": [],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list2.isNull",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list1.isNull",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_mergelist (const YCPList &list1, const YCPList &list2)\n{\n    /**\n     * @builtin merge\n     * @short Merges two lists into one\n     * @param list LIST1 First List\n     * @param list LIST2 Second List\n     * @return list\n     *\n     * @description\n     * Interprets two lists as sets and returns a new list that has\n     * all elements of the first list and all of the second list. Identical\n     * elements are preserved. The order of the elements in the new list is\n     * preserved. Elements of <tt>l1</tt> are prior to elements from <tt>l2</tt>.\n     * <tt>nil</tt> as either argument makes the result <tt>nil</tt> too.\n     *\n     * @see union\n     * @usage merge ([1, 2], [3, 4]) -> [1, 2, 3, 4]\n     * @usage merge ([1, 2, 3], [2, 3, 4]) -> [1, 2, 3, 2, 3, 4]\n     */\n\n    if (list1.isNull () || list2.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPList newlist;\n\n    for (int l = 0; l < 2; l++)\n    {\n\tYCPList list = (l == 0 ? list1 : list2);\n\n\tfor (int e = 0; e < list->size (); e++)\n\t{\n\t    newlist->add (list->value (e));\n\t}\n    }\n\n    return newlist;\n}"
  },
  {
    "function_name": "l_unionlist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "172-222",
    "snippet": "static YCPValue\nl_unionlist (const YCPList &list1, const YCPList &list2)\n{\n    /**\n     * @builtin union\n     * @id union-list\n     * @short Unions of lists\n     * @param list LIST1 First List\n     * @param list LIST2 Second List\n     * @return list\n     *\n     * @description\n     * Interprets two lists as sets and returns a new list that has\n     * all elements of the first list and all of the second list. Identical\n     * elements are merged. The order of the elements in the new list is\n     * preserved. Elements of <tt>l1</tt> are prior to elements from <tt>l2</tt>.\n     * <tt>nil</tt> as either argument makes the result <tt>nil</tt> too.\n     *\n     * WARNING: quadratic complexity so far\n     *\n     * @see merge\n     * @usage union ([1, 2], [3, 4]) -> [1, 2, 3, 4]\n     * @usage union ([1, 2, 3], [2, 3, 4]) -> [1, 2, 3, 4]\n     * @usage union ([1, 3, 5], [1, 2, 4, 6]) -> [1, 3, 5, 2, 4, 6]\n     */\n\n    if (list1.isNull () || list2.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPList newlist;\n\n    for (int l = 0; l < 2; l++)\n    {\n\tYCPList list = (l == 0 ? list1 : list2);\n\n\tfor (int e = 0; e < list->size (); e++)\n\t{\n\t    YCPValue to_insert = list->value (e);\n\n\t    // Already contained? I know, this has an _awful_ complexity.\n\t    // We need to introduce an order on YCPValueRep to solve the problem.\n\n\t    if (!newlist->contains(to_insert))\n\t\tnewlist->add (to_insert);\n\t}\n    }\n\n    return newlist;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "newlist->add",
          "args": [
            "to_insert"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "newlist->contains",
          "args": [
            "to_insert"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "contains",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "111-114",
          "snippet": "bool YCPListRep::contains (const YCPValue& value) const\n{\n    return find_if(begin(), end(), bind2nd(ycp_equal_to(), value)) != end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  bool YCPListRep::contains (const YCPValue& value) const\n  {\n      return find_if(begin(), end(), bind2nd(ycp_equal_to(), value)) != end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->value",
          "args": [
            "e"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->size",
          "args": [],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list2.isNull",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list1.isNull",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_unionlist (const YCPList &list1, const YCPList &list2)\n{\n    /**\n     * @builtin union\n     * @id union-list\n     * @short Unions of lists\n     * @param list LIST1 First List\n     * @param list LIST2 Second List\n     * @return list\n     *\n     * @description\n     * Interprets two lists as sets and returns a new list that has\n     * all elements of the first list and all of the second list. Identical\n     * elements are merged. The order of the elements in the new list is\n     * preserved. Elements of <tt>l1</tt> are prior to elements from <tt>l2</tt>.\n     * <tt>nil</tt> as either argument makes the result <tt>nil</tt> too.\n     *\n     * WARNING: quadratic complexity so far\n     *\n     * @see merge\n     * @usage union ([1, 2], [3, 4]) -> [1, 2, 3, 4]\n     * @usage union ([1, 2, 3], [2, 3, 4]) -> [1, 2, 3, 4]\n     * @usage union ([1, 3, 5], [1, 2, 4, 6]) -> [1, 3, 5, 2, 4, 6]\n     */\n\n    if (list1.isNull () || list2.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPList newlist;\n\n    for (int l = 0; l < 2; l++)\n    {\n\tYCPList list = (l == 0 ? list1 : list2);\n\n\tfor (int e = 0; e < list->size (); e++)\n\t{\n\t    YCPValue to_insert = list->value (e);\n\n\t    // Already contained? I know, this has an _awful_ complexity.\n\t    // We need to introduce an order on YCPValueRep to solve the problem.\n\n\t    if (!newlist->contains(to_insert))\n\t\tnewlist->add (to_insert);\n\t}\n    }\n\n    return newlist;\n}"
  },
  {
    "function_name": "l_setcontains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "150-169",
    "snippet": "static YCPValue\nl_setcontains (const YCPList &list, const YCPValue &value)\n{\n    /**\n     * @builtin setcontains\n     * @short Checks if a sorted list contains an element\n     *\n     * @param list LIST List\n     * @param any ELEMENT Element\n     * @return boolean True if element is in the list.\n     * @description\n     * Determines, if a certain value <tt>ELEMENT</tt> is contained in\n     * a list <tt>LIST</tt>, but assumes that <tt>LIST</tt> is sorted. If <tt>LIST</tt> is\n     * not sorted, the result is undefined.\n     *\n     * @usage setcontains ([1, 2, 5], 2) -> true\n     */\n\n    return YCPBoolean(binary_search(list->begin(), list->end(), value, ycp_less()));\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "binary_search(list->begin(), list->end(), value, ycp_less())"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "binary_search",
          "args": [
            "list->begin()",
            "list->end()",
            "value",
            "ycp_less()"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp_less",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "ycp_less",
          "container": "ycp_less",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/ycpless.h",
          "lines": "40-40",
          "snippet": "ycp_less(bool respect_locale = false) : respect_locale(respect_locale) {}",
          "includes": [
            "#include \"YCPValue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"YCPValue.h\"\n\nycp_less {\n  ycp_less(bool respect_locale = false) : respect_locale(respect_locale) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->end",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->begin",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_setcontains (const YCPList &list, const YCPValue &value)\n{\n    /**\n     * @builtin setcontains\n     * @short Checks if a sorted list contains an element\n     *\n     * @param list LIST List\n     * @param any ELEMENT Element\n     * @return boolean True if element is in the list.\n     * @description\n     * Determines, if a certain value <tt>ELEMENT</tt> is contained in\n     * a list <tt>LIST</tt>, but assumes that <tt>LIST</tt> is sorted. If <tt>LIST</tt> is\n     * not sorted, the result is undefined.\n     *\n     * @usage setcontains ([1, 2, 5], 2) -> true\n     */\n\n    return YCPBoolean(binary_search(list->begin(), list->end(), value, ycp_less()));\n}"
  },
  {
    "function_name": "l_contains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "129-147",
    "snippet": "static YCPValue\nl_contains (const YCPList &list, const YCPValue &value)\n{\n    /**\n     * @builtin contains\n     * @short Checks if a list contains an element\n     * @param list LIST List\n     * @param any ELEMENT Element\n     * @return boolean True if element is in the list.\n     * @description\n     *\n     * Determines, if a certain value <tt>ELEMENT</tt> is contained in\n     * a list <tt>LIST</tt>.\n     *\n     * @usage contains ([1, 2, 5], 2) -> true\n     */\n\n    return YCPBoolean(list->contains(value));\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "list->contains(value)"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->contains",
          "args": [
            "value"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "contains",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "111-114",
          "snippet": "bool YCPListRep::contains (const YCPValue& value) const\n{\n    return find_if(begin(), end(), bind2nd(ycp_equal_to(), value)) != end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  bool YCPListRep::contains (const YCPValue& value) const\n  {\n      return find_if(begin(), end(), bind2nd(ycp_equal_to(), value)) != end();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_contains (const YCPList &list, const YCPValue &value)\n{\n    /**\n     * @builtin contains\n     * @short Checks if a list contains an element\n     * @param list LIST List\n     * @param any ELEMENT Element\n     * @return boolean True if element is in the list.\n     * @description\n     *\n     * Determines, if a certain value <tt>ELEMENT</tt> is contained in\n     * a list <tt>LIST</tt>.\n     *\n     * @usage contains ([1, 2, 5], 2) -> true\n     */\n\n    return YCPBoolean(list->contains(value));\n}"
  },
  {
    "function_name": "l_prepend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "104-126",
    "snippet": "static YCPValue\nl_prepend (const YCPList &list, const YCPValue &value)\n{\n    /**\n     * @builtin prepend\n     * @short Prepends a list with a new element\n     * @param list LIST List\n     * @param any ELEMENT Element to prepend\n     * @return list\n     * @description\n     * Creates a new list that is identical to the list <tt>LIST</tt> but has\n     * the value <tt>ELEMENT</tt> prepended as additional element.\n     *\n     * @usage prepend ([1, 4], 8) -> [8, 1, 4]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    return list->functionalAdd (value, true);\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list->functionalAdd",
          "args": [
            "value",
            "true"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "functionalAdd",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "79-101",
          "snippet": "YCPMap\nYCPMapRep::functionalAdd (const YCPValue& key, const YCPValue& value) const\n{\n    y2debug (\"YCPMapRep::functionalAdd ('%s', '%s', '%s')\", key->toString().c_str(), value->toString().c_str(), this->toString().c_str());\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn YCPNull ();\n    }\n\n    YCPMap newmap;\n\n    for (YCPMap::const_iterator pos = begin(); pos != end(); ++pos)\n    {\n\tnewmap->add(pos->first, pos->second);\n    }\n\n    newmap->add( key, value );\n\n    return newmap;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMap\n  YCPMapRep::functionalAdd (const YCPValue& key, const YCPValue& value) const\n  {\n      y2debug (\"YCPMapRep::functionalAdd ('%s', '%s', '%s')\", key->toString().c_str(), value->toString().c_str(), this->toString().c_str());\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn YCPNull ();\n      }\n  \n      YCPMap newmap;\n  \n      for (YCPMap::const_iterator pos = begin(); pos != end(); ++pos)\n      {\n  \tnewmap->add(pos->first, pos->second);\n      }\n  \n      newmap->add( key, value );\n  \n      return newmap;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list.isNull",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_prepend (const YCPList &list, const YCPValue &value)\n{\n    /**\n     * @builtin prepend\n     * @short Prepends a list with a new element\n     * @param list LIST List\n     * @param any ELEMENT Element to prepend\n     * @return list\n     * @description\n     * Creates a new list that is identical to the list <tt>LIST</tt> but has\n     * the value <tt>ELEMENT</tt> prepended as additional element.\n     *\n     * @usage prepend ([1, 4], 8) -> [8, 1, 4]\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    return list->functionalAdd (value, true);\n}"
  },
  {
    "function_name": "l_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinList.cc",
    "lines": "45-101",
    "snippet": "static YCPValue\nl_find (const YCPSymbol &symbol, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin find\n     * @id find-list\n     * @short Searches for the first occurence of a certain element in a list\n     * @param any VAR\n     * @param list LIST\n     * @param block EXPR\n     *\n     * @description\n     * Searches for a certain item in the list. It applies the expression\n     * <tt>EXPR</tt> to each element in the list and returns the first element\n     * the makes the expression evaluate to true, if <tt>VAR</tt> is bound to\n     * that element.\n     *\n     * @return any Returns nil, if nothing is found.\n     * @usage find (integer n, [3,5,6,4], ``(n >= 5)) -> 5\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPValue ret = YCPNull ();\n\n    SymbolEntryPtr s = symbol->asEntry()->entry();\n\n    for (YCPList::const_iterator it = list->begin(); it != list->end(); ++it)\n    {\n\ts->setValue(*it);\n\n\tYCPValue v = expr->evaluate ();\n\n\tif (v.isNull ())\n\t{\n\t    ycp2error (\"Bad find expression %s\", expr->toString ().c_str ());\n\t    break;\n\t}\n\t// nil == false\n\tif (v->isVoid ())\n\t{\n\t    ycp2error (\"The expression for 'find' returned 'nil'\");\n\t    continue;\n\t}\n\n\tif (v->asBoolean ()->value ())\n\t{\n\t    ret = *it;\n\t    break;\n\t}\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCodeCompare.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPBuiltinList.h\"",
      "#include <algorithm>\t\t// sort",
      "#include <set>\t\t\t// for toset"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v->asBoolean",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "asBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "94-104",
          "snippet": "YCPBoolean\nYCPValueRep::asBoolean() const\n{\n    if (!isBoolean())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPBoolean\n  YCPValueRep::asBoolean() const\n  {\n      if (!isBoolean())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"The expression for 'find' returned 'nil'\""
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->isVoid",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad find expression %s\"",
            "expr->toString ().c_str ()"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->toString",
          "args": [],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->evaluate",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s->setValue",
          "args": [
            "*it"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "IniEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "155-155",
          "snippet": "void setValue(const string&c)   { dirty = true; val = c;     }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniEntry {\n  void setValue(const string&c)   { dirty = true; val = c;     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->end",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->begin",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "symbol->asEntry",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "asEntry",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "227-237",
          "snippet": "YCPEntry\nYCPValueRep::asEntry() const\n{\n    if (!isEntry())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPEntry (static_cast<const YCPEntryRep*>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPEntry\n  YCPValueRep::asEntry() const\n  {\n      if (!isEntry())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPEntry (static_cast<const YCPEntryRep*>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list.isNull",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPBuiltinList.h\"\n#include <algorithm>\t\t// sort\n#include <set>\t\t\t// for toset\n\nstatic YCPValue\nl_find (const YCPSymbol &symbol, const YCPList &list, const YCPCode &expr)\n{\n    /**\n     * @builtin find\n     * @id find-list\n     * @short Searches for the first occurence of a certain element in a list\n     * @param any VAR\n     * @param list LIST\n     * @param block EXPR\n     *\n     * @description\n     * Searches for a certain item in the list. It applies the expression\n     * <tt>EXPR</tt> to each element in the list and returns the first element\n     * the makes the expression evaluate to true, if <tt>VAR</tt> is bound to\n     * that element.\n     *\n     * @return any Returns nil, if nothing is found.\n     * @usage find (integer n, [3,5,6,4], ``(n >= 5)) -> 5\n     */\n\n    if (list.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    YCPValue ret = YCPNull ();\n\n    SymbolEntryPtr s = symbol->asEntry()->entry();\n\n    for (YCPList::const_iterator it = list->begin(); it != list->end(); ++it)\n    {\n\ts->setValue(*it);\n\n\tYCPValue v = expr->evaluate ();\n\n\tif (v.isNull ())\n\t{\n\t    ycp2error (\"Bad find expression %s\", expr->toString ().c_str ());\n\t    break;\n\t}\n\t// nil == false\n\tif (v->isVoid ())\n\t{\n\t    ycp2error (\"The expression for 'find' returned 'nil'\");\n\t    continue;\n\t}\n\n\tif (v->asBoolean ()->value ())\n\t{\n\t    ret = *it;\n\t    break;\n\t}\n    }\n\n    return ret;\n}"
  }
]