[
  {
    "function_name": "changeCase",
    "container": "IniParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "1098-1120",
    "snippet": "string IniParser::changeCase (const string&str) const\n{\n    string tmp = str;\n    if (!ignore_case)\n      return tmp;\n    if (prefer_uppercase)\n    {\n\tfor (string::iterator it = tmp.begin(); it != tmp.end(); ++it)\n\t    *it = toupper (*it);\n    }\n    else\n    {\n\tfor (string::iterator it = tmp.begin(); it != tmp.end(); ++it)\n\t    *it = tolower (*it);\n\tif (first_upper)\n\t{\n\tstring::iterator it = tmp.begin ();\n\tif (it != tmp.end ())\n\t    *it = toupper (*it);\n\t}\t    \n    }\n    return tmp;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "*it"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmp.end",
          "args": [],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmp.begin",
          "args": [],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "*it"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "s_tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinString.cc",
          "lines": "540-564",
          "snippet": "static YCPValue\ns_tolower (const YCPString &s)\n{\n    /**\n     * @builtin tolower\n     * @short Makes a string lowercase\n     * @param string s String\n     * @return string String in lower case\n     *\n     * @description\n     * Returns string with all alphabetic characters converted to lowercase.\n     * Notice: national characters are left unchanged.\n     *\n     * @usage tolower (\"aBcDeF\") -> \"abcdef\"\n     * @usage tolower (\"ABCÁÄÖČ\") -> \"abcÁÄÖČ\"\n     */\n\n    if (s.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    for (unsigned i = 0; i < ss.size (); i++)\n\tss[i] = tolower (ss[i]);\n    return YCPString (ss);\n}\n\n\nstati",
          "includes": [
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"y2crypt.h\"",
            "#include \"y2string.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPBuiltinString.h\"",
            "#include <string>",
            "#include <libintl.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/StaticDeclaration.h\"\n#include \"y2crypt.h\"\n#include \"y2string.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPBuiltinString.h\"\n#include <string>\n#include <libintl.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nstatic YCPValue\ns_tolower (const YCPString &s)\n{\n    /**\n     * @builtin tolower\n     * @short Makes a string lowercase\n     * @param string s String\n     * @return string String in lower case\n     *\n     * @description\n     * Returns string with all alphabetic characters converted to lowercase.\n     * Notice: national characters are left unchanged.\n     *\n     * @usage tolower (\"aBcDeF\") -> \"abcdef\"\n     * @usage tolower (\"ABCÁÄÖČ\") -> \"abcÁÄÖČ\"\n     */\n\n    if (s.isNull ())\n\treturn YCPNull ();\n\n    string ss = s->value ();\n    for (unsigned i = 0; i < ss.size (); i++)\n\tss[i] = tolower (ss[i]);\n    return YCPString (ss);\n}\n\n\nstati"
        }
      },
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "*it"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  string IniParser::changeCase (const string&str) const\n  {\n      string tmp = str;\n      if (!ignore_case)\n        return tmp;\n      if (prefer_uppercase)\n      {\n  \tfor (string::iterator it = tmp.begin(); it != tmp.end(); ++it)\n  \t    *it = toupper (*it);\n      }\n      else\n      {\n  \tfor (string::iterator it = tmp.begin(); it != tmp.end(); ++it)\n  \t    *it = tolower (*it);\n  \tif (first_upper)\n  \t{\n  \tstring::iterator it = tmp.begin ();\n  \tif (it != tmp.end ())\n  \t    *it = toupper (*it);\n  \t}\t    \n      }\n      return tmp;\n  }\n}"
  },
  {
    "function_name": "getFileName",
    "container": "IniParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "1078-1091",
    "snippet": "string IniParser::getFileName (const string&sec, int rb) const\n{\n    string file = sec;\n    if (-1 != rb && (int) rewrites.size () > rb)\n    {\n\tint max = rewrites[rb].out.length () + sec.length () + 1;\n\tchar*buf = new char[max + 1];\n\tsnprintf (buf, max, rewrites[rb].out.c_str (), sec.c_str());\n\ty2debug (\"Rewriting %s to %s\", sec.c_str(), buf);\n\tfile = buf;\n\tdelete [] buf;\n    }\n    return file;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Rewriting %s to %s\"",
            "sec.c_str()",
            "buf"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sec.c_str",
          "args": [],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "max",
            "rewrites[rb].out.c_str ()",
            "sec.c_str()"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sec.c_str",
          "args": [],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rewrites[rb].out.c_str",
          "args": [],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sec.length",
          "args": [],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rewrites.size",
          "args": [],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  string IniParser::getFileName (const string&sec, int rb) const\n  {\n      string file = sec;\n      if (-1 != rb && (int) rewrites.size () > rb)\n      {\n  \tint max = rewrites[rb].out.length () + sec.length () + 1;\n  \tchar*buf = new char[max + 1];\n  \tsnprintf (buf, max, rewrites[rb].out.c_str (), sec.c_str());\n  \ty2debug (\"Rewriting %s to %s\", sec.c_str(), buf);\n  \tfile = buf;\n  \tdelete [] buf;\n      }\n      return file;\n  }\n}"
  },
  {
    "function_name": "write_helper",
    "container": "IniParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "1018-1077",
    "snippet": "int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n{\n    char * out_buffer;\n    string indent;\n    string indent2;\n    int readby = ini.getReadBy ();\n    if (!subindent.empty ())\n    {\n\tfor (int ii = 0; ii<depth - 1;ii++)\n\t    indent = indent + subindent;\n\tif (depth)\n\t    indent2 = indent + subindent;\n    }\n\n    if (ini.getComment ()[0])\n        of << ini.getComment();\n    if (readby>=0 && readby < (int)sections.size ())\n\t{\n\t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free (out_buffer);\n\t}\n    \n    IniIterator\n\tci = ini.getContainerBegin (),\n\tce = ini.getContainerEnd ();\n\n    for (;ci != ce; ++ci)\n\t{\n\t    if (ci->t () == SECTION)\n\t\t{\n\t\t    write_helper (ci->s (), of, depth + 1);\n\t\t    ci->s ().clean();\n\t\t}\n\t    else\n\t\t{\n\t\t    IniEntry&e = ci->e ();\n\t\t    if (e.getComment ()[0])\n\t\t\tof << e.getComment();\n\t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n\t\t\t// bnc#492859, a fixed buffer is too small\n\t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n\t\t\tof << indent2 << out_buffer << \"\\n\";\n\t\t\tfree(out_buffer);\n\t\t    }\n\t\t    e.clean();\n\t\t}\n\t}\n\n    if (ini.getEndComment ()[0])\n        of << indent << ini.getEndComment();\n    if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n\t{\n\t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free(out_buffer);\n\t}\n    ini.clean();\n    return 0;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ini.clean",
          "args": [],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "clean",
          "container": "IniBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "62-62",
          "snippet": "virtual void clean() { dirty = false; }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniBase {\n  virtual void clean() { dirty = false; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "out_buffer"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&out_buffer",
            "sections[readby].end.out.c_str ()",
            "ini.getName()"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ini.getName",
          "args": [],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sections[readby].end.out.c_str",
          "args": [],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sections.size",
          "args": [],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ini.getEndComment",
          "args": [],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ini.getEndComment",
          "args": [],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "out_buffer"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&out_buffer",
            "params[e.getReadBy ()].line.out.c_str ()",
            "e.getName()",
            "e.getValue()"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getValue",
          "args": [],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getName",
          "args": [],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[e.getReadBy",
          "args": [],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "getReadBy",
          "container": "IniBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "59-59",
          "snippet": "int getReadBy()          const { return read_by;   }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniBase {\n  int getReadBy()          const { return read_by;   }\n}"
        }
      },
      {
        "call_info": {
          "callee": "e.getComment",
          "args": [],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "getComment",
          "container": "ModuleEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "81-86",
          "snippet": "ModuleEntry::EntryCom ModuleEntry::getComment() const {\n\n    return (comment.length () ?\n            (comment.find_last_of (\"\\n\") + 1 == comment.length () ? comment : comment + \"\\n\") :\n            comment);\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModuleEntry {\n  ModuleEntry::EntryCom ModuleEntry::getComment() const {\n  \n      return (comment.length () ?\n              (comment.find_last_of (\"\\n\") + 1 == comment.length () ? comment : comment + \"\\n\") :\n              comment);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ci->e",
          "args": [],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ci->s",
          "args": [],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ci->s",
          "args": [],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_helper",
          "args": [
            "ci->s ()",
            "of",
            "depth + 1"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "write_helper",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "1018-1077",
          "snippet": "int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n{\n    char * out_buffer;\n    string indent;\n    string indent2;\n    int readby = ini.getReadBy ();\n    if (!subindent.empty ())\n    {\n\tfor (int ii = 0; ii<depth - 1;ii++)\n\t    indent = indent + subindent;\n\tif (depth)\n\t    indent2 = indent + subindent;\n    }\n\n    if (ini.getComment ()[0])\n        of << ini.getComment();\n    if (readby>=0 && readby < (int)sections.size ())\n\t{\n\t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free (out_buffer);\n\t}\n    \n    IniIterator\n\tci = ini.getContainerBegin (),\n\tce = ini.getContainerEnd ();\n\n    for (;ci != ce; ++ci)\n\t{\n\t    if (ci->t () == SECTION)\n\t\t{\n\t\t    write_helper (ci->s (), of, depth + 1);\n\t\t    ci->s ().clean();\n\t\t}\n\t    else\n\t\t{\n\t\t    IniEntry&e = ci->e ();\n\t\t    if (e.getComment ()[0])\n\t\t\tof << e.getComment();\n\t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n\t\t\t// bnc#492859, a fixed buffer is too small\n\t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n\t\t\tof << indent2 << out_buffer << \"\\n\";\n\t\t\tfree(out_buffer);\n\t\t    }\n\t\t    e.clean();\n\t\t}\n\t}\n\n    if (ini.getEndComment ()[0])\n        of << indent << ini.getEndComment();\n    if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n\t{\n\t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free(out_buffer);\n\t}\n    ini.clean();\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ci->s",
          "args": [],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ci->t",
          "args": [],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "t",
          "container": "IniContainerElement",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "610-610",
          "snippet": "IniType t () const { return _t; }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniContainerElement {\n  IniType t () const { return _t; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ini.getContainerEnd",
          "args": [],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "getContainerEnd",
          "container": "IniSection",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "1201-1204",
          "snippet": "IniIterator IniSection::getContainerEnd ()\n{\n    return container.end ();\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nIniSection {\n  IniIterator IniSection::getContainerEnd ()\n  {\n      return container.end ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ini.getContainerBegin",
          "args": [],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "getContainerBegin",
          "container": "IniSection",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "1196-1199",
          "snippet": "IniIterator IniSection::getContainerBegin ()\n{\n    return container.begin ();\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nIniSection {\n  IniIterator IniSection::getContainerBegin ()\n  {\n      return container.begin ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "out_buffer"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&out_buffer",
            "sections[readby].begin.out.c_str ()",
            "ini.getName()"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ini.getName",
          "args": [],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sections[readby].begin.out.c_str",
          "args": [],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "subindent.empty",
          "args": [],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n  {\n      char * out_buffer;\n      string indent;\n      string indent2;\n      int readby = ini.getReadBy ();\n      if (!subindent.empty ())\n      {\n  \tfor (int ii = 0; ii<depth - 1;ii++)\n  \t    indent = indent + subindent;\n  \tif (depth)\n  \t    indent2 = indent + subindent;\n      }\n  \n      if (ini.getComment ()[0])\n          of << ini.getComment();\n      if (readby>=0 && readby < (int)sections.size ())\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free (out_buffer);\n  \t}\n      \n      IniIterator\n  \tci = ini.getContainerBegin (),\n  \tce = ini.getContainerEnd ();\n  \n      for (;ci != ce; ++ci)\n  \t{\n  \t    if (ci->t () == SECTION)\n  \t\t{\n  \t\t    write_helper (ci->s (), of, depth + 1);\n  \t\t    ci->s ().clean();\n  \t\t}\n  \t    else\n  \t\t{\n  \t\t    IniEntry&e = ci->e ();\n  \t\t    if (e.getComment ()[0])\n  \t\t\tof << e.getComment();\n  \t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n  \t\t\t// bnc#492859, a fixed buffer is too small\n  \t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n  \t\t\tof << indent2 << out_buffer << \"\\n\";\n  \t\t\tfree(out_buffer);\n  \t\t    }\n  \t\t    e.clean();\n  \t\t}\n  \t}\n  \n      if (ini.getEndComment ()[0])\n          of << indent << ini.getEndComment();\n      if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free(out_buffer);\n  \t}\n      ini.clean();\n      return 0;\n  }\n}"
  },
  {
    "function_name": "write",
    "container": "IniParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "928-1017",
    "snippet": "int IniParser::write()\n{\n    int bugs = 0;\n    if (!inifile.isDirty())\n    {\n        y2debug (\"File %s did not change. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n\treturn 0;\n    }\n    if (read_only)\n    {\n        y2debug (\"Attempt to write file %s that was mounted read-only. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n\treturn 0;\n    }\n    UpdateIfModif ();\n\n    if (multiple_files)\n    {\n\tIniIterator\n\t    ci = inifile.getContainerBegin (),\n\t    ce = inifile.getContainerEnd ();\n\n\tfor (;ci != ce; ++ci)\n\t    {\n\t\tif (ci->t () == SECTION)\n\t\t    {\n\t\t\tIniSection&s = ci->s ();\n\t\t\tint wb = s.getRewriteBy (); // bug #19066 \n\t\t\tstring filename = getFileName (s.getName (), wb);\n\n\t\t\t// This is the only place where we unmark a\n\t\t\t// section for deletion - when it is a file\n\t\t\t// that got some data again. We can do it\n\t\t\t// because we only erase the files afterwards.\n\t\t\tdeleted_sections.erase (filename);\n\n\t\t\tif (!s.isDirty ()) {\n\t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\ts.initReadBy ();\n\t\t\t// ensure that the directories exist\n\t\t\tPathname pn (filename);\n\t\t\tPathInfo::assert_dir (pn.dirname ());\n\t\t\tofstream of(filename.c_str());\n\t\t\tif (!of.good())\n\t\t\t{\n\t\t\t    bugs++;\n\t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\twrite_helper (s, of, 0);\n\t\t\ts.clean();\n\t\t\tof.close ();\n\t\t    }\n\t\telse\n\t\t    {\n\t\t\ty2error (\"Value %s encountered at multifile top level\",\n\t\t\t\t ci->e ().getName ());\n\t\t    }\n\t    }\n\n\t// FIXME: update time stamps of files...\n\n\t// erase removed files...\n\tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n\t    if (multi_files.find (*i) != multi_files.end ()) {\n\t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n\t\tunlink ((*i).c_str());\n\t    }\n    }\n    else\n    {\n\t// ensure that the directories exist\n\tPathname pn (file);\n\tPathInfo::assert_dir (pn.dirname ());\n\tofstream of(file.c_str());\n\tif (!of.good())\n\t{\n\t    y2error (\"Can not open file %s for write\", file.c_str());\n\t    return -1;\n\t}\n\n\twrite_helper (inifile, of, 0);\n\n\tof.close();\n\ttimestamp = getTimeStamp ();\n    }\n    inifile.clean ();\n    return bugs ? -1 : 0;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inifile.clean",
          "args": [],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "clean",
          "container": "IniBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "62-62",
          "snippet": "virtual void clean() { dirty = false; }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniBase {\n  virtual void clean() { dirty = false; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTimeStamp",
          "args": [],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "getTimeStamp",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "913-927",
          "snippet": "time_t IniParser::getTimeStamp()\n{\n    struct stat st;\n    if (multiple_files)\n    {\n\tprintf (\"bad call of getTimeStamp aborting. FIXME\\n\");//FIXME\n\tabort ();\n    }\n    if (stat(file.c_str(), &st))\n    {\n\ty2error(\"Unable to stat '%s': %s\", file.c_str(), strerror(errno));\n\treturn 0;\n    }\n    return st.st_mtime;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  time_t IniParser::getTimeStamp()\n  {\n      struct stat st;\n      if (multiple_files)\n      {\n  \tprintf (\"bad call of getTimeStamp aborting. FIXME\\n\");//FIXME\n  \tabort ();\n      }\n      if (stat(file.c_str(), &st))\n      {\n  \ty2error(\"Unable to stat '%s': %s\", file.c_str(), strerror(errno));\n  \treturn 0;\n      }\n      return st.st_mtime;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "of.close",
          "args": [],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "325-351",
          "snippet": "int\nExternalProgram::close()\n{\n    if (pid > 0)\n    {\n\tExternalDataSource::close();\n\t// Wait for child to exit\n\tint ret;\n        int status = 0;\n\tdo\n\t{\n\t    ret = waitpid(pid, &status, 0);\n\t}\n\twhile (ret == -1 && errno == EINTR);\n\n\tif (ret != -1)\n\t{\n\t    status = checkStatus( status );\n\t}\n        pid = -1;\n        return status;\n    }\n    else\n    {\n        return _exitStatus;\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  int\n  ExternalProgram::close()\n  {\n      if (pid > 0)\n      {\n  \tExternalDataSource::close();\n  \t// Wait for child to exit\n  \tint ret;\n          int status = 0;\n  \tdo\n  \t{\n  \t    ret = waitpid(pid, &status, 0);\n  \t}\n  \twhile (ret == -1 && errno == EINTR);\n  \n  \tif (ret != -1)\n  \t{\n  \t    status = checkStatus( status );\n  \t}\n          pid = -1;\n          return status;\n      }\n      else\n      {\n          return _exitStatus;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_helper",
          "args": [
            "inifile",
            "of",
            "0"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "write_helper",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "1018-1077",
          "snippet": "int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n{\n    char * out_buffer;\n    string indent;\n    string indent2;\n    int readby = ini.getReadBy ();\n    if (!subindent.empty ())\n    {\n\tfor (int ii = 0; ii<depth - 1;ii++)\n\t    indent = indent + subindent;\n\tif (depth)\n\t    indent2 = indent + subindent;\n    }\n\n    if (ini.getComment ()[0])\n        of << ini.getComment();\n    if (readby>=0 && readby < (int)sections.size ())\n\t{\n\t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free (out_buffer);\n\t}\n    \n    IniIterator\n\tci = ini.getContainerBegin (),\n\tce = ini.getContainerEnd ();\n\n    for (;ci != ce; ++ci)\n\t{\n\t    if (ci->t () == SECTION)\n\t\t{\n\t\t    write_helper (ci->s (), of, depth + 1);\n\t\t    ci->s ().clean();\n\t\t}\n\t    else\n\t\t{\n\t\t    IniEntry&e = ci->e ();\n\t\t    if (e.getComment ()[0])\n\t\t\tof << e.getComment();\n\t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n\t\t\t// bnc#492859, a fixed buffer is too small\n\t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n\t\t\tof << indent2 << out_buffer << \"\\n\";\n\t\t\tfree(out_buffer);\n\t\t    }\n\t\t    e.clean();\n\t\t}\n\t}\n\n    if (ini.getEndComment ()[0])\n        of << indent << ini.getEndComment();\n    if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n\t{\n\t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free(out_buffer);\n\t}\n    ini.clean();\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n  {\n      char * out_buffer;\n      string indent;\n      string indent2;\n      int readby = ini.getReadBy ();\n      if (!subindent.empty ())\n      {\n  \tfor (int ii = 0; ii<depth - 1;ii++)\n  \t    indent = indent + subindent;\n  \tif (depth)\n  \t    indent2 = indent + subindent;\n      }\n  \n      if (ini.getComment ()[0])\n          of << ini.getComment();\n      if (readby>=0 && readby < (int)sections.size ())\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free (out_buffer);\n  \t}\n      \n      IniIterator\n  \tci = ini.getContainerBegin (),\n  \tce = ini.getContainerEnd ();\n  \n      for (;ci != ce; ++ci)\n  \t{\n  \t    if (ci->t () == SECTION)\n  \t\t{\n  \t\t    write_helper (ci->s (), of, depth + 1);\n  \t\t    ci->s ().clean();\n  \t\t}\n  \t    else\n  \t\t{\n  \t\t    IniEntry&e = ci->e ();\n  \t\t    if (e.getComment ()[0])\n  \t\t\tof << e.getComment();\n  \t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n  \t\t\t// bnc#492859, a fixed buffer is too small\n  \t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n  \t\t\tof << indent2 << out_buffer << \"\\n\";\n  \t\t\tfree(out_buffer);\n  \t\t    }\n  \t\t    e.clean();\n  \t\t}\n  \t}\n  \n      if (ini.getEndComment ()[0])\n          of << indent << ini.getEndComment();\n      if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free(out_buffer);\n  \t}\n      ini.clean();\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Can not open file %s for write\"",
            "file.c_str()"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.c_str",
          "args": [],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of.good",
          "args": [],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.c_str",
          "args": [],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PathInfo::assert_dir",
          "args": [
            "pn.dirname ()"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pn.dirname",
          "args": [],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "dirname",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "70-70",
          "snippet": "Pathname    dirname()       const { return dirname( *this ); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  Pathname    dirname()       const { return dirname( *this ); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "(*i).c_str()"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "unlink",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "541-548",
          "snippet": "int PathInfo::unlink( const Pathname & path )\n{\n  DBG << \"unlink \" << path;\n  if ( ::unlink( path.asString().c_str() ) == -1 ) {\n    return _Log_Result( errno );\n  }\n  return _Log_Result( 0 );\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::unlink( const Pathname & path )\n  {\n    DBG << \"unlink \" << path;\n    if ( ::unlink( path.asString().c_str() ) == -1 ) {\n      return _Log_Result( errno );\n    }\n    return _Log_Result( 0 );\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Removing file %s\\n\"",
            "(*i).c_str()"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "multi_files.end",
          "args": [],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "multi_files.find",
          "args": [
            "*i"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deleted_sections.begin",
          "args": [],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Value %s encountered at multifile top level\"",
            "ci->e ().getName ()"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ci->e",
          "args": [],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ci->e",
          "args": [],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Can not open file %s for write\"",
            "filename.c_str()"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of.good",
          "args": [],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PathInfo::assert_dir",
          "args": [
            "pn.dirname ()"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.initReadBy",
          "args": [],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "initReadBy",
          "container": "IniSection",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "503-503",
          "snippet": "void initReadBy () { read_by = -1; }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniSection {\n  void initReadBy () { read_by = -1; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Skipping file %s that was not changed.\"",
            "filename.c_str()"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.isDirty",
          "args": [],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "isDirty",
          "container": "IniSection",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "1165-1178",
          "snippet": "bool IniSection::isDirty ()\n{\n    if (dirty)\n\treturn true;\n    // every write dirtyfies not only value but section too\n    // so it is enough for us to find the first dirty section\n    IniSectionIdxIterator xi = isections.begin (), xe = isections. end ();\n    for (; xi != xe; ++xi)\n    {\n\tif (xi->second->s ().isDirty ())\n\t  return true;\n    }\n    return false;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nIniSection {\n  bool IniSection::isDirty ()\n  {\n      if (dirty)\n  \treturn true;\n      // every write dirtyfies not only value but section too\n      // so it is enough for us to find the first dirty section\n      IniSectionIdxIterator xi = isections.begin (), xe = isections. end ();\n      for (; xi != xe; ++xi)\n      {\n  \tif (xi->second->s ().isDirty ())\n  \t  return true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "deleted_sections.erase",
          "args": [
            "filename"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "683-695",
          "snippet": "int PathInfo::erase( const Pathname & path )\n{\n  int res = 0;\n  PathInfo p( path, LSTAT );\n  if ( p.isExist() )\n    {\n      if ( p.isDir() )\n        res = PathInfo::recursive_rmdir( path );\n      else\n        res = PathInfo::unlink( path );\n    }\n  return res;\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::erase( const Pathname & path )\n  {\n    int res = 0;\n    PathInfo p( path, LSTAT );\n    if ( p.isExist() )\n      {\n        if ( p.isDir() )\n          res = PathInfo::recursive_rmdir( path );\n        else\n          res = PathInfo::unlink( path );\n      }\n    return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getFileName",
          "args": [
            "s.getName ()",
            "wb"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "getFileName",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "1078-1091",
          "snippet": "string IniParser::getFileName (const string&sec, int rb) const\n{\n    string file = sec;\n    if (-1 != rb && (int) rewrites.size () > rb)\n    {\n\tint max = rewrites[rb].out.length () + sec.length () + 1;\n\tchar*buf = new char[max + 1];\n\tsnprintf (buf, max, rewrites[rb].out.c_str (), sec.c_str());\n\ty2debug (\"Rewriting %s to %s\", sec.c_str(), buf);\n\tfile = buf;\n\tdelete [] buf;\n    }\n    return file;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  string IniParser::getFileName (const string&sec, int rb) const\n  {\n      string file = sec;\n      if (-1 != rb && (int) rewrites.size () > rb)\n      {\n  \tint max = rewrites[rb].out.length () + sec.length () + 1;\n  \tchar*buf = new char[max + 1];\n  \tsnprintf (buf, max, rewrites[rb].out.c_str (), sec.c_str());\n  \ty2debug (\"Rewriting %s to %s\", sec.c_str(), buf);\n  \tfile = buf;\n  \tdelete [] buf;\n      }\n      return file;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.getName",
          "args": [],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.getRewriteBy",
          "args": [],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "getRewriteBy",
          "container": "IniSection",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "507-507",
          "snippet": "int getRewriteBy() { return rewrite_by; }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniSection {\n  int getRewriteBy() { return rewrite_by; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ci->s",
          "args": [],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ci->t",
          "args": [],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "t",
          "container": "IniContainerElement",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "610-610",
          "snippet": "IniType t () const { return _t; }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniContainerElement {\n  IniType t () const { return _t; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inifile.getContainerEnd",
          "args": [],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "getContainerEnd",
          "container": "IniSection",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "1201-1204",
          "snippet": "IniIterator IniSection::getContainerEnd ()\n{\n    return container.end ();\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nIniSection {\n  IniIterator IniSection::getContainerEnd ()\n  {\n      return container.end ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inifile.getContainerBegin",
          "args": [],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "getContainerBegin",
          "container": "IniSection",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "1196-1199",
          "snippet": "IniIterator IniSection::getContainerBegin ()\n{\n    return container.begin ();\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nIniSection {\n  IniIterator IniSection::getContainerBegin ()\n  {\n      return container.begin ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpdateIfModif",
          "args": [],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "UpdateIfModif",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "888-911",
          "snippet": "void IniParser::UpdateIfModif ()\n{\n    if (read_only)\n        return;\n    // #42297: parsing a file with repeat_names cannot remove duplicates\n    // so reparsing it would duplicate the whole file.\n    // Therefore we do not reparse.\n    if (repeat_names)\n    {\n\ty2debug (\"Skipping possible reparse due to repeat_names\");\n\treturn;\n    }\n    if (multiple_files)\n\tparse ();\n    else\n    {\n\tif (timestamp != getTimeStamp())\n\t{\n\t    y2warning(\"Data file '%s' was changed externaly!\", file.c_str());\n\t    parse ();\n\t}\n    }\n    return ;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  void IniParser::UpdateIfModif ()\n  {\n      if (read_only)\n          return;\n      // #42297: parsing a file with repeat_names cannot remove duplicates\n      // so reparsing it would duplicate the whole file.\n      // Therefore we do not reparse.\n      if (repeat_names)\n      {\n  \ty2debug (\"Skipping possible reparse due to repeat_names\");\n  \treturn;\n      }\n      if (multiple_files)\n  \tparse ();\n      else\n      {\n  \tif (timestamp != getTimeStamp())\n  \t{\n  \t    y2warning(\"Data file '%s' was changed externaly!\", file.c_str());\n  \t    parse ();\n  \t}\n      }\n      return ;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Attempt to write file %s that was mounted read-only. Not saving.\"",
            "multiple_files ? files[0].c_str () : file.c_str ()"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.c_str",
          "args": [],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files[0].c_str",
          "args": [],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"File %s did not change. Not saving.\"",
            "multiple_files ? files[0].c_str () : file.c_str ()"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.c_str",
          "args": [],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files[0].c_str",
          "args": [],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::write()\n  {\n      int bugs = 0;\n      if (!inifile.isDirty())\n      {\n          y2debug (\"File %s did not change. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n  \treturn 0;\n      }\n      if (read_only)\n      {\n          y2debug (\"Attempt to write file %s that was mounted read-only. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n  \treturn 0;\n      }\n      UpdateIfModif ();\n  \n      if (multiple_files)\n      {\n  \tIniIterator\n  \t    ci = inifile.getContainerBegin (),\n  \t    ce = inifile.getContainerEnd ();\n  \n  \tfor (;ci != ce; ++ci)\n  \t    {\n  \t\tif (ci->t () == SECTION)\n  \t\t    {\n  \t\t\tIniSection&s = ci->s ();\n  \t\t\tint wb = s.getRewriteBy (); // bug #19066 \n  \t\t\tstring filename = getFileName (s.getName (), wb);\n  \n  \t\t\t// This is the only place where we unmark a\n  \t\t\t// section for deletion - when it is a file\n  \t\t\t// that got some data again. We can do it\n  \t\t\t// because we only erase the files afterwards.\n  \t\t\tdeleted_sections.erase (filename);\n  \n  \t\t\tif (!s.isDirty ()) {\n  \t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n  \t\t\t    continue;\n  \t\t\t}\n  \t\t\ts.initReadBy ();\n  \t\t\t// ensure that the directories exist\n  \t\t\tPathname pn (filename);\n  \t\t\tPathInfo::assert_dir (pn.dirname ());\n  \t\t\tofstream of(filename.c_str());\n  \t\t\tif (!of.good())\n  \t\t\t{\n  \t\t\t    bugs++;\n  \t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n  \t\t\t    continue;\n  \t\t\t}\n  \t\t\twrite_helper (s, of, 0);\n  \t\t\ts.clean();\n  \t\t\tof.close ();\n  \t\t    }\n  \t\telse\n  \t\t    {\n  \t\t\ty2error (\"Value %s encountered at multifile top level\",\n  \t\t\t\t ci->e ().getName ());\n  \t\t    }\n  \t    }\n  \n  \t// FIXME: update time stamps of files...\n  \n  \t// erase removed files...\n  \tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n  \t    if (multi_files.find (*i) != multi_files.end ()) {\n  \t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n  \t\tunlink ((*i).c_str());\n  \t    }\n      }\n      else\n      {\n  \t// ensure that the directories exist\n  \tPathname pn (file);\n  \tPathInfo::assert_dir (pn.dirname ());\n  \tofstream of(file.c_str());\n  \tif (!of.good())\n  \t{\n  \t    y2error (\"Can not open file %s for write\", file.c_str());\n  \t    return -1;\n  \t}\n  \n  \twrite_helper (inifile, of, 0);\n  \n  \tof.close();\n  \ttimestamp = getTimeStamp ();\n      }\n      inifile.clean ();\n      return bugs ? -1 : 0;\n  }\n}"
  },
  {
    "function_name": "getTimeStamp",
    "container": "IniParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "913-927",
    "snippet": "time_t IniParser::getTimeStamp()\n{\n    struct stat st;\n    if (multiple_files)\n    {\n\tprintf (\"bad call of getTimeStamp aborting. FIXME\\n\");//FIXME\n\tabort ();\n    }\n    if (stat(file.c_str(), &st))\n    {\n\ty2error(\"Unable to stat '%s': %s\", file.c_str(), strerror(errno));\n\treturn 0;\n    }\n    return st.st_mtime;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unable to stat '%s': %s\"",
            "file.c_str()",
            "strerror(errno)"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.c_str",
          "args": [],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "file.c_str()",
            "&st"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.c_str",
          "args": [],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"bad call of getTimeStamp aborting. FIXME\\n\""
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  time_t IniParser::getTimeStamp()\n  {\n      struct stat st;\n      if (multiple_files)\n      {\n  \tprintf (\"bad call of getTimeStamp aborting. FIXME\\n\");//FIXME\n  \tabort ();\n      }\n      if (stat(file.c_str(), &st))\n      {\n  \ty2error(\"Unable to stat '%s': %s\", file.c_str(), strerror(errno));\n  \treturn 0;\n      }\n      return st.st_mtime;\n  }\n}"
  },
  {
    "function_name": "UpdateIfModif",
    "container": "IniParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "888-911",
    "snippet": "void IniParser::UpdateIfModif ()\n{\n    if (read_only)\n        return;\n    // #42297: parsing a file with repeat_names cannot remove duplicates\n    // so reparsing it would duplicate the whole file.\n    // Therefore we do not reparse.\n    if (repeat_names)\n    {\n\ty2debug (\"Skipping possible reparse due to repeat_names\");\n\treturn;\n    }\n    if (multiple_files)\n\tparse ();\n    else\n    {\n\tif (timestamp != getTimeStamp())\n\t{\n\t    y2warning(\"Data file '%s' was changed externaly!\", file.c_str());\n\t    parse ();\n\t}\n    }\n    return ;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse",
          "args": [],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "484-562",
          "snippet": "int IniParser::parse()\n{\n    if (multiple_files)\n    {\n\tglob_t do_files;\n\tint len = files.size ();\n\tint flags = 0;\n\tfor (int i = 0;i<len;i++)\n\t{\n\t    glob (files[i].c_str (),flags, NULL, &do_files);\n\t    flags = GLOB_APPEND;\n\t}\n\tchar**f = do_files.gl_pathv;\n\tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n\t{\n\t    int section_index = -1;\n\t    string section_name = *f;\n\t    //FIXME: create function out of it.\n\t    // do we have name rewrite rules?\n\t    for (size_t j = 0; j < rewrites.size (); j++)\n\t\t{\n\t\t    RegexMatch m (rewrites[j].rx, section_name);\n\t\t    if (m)\n\t\t    {\n\t\t\tsection_index = j;\n\t\t\tsection_name = m[1];\n\t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    // do we know about the file?\n\t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n\t    if (ff == multi_files.end())\n\t    {\n\t\t// new file\n\t\tif (scanner_start (*f))\n\t\t    y2error (\"Cannot open %s.\", *f);\n\t\telse\n\t\t{\n\t\t    FileDescr fdsc (*f);\n\t\t    multi_files[*f] = fdsc;\n\t\t    inifile.initSection (section_name, \"\", -1, section_index);\n\t\t    parse_helper(inifile.getSection(section_name.c_str()));\n\t\t    scanner_stop();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif ((*ff).second.changed ())\n\t\t{\n\t\t    if (scanner_start (*f))\n\t\t\ty2error (\"Cannot open %s.\", *f);\n\t\t    else\n\t\t    {\n\t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n\t\t\tFileDescr fdsc (*f);\n\t\t\tmulti_files [*f] = fdsc;\n\t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n\t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n\t\t\tscanner_stop();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tif (scanner_start (file.c_str()))\n\t    {\n\t\ty2error (\"Can not open %s.\", file.c_str());\n\t\treturn -1;\n\t    }\n\tparse_helper(inifile);\n\tscanner_stop();\n\ttimestamp = getTimeStamp ();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse()\n  {\n      if (multiple_files)\n      {\n  \tglob_t do_files;\n  \tint len = files.size ();\n  \tint flags = 0;\n  \tfor (int i = 0;i<len;i++)\n  \t{\n  \t    glob (files[i].c_str (),flags, NULL, &do_files);\n  \t    flags = GLOB_APPEND;\n  \t}\n  \tchar**f = do_files.gl_pathv;\n  \tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n  \t{\n  \t    int section_index = -1;\n  \t    string section_name = *f;\n  \t    //FIXME: create function out of it.\n  \t    // do we have name rewrite rules?\n  \t    for (size_t j = 0; j < rewrites.size (); j++)\n  \t\t{\n  \t\t    RegexMatch m (rewrites[j].rx, section_name);\n  \t\t    if (m)\n  \t\t    {\n  \t\t\tsection_index = j;\n  \t\t\tsection_name = m[1];\n  \t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \n  \t    // do we know about the file?\n  \t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n  \t    if (ff == multi_files.end())\n  \t    {\n  \t\t// new file\n  \t\tif (scanner_start (*f))\n  \t\t    y2error (\"Cannot open %s.\", *f);\n  \t\telse\n  \t\t{\n  \t\t    FileDescr fdsc (*f);\n  \t\t    multi_files[*f] = fdsc;\n  \t\t    inifile.initSection (section_name, \"\", -1, section_index);\n  \t\t    parse_helper(inifile.getSection(section_name.c_str()));\n  \t\t    scanner_stop();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif ((*ff).second.changed ())\n  \t\t{\n  \t\t    if (scanner_start (*f))\n  \t\t\ty2error (\"Cannot open %s.\", *f);\n  \t\t    else\n  \t\t    {\n  \t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n  \t\t\tFileDescr fdsc (*f);\n  \t\t\tmulti_files [*f] = fdsc;\n  \t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n  \t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n  \t\t\tscanner_stop();\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n      else\n      {\n  \tif (scanner_start (file.c_str()))\n  \t    {\n  \t\ty2error (\"Can not open %s.\", file.c_str());\n  \t\treturn -1;\n  \t    }\n  \tparse_helper(inifile);\n  \tscanner_stop();\n  \ttimestamp = getTimeStamp ();\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"Data file '%s' was changed externaly!\"",
            "file.c_str()"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.c_str",
          "args": [],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getTimeStamp",
          "args": [],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "getTimeStamp",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "913-927",
          "snippet": "time_t IniParser::getTimeStamp()\n{\n    struct stat st;\n    if (multiple_files)\n    {\n\tprintf (\"bad call of getTimeStamp aborting. FIXME\\n\");//FIXME\n\tabort ();\n    }\n    if (stat(file.c_str(), &st))\n    {\n\ty2error(\"Unable to stat '%s': %s\", file.c_str(), strerror(errno));\n\treturn 0;\n    }\n    return st.st_mtime;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  time_t IniParser::getTimeStamp()\n  {\n      struct stat st;\n      if (multiple_files)\n      {\n  \tprintf (\"bad call of getTimeStamp aborting. FIXME\\n\");//FIXME\n  \tabort ();\n      }\n      if (stat(file.c_str(), &st))\n      {\n  \ty2error(\"Unable to stat '%s': %s\", file.c_str(), strerror(errno));\n  \treturn 0;\n      }\n      return st.st_mtime;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Skipping possible reparse due to repeat_names\""
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  void IniParser::UpdateIfModif ()\n  {\n      if (read_only)\n          return;\n      // #42297: parsing a file with repeat_names cannot remove duplicates\n      // so reparsing it would duplicate the whole file.\n      // Therefore we do not reparse.\n      if (repeat_names)\n      {\n  \ty2debug (\"Skipping possible reparse due to repeat_names\");\n  \treturn;\n      }\n      if (multiple_files)\n  \tparse ();\n      else\n      {\n  \tif (timestamp != getTimeStamp())\n  \t{\n  \t    y2warning(\"Data file '%s' was changed externaly!\", file.c_str());\n  \t    parse ();\n  \t}\n      }\n      return ;\n  }\n}"
  },
  {
    "function_name": "parse_helper",
    "container": "IniParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "564-886",
    "snippet": "int IniParser::parse_helper(IniSection&ini)\n{\n    string comment = \"\";\n    string key = \"\";\n    string val = \"\";\n    int state = 0;\t\t// 1: precessing a multiline value\n    int matched_by = -1;\n\n    string line;\n    size_t i;\n\n    // stack of open sections, innermost at front\n    list<IniSection *> open_sections;\n\n    //\n    // read line\n    //\n    while (!scanner_get (line))\n\t{\n\t    //\n\t    // check for whole-line comment (always as the first stage)\n\t    //\n\t    for (i = 0;i<linecomments.size (); i++)\n\t\t{\n\t\t    if (RegexMatch (linecomments[i], line, 0))\n\t\t\t{\n\t\t\t    // we have it !!!\n\t\t\t    comment = comment + line + \"\\n\";\n\t\t\t    break;\n\t\t\t}\n\t\t}\n\t    if (i<linecomments.size ()) // found? -> next line\n\t\tcontinue;\n\n\t    //\n\t    // check for comments on line\n\t    //\n\t    if (!comments_last)\n\t\t{\n\t\t    for (i = 0;i<comments.size (); i++)\n\t\t\t{\n\t\t\t    RegexMatch m (comments[i], line);\n\t\t\t    if (m)\n\t\t\t    {\n\t\t\t\t// we have it !!!\n\t\t\t\tcomment = comment + m[0] + \"\\n\";\n\t\t\t\tline = m.rest;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t}\n\n\t    //\n\t    // are we in broken line?\n\t    //\n\t    if (state)\n\t\t{\n\t\t    RegexMatch m (params[matched_by].end, line);\n\t\t    if (m)\n\t\t    {    \n\t\t\t// it is the end of broken line\n\t\t\tstate = 0;\n\t\t\tval = val + (join_multiline ? \" \" : \"\\n\") + m[1];\n\t\t\tline = m.rest;\n\t\t\tif (open_sections.empty ())\n\t\t\t    {   // we are in toplevel section, going deeper\n\t\t\t\t// check for toplevel values allowance\n\t\t\t\tif (!global_values)\n\t\t\t\t    scanner_error (\"%s: values at the top level not allowed.\", key.c_str ());\n\t\t\t\telse\n\t\t\t\t    ini.initValue (key, val, comment, matched_by);\n\t\t\t    }\n\t\t\telse {\n\t\t\t    open_sections.front()->initValue(key, val, comment, matched_by);\n\t\t\t}\n\t\t\tcomment = \"\";\n\t\t    }\n\t\t    else\n\t\t\tval = val + (join_multiline ? \" \" : \"\\n\") + line;\n\t\t}\n\t    if (!state)\n\t\t{\n\t\t    //\n\t\t    // check for section begin\n\t\t    //\n\t\t    {\n\t\t\tstring found;\n\n\t\t\tfor (i = 0; i < sections.size (); i++)\n\t\t\t    {\n\t\t\t\tRegexMatch m (sections[i].begin.rx, line);\n\t\t\t\tif (m)\n\t\t\t\t{\n\t\t\t\t    found = m[1];\n\t\t\t\t    line = m.rest;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\tif (i < sections.size ())\n\t\t\t    {\n\t\t\t\t// section begin found !!! check conditions\n\t\t\t\tif (!open_sections.empty())\n\t\t\t\t    {   // there were some sections\n\t\t\t\t\t// is there need to close previous section?\n\t\t\t\t\tIniSection * cur = open_sections.front();\n\t\t\t\t\tif (sectionNeedsEnd(cur->getReadBy()))\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(no_nested_sections)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tscanner_error (\"Section %s started but section %s is not finished\",\n\t\t\t\t\t\t\t\t found.c_str(),\n\t\t\t\t\t\t\t\t cur->getName());\n\t\t\t\t\t\t\topen_sections.pop_front();\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    open_sections.pop_front();\n\t\t\t\t    }\n\n\t\t\t\tIniSection * parent = NULL;\n\t\t\t\tif (open_sections.empty())\n\t\t\t\t    {   // we are in toplevel section, going deeper\n\t\t\t\t\tparent = &ini;\n\t\t\t\t    }\n\t\t\t\telse\n\t\t\t\t    {\n\t\t\t\t\tif (no_nested_sections)\n\t\t\t\t\t    scanner_error (\"Attempt to create nested section %s.\", found.c_str ());\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t    parent = open_sections.front();\n\t\t\t\t\t}\n\t\t\t\t    }\n\n\t\t\t\tif (parent)\n\t\t\t\t    open_sections.push_front (& parent->initSection (found, comment, i));\n\n\t\t\t\tcomment = \"\";\n\t\t\t    }\n\t\t    } // check for section begin\n\n\t\t    //\n\t\t    // check for section end\n\t\t    //\n\t\t    {\n\t\t\tstring found;\n\n\t\t\tfor (i = 0; i < sections.size (); i++)\n\t\t\t    {\n\t\t\t\tif (!sections[i].end_valid)\n\t\t\t\t    continue;\n\t\t\t\tRegexMatch m (sections[i].end.rx, line);\n\t\t\t\tif (m)\n\t\t\t\t{\n\t\t\t\t    found = 1 < m.matches.size () ? m[1]: \"\";\n\t\t\t\t    line = m.rest;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\tif (i < sections.size ())\n\t\t\t    {\n\t\t\t\t// we found new section enclosing which\n\t\t\t\t// means that we can save possible trailing\n\t\t\t\t// comment\n\t\t\t\tif (!comment.empty ())\n\t\t\t\t    {\n\t\t\t\t\tif (open_sections.empty())\n\t\t\t\t\t    ini.setEndComment (comment.c_str ());\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\topen_sections.front()->setEndComment (comment.c_str ());\n\t\t\t\t\t    }\n\t\t\t\t\tcomment = \"\";\n\t\t\t\t    }\n\t\t\t\tif (open_sections.empty ())\n\t\t\t\t    scanner_error (\"Nothing to close.\");\n\t\t\t\telse {\n\t\t\t\t    list<IniSection *>::iterator\n\t\t\t\t\tb = open_sections.begin(),\n\t\t\t\t\te = open_sections.end(),\n\t\t\t\t\tit;\n\n\t\t\t\t    string name_to_close = found;\n\t\t\t\t    bool complain = false;\n\n\t\t\t\t    if (!name_to_close.empty ())\n\t\t\t\t    {   // there is a subexpression (section name)\n\t\t\t\t\tfor (it = b; it != e; ++it) {\n\t\t\t\t\t    if ((*it)->getName() == name_to_close)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (it == e) {\n\t\t\t\t\t    // no match by name, try matching by type\n\t\t\t\t\t    name_to_close = \"\";\n\t\t\t\t\t    complain = true;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    \n\t\t\t\t    if (name_to_close.empty ()) {\n\t\t\t\t\t// there was no name or we did not find the specified one\n\t\t\t\t\tfor (it = b; it != e; ++it) {\n\t\t\t\t\t    if ((*it)->getReadBy() == i)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (it == e) {\n\t\t\t\t\t    // not even a match by type\n\t\t\t\t\t    it = b;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (complain)\n\t\t\t\t\t    scanner_error (\"Unexpected closing %s. Closing section %s.\", found.c_str(), (*it)->getName());\n\t\t\t\t    }\n\t\t\t\t    open_sections.erase (b, ++it);\n\t\t\t\t}\n\t\t\t    }\n\t\t    }\n\n\t\t    //\n\t\t    // check for line\n\t\t    //\n\t\t    {\n\t\t\tstring key,val;\n\t\t\tfor (i = 0; i < params.size (); i++)\n\t\t\t{\n\t\t\t    RegexMatch m (params[i].line.rx, line);\n\t\t\t    if (m)\n\t\t\t    {\n\t\t\t\tkey = m[1];\n\t\t\t\tval = m[2];\n\t\t\t\tline = m.rest;\n\t\t\t\tbreak;\n\t\t\t    }\t\t\t\t\n\t\t\t}\n\t\t\tif (i != params.size ())\n\t\t\t    {\n\t\t\t\tif (open_sections.empty())\n\t\t\t\t    {   // we are in toplevel section, going deeper\n\t\t\t\t\t// check for toplevel values allowance\n\t\t\t\t\tif (!global_values)\n\t\t\t\t\t    scanner_error (\"%s: values at the top level not allowed.\", key.c_str ());\n\t\t\t\t\telse\n\t\t\t\t\t    ini.initValue (key, val, comment, i);\n\t\t\t\t    }\n\t\t\t\telse\n\t\t\t\t    {\n\t\t\t\t\topen_sections.front()->initValue(key, val, comment, i);\n\t\t\t\t    }\n\t\t\t\tcomment = \"\";\n\t\t\t    }\n\t\t    }\n\n\t\t    //\n\t\t    // check for broken line\n\t\t    //\n\t\t    {\n\t\t\tfor (i = 0; i < params.size (); i++)\n\t\t\t{\n\t\t\t    if (!params[i].multiline_valid)\n\t\t\t\tcontinue;\n\t\t\t    RegexMatch m (params[i].begin, line);\n\t\t\t    if (m)\n\t\t\t    {\n\t\t\t\t// broken line\n\t\t\t\tkey = m[1];\n\t\t\t\tval = m[2];\n\t\t\t\tline = m.rest;\n\t\t\t\tmatched_by = i;\n\t\t\t\tstate = 1;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\n\t\t    //\n\t\t    // check for comments on line\n\t\t    //\n\t\t    if (comments_last && !comments.empty ())\n\t\t    {\n\t\t\tfor (i = 0; i < comments.size (); i++)\n\t\t\t{\n\t\t\t    RegexMatch m (comments[i], line);\n\t\t\t    if (m)\n\t\t\t    {\n\t\t\t\t// we have it !!!\n\t\t\t\tcomment = comment + m[0] + \"\\n\";\n\t\t\t\tline = m.rest;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    //\n\t\t    // if line is not empty, report it\n\t\t    //\n\t\t    {\n\t\t\tif (!onlySpaces (line.c_str()))\n\t\t\t    scanner_error (\"Extra characters: %s\", line.c_str ());\n\t\t    }\n\t\t}\n\t}\n    if (!comment.empty ())\n    {\n\tif (!no_finalcomment_kill)\n\t{\n\t    // kill empty lines at the end of comment\n\t    int i = comment.length ();\n\t    const char*p = comment.c_str () + i - 1;\n\t    while (i)\n\t    {\n\t\tif ('\\n' != *p)\n\t\t    break;\n\t\ti --;\n\t\tp --;\n\t    }\n\t    if (i > 0)\n\t\ti++;\n\t    comment.resize (i);\n\t}\n\tini.setEndComment (comment.c_str ());\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ini.setEndComment",
          "args": [
            "comment.c_str ()"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "setEndComment",
          "container": "IniSection",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "1158-1164",
          "snippet": "void IniSection::setEndComment (const char*c)\n{\n    if (comment.empty () && container.empty ())\n\tcomment = c;\n    else\n\tend_comment = c;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nIniSection {\n  void IniSection::setEndComment (const char*c)\n  {\n      if (comment.empty () && container.empty ())\n  \tcomment = c;\n      else\n  \tend_comment = c;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "comment.c_str",
          "args": [],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comment.resize",
          "args": [
            "i"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comment.c_str",
          "args": [],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comment.length",
          "args": [],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "comment.empty",
          "args": [],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scanner_error",
          "args": [
            "\"Extra characters: %s\"",
            "line.c_str ()"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.c_str",
          "args": [],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onlySpaces",
          "args": [
            "line.c_str()"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "onlySpaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "81-90",
          "snippet": "bool onlySpaces (const char*str)\n{\n    while (*str)\n    {\n\tif (' ' != *str && '\\t' != *str && '\\r' != *str && '\\n' != *str)\n\t    return false;\n\tstr++;\n    }\n    return true;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool onlySpaces (const char*str)\n{\n    while (*str)\n    {\n\tif (' ' != *str && '\\t' != *str && '\\r' != *str && '\\n' != *str)\n\t    return false;\n\tstr++;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "line.c_str",
          "args": [],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comments.size",
          "args": [],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_sections.front",
          "args": [
            "key",
            "val",
            "comment",
            "i"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_sections.front",
          "args": [],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ini.initValue",
          "args": [
            "key",
            "val",
            "comment",
            "i"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "initValue",
          "container": "IniSection",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "78-107",
          "snippet": "void IniSection::initValue (const string&key,const string&val,const string&comment,int rb)\n{\n    string k = ip->changeCase (key);\n    IniEntry e;\n    IniEntryIdxIterator exi;\n    if (!ip->repeatNames () && (exi = ivalues.find (k)) != ivalues.end ())\n\t{\n\t    IniIterator ei = exi->second;\n\t    // update existing value\n\t    // copy the old value\n\t    e = ei->e ();\n\t    // remove and unindex the old value\n\t    // This means that container needs to be a list, not vector,\n\t    // so that iterators kept in ivalues are still valid\n\t    container.erase (ei);\n\t    ivalues.erase (exi);\n\t}\n    else\n\t{\n\t    // nothing\n\t}\n    // create new value\n    e.init (k, comment, rb, val);\n    // insert it\n    IniContainerElement ce (e);\n    container.push_back (ce);\n    // index it\n    ivalues.insert (IniEntryIndex::value_type (k, --container.end ()));\n\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nIniSection {\n  void IniSection::initValue (const string&key,const string&val,const string&comment,int rb)\n  {\n      string k = ip->changeCase (key);\n      IniEntry e;\n      IniEntryIdxIterator exi;\n      if (!ip->repeatNames () && (exi = ivalues.find (k)) != ivalues.end ())\n  \t{\n  \t    IniIterator ei = exi->second;\n  \t    // update existing value\n  \t    // copy the old value\n  \t    e = ei->e ();\n  \t    // remove and unindex the old value\n  \t    // This means that container needs to be a list, not vector,\n  \t    // so that iterators kept in ivalues are still valid\n  \t    container.erase (ei);\n  \t    ivalues.erase (exi);\n  \t}\n      else\n  \t{\n  \t    // nothing\n  \t}\n      // create new value\n      e.init (k, comment, rb, val);\n      // insert it\n      IniContainerElement ce (e);\n      container.push_back (ce);\n      // index it\n      ivalues.insert (IniEntryIndex::value_type (k, --container.end ()));\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scanner_error",
          "args": [
            "\"%s: values at the top level not allowed.\"",
            "key.c_str ()"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.c_str",
          "args": [],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_sections.erase",
          "args": [
            "b",
            "++it"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_error",
          "args": [
            "\"Unexpected closing %s. Closing section %s.\"",
            "found.c_str()",
            "(*it)->getName()"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "found.c_str",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_sections.end",
          "args": [],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_sections.begin",
          "args": [],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scanner_error",
          "args": [
            "\"Nothing to close.\""
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_sections.front",
          "args": [
            "comment.c_str ()"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comment.c_str",
          "args": [],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_sections.front",
          "args": [],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comment.c_str",
          "args": [],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_sections.push_front",
          "args": [
            "& parent->initSection (found, comment, i)"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent->initSection",
          "args": [
            "found",
            "comment",
            "i"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_sections.front",
          "args": [],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_error",
          "args": [
            "\"Attempt to create nested section %s.\"",
            "found.c_str ()"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "found.c_str",
          "args": [],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_sections.pop_front",
          "args": [],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_sections.pop_front",
          "args": [],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_error",
          "args": [
            "\"Section %s started but section %s is not finished\"",
            "found.c_str()",
            "cur->getName()"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->getName",
          "args": [],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "found.c_str",
          "args": [],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sectionNeedsEnd",
          "args": [
            "cur->getReadBy()"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "sectionNeedsEnd",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.h",
          "lines": "442-442",
          "snippet": "bool sectionNeedsEnd (int i) { return sections[i].end_valid; }",
          "includes": [
            "#include \"IniFile.h\"",
            "#include <set>",
            "#include <vector>",
            "#include <string>",
            "#include <fstream>",
            "#include <iosfwd>",
            "#include <YCP.h>",
            "#include <y2util/RepDef.h>",
            "#include <locale.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include <set>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <iosfwd>\n#include <YCP.h>\n#include <y2util/RepDef.h>\n#include <locale.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nIniParser {\n  bool sectionNeedsEnd (int i) { return sections[i].end_valid; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->getReadBy",
          "args": [],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "getReadBy",
          "container": "IniBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "59-59",
          "snippet": "int getReadBy()          const { return read_by;   }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniBase {\n  int getReadBy()          const { return read_by;   }\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_sections.front",
          "args": [],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_sections.front",
          "args": [
            "key",
            "val",
            "comment",
            "matched_by"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_sections.front",
          "args": [],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_error",
          "args": [
            "\"%s: values at the top level not allowed.\"",
            "key.c_str ()"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.c_str",
          "args": [],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RegexMatch",
          "args": [
            "linecomments[i]",
            "line",
            "0"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_get",
          "args": [
            "line"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_get",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "424-441",
          "snippet": "int IniParser::scanner_get(string&s)\n{\n    if (!scanner)\n\treturn -1;\n    getline (scanner, s);\n    scanner_line++;\n    if (line_can_continue && s.length ())\n    {\n\tstring tmp;\n\twhile (s[s.length()-1] == '\\\\')\n\t{\n\t    getline (scanner, tmp);\n\t    scanner_line++;\n\t    s = s + \"\\n\" + tmp;\n\t}\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::scanner_get(string&s)\n  {\n      if (!scanner)\n  \treturn -1;\n      getline (scanner, s);\n      scanner_line++;\n      if (line_can_continue && s.length ())\n      {\n  \tstring tmp;\n  \twhile (s[s.length()-1] == '\\\\')\n  \t{\n  \t    getline (scanner, tmp);\n  \t    scanner_line++;\n  \t    s = s + \"\\n\" + tmp;\n  \t}\n      }\n      return 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse_helper(IniSection&ini)\n  {\n      string comment = \"\";\n      string key = \"\";\n      string val = \"\";\n      int state = 0;\t\t// 1: precessing a multiline value\n      int matched_by = -1;\n  \n      string line;\n      size_t i;\n  \n      // stack of open sections, innermost at front\n      list<IniSection *> open_sections;\n  \n      //\n      // read line\n      //\n      while (!scanner_get (line))\n  \t{\n  \t    //\n  \t    // check for whole-line comment (always as the first stage)\n  \t    //\n  \t    for (i = 0;i<linecomments.size (); i++)\n  \t\t{\n  \t\t    if (RegexMatch (linecomments[i], line, 0))\n  \t\t\t{\n  \t\t\t    // we have it !!!\n  \t\t\t    comment = comment + line + \"\\n\";\n  \t\t\t    break;\n  \t\t\t}\n  \t\t}\n  \t    if (i<linecomments.size ()) // found? -> next line\n  \t\tcontinue;\n  \n  \t    //\n  \t    // check for comments on line\n  \t    //\n  \t    if (!comments_last)\n  \t\t{\n  \t\t    for (i = 0;i<comments.size (); i++)\n  \t\t\t{\n  \t\t\t    RegexMatch m (comments[i], line);\n  \t\t\t    if (m)\n  \t\t\t    {\n  \t\t\t\t// we have it !!!\n  \t\t\t\tcomment = comment + m[0] + \"\\n\";\n  \t\t\t\tline = m.rest;\n  \t\t\t\tbreak;\n  \t\t\t    }\n  \t\t\t}\n  \t\t}\n  \n  \t    //\n  \t    // are we in broken line?\n  \t    //\n  \t    if (state)\n  \t\t{\n  \t\t    RegexMatch m (params[matched_by].end, line);\n  \t\t    if (m)\n  \t\t    {    \n  \t\t\t// it is the end of broken line\n  \t\t\tstate = 0;\n  \t\t\tval = val + (join_multiline ? \" \" : \"\\n\") + m[1];\n  \t\t\tline = m.rest;\n  \t\t\tif (open_sections.empty ())\n  \t\t\t    {   // we are in toplevel section, going deeper\n  \t\t\t\t// check for toplevel values allowance\n  \t\t\t\tif (!global_values)\n  \t\t\t\t    scanner_error (\"%s: values at the top level not allowed.\", key.c_str ());\n  \t\t\t\telse\n  \t\t\t\t    ini.initValue (key, val, comment, matched_by);\n  \t\t\t    }\n  \t\t\telse {\n  \t\t\t    open_sections.front()->initValue(key, val, comment, matched_by);\n  \t\t\t}\n  \t\t\tcomment = \"\";\n  \t\t    }\n  \t\t    else\n  \t\t\tval = val + (join_multiline ? \" \" : \"\\n\") + line;\n  \t\t}\n  \t    if (!state)\n  \t\t{\n  \t\t    //\n  \t\t    // check for section begin\n  \t\t    //\n  \t\t    {\n  \t\t\tstring found;\n  \n  \t\t\tfor (i = 0; i < sections.size (); i++)\n  \t\t\t    {\n  \t\t\t\tRegexMatch m (sections[i].begin.rx, line);\n  \t\t\t\tif (m)\n  \t\t\t\t{\n  \t\t\t\t    found = m[1];\n  \t\t\t\t    line = m.rest;\n  \t\t\t\t    break;\n  \t\t\t\t}\n  \t\t\t    }\n  \t\t\tif (i < sections.size ())\n  \t\t\t    {\n  \t\t\t\t// section begin found !!! check conditions\n  \t\t\t\tif (!open_sections.empty())\n  \t\t\t\t    {   // there were some sections\n  \t\t\t\t\t// is there need to close previous section?\n  \t\t\t\t\tIniSection * cur = open_sections.front();\n  \t\t\t\t\tif (sectionNeedsEnd(cur->getReadBy()))\n  \t\t\t\t\t    {\n  \t\t\t\t\t\tif(no_nested_sections)\n  \t\t\t\t\t\t    {\n  \t\t\t\t\t\t\tscanner_error (\"Section %s started but section %s is not finished\",\n  \t\t\t\t\t\t\t\t found.c_str(),\n  \t\t\t\t\t\t\t\t cur->getName());\n  \t\t\t\t\t\t\topen_sections.pop_front();\n  \t\t\t\t\t\t    }\n  \t\t\t\t\t    }\n  \t\t\t\t\telse\n  \t\t\t\t\t    open_sections.pop_front();\n  \t\t\t\t    }\n  \n  \t\t\t\tIniSection * parent = NULL;\n  \t\t\t\tif (open_sections.empty())\n  \t\t\t\t    {   // we are in toplevel section, going deeper\n  \t\t\t\t\tparent = &ini;\n  \t\t\t\t    }\n  \t\t\t\telse\n  \t\t\t\t    {\n  \t\t\t\t\tif (no_nested_sections)\n  \t\t\t\t\t    scanner_error (\"Attempt to create nested section %s.\", found.c_str ());\n  \t\t\t\t\telse\n  \t\t\t\t\t{\n  \t\t\t\t\t    parent = open_sections.front();\n  \t\t\t\t\t}\n  \t\t\t\t    }\n  \n  \t\t\t\tif (parent)\n  \t\t\t\t    open_sections.push_front (& parent->initSection (found, comment, i));\n  \n  \t\t\t\tcomment = \"\";\n  \t\t\t    }\n  \t\t    } // check for section begin\n  \n  \t\t    //\n  \t\t    // check for section end\n  \t\t    //\n  \t\t    {\n  \t\t\tstring found;\n  \n  \t\t\tfor (i = 0; i < sections.size (); i++)\n  \t\t\t    {\n  \t\t\t\tif (!sections[i].end_valid)\n  \t\t\t\t    continue;\n  \t\t\t\tRegexMatch m (sections[i].end.rx, line);\n  \t\t\t\tif (m)\n  \t\t\t\t{\n  \t\t\t\t    found = 1 < m.matches.size () ? m[1]: \"\";\n  \t\t\t\t    line = m.rest;\n  \t\t\t\t    break;\n  \t\t\t\t}\n  \t\t\t    }\n  \t\t\tif (i < sections.size ())\n  \t\t\t    {\n  \t\t\t\t// we found new section enclosing which\n  \t\t\t\t// means that we can save possible trailing\n  \t\t\t\t// comment\n  \t\t\t\tif (!comment.empty ())\n  \t\t\t\t    {\n  \t\t\t\t\tif (open_sections.empty())\n  \t\t\t\t\t    ini.setEndComment (comment.c_str ());\n  \t\t\t\t\telse\n  \t\t\t\t\t    {\n  \t\t\t\t\t\topen_sections.front()->setEndComment (comment.c_str ());\n  \t\t\t\t\t    }\n  \t\t\t\t\tcomment = \"\";\n  \t\t\t\t    }\n  \t\t\t\tif (open_sections.empty ())\n  \t\t\t\t    scanner_error (\"Nothing to close.\");\n  \t\t\t\telse {\n  \t\t\t\t    list<IniSection *>::iterator\n  \t\t\t\t\tb = open_sections.begin(),\n  \t\t\t\t\te = open_sections.end(),\n  \t\t\t\t\tit;\n  \n  \t\t\t\t    string name_to_close = found;\n  \t\t\t\t    bool complain = false;\n  \n  \t\t\t\t    if (!name_to_close.empty ())\n  \t\t\t\t    {   // there is a subexpression (section name)\n  \t\t\t\t\tfor (it = b; it != e; ++it) {\n  \t\t\t\t\t    if ((*it)->getName() == name_to_close)\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \n  \t\t\t\t\tif (it == e) {\n  \t\t\t\t\t    // no match by name, try matching by type\n  \t\t\t\t\t    name_to_close = \"\";\n  \t\t\t\t\t    complain = true;\n  \t\t\t\t\t}\n  \t\t\t\t    }\n  \t\t\t\t    \n  \t\t\t\t    if (name_to_close.empty ()) {\n  \t\t\t\t\t// there was no name or we did not find the specified one\n  \t\t\t\t\tfor (it = b; it != e; ++it) {\n  \t\t\t\t\t    if ((*it)->getReadBy() == i)\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \t\t\t\t\tif (it == e) {\n  \t\t\t\t\t    // not even a match by type\n  \t\t\t\t\t    it = b;\n  \t\t\t\t\t}\n  \n  \t\t\t\t\tif (complain)\n  \t\t\t\t\t    scanner_error (\"Unexpected closing %s. Closing section %s.\", found.c_str(), (*it)->getName());\n  \t\t\t\t    }\n  \t\t\t\t    open_sections.erase (b, ++it);\n  \t\t\t\t}\n  \t\t\t    }\n  \t\t    }\n  \n  \t\t    //\n  \t\t    // check for line\n  \t\t    //\n  \t\t    {\n  \t\t\tstring key,val;\n  \t\t\tfor (i = 0; i < params.size (); i++)\n  \t\t\t{\n  \t\t\t    RegexMatch m (params[i].line.rx, line);\n  \t\t\t    if (m)\n  \t\t\t    {\n  \t\t\t\tkey = m[1];\n  \t\t\t\tval = m[2];\n  \t\t\t\tline = m.rest;\n  \t\t\t\tbreak;\n  \t\t\t    }\t\t\t\t\n  \t\t\t}\n  \t\t\tif (i != params.size ())\n  \t\t\t    {\n  \t\t\t\tif (open_sections.empty())\n  \t\t\t\t    {   // we are in toplevel section, going deeper\n  \t\t\t\t\t// check for toplevel values allowance\n  \t\t\t\t\tif (!global_values)\n  \t\t\t\t\t    scanner_error (\"%s: values at the top level not allowed.\", key.c_str ());\n  \t\t\t\t\telse\n  \t\t\t\t\t    ini.initValue (key, val, comment, i);\n  \t\t\t\t    }\n  \t\t\t\telse\n  \t\t\t\t    {\n  \t\t\t\t\topen_sections.front()->initValue(key, val, comment, i);\n  \t\t\t\t    }\n  \t\t\t\tcomment = \"\";\n  \t\t\t    }\n  \t\t    }\n  \n  \t\t    //\n  \t\t    // check for broken line\n  \t\t    //\n  \t\t    {\n  \t\t\tfor (i = 0; i < params.size (); i++)\n  \t\t\t{\n  \t\t\t    if (!params[i].multiline_valid)\n  \t\t\t\tcontinue;\n  \t\t\t    RegexMatch m (params[i].begin, line);\n  \t\t\t    if (m)\n  \t\t\t    {\n  \t\t\t\t// broken line\n  \t\t\t\tkey = m[1];\n  \t\t\t\tval = m[2];\n  \t\t\t\tline = m.rest;\n  \t\t\t\tmatched_by = i;\n  \t\t\t\tstate = 1;\n  \t\t\t\tbreak;\n  \t\t\t    }\n  \t\t\t}\n  \t\t    }\n  \n  \t\t    //\n  \t\t    // check for comments on line\n  \t\t    //\n  \t\t    if (comments_last && !comments.empty ())\n  \t\t    {\n  \t\t\tfor (i = 0; i < comments.size (); i++)\n  \t\t\t{\n  \t\t\t    RegexMatch m (comments[i], line);\n  \t\t\t    if (m)\n  \t\t\t    {\n  \t\t\t\t// we have it !!!\n  \t\t\t\tcomment = comment + m[0] + \"\\n\";\n  \t\t\t\tline = m.rest;\n  \t\t\t\tbreak;\n  \t\t\t    }\n  \t\t\t}\n  \t\t    }\n  \t\t    //\n  \t\t    // if line is not empty, report it\n  \t\t    //\n  \t\t    {\n  \t\t\tif (!onlySpaces (line.c_str()))\n  \t\t\t    scanner_error (\"Extra characters: %s\", line.c_str ());\n  \t\t    }\n  \t\t}\n  \t}\n      if (!comment.empty ())\n      {\n  \tif (!no_finalcomment_kill)\n  \t{\n  \t    // kill empty lines at the end of comment\n  \t    int i = comment.length ();\n  \t    const char*p = comment.c_str () + i - 1;\n  \t    while (i)\n  \t    {\n  \t\tif ('\\n' != *p)\n  \t\t    break;\n  \t\ti --;\n  \t\tp --;\n  \t    }\n  \t    if (i > 0)\n  \t\ti++;\n  \t    comment.resize (i);\n  \t}\n  \tini.setEndComment (comment.c_str ());\n      }\n  \n      return 0;\n  }\n}"
  },
  {
    "function_name": "parse",
    "container": "IniParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "484-562",
    "snippet": "int IniParser::parse()\n{\n    if (multiple_files)\n    {\n\tglob_t do_files;\n\tint len = files.size ();\n\tint flags = 0;\n\tfor (int i = 0;i<len;i++)\n\t{\n\t    glob (files[i].c_str (),flags, NULL, &do_files);\n\t    flags = GLOB_APPEND;\n\t}\n\tchar**f = do_files.gl_pathv;\n\tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n\t{\n\t    int section_index = -1;\n\t    string section_name = *f;\n\t    //FIXME: create function out of it.\n\t    // do we have name rewrite rules?\n\t    for (size_t j = 0; j < rewrites.size (); j++)\n\t\t{\n\t\t    RegexMatch m (rewrites[j].rx, section_name);\n\t\t    if (m)\n\t\t    {\n\t\t\tsection_index = j;\n\t\t\tsection_name = m[1];\n\t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    // do we know about the file?\n\t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n\t    if (ff == multi_files.end())\n\t    {\n\t\t// new file\n\t\tif (scanner_start (*f))\n\t\t    y2error (\"Cannot open %s.\", *f);\n\t\telse\n\t\t{\n\t\t    FileDescr fdsc (*f);\n\t\t    multi_files[*f] = fdsc;\n\t\t    inifile.initSection (section_name, \"\", -1, section_index);\n\t\t    parse_helper(inifile.getSection(section_name.c_str()));\n\t\t    scanner_stop();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif ((*ff).second.changed ())\n\t\t{\n\t\t    if (scanner_start (*f))\n\t\t\ty2error (\"Cannot open %s.\", *f);\n\t\t    else\n\t\t    {\n\t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n\t\t\tFileDescr fdsc (*f);\n\t\t\tmulti_files [*f] = fdsc;\n\t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n\t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n\t\t\tscanner_stop();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tif (scanner_start (file.c_str()))\n\t    {\n\t\ty2error (\"Can not open %s.\", file.c_str());\n\t\treturn -1;\n\t    }\n\tparse_helper(inifile);\n\tscanner_stop();\n\ttimestamp = getTimeStamp ();\n    }\n    return 0;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getTimeStamp",
          "args": [],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "getTimeStamp",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "913-927",
          "snippet": "time_t IniParser::getTimeStamp()\n{\n    struct stat st;\n    if (multiple_files)\n    {\n\tprintf (\"bad call of getTimeStamp aborting. FIXME\\n\");//FIXME\n\tabort ();\n    }\n    if (stat(file.c_str(), &st))\n    {\n\ty2error(\"Unable to stat '%s': %s\", file.c_str(), strerror(errno));\n\treturn 0;\n    }\n    return st.st_mtime;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  time_t IniParser::getTimeStamp()\n  {\n      struct stat st;\n      if (multiple_files)\n      {\n  \tprintf (\"bad call of getTimeStamp aborting. FIXME\\n\");//FIXME\n  \tabort ();\n      }\n      if (stat(file.c_str(), &st))\n      {\n  \ty2error(\"Unable to stat '%s': %s\", file.c_str(), strerror(errno));\n  \treturn 0;\n      }\n      return st.st_mtime;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scanner_stop",
          "args": [],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_stop",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "419-423",
          "snippet": "void IniParser::scanner_stop()\n{\n    scanner.close();\n    scanner.clear();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  void IniParser::scanner_stop()\n  {\n      scanner.close();\n      scanner.clear();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_helper",
          "args": [
            "inifile"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "parse_helper",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "564-886",
          "snippet": "int IniParser::parse_helper(IniSection&ini)\n{\n    string comment = \"\";\n    string key = \"\";\n    string val = \"\";\n    int state = 0;\t\t// 1: precessing a multiline value\n    int matched_by = -1;\n\n    string line;\n    size_t i;\n\n    // stack of open sections, innermost at front\n    list<IniSection *> open_sections;\n\n    //\n    // read line\n    //\n    while (!scanner_get (line))\n\t{\n\t    //\n\t    // check for whole-line comment (always as the first stage)\n\t    //\n\t    for (i = 0;i<linecomments.size (); i++)\n\t\t{\n\t\t    if (RegexMatch (linecomments[i], line, 0))\n\t\t\t{\n\t\t\t    // we have it !!!\n\t\t\t    comment = comment + line + \"\\n\";\n\t\t\t    break;\n\t\t\t}\n\t\t}\n\t    if (i<linecomments.size ()) // found? -> next line\n\t\tcontinue;\n\n\t    //\n\t    // check for comments on line\n\t    //\n\t    if (!comments_last)\n\t\t{\n\t\t    for (i = 0;i<comments.size (); i++)\n\t\t\t{\n\t\t\t    RegexMatch m (comments[i], line);\n\t\t\t    if (m)\n\t\t\t    {\n\t\t\t\t// we have it !!!\n\t\t\t\tcomment = comment + m[0] + \"\\n\";\n\t\t\t\tline = m.rest;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t}\n\n\t    //\n\t    // are we in broken line?\n\t    //\n\t    if (state)\n\t\t{\n\t\t    RegexMatch m (params[matched_by].end, line);\n\t\t    if (m)\n\t\t    {    \n\t\t\t// it is the end of broken line\n\t\t\tstate = 0;\n\t\t\tval = val + (join_multiline ? \" \" : \"\\n\") + m[1];\n\t\t\tline = m.rest;\n\t\t\tif (open_sections.empty ())\n\t\t\t    {   // we are in toplevel section, going deeper\n\t\t\t\t// check for toplevel values allowance\n\t\t\t\tif (!global_values)\n\t\t\t\t    scanner_error (\"%s: values at the top level not allowed.\", key.c_str ());\n\t\t\t\telse\n\t\t\t\t    ini.initValue (key, val, comment, matched_by);\n\t\t\t    }\n\t\t\telse {\n\t\t\t    open_sections.front()->initValue(key, val, comment, matched_by);\n\t\t\t}\n\t\t\tcomment = \"\";\n\t\t    }\n\t\t    else\n\t\t\tval = val + (join_multiline ? \" \" : \"\\n\") + line;\n\t\t}\n\t    if (!state)\n\t\t{\n\t\t    //\n\t\t    // check for section begin\n\t\t    //\n\t\t    {\n\t\t\tstring found;\n\n\t\t\tfor (i = 0; i < sections.size (); i++)\n\t\t\t    {\n\t\t\t\tRegexMatch m (sections[i].begin.rx, line);\n\t\t\t\tif (m)\n\t\t\t\t{\n\t\t\t\t    found = m[1];\n\t\t\t\t    line = m.rest;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\tif (i < sections.size ())\n\t\t\t    {\n\t\t\t\t// section begin found !!! check conditions\n\t\t\t\tif (!open_sections.empty())\n\t\t\t\t    {   // there were some sections\n\t\t\t\t\t// is there need to close previous section?\n\t\t\t\t\tIniSection * cur = open_sections.front();\n\t\t\t\t\tif (sectionNeedsEnd(cur->getReadBy()))\n\t\t\t\t\t    {\n\t\t\t\t\t\tif(no_nested_sections)\n\t\t\t\t\t\t    {\n\t\t\t\t\t\t\tscanner_error (\"Section %s started but section %s is not finished\",\n\t\t\t\t\t\t\t\t found.c_str(),\n\t\t\t\t\t\t\t\t cur->getName());\n\t\t\t\t\t\t\topen_sections.pop_front();\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t    open_sections.pop_front();\n\t\t\t\t    }\n\n\t\t\t\tIniSection * parent = NULL;\n\t\t\t\tif (open_sections.empty())\n\t\t\t\t    {   // we are in toplevel section, going deeper\n\t\t\t\t\tparent = &ini;\n\t\t\t\t    }\n\t\t\t\telse\n\t\t\t\t    {\n\t\t\t\t\tif (no_nested_sections)\n\t\t\t\t\t    scanner_error (\"Attempt to create nested section %s.\", found.c_str ());\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t    parent = open_sections.front();\n\t\t\t\t\t}\n\t\t\t\t    }\n\n\t\t\t\tif (parent)\n\t\t\t\t    open_sections.push_front (& parent->initSection (found, comment, i));\n\n\t\t\t\tcomment = \"\";\n\t\t\t    }\n\t\t    } // check for section begin\n\n\t\t    //\n\t\t    // check for section end\n\t\t    //\n\t\t    {\n\t\t\tstring found;\n\n\t\t\tfor (i = 0; i < sections.size (); i++)\n\t\t\t    {\n\t\t\t\tif (!sections[i].end_valid)\n\t\t\t\t    continue;\n\t\t\t\tRegexMatch m (sections[i].end.rx, line);\n\t\t\t\tif (m)\n\t\t\t\t{\n\t\t\t\t    found = 1 < m.matches.size () ? m[1]: \"\";\n\t\t\t\t    line = m.rest;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\tif (i < sections.size ())\n\t\t\t    {\n\t\t\t\t// we found new section enclosing which\n\t\t\t\t// means that we can save possible trailing\n\t\t\t\t// comment\n\t\t\t\tif (!comment.empty ())\n\t\t\t\t    {\n\t\t\t\t\tif (open_sections.empty())\n\t\t\t\t\t    ini.setEndComment (comment.c_str ());\n\t\t\t\t\telse\n\t\t\t\t\t    {\n\t\t\t\t\t\topen_sections.front()->setEndComment (comment.c_str ());\n\t\t\t\t\t    }\n\t\t\t\t\tcomment = \"\";\n\t\t\t\t    }\n\t\t\t\tif (open_sections.empty ())\n\t\t\t\t    scanner_error (\"Nothing to close.\");\n\t\t\t\telse {\n\t\t\t\t    list<IniSection *>::iterator\n\t\t\t\t\tb = open_sections.begin(),\n\t\t\t\t\te = open_sections.end(),\n\t\t\t\t\tit;\n\n\t\t\t\t    string name_to_close = found;\n\t\t\t\t    bool complain = false;\n\n\t\t\t\t    if (!name_to_close.empty ())\n\t\t\t\t    {   // there is a subexpression (section name)\n\t\t\t\t\tfor (it = b; it != e; ++it) {\n\t\t\t\t\t    if ((*it)->getName() == name_to_close)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (it == e) {\n\t\t\t\t\t    // no match by name, try matching by type\n\t\t\t\t\t    name_to_close = \"\";\n\t\t\t\t\t    complain = true;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    \n\t\t\t\t    if (name_to_close.empty ()) {\n\t\t\t\t\t// there was no name or we did not find the specified one\n\t\t\t\t\tfor (it = b; it != e; ++it) {\n\t\t\t\t\t    if ((*it)->getReadBy() == i)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (it == e) {\n\t\t\t\t\t    // not even a match by type\n\t\t\t\t\t    it = b;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (complain)\n\t\t\t\t\t    scanner_error (\"Unexpected closing %s. Closing section %s.\", found.c_str(), (*it)->getName());\n\t\t\t\t    }\n\t\t\t\t    open_sections.erase (b, ++it);\n\t\t\t\t}\n\t\t\t    }\n\t\t    }\n\n\t\t    //\n\t\t    // check for line\n\t\t    //\n\t\t    {\n\t\t\tstring key,val;\n\t\t\tfor (i = 0; i < params.size (); i++)\n\t\t\t{\n\t\t\t    RegexMatch m (params[i].line.rx, line);\n\t\t\t    if (m)\n\t\t\t    {\n\t\t\t\tkey = m[1];\n\t\t\t\tval = m[2];\n\t\t\t\tline = m.rest;\n\t\t\t\tbreak;\n\t\t\t    }\t\t\t\t\n\t\t\t}\n\t\t\tif (i != params.size ())\n\t\t\t    {\n\t\t\t\tif (open_sections.empty())\n\t\t\t\t    {   // we are in toplevel section, going deeper\n\t\t\t\t\t// check for toplevel values allowance\n\t\t\t\t\tif (!global_values)\n\t\t\t\t\t    scanner_error (\"%s: values at the top level not allowed.\", key.c_str ());\n\t\t\t\t\telse\n\t\t\t\t\t    ini.initValue (key, val, comment, i);\n\t\t\t\t    }\n\t\t\t\telse\n\t\t\t\t    {\n\t\t\t\t\topen_sections.front()->initValue(key, val, comment, i);\n\t\t\t\t    }\n\t\t\t\tcomment = \"\";\n\t\t\t    }\n\t\t    }\n\n\t\t    //\n\t\t    // check for broken line\n\t\t    //\n\t\t    {\n\t\t\tfor (i = 0; i < params.size (); i++)\n\t\t\t{\n\t\t\t    if (!params[i].multiline_valid)\n\t\t\t\tcontinue;\n\t\t\t    RegexMatch m (params[i].begin, line);\n\t\t\t    if (m)\n\t\t\t    {\n\t\t\t\t// broken line\n\t\t\t\tkey = m[1];\n\t\t\t\tval = m[2];\n\t\t\t\tline = m.rest;\n\t\t\t\tmatched_by = i;\n\t\t\t\tstate = 1;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\n\t\t    //\n\t\t    // check for comments on line\n\t\t    //\n\t\t    if (comments_last && !comments.empty ())\n\t\t    {\n\t\t\tfor (i = 0; i < comments.size (); i++)\n\t\t\t{\n\t\t\t    RegexMatch m (comments[i], line);\n\t\t\t    if (m)\n\t\t\t    {\n\t\t\t\t// we have it !!!\n\t\t\t\tcomment = comment + m[0] + \"\\n\";\n\t\t\t\tline = m.rest;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    //\n\t\t    // if line is not empty, report it\n\t\t    //\n\t\t    {\n\t\t\tif (!onlySpaces (line.c_str()))\n\t\t\t    scanner_error (\"Extra characters: %s\", line.c_str ());\n\t\t    }\n\t\t}\n\t}\n    if (!comment.empty ())\n    {\n\tif (!no_finalcomment_kill)\n\t{\n\t    // kill empty lines at the end of comment\n\t    int i = comment.length ();\n\t    const char*p = comment.c_str () + i - 1;\n\t    while (i)\n\t    {\n\t\tif ('\\n' != *p)\n\t\t    break;\n\t\ti --;\n\t\tp --;\n\t    }\n\t    if (i > 0)\n\t\ti++;\n\t    comment.resize (i);\n\t}\n\tini.setEndComment (comment.c_str ());\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse_helper(IniSection&ini)\n  {\n      string comment = \"\";\n      string key = \"\";\n      string val = \"\";\n      int state = 0;\t\t// 1: precessing a multiline value\n      int matched_by = -1;\n  \n      string line;\n      size_t i;\n  \n      // stack of open sections, innermost at front\n      list<IniSection *> open_sections;\n  \n      //\n      // read line\n      //\n      while (!scanner_get (line))\n  \t{\n  \t    //\n  \t    // check for whole-line comment (always as the first stage)\n  \t    //\n  \t    for (i = 0;i<linecomments.size (); i++)\n  \t\t{\n  \t\t    if (RegexMatch (linecomments[i], line, 0))\n  \t\t\t{\n  \t\t\t    // we have it !!!\n  \t\t\t    comment = comment + line + \"\\n\";\n  \t\t\t    break;\n  \t\t\t}\n  \t\t}\n  \t    if (i<linecomments.size ()) // found? -> next line\n  \t\tcontinue;\n  \n  \t    //\n  \t    // check for comments on line\n  \t    //\n  \t    if (!comments_last)\n  \t\t{\n  \t\t    for (i = 0;i<comments.size (); i++)\n  \t\t\t{\n  \t\t\t    RegexMatch m (comments[i], line);\n  \t\t\t    if (m)\n  \t\t\t    {\n  \t\t\t\t// we have it !!!\n  \t\t\t\tcomment = comment + m[0] + \"\\n\";\n  \t\t\t\tline = m.rest;\n  \t\t\t\tbreak;\n  \t\t\t    }\n  \t\t\t}\n  \t\t}\n  \n  \t    //\n  \t    // are we in broken line?\n  \t    //\n  \t    if (state)\n  \t\t{\n  \t\t    RegexMatch m (params[matched_by].end, line);\n  \t\t    if (m)\n  \t\t    {    \n  \t\t\t// it is the end of broken line\n  \t\t\tstate = 0;\n  \t\t\tval = val + (join_multiline ? \" \" : \"\\n\") + m[1];\n  \t\t\tline = m.rest;\n  \t\t\tif (open_sections.empty ())\n  \t\t\t    {   // we are in toplevel section, going deeper\n  \t\t\t\t// check for toplevel values allowance\n  \t\t\t\tif (!global_values)\n  \t\t\t\t    scanner_error (\"%s: values at the top level not allowed.\", key.c_str ());\n  \t\t\t\telse\n  \t\t\t\t    ini.initValue (key, val, comment, matched_by);\n  \t\t\t    }\n  \t\t\telse {\n  \t\t\t    open_sections.front()->initValue(key, val, comment, matched_by);\n  \t\t\t}\n  \t\t\tcomment = \"\";\n  \t\t    }\n  \t\t    else\n  \t\t\tval = val + (join_multiline ? \" \" : \"\\n\") + line;\n  \t\t}\n  \t    if (!state)\n  \t\t{\n  \t\t    //\n  \t\t    // check for section begin\n  \t\t    //\n  \t\t    {\n  \t\t\tstring found;\n  \n  \t\t\tfor (i = 0; i < sections.size (); i++)\n  \t\t\t    {\n  \t\t\t\tRegexMatch m (sections[i].begin.rx, line);\n  \t\t\t\tif (m)\n  \t\t\t\t{\n  \t\t\t\t    found = m[1];\n  \t\t\t\t    line = m.rest;\n  \t\t\t\t    break;\n  \t\t\t\t}\n  \t\t\t    }\n  \t\t\tif (i < sections.size ())\n  \t\t\t    {\n  \t\t\t\t// section begin found !!! check conditions\n  \t\t\t\tif (!open_sections.empty())\n  \t\t\t\t    {   // there were some sections\n  \t\t\t\t\t// is there need to close previous section?\n  \t\t\t\t\tIniSection * cur = open_sections.front();\n  \t\t\t\t\tif (sectionNeedsEnd(cur->getReadBy()))\n  \t\t\t\t\t    {\n  \t\t\t\t\t\tif(no_nested_sections)\n  \t\t\t\t\t\t    {\n  \t\t\t\t\t\t\tscanner_error (\"Section %s started but section %s is not finished\",\n  \t\t\t\t\t\t\t\t found.c_str(),\n  \t\t\t\t\t\t\t\t cur->getName());\n  \t\t\t\t\t\t\topen_sections.pop_front();\n  \t\t\t\t\t\t    }\n  \t\t\t\t\t    }\n  \t\t\t\t\telse\n  \t\t\t\t\t    open_sections.pop_front();\n  \t\t\t\t    }\n  \n  \t\t\t\tIniSection * parent = NULL;\n  \t\t\t\tif (open_sections.empty())\n  \t\t\t\t    {   // we are in toplevel section, going deeper\n  \t\t\t\t\tparent = &ini;\n  \t\t\t\t    }\n  \t\t\t\telse\n  \t\t\t\t    {\n  \t\t\t\t\tif (no_nested_sections)\n  \t\t\t\t\t    scanner_error (\"Attempt to create nested section %s.\", found.c_str ());\n  \t\t\t\t\telse\n  \t\t\t\t\t{\n  \t\t\t\t\t    parent = open_sections.front();\n  \t\t\t\t\t}\n  \t\t\t\t    }\n  \n  \t\t\t\tif (parent)\n  \t\t\t\t    open_sections.push_front (& parent->initSection (found, comment, i));\n  \n  \t\t\t\tcomment = \"\";\n  \t\t\t    }\n  \t\t    } // check for section begin\n  \n  \t\t    //\n  \t\t    // check for section end\n  \t\t    //\n  \t\t    {\n  \t\t\tstring found;\n  \n  \t\t\tfor (i = 0; i < sections.size (); i++)\n  \t\t\t    {\n  \t\t\t\tif (!sections[i].end_valid)\n  \t\t\t\t    continue;\n  \t\t\t\tRegexMatch m (sections[i].end.rx, line);\n  \t\t\t\tif (m)\n  \t\t\t\t{\n  \t\t\t\t    found = 1 < m.matches.size () ? m[1]: \"\";\n  \t\t\t\t    line = m.rest;\n  \t\t\t\t    break;\n  \t\t\t\t}\n  \t\t\t    }\n  \t\t\tif (i < sections.size ())\n  \t\t\t    {\n  \t\t\t\t// we found new section enclosing which\n  \t\t\t\t// means that we can save possible trailing\n  \t\t\t\t// comment\n  \t\t\t\tif (!comment.empty ())\n  \t\t\t\t    {\n  \t\t\t\t\tif (open_sections.empty())\n  \t\t\t\t\t    ini.setEndComment (comment.c_str ());\n  \t\t\t\t\telse\n  \t\t\t\t\t    {\n  \t\t\t\t\t\topen_sections.front()->setEndComment (comment.c_str ());\n  \t\t\t\t\t    }\n  \t\t\t\t\tcomment = \"\";\n  \t\t\t\t    }\n  \t\t\t\tif (open_sections.empty ())\n  \t\t\t\t    scanner_error (\"Nothing to close.\");\n  \t\t\t\telse {\n  \t\t\t\t    list<IniSection *>::iterator\n  \t\t\t\t\tb = open_sections.begin(),\n  \t\t\t\t\te = open_sections.end(),\n  \t\t\t\t\tit;\n  \n  \t\t\t\t    string name_to_close = found;\n  \t\t\t\t    bool complain = false;\n  \n  \t\t\t\t    if (!name_to_close.empty ())\n  \t\t\t\t    {   // there is a subexpression (section name)\n  \t\t\t\t\tfor (it = b; it != e; ++it) {\n  \t\t\t\t\t    if ((*it)->getName() == name_to_close)\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \n  \t\t\t\t\tif (it == e) {\n  \t\t\t\t\t    // no match by name, try matching by type\n  \t\t\t\t\t    name_to_close = \"\";\n  \t\t\t\t\t    complain = true;\n  \t\t\t\t\t}\n  \t\t\t\t    }\n  \t\t\t\t    \n  \t\t\t\t    if (name_to_close.empty ()) {\n  \t\t\t\t\t// there was no name or we did not find the specified one\n  \t\t\t\t\tfor (it = b; it != e; ++it) {\n  \t\t\t\t\t    if ((*it)->getReadBy() == i)\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \t\t\t\t\tif (it == e) {\n  \t\t\t\t\t    // not even a match by type\n  \t\t\t\t\t    it = b;\n  \t\t\t\t\t}\n  \n  \t\t\t\t\tif (complain)\n  \t\t\t\t\t    scanner_error (\"Unexpected closing %s. Closing section %s.\", found.c_str(), (*it)->getName());\n  \t\t\t\t    }\n  \t\t\t\t    open_sections.erase (b, ++it);\n  \t\t\t\t}\n  \t\t\t    }\n  \t\t    }\n  \n  \t\t    //\n  \t\t    // check for line\n  \t\t    //\n  \t\t    {\n  \t\t\tstring key,val;\n  \t\t\tfor (i = 0; i < params.size (); i++)\n  \t\t\t{\n  \t\t\t    RegexMatch m (params[i].line.rx, line);\n  \t\t\t    if (m)\n  \t\t\t    {\n  \t\t\t\tkey = m[1];\n  \t\t\t\tval = m[2];\n  \t\t\t\tline = m.rest;\n  \t\t\t\tbreak;\n  \t\t\t    }\t\t\t\t\n  \t\t\t}\n  \t\t\tif (i != params.size ())\n  \t\t\t    {\n  \t\t\t\tif (open_sections.empty())\n  \t\t\t\t    {   // we are in toplevel section, going deeper\n  \t\t\t\t\t// check for toplevel values allowance\n  \t\t\t\t\tif (!global_values)\n  \t\t\t\t\t    scanner_error (\"%s: values at the top level not allowed.\", key.c_str ());\n  \t\t\t\t\telse\n  \t\t\t\t\t    ini.initValue (key, val, comment, i);\n  \t\t\t\t    }\n  \t\t\t\telse\n  \t\t\t\t    {\n  \t\t\t\t\topen_sections.front()->initValue(key, val, comment, i);\n  \t\t\t\t    }\n  \t\t\t\tcomment = \"\";\n  \t\t\t    }\n  \t\t    }\n  \n  \t\t    //\n  \t\t    // check for broken line\n  \t\t    //\n  \t\t    {\n  \t\t\tfor (i = 0; i < params.size (); i++)\n  \t\t\t{\n  \t\t\t    if (!params[i].multiline_valid)\n  \t\t\t\tcontinue;\n  \t\t\t    RegexMatch m (params[i].begin, line);\n  \t\t\t    if (m)\n  \t\t\t    {\n  \t\t\t\t// broken line\n  \t\t\t\tkey = m[1];\n  \t\t\t\tval = m[2];\n  \t\t\t\tline = m.rest;\n  \t\t\t\tmatched_by = i;\n  \t\t\t\tstate = 1;\n  \t\t\t\tbreak;\n  \t\t\t    }\n  \t\t\t}\n  \t\t    }\n  \n  \t\t    //\n  \t\t    // check for comments on line\n  \t\t    //\n  \t\t    if (comments_last && !comments.empty ())\n  \t\t    {\n  \t\t\tfor (i = 0; i < comments.size (); i++)\n  \t\t\t{\n  \t\t\t    RegexMatch m (comments[i], line);\n  \t\t\t    if (m)\n  \t\t\t    {\n  \t\t\t\t// we have it !!!\n  \t\t\t\tcomment = comment + m[0] + \"\\n\";\n  \t\t\t\tline = m.rest;\n  \t\t\t\tbreak;\n  \t\t\t    }\n  \t\t\t}\n  \t\t    }\n  \t\t    //\n  \t\t    // if line is not empty, report it\n  \t\t    //\n  \t\t    {\n  \t\t\tif (!onlySpaces (line.c_str()))\n  \t\t\t    scanner_error (\"Extra characters: %s\", line.c_str ());\n  \t\t    }\n  \t\t}\n  \t}\n      if (!comment.empty ())\n      {\n  \tif (!no_finalcomment_kill)\n  \t{\n  \t    // kill empty lines at the end of comment\n  \t    int i = comment.length ();\n  \t    const char*p = comment.c_str () + i - 1;\n  \t    while (i)\n  \t    {\n  \t\tif ('\\n' != *p)\n  \t\t    break;\n  \t\ti --;\n  \t\tp --;\n  \t    }\n  \t    if (i > 0)\n  \t\ti++;\n  \t    comment.resize (i);\n  \t}\n  \tini.setEndComment (comment.c_str ());\n      }\n  \n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Can not open %s.\"",
            "file.c_str()"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.c_str",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_start",
          "args": [
            "file.c_str()"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_start",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "410-418",
          "snippet": "int IniParser::scanner_start(const char*fn)\n{\n    scanner.open(fn);\n    scanner_file = fn;\n    scanner_line = 0;\n    if (!scanner.is_open())\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::scanner_start(const char*fn)\n  {\n      scanner.open(fn);\n      scanner_file = fn;\n      scanner_line = 0;\n      if (!scanner.is_open())\n          return -1;\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file.c_str",
          "args": [],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inifile.getSection",
          "args": [
            "section_name.c_str()"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "section_name.c_str",
          "args": [],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inifile.initSection",
          "args": [
            "section_name",
            "\"\"",
            "-1",
            "section_index"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"File %s changed. Reloading.\"",
            "*f"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Cannot open %s.\"",
            "*f"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inifile.getSection",
          "args": [
            "section_name.c_str()"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "section_name.c_str",
          "args": [],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inifile.initSection",
          "args": [
            "section_name",
            "\"\"",
            "-1",
            "section_index"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Cannot open %s.\"",
            "*f"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "multi_files.end",
          "args": [],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "multi_files.find",
          "args": [
            "*f"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Rewriting %s to %s\"",
            "*f",
            "section_name.c_str()"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "section_name.c_str",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rewrites.size",
          "args": [],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "glob",
          "args": [
            "files[i].c_str ()",
            "flags",
            "NULL",
            "&do_files"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files[i].c_str",
          "args": [],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse()\n  {\n      if (multiple_files)\n      {\n  \tglob_t do_files;\n  \tint len = files.size ();\n  \tint flags = 0;\n  \tfor (int i = 0;i<len;i++)\n  \t{\n  \t    glob (files[i].c_str (),flags, NULL, &do_files);\n  \t    flags = GLOB_APPEND;\n  \t}\n  \tchar**f = do_files.gl_pathv;\n  \tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n  \t{\n  \t    int section_index = -1;\n  \t    string section_name = *f;\n  \t    //FIXME: create function out of it.\n  \t    // do we have name rewrite rules?\n  \t    for (size_t j = 0; j < rewrites.size (); j++)\n  \t\t{\n  \t\t    RegexMatch m (rewrites[j].rx, section_name);\n  \t\t    if (m)\n  \t\t    {\n  \t\t\tsection_index = j;\n  \t\t\tsection_name = m[1];\n  \t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \n  \t    // do we know about the file?\n  \t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n  \t    if (ff == multi_files.end())\n  \t    {\n  \t\t// new file\n  \t\tif (scanner_start (*f))\n  \t\t    y2error (\"Cannot open %s.\", *f);\n  \t\telse\n  \t\t{\n  \t\t    FileDescr fdsc (*f);\n  \t\t    multi_files[*f] = fdsc;\n  \t\t    inifile.initSection (section_name, \"\", -1, section_index);\n  \t\t    parse_helper(inifile.getSection(section_name.c_str()));\n  \t\t    scanner_stop();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif ((*ff).second.changed ())\n  \t\t{\n  \t\t    if (scanner_start (*f))\n  \t\t\ty2error (\"Cannot open %s.\", *f);\n  \t\t    else\n  \t\t    {\n  \t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n  \t\t\tFileDescr fdsc (*f);\n  \t\t\tmulti_files [*f] = fdsc;\n  \t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n  \t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n  \t\t\tscanner_stop();\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n      else\n      {\n  \tif (scanner_start (file.c_str()))\n  \t    {\n  \t\ty2error (\"Can not open %s.\", file.c_str());\n  \t\treturn -1;\n  \t    }\n  \tparse_helper(inifile);\n  \tscanner_stop();\n  \ttimestamp = getTimeStamp ();\n      }\n      return 0;\n  }\n}"
  },
  {
    "function_name": "FileDescr",
    "container": "FileDescr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "471-482",
    "snippet": "FileDescr::FileDescr (char*fn_)\n{\n    fn = fn_;\n    sn = fn_;\n    struct stat st;\n    if (stat(fn_, &st))\n    {\n\ty2error(\"Unable to stat '%s': %s\", fn_, strerror(errno));\n\ttimestamp = 0;\n    }\n    timestamp = st.st_mtime;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unable to stat '%s': %s\"",
            "fn_",
            "strerror(errno)"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fn_",
            "&st"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nFileDescr {\n  FileDescr::FileDescr (char*fn_)\n  {\n      fn = fn_;\n      sn = fn_;\n      struct stat st;\n      if (stat(fn_, &st))\n      {\n  \ty2error(\"Unable to stat '%s': %s\", fn_, strerror(errno));\n  \ttimestamp = 0;\n      }\n      timestamp = st.st_mtime;\n  }\n}"
  },
  {
    "function_name": "changed",
    "container": "FileDescr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "455-469",
    "snippet": "bool FileDescr::changed ()\n{\n    struct stat st;\n    if (stat(fn.c_str(), &st))\n    {\n\ty2error(\"Unable to stat '%s': %s\", fn.c_str(), strerror(errno));\n\treturn false;\n    }\n    if (timestamp != st.st_mtime)\n    {\n\ttimestamp = st.st_mtime;\n\treturn true;\n    }\n    return false;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unable to stat '%s': %s\"",
            "fn.c_str()",
            "strerror(errno)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn.c_str",
          "args": [],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fn.c_str()",
            "&st"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn.c_str",
          "args": [],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nFileDescr {\n  bool FileDescr::changed ()\n  {\n      struct stat st;\n      if (stat(fn.c_str(), &st))\n      {\n  \ty2error(\"Unable to stat '%s': %s\", fn.c_str(), strerror(errno));\n  \treturn false;\n      }\n      if (timestamp != st.st_mtime)\n      {\n  \ttimestamp = st.st_mtime;\n  \treturn true;\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "StripLine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "446-453",
    "snippet": "void StripLine (string&l, regmatch_t&r)\n{\n    string out;\n    if (r.rm_so>1)\n\tout = l.substr (0,r.rm_so);\n    out = out + l.substr(r.rm_eo);\n    l = out;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "l.substr",
          "args": [
            "r.rm_eo"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l.substr",
          "args": [
            "0",
            "r.rm_so"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nvoid StripLine (string&l, regmatch_t&r)\n{\n    string out;\n    if (r.rm_so>1)\n\tout = l.substr (0,r.rm_so);\n    out = out + l.substr(r.rm_eo);\n    l = out;\n}"
  },
  {
    "function_name": "scanner_get",
    "container": "IniParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "424-441",
    "snippet": "int IniParser::scanner_get(string&s)\n{\n    if (!scanner)\n\treturn -1;\n    getline (scanner, s);\n    scanner_line++;\n    if (line_can_continue && s.length ())\n    {\n\tstring tmp;\n\twhile (s[s.length()-1] == '\\\\')\n\t{\n\t    getline (scanner, tmp);\n\t    scanner_line++;\n\t    s = s + \"\\n\" + tmp;\n\t}\n    }\n    return 0;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "scanner",
            "tmp"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/stringutil.cc",
          "lines": "60-63",
          "snippet": "std::string getline( std::istream & str, bool trim )\n{\n  return _getline(str, trim?TRIM:NO_TRIM);\n}",
          "includes": [
            "#include <y2util/stringutil.h>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/stringutil.h>\n#include <fstream>\n#include <iostream>\n\nstd::string getline( std::istream & str, bool trim )\n{\n  return _getline(str, trim?TRIM:NO_TRIM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.length",
          "args": [],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::scanner_get(string&s)\n  {\n      if (!scanner)\n  \treturn -1;\n      getline (scanner, s);\n      scanner_line++;\n      if (line_can_continue && s.length ())\n      {\n  \tstring tmp;\n  \twhile (s[s.length()-1] == '\\\\')\n  \t{\n  \t    getline (scanner, tmp);\n  \t    scanner_line++;\n  \t    s = s + \"\\n\" + tmp;\n  \t}\n      }\n      return 0;\n  }\n}"
  },
  {
    "function_name": "scanner_stop",
    "container": "IniParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "419-423",
    "snippet": "void IniParser::scanner_stop()\n{\n    scanner.close();\n    scanner.clear();\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scanner.clear",
          "args": [],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/PathInfo.h",
          "lines": "461-461",
          "snippet": "void clear() { _devino.clear(); }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <map>",
            "#include <set>",
            "#include <list>",
            "#include <iosfwd>",
            "#include <cerrno>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <map>\n#include <set>\n#include <list>\n#include <iosfwd>\n#include <cerrno>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid clear() { _devino.clear(); }"
        }
      },
      {
        "call_info": {
          "callee": "scanner.close",
          "args": [],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "325-351",
          "snippet": "int\nExternalProgram::close()\n{\n    if (pid > 0)\n    {\n\tExternalDataSource::close();\n\t// Wait for child to exit\n\tint ret;\n        int status = 0;\n\tdo\n\t{\n\t    ret = waitpid(pid, &status, 0);\n\t}\n\twhile (ret == -1 && errno == EINTR);\n\n\tif (ret != -1)\n\t{\n\t    status = checkStatus( status );\n\t}\n        pid = -1;\n        return status;\n    }\n    else\n    {\n        return _exitStatus;\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  int\n  ExternalProgram::close()\n  {\n      if (pid > 0)\n      {\n  \tExternalDataSource::close();\n  \t// Wait for child to exit\n  \tint ret;\n          int status = 0;\n  \tdo\n  \t{\n  \t    ret = waitpid(pid, &status, 0);\n  \t}\n  \twhile (ret == -1 && errno == EINTR);\n  \n  \tif (ret != -1)\n  \t{\n  \t    status = checkStatus( status );\n  \t}\n          pid = -1;\n          return status;\n      }\n      else\n      {\n          return _exitStatus;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  void IniParser::scanner_stop()\n  {\n      scanner.close();\n      scanner.clear();\n  }\n}"
  },
  {
    "function_name": "scanner_start",
    "container": "IniParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "410-418",
    "snippet": "int IniParser::scanner_start(const char*fn)\n{\n    scanner.open(fn);\n    scanner_file = fn;\n    scanner_line = 0;\n    if (!scanner.is_open())\n        return -1;\n    return 0;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scanner.is_open",
          "args": [],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner.open",
          "args": [
            "fn"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::scanner_start(const char*fn)\n  {\n      scanner.open(fn);\n      scanner_file = fn;\n      scanner_line = 0;\n      if (!scanner.is_open())\n          return -1;\n      return 0;\n  }\n}"
  },
  {
    "function_name": "initMachine",
    "container": "IniParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "168-408",
    "snippet": "int IniParser::initMachine (const YCPMap&scr)\n{\n    started = true;\n\n    //\n    // now process the script\n    //\n    ignore_case_regexps = ignore_case = prefer_uppercase = first_upper = line_can_continue = no_nested_sections =\n\tglobal_values = repeat_names = comments_last = join_multiline =\n\tno_finalcomment_kill = read_only = flat = false;\n\n    // read the options\n    YCPValue v = scr->value(YCPString(\"options\"));\n    if (!v.isNull()) {\n\tif (!v->isList ())\n\t    y2error (\"'options' must be a list\");\n\telse {\n\t    int len = v->asList()->size();\n\t    for (int i = 0;i<len;i++)\n\t\t{\n\t\t    if (!v->asList()->value(i)->isString()) {\n\t\t\ty2error (\"items of 'options' must be strings\");\n\t\t\tcontinue;\n\t\t    }\n\t\t    string sv = v->asList()->value(i)->asString()->value();\n#define COMPARE_OPTION(X) if (sv == #X) X = true; else \n\t\t    COMPARE_OPTION (ignore_case_regexps)\n\t\t    COMPARE_OPTION (ignore_case)\n\t\t    COMPARE_OPTION (prefer_uppercase)\n\t\t    COMPARE_OPTION (first_upper)\n\t\t    COMPARE_OPTION (line_can_continue)\n\t\t    COMPARE_OPTION (no_nested_sections)\n\t\t    COMPARE_OPTION (global_values)\n\t\t    COMPARE_OPTION (repeat_names)\n\t\t    COMPARE_OPTION (comments_last)\n\t\t    COMPARE_OPTION (join_multiline)\n\t\t    COMPARE_OPTION (no_finalcomment_kill)\n\t\t    COMPARE_OPTION (read_only)\n\t\t    COMPARE_OPTION (flat)\n\t\t\ty2error (\"Option not implemented yet: %s\", sv.c_str());\n#undef  COMPARE_OPTION\n\t\t}\n\t}\n    }\n\n    if (ignore_case && multiple_files)\n    {\n       ycperror (\"When using multiple files, ignore_case does not work\");\n       ignore_case = false;\n    }\n\n    v = scr->value(YCPString(\"rewrite\"));\n    if (!v.isNull()) {\n\tif (!v->isList ())\n\t    y2error (\"'rewrite' must be a list\");\n\telse {\n\n\tint len = v->asList()->size();\n\trewrites.clear ();\n\trewrites.reserve (len);\n\tfor (int i = 0; i<len;i++)\n\t{\n\t    YCPValue ival = v->asList()->value(i);\n\t    if (ival->isList() && \n\t\t2 == ival->asList()->size() && \n\t\tival->asList()->value(0)->isString() &&\n\t\tival->asList()->value(1)->isString())\n\t    {\n\t\tIoPattern p;\n\t\tif (!p.rx.compile (ival->asList()->value(0)->asString()->value(), ignore_case_regexps))\n\t\t{\n\t\t    p.out = ival->asList()->value(1)->asString()->value();\n\t\t    rewrites.push_back (p);\n\t\t}\n\t    }\n\t    else\n\t\ty2error (\"items of 'rewrite' must be lists of two strings\");\n\t}\n\n\t}\n    }\n\n    v = scr->value(YCPString(\"subindent\"));\n    if (!v.isNull()) {\n\tif (!v->isString ())\n\t    y2error (\"'subindent' must be a string\");\n\telse\n\t    subindent = v->asString()->value();\n    }\n\n    // read comments\n    v = scr->value(YCPString(\"comments\"));\n    if (!v.isNull()) {\n\tif (!v->isList ())\n\t    y2error (\"'comments' must be a list\");\n\telse {\n\t    int len = v->asList()->size();\n\t    linecomments.clear ();\n\t    comments.clear ();\n\t    linecomments.reserve (len);\n\t    comments.reserve (len);\n\t    for (int i = 0;  i < len; i++)\n\t    {\n\t\tif (!v->asList()->value(i)->isString()) {\n\t\t    y2error (\"items of 'comments' must be strings\");\n\t\t    continue;\n\t\t}\n\t\tYCPString s = v->asList()->value(i)->asString();\n\t\tvector <Regex> & regexes = ('^' == s->value_cstr()[0]) ?\n\t\t    linecomments : comments;\n\t\tRegex r;\n\t\tif (!r.compile (s->value (), ignore_case_regexps))\n\t\t{\n\t\t    regexes.push_back (r);\n\t\t}\n\t    }\n\t}\n    }\n\n    // read sections\n    v = scr->value(YCPString(\"sections\"));\n    if (!v.isNull()) {\n\tif (!v->isList ())\n\t    y2error (\"'sections' must be a list\");\n\telse {\n\t    int len = v->asList()->size();\n\t    // compile them to regex_t\n\t    sections.clear ();\n\t    sections.reserve (len);\n\t    for (int i = 0;  i < len; i++)\n\t\t{\n\t\t    if (!v->asList()->value(i)->isMap())\n\t\t\ty2error (\"items of 'sections' must be maps\");\n\t\t    else\n\t\t\t{\n\t\t\t    section s;\n\t\t\t    YCPMap m = v->asList()->value(i)->asMap ();\n\t\t\t    s.end_valid = false;\n\t\t\t    YCPList p;\n\t\t\t    switch (getBeginEndType (m))\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t    p = m->value(YCPString(\"end\"))->asList();\n\t\t\t\t    if (s.end.rx.compile (\n\t\t\t\t\t    p->value(0)->asString()->value (),\n\t\t\t\t\t    ignore_case_regexps))\n\t\t\t\t\tbreak;\n\t\t\t\t    s.end.out =\n\t\t\t\t\tp->value(1)->asString()->value ();\n\t\t\t\t    s.end_valid = true;\n\t\t\t\t    // Fall through\n\t\t\t\tcase 1:\n\t\t\t\t    p = m->value(YCPString(\"begin\"))->asList();\n\t\t\t\t    if (s.begin.rx.compile (\n\t\t\t\t\t    p->value(0)->asString()->value (),\n\t\t\t\t\t    ignore_case_regexps))\n\t\t\t\t\t{\n\t\t\t\t\t    // compile failed\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t    s.begin.out =\n\t\t\t\t\tp->value(1)->asString()->value ();\n\t\t\t\t    sections.push_back (s);\n\t\t\t\t    break;\n\t\t\t\tcase -1:\n\t\t\t\tdefault:\n\t\t\t\t    y2error (\"Bad format of %dth section map\", i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    }\n\n    // read parameters\n    v = scr->value(YCPString(\"params\"));\n    if (!v.isNull()) {\n\tif (!v->isList ())\n\t    y2error (\"'params' must be a list\");\n\telse {\n\t    int len = v->asList()->size();\n\t    // compile them to regex_t\n\t    params.clear ();\n\t    params.reserve (len);\n\t    for (int i = 0; i < len; i++)\n\t\t{\n\t\t    if (!v->asList()->value(i)->isMap())\n\t\t\ty2error (\"items of 'params' must be maps\");\n\t\t    else\n\t\t\t{\n\t\t\t    YCPMap m = v->asList()->value(i)->asMap ();\n\t\t\t    param pa;\n\t\t\t    pa.multiline_valid = false;\n\t\t\t    YCPList p;\n\t\t\t    switch (getParamsType (m))\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t    p = m->value(YCPString(\"multiline\"))->asList();\n\t\t\t\t    if (!pa.begin.compile (\n\t\t\t\t\t    p->value(0)->asString()->value (),\n\t\t\t\t\t    ignore_case_regexps))\n\t\t\t\t\tif (!pa.end.compile (\n\t\t\t\t\t\tp->value(1)->asString()->value (),\n\t\t\t\t\t\tignore_case_regexps))\n\t\t\t\t\t    {\n\t\t\t\t\t\tpa.multiline_valid = true;\n\t\t\t\t\t    }\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t    y2error (\"Bad regexp(multiline): %s\",\n\t\t\t\t\t\tp->value(1)->asString()->value_cstr());\n\t\t\t\t\t}\n\t\t\t\t    else\n\t\t\t\t\t  y2error (\"Bad regexp(multiline): %s\",\n\t\t\t\t\t      p->value(0)->asString()->value_cstr());\n\t\t\t\tcase 1:\n\t\t\t\t    p = m->value(YCPString(\"match\"))->asList();\n\t\t\t\t    if (pa.line.rx.compile (\n\t\t\t\t\t    p->value(0)->asString()->value (),\n\t\t\t\t\t    ignore_case_regexps))\n\t\t\t\t    {\n\t\t\t\t\tif (pa.multiline_valid)\n\t\t\t\t\t{\n\t\t\t\t\t    y2error (\"Bad regexp(match): %s\",\n\t\t\t\t\t\tp->value(0)->asString()->value_cstr());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t    }\n\t\t\t\t    pa.line.out =\n\t\t\t\t\tp->value(1)->asString()->value ();\n\t\t\t\t    params.push_back (pa);\n\t\t\t\t    break;\n\t\t\t\tcase -1:\n\t\t\t\tdefault:\n\t\t\t\t    y2error (\"Bad format of %dth param map\", i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    }\n    return 0;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad format of %dth param map\"",
            "i"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.push_back",
          "args": [
            "pa"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->value",
          "args": [],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "YCPSymbolRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "69-73",
          "snippet": "YCPValueType\nYCPSymbolRep::valuetype() const\n{\n    return YT_SYMBOL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbolRep {\n  YCPValueType\n  YCPSymbolRep::valuetype() const\n  {\n      return YT_SYMBOL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->value",
          "args": [
            "1"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad regexp(match): %s\"",
            "p->value(0)->asString()->value_cstr()"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pa.line.rx.compile",
          "args": [
            "p->value(0)->asString()->value ()",
            "ignore_case_regexps"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "compile",
          "container": "Regex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.h",
          "lines": "130-141",
          "snippet": "int compile (const string& pattern, bool ignore_case) {\n\tif (rxtp)\n\t{\n\t    y2error (\"Regex_t @%p already compiled\", this);\n\t    return -1;\n\t}\n\telse\n\t{\n\t    rxtp = new Regex_t;\n\t    return rxtp->compile (pattern, ignore_case);\n\t}\n    }",
          "includes": [
            "#include \"IniFile.h\"",
            "#include <set>",
            "#include <vector>",
            "#include <string>",
            "#include <fstream>",
            "#include <iosfwd>",
            "#include <YCP.h>",
            "#include <y2util/RepDef.h>",
            "#include <locale.h>",
            "#include <regex.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include <set>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <iosfwd>\n#include <YCP.h>\n#include <y2util/RepDef.h>\n#include <locale.h>\n#include <regex.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\nRegex {\n  int compile (const string& pattern, bool ignore_case) {\n  \tif (rxtp)\n  \t{\n  \t    y2error (\"Regex_t @%p already compiled\", this);\n  \t    return -1;\n  \t}\n  \telse\n  \t{\n  \t    rxtp = new Regex_t;\n  \t    return rxtp->compile (pattern, ignore_case);\n  \t}\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->value",
          "args": [],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPBuiltinStatementRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinStatement.cc",
          "lines": "51-54",
          "snippet": "YCPValue YCPBuiltinStatementRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"YCPBuiltinStatement.h\"",
            "#include \"YCPBuiltin.h\"",
            "#include \"y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"YCPBuiltinStatement.h\"\n#include \"YCPBuiltin.h\"\n#include \"y2log.h\"\n\nYCPBuiltinStatementRep {\n  YCPValue YCPBuiltinStatementRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "\"match\""
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad regexp(multiline): %s\"",
            "p->value(0)->asString()->value_cstr()"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad regexp(multiline): %s\"",
            "p->value(1)->asString()->value_cstr()"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getParamsType",
          "args": [
            "m"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "getParamsType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "136-149",
          "snippet": "int getParamsType (const YCPMap&m)\n{\n    if (m->value(YCPString(\"match\")).isNull())\n\treturn -1;\n    if (!isYCPStringPair (m->value (YCPString (\"match\"))))\n\treturn -1;\n    \n    if (m->value(YCPString(\"multiline\")).isNull())\n\treturn 1;\n    if (!isYCPStringPair (m->value (YCPString (\"multiline\"))))\n\treturn 1;\n\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nint getParamsType (const YCPMap&m)\n{\n    if (m->value(YCPString(\"match\")).isNull())\n\treturn -1;\n    if (!isYCPStringPair (m->value (YCPString (\"match\"))))\n\treturn -1;\n    \n    if (m->value(YCPString(\"multiline\")).isNull())\n\treturn 1;\n    if (!isYCPStringPair (m->value (YCPString (\"multiline\"))))\n\treturn 1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->asList",
          "args": [],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->asList",
          "args": [
            "i"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"items of 'params' must be maps\""
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->asList",
          "args": [
            "i"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.reserve",
          "args": [
            "len"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "reserve",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "117-121",
          "snippet": "void\nYCPTermRep::reserve (int size)\n{\n    l->reserve (size);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::reserve (int size)\n  {\n      l->reserve (size);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.clear",
          "args": [],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/PathInfo.h",
          "lines": "461-461",
          "snippet": "void clear() { _devino.clear(); }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <map>",
            "#include <set>",
            "#include <list>",
            "#include <iosfwd>",
            "#include <cerrno>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <map>\n#include <set>\n#include <list>\n#include <iosfwd>\n#include <cerrno>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid clear() { _devino.clear(); }"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"'params' must be a list\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->isList",
          "args": [],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad format of %dth section map\"",
            "i"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getBeginEndType",
          "args": [
            "m"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "getBeginEndType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "112-125",
          "snippet": "int getBeginEndType (const YCPMap&m)\n{\n    if (m->value(YCPString(\"begin\")).isNull())\n\treturn -1;\n    if (!isYCPStringPair (m->value (YCPString (\"begin\"))))\n\treturn -1;\n    \n    if (m->value(YCPString(\"end\")).isNull())\n\treturn 1;\n    if (!isYCPStringPair (m->value (YCPString (\"end\"))))\n\treturn 1;\n\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nint getBeginEndType (const YCPMap&m)\n{\n    if (m->value(YCPString(\"begin\")).isNull())\n\treturn -1;\n    if (!isYCPStringPair (m->value (YCPString (\"begin\"))))\n\treturn -1;\n    \n    if (m->value(YCPString(\"end\")).isNull())\n\treturn 1;\n    if (!isYCPStringPair (m->value (YCPString (\"end\"))))\n\treturn 1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->asList",
          "args": [
            "i"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"items of 'sections' must be maps\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->asList",
          "args": [
            "i"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"'sections' must be a list\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s->value",
          "args": [],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YConst",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "342-346",
          "snippet": "YCPValue\nYConst::value() const\n{\n    return m_value;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYConst {\n  YCPValue\n  YConst::value() const\n  {\n      return m_value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s->value_cstr",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->asList",
          "args": [
            "i"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"items of 'comments' must be strings\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->asList",
          "args": [
            "i"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"'comments' must be a list\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->asString",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"'subindent' must be a string\""
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->isString",
          "args": [],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"items of 'rewrite' must be lists of two strings\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ival->asList",
          "args": [
            "1"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ival->asList",
          "args": [
            "0"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ival->asList",
          "args": [
            "1"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ival->asList",
          "args": [
            "0"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->asList",
          "args": [
            "i"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"'rewrite' must be a list\""
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycperror",
          "args": [
            "\"When using multiple files, ignore_case does not work\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Option not implemented yet: %s\"",
            "sv.c_str()"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sv.c_str",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPARE_OPTION",
          "args": [
            "flat"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPARE_OPTION",
          "args": [
            "read_only"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPARE_OPTION",
          "args": [
            "no_finalcomment_kill"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPARE_OPTION",
          "args": [
            "join_multiline"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPARE_OPTION",
          "args": [
            "comments_last"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPARE_OPTION",
          "args": [
            "repeat_names"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPARE_OPTION",
          "args": [
            "global_values"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPARE_OPTION",
          "args": [
            "no_nested_sections"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPARE_OPTION",
          "args": [
            "line_can_continue"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPARE_OPTION",
          "args": [
            "first_upper"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPARE_OPTION",
          "args": [
            "prefer_uppercase"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPARE_OPTION",
          "args": [
            "ignore_case"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPARE_OPTION",
          "args": [
            "ignore_case_regexps"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->asList",
          "args": [
            "i"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"items of 'options' must be strings\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->asList",
          "args": [
            "i"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"'options' must be a list\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::initMachine (const YCPMap&scr)\n  {\n      started = true;\n  \n      //\n      // now process the script\n      //\n      ignore_case_regexps = ignore_case = prefer_uppercase = first_upper = line_can_continue = no_nested_sections =\n  \tglobal_values = repeat_names = comments_last = join_multiline =\n  \tno_finalcomment_kill = read_only = flat = false;\n  \n      // read the options\n      YCPValue v = scr->value(YCPString(\"options\"));\n      if (!v.isNull()) {\n  \tif (!v->isList ())\n  \t    y2error (\"'options' must be a list\");\n  \telse {\n  \t    int len = v->asList()->size();\n  \t    for (int i = 0;i<len;i++)\n  \t\t{\n  \t\t    if (!v->asList()->value(i)->isString()) {\n  \t\t\ty2error (\"items of 'options' must be strings\");\n  \t\t\tcontinue;\n  \t\t    }\n  \t\t    string sv = v->asList()->value(i)->asString()->value();\n  #define COMPARE_OPTION(X) if (sv == #X) X = true; else \n  \t\t    COMPARE_OPTION (ignore_case_regexps)\n  \t\t    COMPARE_OPTION (ignore_case)\n  \t\t    COMPARE_OPTION (prefer_uppercase)\n  \t\t    COMPARE_OPTION (first_upper)\n  \t\t    COMPARE_OPTION (line_can_continue)\n  \t\t    COMPARE_OPTION (no_nested_sections)\n  \t\t    COMPARE_OPTION (global_values)\n  \t\t    COMPARE_OPTION (repeat_names)\n  \t\t    COMPARE_OPTION (comments_last)\n  \t\t    COMPARE_OPTION (join_multiline)\n  \t\t    COMPARE_OPTION (no_finalcomment_kill)\n  \t\t    COMPARE_OPTION (read_only)\n  \t\t    COMPARE_OPTION (flat)\n  \t\t\ty2error (\"Option not implemented yet: %s\", sv.c_str());\n  #undef  COMPARE_OPTION\n  \t\t}\n  \t}\n      }\n  \n      if (ignore_case && multiple_files)\n      {\n         ycperror (\"When using multiple files, ignore_case does not work\");\n         ignore_case = false;\n      }\n  \n      v = scr->value(YCPString(\"rewrite\"));\n      if (!v.isNull()) {\n  \tif (!v->isList ())\n  \t    y2error (\"'rewrite' must be a list\");\n  \telse {\n  \n  \tint len = v->asList()->size();\n  \trewrites.clear ();\n  \trewrites.reserve (len);\n  \tfor (int i = 0; i<len;i++)\n  \t{\n  \t    YCPValue ival = v->asList()->value(i);\n  \t    if (ival->isList() && \n  \t\t2 == ival->asList()->size() && \n  \t\tival->asList()->value(0)->isString() &&\n  \t\tival->asList()->value(1)->isString())\n  \t    {\n  \t\tIoPattern p;\n  \t\tif (!p.rx.compile (ival->asList()->value(0)->asString()->value(), ignore_case_regexps))\n  \t\t{\n  \t\t    p.out = ival->asList()->value(1)->asString()->value();\n  \t\t    rewrites.push_back (p);\n  \t\t}\n  \t    }\n  \t    else\n  \t\ty2error (\"items of 'rewrite' must be lists of two strings\");\n  \t}\n  \n  \t}\n      }\n  \n      v = scr->value(YCPString(\"subindent\"));\n      if (!v.isNull()) {\n  \tif (!v->isString ())\n  \t    y2error (\"'subindent' must be a string\");\n  \telse\n  \t    subindent = v->asString()->value();\n      }\n  \n      // read comments\n      v = scr->value(YCPString(\"comments\"));\n      if (!v.isNull()) {\n  \tif (!v->isList ())\n  \t    y2error (\"'comments' must be a list\");\n  \telse {\n  \t    int len = v->asList()->size();\n  \t    linecomments.clear ();\n  \t    comments.clear ();\n  \t    linecomments.reserve (len);\n  \t    comments.reserve (len);\n  \t    for (int i = 0;  i < len; i++)\n  \t    {\n  \t\tif (!v->asList()->value(i)->isString()) {\n  \t\t    y2error (\"items of 'comments' must be strings\");\n  \t\t    continue;\n  \t\t}\n  \t\tYCPString s = v->asList()->value(i)->asString();\n  \t\tvector <Regex> & regexes = ('^' == s->value_cstr()[0]) ?\n  \t\t    linecomments : comments;\n  \t\tRegex r;\n  \t\tif (!r.compile (s->value (), ignore_case_regexps))\n  \t\t{\n  \t\t    regexes.push_back (r);\n  \t\t}\n  \t    }\n  \t}\n      }\n  \n      // read sections\n      v = scr->value(YCPString(\"sections\"));\n      if (!v.isNull()) {\n  \tif (!v->isList ())\n  \t    y2error (\"'sections' must be a list\");\n  \telse {\n  \t    int len = v->asList()->size();\n  \t    // compile them to regex_t\n  \t    sections.clear ();\n  \t    sections.reserve (len);\n  \t    for (int i = 0;  i < len; i++)\n  \t\t{\n  \t\t    if (!v->asList()->value(i)->isMap())\n  \t\t\ty2error (\"items of 'sections' must be maps\");\n  \t\t    else\n  \t\t\t{\n  \t\t\t    section s;\n  \t\t\t    YCPMap m = v->asList()->value(i)->asMap ();\n  \t\t\t    s.end_valid = false;\n  \t\t\t    YCPList p;\n  \t\t\t    switch (getBeginEndType (m))\n  \t\t\t\t{\n  \t\t\t\tcase 0:\n  \t\t\t\t    p = m->value(YCPString(\"end\"))->asList();\n  \t\t\t\t    if (s.end.rx.compile (\n  \t\t\t\t\t    p->value(0)->asString()->value (),\n  \t\t\t\t\t    ignore_case_regexps))\n  \t\t\t\t\tbreak;\n  \t\t\t\t    s.end.out =\n  \t\t\t\t\tp->value(1)->asString()->value ();\n  \t\t\t\t    s.end_valid = true;\n  \t\t\t\t    // Fall through\n  \t\t\t\tcase 1:\n  \t\t\t\t    p = m->value(YCPString(\"begin\"))->asList();\n  \t\t\t\t    if (s.begin.rx.compile (\n  \t\t\t\t\t    p->value(0)->asString()->value (),\n  \t\t\t\t\t    ignore_case_regexps))\n  \t\t\t\t\t{\n  \t\t\t\t\t    // compile failed\n  \t\t\t\t\t    break;\n  \t\t\t\t\t}\n  \t\t\t\t    s.begin.out =\n  \t\t\t\t\tp->value(1)->asString()->value ();\n  \t\t\t\t    sections.push_back (s);\n  \t\t\t\t    break;\n  \t\t\t\tcase -1:\n  \t\t\t\tdefault:\n  \t\t\t\t    y2error (\"Bad format of %dth section map\", i);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n      }\n  \n      // read parameters\n      v = scr->value(YCPString(\"params\"));\n      if (!v.isNull()) {\n  \tif (!v->isList ())\n  \t    y2error (\"'params' must be a list\");\n  \telse {\n  \t    int len = v->asList()->size();\n  \t    // compile them to regex_t\n  \t    params.clear ();\n  \t    params.reserve (len);\n  \t    for (int i = 0; i < len; i++)\n  \t\t{\n  \t\t    if (!v->asList()->value(i)->isMap())\n  \t\t\ty2error (\"items of 'params' must be maps\");\n  \t\t    else\n  \t\t\t{\n  \t\t\t    YCPMap m = v->asList()->value(i)->asMap ();\n  \t\t\t    param pa;\n  \t\t\t    pa.multiline_valid = false;\n  \t\t\t    YCPList p;\n  \t\t\t    switch (getParamsType (m))\n  \t\t\t\t{\n  \t\t\t\tcase 0:\n  \t\t\t\t    p = m->value(YCPString(\"multiline\"))->asList();\n  \t\t\t\t    if (!pa.begin.compile (\n  \t\t\t\t\t    p->value(0)->asString()->value (),\n  \t\t\t\t\t    ignore_case_regexps))\n  \t\t\t\t\tif (!pa.end.compile (\n  \t\t\t\t\t\tp->value(1)->asString()->value (),\n  \t\t\t\t\t\tignore_case_regexps))\n  \t\t\t\t\t    {\n  \t\t\t\t\t\tpa.multiline_valid = true;\n  \t\t\t\t\t    }\n  \t\t\t\t\telse\n  \t\t\t\t\t{\n  \t\t\t\t\t    y2error (\"Bad regexp(multiline): %s\",\n  \t\t\t\t\t\tp->value(1)->asString()->value_cstr());\n  \t\t\t\t\t}\n  \t\t\t\t    else\n  \t\t\t\t\t  y2error (\"Bad regexp(multiline): %s\",\n  \t\t\t\t\t      p->value(0)->asString()->value_cstr());\n  \t\t\t\tcase 1:\n  \t\t\t\t    p = m->value(YCPString(\"match\"))->asList();\n  \t\t\t\t    if (pa.line.rx.compile (\n  \t\t\t\t\t    p->value(0)->asString()->value (),\n  \t\t\t\t\t    ignore_case_regexps))\n  \t\t\t\t    {\n  \t\t\t\t\tif (pa.multiline_valid)\n  \t\t\t\t\t{\n  \t\t\t\t\t    y2error (\"Bad regexp(match): %s\",\n  \t\t\t\t\t\tp->value(0)->asString()->value_cstr());\n  \t\t\t\t\t}\n  \t\t\t\t\tbreak;\n  \t\t\t\t    }\n  \t\t\t\t    pa.line.out =\n  \t\t\t\t\tp->value(1)->asString()->value ();\n  \t\t\t\t    params.push_back (pa);\n  \t\t\t\t    break;\n  \t\t\t\tcase -1:\n  \t\t\t\tdefault:\n  \t\t\t\t    y2error (\"Bad format of %dth param map\", i);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n      }\n      return 0;\n  }\n}"
  },
  {
    "function_name": "initFiles",
    "container": "IniParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "163-167",
    "snippet": "void IniParser::initFiles (const char*fn)\n{\n    file = fn;\n    multiple_files = false;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  void IniParser::initFiles (const char*fn)\n  {\n      file = fn;\n      multiple_files = false;\n  }\n}"
  },
  {
    "function_name": "initFiles",
    "container": "IniParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "151-162",
    "snippet": "void IniParser::initFiles (const YCPList&f)\n{\n    multiple_files = true;\n    files.clear ();\n\n    int len = f->size();\n    for (int i = 0;i<len;i++)\n\tif (f->value (i)->isString ())\n\t    files.push_back (f->value (i)->asString()->value());\n\telse\n\t    y2error (\"Bad file specification: %s\", f->value (i)->toString ().c_str());\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad file specification: %s\"",
            "f->value (i)->toString ().c_str()"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->value",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "f->value",
          "args": [
            "i"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "files.push_back",
          "args": [
            "f->value (i)->asString()->value()"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "f->size",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/PathInfo.h",
          "lines": "178-178",
          "snippet": "off_t         size()    const { return isExist() ? statbuf_C.st_size : 0; }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <map>",
            "#include <set>",
            "#include <list>",
            "#include <iosfwd>",
            "#include <cerrno>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <map>\n#include <set>\n#include <list>\n#include <iosfwd>\n#include <cerrno>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nPathInfo {\n  off_t         size()    const { return isExist() ? statbuf_C.st_size : 0; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "files.clear",
          "args": [],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/PathInfo.h",
          "lines": "461-461",
          "snippet": "void clear() { _devino.clear(); }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <map>",
            "#include <set>",
            "#include <list>",
            "#include <iosfwd>",
            "#include <cerrno>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <map>\n#include <set>\n#include <list>\n#include <iosfwd>\n#include <cerrno>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid clear() { _devino.clear(); }"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  void IniParser::initFiles (const YCPList&f)\n  {\n      multiple_files = true;\n      files.clear ();\n  \n      int len = f->size();\n      for (int i = 0;i<len;i++)\n  \tif (f->value (i)->isString ())\n  \t    files.push_back (f->value (i)->asString()->value());\n  \telse\n  \t    y2error (\"Bad file specification: %s\", f->value (i)->toString ().c_str());\n  }\n}"
  },
  {
    "function_name": "getParamsType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "136-149",
    "snippet": "int getParamsType (const YCPMap&m)\n{\n    if (m->value(YCPString(\"match\")).isNull())\n\treturn -1;\n    if (!isYCPStringPair (m->value (YCPString (\"match\"))))\n\treturn -1;\n    \n    if (m->value(YCPString(\"multiline\")).isNull())\n\treturn 1;\n    if (!isYCPStringPair (m->value (YCPString (\"multiline\"))))\n\treturn 1;\n\n    return 0;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isYCPStringPair",
          "args": [
            "m->value (YCPString (\"multiline\"))"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->value",
          "args": [
            "YCPString (\"multiline\")"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->value",
          "args": [],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPBuiltinStatementRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinStatement.cc",
          "lines": "51-54",
          "snippet": "YCPValue YCPBuiltinStatementRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"YCPBuiltinStatement.h\"",
            "#include \"YCPBuiltin.h\"",
            "#include \"y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"YCPBuiltinStatement.h\"\n#include \"YCPBuiltin.h\"\n#include \"y2log.h\"\n\nYCPBuiltinStatementRep {\n  YCPValue YCPBuiltinStatementRep::value() const\n  {\n      return v;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nint getParamsType (const YCPMap&m)\n{\n    if (m->value(YCPString(\"match\")).isNull())\n\treturn -1;\n    if (!isYCPStringPair (m->value (YCPString (\"match\"))))\n\treturn -1;\n    \n    if (m->value(YCPString(\"multiline\")).isNull())\n\treturn 1;\n    if (!isYCPStringPair (m->value (YCPString (\"multiline\"))))\n\treturn 1;\n\n    return 0;\n}"
  },
  {
    "function_name": "getBeginEndType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "112-125",
    "snippet": "int getBeginEndType (const YCPMap&m)\n{\n    if (m->value(YCPString(\"begin\")).isNull())\n\treturn -1;\n    if (!isYCPStringPair (m->value (YCPString (\"begin\"))))\n\treturn -1;\n    \n    if (m->value(YCPString(\"end\")).isNull())\n\treturn 1;\n    if (!isYCPStringPair (m->value (YCPString (\"end\"))))\n\treturn 1;\n\n    return 0;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isYCPStringPair",
          "args": [
            "m->value (YCPString (\"end\"))"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->value",
          "args": [
            "YCPString (\"end\")"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->value",
          "args": [],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPBuiltinStatementRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinStatement.cc",
          "lines": "51-54",
          "snippet": "YCPValue YCPBuiltinStatementRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"YCPBuiltinStatement.h\"",
            "#include \"YCPBuiltin.h\"",
            "#include \"y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"YCPBuiltinStatement.h\"\n#include \"YCPBuiltin.h\"\n#include \"y2log.h\"\n\nYCPBuiltinStatementRep {\n  YCPValue YCPBuiltinStatementRep::value() const\n  {\n      return v;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nint getBeginEndType (const YCPMap&m)\n{\n    if (m->value(YCPString(\"begin\")).isNull())\n\treturn -1;\n    if (!isYCPStringPair (m->value (YCPString (\"begin\"))))\n\treturn -1;\n    \n    if (m->value(YCPString(\"end\")).isNull())\n\treturn 1;\n    if (!isYCPStringPair (m->value (YCPString (\"end\"))))\n\treturn 1;\n\n    return 0;\n}"
  },
  {
    "function_name": "isYCPStringPair",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "92-102",
    "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "l->value",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPBooleanRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "38-42",
          "snippet": "bool\nYCPBooleanRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBooleanRep {\n  bool\n  YCPBooleanRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "l->value",
          "args": [
            "1"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "l->size",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPByteblockRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPByteblock.cc",
          "lines": "59-63",
          "snippet": "long\nYCPByteblockRep::size() const\n{\n    return len;\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPByteblock.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPByteblock.h\"\n#include <ycp/y2log.h>\n\nYCPByteblockRep {\n  long\n  YCPByteblockRep::size() const\n  {\n      return len;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->asList",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->isList",
          "args": [],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
  },
  {
    "function_name": "onlySpaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "81-90",
    "snippet": "bool onlySpaces (const char*str)\n{\n    while (*str)\n    {\n\tif (' ' != *str && '\\t' != *str && '\\r' != *str && '\\n' != *str)\n\t    return false;\n\tstr++;\n    }\n    return true;\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool onlySpaces (const char*str)\n{\n    while (*str)\n    {\n\tif (' ' != *str && '\\t' != *str && '\\r' != *str && '\\n' != *str)\n\t    return false;\n\tstr++;\n    }\n    return true;\n}"
  },
  {
    "function_name": "y2errPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "71-79",
    "snippet": "void y2errPath (const vector<string>&p, const char*c = \"\")\n{\n    string out = c;\n    int i = 0;\n    int len = p.size();\n    for (;i<len;i++)\n\tout = out + p[i] + \" \";\n    y2error (\"%s\", out.c_str());\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"%s\"",
            "out.c_str()"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.c_str",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.size",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nvoid y2errPath (const vector<string>&p, const char*c = \"\")\n{\n    string out = c;\n    int i = 0;\n    int len = p.size();\n    for (;i<len;i++)\n\tout = out + p[i] + \" \";\n    y2error (\"%s\", out.c_str());\n}"
  },
  {
    "function_name": "printPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "62-70",
    "snippet": "void printPath(const vector<string>&p, const char*c = \"\")\n{\n    int i = 0;\n    int len = p.size();\n    printf(\"%s:\", c);\n    for (;i<len;i++)\n\tprintf(\"%s \", p[i].c_str());\n    printf(\"\\n\");\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s \"",
            "p[i].c_str()"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p[i].c_str",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:\"",
            "c"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.size",
          "args": [],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nvoid printPath(const vector<string>&p, const char*c = \"\")\n{\n    int i = 0;\n    int len = p.size();\n    printf(\"%s:\", c);\n    for (;i<len;i++)\n\tprintf(\"%s \", p[i].c_str());\n    printf(\"\\n\");\n}"
  },
  {
    "function_name": "~IniParser",
    "container": "IniParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "55-58",
    "snippet": "IniParser::~IniParser ()\n{\n    // regex deallocation used to be here\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  IniParser::~IniParser ()\n  {\n      // regex deallocation used to be here\n  }\n}"
  },
  {
    "function_name": "~TemporaryLocale",
    "container": "TemporaryLocale",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "40-45",
    "snippet": "TemporaryLocale::~TemporaryLocale () {\n    if (_oldlocale != NULL) {\n\tmy_setlocale (_category, _oldlocale);\n\tfree (_oldlocale);\n    }\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "_oldlocale"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_setlocale",
          "args": [
            "_category",
            "_oldlocale"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nTemporaryLocale {\n  TemporaryLocale::~TemporaryLocale () {\n      if (_oldlocale != NULL) {\n  \tmy_setlocale (_category, _oldlocale);\n  \tfree (_oldlocale);\n      }\n  }\n}"
  },
  {
    "function_name": "TemporaryLocale",
    "container": "TemporaryLocale",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
    "lines": "32-38",
    "snippet": "TemporaryLocale::TemporaryLocale (int category, const char * locale) {\n    _category = category;\n    _oldlocale = my_setlocale (_category, NULL);\n    if (_oldlocale != NULL)\n\t_oldlocale = strdup (_oldlocale);\n    my_setlocale (_category, locale);\n}",
    "includes": [
      "#include \"IniFile.h\"",
      "#include \"IniParser.h\"",
      "#include <cassert>",
      "#include <glob.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <set>",
      "#include <vector>",
      "#include <ycp/y2log.h>",
      "#include <y2util/PathInfo.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "my_setlocale",
          "args": [
            "_category",
            "locale"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "_oldlocale"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_setlocale",
          "args": [
            "_category",
            "NULL"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nTemporaryLocale {\n  TemporaryLocale::TemporaryLocale (int category, const char * locale) {\n      _category = category;\n      _oldlocale = my_setlocale (_category, NULL);\n      if (_oldlocale != NULL)\n  \t_oldlocale = strdup (_oldlocale);\n      my_setlocale (_category, locale);\n  }\n}"
  }
]