[
  {
    "function_name": "detailedtype",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1952-2020",
    "snippet": "constTypePtr\nType::detailedtype (constTypePtr type) const\n{\n#if DO_DEBUG\n    y2debug (\"Type::detailedtype '%s' ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\n    if (isVoid())\t\t\t// 'nil' does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n    else if (type->isVoid())\t\t// 'nil' does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n    else if (type->isUnspec())\t\t// <unspec> does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n    else if (type->isAny())\t\t// 'any' does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n    else if (isUnspec())\t\t// <unspec> does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n    else if (isAny())\t\t\t// 'any' does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n    else if (match (type) >= 0)\t\t// if this matches the expected type, the latter is more detailed\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n    else if (type->match (this) >= 0)\t// if type matches the expected this, the latter is more detailed\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n\n#if DO_DEBUG\n    y2debug (\"Type::detailedtype '%s' ('%s') -> error\", toString().c_str(), type->toString().c_str());\n#endif\n    return Type::Error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Type::detailedtype '%s' ('%s') -> error\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Type::detailedtype '%s'* ('%s')\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->match",
          "args": [
            "this"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1739-1797",
          "snippet": "int\nFunctionType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    int bm = basematch (expected);\n\n    if (bm == 1) return 0;\t\t// any or wildcard match\n\n    if ((bm == 0\n\t    && expected->isFunction()))\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (m_returntype->match (ft->m_returntype) < 0)\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return -1;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return 0;\n\t}\n\n\tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n\tif (!wildcard)\n\t{\n\t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter count mismatch\");\n#endif\n\t\treturn -1;\n\t    }\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > esize\t\t\t// don't check wildcard parameters\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n\t    {\n\t\treturn -1;\n\t    }\n\t}\n\treturn 0;\n    }\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  int\n  FunctionType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      int bm = basematch (expected);\n  \n      if (bm == 1) return 0;\t\t// any or wildcard match\n  \n      if ((bm == 0\n  \t    && expected->isFunction()))\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (m_returntype->match (ft->m_returntype) < 0)\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return -1;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return 0;\n  \t}\n  \n  \tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n  \tif (!wildcard)\n  \t{\n  \t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter count mismatch\");\n  #endif\n  \t\treturn -1;\n  \t    }\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > esize\t\t\t// don't check wildcard parameters\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n  \t    {\n  \t\treturn -1;\n  \t    }\n  \t}\n  \treturn 0;\n      }\n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Type::detailedtype '%s' ('%s')*\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Type::detailedtype '%s' ('%s')*\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isAny",
          "args": [],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "isAny",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "283-283",
          "snippet": "bool isAny () const\t\t{ return m_kind == AnyT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isAny () const\t\t{ return m_kind == AnyT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Type::detailedtype '%s' ('%s')*\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isUnspec",
          "args": [],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Type::detailedtype '%s'* ('%s')\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Type::detailedtype '%s'* ('%s')\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Type::detailedtype '%s'* ('%s')\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->isVoid",
          "args": [],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "293-293",
          "snippet": "bool isVoid () const\t{ return m_kind == VoidT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isVoid () const\t{ return m_kind == VoidT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Type::detailedtype '%s' ('%s')*\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Type::detailedtype '%s' ('%s')\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nType {\n  constTypePtr\n  Type::detailedtype (constTypePtr type) const\n  {\n  #if DO_DEBUG\n      y2debug (\"Type::detailedtype '%s' ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \n      if (isVoid())\t\t\t// 'nil' does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n      else if (type->isVoid())\t\t// 'nil' does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n      else if (type->isUnspec())\t\t// <unspec> does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n      else if (type->isAny())\t\t// 'any' does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n      else if (isUnspec())\t\t// <unspec> does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n      else if (isAny())\t\t\t// 'any' does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n      else if (match (type) >= 0)\t\t// if this matches the expected type, the latter is more detailed\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n      else if (type->match (this) >= 0)\t// if type matches the expected this, the latter is more detailed\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"Type::detailedtype '%s' ('%s') -> error\", toString().c_str(), type->toString().c_str());\n  #endif\n      return Type::Error;\n  }\n}"
  },
  {
    "function_name": "commontype",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1917-1944",
    "snippet": "constTypePtr\nType::commontype (constTypePtr type) const\n{\n    if (isVoid())\t\t// 'nil' does not influence the type\n    {\n\treturn type;\n    }\n\n    if (match (type) >= 0)\n    {\n#if DO_DEBUG\n\ty2debug (\"commontype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n    else if (!isAny()\n\t     && type->match (this) >= 0)\n    {\n#if DO_DEBUG\n    y2debug (\"commontype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n#if DO_DEBUG\n    y2debug (\"commontype '%s' ('%s') -> any\", toString().c_str(), type->toString().c_str());\n#endif\n    return Type::Any;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "const constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"commontype '%s' ('%s') -> any\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"commontype '%s' ('%s')*\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->match",
          "args": [
            "this"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1739-1797",
          "snippet": "int\nFunctionType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    int bm = basematch (expected);\n\n    if (bm == 1) return 0;\t\t// any or wildcard match\n\n    if ((bm == 0\n\t    && expected->isFunction()))\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (m_returntype->match (ft->m_returntype) < 0)\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return -1;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return 0;\n\t}\n\n\tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n\tif (!wildcard)\n\t{\n\t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter count mismatch\");\n#endif\n\t\treturn -1;\n\t    }\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > esize\t\t\t// don't check wildcard parameters\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n\t    {\n\t\treturn -1;\n\t    }\n\t}\n\treturn 0;\n    }\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  int\n  FunctionType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      int bm = basematch (expected);\n  \n      if (bm == 1) return 0;\t\t// any or wildcard match\n  \n      if ((bm == 0\n  \t    && expected->isFunction()))\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (m_returntype->match (ft->m_returntype) < 0)\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return -1;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return 0;\n  \t}\n  \n  \tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n  \tif (!wildcard)\n  \t{\n  \t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter count mismatch\");\n  #endif\n  \t\treturn -1;\n  \t    }\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > esize\t\t\t// don't check wildcard parameters\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n  \t    {\n  \t\treturn -1;\n  \t    }\n  \t}\n  \treturn 0;\n      }\n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isAny",
          "args": [],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "isAny",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "283-283",
          "snippet": "bool isAny () const\t\t{ return m_kind == AnyT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isAny () const\t\t{ return m_kind == AnyT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"commontype '%s'* ('%s')\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isVoid",
          "args": [],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "293-293",
          "snippet": "bool isVoid () const\t{ return m_kind == VoidT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isVoid () const\t{ return m_kind == VoidT; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));\n\nType {\n  constTypePtr\n  Type::commontype (constTypePtr type) const\n  {\n      if (isVoid())\t\t// 'nil' does not influence the type\n      {\n  \treturn type;\n      }\n  \n      if (match (type) >= 0)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"commontype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n      else if (!isAny()\n  \t     && type->match (this) >= 0)\n      {\n  #if DO_DEBUG\n      y2debug (\"commontype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n  #if DO_DEBUG\n      y2debug (\"commontype '%s' ('%s') -> any\", toString().c_str(), type->toString().c_str());\n  #endif\n      return Type::Any;\n  }\n}"
  },
  {
    "function_name": "valueType",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1876-1909",
    "snippet": "YCPValueType\nType::valueType () const\n{\n    switch (m_kind)\n    {\n\tcase UnspecT:\treturn YT_ERROR;\n\tcase VoidT:\treturn YT_VOID;\n\tcase AnyT:\treturn YT_VOID;\n\tcase BooleanT:\treturn YT_BOOLEAN;\n\tcase IntegerT:\treturn YT_INTEGER;\n\tcase FloatT:\treturn YT_FLOAT;\n\tcase StringT:\treturn YT_STRING ;\n\tcase ByteblockT:return YT_BYTEBLOCK;\n\tcase PathT:\treturn YT_PATH;\n\tcase TermT:\treturn YT_TERM;\n\tcase SymbolT:\treturn YT_SYMBOL;\n\tcase ErrorT:\treturn YT_ERROR;\n\tcase LocaleT:\treturn YT_STRING;\n\tcase WildcardT: return YT_ERROR;\n\tcase FlexT:\treturn YT_ERROR;\n\tcase NFlexT:\treturn YT_ERROR;\n\n\tcase VariableT: return YT_ENTRY;\n\tcase BlockT:\treturn YT_CODE;\n\tcase ListT:\treturn YT_LIST;\n\tcase MapT:\treturn YT_MAP;\n\tcase TupleT:\treturn YT_ERROR;\t// not expressable\n\tcase FunctionT:\treturn YT_ERROR;\t// not expressable\n\n\tcase NilT:\treturn YT_VOID;\n    }\n\n    return YT_ERROR;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  YCPValueType\n  Type::valueType () const\n  {\n      switch (m_kind)\n      {\n  \tcase UnspecT:\treturn YT_ERROR;\n  \tcase VoidT:\treturn YT_VOID;\n  \tcase AnyT:\treturn YT_VOID;\n  \tcase BooleanT:\treturn YT_BOOLEAN;\n  \tcase IntegerT:\treturn YT_INTEGER;\n  \tcase FloatT:\treturn YT_FLOAT;\n  \tcase StringT:\treturn YT_STRING ;\n  \tcase ByteblockT:return YT_BYTEBLOCK;\n  \tcase PathT:\treturn YT_PATH;\n  \tcase TermT:\treturn YT_TERM;\n  \tcase SymbolT:\treturn YT_SYMBOL;\n  \tcase ErrorT:\treturn YT_ERROR;\n  \tcase LocaleT:\treturn YT_STRING;\n  \tcase WildcardT: return YT_ERROR;\n  \tcase FlexT:\treturn YT_ERROR;\n  \tcase NFlexT:\treturn YT_ERROR;\n  \n  \tcase VariableT: return YT_ENTRY;\n  \tcase BlockT:\treturn YT_CODE;\n  \tcase ListT:\treturn YT_LIST;\n  \tcase MapT:\treturn YT_MAP;\n  \tcase TupleT:\treturn YT_ERROR;\t// not expressable\n  \tcase FunctionT:\treturn YT_ERROR;\t// not expressable\n  \n  \tcase NilT:\treturn YT_VOID;\n      }\n  \n      return YT_ERROR;\n  }\n}"
  },
  {
    "function_name": "unflex",
    "container": "FunctionType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1857-1872",
    "snippet": "constTypePtr\nFunctionType::unflex (constTypePtr type, unsigned int number) const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype->unflex (type, number)));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount (); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType(index)->unflex (type, number));\n\t}\n    }\n#if DO_DEBUG\n    y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n#endif\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"unflex '%s'%d -%s-> '%s'\"",
            "toString().c_str()",
            "number",
            "type->toString().c_str()",
            "tp->toString().c_str()"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp->toString",
          "args": [],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp->concat",
          "args": [
            "m_arguments->parameterType(index)->unflex (type, number)"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "concat",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1649-1661",
          "snippet": "void\nFunctionType::concat (constTypePtr t)\n{\n    if (!m_arguments)\n    {\n\tm_arguments = TupleTypePtr (new TupleType (t));\n    }\n    else\n    {\n\tm_arguments->concat (t);\n    }\n    return;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  void\n  FunctionType::concat (constTypePtr t)\n  {\n      if (!m_arguments)\n      {\n  \tm_arguments = TupleTypePtr (new TupleType (t));\n      }\n      else\n      {\n  \tm_arguments->concat (t);\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_arguments->parameterType",
          "args": [
            "type",
            "number"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_arguments->parameterType",
          "args": [
            "index"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "parameterType",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1675-1683",
          "snippet": "constTypePtr\nFunctionType::parameterType (unsigned int parameter_number) const\n{\n    if (!m_arguments)\n    {\n\treturn Type::Error;\n    }\n    return m_arguments->parameterType (parameter_number);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nFunctionType {\n  constTypePtr\n  FunctionType::parameterType (unsigned int parameter_number) const\n  {\n      if (!m_arguments)\n      {\n  \treturn Type::Error;\n      }\n      return m_arguments->parameterType (parameter_number);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_arguments->parameterCount",
          "args": [],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionTypePtr",
          "args": [
            "new FunctionType (m_returntype->unflex (type, number))"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_returntype->unflex",
          "args": [
            "type",
            "number"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "unflex",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1857-1872",
          "snippet": "constTypePtr\nFunctionType::unflex (constTypePtr type, unsigned int number) const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype->unflex (type, number)));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount (); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType(index)->unflex (type, number));\n\t}\n    }\n#if DO_DEBUG\n    y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n#endif\n    return tp;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  constTypePtr\n  FunctionType::unflex (constTypePtr type, unsigned int number) const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype->unflex (type, number)));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount (); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType(index)->unflex (type, number));\n  \t}\n      }\n  #if DO_DEBUG\n      y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n  #endif\n      return tp;\n  }\n}"
  },
  {
    "function_name": "clone",
    "container": "FunctionType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1842-1854",
    "snippet": "TypePtr\nFunctionType::clone () const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType (index));\n\t}\n    }\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tp->concat",
          "args": [
            "m_arguments->parameterType (index)"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "concat",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1649-1661",
          "snippet": "void\nFunctionType::concat (constTypePtr t)\n{\n    if (!m_arguments)\n    {\n\tm_arguments = TupleTypePtr (new TupleType (t));\n    }\n    else\n    {\n\tm_arguments->concat (t);\n    }\n    return;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  void\n  FunctionType::concat (constTypePtr t)\n  {\n      if (!m_arguments)\n      {\n  \tm_arguments = TupleTypePtr (new TupleType (t));\n      }\n      else\n      {\n  \tm_arguments->concat (t);\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_arguments->parameterType",
          "args": [
            "index"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "parameterType",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1675-1683",
          "snippet": "constTypePtr\nFunctionType::parameterType (unsigned int parameter_number) const\n{\n    if (!m_arguments)\n    {\n\treturn Type::Error;\n    }\n    return m_arguments->parameterType (parameter_number);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nFunctionType {\n  constTypePtr\n  FunctionType::parameterType (unsigned int parameter_number) const\n  {\n      if (!m_arguments)\n      {\n  \treturn Type::Error;\n      }\n      return m_arguments->parameterType (parameter_number);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_arguments->parameterCount",
          "args": [],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionTypePtr",
          "args": [
            "new FunctionType (m_returntype)"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  TypePtr\n  FunctionType::clone () const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType (index));\n  \t}\n      }\n      return tp;\n  }\n}"
  },
  {
    "function_name": "equals",
    "container": "FunctionType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1800-1839",
    "snippet": "bool\nFunctionType::equals (constTypePtr expected) const\n{\n#if DO_DEBUG\n//    y2debug (\"FunctionType::equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    if (expected->isFunction())\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (! m_returntype->equals (ft->m_returntype))\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return false;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return true;\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (! m_arguments->parameterType(index)->equals (ft->parameterType(index)))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter %d type mismatch\", index);\n#endif\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n    return false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_arguments->parameterType",
          "args": [
            "ft->parameterType(index)"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "parameterType",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1675-1683",
          "snippet": "constTypePtr\nFunctionType::parameterType (unsigned int parameter_number) const\n{\n    if (!m_arguments)\n    {\n\treturn Type::Error;\n    }\n    return m_arguments->parameterType (parameter_number);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nFunctionType {\n  constTypePtr\n  FunctionType::parameterType (unsigned int parameter_number) const\n  {\n      if (!m_arguments)\n      {\n  \treturn Type::Error;\n      }\n      return m_arguments->parameterType (parameter_number);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_arguments->parameterCount",
          "args": [],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_returntype->equals",
          "args": [
            "ft->m_returntype"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "equals",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1800-1839",
          "snippet": "bool\nFunctionType::equals (constTypePtr expected) const\n{\n#if DO_DEBUG\n//    y2debug (\"FunctionType::equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    if (expected->isFunction())\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (! m_returntype->equals (ft->m_returntype))\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return false;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return true;\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (! m_arguments->parameterType(index)->equals (ft->parameterType(index)))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter %d type mismatch\", index);\n#endif\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n    return false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "expected->isFunction",
          "args": [],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "isFunction",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "303-303",
          "snippet": "bool isFunction () const\t{ return m_kind == FunctionT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isFunction () const\t{ return m_kind == FunctionT; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  bool\n  FunctionType::equals (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n  //    y2debug (\"FunctionType::equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      if (expected->isFunction())\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (! m_returntype->equals (ft->m_returntype))\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return false;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return true;\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (! m_arguments->parameterType(index)->equals (ft->parameterType(index)))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter %d type mismatch\", index);\n  #endif\n  \t\treturn false;\n  \t    }\n  \t}\n  \treturn true;\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "match",
    "container": "FunctionType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1739-1797",
    "snippet": "int\nFunctionType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    int bm = basematch (expected);\n\n    if (bm == 1) return 0;\t\t// any or wildcard match\n\n    if ((bm == 0\n\t    && expected->isFunction()))\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (m_returntype->match (ft->m_returntype) < 0)\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return -1;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return 0;\n\t}\n\n\tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n\tif (!wildcard)\n\t{\n\t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter count mismatch\");\n#endif\n\t\treturn -1;\n\t    }\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > esize\t\t\t// don't check wildcard parameters\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n\t    {\n\t\treturn -1;\n\t    }\n\t}\n\treturn 0;\n    }\n    return -1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_arguments->parameterType",
          "args": [
            "ft->parameterType(index)"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "parameterType",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1675-1683",
          "snippet": "constTypePtr\nFunctionType::parameterType (unsigned int parameter_number) const\n{\n    if (!m_arguments)\n    {\n\treturn Type::Error;\n    }\n    return m_arguments->parameterType (parameter_number);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nFunctionType {\n  constTypePtr\n  FunctionType::parameterType (unsigned int parameter_number) const\n  {\n      if (!m_arguments)\n      {\n  \treturn Type::Error;\n      }\n      return m_arguments->parameterType (parameter_number);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_arguments->parameterCount",
          "args": [],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ft->parameterType",
          "args": [],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_returntype->match",
          "args": [
            "ft->m_returntype"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1739-1797",
          "snippet": "int\nFunctionType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    int bm = basematch (expected);\n\n    if (bm == 1) return 0;\t\t// any or wildcard match\n\n    if ((bm == 0\n\t    && expected->isFunction()))\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (m_returntype->match (ft->m_returntype) < 0)\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return -1;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return 0;\n\t}\n\n\tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n\tif (!wildcard)\n\t{\n\t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter count mismatch\");\n#endif\n\t\treturn -1;\n\t    }\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > esize\t\t\t// don't check wildcard parameters\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n\t    {\n\t\treturn -1;\n\t    }\n\t}\n\treturn 0;\n    }\n    return -1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "expected->isFunction",
          "args": [],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "isFunction",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "303-303",
          "snippet": "bool isFunction () const\t{ return m_kind == FunctionT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isFunction () const\t{ return m_kind == FunctionT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "basematch",
          "args": [
            "expected"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "basematch",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "251-302",
          "snippet": "int\nType::basematch (constTypePtr expected) const\n{\n    tkind ek = expected->m_kind;\n\n#if DO_DEBUG\n//    y2debug (\"basematch '%s', expected '%s'[%d]\", toString().c_str(), expected->toString().c_str(), ek);\n#endif\n\n    if (isError()\n\t|| ek == ErrorT)\n    {\n#if DO_DEBUG\n\ty2debug (\"Error !\");\n#endif\n\treturn -1;\n    }\n\n    if (expected->isReference()\n\t&& (!expected->isConst()\n\t    && isConst()))\n    {\n#if DO_DEBUG\n\ty2debug (\"doesn't expect const\");\n#endif\n\treturn -1;\n    }\n\n    if (ek == AnyT\n\t|| ek == FlexT\n\t|| ek == NFlexT\n\t|| ek == WildcardT\n\t|| ek == UnspecT)\t\t\t// list == list<unspec>\n    {\n#if DO_DEBUG\n//\ty2debug (\"free match\");\n#endif\n\treturn 1;\n    }\n\n    if (isVoid())\t\t\t\t// nil matches everywhere\n    {\n\treturn 0;\n    }\n\n    if (isBasetype() == expected->isBasetype())\n    {\n\treturn 0;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nType {\n  int\n  Type::basematch (constTypePtr expected) const\n  {\n      tkind ek = expected->m_kind;\n  \n  #if DO_DEBUG\n  //    y2debug (\"basematch '%s', expected '%s'[%d]\", toString().c_str(), expected->toString().c_str(), ek);\n  #endif\n  \n      if (isError()\n  \t|| ek == ErrorT)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Error !\");\n  #endif\n  \treturn -1;\n      }\n  \n      if (expected->isReference()\n  \t&& (!expected->isConst()\n  \t    && isConst()))\n      {\n  #if DO_DEBUG\n  \ty2debug (\"doesn't expect const\");\n  #endif\n  \treturn -1;\n      }\n  \n      if (ek == AnyT\n  \t|| ek == FlexT\n  \t|| ek == NFlexT\n  \t|| ek == WildcardT\n  \t|| ek == UnspecT)\t\t\t// list == list<unspec>\n      {\n  #if DO_DEBUG\n  //\ty2debug (\"free match\");\n  #endif\n  \treturn 1;\n      }\n  \n      if (isVoid())\t\t\t\t// nil matches everywhere\n      {\n  \treturn 0;\n      }\n  \n      if (isBasetype() == expected->isBasetype())\n      {\n  \treturn 0;\n      }\n  \n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"FunctionType::match '%s', expected '%s'\"",
            "toString().c_str()",
            "expected->toString().c_str()"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected->toString",
          "args": [],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  int\n  FunctionType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      int bm = basematch (expected);\n  \n      if (bm == 1) return 0;\t\t// any or wildcard match\n  \n      if ((bm == 0\n  \t    && expected->isFunction()))\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (m_returntype->match (ft->m_returntype) < 0)\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return -1;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return 0;\n  \t}\n  \n  \tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n  \tif (!wildcard)\n  \t{\n  \t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter count mismatch\");\n  #endif\n  \t\treturn -1;\n  \t    }\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > esize\t\t\t// don't check wildcard parameters\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n  \t    {\n  \t\treturn -1;\n  \t    }\n  \t}\n  \treturn 0;\n      }\n      return -1;\n  }\n}"
  },
  {
    "function_name": "matchFlex",
    "container": "FunctionType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1716-1736",
    "snippet": "constTypePtr\nFunctionType::matchFlex (constTypePtr type, unsigned int number) const\n{\n#if DO_DEBUG\n    y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n#endif\n    if (!type->isFunction())\n    {\n\treturn 0;\n    }\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    constFunctionTypePtr ft = (constFunctionTypePtr)type;\n    if (!ft->m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->matchFlex (ft->m_arguments, number);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_arguments->matchFlex",
          "args": [
            "ft->m_arguments",
            "number"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "matchFlex",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1716-1736",
          "snippet": "constTypePtr\nFunctionType::matchFlex (constTypePtr type, unsigned int number) const\n{\n#if DO_DEBUG\n    y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n#endif\n    if (!type->isFunction())\n    {\n\treturn 0;\n    }\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    constFunctionTypePtr ft = (constFunctionTypePtr)type;\n    if (!ft->m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->matchFlex (ft->m_arguments, number);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "type->isFunction",
          "args": [],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "isFunction",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "303-303",
          "snippet": "bool isFunction () const\t{ return m_kind == FunctionT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isFunction () const\t{ return m_kind == FunctionT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"matchFlex '%s' (%s)\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  constTypePtr\n  FunctionType::matchFlex (constTypePtr type, unsigned int number) const\n  {\n  #if DO_DEBUG\n      y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n  #endif\n      if (!type->isFunction())\n      {\n  \treturn 0;\n      }\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      constFunctionTypePtr ft = (constFunctionTypePtr)type;\n      if (!ft->m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->matchFlex (ft->m_arguments, number);\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "FunctionType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1693-1713",
    "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "postToString",
          "args": [],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "postToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "244-244",
          "snippet": "string postToString () const { return (m_reference ? \" &\" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string postToString () const { return (m_reference ? \" &\" : \"\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_arguments->parameterType",
          "args": [],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_arguments->parameterType",
          "args": [
            "index"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "parameterType",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1675-1683",
          "snippet": "constTypePtr\nFunctionType::parameterType (unsigned int parameter_number) const\n{\n    if (!m_arguments)\n    {\n\treturn Type::Error;\n    }\n    return m_arguments->parameterType (parameter_number);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nFunctionType {\n  constTypePtr\n  FunctionType::parameterType (unsigned int parameter_number) const\n  {\n      if (!m_arguments)\n      {\n  \treturn Type::Error;\n      }\n      return m_arguments->parameterType (parameter_number);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_arguments->parameterCount",
          "args": [],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_returntype->toString",
          "args": [],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "preToString",
          "args": [],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "preToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "239-239",
          "snippet": "string preToString () const { return (m_const ? \"const \" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string preToString () const { return (m_const ? \"const \" : \"\"); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
  },
  {
    "function_name": "parameters",
    "container": "FunctionType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1686-1690",
    "snippet": "constTupleTypePtr\nFunctionType::parameters () const\n{\n    return m_arguments;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  constTupleTypePtr\n  FunctionType::parameters () const\n  {\n      return m_arguments;\n  }\n}"
  },
  {
    "function_name": "parameterType",
    "container": "FunctionType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1675-1683",
    "snippet": "constTypePtr\nFunctionType::parameterType (unsigned int parameter_number) const\n{\n    if (!m_arguments)\n    {\n\treturn Type::Error;\n    }\n    return m_arguments->parameterType (parameter_number);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_arguments->parameterType",
          "args": [
            "parameter_number"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "parameterType",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1675-1683",
          "snippet": "constTypePtr\nFunctionType::parameterType (unsigned int parameter_number) const\n{\n    if (!m_arguments)\n    {\n\treturn Type::Error;\n    }\n    return m_arguments->parameterType (parameter_number);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nFunctionType {\n  constTypePtr\n  FunctionType::parameterType (unsigned int parameter_number) const\n  {\n      if (!m_arguments)\n      {\n  \treturn Type::Error;\n      }\n      return m_arguments->parameterType (parameter_number);\n  }\n}"
  },
  {
    "function_name": "parameterCount",
    "container": "FunctionType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1664-1672",
    "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_arguments->parameterCount",
          "args": [],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
  },
  {
    "function_name": "concat",
    "container": "FunctionType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1649-1661",
    "snippet": "void\nFunctionType::concat (constTypePtr t)\n{\n    if (!m_arguments)\n    {\n\tm_arguments = TupleTypePtr (new TupleType (t));\n    }\n    else\n    {\n\tm_arguments->concat (t);\n    }\n    return;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_arguments->concat",
          "args": [
            "t"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "concat",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1649-1661",
          "snippet": "void\nFunctionType::concat (constTypePtr t)\n{\n    if (!m_arguments)\n    {\n\tm_arguments = TupleTypePtr (new TupleType (t));\n    }\n    else\n    {\n\tm_arguments->concat (t);\n    }\n    return;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "TupleTypePtr",
          "args": [
            "new TupleType (t)"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  void\n  FunctionType::concat (constTypePtr t)\n  {\n      if (!m_arguments)\n      {\n  \tm_arguments = TupleTypePtr (new TupleType (t));\n      }\n      else\n      {\n  \tm_arguments->concat (t);\n      }\n      return;\n  }\n}"
  },
  {
    "function_name": "~FunctionType",
    "container": "FunctionType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1644-1646",
    "snippet": "FunctionType::~FunctionType ()\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  FunctionType::~FunctionType ()\n  {\n  }\n}"
  },
  {
    "function_name": "FunctionType",
    "container": "FunctionType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1606-1620",
    "snippet": "FunctionType::FunctionType (bytecodeistream & str)\n    : Type (FunctionT, str)\n    , m_returntype (Bytecode::readType (str))\n{\n#if DO_DEBUG\n    y2debug (\"FunctionType::FunctionType (stream)\");\n#endif\n    if (Bytecode::readBool (str))\n    {\n\tm_arguments = Bytecode::readType (str);\n    }\n#if DO_DEBUG\n    y2debug (\"FunctionType::fromStream (m_returntype %p, m_arguments %p)\", (const void *)m_returntype, (const void *)m_arguments);\n#endif\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"FunctionType::fromStream (m_returntype %p, m_arguments %p)\"",
            "(const void *)m_returntype",
            "(const void *)m_arguments"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readType",
          "args": [
            "str"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "readType",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "349-387",
          "snippet": "TypePtr\nBytecode::readType (bytecodeistream & str)\n{\n    int kind = readInt32 (str);\n#if DO_DEBUG\ny2debug (\"Bytecode::readType(%d)\", kind);\n#endif\n    switch ((Type::tkind)kind)\n    {\n\tcase Type::UnspecT:\n\tcase Type::ErrorT:\n\tcase Type::AnyT:\n\tcase Type::BooleanT:\n\tcase Type::ByteblockT:\n\tcase Type::FloatT:\n\tcase Type::IntegerT:\n\tcase Type::LocaleT:\n\tcase Type::PathT:\n\tcase Type::StringT:\n\tcase Type::SymbolT:\n\tcase Type::TermT:\n\tcase Type::VoidT:\n\tcase Type::WildcardT:\n\tcase Type::FlexT:\n\tcase Type::NilT:\n\t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n\tbreak;\n\n\tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n\tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n\tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n\tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n\tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n\tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n\tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n    }\n    y2error (\"Unhandled type kind %d\", kind);\n    return Type::Error->clone();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  TypePtr\n  Bytecode::readType (bytecodeistream & str)\n  {\n      int kind = readInt32 (str);\n  #if DO_DEBUG\n  y2debug (\"Bytecode::readType(%d)\", kind);\n  #endif\n      switch ((Type::tkind)kind)\n      {\n  \tcase Type::UnspecT:\n  \tcase Type::ErrorT:\n  \tcase Type::AnyT:\n  \tcase Type::BooleanT:\n  \tcase Type::ByteblockT:\n  \tcase Type::FloatT:\n  \tcase Type::IntegerT:\n  \tcase Type::LocaleT:\n  \tcase Type::PathT:\n  \tcase Type::StringT:\n  \tcase Type::SymbolT:\n  \tcase Type::TermT:\n  \tcase Type::VoidT:\n  \tcase Type::WildcardT:\n  \tcase Type::FlexT:\n  \tcase Type::NilT:\n  \t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n  \tbreak;\n  \n  \tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n  \tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n  \tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n  \tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n  \tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n  \tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n  \tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n      }\n      y2error (\"Unhandled type kind %d\", kind);\n      return Type::Error->clone();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readBool",
          "args": [
            "str"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "readBool",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "158-172",
          "snippet": "bool\nBytecode::readBool (bytecodeistream & str)\n{\n    char c;\n    str.get (c);\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n#endif\n\n    if (c != 0)\n    {\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readBool (bytecodeistream & str)\n  {\n      char c;\n      str.get (c);\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n  #endif\n  \n      if (c != 0)\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"FunctionType::FunctionType (stream)\""
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  FunctionType::FunctionType (bytecodeistream & str)\n      : Type (FunctionT, str)\n      , m_returntype (Bytecode::readType (str))\n  {\n  #if DO_DEBUG\n      y2debug (\"FunctionType::FunctionType (stream)\");\n  #endif\n      if (Bytecode::readBool (str))\n      {\n  \tm_arguments = Bytecode::readType (str);\n      }\n  #if DO_DEBUG\n      y2debug (\"FunctionType::fromStream (m_returntype %p, m_arguments %p)\", (const void *)m_returntype, (const void *)m_arguments);\n  #endif\n  }\n}"
  },
  {
    "function_name": "FunctionType",
    "container": "FunctionType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1596-1604",
    "snippet": "FunctionType::FunctionType (constTypePtr return_type, constFunctionTypePtr arguments)\n    : Type (FunctionT)\n    , m_returntype (return_type)\n{\n    for (int i = 0; i < arguments->parameterCount (); i++)\n    {\n\tconcat (arguments->parameterType (i));\n    }\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "concat",
          "args": [
            "arguments->parameterType (i)"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "concat",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1649-1661",
          "snippet": "void\nFunctionType::concat (constTypePtr t)\n{\n    if (!m_arguments)\n    {\n\tm_arguments = TupleTypePtr (new TupleType (t));\n    }\n    else\n    {\n\tm_arguments->concat (t);\n    }\n    return;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  void\n  FunctionType::concat (constTypePtr t)\n  {\n      if (!m_arguments)\n      {\n  \tm_arguments = TupleTypePtr (new TupleType (t));\n      }\n      else\n      {\n  \tm_arguments->concat (t);\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arguments->parameterType",
          "args": [
            "i"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "parameterType",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1675-1683",
          "snippet": "constTypePtr\nFunctionType::parameterType (unsigned int parameter_number) const\n{\n    if (!m_arguments)\n    {\n\treturn Type::Error;\n    }\n    return m_arguments->parameterType (parameter_number);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nFunctionType {\n  constTypePtr\n  FunctionType::parameterType (unsigned int parameter_number) const\n  {\n      if (!m_arguments)\n      {\n  \treturn Type::Error;\n      }\n      return m_arguments->parameterType (parameter_number);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arguments->parameterCount",
          "args": [],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  FunctionType::FunctionType (constTypePtr return_type, constFunctionTypePtr arguments)\n      : Type (FunctionT)\n      , m_returntype (return_type)\n  {\n      for (int i = 0; i < arguments->parameterCount (); i++)\n      {\n  \tconcat (arguments->parameterType (i));\n      }\n  }\n}"
  },
  {
    "function_name": "FunctionType",
    "container": "FunctionType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1590-1594",
    "snippet": "FunctionType::FunctionType (constTypePtr returntype, bool as_const)\n    : Type (FunctionT, as_const)\n    , m_returntype (returntype)\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  FunctionType::FunctionType (constTypePtr returntype, bool as_const)\n      : Type (FunctionT, as_const)\n      , m_returntype (returntype)\n  {\n  }\n}"
  },
  {
    "function_name": "unflex",
    "container": "TupleType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1573-1585",
    "snippet": "constTypePtr\nTupleType::unflex (constTypePtr type, unsigned int number) const\n{\n    TupleTypePtr tp = TupleTypePtr (new TupleType (m_types[0]->unflex (type, number)));\n    for (unsigned index = 1; index < m_types.size(); index++)\n    {\n\ttp->concat (m_types[index]->unflex (type, number));\n    }\n#if DO_DEBUG\n    y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n#endif\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"unflex '%s'%d -%s-> '%s'\"",
            "toString().c_str()",
            "number",
            "type->toString().c_str()",
            "tp->toString().c_str()"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp->toString",
          "args": [],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp->concat",
          "args": [
            "m_types[index]->unflex (type, number)"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "concat",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1649-1661",
          "snippet": "void\nFunctionType::concat (constTypePtr t)\n{\n    if (!m_arguments)\n    {\n\tm_arguments = TupleTypePtr (new TupleType (t));\n    }\n    else\n    {\n\tm_arguments->concat (t);\n    }\n    return;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  void\n  FunctionType::concat (constTypePtr t)\n  {\n      if (!m_arguments)\n      {\n  \tm_arguments = TupleTypePtr (new TupleType (t));\n      }\n      else\n      {\n  \tm_arguments->concat (t);\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_types[index]->unflex",
          "args": [
            "type",
            "number"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "unflex",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1857-1872",
          "snippet": "constTypePtr\nFunctionType::unflex (constTypePtr type, unsigned int number) const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype->unflex (type, number)));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount (); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType(index)->unflex (type, number));\n\t}\n    }\n#if DO_DEBUG\n    y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n#endif\n    return tp;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  constTypePtr\n  FunctionType::unflex (constTypePtr type, unsigned int number) const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype->unflex (type, number)));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount (); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType(index)->unflex (type, number));\n  \t}\n      }\n  #if DO_DEBUG\n      y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n  #endif\n      return tp;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_types.size",
          "args": [],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TupleTypePtr",
          "args": [
            "new TupleType (m_types[0]->unflex (type, number))"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nTupleType {\n  constTypePtr\n  TupleType::unflex (constTypePtr type, unsigned int number) const\n  {\n      TupleTypePtr tp = TupleTypePtr (new TupleType (m_types[0]->unflex (type, number)));\n      for (unsigned index = 1; index < m_types.size(); index++)\n      {\n  \ttp->concat (m_types[index]->unflex (type, number));\n      }\n  #if DO_DEBUG\n      y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n  #endif\n      return tp;\n  }\n}"
  },
  {
    "function_name": "clone",
    "container": "TupleType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1561-1570",
    "snippet": "TypePtr\nTupleType::clone () const\n{\n    TupleTypePtr tp = TupleTypePtr (new TupleType (m_types[0]));\n    for (unsigned index = 1; index < m_types.size(); index++)\n    {\n\ttp->concat (m_types[index]);\n    }\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tp->concat",
          "args": [
            "m_types[index]"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "concat",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1649-1661",
          "snippet": "void\nFunctionType::concat (constTypePtr t)\n{\n    if (!m_arguments)\n    {\n\tm_arguments = TupleTypePtr (new TupleType (t));\n    }\n    else\n    {\n\tm_arguments->concat (t);\n    }\n    return;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  void\n  FunctionType::concat (constTypePtr t)\n  {\n      if (!m_arguments)\n      {\n  \tm_arguments = TupleTypePtr (new TupleType (t));\n      }\n      else\n      {\n  \tm_arguments->concat (t);\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_types.size",
          "args": [],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TupleTypePtr",
          "args": [
            "new TupleType (m_types[0])"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nTupleType {\n  TypePtr\n  TupleType::clone () const\n  {\n      TupleTypePtr tp = TupleTypePtr (new TupleType (m_types[0]));\n      for (unsigned index = 1; index < m_types.size(); index++)\n      {\n  \ttp->concat (m_types[index]);\n      }\n      return tp;\n  }\n}"
  },
  {
    "function_name": "canCast",
    "container": "TupleType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1535-1558",
    "snippet": "bool\nTupleType::canCast (constTypePtr to) const\n{\n    if (to->isTuple ())\n    {\n\tconst TupleType & tt = (const TupleType)to;\n\tunsigned int esize = tt.m_types.size();\n\tbool wildcard = tt.m_types[esize-1]->isWildcard();\n\tfor (unsigned index = 0; index < m_types.size(); index++)\n\t{\n\t    if (index > esize\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (!m_types[index]->canCast (tt.m_types[index]))\n\t    {\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n    return false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_types[index]->canCast",
          "args": [
            "tt.m_types[index]"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "canCast",
          "container": "TupleType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1535-1558",
          "snippet": "bool\nTupleType::canCast (constTypePtr to) const\n{\n    if (to->isTuple ())\n    {\n\tconst TupleType & tt = (const TupleType)to;\n\tunsigned int esize = tt.m_types.size();\n\tbool wildcard = tt.m_types[esize-1]->isWildcard();\n\tfor (unsigned index = 0; index < m_types.size(); index++)\n\t{\n\t    if (index > esize\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (!m_types[index]->canCast (tt.m_types[index]))\n\t    {\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n    return false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "m_types.size",
          "args": [],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tt.m_types[esize-1]->isWildcard",
          "args": [],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "isWildcard",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "294-294",
          "snippet": "bool isWildcard () const\t{ return m_kind == WildcardT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isWildcard () const\t{ return m_kind == WildcardT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "to->isTuple",
          "args": [],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "isTuple",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "302-302",
          "snippet": "bool isTuple () const\t{ return m_kind == TupleT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isTuple () const\t{ return m_kind == TupleT; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nTupleType {\n  bool\n  TupleType::canCast (constTypePtr to) const\n  {\n      if (to->isTuple ())\n      {\n  \tconst TupleType & tt = (const TupleType)to;\n  \tunsigned int esize = tt.m_types.size();\n  \tbool wildcard = tt.m_types[esize-1]->isWildcard();\n  \tfor (unsigned index = 0; index < m_types.size(); index++)\n  \t{\n  \t    if (index > esize\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (!m_types[index]->canCast (tt.m_types[index]))\n  \t    {\n  \t\treturn false;\n  \t    }\n  \t}\n  \treturn true;\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "equals",
    "container": "TupleType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1506-1532",
    "snippet": "bool\nTupleType::equals (constTypePtr expected) const\n{\n#if DO_DEBUG\n//    y2debug (\"equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    if (expected->isTuple())\n    {\n\tconst TupleType & tt = (const TupleType)expected;\n\tunsigned int esize = tt.m_types.size();\n\n\tif (esize != m_types.size ())\n\t{\n\t    return false;\n\t}\n\n\tfor (unsigned index = 0; index < m_types.size(); index++)\n\t{\n\t    if (m_types[index]->equals (tt.m_types[index]))\n\t    {\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n    return false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_types[index]->equals",
          "args": [
            "tt.m_types[index]"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "equals",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1800-1839",
          "snippet": "bool\nFunctionType::equals (constTypePtr expected) const\n{\n#if DO_DEBUG\n//    y2debug (\"FunctionType::equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    if (expected->isFunction())\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (! m_returntype->equals (ft->m_returntype))\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return false;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return true;\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (! m_arguments->parameterType(index)->equals (ft->parameterType(index)))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter %d type mismatch\", index);\n#endif\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  bool\n  FunctionType::equals (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n  //    y2debug (\"FunctionType::equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      if (expected->isFunction())\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (! m_returntype->equals (ft->m_returntype))\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return false;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return true;\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (! m_arguments->parameterType(index)->equals (ft->parameterType(index)))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter %d type mismatch\", index);\n  #endif\n  \t\treturn false;\n  \t    }\n  \t}\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_types.size",
          "args": [],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expected->isTuple",
          "args": [],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "isTuple",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "302-302",
          "snippet": "bool isTuple () const\t{ return m_kind == TupleT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isTuple () const\t{ return m_kind == TupleT; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nTupleType {\n  bool\n  TupleType::equals (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n  //    y2debug (\"equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      if (expected->isTuple())\n      {\n  \tconst TupleType & tt = (const TupleType)expected;\n  \tunsigned int esize = tt.m_types.size();\n  \n  \tif (esize != m_types.size ())\n  \t{\n  \t    return false;\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_types.size(); index++)\n  \t{\n  \t    if (m_types[index]->equals (tt.m_types[index]))\n  \t    {\n  \t\treturn false;\n  \t    }\n  \t}\n  \treturn true;\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "match",
    "container": "TupleType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1469-1503",
    "snippet": "int\nTupleType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    int bm = basematch (expected);\n\n    if (bm == 1)\n    {\n\treturn 0;\n    }\n\n    if (bm == 0\n\t    && expected->isTuple())\n    {\n\tconstTupleTypePtr tt = expected;\n\tunsigned int esize = tt->m_types.size();\n\tbool wildcard = tt->m_types[esize-1]->isWildcard();\n\tfor (unsigned index = 0; index < m_types.size(); index++)\n\t{\n\t    if (index > esize\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (m_types[index]->match (tt->m_types[index]) < 0)\n\t    {\n\t\treturn -1;\n\t    }\n\t}\n\treturn 0;\n    }\n    return -1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_types[index]->match",
          "args": [
            "tt->m_types[index]"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1739-1797",
          "snippet": "int\nFunctionType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    int bm = basematch (expected);\n\n    if (bm == 1) return 0;\t\t// any or wildcard match\n\n    if ((bm == 0\n\t    && expected->isFunction()))\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (m_returntype->match (ft->m_returntype) < 0)\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return -1;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return 0;\n\t}\n\n\tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n\tif (!wildcard)\n\t{\n\t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter count mismatch\");\n#endif\n\t\treturn -1;\n\t    }\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > esize\t\t\t// don't check wildcard parameters\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n\t    {\n\t\treturn -1;\n\t    }\n\t}\n\treturn 0;\n    }\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  int\n  FunctionType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      int bm = basematch (expected);\n  \n      if (bm == 1) return 0;\t\t// any or wildcard match\n  \n      if ((bm == 0\n  \t    && expected->isFunction()))\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (m_returntype->match (ft->m_returntype) < 0)\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return -1;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return 0;\n  \t}\n  \n  \tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n  \tif (!wildcard)\n  \t{\n  \t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter count mismatch\");\n  #endif\n  \t\treturn -1;\n  \t    }\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > esize\t\t\t// don't check wildcard parameters\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n  \t    {\n  \t\treturn -1;\n  \t    }\n  \t}\n  \treturn 0;\n      }\n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_types.size",
          "args": [],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tt->m_types[esize-1]->isWildcard",
          "args": [],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "isWildcard",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "294-294",
          "snippet": "bool isWildcard () const\t{ return m_kind == WildcardT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isWildcard () const\t{ return m_kind == WildcardT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expected->isTuple",
          "args": [],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "isTuple",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "302-302",
          "snippet": "bool isTuple () const\t{ return m_kind == TupleT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isTuple () const\t{ return m_kind == TupleT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "basematch",
          "args": [
            "expected"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "basematch",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "251-302",
          "snippet": "int\nType::basematch (constTypePtr expected) const\n{\n    tkind ek = expected->m_kind;\n\n#if DO_DEBUG\n//    y2debug (\"basematch '%s', expected '%s'[%d]\", toString().c_str(), expected->toString().c_str(), ek);\n#endif\n\n    if (isError()\n\t|| ek == ErrorT)\n    {\n#if DO_DEBUG\n\ty2debug (\"Error !\");\n#endif\n\treturn -1;\n    }\n\n    if (expected->isReference()\n\t&& (!expected->isConst()\n\t    && isConst()))\n    {\n#if DO_DEBUG\n\ty2debug (\"doesn't expect const\");\n#endif\n\treturn -1;\n    }\n\n    if (ek == AnyT\n\t|| ek == FlexT\n\t|| ek == NFlexT\n\t|| ek == WildcardT\n\t|| ek == UnspecT)\t\t\t// list == list<unspec>\n    {\n#if DO_DEBUG\n//\ty2debug (\"free match\");\n#endif\n\treturn 1;\n    }\n\n    if (isVoid())\t\t\t\t// nil matches everywhere\n    {\n\treturn 0;\n    }\n\n    if (isBasetype() == expected->isBasetype())\n    {\n\treturn 0;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nType {\n  int\n  Type::basematch (constTypePtr expected) const\n  {\n      tkind ek = expected->m_kind;\n  \n  #if DO_DEBUG\n  //    y2debug (\"basematch '%s', expected '%s'[%d]\", toString().c_str(), expected->toString().c_str(), ek);\n  #endif\n  \n      if (isError()\n  \t|| ek == ErrorT)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Error !\");\n  #endif\n  \treturn -1;\n      }\n  \n      if (expected->isReference()\n  \t&& (!expected->isConst()\n  \t    && isConst()))\n      {\n  #if DO_DEBUG\n  \ty2debug (\"doesn't expect const\");\n  #endif\n  \treturn -1;\n      }\n  \n      if (ek == AnyT\n  \t|| ek == FlexT\n  \t|| ek == NFlexT\n  \t|| ek == WildcardT\n  \t|| ek == UnspecT)\t\t\t// list == list<unspec>\n      {\n  #if DO_DEBUG\n  //\ty2debug (\"free match\");\n  #endif\n  \treturn 1;\n      }\n  \n      if (isVoid())\t\t\t\t// nil matches everywhere\n      {\n  \treturn 0;\n      }\n  \n      if (isBasetype() == expected->isBasetype())\n      {\n  \treturn 0;\n      }\n  \n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"match '%s', expected '%s'\"",
            "toString().c_str()",
            "expected->toString().c_str()"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected->toString",
          "args": [],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nTupleType {\n  int\n  TupleType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      int bm = basematch (expected);\n  \n      if (bm == 1)\n      {\n  \treturn 0;\n      }\n  \n      if (bm == 0\n  \t    && expected->isTuple())\n      {\n  \tconstTupleTypePtr tt = expected;\n  \tunsigned int esize = tt->m_types.size();\n  \tbool wildcard = tt->m_types[esize-1]->isWildcard();\n  \tfor (unsigned index = 0; index < m_types.size(); index++)\n  \t{\n  \t    if (index > esize\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (m_types[index]->match (tt->m_types[index]) < 0)\n  \t    {\n  \t\treturn -1;\n  \t    }\n  \t}\n  \treturn 0;\n      }\n      return -1;\n  }\n}"
  },
  {
    "function_name": "matchFlex",
    "container": "TupleType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1440-1466",
    "snippet": "constTypePtr\nTupleType::matchFlex (constTypePtr type, unsigned int number) const\n{\n#if DO_DEBUG\n    y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n#endif\n    if (!type->isTuple())\n    {\n\treturn 0;\n    }\n\n    constTupleTypePtr tt = (constTupleTypePtr)type;\n    for (unsigned index = 0; index < m_types.size(); index++)\n    {\n\tconstTypePtr t = tt->parameterType (index);\n\tif (t->isError())\n\t{\n\t    break;\n\t}\n\tt = m_types[index]->matchFlex (t, number);\n\tif (t != 0)\n\t{\n\t    return t;\n\t}\n    }\n    return 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_types[index]->matchFlex",
          "args": [
            "t",
            "number"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "matchFlex",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1716-1736",
          "snippet": "constTypePtr\nFunctionType::matchFlex (constTypePtr type, unsigned int number) const\n{\n#if DO_DEBUG\n    y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n#endif\n    if (!type->isFunction())\n    {\n\treturn 0;\n    }\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    constFunctionTypePtr ft = (constFunctionTypePtr)type;\n    if (!ft->m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->matchFlex (ft->m_arguments, number);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  constTypePtr\n  FunctionType::matchFlex (constTypePtr type, unsigned int number) const\n  {\n  #if DO_DEBUG\n      y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n  #endif\n      if (!type->isFunction())\n      {\n  \treturn 0;\n      }\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      constFunctionTypePtr ft = (constFunctionTypePtr)type;\n      if (!ft->m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->matchFlex (ft->m_arguments, number);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->isError",
          "args": [],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "isError",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "282-282",
          "snippet": "bool isError () const\t{ return m_kind == ErrorT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isError () const\t{ return m_kind == ErrorT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tt->parameterType",
          "args": [
            "index"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "parameterType",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1675-1683",
          "snippet": "constTypePtr\nFunctionType::parameterType (unsigned int parameter_number) const\n{\n    if (!m_arguments)\n    {\n\treturn Type::Error;\n    }\n    return m_arguments->parameterType (parameter_number);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nFunctionType {\n  constTypePtr\n  FunctionType::parameterType (unsigned int parameter_number) const\n  {\n      if (!m_arguments)\n      {\n  \treturn Type::Error;\n      }\n      return m_arguments->parameterType (parameter_number);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_types.size",
          "args": [],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isTuple",
          "args": [],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "isTuple",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "302-302",
          "snippet": "bool isTuple () const\t{ return m_kind == TupleT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isTuple () const\t{ return m_kind == TupleT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"matchFlex '%s' (%s)\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nTupleType {\n  constTypePtr\n  TupleType::matchFlex (constTypePtr type, unsigned int number) const\n  {\n  #if DO_DEBUG\n      y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n  #endif\n      if (!type->isTuple())\n      {\n  \treturn 0;\n      }\n  \n      constTupleTypePtr tt = (constTupleTypePtr)type;\n      for (unsigned index = 0; index < m_types.size(); index++)\n      {\n  \tconstTypePtr t = tt->parameterType (index);\n  \tif (t->isError())\n  \t{\n  \t    break;\n  \t}\n  \tt = m_types[index]->matchFlex (t, number);\n  \tif (t != 0)\n  \t{\n  \t    return t;\n  \t}\n      }\n      return 0;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "TupleType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1424-1437",
    "snippet": "string\nTupleType::toString () const\n{\n    string ret = preToString() + \"(\";\n\n    for (unsigned index = 0; index < m_types.size(); index++)\n    {\n\tif (index != 0) ret += \", \";\n\tret += m_types[index]->toString();\n    }\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "postToString",
          "args": [],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "postToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "244-244",
          "snippet": "string postToString () const { return (m_reference ? \" &\" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string postToString () const { return (m_reference ? \" &\" : \"\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_types[index]->toString",
          "args": [],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_types.size",
          "args": [],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "preToString",
          "args": [],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "preToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "239-239",
          "snippet": "string preToString () const { return (m_const ? \"const \" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string preToString () const { return (m_const ? \"const \" : \"\"); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nTupleType {\n  string\n  TupleType::toString () const\n  {\n      string ret = preToString() + \"(\";\n  \n      for (unsigned index = 0; index < m_types.size(); index++)\n      {\n  \tif (index != 0) ret += \", \";\n  \tret += m_types[index]->toString();\n      }\n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
  },
  {
    "function_name": "parameterType",
    "container": "TupleType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1413-1421",
    "snippet": "constTypePtr\nTupleType::parameterType (unsigned int parameter_number) const\n{\n    if (parameter_number >= m_types.size())\n    {\n\treturn Type::Error;\n    }\n    return m_types[parameter_number];\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_types.size",
          "args": [],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nTupleType {\n  constTypePtr\n  TupleType::parameterType (unsigned int parameter_number) const\n  {\n      if (parameter_number >= m_types.size())\n      {\n  \treturn Type::Error;\n      }\n      return m_types[parameter_number];\n  }\n}"
  },
  {
    "function_name": "concat",
    "container": "TupleType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1405-1410",
    "snippet": "void\nTupleType::concat (constTypePtr t)\n{\n    m_types.push_back (t);\n    return;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_types.push_back",
          "args": [
            "t"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nTupleType {\n  void\n  TupleType::concat (constTypePtr t)\n  {\n      m_types.push_back (t);\n      return;\n  }\n}"
  },
  {
    "function_name": "~TupleType",
    "container": "TupleType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1387-1389",
    "snippet": "TupleType::~TupleType()\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nTupleType {\n  TupleType::~TupleType()\n  {\n  }\n}"
  },
  {
    "function_name": "TupleType",
    "container": "TupleType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1370-1384",
    "snippet": "TupleType::TupleType (bytecodeistream & str)\n    : Type (TupleT, str)\n{\n    u_int32_t count = Bytecode::readInt32 (str);\n#if DO_DEBUG\n    y2debug (\"TupleType::TupleType %d elements\", count);\n#endif\n    for (unsigned index = 0; index < count; index++)\n    {\n\tm_types.push_back (Bytecode::readType (str));\n    }\n#if DO_DEBUG\n    y2debug (\"TupleType::TupleType done\");\n#endif\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"TupleType::TupleType done\""
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_types.push_back",
          "args": [
            "Bytecode::readType (str)"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readType",
          "args": [
            "str"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "readType",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "349-387",
          "snippet": "TypePtr\nBytecode::readType (bytecodeistream & str)\n{\n    int kind = readInt32 (str);\n#if DO_DEBUG\ny2debug (\"Bytecode::readType(%d)\", kind);\n#endif\n    switch ((Type::tkind)kind)\n    {\n\tcase Type::UnspecT:\n\tcase Type::ErrorT:\n\tcase Type::AnyT:\n\tcase Type::BooleanT:\n\tcase Type::ByteblockT:\n\tcase Type::FloatT:\n\tcase Type::IntegerT:\n\tcase Type::LocaleT:\n\tcase Type::PathT:\n\tcase Type::StringT:\n\tcase Type::SymbolT:\n\tcase Type::TermT:\n\tcase Type::VoidT:\n\tcase Type::WildcardT:\n\tcase Type::FlexT:\n\tcase Type::NilT:\n\t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n\tbreak;\n\n\tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n\tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n\tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n\tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n\tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n\tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n\tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n    }\n    y2error (\"Unhandled type kind %d\", kind);\n    return Type::Error->clone();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  TypePtr\n  Bytecode::readType (bytecodeistream & str)\n  {\n      int kind = readInt32 (str);\n  #if DO_DEBUG\n  y2debug (\"Bytecode::readType(%d)\", kind);\n  #endif\n      switch ((Type::tkind)kind)\n      {\n  \tcase Type::UnspecT:\n  \tcase Type::ErrorT:\n  \tcase Type::AnyT:\n  \tcase Type::BooleanT:\n  \tcase Type::ByteblockT:\n  \tcase Type::FloatT:\n  \tcase Type::IntegerT:\n  \tcase Type::LocaleT:\n  \tcase Type::PathT:\n  \tcase Type::StringT:\n  \tcase Type::SymbolT:\n  \tcase Type::TermT:\n  \tcase Type::VoidT:\n  \tcase Type::WildcardT:\n  \tcase Type::FlexT:\n  \tcase Type::NilT:\n  \t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n  \tbreak;\n  \n  \tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n  \tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n  \tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n  \tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n  \tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n  \tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n  \tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n      }\n      y2error (\"Unhandled type kind %d\", kind);\n      return Type::Error->clone();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"TupleType::TupleType %d elements\"",
            "count"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readInt32",
          "args": [
            "str"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nTupleType {\n  TupleType::TupleType (bytecodeistream & str)\n      : Type (TupleT, str)\n  {\n      u_int32_t count = Bytecode::readInt32 (str);\n  #if DO_DEBUG\n      y2debug (\"TupleType::TupleType %d elements\", count);\n  #endif\n      for (unsigned index = 0; index < count; index++)\n      {\n  \tm_types.push_back (Bytecode::readType (str));\n      }\n  #if DO_DEBUG\n      y2debug (\"TupleType::TupleType done\");\n  #endif\n  }\n}"
  },
  {
    "function_name": "TupleType",
    "container": "TupleType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1363-1367",
    "snippet": "TupleType::TupleType (constTypePtr type, bool as_const)\n    : Type (TupleT, as_const)\n{\n    concat (type);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "concat",
          "args": [
            "type"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "concat",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1649-1661",
          "snippet": "void\nFunctionType::concat (constTypePtr t)\n{\n    if (!m_arguments)\n    {\n\tm_arguments = TupleTypePtr (new TupleType (t));\n    }\n    else\n    {\n\tm_arguments->concat (t);\n    }\n    return;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  void\n  FunctionType::concat (constTypePtr t)\n  {\n      if (!m_arguments)\n      {\n  \tm_arguments = TupleTypePtr (new TupleType (t));\n      }\n      else\n      {\n  \tm_arguments->concat (t);\n      }\n      return;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nTupleType {\n  TupleType::TupleType (constTypePtr type, bool as_const)\n      : Type (TupleT, as_const)\n  {\n      concat (type);\n  }\n}"
  },
  {
    "function_name": "unflex",
    "container": "BlockType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1350-1358",
    "snippet": "constTypePtr\nBlockType::unflex (constTypePtr type, unsigned int number) const\n{\n    TypePtr tp = BlockTypePtr (new BlockType (m_type->unflex (type, number)));\n#if DO_DEBUG\n    y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n#endif\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"unflex '%s'%d -%s-> '%s'\"",
            "toString().c_str()",
            "number",
            "type->toString().c_str()",
            "tp->toString().c_str()"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp->toString",
          "args": [],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockTypePtr",
          "args": [
            "new BlockType (m_type->unflex (type, number))"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_type->unflex",
          "args": [
            "type",
            "number"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "unflex",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1857-1872",
          "snippet": "constTypePtr\nFunctionType::unflex (constTypePtr type, unsigned int number) const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype->unflex (type, number)));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount (); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType(index)->unflex (type, number));\n\t}\n    }\n#if DO_DEBUG\n    y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n#endif\n    return tp;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  constTypePtr\n  FunctionType::unflex (constTypePtr type, unsigned int number) const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype->unflex (type, number)));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount (); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType(index)->unflex (type, number));\n  \t}\n      }\n  #if DO_DEBUG\n      y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n  #endif\n      return tp;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nBlockType {\n  constTypePtr\n  BlockType::unflex (constTypePtr type, unsigned int number) const\n  {\n      TypePtr tp = BlockTypePtr (new BlockType (m_type->unflex (type, number)));\n  #if DO_DEBUG\n      y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n  #endif\n      return tp;\n  }\n}"
  },
  {
    "function_name": "clone",
    "container": "BlockType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1342-1347",
    "snippet": "TypePtr\nBlockType::clone () const\n{\n    BlockTypePtr tp = BlockTypePtr (new BlockType (m_type));\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BlockTypePtr",
          "args": [
            "new BlockType (m_type)"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nBlockType {\n  TypePtr\n  BlockType::clone () const\n  {\n      BlockTypePtr tp = BlockTypePtr (new BlockType (m_type));\n      return tp;\n  }\n}"
  },
  {
    "function_name": "canCast",
    "container": "BlockType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1335-1340",
    "snippet": "bool\nBlockType::canCast (constTypePtr to) const\n{\n    if (to->isBlock ()) return m_type->canCast (((constBlockTypePtr)to)->m_type);\n    return false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_type->canCast",
          "args": [
            "((constBlockTypePtr)to)->m_type"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "canCast",
          "container": "TupleType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1535-1558",
          "snippet": "bool\nTupleType::canCast (constTypePtr to) const\n{\n    if (to->isTuple ())\n    {\n\tconst TupleType & tt = (const TupleType)to;\n\tunsigned int esize = tt.m_types.size();\n\tbool wildcard = tt.m_types[esize-1]->isWildcard();\n\tfor (unsigned index = 0; index < m_types.size(); index++)\n\t{\n\t    if (index > esize\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (!m_types[index]->canCast (tt.m_types[index]))\n\t    {\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nTupleType {\n  bool\n  TupleType::canCast (constTypePtr to) const\n  {\n      if (to->isTuple ())\n      {\n  \tconst TupleType & tt = (const TupleType)to;\n  \tunsigned int esize = tt.m_types.size();\n  \tbool wildcard = tt.m_types[esize-1]->isWildcard();\n  \tfor (unsigned index = 0; index < m_types.size(); index++)\n  \t{\n  \t    if (index > esize\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (!m_types[index]->canCast (tt.m_types[index]))\n  \t    {\n  \t\treturn false;\n  \t    }\n  \t}\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "to->isBlock",
          "args": [],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "isBlock",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "301-301",
          "snippet": "bool isBlock () const\t{ return m_kind == BlockT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isBlock () const\t{ return m_kind == BlockT; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nBlockType {\n  bool\n  BlockType::canCast (constTypePtr to) const\n  {\n      if (to->isBlock ()) return m_type->canCast (((constBlockTypePtr)to)->m_type);\n      return false;\n  }\n}"
  },
  {
    "function_name": "equals",
    "container": "BlockType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1320-1332",
    "snippet": "bool\nBlockType::equals (constTypePtr expected) const\n{\n#if DO_DEBUG\n//    y2debug (\"equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    if (expected->isBlock()\n\t    && m_type->equals (((constBlockTypePtr)expected)->m_type) )\n    {\n\treturn true;\n    }\n    return false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_type->equals",
          "args": [
            "((constBlockTypePtr)expected)->m_type"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "equals",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1800-1839",
          "snippet": "bool\nFunctionType::equals (constTypePtr expected) const\n{\n#if DO_DEBUG\n//    y2debug (\"FunctionType::equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    if (expected->isFunction())\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (! m_returntype->equals (ft->m_returntype))\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return false;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return true;\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (! m_arguments->parameterType(index)->equals (ft->parameterType(index)))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter %d type mismatch\", index);\n#endif\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  bool\n  FunctionType::equals (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n  //    y2debug (\"FunctionType::equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      if (expected->isFunction())\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (! m_returntype->equals (ft->m_returntype))\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return false;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return true;\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (! m_arguments->parameterType(index)->equals (ft->parameterType(index)))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter %d type mismatch\", index);\n  #endif\n  \t\treturn false;\n  \t    }\n  \t}\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expected->isBlock",
          "args": [],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "isBlock",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "301-301",
          "snippet": "bool isBlock () const\t{ return m_kind == BlockT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isBlock () const\t{ return m_kind == BlockT; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nBlockType {\n  bool\n  BlockType::equals (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n  //    y2debug (\"equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      if (expected->isBlock()\n  \t    && m_type->equals (((constBlockTypePtr)expected)->m_type) )\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "match",
    "container": "BlockType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1302-1317",
    "snippet": "int\nBlockType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    int bm = basematch (expected);\n    if (bm == 1\n\t|| (bm == 0\n\t    && expected->isBlock()\n\t    && m_type->match (((constBlockTypePtr)expected)->m_type) >= 0))\n    {\n\treturn 0;\n    }\n    return -1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_type->match",
          "args": [
            "((constBlockTypePtr)expected)->m_type"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1739-1797",
          "snippet": "int\nFunctionType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    int bm = basematch (expected);\n\n    if (bm == 1) return 0;\t\t// any or wildcard match\n\n    if ((bm == 0\n\t    && expected->isFunction()))\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (m_returntype->match (ft->m_returntype) < 0)\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return -1;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return 0;\n\t}\n\n\tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n\tif (!wildcard)\n\t{\n\t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter count mismatch\");\n#endif\n\t\treturn -1;\n\t    }\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > esize\t\t\t// don't check wildcard parameters\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n\t    {\n\t\treturn -1;\n\t    }\n\t}\n\treturn 0;\n    }\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  int\n  FunctionType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      int bm = basematch (expected);\n  \n      if (bm == 1) return 0;\t\t// any or wildcard match\n  \n      if ((bm == 0\n  \t    && expected->isFunction()))\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (m_returntype->match (ft->m_returntype) < 0)\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return -1;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return 0;\n  \t}\n  \n  \tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n  \tif (!wildcard)\n  \t{\n  \t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter count mismatch\");\n  #endif\n  \t\treturn -1;\n  \t    }\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > esize\t\t\t// don't check wildcard parameters\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n  \t    {\n  \t\treturn -1;\n  \t    }\n  \t}\n  \treturn 0;\n      }\n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expected->isBlock",
          "args": [],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "isBlock",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "301-301",
          "snippet": "bool isBlock () const\t{ return m_kind == BlockT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isBlock () const\t{ return m_kind == BlockT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "basematch",
          "args": [
            "expected"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "basematch",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "251-302",
          "snippet": "int\nType::basematch (constTypePtr expected) const\n{\n    tkind ek = expected->m_kind;\n\n#if DO_DEBUG\n//    y2debug (\"basematch '%s', expected '%s'[%d]\", toString().c_str(), expected->toString().c_str(), ek);\n#endif\n\n    if (isError()\n\t|| ek == ErrorT)\n    {\n#if DO_DEBUG\n\ty2debug (\"Error !\");\n#endif\n\treturn -1;\n    }\n\n    if (expected->isReference()\n\t&& (!expected->isConst()\n\t    && isConst()))\n    {\n#if DO_DEBUG\n\ty2debug (\"doesn't expect const\");\n#endif\n\treturn -1;\n    }\n\n    if (ek == AnyT\n\t|| ek == FlexT\n\t|| ek == NFlexT\n\t|| ek == WildcardT\n\t|| ek == UnspecT)\t\t\t// list == list<unspec>\n    {\n#if DO_DEBUG\n//\ty2debug (\"free match\");\n#endif\n\treturn 1;\n    }\n\n    if (isVoid())\t\t\t\t// nil matches everywhere\n    {\n\treturn 0;\n    }\n\n    if (isBasetype() == expected->isBasetype())\n    {\n\treturn 0;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nType {\n  int\n  Type::basematch (constTypePtr expected) const\n  {\n      tkind ek = expected->m_kind;\n  \n  #if DO_DEBUG\n  //    y2debug (\"basematch '%s', expected '%s'[%d]\", toString().c_str(), expected->toString().c_str(), ek);\n  #endif\n  \n      if (isError()\n  \t|| ek == ErrorT)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Error !\");\n  #endif\n  \treturn -1;\n      }\n  \n      if (expected->isReference()\n  \t&& (!expected->isConst()\n  \t    && isConst()))\n      {\n  #if DO_DEBUG\n  \ty2debug (\"doesn't expect const\");\n  #endif\n  \treturn -1;\n      }\n  \n      if (ek == AnyT\n  \t|| ek == FlexT\n  \t|| ek == NFlexT\n  \t|| ek == WildcardT\n  \t|| ek == UnspecT)\t\t\t// list == list<unspec>\n      {\n  #if DO_DEBUG\n  //\ty2debug (\"free match\");\n  #endif\n  \treturn 1;\n      }\n  \n      if (isVoid())\t\t\t\t// nil matches everywhere\n      {\n  \treturn 0;\n      }\n  \n      if (isBasetype() == expected->isBasetype())\n      {\n  \treturn 0;\n      }\n  \n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"match '%s', expected '%s'\"",
            "toString().c_str()",
            "expected->toString().c_str()"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected->toString",
          "args": [],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nBlockType {\n  int\n  BlockType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      int bm = basematch (expected);\n      if (bm == 1\n  \t|| (bm == 0\n  \t    && expected->isBlock()\n  \t    && m_type->match (((constBlockTypePtr)expected)->m_type) >= 0))\n      {\n  \treturn 0;\n      }\n      return -1;\n  }\n}"
  },
  {
    "function_name": "matchFlex",
    "container": "BlockType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1288-1299",
    "snippet": "constTypePtr\nBlockType::matchFlex (constTypePtr type, unsigned int number) const\n{\n#if DO_DEBUG\n    y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n#endif\n    if (type->isBlock())\n    {\n\treturn m_type->matchFlex (((constBlockTypePtr)type)->m_type, number);\n    }\n    return 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_type->matchFlex",
          "args": [
            "((constBlockTypePtr)type)->m_type",
            "number"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "matchFlex",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1716-1736",
          "snippet": "constTypePtr\nFunctionType::matchFlex (constTypePtr type, unsigned int number) const\n{\n#if DO_DEBUG\n    y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n#endif\n    if (!type->isFunction())\n    {\n\treturn 0;\n    }\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    constFunctionTypePtr ft = (constFunctionTypePtr)type;\n    if (!ft->m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->matchFlex (ft->m_arguments, number);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  constTypePtr\n  FunctionType::matchFlex (constTypePtr type, unsigned int number) const\n  {\n  #if DO_DEBUG\n      y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n  #endif\n      if (!type->isFunction())\n      {\n  \treturn 0;\n      }\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      constFunctionTypePtr ft = (constFunctionTypePtr)type;\n      if (!ft->m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->matchFlex (ft->m_arguments, number);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isBlock",
          "args": [],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "isBlock",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "301-301",
          "snippet": "bool isBlock () const\t{ return m_kind == BlockT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isBlock () const\t{ return m_kind == BlockT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"matchFlex '%s' (%s)\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nBlockType {\n  constTypePtr\n  BlockType::matchFlex (constTypePtr type, unsigned int number) const\n  {\n  #if DO_DEBUG\n      y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n  #endif\n      if (type->isBlock())\n      {\n  \treturn m_type->matchFlex (((constBlockTypePtr)type)->m_type, number);\n      }\n      return 0;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "BlockType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1279-1285",
    "snippet": "string\nBlockType::toString () const\n{\n    return preToString()\n\t   + \"block <\" + m_type->toString() + \">\"\n\t   + postToString();\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "postToString",
          "args": [],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "postToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "244-244",
          "snippet": "string postToString () const { return (m_reference ? \" &\" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string postToString () const { return (m_reference ? \" &\" : \"\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_type->toString",
          "args": [],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "preToString",
          "args": [],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "preToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "239-239",
          "snippet": "string preToString () const { return (m_const ? \"const \" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string preToString () const { return (m_const ? \"const \" : \"\"); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nBlockType {\n  string\n  BlockType::toString () const\n  {\n      return preToString()\n  \t   + \"block <\" + m_type->toString() + \">\"\n  \t   + postToString();\n  }\n}"
  },
  {
    "function_name": "~BlockType",
    "container": "BlockType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1265-1267",
    "snippet": "BlockType::~BlockType ()\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nBlockType {\n  BlockType::~BlockType ()\n  {\n  }\n}"
  },
  {
    "function_name": "BlockType",
    "container": "BlockType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1258-1262",
    "snippet": "BlockType::BlockType (bytecodeistream & str)\n    : Type (BlockT, str)\n    , m_type (Bytecode::readType (str))\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readType",
          "args": [
            "str"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "readType",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "349-387",
          "snippet": "TypePtr\nBytecode::readType (bytecodeistream & str)\n{\n    int kind = readInt32 (str);\n#if DO_DEBUG\ny2debug (\"Bytecode::readType(%d)\", kind);\n#endif\n    switch ((Type::tkind)kind)\n    {\n\tcase Type::UnspecT:\n\tcase Type::ErrorT:\n\tcase Type::AnyT:\n\tcase Type::BooleanT:\n\tcase Type::ByteblockT:\n\tcase Type::FloatT:\n\tcase Type::IntegerT:\n\tcase Type::LocaleT:\n\tcase Type::PathT:\n\tcase Type::StringT:\n\tcase Type::SymbolT:\n\tcase Type::TermT:\n\tcase Type::VoidT:\n\tcase Type::WildcardT:\n\tcase Type::FlexT:\n\tcase Type::NilT:\n\t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n\tbreak;\n\n\tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n\tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n\tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n\tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n\tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n\tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n\tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n    }\n    y2error (\"Unhandled type kind %d\", kind);\n    return Type::Error->clone();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  TypePtr\n  Bytecode::readType (bytecodeistream & str)\n  {\n      int kind = readInt32 (str);\n  #if DO_DEBUG\n  y2debug (\"Bytecode::readType(%d)\", kind);\n  #endif\n      switch ((Type::tkind)kind)\n      {\n  \tcase Type::UnspecT:\n  \tcase Type::ErrorT:\n  \tcase Type::AnyT:\n  \tcase Type::BooleanT:\n  \tcase Type::ByteblockT:\n  \tcase Type::FloatT:\n  \tcase Type::IntegerT:\n  \tcase Type::LocaleT:\n  \tcase Type::PathT:\n  \tcase Type::StringT:\n  \tcase Type::SymbolT:\n  \tcase Type::TermT:\n  \tcase Type::VoidT:\n  \tcase Type::WildcardT:\n  \tcase Type::FlexT:\n  \tcase Type::NilT:\n  \t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n  \tbreak;\n  \n  \tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n  \tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n  \tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n  \tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n  \tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n  \tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n  \tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n      }\n      y2error (\"Unhandled type kind %d\", kind);\n      return Type::Error->clone();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nBlockType {\n  BlockType::BlockType (bytecodeistream & str)\n      : Type (BlockT, str)\n      , m_type (Bytecode::readType (str))\n  {\n  }\n}"
  },
  {
    "function_name": "BlockType",
    "container": "BlockType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1251-1255",
    "snippet": "BlockType::BlockType (constTypePtr type, bool as_const)\n    : Type (BlockT, as_const)\n    , m_type (type)\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nBlockType {\n  BlockType::BlockType (constTypePtr type, bool as_const)\n      : Type (BlockT, as_const)\n      , m_type (type)\n  {\n  }\n}"
  },
  {
    "function_name": "unflex",
    "container": "MapType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1225-1246",
    "snippet": "constTypePtr\nMapType::unflex (constTypePtr type, unsigned int number) const\n{\n    TypePtr tp;\n    if (m_keytype->isFlex())\n    {\n\ttp = MapTypePtr (new MapType (m_keytype->unflex (type, number), m_valuetype));\n    }\n    else if (m_valuetype->isFlex())\n    {\n\ttp = MapTypePtr (new MapType (m_keytype, m_valuetype->unflex (type, number)));\n    }\n    else\n    {\n\ttp = clone();\n    }\n\n#if DO_DEBUG\n    y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n#endif\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"unflex '%s'%d -%s-> '%s'\"",
            "toString().c_str()",
            "number",
            "type->toString().c_str()",
            "tp->toString().c_str()"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp->toString",
          "args": [],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "clone",
          "args": [],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "clone",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1842-1854",
          "snippet": "TypePtr\nFunctionType::clone () const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType (index));\n\t}\n    }\n    return tp;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  TypePtr\n  FunctionType::clone () const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType (index));\n  \t}\n      }\n      return tp;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MapTypePtr",
          "args": [
            "new MapType (m_keytype, m_valuetype->unflex (type, number))"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_valuetype->unflex",
          "args": [
            "type",
            "number"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "unflex",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1857-1872",
          "snippet": "constTypePtr\nFunctionType::unflex (constTypePtr type, unsigned int number) const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype->unflex (type, number)));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount (); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType(index)->unflex (type, number));\n\t}\n    }\n#if DO_DEBUG\n    y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n#endif\n    return tp;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  constTypePtr\n  FunctionType::unflex (constTypePtr type, unsigned int number) const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype->unflex (type, number)));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount (); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType(index)->unflex (type, number));\n  \t}\n      }\n  #if DO_DEBUG\n      y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n  #endif\n      return tp;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_valuetype->isFlex",
          "args": [],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "isFlex",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "295-295",
          "snippet": "bool isFlex () const\t{ return ((m_kind == FlexT) || (m_kind == NFlexT)); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isFlex () const\t{ return ((m_kind == FlexT) || (m_kind == NFlexT)); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MapTypePtr",
          "args": [
            "new MapType (m_keytype->unflex (type, number), m_valuetype)"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nMapType {\n  constTypePtr\n  MapType::unflex (constTypePtr type, unsigned int number) const\n  {\n      TypePtr tp;\n      if (m_keytype->isFlex())\n      {\n  \ttp = MapTypePtr (new MapType (m_keytype->unflex (type, number), m_valuetype));\n      }\n      else if (m_valuetype->isFlex())\n      {\n  \ttp = MapTypePtr (new MapType (m_keytype, m_valuetype->unflex (type, number)));\n      }\n      else\n      {\n  \ttp = clone();\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n  #endif\n      return tp;\n  }\n}"
  },
  {
    "function_name": "clone",
    "container": "MapType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1217-1222",
    "snippet": "TypePtr\nMapType::clone () const\n{\n    MapTypePtr tp = MapTypePtr (new MapType (m_keytype, m_valuetype));\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MapTypePtr",
          "args": [
            "new MapType (m_keytype, m_valuetype)"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nMapType {\n  TypePtr\n  MapType::clone () const\n  {\n      MapTypePtr tp = MapTypePtr (new MapType (m_keytype, m_valuetype));\n      return tp;\n  }\n}"
  },
  {
    "function_name": "canCast",
    "container": "MapType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1204-1214",
    "snippet": "bool\nMapType::canCast (constTypePtr to) const\n{\n#if DO_DEBUG\n//    y2debug (\"canCast '%s' to '%s'\", toString().c_str(), to->toString().c_str());\n#endif\n    if (to->isMap ())\n\treturn (m_keytype->canCast (((constMapTypePtr)to)->m_keytype))\n\t    && (m_valuetype->canCast (((constMapTypePtr)to)->m_valuetype));\n    return false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_valuetype->canCast",
          "args": [
            "((constMapTypePtr)to)->m_valuetype"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "canCast",
          "container": "TupleType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1535-1558",
          "snippet": "bool\nTupleType::canCast (constTypePtr to) const\n{\n    if (to->isTuple ())\n    {\n\tconst TupleType & tt = (const TupleType)to;\n\tunsigned int esize = tt.m_types.size();\n\tbool wildcard = tt.m_types[esize-1]->isWildcard();\n\tfor (unsigned index = 0; index < m_types.size(); index++)\n\t{\n\t    if (index > esize\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (!m_types[index]->canCast (tt.m_types[index]))\n\t    {\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nTupleType {\n  bool\n  TupleType::canCast (constTypePtr to) const\n  {\n      if (to->isTuple ())\n      {\n  \tconst TupleType & tt = (const TupleType)to;\n  \tunsigned int esize = tt.m_types.size();\n  \tbool wildcard = tt.m_types[esize-1]->isWildcard();\n  \tfor (unsigned index = 0; index < m_types.size(); index++)\n  \t{\n  \t    if (index > esize\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (!m_types[index]->canCast (tt.m_types[index]))\n  \t    {\n  \t\treturn false;\n  \t    }\n  \t}\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "to->isMap",
          "args": [],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "300-300",
          "snippet": "bool isMap () const\t\t{ return m_kind == MapT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isMap () const\t\t{ return m_kind == MapT; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nMapType {\n  bool\n  MapType::canCast (constTypePtr to) const\n  {\n  #if DO_DEBUG\n  //    y2debug (\"canCast '%s' to '%s'\", toString().c_str(), to->toString().c_str());\n  #endif\n      if (to->isMap ())\n  \treturn (m_keytype->canCast (((constMapTypePtr)to)->m_keytype))\n  \t    && (m_valuetype->canCast (((constMapTypePtr)to)->m_valuetype));\n      return false;\n  }\n}"
  },
  {
    "function_name": "detailedtype",
    "container": "MapType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1182-1201",
    "snippet": "constTypePtr\nMapType::detailedtype (constTypePtr type) const\n{\n#if DO_DEBUG\n    y2debug (\"MapType::detailedtype '%s', '%s'\", toString().c_str(), type->toString().c_str());\n#endif\n#warning not implemented\n    if (type->isVoid()\n\t|| type->isUnspec())\n    {\n\treturn constMapTypePtr (this);\n    }\n    else if (type->isMap())\n    {\n\tconstMapTypePtr maptype = type;\n\treturn MapTypePtr (new MapType (m_keytype->detailedtype (maptype->m_keytype), m_valuetype->detailedtype (maptype->m_valuetype)));\n    }\n\n    return Type::Error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MapTypePtr",
          "args": [
            "new MapType (m_keytype->detailedtype (maptype->m_keytype), m_valuetype->detailedtype (maptype->m_valuetype))"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_valuetype->detailedtype",
          "args": [
            "maptype->m_valuetype"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "detailedtype",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1952-2020",
          "snippet": "constTypePtr\nType::detailedtype (constTypePtr type) const\n{\n#if DO_DEBUG\n    y2debug (\"Type::detailedtype '%s' ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\n    if (isVoid())\t\t\t// 'nil' does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n    else if (type->isVoid())\t\t// 'nil' does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n    else if (type->isUnspec())\t\t// <unspec> does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n    else if (type->isAny())\t\t// 'any' does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n    else if (isUnspec())\t\t// <unspec> does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n    else if (isAny())\t\t\t// 'any' does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n    else if (match (type) >= 0)\t\t// if this matches the expected type, the latter is more detailed\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n    else if (type->match (this) >= 0)\t// if type matches the expected this, the latter is more detailed\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n\n#if DO_DEBUG\n    y2debug (\"Type::detailedtype '%s' ('%s') -> error\", toString().c_str(), type->toString().c_str());\n#endif\n    return Type::Error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nType {\n  constTypePtr\n  Type::detailedtype (constTypePtr type) const\n  {\n  #if DO_DEBUG\n      y2debug (\"Type::detailedtype '%s' ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \n      if (isVoid())\t\t\t// 'nil' does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n      else if (type->isVoid())\t\t// 'nil' does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n      else if (type->isUnspec())\t\t// <unspec> does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n      else if (type->isAny())\t\t// 'any' does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n      else if (isUnspec())\t\t// <unspec> does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n      else if (isAny())\t\t\t// 'any' does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n      else if (match (type) >= 0)\t\t// if this matches the expected type, the latter is more detailed\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n      else if (type->match (this) >= 0)\t// if type matches the expected this, the latter is more detailed\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"Type::detailedtype '%s' ('%s') -> error\", toString().c_str(), type->toString().c_str());\n  #endif\n      return Type::Error;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isMap",
          "args": [],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "300-300",
          "snippet": "bool isMap () const\t\t{ return m_kind == MapT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isMap () const\t\t{ return m_kind == MapT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "constMapTypePtr",
          "args": [
            "this"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->isUnspec",
          "args": [],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isVoid",
          "args": [],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "293-293",
          "snippet": "bool isVoid () const\t{ return m_kind == VoidT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isVoid () const\t{ return m_kind == VoidT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"MapType::detailedtype '%s', '%s'\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nMapType {\n  constTypePtr\n  MapType::detailedtype (constTypePtr type) const\n  {\n  #if DO_DEBUG\n      y2debug (\"MapType::detailedtype '%s', '%s'\", toString().c_str(), type->toString().c_str());\n  #endif\n  #warning not implemented\n      if (type->isVoid()\n  \t|| type->isUnspec())\n      {\n  \treturn constMapTypePtr (this);\n      }\n      else if (type->isMap())\n      {\n  \tconstMapTypePtr maptype = type;\n  \treturn MapTypePtr (new MapType (m_keytype->detailedtype (maptype->m_keytype), m_valuetype->detailedtype (maptype->m_valuetype)));\n      }\n  \n      return Type::Error;\n  }\n}"
  },
  {
    "function_name": "commontype",
    "container": "MapType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1157-1175",
    "snippet": "constTypePtr\nMapType::commontype (constTypePtr type) const\n{\n#if DO_DEBUG\n    y2debug (\"commontype '%s', '%s'\", toString().c_str(), type->toString().c_str());\n#endif\n    if (type->isVoid()\n\t|| type->isUnspec())\n    {\n\treturn constMapTypePtr (this);\n    }\n    else if (type->isMap())\n    {\n\tconstMapTypePtr maptype = type;\n\treturn MapTypePtr (new MapType (m_keytype->commontype (maptype->m_keytype), m_valuetype->commontype (maptype->m_valuetype)));\n    }\n\n    return Type::Any;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "const constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MapTypePtr",
          "args": [
            "new MapType (m_keytype->commontype (maptype->m_keytype), m_valuetype->commontype (maptype->m_valuetype))"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_valuetype->commontype",
          "args": [
            "maptype->m_valuetype"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "commontype",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1917-1944",
          "snippet": "constTypePtr\nType::commontype (constTypePtr type) const\n{\n    if (isVoid())\t\t// 'nil' does not influence the type\n    {\n\treturn type;\n    }\n\n    if (match (type) >= 0)\n    {\n#if DO_DEBUG\n\ty2debug (\"commontype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n    else if (!isAny()\n\t     && type->match (this) >= 0)\n    {\n#if DO_DEBUG\n    y2debug (\"commontype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n#if DO_DEBUG\n    y2debug (\"commontype '%s' ('%s') -> any\", toString().c_str(), type->toString().c_str());\n#endif\n    return Type::Any;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "const constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));\n\nType {\n  constTypePtr\n  Type::commontype (constTypePtr type) const\n  {\n      if (isVoid())\t\t// 'nil' does not influence the type\n      {\n  \treturn type;\n      }\n  \n      if (match (type) >= 0)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"commontype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n      else if (!isAny()\n  \t     && type->match (this) >= 0)\n      {\n  #if DO_DEBUG\n      y2debug (\"commontype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n  #if DO_DEBUG\n      y2debug (\"commontype '%s' ('%s') -> any\", toString().c_str(), type->toString().c_str());\n  #endif\n      return Type::Any;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isMap",
          "args": [],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "300-300",
          "snippet": "bool isMap () const\t\t{ return m_kind == MapT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isMap () const\t\t{ return m_kind == MapT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "constMapTypePtr",
          "args": [
            "this"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->isUnspec",
          "args": [],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isVoid",
          "args": [],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "293-293",
          "snippet": "bool isVoid () const\t{ return m_kind == VoidT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isVoid () const\t{ return m_kind == VoidT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"commontype '%s', '%s'\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));\n\nMapType {\n  constTypePtr\n  MapType::commontype (constTypePtr type) const\n  {\n  #if DO_DEBUG\n      y2debug (\"commontype '%s', '%s'\", toString().c_str(), type->toString().c_str());\n  #endif\n      if (type->isVoid()\n  \t|| type->isUnspec())\n      {\n  \treturn constMapTypePtr (this);\n      }\n      else if (type->isMap())\n      {\n  \tconstMapTypePtr maptype = type;\n  \treturn MapTypePtr (new MapType (m_keytype->commontype (maptype->m_keytype), m_valuetype->commontype (maptype->m_valuetype)));\n      }\n  \n      return Type::Any;\n  }\n}"
  },
  {
    "function_name": "equals",
    "container": "MapType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1136-1149",
    "snippet": "bool\nMapType::equals (constTypePtr expected) const\n{\n#if DO_DEBUG\n//    y2debug (\"equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    if (expected->isMap()\n\t    && m_valuetype->equals (((constMapTypePtr)expected)->m_valuetype)\n\t    && m_keytype->equals (((constMapTypePtr)expected)->m_keytype) )\n    {\n\treturn true;\n    }\n    return false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_keytype->equals",
          "args": [
            "((constMapTypePtr)expected)->m_keytype"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "equals",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1800-1839",
          "snippet": "bool\nFunctionType::equals (constTypePtr expected) const\n{\n#if DO_DEBUG\n//    y2debug (\"FunctionType::equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    if (expected->isFunction())\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (! m_returntype->equals (ft->m_returntype))\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return false;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return true;\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (! m_arguments->parameterType(index)->equals (ft->parameterType(index)))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter %d type mismatch\", index);\n#endif\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  bool\n  FunctionType::equals (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n  //    y2debug (\"FunctionType::equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      if (expected->isFunction())\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (! m_returntype->equals (ft->m_returntype))\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return false;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return true;\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (! m_arguments->parameterType(index)->equals (ft->parameterType(index)))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter %d type mismatch\", index);\n  #endif\n  \t\treturn false;\n  \t    }\n  \t}\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expected->isMap",
          "args": [],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "300-300",
          "snippet": "bool isMap () const\t\t{ return m_kind == MapT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isMap () const\t\t{ return m_kind == MapT; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nMapType {\n  bool\n  MapType::equals (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n  //    y2debug (\"equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      if (expected->isMap()\n  \t    && m_valuetype->equals (((constMapTypePtr)expected)->m_valuetype)\n  \t    && m_keytype->equals (((constMapTypePtr)expected)->m_keytype) )\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "match",
    "container": "MapType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1107-1134",
    "snippet": "int\nMapType::match (constTypePtr expected) const\n{\n    int bm = basematch (expected);\n#if DO_DEBUG\n    y2debug (\"match '%s', expected '%s', basematch %d\", toString().c_str(), expected->toString().c_str(), bm);\n#endif\n    if (bm == 1)\n    {\n\treturn 0;\n    }\n\n    if (bm == 0\n\t&& expected->isMap())\n    {\n\t// check if the expected map is more detailed\n\n\tconstMapTypePtr mexpected = (constMapTypePtr)expected;\n\tif (   (m_keytype->isUnspec()\t\t\t\t\t// this is a constant $[]\n\t\t|| m_keytype->match (mexpected->m_keytype) >= 0)\n\t    && (m_valuetype->isUnspec()\t\t\t\t\t// this is a constant $[]\n\t\t|| m_valuetype->match (mexpected->m_valuetype) >= 0))\n\t{\n\t    return 0;\n\t}\n    }\n    return -1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_valuetype->match",
          "args": [
            "mexpected->m_valuetype"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1739-1797",
          "snippet": "int\nFunctionType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    int bm = basematch (expected);\n\n    if (bm == 1) return 0;\t\t// any or wildcard match\n\n    if ((bm == 0\n\t    && expected->isFunction()))\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (m_returntype->match (ft->m_returntype) < 0)\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return -1;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return 0;\n\t}\n\n\tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n\tif (!wildcard)\n\t{\n\t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter count mismatch\");\n#endif\n\t\treturn -1;\n\t    }\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > esize\t\t\t// don't check wildcard parameters\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n\t    {\n\t\treturn -1;\n\t    }\n\t}\n\treturn 0;\n    }\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  int\n  FunctionType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      int bm = basematch (expected);\n  \n      if (bm == 1) return 0;\t\t// any or wildcard match\n  \n      if ((bm == 0\n  \t    && expected->isFunction()))\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (m_returntype->match (ft->m_returntype) < 0)\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return -1;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return 0;\n  \t}\n  \n  \tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n  \tif (!wildcard)\n  \t{\n  \t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter count mismatch\");\n  #endif\n  \t\treturn -1;\n  \t    }\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > esize\t\t\t// don't check wildcard parameters\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n  \t    {\n  \t\treturn -1;\n  \t    }\n  \t}\n  \treturn 0;\n      }\n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_valuetype->isUnspec",
          "args": [],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expected->isMap",
          "args": [],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "300-300",
          "snippet": "bool isMap () const\t\t{ return m_kind == MapT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isMap () const\t\t{ return m_kind == MapT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"match '%s', expected '%s', basematch %d\"",
            "toString().c_str()",
            "expected->toString().c_str()",
            "bm"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected->toString",
          "args": [],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "basematch",
          "args": [
            "expected"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "basematch",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "251-302",
          "snippet": "int\nType::basematch (constTypePtr expected) const\n{\n    tkind ek = expected->m_kind;\n\n#if DO_DEBUG\n//    y2debug (\"basematch '%s', expected '%s'[%d]\", toString().c_str(), expected->toString().c_str(), ek);\n#endif\n\n    if (isError()\n\t|| ek == ErrorT)\n    {\n#if DO_DEBUG\n\ty2debug (\"Error !\");\n#endif\n\treturn -1;\n    }\n\n    if (expected->isReference()\n\t&& (!expected->isConst()\n\t    && isConst()))\n    {\n#if DO_DEBUG\n\ty2debug (\"doesn't expect const\");\n#endif\n\treturn -1;\n    }\n\n    if (ek == AnyT\n\t|| ek == FlexT\n\t|| ek == NFlexT\n\t|| ek == WildcardT\n\t|| ek == UnspecT)\t\t\t// list == list<unspec>\n    {\n#if DO_DEBUG\n//\ty2debug (\"free match\");\n#endif\n\treturn 1;\n    }\n\n    if (isVoid())\t\t\t\t// nil matches everywhere\n    {\n\treturn 0;\n    }\n\n    if (isBasetype() == expected->isBasetype())\n    {\n\treturn 0;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nType {\n  int\n  Type::basematch (constTypePtr expected) const\n  {\n      tkind ek = expected->m_kind;\n  \n  #if DO_DEBUG\n  //    y2debug (\"basematch '%s', expected '%s'[%d]\", toString().c_str(), expected->toString().c_str(), ek);\n  #endif\n  \n      if (isError()\n  \t|| ek == ErrorT)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Error !\");\n  #endif\n  \treturn -1;\n      }\n  \n      if (expected->isReference()\n  \t&& (!expected->isConst()\n  \t    && isConst()))\n      {\n  #if DO_DEBUG\n  \ty2debug (\"doesn't expect const\");\n  #endif\n  \treturn -1;\n      }\n  \n      if (ek == AnyT\n  \t|| ek == FlexT\n  \t|| ek == NFlexT\n  \t|| ek == WildcardT\n  \t|| ek == UnspecT)\t\t\t// list == list<unspec>\n      {\n  #if DO_DEBUG\n  //\ty2debug (\"free match\");\n  #endif\n  \treturn 1;\n      }\n  \n      if (isVoid())\t\t\t\t// nil matches everywhere\n      {\n  \treturn 0;\n      }\n  \n      if (isBasetype() == expected->isBasetype())\n      {\n  \treturn 0;\n      }\n  \n      return -1;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nMapType {\n  int\n  MapType::match (constTypePtr expected) const\n  {\n      int bm = basematch (expected);\n  #if DO_DEBUG\n      y2debug (\"match '%s', expected '%s', basematch %d\", toString().c_str(), expected->toString().c_str(), bm);\n  #endif\n      if (bm == 1)\n      {\n  \treturn 0;\n      }\n  \n      if (bm == 0\n  \t&& expected->isMap())\n      {\n  \t// check if the expected map is more detailed\n  \n  \tconstMapTypePtr mexpected = (constMapTypePtr)expected;\n  \tif (   (m_keytype->isUnspec()\t\t\t\t\t// this is a constant $[]\n  \t\t|| m_keytype->match (mexpected->m_keytype) >= 0)\n  \t    && (m_valuetype->isUnspec()\t\t\t\t\t// this is a constant $[]\n  \t\t|| m_valuetype->match (mexpected->m_valuetype) >= 0))\n  \t{\n  \t    return 0;\n  \t}\n      }\n      return -1;\n  }\n}"
  },
  {
    "function_name": "matchFlex",
    "container": "MapType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1088-1104",
    "snippet": "constTypePtr\nMapType::matchFlex (constTypePtr type, unsigned int number) const\n{\n#if DO_DEBUG\n    y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n#endif\n    if (!type->isMap())\n    {\n\treturn 0;\n    }\n    constTypePtr flex = m_valuetype->matchFlex (((constMapTypePtr)type)->m_valuetype, number);\n    if (flex)\n    {\n\treturn flex;\n    }\n    return m_keytype->matchFlex (((constMapTypePtr)type)->m_keytype, number);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_keytype->matchFlex",
          "args": [
            "((constMapTypePtr)type)->m_keytype",
            "number"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "matchFlex",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1716-1736",
          "snippet": "constTypePtr\nFunctionType::matchFlex (constTypePtr type, unsigned int number) const\n{\n#if DO_DEBUG\n    y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n#endif\n    if (!type->isFunction())\n    {\n\treturn 0;\n    }\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    constFunctionTypePtr ft = (constFunctionTypePtr)type;\n    if (!ft->m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->matchFlex (ft->m_arguments, number);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  constTypePtr\n  FunctionType::matchFlex (constTypePtr type, unsigned int number) const\n  {\n  #if DO_DEBUG\n      y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n  #endif\n      if (!type->isFunction())\n      {\n  \treturn 0;\n      }\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      constFunctionTypePtr ft = (constFunctionTypePtr)type;\n      if (!ft->m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->matchFlex (ft->m_arguments, number);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isMap",
          "args": [],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "300-300",
          "snippet": "bool isMap () const\t\t{ return m_kind == MapT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isMap () const\t\t{ return m_kind == MapT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"matchFlex '%s' (%s)\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nMapType {\n  constTypePtr\n  MapType::matchFlex (constTypePtr type, unsigned int number) const\n  {\n  #if DO_DEBUG\n      y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n  #endif\n      if (!type->isMap())\n      {\n  \treturn 0;\n      }\n      constTypePtr flex = m_valuetype->matchFlex (((constMapTypePtr)type)->m_valuetype, number);\n      if (flex)\n      {\n  \treturn flex;\n      }\n      return m_keytype->matchFlex (((constMapTypePtr)type)->m_keytype, number);\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "MapType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1066-1085",
    "snippet": "string\nMapType::toString () const\n{\n    string ret = preToString() + \"map\";\n\n    // map <<unspec>, <unspec>> -> map\n    // map <any, <unspec>> -> map\n    // map <any, any> -> map\n    if (! (   (m_keytype->isUnspec() || m_keytype->isAny())\n\t   && (m_valuetype->isUnspec() || m_valuetype->isAny())))\n    {\n\tret += \" <\";\n\tret += m_keytype->toString();\n\tret += \", \";\n\tret += m_valuetype->toString();\n\tret += \">\";\n    }\n    ret += postToString();\n    return ret;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "postToString",
          "args": [],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "postToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "244-244",
          "snippet": "string postToString () const { return (m_reference ? \" &\" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string postToString () const { return (m_reference ? \" &\" : \"\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_valuetype->toString",
          "args": [],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_valuetype->isAny",
          "args": [],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "isAny",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "283-283",
          "snippet": "bool isAny () const\t\t{ return m_kind == AnyT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isAny () const\t\t{ return m_kind == AnyT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_valuetype->isUnspec",
          "args": [],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "preToString",
          "args": [],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "preToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "239-239",
          "snippet": "string preToString () const { return (m_const ? \"const \" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string preToString () const { return (m_const ? \"const \" : \"\"); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nMapType {\n  string\n  MapType::toString () const\n  {\n      string ret = preToString() + \"map\";\n  \n      // map <<unspec>, <unspec>> -> map\n      // map <any, <unspec>> -> map\n      // map <any, any> -> map\n      if (! (   (m_keytype->isUnspec() || m_keytype->isAny())\n  \t   && (m_valuetype->isUnspec() || m_valuetype->isAny())))\n      {\n  \tret += \" <\";\n  \tret += m_keytype->toString();\n  \tret += \", \";\n  \tret += m_valuetype->toString();\n  \tret += \">\";\n      }\n      ret += postToString();\n      return ret;\n  }\n}"
  },
  {
    "function_name": "~MapType",
    "container": "MapType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1051-1053",
    "snippet": "MapType::~MapType ()\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nMapType {\n  MapType::~MapType ()\n  {\n  }\n}"
  },
  {
    "function_name": "MapType",
    "container": "MapType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1043-1048",
    "snippet": "MapType::MapType (bytecodeistream & str)\n    : Type (MapT, str)\n    , m_keytype (Bytecode::readType (str))\n    , m_valuetype (Bytecode::readType (str))\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readType",
          "args": [
            "str"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "readType",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "349-387",
          "snippet": "TypePtr\nBytecode::readType (bytecodeistream & str)\n{\n    int kind = readInt32 (str);\n#if DO_DEBUG\ny2debug (\"Bytecode::readType(%d)\", kind);\n#endif\n    switch ((Type::tkind)kind)\n    {\n\tcase Type::UnspecT:\n\tcase Type::ErrorT:\n\tcase Type::AnyT:\n\tcase Type::BooleanT:\n\tcase Type::ByteblockT:\n\tcase Type::FloatT:\n\tcase Type::IntegerT:\n\tcase Type::LocaleT:\n\tcase Type::PathT:\n\tcase Type::StringT:\n\tcase Type::SymbolT:\n\tcase Type::TermT:\n\tcase Type::VoidT:\n\tcase Type::WildcardT:\n\tcase Type::FlexT:\n\tcase Type::NilT:\n\t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n\tbreak;\n\n\tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n\tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n\tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n\tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n\tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n\tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n\tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n    }\n    y2error (\"Unhandled type kind %d\", kind);\n    return Type::Error->clone();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  TypePtr\n  Bytecode::readType (bytecodeistream & str)\n  {\n      int kind = readInt32 (str);\n  #if DO_DEBUG\n  y2debug (\"Bytecode::readType(%d)\", kind);\n  #endif\n      switch ((Type::tkind)kind)\n      {\n  \tcase Type::UnspecT:\n  \tcase Type::ErrorT:\n  \tcase Type::AnyT:\n  \tcase Type::BooleanT:\n  \tcase Type::ByteblockT:\n  \tcase Type::FloatT:\n  \tcase Type::IntegerT:\n  \tcase Type::LocaleT:\n  \tcase Type::PathT:\n  \tcase Type::StringT:\n  \tcase Type::SymbolT:\n  \tcase Type::TermT:\n  \tcase Type::VoidT:\n  \tcase Type::WildcardT:\n  \tcase Type::FlexT:\n  \tcase Type::NilT:\n  \t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n  \tbreak;\n  \n  \tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n  \tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n  \tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n  \tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n  \tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n  \tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n  \tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n      }\n      y2error (\"Unhandled type kind %d\", kind);\n      return Type::Error->clone();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nMapType {\n  MapType::MapType (bytecodeistream & str)\n      : Type (MapT, str)\n      , m_keytype (Bytecode::readType (str))\n      , m_valuetype (Bytecode::readType (str))\n  {\n  }\n}"
  },
  {
    "function_name": "MapType",
    "container": "MapType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1035-1040",
    "snippet": "MapType::MapType (constTypePtr key, constTypePtr value, bool as_const)\n    : Type (MapT, as_const)\n    , m_keytype (key)\n    , m_valuetype (value)\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nMapType {\n  MapType::MapType (constTypePtr key, constTypePtr value, bool as_const)\n      : Type (MapT, as_const)\n      , m_keytype (key)\n      , m_valuetype (value)\n  {\n  }\n}"
  },
  {
    "function_name": "unflex",
    "container": "ListType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1023-1031",
    "snippet": "constTypePtr\nListType::unflex (constTypePtr type, unsigned int number) const\n{\n    TypePtr tp = ListTypePtr (new ListType (m_type->unflex (type, number)));\n#if DO_DEBUG\n    y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n#endif\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"unflex '%s'%d -%s-> '%s'\"",
            "toString().c_str()",
            "number",
            "type->toString().c_str()",
            "tp->toString().c_str()"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp->toString",
          "args": [],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ListTypePtr",
          "args": [
            "new ListType (m_type->unflex (type, number))"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_type->unflex",
          "args": [
            "type",
            "number"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "unflex",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1857-1872",
          "snippet": "constTypePtr\nFunctionType::unflex (constTypePtr type, unsigned int number) const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype->unflex (type, number)));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount (); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType(index)->unflex (type, number));\n\t}\n    }\n#if DO_DEBUG\n    y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n#endif\n    return tp;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  constTypePtr\n  FunctionType::unflex (constTypePtr type, unsigned int number) const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype->unflex (type, number)));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount (); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType(index)->unflex (type, number));\n  \t}\n      }\n  #if DO_DEBUG\n      y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n  #endif\n      return tp;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nListType {\n  constTypePtr\n  ListType::unflex (constTypePtr type, unsigned int number) const\n  {\n      TypePtr tp = ListTypePtr (new ListType (m_type->unflex (type, number)));\n  #if DO_DEBUG\n      y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n  #endif\n      return tp;\n  }\n}"
  },
  {
    "function_name": "clone",
    "container": "ListType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1015-1020",
    "snippet": "TypePtr\nListType::clone () const\n{\n    ListTypePtr tp = ListTypePtr (new ListType (m_type));\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListTypePtr",
          "args": [
            "new ListType (m_type)"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nListType {\n  TypePtr\n  ListType::clone () const\n  {\n      ListTypePtr tp = ListTypePtr (new ListType (m_type));\n      return tp;\n  }\n}"
  },
  {
    "function_name": "canCast",
    "container": "ListType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "1008-1013",
    "snippet": "bool\nListType::canCast (constTypePtr to) const\n{\n    if (to->isList ()) return m_type->canCast (((constListTypePtr)to)->m_type);\n    return false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_type->canCast",
          "args": [
            "((constListTypePtr)to)->m_type"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "canCast",
          "container": "TupleType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1535-1558",
          "snippet": "bool\nTupleType::canCast (constTypePtr to) const\n{\n    if (to->isTuple ())\n    {\n\tconst TupleType & tt = (const TupleType)to;\n\tunsigned int esize = tt.m_types.size();\n\tbool wildcard = tt.m_types[esize-1]->isWildcard();\n\tfor (unsigned index = 0; index < m_types.size(); index++)\n\t{\n\t    if (index > esize\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (!m_types[index]->canCast (tt.m_types[index]))\n\t    {\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nTupleType {\n  bool\n  TupleType::canCast (constTypePtr to) const\n  {\n      if (to->isTuple ())\n      {\n  \tconst TupleType & tt = (const TupleType)to;\n  \tunsigned int esize = tt.m_types.size();\n  \tbool wildcard = tt.m_types[esize-1]->isWildcard();\n  \tfor (unsigned index = 0; index < m_types.size(); index++)\n  \t{\n  \t    if (index > esize\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (!m_types[index]->canCast (tt.m_types[index]))\n  \t    {\n  \t\treturn false;\n  \t    }\n  \t}\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "to->isList",
          "args": [],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "299-299",
          "snippet": "bool isList () const\t{ return m_kind == ListT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isList () const\t{ return m_kind == ListT; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nListType {\n  bool\n  ListType::canCast (constTypePtr to) const\n  {\n      if (to->isList ()) return m_type->canCast (((constListTypePtr)to)->m_type);\n      return false;\n  }\n}"
  },
  {
    "function_name": "detailedtype",
    "container": "ListType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "986-1005",
    "snippet": "constTypePtr\nListType::detailedtype (constTypePtr type) const\n{\n#if DO_DEBUG\n    y2debug (\"ListType::detailedtype '%s', '%s'\", toString().c_str(), type->toString().c_str());\n#endif\n#warning unfinished\n    if (type->isVoid()\n\t|| type->isUnspec())\n    {\n\treturn constListTypePtr (this);\n    }\n    else if (type->isList())\n    {\n\tconstListTypePtr listtype = type;\n\treturn ListTypePtr (new ListType (m_type->detailedtype (listtype->m_type)));\n    }\n\n    return Type::Error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListTypePtr",
          "args": [
            "new ListType (m_type->detailedtype (listtype->m_type))"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_type->detailedtype",
          "args": [
            "listtype->m_type"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "detailedtype",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1952-2020",
          "snippet": "constTypePtr\nType::detailedtype (constTypePtr type) const\n{\n#if DO_DEBUG\n    y2debug (\"Type::detailedtype '%s' ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\n    if (isVoid())\t\t\t// 'nil' does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n    else if (type->isVoid())\t\t// 'nil' does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n    else if (type->isUnspec())\t\t// <unspec> does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n    else if (type->isAny())\t\t// 'any' does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n    else if (isUnspec())\t\t// <unspec> does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n    else if (isAny())\t\t\t// 'any' does not contain type information\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n    else if (match (type) >= 0)\t\t// if this matches the expected type, the latter is more detailed\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n    else if (type->match (this) >= 0)\t// if type matches the expected this, the latter is more detailed\n    {\n#if DO_DEBUG\n\ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n\n#if DO_DEBUG\n    y2debug (\"Type::detailedtype '%s' ('%s') -> error\", toString().c_str(), type->toString().c_str());\n#endif\n    return Type::Error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nType {\n  constTypePtr\n  Type::detailedtype (constTypePtr type) const\n  {\n  #if DO_DEBUG\n      y2debug (\"Type::detailedtype '%s' ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \n      if (isVoid())\t\t\t// 'nil' does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n      else if (type->isVoid())\t\t// 'nil' does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n      else if (type->isUnspec())\t\t// <unspec> does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n      else if (type->isAny())\t\t// 'any' does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n      else if (isUnspec())\t\t// <unspec> does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n      else if (isAny())\t\t\t// 'any' does not contain type information\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n      else if (match (type) >= 0)\t\t// if this matches the expected type, the latter is more detailed\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n      else if (type->match (this) >= 0)\t// if type matches the expected this, the latter is more detailed\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Type::detailedtype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"Type::detailedtype '%s' ('%s') -> error\", toString().c_str(), type->toString().c_str());\n  #endif\n      return Type::Error;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isList",
          "args": [],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "299-299",
          "snippet": "bool isList () const\t{ return m_kind == ListT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isList () const\t{ return m_kind == ListT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "constListTypePtr",
          "args": [
            "this"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->isUnspec",
          "args": [],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isVoid",
          "args": [],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "293-293",
          "snippet": "bool isVoid () const\t{ return m_kind == VoidT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isVoid () const\t{ return m_kind == VoidT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"ListType::detailedtype '%s', '%s'\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nListType {\n  constTypePtr\n  ListType::detailedtype (constTypePtr type) const\n  {\n  #if DO_DEBUG\n      y2debug (\"ListType::detailedtype '%s', '%s'\", toString().c_str(), type->toString().c_str());\n  #endif\n  #warning unfinished\n      if (type->isVoid()\n  \t|| type->isUnspec())\n      {\n  \treturn constListTypePtr (this);\n      }\n      else if (type->isList())\n      {\n  \tconstListTypePtr listtype = type;\n  \treturn ListTypePtr (new ListType (m_type->detailedtype (listtype->m_type)));\n      }\n  \n      return Type::Error;\n  }\n}"
  },
  {
    "function_name": "commontype",
    "container": "ListType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "960-978",
    "snippet": "constTypePtr\nListType::commontype (constTypePtr type) const\n{\n#if DO_DEBUG\n    y2debug (\"commontype '%s', '%s'\", toString().c_str(), type->toString().c_str());\n#endif\n    if (type->isVoid()\n\t|| type->isUnspec())\n    {\n\treturn constListTypePtr (this);\n    }\n    else if (type->isList())\n    {\n\tconstListTypePtr listtype = type;\n\treturn ListTypePtr (new ListType (m_type->commontype (listtype->m_type)));\n    }\n\n    return Type::Any;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "const constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListTypePtr",
          "args": [
            "new ListType (m_type->commontype (listtype->m_type))"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_type->commontype",
          "args": [
            "listtype->m_type"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "commontype",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1917-1944",
          "snippet": "constTypePtr\nType::commontype (constTypePtr type) const\n{\n    if (isVoid())\t\t// 'nil' does not influence the type\n    {\n\treturn type;\n    }\n\n    if (match (type) >= 0)\n    {\n#if DO_DEBUG\n\ty2debug (\"commontype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n    else if (!isAny()\n\t     && type->match (this) >= 0)\n    {\n#if DO_DEBUG\n    y2debug (\"commontype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n#if DO_DEBUG\n    y2debug (\"commontype '%s' ('%s') -> any\", toString().c_str(), type->toString().c_str());\n#endif\n    return Type::Any;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "const constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));\n\nType {\n  constTypePtr\n  Type::commontype (constTypePtr type) const\n  {\n      if (isVoid())\t\t// 'nil' does not influence the type\n      {\n  \treturn type;\n      }\n  \n      if (match (type) >= 0)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"commontype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n      else if (!isAny()\n  \t     && type->match (this) >= 0)\n      {\n  #if DO_DEBUG\n      y2debug (\"commontype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n  #if DO_DEBUG\n      y2debug (\"commontype '%s' ('%s') -> any\", toString().c_str(), type->toString().c_str());\n  #endif\n      return Type::Any;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isList",
          "args": [],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "299-299",
          "snippet": "bool isList () const\t{ return m_kind == ListT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isList () const\t{ return m_kind == ListT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "constListTypePtr",
          "args": [
            "this"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->isUnspec",
          "args": [],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isVoid",
          "args": [],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "293-293",
          "snippet": "bool isVoid () const\t{ return m_kind == VoidT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isVoid () const\t{ return m_kind == VoidT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"commontype '%s', '%s'\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));\n\nListType {\n  constTypePtr\n  ListType::commontype (constTypePtr type) const\n  {\n  #if DO_DEBUG\n      y2debug (\"commontype '%s', '%s'\", toString().c_str(), type->toString().c_str());\n  #endif\n      if (type->isVoid()\n  \t|| type->isUnspec())\n      {\n  \treturn constListTypePtr (this);\n      }\n      else if (type->isList())\n      {\n  \tconstListTypePtr listtype = type;\n  \treturn ListTypePtr (new ListType (m_type->commontype (listtype->m_type)));\n      }\n  \n      return Type::Any;\n  }\n}"
  },
  {
    "function_name": "equals",
    "container": "ListType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "940-952",
    "snippet": "bool\nListType::equals (constTypePtr expected) const\n{\n#if DO_DEBUG\n//    y2debug (\"equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    if (expected->isList()\n\t    && m_type->equals (((constListTypePtr)expected)->m_type))\n    {\n\treturn true;\n    }\n    return false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_type->equals",
          "args": [
            "((constListTypePtr)expected)->m_type"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "equals",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1800-1839",
          "snippet": "bool\nFunctionType::equals (constTypePtr expected) const\n{\n#if DO_DEBUG\n//    y2debug (\"FunctionType::equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    if (expected->isFunction())\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (! m_returntype->equals (ft->m_returntype))\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return false;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return true;\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (! m_arguments->parameterType(index)->equals (ft->parameterType(index)))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter %d type mismatch\", index);\n#endif\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  bool\n  FunctionType::equals (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n  //    y2debug (\"FunctionType::equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      if (expected->isFunction())\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (! m_returntype->equals (ft->m_returntype))\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return false;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return true;\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (! m_arguments->parameterType(index)->equals (ft->parameterType(index)))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter %d type mismatch\", index);\n  #endif\n  \t\treturn false;\n  \t    }\n  \t}\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expected->isList",
          "args": [],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "299-299",
          "snippet": "bool isList () const\t{ return m_kind == ListT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isList () const\t{ return m_kind == ListT; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nListType {\n  bool\n  ListType::equals (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n  //    y2debug (\"equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      if (expected->isList()\n  \t    && m_type->equals (((constListTypePtr)expected)->m_type))\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "match",
    "container": "ListType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "915-938",
    "snippet": "int\nListType::match (constTypePtr expected) const\n{\n    int bm = basematch (expected);\n#if DO_DEBUG\n    y2debug (\"match '%s', expected '%s', basematch %d\", toString().c_str(), expected->toString().c_str(), bm);\n#endif\n    if (bm == 1)\n    {\n\treturn 0;\n    }\n    if (bm == 0\n\t&& expected->isList())\n    {\n\tconstListTypePtr lexpected = expected;\n\tif (lexpected->m_type->isUnspec()\t\t\t\t// empty list\n\t    || m_type->isUnspec()\n\t    || m_type->match (lexpected->m_type) >= 0)\n    {\n\treturn 0;\n    }\n    }\n    return -1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_type->match",
          "args": [
            "lexpected->m_type"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1739-1797",
          "snippet": "int\nFunctionType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    int bm = basematch (expected);\n\n    if (bm == 1) return 0;\t\t// any or wildcard match\n\n    if ((bm == 0\n\t    && expected->isFunction()))\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (m_returntype->match (ft->m_returntype) < 0)\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return -1;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return 0;\n\t}\n\n\tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n\tif (!wildcard)\n\t{\n\t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter count mismatch\");\n#endif\n\t\treturn -1;\n\t    }\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > esize\t\t\t// don't check wildcard parameters\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n\t    {\n\t\treturn -1;\n\t    }\n\t}\n\treturn 0;\n    }\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  int\n  FunctionType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      int bm = basematch (expected);\n  \n      if (bm == 1) return 0;\t\t// any or wildcard match\n  \n      if ((bm == 0\n  \t    && expected->isFunction()))\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (m_returntype->match (ft->m_returntype) < 0)\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return -1;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return 0;\n  \t}\n  \n  \tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n  \tif (!wildcard)\n  \t{\n  \t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter count mismatch\");\n  #endif\n  \t\treturn -1;\n  \t    }\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > esize\t\t\t// don't check wildcard parameters\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n  \t    {\n  \t\treturn -1;\n  \t    }\n  \t}\n  \treturn 0;\n      }\n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_type->isUnspec",
          "args": [],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expected->isList",
          "args": [],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "299-299",
          "snippet": "bool isList () const\t{ return m_kind == ListT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isList () const\t{ return m_kind == ListT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"match '%s', expected '%s', basematch %d\"",
            "toString().c_str()",
            "expected->toString().c_str()",
            "bm"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected->toString",
          "args": [],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "basematch",
          "args": [
            "expected"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "basematch",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "251-302",
          "snippet": "int\nType::basematch (constTypePtr expected) const\n{\n    tkind ek = expected->m_kind;\n\n#if DO_DEBUG\n//    y2debug (\"basematch '%s', expected '%s'[%d]\", toString().c_str(), expected->toString().c_str(), ek);\n#endif\n\n    if (isError()\n\t|| ek == ErrorT)\n    {\n#if DO_DEBUG\n\ty2debug (\"Error !\");\n#endif\n\treturn -1;\n    }\n\n    if (expected->isReference()\n\t&& (!expected->isConst()\n\t    && isConst()))\n    {\n#if DO_DEBUG\n\ty2debug (\"doesn't expect const\");\n#endif\n\treturn -1;\n    }\n\n    if (ek == AnyT\n\t|| ek == FlexT\n\t|| ek == NFlexT\n\t|| ek == WildcardT\n\t|| ek == UnspecT)\t\t\t// list == list<unspec>\n    {\n#if DO_DEBUG\n//\ty2debug (\"free match\");\n#endif\n\treturn 1;\n    }\n\n    if (isVoid())\t\t\t\t// nil matches everywhere\n    {\n\treturn 0;\n    }\n\n    if (isBasetype() == expected->isBasetype())\n    {\n\treturn 0;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nType {\n  int\n  Type::basematch (constTypePtr expected) const\n  {\n      tkind ek = expected->m_kind;\n  \n  #if DO_DEBUG\n  //    y2debug (\"basematch '%s', expected '%s'[%d]\", toString().c_str(), expected->toString().c_str(), ek);\n  #endif\n  \n      if (isError()\n  \t|| ek == ErrorT)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Error !\");\n  #endif\n  \treturn -1;\n      }\n  \n      if (expected->isReference()\n  \t&& (!expected->isConst()\n  \t    && isConst()))\n      {\n  #if DO_DEBUG\n  \ty2debug (\"doesn't expect const\");\n  #endif\n  \treturn -1;\n      }\n  \n      if (ek == AnyT\n  \t|| ek == FlexT\n  \t|| ek == NFlexT\n  \t|| ek == WildcardT\n  \t|| ek == UnspecT)\t\t\t// list == list<unspec>\n      {\n  #if DO_DEBUG\n  //\ty2debug (\"free match\");\n  #endif\n  \treturn 1;\n      }\n  \n      if (isVoid())\t\t\t\t// nil matches everywhere\n      {\n  \treturn 0;\n      }\n  \n      if (isBasetype() == expected->isBasetype())\n      {\n  \treturn 0;\n      }\n  \n      return -1;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nListType {\n  int\n  ListType::match (constTypePtr expected) const\n  {\n      int bm = basematch (expected);\n  #if DO_DEBUG\n      y2debug (\"match '%s', expected '%s', basematch %d\", toString().c_str(), expected->toString().c_str(), bm);\n  #endif\n      if (bm == 1)\n      {\n  \treturn 0;\n      }\n      if (bm == 0\n  \t&& expected->isList())\n      {\n  \tconstListTypePtr lexpected = expected;\n  \tif (lexpected->m_type->isUnspec()\t\t\t\t// empty list\n  \t    || m_type->isUnspec()\n  \t    || m_type->match (lexpected->m_type) >= 0)\n      {\n  \treturn 0;\n      }\n      }\n      return -1;\n  }\n}"
  },
  {
    "function_name": "matchFlex",
    "container": "ListType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "901-912",
    "snippet": "constTypePtr\nListType::matchFlex (constTypePtr type, unsigned int number) const\n{\n#if DO_DEBUG\n    y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n#endif\n    if (type->isList())\n    {\n\treturn m_type->matchFlex (((constListTypePtr)type)->m_type, number);\n    }\n    return 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_type->matchFlex",
          "args": [
            "((constListTypePtr)type)->m_type",
            "number"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "matchFlex",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1716-1736",
          "snippet": "constTypePtr\nFunctionType::matchFlex (constTypePtr type, unsigned int number) const\n{\n#if DO_DEBUG\n    y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n#endif\n    if (!type->isFunction())\n    {\n\treturn 0;\n    }\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    constFunctionTypePtr ft = (constFunctionTypePtr)type;\n    if (!ft->m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->matchFlex (ft->m_arguments, number);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  constTypePtr\n  FunctionType::matchFlex (constTypePtr type, unsigned int number) const\n  {\n  #if DO_DEBUG\n      y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n  #endif\n      if (!type->isFunction())\n      {\n  \treturn 0;\n      }\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      constFunctionTypePtr ft = (constFunctionTypePtr)type;\n      if (!ft->m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->matchFlex (ft->m_arguments, number);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isList",
          "args": [],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "299-299",
          "snippet": "bool isList () const\t{ return m_kind == ListT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isList () const\t{ return m_kind == ListT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"matchFlex '%s' (%s)\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nListType {\n  constTypePtr\n  ListType::matchFlex (constTypePtr type, unsigned int number) const\n  {\n  #if DO_DEBUG\n      y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n  #endif\n      if (type->isList())\n      {\n  \treturn m_type->matchFlex (((constListTypePtr)type)->m_type, number);\n      }\n      return 0;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "ListType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "884-898",
    "snippet": "string\nListType::toString () const\n{\n    string ret = preToString() + \"list\";\n\n    if (!m_type->isUnspec()\n\t&& !m_type->isAny())\t\t// list <any> -> list\n    {\n\tret += \" <\";\n\tret += m_type->toString();\n\tret += \">\";\n    }\n    ret += postToString();\n    return ret;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "postToString",
          "args": [],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "postToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "244-244",
          "snippet": "string postToString () const { return (m_reference ? \" &\" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string postToString () const { return (m_reference ? \" &\" : \"\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_type->toString",
          "args": [],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_type->isAny",
          "args": [],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "isAny",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "283-283",
          "snippet": "bool isAny () const\t\t{ return m_kind == AnyT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isAny () const\t\t{ return m_kind == AnyT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_type->isUnspec",
          "args": [],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "preToString",
          "args": [],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "preToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "239-239",
          "snippet": "string preToString () const { return (m_const ? \"const \" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string preToString () const { return (m_const ? \"const \" : \"\"); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nListType {\n  string\n  ListType::toString () const\n  {\n      string ret = preToString() + \"list\";\n  \n      if (!m_type->isUnspec()\n  \t&& !m_type->isAny())\t\t// list <any> -> list\n      {\n  \tret += \" <\";\n  \tret += m_type->toString();\n  \tret += \">\";\n      }\n      ret += postToString();\n      return ret;\n  }\n}"
  },
  {
    "function_name": "~ListType",
    "container": "ListType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "870-872",
    "snippet": "ListType::~ListType ()\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nListType {\n  ListType::~ListType ()\n  {\n  }\n}"
  },
  {
    "function_name": "ListType",
    "container": "ListType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "863-867",
    "snippet": "ListType::ListType (bytecodeistream & str)\n    : Type (ListT, str)\n    , m_type (Bytecode::readType (str))\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readType",
          "args": [
            "str"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "readType",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "349-387",
          "snippet": "TypePtr\nBytecode::readType (bytecodeistream & str)\n{\n    int kind = readInt32 (str);\n#if DO_DEBUG\ny2debug (\"Bytecode::readType(%d)\", kind);\n#endif\n    switch ((Type::tkind)kind)\n    {\n\tcase Type::UnspecT:\n\tcase Type::ErrorT:\n\tcase Type::AnyT:\n\tcase Type::BooleanT:\n\tcase Type::ByteblockT:\n\tcase Type::FloatT:\n\tcase Type::IntegerT:\n\tcase Type::LocaleT:\n\tcase Type::PathT:\n\tcase Type::StringT:\n\tcase Type::SymbolT:\n\tcase Type::TermT:\n\tcase Type::VoidT:\n\tcase Type::WildcardT:\n\tcase Type::FlexT:\n\tcase Type::NilT:\n\t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n\tbreak;\n\n\tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n\tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n\tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n\tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n\tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n\tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n\tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n    }\n    y2error (\"Unhandled type kind %d\", kind);\n    return Type::Error->clone();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  TypePtr\n  Bytecode::readType (bytecodeistream & str)\n  {\n      int kind = readInt32 (str);\n  #if DO_DEBUG\n  y2debug (\"Bytecode::readType(%d)\", kind);\n  #endif\n      switch ((Type::tkind)kind)\n      {\n  \tcase Type::UnspecT:\n  \tcase Type::ErrorT:\n  \tcase Type::AnyT:\n  \tcase Type::BooleanT:\n  \tcase Type::ByteblockT:\n  \tcase Type::FloatT:\n  \tcase Type::IntegerT:\n  \tcase Type::LocaleT:\n  \tcase Type::PathT:\n  \tcase Type::StringT:\n  \tcase Type::SymbolT:\n  \tcase Type::TermT:\n  \tcase Type::VoidT:\n  \tcase Type::WildcardT:\n  \tcase Type::FlexT:\n  \tcase Type::NilT:\n  \t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n  \tbreak;\n  \n  \tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n  \tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n  \tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n  \tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n  \tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n  \tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n  \tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n      }\n      y2error (\"Unhandled type kind %d\", kind);\n      return Type::Error->clone();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nListType {\n  ListType::ListType (bytecodeistream & str)\n      : Type (ListT, str)\n      , m_type (Bytecode::readType (str))\n  {\n  }\n}"
  },
  {
    "function_name": "ListType",
    "container": "ListType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "856-860",
    "snippet": "ListType::ListType (constTypePtr type, bool as_const)\n    : Type (ListT, as_const)\n    , m_type (type)\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nListType {\n  ListType::ListType (constTypePtr type, bool as_const)\n      : Type (ListT, as_const)\n      , m_type (type)\n  {\n  }\n}"
  },
  {
    "function_name": "unflex",
    "container": "VariableType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "842-850",
    "snippet": "constTypePtr\nVariableType::unflex (constTypePtr type, unsigned int number) const\n{\n    TypePtr tp = VariableTypePtr (new VariableType (m_type->unflex (type, number)));\n#if DO_DEBUG\n    y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n#endif\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"unflex '%s'%d -%s-> '%s'\"",
            "toString().c_str()",
            "number",
            "type->toString().c_str()",
            "tp->toString().c_str()"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp->toString",
          "args": [],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VariableTypePtr",
          "args": [
            "new VariableType (m_type->unflex (type, number))"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_type->unflex",
          "args": [
            "type",
            "number"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "unflex",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1857-1872",
          "snippet": "constTypePtr\nFunctionType::unflex (constTypePtr type, unsigned int number) const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype->unflex (type, number)));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount (); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType(index)->unflex (type, number));\n\t}\n    }\n#if DO_DEBUG\n    y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n#endif\n    return tp;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  constTypePtr\n  FunctionType::unflex (constTypePtr type, unsigned int number) const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype->unflex (type, number)));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount (); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType(index)->unflex (type, number));\n  \t}\n      }\n  #if DO_DEBUG\n      y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n  #endif\n      return tp;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nVariableType {\n  constTypePtr\n  VariableType::unflex (constTypePtr type, unsigned int number) const\n  {\n      TypePtr tp = VariableTypePtr (new VariableType (m_type->unflex (type, number)));\n  #if DO_DEBUG\n      y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n  #endif\n      return tp;\n  }\n}"
  },
  {
    "function_name": "clone",
    "container": "VariableType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "834-839",
    "snippet": "TypePtr\nVariableType::clone () const\n{\n    VariableTypePtr tp = VariableTypePtr (new VariableType (m_type));\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VariableTypePtr",
          "args": [
            "new VariableType (m_type)"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nVariableType {\n  TypePtr\n  VariableType::clone () const\n  {\n      VariableTypePtr tp = VariableTypePtr (new VariableType (m_type));\n      return tp;\n  }\n}"
  },
  {
    "function_name": "equals",
    "container": "VariableType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "819-831",
    "snippet": "bool\nVariableType::equals (constTypePtr expected) const\n{\n#if DO_DEBUG\n//    y2debug (\"equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    if (expected->isVariable()\n\t    && m_type->equals (((constVariableTypePtr)expected)->m_type))\n    {\n\treturn true;\n    }\n    return false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_type->equals",
          "args": [
            "((constVariableTypePtr)expected)->m_type"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "equals",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1800-1839",
          "snippet": "bool\nFunctionType::equals (constTypePtr expected) const\n{\n#if DO_DEBUG\n//    y2debug (\"FunctionType::equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    if (expected->isFunction())\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (! m_returntype->equals (ft->m_returntype))\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return false;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return true;\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (! m_arguments->parameterType(index)->equals (ft->parameterType(index)))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter %d type mismatch\", index);\n#endif\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  bool\n  FunctionType::equals (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n  //    y2debug (\"FunctionType::equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      if (expected->isFunction())\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (! m_returntype->equals (ft->m_returntype))\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return false;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return true;\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (! m_arguments->parameterType(index)->equals (ft->parameterType(index)))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter %d type mismatch\", index);\n  #endif\n  \t\treturn false;\n  \t    }\n  \t}\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expected->isVariable",
          "args": [],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "isVariable",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "298-298",
          "snippet": "bool isVariable () const\t{ return m_kind == VariableT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isVariable () const\t{ return m_kind == VariableT; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nVariableType {\n  bool\n  VariableType::equals (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n  //    y2debug (\"equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      if (expected->isVariable()\n  \t    && m_type->equals (((constVariableTypePtr)expected)->m_type))\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "match",
    "container": "VariableType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "801-816",
    "snippet": "int\nVariableType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    int bm = basematch (expected);\n    if (bm == 1\n\t|| (bm == 0\n\t    && expected->isVariable()\n\t    && m_type->match (((constVariableTypePtr)expected)->m_type) >= 0))\n    {\n\treturn 0;\n    }\n    return -1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_type->match",
          "args": [
            "((constVariableTypePtr)expected)->m_type"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1739-1797",
          "snippet": "int\nFunctionType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    int bm = basematch (expected);\n\n    if (bm == 1) return 0;\t\t// any or wildcard match\n\n    if ((bm == 0\n\t    && expected->isFunction()))\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (m_returntype->match (ft->m_returntype) < 0)\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return -1;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return 0;\n\t}\n\n\tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n\tif (!wildcard)\n\t{\n\t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter count mismatch\");\n#endif\n\t\treturn -1;\n\t    }\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > esize\t\t\t// don't check wildcard parameters\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n\t    {\n\t\treturn -1;\n\t    }\n\t}\n\treturn 0;\n    }\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  int\n  FunctionType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      int bm = basematch (expected);\n  \n      if (bm == 1) return 0;\t\t// any or wildcard match\n  \n      if ((bm == 0\n  \t    && expected->isFunction()))\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (m_returntype->match (ft->m_returntype) < 0)\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return -1;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return 0;\n  \t}\n  \n  \tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n  \tif (!wildcard)\n  \t{\n  \t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter count mismatch\");\n  #endif\n  \t\treturn -1;\n  \t    }\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > esize\t\t\t// don't check wildcard parameters\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n  \t    {\n  \t\treturn -1;\n  \t    }\n  \t}\n  \treturn 0;\n      }\n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expected->isVariable",
          "args": [],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "isVariable",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "298-298",
          "snippet": "bool isVariable () const\t{ return m_kind == VariableT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isVariable () const\t{ return m_kind == VariableT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "basematch",
          "args": [
            "expected"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "basematch",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "251-302",
          "snippet": "int\nType::basematch (constTypePtr expected) const\n{\n    tkind ek = expected->m_kind;\n\n#if DO_DEBUG\n//    y2debug (\"basematch '%s', expected '%s'[%d]\", toString().c_str(), expected->toString().c_str(), ek);\n#endif\n\n    if (isError()\n\t|| ek == ErrorT)\n    {\n#if DO_DEBUG\n\ty2debug (\"Error !\");\n#endif\n\treturn -1;\n    }\n\n    if (expected->isReference()\n\t&& (!expected->isConst()\n\t    && isConst()))\n    {\n#if DO_DEBUG\n\ty2debug (\"doesn't expect const\");\n#endif\n\treturn -1;\n    }\n\n    if (ek == AnyT\n\t|| ek == FlexT\n\t|| ek == NFlexT\n\t|| ek == WildcardT\n\t|| ek == UnspecT)\t\t\t// list == list<unspec>\n    {\n#if DO_DEBUG\n//\ty2debug (\"free match\");\n#endif\n\treturn 1;\n    }\n\n    if (isVoid())\t\t\t\t// nil matches everywhere\n    {\n\treturn 0;\n    }\n\n    if (isBasetype() == expected->isBasetype())\n    {\n\treturn 0;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nType {\n  int\n  Type::basematch (constTypePtr expected) const\n  {\n      tkind ek = expected->m_kind;\n  \n  #if DO_DEBUG\n  //    y2debug (\"basematch '%s', expected '%s'[%d]\", toString().c_str(), expected->toString().c_str(), ek);\n  #endif\n  \n      if (isError()\n  \t|| ek == ErrorT)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Error !\");\n  #endif\n  \treturn -1;\n      }\n  \n      if (expected->isReference()\n  \t&& (!expected->isConst()\n  \t    && isConst()))\n      {\n  #if DO_DEBUG\n  \ty2debug (\"doesn't expect const\");\n  #endif\n  \treturn -1;\n      }\n  \n      if (ek == AnyT\n  \t|| ek == FlexT\n  \t|| ek == NFlexT\n  \t|| ek == WildcardT\n  \t|| ek == UnspecT)\t\t\t// list == list<unspec>\n      {\n  #if DO_DEBUG\n  //\ty2debug (\"free match\");\n  #endif\n  \treturn 1;\n      }\n  \n      if (isVoid())\t\t\t\t// nil matches everywhere\n      {\n  \treturn 0;\n      }\n  \n      if (isBasetype() == expected->isBasetype())\n      {\n  \treturn 0;\n      }\n  \n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"match '%s', expected '%s'\"",
            "toString().c_str()",
            "expected->toString().c_str()"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected->toString",
          "args": [],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nVariableType {\n  int\n  VariableType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      int bm = basematch (expected);\n      if (bm == 1\n  \t|| (bm == 0\n  \t    && expected->isVariable()\n  \t    && m_type->match (((constVariableTypePtr)expected)->m_type) >= 0))\n      {\n  \treturn 0;\n      }\n      return -1;\n  }\n}"
  },
  {
    "function_name": "matchFlex",
    "container": "VariableType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "787-798",
    "snippet": "constTypePtr\nVariableType::matchFlex (constTypePtr type, unsigned int number) const\n{\n#if DO_DEBUG\n    y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n#endif\n    if (type->isVariable())\n    {\n\treturn m_type->matchFlex (((constVariableTypePtr)type)->m_type, number);\n    }\n    return 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_type->matchFlex",
          "args": [
            "((constVariableTypePtr)type)->m_type",
            "number"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "matchFlex",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1716-1736",
          "snippet": "constTypePtr\nFunctionType::matchFlex (constTypePtr type, unsigned int number) const\n{\n#if DO_DEBUG\n    y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n#endif\n    if (!type->isFunction())\n    {\n\treturn 0;\n    }\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    constFunctionTypePtr ft = (constFunctionTypePtr)type;\n    if (!ft->m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->matchFlex (ft->m_arguments, number);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  constTypePtr\n  FunctionType::matchFlex (constTypePtr type, unsigned int number) const\n  {\n  #if DO_DEBUG\n      y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n  #endif\n      if (!type->isFunction())\n      {\n  \treturn 0;\n      }\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      constFunctionTypePtr ft = (constFunctionTypePtr)type;\n      if (!ft->m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->matchFlex (ft->m_arguments, number);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isVariable",
          "args": [],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "isVariable",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "298-298",
          "snippet": "bool isVariable () const\t{ return m_kind == VariableT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isVariable () const\t{ return m_kind == VariableT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"matchFlex '%s' (%s)\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nVariableType {\n  constTypePtr\n  VariableType::matchFlex (constTypePtr type, unsigned int number) const\n  {\n  #if DO_DEBUG\n      y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n  #endif\n      if (type->isVariable())\n      {\n  \treturn m_type->matchFlex (((constVariableTypePtr)type)->m_type, number);\n      }\n      return 0;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "VariableType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "780-784",
    "snippet": "string\nVariableType::toString () const\n{\n    return \"variable <\" + m_type->toString() + \">\";\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_type->toString",
          "args": [],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nVariableType {\n  string\n  VariableType::toString () const\n  {\n      return \"variable <\" + m_type->toString() + \">\";\n  }\n}"
  },
  {
    "function_name": "~VariableType",
    "container": "VariableType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "766-768",
    "snippet": "VariableType::~VariableType ()\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nVariableType {\n  VariableType::~VariableType ()\n  {\n  }\n}"
  },
  {
    "function_name": "VariableType",
    "container": "VariableType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "759-763",
    "snippet": "VariableType::VariableType (bytecodeistream & str)\n    : Type (VariableT, str)\n    , m_type (Bytecode::readType (str))\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readType",
          "args": [
            "str"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "readType",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "349-387",
          "snippet": "TypePtr\nBytecode::readType (bytecodeistream & str)\n{\n    int kind = readInt32 (str);\n#if DO_DEBUG\ny2debug (\"Bytecode::readType(%d)\", kind);\n#endif\n    switch ((Type::tkind)kind)\n    {\n\tcase Type::UnspecT:\n\tcase Type::ErrorT:\n\tcase Type::AnyT:\n\tcase Type::BooleanT:\n\tcase Type::ByteblockT:\n\tcase Type::FloatT:\n\tcase Type::IntegerT:\n\tcase Type::LocaleT:\n\tcase Type::PathT:\n\tcase Type::StringT:\n\tcase Type::SymbolT:\n\tcase Type::TermT:\n\tcase Type::VoidT:\n\tcase Type::WildcardT:\n\tcase Type::FlexT:\n\tcase Type::NilT:\n\t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n\tbreak;\n\n\tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n\tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n\tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n\tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n\tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n\tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n\tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n    }\n    y2error (\"Unhandled type kind %d\", kind);\n    return Type::Error->clone();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  TypePtr\n  Bytecode::readType (bytecodeistream & str)\n  {\n      int kind = readInt32 (str);\n  #if DO_DEBUG\n  y2debug (\"Bytecode::readType(%d)\", kind);\n  #endif\n      switch ((Type::tkind)kind)\n      {\n  \tcase Type::UnspecT:\n  \tcase Type::ErrorT:\n  \tcase Type::AnyT:\n  \tcase Type::BooleanT:\n  \tcase Type::ByteblockT:\n  \tcase Type::FloatT:\n  \tcase Type::IntegerT:\n  \tcase Type::LocaleT:\n  \tcase Type::PathT:\n  \tcase Type::StringT:\n  \tcase Type::SymbolT:\n  \tcase Type::TermT:\n  \tcase Type::VoidT:\n  \tcase Type::WildcardT:\n  \tcase Type::FlexT:\n  \tcase Type::NilT:\n  \t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n  \tbreak;\n  \n  \tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n  \tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n  \tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n  \tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n  \tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n  \tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n  \tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n      }\n      y2error (\"Unhandled type kind %d\", kind);\n      return Type::Error->clone();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nVariableType {\n  VariableType::VariableType (bytecodeistream & str)\n      : Type (VariableT, str)\n      , m_type (Bytecode::readType (str))\n  {\n  }\n}"
  },
  {
    "function_name": "VariableType",
    "container": "VariableType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "752-756",
    "snippet": "VariableType::VariableType (constTypePtr type, bool as_const)\n    : Type (VariableT, as_const)\n    , m_type (type)\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nVariableType {\n  VariableType::VariableType (constTypePtr type, bool as_const)\n      : Type (VariableT, as_const)\n      , m_type (type)\n  {\n  }\n}"
  },
  {
    "function_name": "unflex",
    "container": "NFlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "728-747",
    "snippet": "constTypePtr\nNFlexType::unflex (constTypePtr type, unsigned int number) const\n{\n    TypePtr tp;\n    if (isNFlex()\n\t&& m_number == number)\n    {\n\ttp = type->clone();\n\tif (isConst()) tp->asConst();\t\t// keep qualifiers from flex\n\tif (isReference()) tp->asReference();\n    }\n    else\n    {\n\ttp = clone();\n    }\n#if DO_DEBUG\n    y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n#endif\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"unflex '%s'%d -%s-> '%s'\"",
            "toString().c_str()",
            "number",
            "type->toString().c_str()",
            "tp->toString().c_str()"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp->toString",
          "args": [],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "clone",
          "args": [],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "clone",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1842-1854",
          "snippet": "TypePtr\nFunctionType::clone () const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType (index));\n\t}\n    }\n    return tp;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  TypePtr\n  FunctionType::clone () const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType (index));\n  \t}\n      }\n      return tp;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp->asReference",
          "args": [],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "asReference",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "264-264",
          "snippet": "void asReference () { m_reference = true; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  void asReference () { m_reference = true; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isReference",
          "args": [],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "isReference",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "259-259",
          "snippet": "bool isReference () const { return m_reference; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isReference () const { return m_reference; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp->asConst",
          "args": [],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "asConst",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "254-254",
          "snippet": "void asConst () { m_const = true; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  void asConst () { m_const = true; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isConst",
          "args": [],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "isConst",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "249-249",
          "snippet": "bool isConst () const { return m_const; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isConst () const { return m_const; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isNFlex",
          "args": [],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "isNFlex",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "296-296",
          "snippet": "bool isNFlex () const\t{ return m_kind == NFlexT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isNFlex () const\t{ return m_kind == NFlexT; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nNFlexType {\n  constTypePtr\n  NFlexType::unflex (constTypePtr type, unsigned int number) const\n  {\n      TypePtr tp;\n      if (isNFlex()\n  \t&& m_number == number)\n      {\n  \ttp = type->clone();\n  \tif (isConst()) tp->asConst();\t\t// keep qualifiers from flex\n  \tif (isReference()) tp->asReference();\n      }\n      else\n      {\n  \ttp = clone();\n      }\n  #if DO_DEBUG\n      y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n  #endif\n      return tp;\n  }\n}"
  },
  {
    "function_name": "number",
    "container": "NFlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "721-725",
    "snippet": "unsigned int\nNFlexType::number () const\n{\n    return m_number;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nNFlexType {\n  unsigned int\n  NFlexType::number () const\n  {\n      return m_number;\n  }\n}"
  },
  {
    "function_name": "clone",
    "container": "NFlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "713-718",
    "snippet": "TypePtr\nNFlexType::clone () const\n{\n    NFlexTypePtr tp = NFlexTypePtr (new NFlexType (m_number));\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NFlexTypePtr",
          "args": [
            "new NFlexType (m_number)"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nNFlexType {\n  TypePtr\n  NFlexType::clone () const\n  {\n      NFlexTypePtr tp = NFlexTypePtr (new NFlexType (m_number));\n      return tp;\n  }\n}"
  },
  {
    "function_name": "match",
    "container": "NFlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "703-710",
    "snippet": "int\nNFlexType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"NFlexType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    return (expected->isFlex() ? 0 : -1);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expected->isFlex",
          "args": [],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "isFlex",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "295-295",
          "snippet": "bool isFlex () const\t{ return ((m_kind == FlexT) || (m_kind == NFlexT)); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isFlex () const\t{ return ((m_kind == FlexT) || (m_kind == NFlexT)); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"NFlexType::match '%s', expected '%s'\"",
            "toString().c_str()",
            "expected->toString().c_str()"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected->toString",
          "args": [],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nNFlexType {\n  int\n  NFlexType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"NFlexType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      return (expected->isFlex() ? 0 : -1);\n  }\n}"
  },
  {
    "function_name": "matchFlex",
    "container": "NFlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "684-700",
    "snippet": "constTypePtr\nNFlexType::matchFlex (constTypePtr type, unsigned int number) const\n{\n#if DO_DEBUG\n    y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n#endif\n    if (number == 0\n\t|| number != m_number)\n    {\n\treturn 0;\n    }\n    if (type->isUnspec ())\n    {\n\treturn Type::Any;\n    }\n    return type;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "const constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "type->isUnspec",
          "args": [],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"matchFlex '%s' (%s)\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));\n\nNFlexType {\n  constTypePtr\n  NFlexType::matchFlex (constTypePtr type, unsigned int number) const\n  {\n  #if DO_DEBUG\n      y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n  #endif\n      if (number == 0\n  \t|| number != m_number)\n      {\n  \treturn 0;\n      }\n      if (type->isUnspec ())\n      {\n  \treturn Type::Any;\n      }\n      return type;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "NFlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "674-681",
    "snippet": "string\nNFlexType::toString () const\n{\n    static char numbuf[8];\n    snprintf (numbuf, 8, \"%d\", m_number);\n\n    return preToString() + \"<T\" + string (numbuf) + \">\" + postToString();\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "postToString",
          "args": [],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "postToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "244-244",
          "snippet": "string postToString () const { return (m_reference ? \" &\" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string postToString () const { return (m_reference ? \" &\" : \"\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "numbuf"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "preToString",
          "args": [],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "preToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "239-239",
          "snippet": "string preToString () const { return (m_const ? \"const \" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string preToString () const { return (m_const ? \"const \" : \"\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "numbuf",
            "8",
            "\"%d\"",
            "m_number"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nNFlexType {\n  string\n  NFlexType::toString () const\n  {\n      static char numbuf[8];\n      snprintf (numbuf, 8, \"%d\", m_number);\n  \n      return preToString() + \"<T\" + string (numbuf) + \">\" + postToString();\n  }\n}"
  },
  {
    "function_name": "~NFlexType",
    "container": "NFlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "657-659",
    "snippet": "NFlexType::~NFlexType ()\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nNFlexType {\n  NFlexType::~NFlexType ()\n  {\n  }\n}"
  },
  {
    "function_name": "NFlexType",
    "container": "NFlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "647-654",
    "snippet": "NFlexType::NFlexType (bytecodeistream & str)\n    : Type (NFlexT, str)\n    , m_number (Bytecode::readInt32 (str))\n{\n#if DO_DEBUG\n    y2debug (\"NFlexType::NFlexType(stream: %d)\", m_number);\n#endif\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"NFlexType::NFlexType(stream: %d)\"",
            "m_number"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readInt32",
          "args": [
            "str"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nNFlexType {\n  NFlexType::NFlexType (bytecodeistream & str)\n      : Type (NFlexT, str)\n      , m_number (Bytecode::readInt32 (str))\n  {\n  #if DO_DEBUG\n      y2debug (\"NFlexType::NFlexType(stream: %d)\", m_number);\n  #endif\n  }\n}"
  },
  {
    "function_name": "NFlexType",
    "container": "NFlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "639-644",
    "snippet": "NFlexType::NFlexType (unsigned int number, bool as_const)\n    : Type (NFlexT, as_const)\n    , m_number (number)\n{\n    if (number == 0) ycp2error (\"NFlexType::NFlexType (0)\");\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"NFlexType::NFlexType (0)\""
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nNFlexType {\n  NFlexType::NFlexType (unsigned int number, bool as_const)\n      : Type (NFlexT, as_const)\n      , m_number (number)\n  {\n      if (number == 0) ycp2error (\"NFlexType::NFlexType (0)\");\n  }\n}"
  },
  {
    "function_name": "unflex",
    "container": "FlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "615-634",
    "snippet": "constTypePtr\nFlexType::unflex (constTypePtr type, unsigned int number) const\n{\n    TypePtr tp;\n    if (isFlex()\n\t&& number == 0)\n    {\n\ttp = type->clone();\n\tif (isConst()) tp->asConst();\t\t// keep qualifiers from flex\n\tif (isReference()) tp->asReference();\n    }\n    else\n    {\n\ttp = clone();\n    }\n#if DO_DEBUG\n    y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n#endif\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"unflex '%s'%d -%s-> '%s'\"",
            "toString().c_str()",
            "number",
            "type->toString().c_str()",
            "tp->toString().c_str()"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp->toString",
          "args": [],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "clone",
          "args": [],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "clone",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1842-1854",
          "snippet": "TypePtr\nFunctionType::clone () const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType (index));\n\t}\n    }\n    return tp;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  TypePtr\n  FunctionType::clone () const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType (index));\n  \t}\n      }\n      return tp;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp->asReference",
          "args": [],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "asReference",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "264-264",
          "snippet": "void asReference () { m_reference = true; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  void asReference () { m_reference = true; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isReference",
          "args": [],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "isReference",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "259-259",
          "snippet": "bool isReference () const { return m_reference; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isReference () const { return m_reference; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp->asConst",
          "args": [],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "asConst",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "254-254",
          "snippet": "void asConst () { m_const = true; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  void asConst () { m_const = true; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isConst",
          "args": [],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "isConst",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "249-249",
          "snippet": "bool isConst () const { return m_const; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isConst () const { return m_const; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isFlex",
          "args": [],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "isFlex",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "295-295",
          "snippet": "bool isFlex () const\t{ return ((m_kind == FlexT) || (m_kind == NFlexT)); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isFlex () const\t{ return ((m_kind == FlexT) || (m_kind == NFlexT)); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFlexType {\n  constTypePtr\n  FlexType::unflex (constTypePtr type, unsigned int number) const\n  {\n      TypePtr tp;\n      if (isFlex()\n  \t&& number == 0)\n      {\n  \ttp = type->clone();\n  \tif (isConst()) tp->asConst();\t\t// keep qualifiers from flex\n  \tif (isReference()) tp->asReference();\n      }\n      else\n      {\n  \ttp = clone();\n      }\n  #if DO_DEBUG\n      y2debug (\"unflex '%s'%d -%s-> '%s'\", toString().c_str(), number, type->toString().c_str(), tp->toString().c_str());\n  #endif\n      return tp;\n  }\n}"
  },
  {
    "function_name": "clone",
    "container": "FlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "607-612",
    "snippet": "TypePtr\nFlexType::clone () const\n{\n    FlexTypePtr tp = FlexTypePtr (new FlexType ());\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FlexTypePtr",
          "args": [
            "new FlexType ()"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFlexType {\n  TypePtr\n  FlexType::clone () const\n  {\n      FlexTypePtr tp = FlexTypePtr (new FlexType ());\n      return tp;\n  }\n}"
  },
  {
    "function_name": "match",
    "container": "FlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "597-604",
    "snippet": "int\nFlexType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"FlexType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    return (expected->isFlex() ? 0 : -1);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expected->isFlex",
          "args": [],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "isFlex",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "295-295",
          "snippet": "bool isFlex () const\t{ return ((m_kind == FlexT) || (m_kind == NFlexT)); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isFlex () const\t{ return ((m_kind == FlexT) || (m_kind == NFlexT)); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"FlexType::match '%s', expected '%s'\"",
            "toString().c_str()",
            "expected->toString().c_str()"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected->toString",
          "args": [],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFlexType {\n  int\n  FlexType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"FlexType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      return (expected->isFlex() ? 0 : -1);\n  }\n}"
  },
  {
    "function_name": "matchFlex",
    "container": "FlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "579-594",
    "snippet": "constTypePtr\nFlexType::matchFlex (constTypePtr type, unsigned int number) const\n{\n#if DO_DEBUG\n    y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n#endif\n    if (number != 0)\n    {\n\treturn 0;\n    }\n    if (type->isUnspec ())\n    {\n\treturn Type::Any;\n    }\n    return type;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "const constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "type->isUnspec",
          "args": [],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"matchFlex '%s' (%s)\"",
            "toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));\n\nFlexType {\n  constTypePtr\n  FlexType::matchFlex (constTypePtr type, unsigned int number) const\n  {\n  #if DO_DEBUG\n      y2debug (\"matchFlex '%s' (%s)\", toString().c_str(), type->toString().c_str());\n  #endif\n      if (number != 0)\n      {\n  \treturn 0;\n      }\n      if (type->isUnspec ())\n      {\n  \treturn Type::Any;\n      }\n      return type;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "FlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "572-576",
    "snippet": "string\nFlexType::toString () const\n{\n    return preToString() + \"<T>\" + postToString();\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "postToString",
          "args": [],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "postToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "244-244",
          "snippet": "string postToString () const { return (m_reference ? \" &\" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string postToString () const { return (m_reference ? \" &\" : \"\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "preToString",
          "args": [],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "preToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "239-239",
          "snippet": "string preToString () const { return (m_const ? \"const \" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string preToString () const { return (m_const ? \"const \" : \"\"); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFlexType {\n  string\n  FlexType::toString () const\n  {\n      return preToString() + \"<T>\" + postToString();\n  }\n}"
  },
  {
    "function_name": "~FlexType",
    "container": "FlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "559-561",
    "snippet": "FlexType::~FlexType ()\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFlexType {\n  FlexType::~FlexType ()\n  {\n  }\n}"
  },
  {
    "function_name": "FlexType",
    "container": "FlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "550-556",
    "snippet": "FlexType::FlexType (bytecodeistream & str)\n    : Type (FlexT, str)\n{\n#if DO_DEBUG\n    y2debug (\"FlexType::FlexType\");\n#endif\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"FlexType::FlexType\""
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFlexType {\n  FlexType::FlexType (bytecodeistream & str)\n      : Type (FlexT, str)\n  {\n  #if DO_DEBUG\n      y2debug (\"FlexType::FlexType\");\n  #endif\n  }\n}"
  },
  {
    "function_name": "FlexType",
    "container": "FlexType",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "544-547",
    "snippet": "FlexType::FlexType (bool as_const)\n    : Type (FlexT, as_const)\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFlexType {\n  FlexType::FlexType (bool as_const)\n      : Type (FlexT, as_const)\n  {\n  }\n}"
  },
  {
    "function_name": "unflex",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "535-539",
    "snippet": "constTypePtr\nType::unflex (constTypePtr type, unsigned int number) const\n{\n    return clone();\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clone",
          "args": [],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "clone",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1842-1854",
          "snippet": "TypePtr\nFunctionType::clone () const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType (index));\n\t}\n    }\n    return tp;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  TypePtr\n  FunctionType::clone () const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType (index));\n  \t}\n      }\n      return tp;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  constTypePtr\n  Type::unflex (constTypePtr type, unsigned int number) const\n  {\n      return clone();\n  }\n}"
  },
  {
    "function_name": "clone",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "527-532",
    "snippet": "TypePtr\nType::clone () const\n{\n    TypePtr tp = TypePtr (new Type (m_kind));\n    return tp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new Type (m_kind)"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  TypePtr\n  Type::clone () const\n  {\n      TypePtr tp = TypePtr (new Type (m_kind));\n      return tp;\n  }\n}"
  },
  {
    "function_name": "equals",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "516-524",
    "snippet": "bool\nType::equals (constTypePtr expected) const\n{\n#if DO_DEBUG\n//    y2debug (\"equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n\n    return (isBasetype() == expected->isBasetype()) && (expected->m_kind == m_kind);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expected->isBasetype",
          "args": [],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "isBasetype",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "502-502",
          "snippet": "bool isBasetype () const { return false; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nFunctionType {\n  bool isBasetype () const { return false; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nType {\n  bool\n  Type::equals (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n  //    y2debug (\"equals '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n  \n      return (isBasetype() == expected->isBasetype()) && (expected->m_kind == m_kind);\n  }\n}"
  },
  {
    "function_name": "canCast",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "502-513",
    "snippet": "bool\nType::canCast (constTypePtr to) const\n{\n#if DO_DEBUG\n    y2debug (\"Type::canCast [%s] -> [%s]\", toString().c_str(), to->toString().c_str());\n#endif\n    if (isAny())\n    {\n\treturn true;\n    }\n    return (match (to) >= 0);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "match",
          "args": [
            "to"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1739-1797",
          "snippet": "int\nFunctionType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    int bm = basematch (expected);\n\n    if (bm == 1) return 0;\t\t// any or wildcard match\n\n    if ((bm == 0\n\t    && expected->isFunction()))\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (m_returntype->match (ft->m_returntype) < 0)\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return -1;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return 0;\n\t}\n\n\tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n\tif (!wildcard)\n\t{\n\t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter count mismatch\");\n#endif\n\t\treturn -1;\n\t    }\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > esize\t\t\t// don't check wildcard parameters\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n\t    {\n\t\treturn -1;\n\t    }\n\t}\n\treturn 0;\n    }\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  int\n  FunctionType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      int bm = basematch (expected);\n  \n      if (bm == 1) return 0;\t\t// any or wildcard match\n  \n      if ((bm == 0\n  \t    && expected->isFunction()))\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (m_returntype->match (ft->m_returntype) < 0)\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return -1;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return 0;\n  \t}\n  \n  \tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n  \tif (!wildcard)\n  \t{\n  \t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter count mismatch\");\n  #endif\n  \t\treturn -1;\n  \t    }\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > esize\t\t\t// don't check wildcard parameters\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n  \t    {\n  \t\treturn -1;\n  \t    }\n  \t}\n  \treturn 0;\n      }\n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isAny",
          "args": [],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "isAny",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "283-283",
          "snippet": "bool isAny () const\t\t{ return m_kind == AnyT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isAny () const\t\t{ return m_kind == AnyT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Type::canCast [%s] -> [%s]\"",
            "toString().c_str()",
            "to->toString().c_str()"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to->toString",
          "args": [],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nType {\n  bool\n  Type::canCast (constTypePtr to) const\n  {\n  #if DO_DEBUG\n      y2debug (\"Type::canCast [%s] -> [%s]\", toString().c_str(), to->toString().c_str());\n  #endif\n      if (isAny())\n      {\n  \treturn true;\n      }\n      return (match (to) >= 0);\n  }\n}"
  },
  {
    "function_name": "matchvalue",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "364-499",
    "snippet": "int\nType::matchvalue (YCPValue value) const\n{\n#if DO_DEBUG\n    y2debug (\"matchvalue type '%s', value '%s'\", toString().c_str(), value.isNull()?\"NULL\":value->toString().c_str());\n#endif\n    y2debug (\"matchvalue type '%s'[%d], value '%s'[%s]\",\n\t     toString().c_str(), m_kind,\n\t     value.isNull()?\"NULL\":value->toString().c_str(),\n\t     value.isNull()?\"\":value->valuetype_str());\n\n    if (value.isNull()) return -1;\t\t\t// error value\n\n    if (isAny()) return 0;\t\t\t\t// type 'any' matches any value\n\n    int m = -1;\n\n    switch (value->valuetype())\n    {\n\tcase YT_VOID:\n\t    m = 0;\t\t\t\t\t// value 'nil' matches any type\n\tbreak;\n\tcase YT_BOOLEAN:\n\t    if (isBoolean ()) m = 0;\n\tbreak;\n\tcase YT_INTEGER:\n\t    if (isInteger ()) m = 0;\n\tbreak;\n\tcase YT_FLOAT:\n\t    if (isFloat ()) m = 0;\n\tbreak;\n\tcase YT_STRING:\n\t    if (isString ()) m = 0;\n\tbreak;\n\tcase YT_BYTEBLOCK:\n\t    if (isByteblock ()) m = 0;\n\tbreak;\n\tcase YT_PATH:\n\t    if (isPath ()) m = 0;\n\tbreak;\n\tcase YT_SYMBOL:\n\t    if (isSymbol ()) m = 0;\n\tbreak;\n\tcase YT_TERM:\n\t    if (isTerm ()) m = 0;\n\tbreak;\n\tcase YT_LIST:\n\t{\n\t    if (!isList()) break;\n\n\t    m = 0;\n\n\t    constTypePtr type = this;\n\t    constTypePtr element_type = ((constListTypePtr)type)->type();\n\t    y2debug (\"isList, element_type '%s'\", element_type->toString().c_str());\n\t    if (element_type->isAny()\t\t\t// list<any>\n\t\t|| element_type->isUnspec())\t\t// list\n\t    {\n\t\tbreak;\t\t\t\t\t// -> match\n\t    }\n\n\t    // check every list element\n\t    YCPList lvalue = value->asList();\n\t    for (int i = 0; i < lvalue->size(); i++)\n\t    {\n\t\tYCPValue evalue = lvalue->value (i);\t// get list element value\n\t\ty2debug (\"evalue '%s'\", evalue->toString().c_str());\n\t\tif (element_type->matchvalue (evalue) < 0)\n\t\t{\n\t\t    y2debug (\"Foul\");\n\t\t    m = -1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tbreak;\n\tcase YT_MAP:\n\t{\n\t    if (!isMap()) break;\n\n\t    m = 0;\n\n\t    constTypePtr type = this;\n\t    constTypePtr key_type = ((constMapTypePtr)type)->keytype();\n\t    constTypePtr element_type = ((constMapTypePtr)type)->valuetype();\n\t    y2debug (\"isMap, key_type '%s', element_type '%s'\", key_type->toString().c_str(), element_type->toString().c_str());\n\t    if (element_type->isAny()\t\t\t// map<keytype, any>\n\t\t|| element_type->isUnspec())\t\t// map\n\t    {\n\t\tbreak;\t\t\t\t\t// -> match\n\t    }\n\n\t    // check every map element\n\t    YCPMap mvalue = value->asMap();\n\t    for (YCPMap::const_iterator i = mvalue->begin(); i != mvalue->end(); ++i)\n\t    {\n\t\tYCPValue kvalue = i->first;\t\t\t// get map key value\n\t\tYCPValue evalue = i->second;\t\t\t// get map element value\n\t\ty2debug (\"kvalue '%s', evalue '%s'\", kvalue->toString().c_str(), evalue->toString().c_str());\n\t\tif (key_type->matchvalue (kvalue) < 0)\n\t\t{\n\t\t    y2debug (\"Key has bad type\");\n\t\t    m = -1;\n\t\t    break;\n\t\t}\n\t\tif (element_type->matchvalue (evalue) < 0)\n\t\t{\n\t\t    y2debug (\"Value has bad type\");\n\t\t    m = -1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tbreak;\n\tcase YT_CODE:\t\t\t\t\t// ``{ ... }\n\t{\n\t    YCPCode ycpcode = value->asCode();\n\t    y2debug (\"Code (%s)\", ycpcode->toString().c_str());\n\t}\n\tbreak;\n\tcase YT_EXTERNAL:\t\t\t\t// external entity\n\t{\n\t    y2debug (\"External payload (%s)\", value->toString().c_str());\n\t}\n\tbreak;\n\tcase YT_RETURN:\t\t\t\t\t// { return; }\n\t{\n\t    m = 0;\t\t\t\t\t// -> evaluates to 'nil' -> matches every type\n\t}\n\tbreak;\n\tdefault:\n\tbreak;\n    }\n    y2debug (\"matchvalue -> %d\", m);\n    return m;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"matchvalue -> %d\"",
            "m"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"External payload (%s)\"",
            "value->toString().c_str()"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Code (%s)\"",
            "ycpcode->toString().c_str()"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->asCode",
          "args": [],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "asCode",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "215-225",
          "snippet": "YCPCode\nYCPValueRep::asCode() const\n{\n    if (!isCode())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Code !\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPCode (static_cast<const YCPCodeRep*>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPCode\n  YCPValueRep::asCode() const\n  {\n      if (!isCode())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Code !\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPCode (static_cast<const YCPCodeRep*>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Value has bad type\""
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "element_type->matchvalue",
          "args": [
            "evalue"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "matchvalue",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "364-499",
          "snippet": "int\nType::matchvalue (YCPValue value) const\n{\n#if DO_DEBUG\n    y2debug (\"matchvalue type '%s', value '%s'\", toString().c_str(), value.isNull()?\"NULL\":value->toString().c_str());\n#endif\n    y2debug (\"matchvalue type '%s'[%d], value '%s'[%s]\",\n\t     toString().c_str(), m_kind,\n\t     value.isNull()?\"NULL\":value->toString().c_str(),\n\t     value.isNull()?\"\":value->valuetype_str());\n\n    if (value.isNull()) return -1;\t\t\t// error value\n\n    if (isAny()) return 0;\t\t\t\t// type 'any' matches any value\n\n    int m = -1;\n\n    switch (value->valuetype())\n    {\n\tcase YT_VOID:\n\t    m = 0;\t\t\t\t\t// value 'nil' matches any type\n\tbreak;\n\tcase YT_BOOLEAN:\n\t    if (isBoolean ()) m = 0;\n\tbreak;\n\tcase YT_INTEGER:\n\t    if (isInteger ()) m = 0;\n\tbreak;\n\tcase YT_FLOAT:\n\t    if (isFloat ()) m = 0;\n\tbreak;\n\tcase YT_STRING:\n\t    if (isString ()) m = 0;\n\tbreak;\n\tcase YT_BYTEBLOCK:\n\t    if (isByteblock ()) m = 0;\n\tbreak;\n\tcase YT_PATH:\n\t    if (isPath ()) m = 0;\n\tbreak;\n\tcase YT_SYMBOL:\n\t    if (isSymbol ()) m = 0;\n\tbreak;\n\tcase YT_TERM:\n\t    if (isTerm ()) m = 0;\n\tbreak;\n\tcase YT_LIST:\n\t{\n\t    if (!isList()) break;\n\n\t    m = 0;\n\n\t    constTypePtr type = this;\n\t    constTypePtr element_type = ((constListTypePtr)type)->type();\n\t    y2debug (\"isList, element_type '%s'\", element_type->toString().c_str());\n\t    if (element_type->isAny()\t\t\t// list<any>\n\t\t|| element_type->isUnspec())\t\t// list\n\t    {\n\t\tbreak;\t\t\t\t\t// -> match\n\t    }\n\n\t    // check every list element\n\t    YCPList lvalue = value->asList();\n\t    for (int i = 0; i < lvalue->size(); i++)\n\t    {\n\t\tYCPValue evalue = lvalue->value (i);\t// get list element value\n\t\ty2debug (\"evalue '%s'\", evalue->toString().c_str());\n\t\tif (element_type->matchvalue (evalue) < 0)\n\t\t{\n\t\t    y2debug (\"Foul\");\n\t\t    m = -1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tbreak;\n\tcase YT_MAP:\n\t{\n\t    if (!isMap()) break;\n\n\t    m = 0;\n\n\t    constTypePtr type = this;\n\t    constTypePtr key_type = ((constMapTypePtr)type)->keytype();\n\t    constTypePtr element_type = ((constMapTypePtr)type)->valuetype();\n\t    y2debug (\"isMap, key_type '%s', element_type '%s'\", key_type->toString().c_str(), element_type->toString().c_str());\n\t    if (element_type->isAny()\t\t\t// map<keytype, any>\n\t\t|| element_type->isUnspec())\t\t// map\n\t    {\n\t\tbreak;\t\t\t\t\t// -> match\n\t    }\n\n\t    // check every map element\n\t    YCPMap mvalue = value->asMap();\n\t    for (YCPMap::const_iterator i = mvalue->begin(); i != mvalue->end(); ++i)\n\t    {\n\t\tYCPValue kvalue = i->first;\t\t\t// get map key value\n\t\tYCPValue evalue = i->second;\t\t\t// get map element value\n\t\ty2debug (\"kvalue '%s', evalue '%s'\", kvalue->toString().c_str(), evalue->toString().c_str());\n\t\tif (key_type->matchvalue (kvalue) < 0)\n\t\t{\n\t\t    y2debug (\"Key has bad type\");\n\t\t    m = -1;\n\t\t    break;\n\t\t}\n\t\tif (element_type->matchvalue (evalue) < 0)\n\t\t{\n\t\t    y2debug (\"Value has bad type\");\n\t\t    m = -1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tbreak;\n\tcase YT_CODE:\t\t\t\t\t// ``{ ... }\n\t{\n\t    YCPCode ycpcode = value->asCode();\n\t    y2debug (\"Code (%s)\", ycpcode->toString().c_str());\n\t}\n\tbreak;\n\tcase YT_EXTERNAL:\t\t\t\t// external entity\n\t{\n\t    y2debug (\"External payload (%s)\", value->toString().c_str());\n\t}\n\tbreak;\n\tcase YT_RETURN:\t\t\t\t\t// { return; }\n\t{\n\t    m = 0;\t\t\t\t\t// -> evaluates to 'nil' -> matches every type\n\t}\n\tbreak;\n\tdefault:\n\tbreak;\n    }\n    y2debug (\"matchvalue -> %d\", m);\n    return m;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Key has bad type\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"kvalue '%s', evalue '%s'\"",
            "kvalue->toString().c_str()",
            "evalue->toString().c_str()"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mvalue->end",
          "args": [],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mvalue->begin",
          "args": [],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asMap",
          "args": [],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "element_type->isUnspec",
          "args": [],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "element_type->isAny",
          "args": [],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "isAny",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "283-283",
          "snippet": "bool isAny () const\t\t{ return m_kind == AnyT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isAny () const\t\t{ return m_kind == AnyT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"isMap, key_type '%s', element_type '%s'\"",
            "key_type->toString().c_str()",
            "element_type->toString().c_str()"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isMap",
          "args": [],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "300-300",
          "snippet": "bool isMap () const\t\t{ return m_kind == MapT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isMap () const\t\t{ return m_kind == MapT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Foul\""
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"evalue '%s'\"",
            "evalue->toString().c_str()"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lvalue->value",
          "args": [
            "i"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lvalue->size",
          "args": [],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asList",
          "args": [],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"isList, element_type '%s'\"",
            "element_type->toString().c_str()"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isList",
          "args": [],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "299-299",
          "snippet": "bool isList () const\t{ return m_kind == ListT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isList () const\t{ return m_kind == ListT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isTerm",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "isTerm",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "292-292",
          "snippet": "bool isTerm () const\t{ return m_kind == TermT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isTerm () const\t{ return m_kind == TermT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isSymbol",
          "args": [],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "isSymbol",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "291-291",
          "snippet": "bool isSymbol () const\t{ return m_kind == SymbolT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isSymbol () const\t{ return m_kind == SymbolT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isPath",
          "args": [],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "isPath",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "289-289",
          "snippet": "bool isPath () const\t{ return m_kind == PathT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isPath () const\t{ return m_kind == PathT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isByteblock",
          "args": [],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "isByteblock",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "285-285",
          "snippet": "bool isByteblock () const\t{ return m_kind == ByteblockT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isByteblock () const\t{ return m_kind == ByteblockT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isString",
          "args": [],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "290-290",
          "snippet": "bool isString () const\t{ return m_kind == StringT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isString () const\t{ return m_kind == StringT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isFloat",
          "args": [],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "isFloat",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "286-286",
          "snippet": "bool isFloat () const\t{ return m_kind == FloatT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isFloat () const\t{ return m_kind == FloatT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isInteger",
          "args": [],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "287-287",
          "snippet": "bool isInteger () const\t{ return m_kind == IntegerT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isInteger () const\t{ return m_kind == IntegerT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isBoolean",
          "args": [],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "isBoolean",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "284-284",
          "snippet": "bool isBoolean () const\t{ return m_kind == BooleanT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isBoolean () const\t{ return m_kind == BooleanT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->valuetype",
          "args": [],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "MapType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "434-434",
          "snippet": "constTypePtr valuetype () const { return m_valuetype; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nMapType {\n  constTypePtr valuetype () const { return m_valuetype; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"matchvalue type '%s'[%d], value '%s'[%s]\"",
            "toString().c_str()",
            "m_kind",
            "value.isNull()?\"NULL\":value->toString().c_str()",
            "value.isNull()?\"\":value->valuetype_str()"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->valuetype_str",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"matchvalue type '%s', value '%s'\"",
            "toString().c_str()",
            "value.isNull()?\"NULL\":value->toString().c_str()"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nType {\n  int\n  Type::matchvalue (YCPValue value) const\n  {\n  #if DO_DEBUG\n      y2debug (\"matchvalue type '%s', value '%s'\", toString().c_str(), value.isNull()?\"NULL\":value->toString().c_str());\n  #endif\n      y2debug (\"matchvalue type '%s'[%d], value '%s'[%s]\",\n  \t     toString().c_str(), m_kind,\n  \t     value.isNull()?\"NULL\":value->toString().c_str(),\n  \t     value.isNull()?\"\":value->valuetype_str());\n  \n      if (value.isNull()) return -1;\t\t\t// error value\n  \n      if (isAny()) return 0;\t\t\t\t// type 'any' matches any value\n  \n      int m = -1;\n  \n      switch (value->valuetype())\n      {\n  \tcase YT_VOID:\n  \t    m = 0;\t\t\t\t\t// value 'nil' matches any type\n  \tbreak;\n  \tcase YT_BOOLEAN:\n  \t    if (isBoolean ()) m = 0;\n  \tbreak;\n  \tcase YT_INTEGER:\n  \t    if (isInteger ()) m = 0;\n  \tbreak;\n  \tcase YT_FLOAT:\n  \t    if (isFloat ()) m = 0;\n  \tbreak;\n  \tcase YT_STRING:\n  \t    if (isString ()) m = 0;\n  \tbreak;\n  \tcase YT_BYTEBLOCK:\n  \t    if (isByteblock ()) m = 0;\n  \tbreak;\n  \tcase YT_PATH:\n  \t    if (isPath ()) m = 0;\n  \tbreak;\n  \tcase YT_SYMBOL:\n  \t    if (isSymbol ()) m = 0;\n  \tbreak;\n  \tcase YT_TERM:\n  \t    if (isTerm ()) m = 0;\n  \tbreak;\n  \tcase YT_LIST:\n  \t{\n  \t    if (!isList()) break;\n  \n  \t    m = 0;\n  \n  \t    constTypePtr type = this;\n  \t    constTypePtr element_type = ((constListTypePtr)type)->type();\n  \t    y2debug (\"isList, element_type '%s'\", element_type->toString().c_str());\n  \t    if (element_type->isAny()\t\t\t// list<any>\n  \t\t|| element_type->isUnspec())\t\t// list\n  \t    {\n  \t\tbreak;\t\t\t\t\t// -> match\n  \t    }\n  \n  \t    // check every list element\n  \t    YCPList lvalue = value->asList();\n  \t    for (int i = 0; i < lvalue->size(); i++)\n  \t    {\n  \t\tYCPValue evalue = lvalue->value (i);\t// get list element value\n  \t\ty2debug (\"evalue '%s'\", evalue->toString().c_str());\n  \t\tif (element_type->matchvalue (evalue) < 0)\n  \t\t{\n  \t\t    y2debug (\"Foul\");\n  \t\t    m = -1;\n  \t\t    break;\n  \t\t}\n  \t    }\n  \t}\n  \tbreak;\n  \tcase YT_MAP:\n  \t{\n  \t    if (!isMap()) break;\n  \n  \t    m = 0;\n  \n  \t    constTypePtr type = this;\n  \t    constTypePtr key_type = ((constMapTypePtr)type)->keytype();\n  \t    constTypePtr element_type = ((constMapTypePtr)type)->valuetype();\n  \t    y2debug (\"isMap, key_type '%s', element_type '%s'\", key_type->toString().c_str(), element_type->toString().c_str());\n  \t    if (element_type->isAny()\t\t\t// map<keytype, any>\n  \t\t|| element_type->isUnspec())\t\t// map\n  \t    {\n  \t\tbreak;\t\t\t\t\t// -> match\n  \t    }\n  \n  \t    // check every map element\n  \t    YCPMap mvalue = value->asMap();\n  \t    for (YCPMap::const_iterator i = mvalue->begin(); i != mvalue->end(); ++i)\n  \t    {\n  \t\tYCPValue kvalue = i->first;\t\t\t// get map key value\n  \t\tYCPValue evalue = i->second;\t\t\t// get map element value\n  \t\ty2debug (\"kvalue '%s', evalue '%s'\", kvalue->toString().c_str(), evalue->toString().c_str());\n  \t\tif (key_type->matchvalue (kvalue) < 0)\n  \t\t{\n  \t\t    y2debug (\"Key has bad type\");\n  \t\t    m = -1;\n  \t\t    break;\n  \t\t}\n  \t\tif (element_type->matchvalue (evalue) < 0)\n  \t\t{\n  \t\t    y2debug (\"Value has bad type\");\n  \t\t    m = -1;\n  \t\t    break;\n  \t\t}\n  \t    }\n  \t}\n  \tbreak;\n  \tcase YT_CODE:\t\t\t\t\t// ``{ ... }\n  \t{\n  \t    YCPCode ycpcode = value->asCode();\n  \t    y2debug (\"Code (%s)\", ycpcode->toString().c_str());\n  \t}\n  \tbreak;\n  \tcase YT_EXTERNAL:\t\t\t\t// external entity\n  \t{\n  \t    y2debug (\"External payload (%s)\", value->toString().c_str());\n  \t}\n  \tbreak;\n  \tcase YT_RETURN:\t\t\t\t\t// { return; }\n  \t{\n  \t    m = 0;\t\t\t\t\t// -> evaluates to 'nil' -> matches every type\n  \t}\n  \tbreak;\n  \tdefault:\n  \tbreak;\n      }\n      y2debug (\"matchvalue -> %d\", m);\n      return m;\n  }\n}"
  },
  {
    "function_name": "match",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "305-361",
    "snippet": "int\nType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    if (basematch (expected) < 0)\n    {\n#if DO_DEBUG\n\ty2debug (\"basematch failed\");\n#endif\n\treturn -1;\n    }\n\n    tkind ek = expected->m_kind;\n\n    if (ek == AnyT\n\t|| ek == FlexT\n\t|| ek == NFlexT\n\t|| ek == WildcardT\n\t|| ek == UnspecT)\t\t\t// list == list<unspec>\n    {\n#if DO_DEBUG\n\ty2debug (\"free match\");\n#endif\n\treturn 0;\n    }\n\n    if (m_kind == ek)\n    {\n#if DO_DEBUG\n\ty2debug (\"m_kind (%d) == expected m_kind (%d)\", m_kind, ek);\n#endif\n\treturn 0;\n    }\n\n    if (isAny()) return -1;\t\t// any does not propagate\n    if (isUnspec()) return 0;\t\t// unspecified matches all\n    if (isVoid()) return 0;\t\t// nil matches all\n    if (isInteger())\t\t\t// int -> float\n    {\n\treturn (ek == FloatT) ? 2 : -1;\n    }\n    if (isFloat())\t\t\t// float -> int\n    {\n\treturn (ek == IntegerT) ? 1 : -1;\n    }\n    if (isLocale())\t\t\t// locale -> string\n    {\n\treturn (ek == StringT) ? 0 : -1;\n    }\n    if (isString())\t\t\t// string -> locale\n    {\n\treturn (ek == LocaleT) ? 0 : -1;\n    }\n    return -1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isString",
          "args": [],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "290-290",
          "snippet": "bool isString () const\t{ return m_kind == StringT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isString () const\t{ return m_kind == StringT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isLocale",
          "args": [],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "isLocale",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "288-288",
          "snippet": "bool isLocale () const\t{ return m_kind == LocaleT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isLocale () const\t{ return m_kind == LocaleT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isFloat",
          "args": [],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "isFloat",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "286-286",
          "snippet": "bool isFloat () const\t{ return m_kind == FloatT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isFloat () const\t{ return m_kind == FloatT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isInteger",
          "args": [],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "287-287",
          "snippet": "bool isInteger () const\t{ return m_kind == IntegerT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isInteger () const\t{ return m_kind == IntegerT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isVoid",
          "args": [],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "293-293",
          "snippet": "bool isVoid () const\t{ return m_kind == VoidT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isVoid () const\t{ return m_kind == VoidT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isUnspec",
          "args": [],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isAny",
          "args": [],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "isAny",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "283-283",
          "snippet": "bool isAny () const\t\t{ return m_kind == AnyT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isAny () const\t\t{ return m_kind == AnyT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"m_kind (%d) == expected m_kind (%d)\"",
            "m_kind",
            "ek"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"free match\""
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"basematch failed\""
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "basematch",
          "args": [
            "expected"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "basematch",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "251-302",
          "snippet": "int\nType::basematch (constTypePtr expected) const\n{\n    tkind ek = expected->m_kind;\n\n#if DO_DEBUG\n//    y2debug (\"basematch '%s', expected '%s'[%d]\", toString().c_str(), expected->toString().c_str(), ek);\n#endif\n\n    if (isError()\n\t|| ek == ErrorT)\n    {\n#if DO_DEBUG\n\ty2debug (\"Error !\");\n#endif\n\treturn -1;\n    }\n\n    if (expected->isReference()\n\t&& (!expected->isConst()\n\t    && isConst()))\n    {\n#if DO_DEBUG\n\ty2debug (\"doesn't expect const\");\n#endif\n\treturn -1;\n    }\n\n    if (ek == AnyT\n\t|| ek == FlexT\n\t|| ek == NFlexT\n\t|| ek == WildcardT\n\t|| ek == UnspecT)\t\t\t// list == list<unspec>\n    {\n#if DO_DEBUG\n//\ty2debug (\"free match\");\n#endif\n\treturn 1;\n    }\n\n    if (isVoid())\t\t\t\t// nil matches everywhere\n    {\n\treturn 0;\n    }\n\n    if (isBasetype() == expected->isBasetype())\n    {\n\treturn 0;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nType {\n  int\n  Type::basematch (constTypePtr expected) const\n  {\n      tkind ek = expected->m_kind;\n  \n  #if DO_DEBUG\n  //    y2debug (\"basematch '%s', expected '%s'[%d]\", toString().c_str(), expected->toString().c_str(), ek);\n  #endif\n  \n      if (isError()\n  \t|| ek == ErrorT)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Error !\");\n  #endif\n  \treturn -1;\n      }\n  \n      if (expected->isReference()\n  \t&& (!expected->isConst()\n  \t    && isConst()))\n      {\n  #if DO_DEBUG\n  \ty2debug (\"doesn't expect const\");\n  #endif\n  \treturn -1;\n      }\n  \n      if (ek == AnyT\n  \t|| ek == FlexT\n  \t|| ek == NFlexT\n  \t|| ek == WildcardT\n  \t|| ek == UnspecT)\t\t\t// list == list<unspec>\n      {\n  #if DO_DEBUG\n  //\ty2debug (\"free match\");\n  #endif\n  \treturn 1;\n      }\n  \n      if (isVoid())\t\t\t\t// nil matches everywhere\n      {\n  \treturn 0;\n      }\n  \n      if (isBasetype() == expected->isBasetype())\n      {\n  \treturn 0;\n      }\n  \n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"match '%s', expected '%s'\"",
            "toString().c_str()",
            "expected->toString().c_str()"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected->toString",
          "args": [],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nType {\n  int\n  Type::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      if (basematch (expected) < 0)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"basematch failed\");\n  #endif\n  \treturn -1;\n      }\n  \n      tkind ek = expected->m_kind;\n  \n      if (ek == AnyT\n  \t|| ek == FlexT\n  \t|| ek == NFlexT\n  \t|| ek == WildcardT\n  \t|| ek == UnspecT)\t\t\t// list == list<unspec>\n      {\n  #if DO_DEBUG\n  \ty2debug (\"free match\");\n  #endif\n  \treturn 0;\n      }\n  \n      if (m_kind == ek)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"m_kind (%d) == expected m_kind (%d)\", m_kind, ek);\n  #endif\n  \treturn 0;\n      }\n  \n      if (isAny()) return -1;\t\t// any does not propagate\n      if (isUnspec()) return 0;\t\t// unspecified matches all\n      if (isVoid()) return 0;\t\t// nil matches all\n      if (isInteger())\t\t\t// int -> float\n      {\n  \treturn (ek == FloatT) ? 2 : -1;\n      }\n      if (isFloat())\t\t\t// float -> int\n      {\n  \treturn (ek == IntegerT) ? 1 : -1;\n      }\n      if (isLocale())\t\t\t// locale -> string\n      {\n  \treturn (ek == StringT) ? 0 : -1;\n      }\n      if (isString())\t\t\t// string -> locale\n      {\n  \treturn (ek == LocaleT) ? 0 : -1;\n      }\n      return -1;\n  }\n}"
  },
  {
    "function_name": "basematch",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "251-302",
    "snippet": "int\nType::basematch (constTypePtr expected) const\n{\n    tkind ek = expected->m_kind;\n\n#if DO_DEBUG\n//    y2debug (\"basematch '%s', expected '%s'[%d]\", toString().c_str(), expected->toString().c_str(), ek);\n#endif\n\n    if (isError()\n\t|| ek == ErrorT)\n    {\n#if DO_DEBUG\n\ty2debug (\"Error !\");\n#endif\n\treturn -1;\n    }\n\n    if (expected->isReference()\n\t&& (!expected->isConst()\n\t    && isConst()))\n    {\n#if DO_DEBUG\n\ty2debug (\"doesn't expect const\");\n#endif\n\treturn -1;\n    }\n\n    if (ek == AnyT\n\t|| ek == FlexT\n\t|| ek == NFlexT\n\t|| ek == WildcardT\n\t|| ek == UnspecT)\t\t\t// list == list<unspec>\n    {\n#if DO_DEBUG\n//\ty2debug (\"free match\");\n#endif\n\treturn 1;\n    }\n\n    if (isVoid())\t\t\t\t// nil matches everywhere\n    {\n\treturn 0;\n    }\n\n    if (isBasetype() == expected->isBasetype())\n    {\n\treturn 0;\n    }\n\n    return -1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "expected->isBasetype",
          "args": [],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "isBasetype",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "502-502",
          "snippet": "bool isBasetype () const { return false; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nFunctionType {\n  bool isBasetype () const { return false; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isVoid",
          "args": [],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "293-293",
          "snippet": "bool isVoid () const\t{ return m_kind == VoidT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isVoid () const\t{ return m_kind == VoidT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"doesn't expect const\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isConst",
          "args": [],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "isConst",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "249-249",
          "snippet": "bool isConst () const { return m_const; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isConst () const { return m_const; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expected->isReference",
          "args": [],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "isReference",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "259-259",
          "snippet": "bool isReference () const { return m_reference; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isReference () const { return m_reference; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Error !\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isError",
          "args": [],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "isError",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "282-282",
          "snippet": "bool isError () const\t{ return m_kind == ErrorT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isError () const\t{ return m_kind == ErrorT; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nType {\n  int\n  Type::basematch (constTypePtr expected) const\n  {\n      tkind ek = expected->m_kind;\n  \n  #if DO_DEBUG\n  //    y2debug (\"basematch '%s', expected '%s'[%d]\", toString().c_str(), expected->toString().c_str(), ek);\n  #endif\n  \n      if (isError()\n  \t|| ek == ErrorT)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"Error !\");\n  #endif\n  \treturn -1;\n      }\n  \n      if (expected->isReference()\n  \t&& (!expected->isConst()\n  \t    && isConst()))\n      {\n  #if DO_DEBUG\n  \ty2debug (\"doesn't expect const\");\n  #endif\n  \treturn -1;\n      }\n  \n      if (ek == AnyT\n  \t|| ek == FlexT\n  \t|| ek == NFlexT\n  \t|| ek == WildcardT\n  \t|| ek == UnspecT)\t\t\t// list == list<unspec>\n      {\n  #if DO_DEBUG\n  //\ty2debug (\"free match\");\n  #endif\n  \treturn 1;\n      }\n  \n      if (isVoid())\t\t\t\t// nil matches everywhere\n      {\n  \treturn 0;\n      }\n  \n      if (isBasetype() == expected->isBasetype())\n      {\n  \treturn 0;\n      }\n  \n      return -1;\n  }\n}"
  },
  {
    "function_name": "toXmlString",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "207-242",
    "snippet": "string\nType::toXmlString () const\n{\n    string ret;\n    switch (m_kind)\n    {\n\tcase UnspecT:\tret = \"unspec\"; break;\n\tcase ErrorT:\tret = \"ERR\"; break;\n\tcase AnyT:\tret = \"any\"; break;\n\tcase BooleanT:\tret = \"boolean\"; break;\n\tcase ByteblockT: ret = \"byteblock\"; break;\n\tcase FloatT:\tret = \"float\"; break;\n\tcase IntegerT:\tret = \"integer\"; break;\n\tcase LocaleT:\tret = \"locale\"; break;\n\tcase PathT:\tret = \"path\"; break;\n\tcase StringT:\tret = \"string\"; break;\n\tcase SymbolT:\tret = \"symbol\"; break;\n\tcase TermT:\tret = \"term\"; break;\n\tcase VoidT:\tret = \"void\"; break;\n\tcase WildcardT: ret = \"...\"; break;\n\n\tcase FlexT:\tret = \"flex\"; break;\n\tcase VariableT:\tret = \"var\"; break;\n\tcase BlockT:\tret = \"block\"; break;\n\tcase ListT:\tret = \"list\"; break;\n\tcase MapT:\tret = \"map\"; break;\n\tcase TupleT:\tret = \"tuple\"; break;\n\tcase FunctionT:\tret = \"function\"; break;\n\n\tcase NilT:\tret = \"nil\"; break;\n\tcase NFlexT:\tret = \"nflex\"; break;\n\t// no default:, let gcc warn\n    }\n    if (ret.empty()) ret = \"<UNHANDLED>\";\n    return preToString() + ret + postToString();\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "postToString",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "postToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "244-244",
          "snippet": "string postToString () const { return (m_reference ? \" &\" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string postToString () const { return (m_reference ? \" &\" : \"\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "preToString",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "preToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "239-239",
          "snippet": "string preToString () const { return (m_const ? \"const \" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string preToString () const { return (m_const ? \"const \" : \"\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ret.empty",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  string\n  Type::toXmlString () const\n  {\n      string ret;\n      switch (m_kind)\n      {\n  \tcase UnspecT:\tret = \"unspec\"; break;\n  \tcase ErrorT:\tret = \"ERR\"; break;\n  \tcase AnyT:\tret = \"any\"; break;\n  \tcase BooleanT:\tret = \"boolean\"; break;\n  \tcase ByteblockT: ret = \"byteblock\"; break;\n  \tcase FloatT:\tret = \"float\"; break;\n  \tcase IntegerT:\tret = \"integer\"; break;\n  \tcase LocaleT:\tret = \"locale\"; break;\n  \tcase PathT:\tret = \"path\"; break;\n  \tcase StringT:\tret = \"string\"; break;\n  \tcase SymbolT:\tret = \"symbol\"; break;\n  \tcase TermT:\tret = \"term\"; break;\n  \tcase VoidT:\tret = \"void\"; break;\n  \tcase WildcardT: ret = \"...\"; break;\n  \n  \tcase FlexT:\tret = \"flex\"; break;\n  \tcase VariableT:\tret = \"var\"; break;\n  \tcase BlockT:\tret = \"block\"; break;\n  \tcase ListT:\tret = \"list\"; break;\n  \tcase MapT:\tret = \"map\"; break;\n  \tcase TupleT:\tret = \"tuple\"; break;\n  \tcase FunctionT:\tret = \"function\"; break;\n  \n  \tcase NilT:\tret = \"nil\"; break;\n  \tcase NFlexT:\tret = \"nflex\"; break;\n  \t// no default:, let gcc warn\n      }\n      if (ret.empty()) ret = \"<UNHANDLED>\";\n      return preToString() + ret + postToString();\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "169-204",
    "snippet": "string\nType::toString () const\n{\n    string ret;\n    switch (m_kind)\n    {\n\tcase UnspecT:\tret = \"<unspec>\"; break;\n\tcase ErrorT:\tret = \"<*ERR*>\"; break;\n\tcase AnyT:\tret = \"any\"; break;\n\tcase BooleanT:\tret = \"boolean\"; break;\n\tcase ByteblockT: ret = \"byteblock\"; break;\n\tcase FloatT:\tret = \"float\"; break;\n\tcase IntegerT:\tret = \"integer\"; break;\n\tcase LocaleT:\tret = \"locale\"; break;\n\tcase PathT:\tret = \"path\"; break;\n\tcase StringT:\tret = \"string\"; break;\n\tcase SymbolT:\tret = \"symbol\"; break;\n\tcase TermT:\tret = \"term\"; break;\n\tcase VoidT:\tret = \"void\"; break;\n\tcase WildcardT: ret = \"...\"; break;\n\n\tcase FlexT:\tret = \"<T>\"; break;\n\tcase VariableT:\tret = \"<VARIABLE>\"; break;\n\tcase BlockT:\tret = \"<BLOCK>\"; break;\n\tcase ListT:\tret = \"<LIST>\"; break;\n\tcase MapT:\tret = \"<MAP>\"; break;\n\tcase TupleT:\tret = \"<TUPLE>\"; break;\n\tcase FunctionT:\tret = \"<FUNCTION>\"; break;\n\n\tcase NilT:\tret = \"<nil>\"; break;\n\tcase NFlexT:\tret = \"<Tx>\"; break;\n\t// no default:, let gcc warn\n    }\n    if (ret.empty()) ret = \"<UNHANDLED>\";\n    return preToString() + ret + postToString();\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "postToString",
          "args": [],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "postToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "244-244",
          "snippet": "string postToString () const { return (m_reference ? \" &\" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string postToString () const { return (m_reference ? \" &\" : \"\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "preToString",
          "args": [],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "preToString",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "239-239",
          "snippet": "string preToString () const { return (m_const ? \"const \" : \"\"); }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  string preToString () const { return (m_const ? \"const \" : \"\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ret.empty",
          "args": [],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  string\n  Type::toString () const\n  {\n      string ret;\n      switch (m_kind)\n      {\n  \tcase UnspecT:\tret = \"<unspec>\"; break;\n  \tcase ErrorT:\tret = \"<*ERR*>\"; break;\n  \tcase AnyT:\tret = \"any\"; break;\n  \tcase BooleanT:\tret = \"boolean\"; break;\n  \tcase ByteblockT: ret = \"byteblock\"; break;\n  \tcase FloatT:\tret = \"float\"; break;\n  \tcase IntegerT:\tret = \"integer\"; break;\n  \tcase LocaleT:\tret = \"locale\"; break;\n  \tcase PathT:\tret = \"path\"; break;\n  \tcase StringT:\tret = \"string\"; break;\n  \tcase SymbolT:\tret = \"symbol\"; break;\n  \tcase TermT:\tret = \"term\"; break;\n  \tcase VoidT:\tret = \"void\"; break;\n  \tcase WildcardT: ret = \"...\"; break;\n  \n  \tcase FlexT:\tret = \"<T>\"; break;\n  \tcase VariableT:\tret = \"<VARIABLE>\"; break;\n  \tcase BlockT:\tret = \"<BLOCK>\"; break;\n  \tcase ListT:\tret = \"<LIST>\"; break;\n  \tcase MapT:\tret = \"<MAP>\"; break;\n  \tcase TupleT:\tret = \"<TUPLE>\"; break;\n  \tcase FunctionT:\tret = \"<FUNCTION>\"; break;\n  \n  \tcase NilT:\tret = \"<nil>\"; break;\n  \tcase NFlexT:\tret = \"<Tx>\"; break;\n  \t// no default:, let gcc warn\n      }\n      if (ret.empty()) ret = \"<UNHANDLED>\";\n      return preToString() + ret + postToString();\n  }\n}"
  },
  {
    "function_name": "Type",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "129-137",
    "snippet": "Type::Type (tkind kind, bytecodeistream & str)\n    : m_kind (kind)\n    , m_const (Bytecode::readBool (str))\n    , m_reference (Bytecode::readBool (str))\n{\n#if DO_DEBUG\n    y2debug (\"Type::fromStream (kind %d, const %d, ref %d)\", m_kind, m_const, m_reference);\n#endif\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Type::fromStream (kind %d, const %d, ref %d)\"",
            "m_kind",
            "m_const",
            "m_reference"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readBool",
          "args": [
            "str"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "readBool",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "158-172",
          "snippet": "bool\nBytecode::readBool (bytecodeistream & str)\n{\n    char c;\n    str.get (c);\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n#endif\n\n    if (c != 0)\n    {\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readBool (bytecodeistream & str)\n  {\n      char c;\n      str.get (c);\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n  #endif\n  \n      if (c != 0)\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nType {\n  Type::Type (tkind kind, bytecodeistream & str)\n      : m_kind (kind)\n      , m_const (Bytecode::readBool (str))\n      , m_reference (Bytecode::readBool (str))\n  {\n  #if DO_DEBUG\n      y2debug (\"Type::fromStream (kind %d, const %d, ref %d)\", m_kind, m_const, m_reference);\n  #endif\n  }\n}"
  },
  {
    "function_name": "~Type",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "122-124",
    "snippet": "Type::~Type()\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  Type::~Type()\n  {\n  }\n}"
  },
  {
    "function_name": "Type",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "116-119",
    "snippet": "Type::Type (const Type &type)\n    : Rep (type), m_kind (type.m_kind)\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  Type::Type (const Type &type)\n      : Rep (type), m_kind (type.m_kind)\n  {\n  }\n}"
  },
  {
    "function_name": "Type",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "111-114",
    "snippet": "Type::Type ()\n    : m_kind (UnspecT)\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  Type::Type ()\n      : m_kind (UnspecT)\n  {\n  }\n}"
  },
  {
    "function_name": "Function",
    "container": "Type",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
    "lines": "102-106",
    "snippet": "FunctionTypePtr\nType::Function(constTypePtr return_type)\n{\n    return FunctionTypePtr ( new FunctionType (return_type) );\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FunctionTypePtr",
          "args": [
            "new FunctionType (return_type)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  FunctionTypePtr\n  Type::Function(constTypePtr return_type)\n  {\n      return FunctionTypePtr ( new FunctionType (return_type) );\n  }\n}"
  }
]