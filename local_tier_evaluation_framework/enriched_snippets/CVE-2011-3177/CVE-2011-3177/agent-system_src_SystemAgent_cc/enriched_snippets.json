[
  {
    "function_name": "Execute",
    "container": "SystemAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
    "lines": "870-1416",
    "snippet": "YCPValue\nSystemAgent::Execute (const YCPPath& path, const YCPValue& value,\n\t\t      const YCPValue& arg)\n{\n    y2debug (\"Execute (%s)\", path->toString().c_str());\n\n    if (path->isRoot ())\n    {\n\treturn YCPError (\"Execute () called without sub-path\");\n    }\n\n    if (value.isNull ())\n    {\n\treturn YCPError (string(\"Execute (\")+path->toString()+\") without argument.\");\n    }\n\n    const string cmd = path->component_str (0); // just a shortcut\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    // .bash*\n\n    if (cmd == \"bash\"\n\t|| cmd == \"bash_output\"\n\t|| cmd == \"bash_background\")\n    {\n\n\tYCPValue environment = YCPVoid();\n\n\tif (!arg.isNull())\n\t    environment = arg;\n\n\t/**\n\t * @builtin Execute (.target.bash, string command, map environment) -> integer\n\t * @builtin Execute (.target.bash_background, string command, map environment) -> integer\n\t * @builtin Execute (.target.bash_output, string command, map environment) -> map\n\t *\n\t * Runs a bash command. The command is stated as string.\n\t * The map variables can be used to give initial environment\n\t * definitions to the target. The keys have to be strings,\n\t * the values can be of any type. If you use string values,\n\t * the strings may _not_ contain single quotes. Escape them\n\t * with double backqoute, if you need them. This is subject\n\t * to change.\n\t *\n\t * The return value will be either an integer with the exitcode of\n\t * the shell script or a map:<pre>\n\t * $[\n\t * <dd> \"exit\" : &lt;integer&gt;,  //exitcode from shell script\n\t * <dd> \"stdout\" : &lt;string&gt;, //stdout of the command\n\t * <dd> \"stderr\" : &lt;string&gt;  //stderr of the command\n\t * ]</pre>\n\t *\n\t * @example Execute (.target.bash, \"/bin/touch $FILE ; exit 5\", $[\"FILE\":\"/somedir/somefile\"]) -> 5\n\t * @example Execute (.target.bash_output, \"/bin/touch $FILE ; exit 5\", $[\"FILE\":\"/somedir/somefile\"]) -> $[ \"exit\" : 5, \"stdout\" : \"\", \"stderr\" : \"\"]\n\t *\n\t */\n\n\tif (value.isNull() || !value->isString())\n\t{\n\t    return YCPError (\"Bad command argument to Execute (.bash, string command [, map env])\");\n\t}\n\n\t/* shell command must have rooted path */\n\tstring bashcommand = value->asString()->value();\n#if 0\n\tif (bashcommand[0] != '/')\n\t{\n\t    ycp2warning (\"\", 0, \"Execute (.bash, ...) without full path !\");\n\t}\n#endif\n\n\t/* check for and construct shell enviroment */\n\tYCPMap variables;\n\tif (environment->isMap())\n\t{\n\t    variables = environment->asMap();\n\t}\n\n\tstring exports = \"\";\n\tfor (YCPMap::const_iterator pos = variables->begin(); pos != variables->end(); ++pos)\n\t{\n\t    const YCPValue& key = pos->first;\n\t    const YCPValue& value = pos->second;\n\n\t    if (!key->isString())\n\t    {\n\t\treturn YCPError (string(\"Invalid value '\")\n\t\t\t\t + key->toString()\n\t\t\t\t + \"' for target variable name, which must be a string\");\n\t    }\n\n\t    exports += \"export \" + key->asString()->value() + \"='\";\n\t    string valstr;\n\t    if (value->isString())\n\t    {\n\t\tvalstr = value->asString()->value();\n\t    }\n\t    else\n\t    {\n\t\tvalstr = value->toString();\n\t    }\n\t    exports += valstr + \"'\\n\";\n\t}\n\n\t/* execute script and return YCP{Integer|Map} */\n\tif (cmd == \"bash\")\n\t{\n\t    return YCPInteger (shellcommand (exports + bashcommand));\n\t}\n\telse if (cmd == \"bash_output\")\n\t{\n\t    return shellcommand_output (exports + bashcommand, tempdir);\n\t}\n\telse if (cmd == \"bash_background\")\n\t{\n\t    return YCPInteger (shellcommand_background (exports + bashcommand));\n\t}\n    } // .bash*\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    else if (cmd == \"bash_input\")\n    {\n\t/**\n\t * @builtin Execute (.target.bash_input, string command, string input) -> integer\n\t *\n\t * Note: Function has only one used within YaST2 and is subject to\n\t * sudden change or removal.\n\t */\n\n\tif (value.isNull() || !value->isString())\n\t{\n\t    return YCPError (\"Bad command argument to Execute (.bash_input, string \"\n\t\t\t     \"command, string stdin\");\n\t}\n\n\tif (arg.isNull() || !arg->isString())\n\t{\n\t    return YCPError (\"Bad command argument to Execute (.bash_input, string \"\n\t\t\t     \"command, string stdin\");\n\t}\n\n\tstring command = value->asString ()->value ();\n\tcommand += \">/dev/null 2>&1\";\n\n\tstring input = arg->asString ()->value ();\n\tinput += \"\\n\";\n\n\tFILE* p = popen (command.c_str (), \"w\");\n\tif (!p)\n\t{\n\t    return YCPError (\"popen failed\");\n\t}\n\n\tfwrite (input.c_str (), input.length (), 1, p);\n\tint ret = pclose (p);\n\n\tif (WIFEXITED (ret))\n\t    return YCPInteger (WEXITSTATUS (ret));\n\treturn YCPInteger (WTERMSIG (ret) + 128);\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    else if (cmd == \"symlink\")\n    {\n\t/**\n\t * @builtin Execute (.target.symlink, string oldpath, string newpath) -> boolean\n\t *\n\t * Creates a symbolic link named newpath which contains the\n\t * string oldpath.\n\t *\n\t * Symbolic links are interpreted at run-time as if the  con\n\t * tents of the link had been substituted into the path being\n\t * followed to find a file or directory.\n\t *\n\t * The return value is true or false, depending of the success.\n\t *\n\t * @example Execute (.target.symlink, \"/lib/YaST2\", \"Y2\")\n\t */\n\n\tif (value.isNull () || arg.isNull () || !value->isString () ||\n\t    !arg->isString ())\n\t{\n\t    return YCPError (\"Bad arguments to Execute (.symlink, string old, string new)\");\n\t}\n\tconst char *oldpath = value->asString()->value_cstr();\n\tconst string newpath = arg->asString()->value();\n\n\ty2milestone (\"symlink %s -> %s\", oldpath, newpath.c_str());\n\n\tremove (newpath.c_str());\n\treturn YCPBoolean (symlink (oldpath, newpath.c_str()) == 0);\n\n    } // .symlink\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    else if (cmd == \"mkdir\")\n    {\n\t/**\n\t * @builtin Execute (.target.mkdir, string path <, integer mode>)) -> boolean\n\t *\n\t * Creates a directory and all its parents, if necessary.\n\t * All created elements will have mode 0755 if mode is omitted.\n\t *\n\t * The return value is true or false, depending of the success, ie if\n\t * the directory exists afterwards.\n\t *\n\t * @example Execute (.target.mkdir, \"/var/adm/mount\")\n\t */\n\n\tif (value.isNull() || !value->isString())\n\t{\n\t    return YCPError (\"Bad path argument to Execute (.mkdir, string path)\");\n\t}\n\n\tstring path = value->asString()->value();\n\n\tint mode = 0755;\n\n\tif (!arg.isNull())\n\t{\n\t    if (arg->isInteger())\n\t    {\n\t\tmode = arg->asInteger()->value();\n\t    }\n\t    else\n\t    {\n\t\treturn YCPError (\"Bad mode argument to Execute (.mkdir, string path, integer mode)\");\n\t    }\n\t}\n\n\tsize_t pos = 0;\n\n\ty2milestone (\"mkdir %s\", path.c_str());\n\n\t// Create leading components\n\twhile (pos = path.find('/', pos + 1), pos != string::npos)\n\t{\n\t    mkdir (path.substr(0, pos).c_str(), mode);\n\t}\n\t// Create the last part\n\tmkdir (path.substr(0, pos).c_str(), mode);\n\n\tstruct stat sb;\n\treturn YCPBoolean(stat(path.c_str(), &sb) == 0 && S_ISDIR(sb.st_mode));\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    else if (cmd == \"mount\")\n    {\n\t/**\n\t * @builtin Execute (.target.mount, [ string device, string mountpoint <, string logfile>], [, string options])) -> boolean\n\t *\n\t * Mounts a (block) device at a mountpoint.\n\t * If logfile is given, the stderr of the mount cmd will be appended to\n\t * this file\n\t *\n\t * The return value is true or false, depending of the success\n\t *\n\t * @example Execute (.target.mount, [\"/dev/fd0\", \"/floppy\"], \"-t msdos\")\n\t * @example Execute (.target.mount, [\"/dev/fd0\", \"/floppy\", \"/var/log/y2mountlog\"], \"-t msdos\")\n\t */\n\n\tif (value.isNull() || !value->isList())\n\t{\n\t    return YCPError (\"Bad path argument to Execute (.mount, [ string device, string mountpoint <, string y2mountlog> ])\");\n\t}\n\n\tYCPList mountlist = value->asList();\n\tif (mountlist->size() < 2\n\t    || !mountlist->value(0)->isString()\n\t    || !mountlist->value(1)->isString())\n\t{\n\t    return YCPError (\"Bad list values in argument to Execute (.mount, [ string device, string mountpoint ])\");\n\t}\n\n\tstring mountcmd = \"/bin/mount \";\n\n\t// arg is mount options, this is optional\n\n\tif (!arg.isNull())\n\t{\n\t    if (arg->isString())\n\t    {\n\t\tmountcmd += arg->asString()->value() + \" \";\n\t    }\n\t    else\n\t    {\n\t\treturn YCPError (\"Bad type of mode argument to Execute (.mount, string|list path, string mode)\", YCPBoolean (false));\n\t    }\n\t}\n\n\t// device\n\tmountcmd += mountlist->value(0)->asString()->value() + \" \";\n\t// mountpoint\n\tmountcmd += mountlist->value(1)->asString()->value();\n\n\tif (mountlist->size() == 3)\n\t{\n\t    if (mountlist->value(2)->isString())\n\t    {\n\t\tmountcmd += \" 2> \" + mountlist->value(2)->asString()->value();\n\t    }\n\t    else\n\t    {\n\t\treturn YCPError (\"Bad logfile argument to Execute (.mount, [ string device, string mountpoint, string logfile ])\", YCPBoolean (false));\n\t    }\n\t}\n\n\treturn YCPBoolean (shellcommand (mountcmd) == 0);\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    else if (cmd == \"smbmount\")\n    {\n\t/**\n\t * @builtin Execute (.target.smbmount, [ string server_and_dir, string mountpoint <, string logfile>], [, string options])) -> boolean\n\t *\n\t * Mounts a SMB share at a mountpoint.\n\t * if logfile is given, the stderr of the mount cmd will be appended to\n\t * this file\n\t *\n\t * The return value is true or false, depending of the success\n\t *\n\t * @example Execute (.target.smbmount, [\"//windows/crap\", \"/crap\"], \"-o guest\")\n\t * @example Execute (.target.smbmount, [\"//smb/share\", \"/smbshare\", \"/var/log/y2mountlog\"])\n\t */\n\n\tif (value.isNull() || !value->isList())\n\t{\n\t    return YCPError (\"Bad share argument to Execute (.smbmount, [ string share, string mountpoint <, string y2mountlog> ])\");\n\t}\n\n\tYCPList mountlist = value->asList();\n\tif (mountlist->size() < 2\n\t    || !mountlist->value(0)->isString()\n\t    || !mountlist->value(1)->isString())\n\t{\n\t    return YCPError (\"Bad list values in argument to Execute (.smbmount, [ string share, string mountpoint ])\");\n\t}\n\n\tstring mountcmd = \"/usr/bin/smbmount \";\n\n\tif (!arg.isNull() && arg->isString())\n\t{\n\t    mountcmd += arg->asString()->value() + \" \";\n\t}\n\telse\n\t{\n\t    return YCPError (\"Bad mode argument to Execute (.smbmount, string path, integer mode)\");\n\t}\n\n\t// share\n\tmountcmd += mountlist->value(0)->asString()->value() + \" \";\n\n\t// mountpoint\n\tmountcmd += mountlist->value(1)->asString()->value();\n\n\t// logfile\n\tif (mountlist->size() == 3)\n\t{\n\t    if (mountlist->value(2)->isString())\n\t    {\n\t\tmountcmd += \" 2> \" + mountlist->value(2)->asString()->value();\n\t    }\n\t    else\n\t    {\n\t\treturn YCPError (\"Bad logfile argument to Execute (.smbmount, [ string device, string mountpoint, string logfile ])\");\n\t    }\n\t}\n\n\treturn YCPBoolean (shellcommand (mountcmd) == 0);\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    else if (cmd == \"umount\")\n    {\n\t/**\n\t * @builtin Execute (.target.umount, string mountpoint) -> boolean\n\t * Unmounts a (block) device at a mountpoint.\n\t *\n\t * The return value is true or false, depending of the success.\n\t *\n\t * @example Execute (.target.umount, \"/floppy\")\n\t */\n\tif (value.isNull() || !value->isString())\n\t{\n\t    return YCPError (\"Bad mountpoint in Execute (.umount, string mountpoint)\");\n\t}\n\n\tstring umountcmd = \"/bin/umount \" + value->asString()->value();\n\n\treturn YCPBoolean (shellcommand (umountcmd) == 0);\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    else if (cmd == \"remove\")\n    {\n\t/**\n\t * @builtin Execute (.target.remove, string file) -> boolean\n\t * Remove a file.\n\t *\n\t * The return value is true or false depending on the success.\n\t *\n\t * @example Execute (.target.remove, \"/tmp/xyz\")\n\t */\n\tif (value.isNull() || !value->isString())\n\t{\n\t    return YCPError (\"Bad file in Execute (.remove, string file)\");\n\t}\n\n\tint ret = unlink (value->asString ()->value_cstr ());\n\n\treturn YCPBoolean (ret == 0);\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    else if (cmd == \"insmod\")\n    {\n\t/**\n\t * @builtin Execute (.target.insmod, string module, string options) -> boolean\n\t * Load module in target system.\n\t *\n\t * The return value is true or false, depending of the success.\n\t *\n\t * @example Execute (.target.insmod, \"a_module\", \"an option\")\n\t */\n\n\tif (value.isNull() || !value->isString())\n\t{\n\t    return YCPError (\"Bad source in Execute (.insmod, string module, string options)\");\n\t}\n\n\tstring insmodcmd = \"/sbin/insmod \" + value->asString()->value();\n\n\tif (!arg.isNull() && arg->isString())\n\t{\n\t    insmodcmd += string (\" \") + arg->asString()->value();\n\t}\n\n\treturn YCPBoolean (shellcommand (insmodcmd) == 0);\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    else if (cmd == \"modprobe\")\n    {\n\t/**\n\t * @builtin Execute (.target.modprobe, string module, string options) -> boolean\n\t * Load module in target system.\n\t *\n\t * The return value is true or false, depending of the success.\n\t *\n\t * @example Execute (.target.modprobe, \"a_module\", \"an option\")\n\t */\n\n\tif (value.isNull() || !value->isString())\n\t{\n\t    return YCPError (\"Bad source in Execute (.modprobe, string module, string options)\", YCPBoolean (false));\n\t}\n\n\tstring modprobecmd = \"/sbin/modprobe \" + value->asString()->value();\n\n\tif (!arg.isNull() && arg->isString())\n\t{\n\t    modprobecmd += string (\" \") + arg->asString()->value();\n\t}\n\n\treturn YCPBoolean (shellcommand (modprobecmd) == 0);\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    else if (cmd == \"kill\") {\n\n\t/**\n\t * @builtin Execute(.target.kill, integer pid [, integer signal]) -> boolean\n\t * Kill process with signal (SIGTERM if not specified).\n\t *\n\t * The return value is true or false, depending of the success.\n\t *\n\t * @example Execute (.target.kill, 1, 9)\n\t */\n\n\tif (value.isNull() || !value->isInteger())\n\t    return YCPError(\"Bad PID in Execute (.kill, integer pid, integer signal)\", YCPBoolean(false));\n\n\tint signal = 15;\n\tint pid = value->asInteger()->value();\n\n\tif (!arg.isNull() && arg->isInteger())\n\t    signal = arg->asInteger()->value();\n\n\treturn YCPBoolean (kill(pid,signal) != -1);\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    else if (cmd == \"control\")\n    {\n\n\tif (path->length()<2)\n\t    return YCPError(string(\"Undefined subpath for Execute (.control.\"));\n\n\tif (path->component_str(1) == \"printer_reset\")\n\t{\n\n\t    /**\n\t     * @builtin Execute (.target.control.printer_reset, string device) -> boolean\n\t     * Reset the given printer (trigger ioctl)\n\t     *\n\t     * The return value is true or false, depending of the success\n\t     *\n\t     */\n\n\t    if (value.isNull() || !value->isString())\n\t    {\n\t\treturn YCPError (\"Bad filename in Execute (.control.printer_reset, string device\");\n\t    }\n\n\t    string device = value->asString()->value();\n\n\t    int fd = open(device.c_str(), O_RDWR);\n\t    if (fd < 0)\n\t    {\n\t\treturn YCPError (string(\"Open failed: \\\"\" + device + \"\\\" \" + string(strerror(errno)?:\"\")));\n\t    }\n\n\t    int ret = ioctl(fd, LPRESET, NULL);\n\t    close(fd);\n\n\t    return YCPBoolean (ret == 0);\n\t}\n\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    return YCPError (string(\"Undefined subpath for Execute (\") + path->toString() + \")\");\n}",
    "includes": [
      "#include \"ShellCommand.h\"",
      "#include \"SystemAgent.h\"",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/pathsearch.h>",
      "#include <YCP.h>",
      "#include <stdexcept>",
      "#include <sstream>",
      "#include <string>",
      "#include <linux/lp.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <resolv.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CPError",
          "args": [
            "tring(\"Undefined subpath for Execute (\") + path->toString() + \")\")"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ath->toString",
          "args": [],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YCPPathRep::Component",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "278-311",
          "snippet": "string\nYCPPathRep::Component::toString() const\n{\n    if (!complex)\n\treturn component.asString();\n    string s = \"\\\"\";\n    for (const char*c = component->c_str();*c;c++)\n    {\n\tswitch (*c)\n\t{\n\t    case '\"': s+= \"\\\\\\\"\"; break;\n\t    case '\\\\':    s+= \"\\\\\\\\\";  break;\n\t    case '\\n':    s+= \"\\\\n\";   break;\n\t    case '\\t':    s+= \"\\\\t\";   break;\n\t    case '\\r':    s+= \"\\\\r\";   break;\n\t    case '\\b':    s+= \"\\\\b\";   break;\n\t    case '\\f':    s+= \"\\\\f\";   break;\n\t    default:\n\t    {\n\t\tif (isprint (*c))\n\t\t    s+= *c;\n\t\telse\n\t\t{\n\t\t    char buf[5];\n\t\t    snprintf (buf, 4, \"%02X\", *(unsigned char*)c);\n\t\t    s += \"\\\\x\";\n\t\t    s += buf;\n\t\t}\n\t    }\n\t}\n    }\n    s+= '\"';\n    return s;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  Component {\n    string\n    YCPPathRep::Component::toString() const\n    {\n        if (!complex)\n    \treturn component.asString();\n        string s = \"\\\"\";\n        for (const char*c = component->c_str();*c;c++)\n        {\n    \tswitch (*c)\n    \t{\n    \t    case '\"': s+= \"\\\\\\\"\"; break;\n    \t    case '\\\\':    s+= \"\\\\\\\\\";  break;\n    \t    case '\\n':    s+= \"\\\\n\";   break;\n    \t    case '\\t':    s+= \"\\\\t\";   break;\n    \t    case '\\r':    s+= \"\\\\r\";   break;\n    \t    case '\\b':    s+= \"\\\\b\";   break;\n    \t    case '\\f':    s+= \"\\\\f\";   break;\n    \t    default:\n    \t    {\n    \t\tif (isprint (*c))\n    \t\t    s+= *c;\n    \t\telse\n    \t\t{\n    \t\t    char buf[5];\n    \t\t    snprintf (buf, 4, \"%02X\", *(unsigned char*)c);\n    \t\t    s += \"\\\\x\";\n    \t\t    s += buf;\n    \t\t}\n    \t    }\n    \t}\n        }\n        s+= '\"';\n        return s;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tring(",
          "args": [
            "Undefined subpath for Execute (\")"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPBoolean",
          "args": [
            "et == 0)"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lose(",
          "args": [
            "d)"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "octl(",
          "args": [
            "d,",
            "PRESET,",
            "ULL)"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPError",
          "args": [
            "tring(\"Open failed: \\\"\" + device + \"\\\" \" + string(strerror(errno)?:\"\")))"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring(",
          "args": [
            "Open failed: \\\"\" + device + \"\\\" \" + string(strerror(errno)?:\"\"))"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring(",
          "args": [
            "trerror(errno)?:\"\")"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trerror(",
          "args": [
            "rrno)"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pen(",
          "args": [
            "evice.c_str(),",
            "_RDWR)"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evice.c_str",
          "args": [],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue->asString",
          "args": [],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPError",
          "args": [
            "Bad filename in Execute (.control.printer_reset, string device\")"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue->isString",
          "args": [],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "alue.isNull",
          "args": [],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ath->component_str",
          "args": [
            ")"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "component_str",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "161-165",
          "snippet": "string\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  string\n  YCPPathRep::component_str(long index) const\n  {\n      return components[index].component.asString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPError(",
          "args": [
            "tring(\"Undefined subpath for Execute (.control.\"))"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring(",
          "args": [
            "Undefined subpath for Execute (.control.\")"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ath->length",
          "args": [],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ill(",
          "args": [
            "id,",
            "ignal)"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg->asInteger",
          "args": [],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "asInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "106-116",
          "snippet": "YCPInteger\nYCPValueRep::asInteger() const\n{\n    if (!isInteger())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPInteger\n  YCPValueRep::asInteger() const\n  {\n      if (!isInteger())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rg->isInteger",
          "args": [],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "63-63",
          "snippet": "bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rg.isNull",
          "args": [],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPError(",
          "args": [
            "Bad PID in Execute (.kill, integer pid, integer signal)\",",
            "CPBoolean(false))"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPBoolean(",
          "args": [
            "alse)"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue.isNull",
          "args": [],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hellcommand",
          "args": [
            "odprobecmd)"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "shellcommand_background",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/ShellCommand.cc",
          "lines": "193-221",
          "snippet": "int\nshellcommand_background (const string &command)\n{\n\n    if (!getenv (\"Y2DEBUGSHELL\") && !getenv (\"Y2DEBUGALL\"))\n    {\n\tsystem (string (command + \" >/dev/null 2>&1 &\").c_str ());\n\t// FIXME execl (\"/bin/sh\", \"-c\", command.c_str(), NULL);\n\treturn 0;\n    }\n\n    /* fork the child */\n    pid_t child = fork ();\n    if (child == -1)\n    {\n\ty2error(\"fork failed: %s\", strerror(errno));\n\treturn -1;\n    }\n\n    /* child process */\n    if (!child)\n    {\n\tshellcommand (command, \"\");\n\t_exit (0);\n    }\n\n    /* return success */\n    return 0;\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include \"ShellCommand.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include \"ShellCommand.h\"\n#include \"ycp/y2log.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string>\n#include <stdio.h>\n#include <errno.h>\n\nint\nshellcommand_background (const string &command)\n{\n\n    if (!getenv (\"Y2DEBUGSHELL\") && !getenv (\"Y2DEBUGALL\"))\n    {\n\tsystem (string (command + \" >/dev/null 2>&1 &\").c_str ());\n\t// FIXME execl (\"/bin/sh\", \"-c\", command.c_str(), NULL);\n\treturn 0;\n    }\n\n    /* fork the child */\n    pid_t child = fork ();\n    if (child == -1)\n    {\n\ty2error(\"fork failed: %s\", strerror(errno));\n\treturn -1;\n    }\n\n    /* child process */\n    if (!child)\n    {\n\tshellcommand (command, \"\");\n\t_exit (0);\n    }\n\n    /* return success */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tring",
          "args": [
            "\")"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rg.isNull",
          "args": [],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPError",
          "args": [
            "Bad source in Execute (.modprobe, string module, string options)\",",
            "CPBoolean (false))"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "YCPError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "317-321",
          "snippet": "YCPValue YCPError (string message, const YCPValue & ret)\n{\n    ycp2error (\"%s\", message.c_str ());\n    return ret;\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValue YCPError (string message, const YCPValue & ret)\n{\n    ycp2error (\"%s\", message.c_str ());\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alue.isNull",
          "args": [],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg.isNull",
          "args": [],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPError",
          "args": [
            "Bad source in Execute (.insmod, string module, string options)\")"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue.isNull",
          "args": [],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlink",
          "args": [
            "alue->asString ()->value_cstr ())"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "unlink",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "541-548",
          "snippet": "int PathInfo::unlink( const Pathname & path )\n{\n  DBG << \"unlink \" << path;\n  if ( ::unlink( path.asString().c_str() ) == -1 ) {\n    return _Log_Result( errno );\n  }\n  return _Log_Result( 0 );\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::unlink( const Pathname & path )\n  {\n    DBG << \"unlink \" << path;\n    if ( ::unlink( path.asString().c_str() ) == -1 ) {\n      return _Log_Result( errno );\n    }\n    return _Log_Result( 0 );\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPError",
          "args": [
            "Bad file in Execute (.remove, string file)\")"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue.isNull",
          "args": [],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPError",
          "args": [
            "Bad mountpoint in Execute (.umount, string mountpoint)\")"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue.isNull",
          "args": [],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPError",
          "args": [
            "Bad logfile argument to Execute (.smbmount, [ string device, string mountpoint, string logfile ])\")"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ountlist->value",
          "args": [],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ountlist->value",
          "args": [
            ")"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ountlist->size",
          "args": [],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPError",
          "args": [
            "Bad mode argument to Execute (.smbmount, string path, integer mode)\")"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg.isNull",
          "args": [],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPError",
          "args": [
            "Bad list values in argument to Execute (.smbmount, [ string share, string mountpoint ])\")"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue->asList",
          "args": [],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPError",
          "args": [
            "Bad share argument to Execute (.smbmount, [ string share, string mountpoint <, string y2mountlog> ])\")"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue->isList",
          "args": [],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "alue.isNull",
          "args": [],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg.isNull",
          "args": [],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPError",
          "args": [
            "Bad list values in argument to Execute (.mount, [ string device, string mountpoint ])\")"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPError",
          "args": [
            "Bad path argument to Execute (.mount, [ string device, string mountpoint <, string y2mountlog> ])\")"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue.isNull",
          "args": [],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPBoolean(",
          "args": [
            "tat(path.c_str(), &sb) == 0 && S_ISDIR(sb.st_mode))"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ISDIR(",
          "args": [
            "b.st_mode)"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tat(",
          "args": [
            "ath.c_str(),",
            "sb)"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ath.c_str",
          "args": [],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdir",
          "args": [
            "ath.substr(0, pos).c_str(),",
            "ode)"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "288-295",
          "snippet": "int PathInfo::mkdir( const Pathname & path, unsigned mode )\n{\n  DBG << \"mkdir \" << path << ' ' << stringutil::octstring( mode );\n  if ( ::mkdir( path.asString().c_str(), mode ) == -1 ) {\n    return _Log_Result( errno );\n  }\n  return _Log_Result( 0 );\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::mkdir( const Pathname & path, unsigned mode )\n  {\n    DBG << \"mkdir \" << path << ' ' << stringutil::octstring( mode );\n    if ( ::mkdir( path.asString().c_str(), mode ) == -1 ) {\n      return _Log_Result( errno );\n    }\n    return _Log_Result( 0 );\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ath.substr",
          "args": [],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ath.substr",
          "args": [
            ",",
            "os)"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ath.substr",
          "args": [],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ath.substr",
          "args": [
            ",",
            "os)"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ath.find",
          "args": [
            "/',",
            "os + 1)"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "YCPPathSearch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/pathsearch.cc",
          "lines": "287-321",
          "snippet": "string\nYCPPathSearch::find (Kind kind, const string& name)\n{\n    if (name[0] == '.'\n\t&& name[1] == '/')\n    {\n\tif (access (name.c_str(), R_OK) == 0)\n\t{\n\t    return name;\n\t}\n\treturn \"\";\n    }\n\n    initialize ();\n\n    std::list<string>& kindList = searchList[kind];\n    std::list<string>::iterator i = kindList.begin (), e = kindList.end ();\n    while (i != e)\n    {\n\tstring pathname = completeFilename (*i + '/' + name);\n\ty2debug (\"trying %s\", pathname.c_str ());\n\tif (access (pathname.c_str(), R_OK) == 0)\n\t{\n\t    y2debug (\"... success\");\n\t    // FIXME: this check is different for clients and for modules - see findy2\n\t    if( searchPrefixWarn && *i != kindList.back () ) {\n\t\ty2warning( \"Using special search prefix '%s' for '%s'\", i->c_str(), pathname.c_str() );\n\t    }\n\t    return pathname;\n\t}\n\n\t++i;\n    }\n    return \"\";\n}",
          "includes": [
            "#include \"pathsearch.h\"",
            "#include <ycp/y2log.h>",
            "#include <boost/algorithm/string.hpp>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool Y2PathSearch::searchPrefixWarn = true;",
            "std::list<string> YCPPathSearch::searchList[YCPPathSearch::num_Kind];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pathsearch.h\"\n#include <ycp/y2log.h>\n#include <boost/algorithm/string.hpp>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n\nbool Y2PathSearch::searchPrefixWarn = true;\nstd::list<string> YCPPathSearch::searchList[YCPPathSearch::num_Kind];\n\nYCPPathSearch {\n  string\n  YCPPathSearch::find (Kind kind, const string& name)\n  {\n      if (name[0] == '.'\n  \t&& name[1] == '/')\n      {\n  \tif (access (name.c_str(), R_OK) == 0)\n  \t{\n  \t    return name;\n  \t}\n  \treturn \"\";\n      }\n  \n      initialize ();\n  \n      std::list<string>& kindList = searchList[kind];\n      std::list<string>::iterator i = kindList.begin (), e = kindList.end ();\n      while (i != e)\n      {\n  \tstring pathname = completeFilename (*i + '/' + name);\n  \ty2debug (\"trying %s\", pathname.c_str ());\n  \tif (access (pathname.c_str(), R_OK) == 0)\n  \t{\n  \t    y2debug (\"... success\");\n  \t    // FIXME: this check is different for clients and for modules - see findy2\n  \t    if( searchPrefixWarn && *i != kindList.back () ) {\n  \t\ty2warning( \"Using special search prefix '%s' for '%s'\", i->c_str(), pathname.c_str() );\n  \t    }\n  \t    return pathname;\n  \t}\n  \n  \t++i;\n      }\n      return \"\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "2milestone",
          "args": [
            "mkdir %s\",",
            "ath.c_str())"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ath.c_str",
          "args": [],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPError",
          "args": [
            "Bad mode argument to Execute (.mkdir, string path, integer mode)\")"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg.isNull",
          "args": [],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPError",
          "args": [
            "Bad path argument to Execute (.mkdir, string path)\")"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue.isNull",
          "args": [],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ymlink",
          "args": [
            "ldpath,",
            "ewpath.c_str())"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "symlink",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "612-619",
          "snippet": "int PathInfo::symlink( const Pathname & oldpath, const Pathname & newpath )\n{\n  DBG << \"symlink \" << newpath << \" -> \" << oldpath;\n  if ( ::symlink( oldpath.asString().c_str(), newpath.asString().c_str() ) == -1 ) {\n    return _Log_Result( errno );\n  }\n  return _Log_Result( 0 );\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::symlink( const Pathname & oldpath, const Pathname & newpath )\n  {\n    DBG << \"symlink \" << newpath << \" -> \" << oldpath;\n    if ( ::symlink( oldpath.asString().c_str(), newpath.asString().c_str() ) == -1 ) {\n      return _Log_Result( errno );\n    }\n    return _Log_Result( 0 );\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ewpath.c_str",
          "args": [],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emove",
          "args": [
            "ewpath.c_str())"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "remove",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "104-113",
          "snippet": "void YCPMapRep::remove(const YCPValue& key)\n{\n    if (!key->isString() && !key->isInteger() && !key->isSymbol())\n    {\n        ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n        return;\n    }\n\n    stl_map.erase (key);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void YCPMapRep::remove(const YCPValue& key)\n  {\n      if (!key->isString() && !key->isInteger() && !key->isSymbol())\n      {\n          ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n          return;\n      }\n  \n      stl_map.erase (key);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ewpath.c_str",
          "args": [],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2milestone",
          "args": [
            "symlink %s -> %s\",",
            "ldpath,",
            "ewpath.c_str())"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewpath.c_str",
          "args": [],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPError",
          "args": [
            "Bad arguments to Execute (.symlink, string old, string new)\")"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg.isNull",
          "args": [],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue.isNull",
          "args": [],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPInteger",
          "args": [
            "WTERMSIG (ret) + 128"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "YCPInteger",
          "container": "YCPInteger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPInteger.cc",
          "lines": "142-145",
          "snippet": "YCPInteger::YCPInteger (bytecodeistream & str)\n    : YCPValue (new YCPIntegerRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/y2log.h\"\n\nYCPInteger {\n  YCPInteger::YCPInteger (bytecodeistream & str)\n      : YCPValue (new YCPIntegerRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "ret"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "ret"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "ret"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "p"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "input.c_str ()",
            "input.length ()",
            "1",
            "p"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.c_str",
          "args": [],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "\"popen failed\""
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "command.c_str ()",
            "\"w\""
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command.c_str",
          "args": [],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "\"Bad command argument to Execute (.bash_input, string \"\n\t\t\t     \"command, string stdin\""
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "\"Bad command argument to Execute (.bash_input, string \"\n\t\t\t     \"command, string stdin\""
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shellcommand_output",
          "args": [
            "exports + bashcommand",
            "tempdir"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "shellcommand_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
          "lines": "204-229",
          "snippet": "static YCPMap\nshellcommand_output (const string& script, const string& tempdir)\n{\n    int ret = shellcommand (script, tempdir);\n\n    string output_stdout;\n    int ret1 = read_file_to_string (string (tempdir + \"/stdout\").c_str (), output_stdout);\n    if (ret1 != 0)\n    {\n\ty2error (\"open for %s failed: %s/stdout\", tempdir.c_str (), strerror (ret1));\n    }\n\n    string output_stderr;\n    int ret2 = read_file_to_string (string (tempdir + \"/stderr\").c_str (), output_stderr);\n    if (ret2 != 0)\n    {\n\ty2error (\"open for %s failed: %s/stderr\", tempdir.c_str (), strerror (ret2));\n    }\n\n    YCPMap result;\n    result->add (YCPString (\"exit\"), YCPInteger (ret));\n    result->add (YCPString (\"stdout\"), YCPString (output_stdout));\n    result->add (YCPString (\"stderr\"), YCPString (output_stderr));\n\n    return result;\n}",
          "includes": [
            "#include \"ShellCommand.h\"",
            "#include \"SystemAgent.h\"",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/pathsearch.h>",
            "#include <YCP.h>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <string>",
            "#include <linux/lp.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <resolv.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic YCPMap\nshellcommand_output (const string& script, const string& tempdir)\n{\n    int ret = shellcommand (script, tempdir);\n\n    string output_stdout;\n    int ret1 = read_file_to_string (string (tempdir + \"/stdout\").c_str (), output_stdout);\n    if (ret1 != 0)\n    {\n\ty2error (\"open for %s failed: %s/stdout\", tempdir.c_str (), strerror (ret1));\n    }\n\n    string output_stderr;\n    int ret2 = read_file_to_string (string (tempdir + \"/stderr\").c_str (), output_stderr);\n    if (ret2 != 0)\n    {\n\ty2error (\"open for %s failed: %s/stderr\", tempdir.c_str (), strerror (ret2));\n    }\n\n    YCPMap result;\n    result->add (YCPString (\"exit\"), YCPInteger (ret));\n    result->add (YCPString (\"stdout\"), YCPString (output_stdout));\n    result->add (YCPString (\"stderr\"), YCPString (output_stderr));\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "string(\"Invalid value '\")\n\t\t\t\t + key->toString()\n\t\t\t\t + \"' for target variable name, which must be a string\""
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"Invalid value '\""
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "variables->end",
          "args": [],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "variables->begin",
          "args": [],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "environment->asMap",
          "args": [],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "environment->isMap",
          "args": [],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "71-71",
          "snippet": "bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2warning",
          "args": [
            "\"\"",
            "0",
            "\"Execute (.bash, ...) without full path !\""
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "\"Bad command argument to Execute (.bash, string command [, map env])\""
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "string(\"Execute (\")+path->toString()+\") without argument.\""
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "\"Execute () called without sub-path\""
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->isRoot",
          "args": [],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "isRoot",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "83-87",
          "snippet": "bool\nYCPPathRep::isRoot() const\n{\n    return components.empty();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  bool\n  YCPPathRep::isRoot() const\n  {\n      return components.empty();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Execute (%s)\"",
            "path->toString().c_str()"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nSystemAgent {\n  YCPValue\n  SystemAgent::Execute (const YCPPath& path, const YCPValue& value,\n  \t\t      const YCPValue& arg)\n  {\n      y2debug (\"Execute (%s)\", path->toString().c_str());\n  \n      if (path->isRoot ())\n      {\n  \treturn YCPError (\"Execute () called without sub-path\");\n      }\n  \n      if (value.isNull ())\n      {\n  \treturn YCPError (string(\"Execute (\")+path->toString()+\") without argument.\");\n      }\n  \n      const string cmd = path->component_str (0); // just a shortcut\n  \n      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n      // .bash*\n  \n      if (cmd == \"bash\"\n  \t|| cmd == \"bash_output\"\n  \t|| cmd == \"bash_background\")\n      {\n  \n  \tYCPValue environment = YCPVoid();\n  \n  \tif (!arg.isNull())\n  \t    environment = arg;\n  \n  \t/**\n  \t * @builtin Execute (.target.bash, string command, map environment) -> integer\n  \t * @builtin Execute (.target.bash_background, string command, map environment) -> integer\n  \t * @builtin Execute (.target.bash_output, string command, map environment) -> map\n  \t *\n  \t * Runs a bash command. The command is stated as string.\n  \t * The map variables can be used to give initial environment\n  \t * definitions to the target. The keys have to be strings,\n  \t * the values can be of any type. If you use string values,\n  \t * the strings may _not_ contain single quotes. Escape them\n  \t * with double backqoute, if you need them. This is subject\n  \t * to change.\n  \t *\n  \t * The return value will be either an integer with the exitcode of\n  \t * the shell script or a map:<pre>\n  \t * $[\n  \t * <dd> \"exit\" : &lt;integer&gt;,  //exitcode from shell script\n  \t * <dd> \"stdout\" : &lt;string&gt;, //stdout of the command\n  \t * <dd> \"stderr\" : &lt;string&gt;  //stderr of the command\n  \t * ]</pre>\n  \t *\n  \t * @example Execute (.target.bash, \"/bin/touch $FILE ; exit 5\", $[\"FILE\":\"/somedir/somefile\"]) -> 5\n  \t * @example Execute (.target.bash_output, \"/bin/touch $FILE ; exit 5\", $[\"FILE\":\"/somedir/somefile\"]) -> $[ \"exit\" : 5, \"stdout\" : \"\", \"stderr\" : \"\"]\n  \t *\n  \t */\n  \n  \tif (value.isNull() || !value->isString())\n  \t{\n  \t    return YCPError (\"Bad command argument to Execute (.bash, string command [, map env])\");\n  \t}\n  \n  \t/* shell command must have rooted path */\n  \tstring bashcommand = value->asString()->value();\n  #if 0\n  \tif (bashcommand[0] != '/')\n  \t{\n  \t    ycp2warning (\"\", 0, \"Execute (.bash, ...) without full path !\");\n  \t}\n  #endif\n  \n  \t/* check for and construct shell enviroment */\n  \tYCPMap variables;\n  \tif (environment->isMap())\n  \t{\n  \t    variables = environment->asMap();\n  \t}\n  \n  \tstring exports = \"\";\n  \tfor (YCPMap::const_iterator pos = variables->begin(); pos != variables->end(); ++pos)\n  \t{\n  \t    const YCPValue& key = pos->first;\n  \t    const YCPValue& value = pos->second;\n  \n  \t    if (!key->isString())\n  \t    {\n  \t\treturn YCPError (string(\"Invalid value '\")\n  \t\t\t\t + key->toString()\n  \t\t\t\t + \"' for target variable name, which must be a string\");\n  \t    }\n  \n  \t    exports += \"export \" + key->asString()->value() + \"='\";\n  \t    string valstr;\n  \t    if (value->isString())\n  \t    {\n  \t\tvalstr = value->asString()->value();\n  \t    }\n  \t    else\n  \t    {\n  \t\tvalstr = value->toString();\n  \t    }\n  \t    exports += valstr + \"'\\n\";\n  \t}\n  \n  \t/* execute script and return YCP{Integer|Map} */\n  \tif (cmd == \"bash\")\n  \t{\n  \t    return YCPInteger (shellcommand (exports + bashcommand));\n  \t}\n  \telse if (cmd == \"bash_output\")\n  \t{\n  \t    return shellcommand_output (exports + bashcommand, tempdir);\n  \t}\n  \telse if (cmd == \"bash_background\")\n  \t{\n  \t    return YCPInteger (shellcommand_background (exports + bashcommand));\n  \t}\n      } // .bash*\n  \n      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  \n      else if (cmd == \"bash_input\")\n      {\n  \t/**\n  \t * @builtin Execute (.target.bash_input, string command, string input) -> integer\n  \t *\n  \t * Note: Function has only one used within YaST2 and is subject to\n  \t * sudden change or removal.\n  \t */\n  \n  \tif (value.isNull() || !value->isString())\n  \t{\n  \t    return YCPError (\"Bad command argument to Execute (.bash_input, string \"\n  \t\t\t     \"command, string stdin\");\n  \t}\n  \n  \tif (arg.isNull() || !arg->isString())\n  \t{\n  \t    return YCPError (\"Bad command argument to Execute (.bash_input, string \"\n  \t\t\t     \"command, string stdin\");\n  \t}\n  \n  \tstring command = value->asString ()->value ();\n  \tcommand += \">/dev/null 2>&1\";\n  \n  \tstring input = arg->asString ()->value ();\n  \tinput += \"\\n\";\n  \n  \tFILE* p = popen (command.c_str (), \"w\");\n  \tif (!p)\n  \t{\n  \t    return YCPError (\"popen failed\");\n  \t}\n  \n  \tfwrite (input.c_str (), input.length (), 1, p);\n  \tint ret = pclose (p);\n  \n  \tif (WIFEXITED (ret))\n  \t    return YCPInteger (WEXITSTATUS (ret));\n  \treturn YCPInteger (WTERMSIG (ret) + 128);\n      }\n  \n      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  \n      else if (cmd == \"symlink\")\n      {\n  \t/**\n  \t * @builtin Execute (.target.symlink, string oldpath, string newpath) -> boolean\n  \t *\n  \t * Creates a symbolic link named newpath which contains the\n  \t * string oldpath.\n  \t *\n  \t * Symbolic links are interpreted at run-time as if the  con\n  \t * tents of the link had been substituted into the path being\n  \t * followed to find a file or directory.\n  \t *\n  \t * The return value is true or false, depending of the success.\n  \t *\n  \t * @example Execute (.target.symlink, \"/lib/YaST2\", \"Y2\")\n  \t */\n  \n  \tif (value.isNull () || arg.isNull () || !value->isString () ||\n  \t    !arg->isString ())\n  \t{\n  \t    return YCPError (\"Bad arguments to Execute (.symlink, string old, string new)\");\n  \t}\n  \tconst char *oldpath = value->asString()->value_cstr();\n  \tconst string newpath = arg->asString()->value();\n  \n  \ty2milestone (\"symlink %s -> %s\", oldpath, newpath.c_str());\n  \n  \tremove (newpath.c_str());\n  \treturn YCPBoolean (symlink (oldpath, newpath.c_str()) == 0);\n  \n      } // .symlink\n  \n      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  \n      else if (cmd == \"mkdir\")\n      {\n  \t/**\n  \t * @builtin Execute (.target.mkdir, string path <, integer mode>)) -> boolean\n  \t *\n  \t * Creates a directory and all its parents, if necessary.\n  \t * All created elements will have mode 0755 if mode is omitted.\n  \t *\n  \t * The return value is true or false, depending of the success, ie if\n  \t * the directory exists afterwards.\n  \t *\n  \t * @example Execute (.target.mkdir, \"/var/adm/mount\")\n  \t */\n  \n  \tif (value.isNull() || !value->isString())\n  \t{\n  \t    return YCPError (\"Bad path argument to Execute (.mkdir, string path)\");\n  \t}\n  \n  \tstring path = value->asString()->value();\n  \n  \tint mode = 0755;\n  \n  \tif (!arg.isNull())\n  \t{\n  \t    if (arg->isInteger())\n  \t    {\n  \t\tmode = arg->asInteger()->value();\n  \t    }\n  \t    else\n  \t    {\n  \t\treturn YCPError (\"Bad mode argument to Execute (.mkdir, string path, integer mode)\");\n  \t    }\n  \t}\n  \n  \tsize_t pos = 0;\n  \n  \ty2milestone (\"mkdir %s\", path.c_str());\n  \n  \t// Create leading components\n  \twhile (pos = path.find('/', pos + 1), pos != string::npos)\n  \t{\n  \t    mkdir (path.substr(0, pos).c_str(), mode);\n  \t}\n  \t// Create the last part\n  \tmkdir (path.substr(0, pos).c_str(), mode);\n  \n  \tstruct stat sb;\n  \treturn YCPBoolean(stat(path.c_str(), &sb) == 0 && S_ISDIR(sb.st_mode));\n      }\n  \n      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  \n      else if (cmd == \"mount\")\n      {\n  \t/**\n  \t * @builtin Execute (.target.mount, [ string device, string mountpoint <, string logfile>], [, string options])) -> boolean\n  \t *\n  \t * Mounts a (block) device at a mountpoint.\n  \t * If logfile is given, the stderr of the mount cmd will be appended to\n  \t * this file\n  \t *\n  \t * The return value is true or false, depending of the success\n  \t *\n  \t * @example Execute (.target.mount, [\"/dev/fd0\", \"/floppy\"], \"-t msdos\")\n  \t * @example Execute (.target.mount, [\"/dev/fd0\", \"/floppy\", \"/var/log/y2mountlog\"], \"-t msdos\")\n  \t */\n  \n  \tif (value.isNull() || !value->isList())\n  \t{\n  \t    return YCPError (\"Bad path argument to Execute (.mount, [ string device, string mountpoint <, string y2mountlog> ])\");\n  \t}\n  \n  \tYCPList mountlist = value->asList();\n  \tif (mountlist->size() < 2\n  \t    || !mountlist->value(0)->isString()\n  \t    || !mountlist->value(1)->isString())\n  \t{\n  \t    return YCPError (\"Bad list values in argument to Execute (.mount, [ string device, string mountpoint ])\");\n  \t}\n  \n  \tstring mountcmd = \"/bin/mount \";\n  \n  \t// arg is mount options, this is optional\n  \n  \tif (!arg.isNull())\n  \t{\n  \t    if (arg->isString())\n  \t    {\n  \t\tmountcmd += arg->asString()->value() + \" \";\n  \t    }\n  \t    else\n  \t    {\n  \t\treturn YCPError (\"Bad type of mode argument to Execute (.mount, string|list path, string mode)\", YCPBoolean (false));\n  \t    }\n  \t}\n  \n  \t// device\n  \tmountcmd += mountlist->value(0)->asString()->value() + \" \";\n  \t// mountpoint\n  \tmountcmd += mountlist->value(1)->asString()->value();\n  \n  \tif (mountlist->size() == 3)\n  \t{\n  \t    if (mountlist->value(2)->isString())\n  \t    {\n  \t\tmountcmd += \" 2> \" + mountlist->value(2)->asString()->value();\n  \t    }\n  \t    else\n  \t    {\n  \t\treturn YCPError (\"Bad logfile argument to Execute (.mount, [ string device, string mountpoint, string logfile ])\", YCPBoolean (false));\n  \t    }\n  \t}\n  \n  \treturn YCPBoolean (shellcommand (mountcmd) == 0);\n      }\n  \n      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  \n      else if (cmd == \"smbmount\")\n      {\n  \t/**\n  \t * @builtin Execute (.target.smbmount, [ string server_and_dir, string mountpoint <, string logfile>], [, string options])) -> boolean\n  \t *\n  \t * Mounts a SMB share at a mountpoint.\n  \t * if logfile is given, the stderr of the mount cmd will be appended to\n  \t * this file\n  \t *\n  \t * The return value is true or false, depending of the success\n  \t *\n  \t * @example Execute (.target.smbmount, [\"//windows/crap\", \"/crap\"], \"-o guest\")\n  \t * @example Execute (.target.smbmount, [\"//smb/share\", \"/smbshare\", \"/var/log/y2mountlog\"])\n  \t */\n  \n  \tif (value.isNull() || !value->isList())\n  \t{\n  \t    return YCPError (\"Bad share argument to Execute (.smbmount, [ string share, string mountpoint <, string y2mountlog> ])\");\n  \t}\n  \n  \tYCPList mountlist = value->asList();\n  \tif (mountlist->size() < 2\n  \t    || !mountlist->value(0)->isString()\n  \t    || !mountlist->value(1)->isString())\n  \t{\n  \t    return YCPError (\"Bad list values in argument to Execute (.smbmount, [ string share, string mountpoint ])\");\n  \t}\n  \n  \tstring mountcmd = \"/usr/bin/smbmount \";\n  \n  \tif (!arg.isNull() && arg->isString())\n  \t{\n  \t    mountcmd += arg->asString()->value() + \" \";\n  \t}\n  \telse\n  \t{\n  \t    return YCPError (\"Bad mode argument to Execute (.smbmount, string path, integer mode)\");\n  \t}\n  \n  \t// share\n  \tmountcmd += mountlist->value(0)->asString()->value() + \" \";\n  \n  \t// mountpoint\n  \tmountcmd += mountlist->value(1)->asString()->value();\n  \n  \t// logfile\n  \tif (mountlist->size() == 3)\n  \t{\n  \t    if (mountlist->value(2)->isString())\n  \t    {\n  \t\tmountcmd += \" 2> \" + mountlist->value(2)->asString()->value();\n  \t    }\n  \t    else\n  \t    {\n  \t\treturn YCPError (\"Bad logfile argument to Execute (.smbmount, [ string device, string mountpoint, string logfile ])\");\n  \t    }\n  \t}\n  \n  \treturn YCPBoolean (shellcommand (mountcmd) == 0);\n      }\n  \n      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  \n      else if (cmd == \"umount\")\n      {\n  \t/**\n  \t * @builtin Execute (.target.umount, string mountpoint) -> boolean\n  \t * Unmounts a (block) device at a mountpoint.\n  \t *\n  \t * The return value is true or false, depending of the success.\n  \t *\n  \t * @example Execute (.target.umount, \"/floppy\")\n  \t */\n  \tif (value.isNull() || !value->isString())\n  \t{\n  \t    return YCPError (\"Bad mountpoint in Execute (.umount, string mountpoint)\");\n  \t}\n  \n  \tstring umountcmd = \"/bin/umount \" + value->asString()->value();\n  \n  \treturn YCPBoolean (shellcommand (umountcmd) == 0);\n      }\n  \n      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  \n      else if (cmd == \"remove\")\n      {\n  \t/**\n  \t * @builtin Execute (.target.remove, string file) -> boolean\n  \t * Remove a file.\n  \t *\n  \t * The return value is true or false depending on the success.\n  \t *\n  \t * @example Execute (.target.remove, \"/tmp/xyz\")\n  \t */\n  \tif (value.isNull() || !value->isString())\n  \t{\n  \t    return YCPError (\"Bad file in Execute (.remove, string file)\");\n  \t}\n  \n  \tint ret = unlink (value->asString ()->value_cstr ());\n  \n  \treturn YCPBoolean (ret == 0);\n      }\n  \n      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  \n      else if (cmd == \"insmod\")\n      {\n  \t/**\n  \t * @builtin Execute (.target.insmod, string module, string options) -> boolean\n  \t * Load module in target system.\n  \t *\n  \t * The return value is true or false, depending of the success.\n  \t *\n  \t * @example Execute (.target.insmod, \"a_module\", \"an option\")\n  \t */\n  \n  \tif (value.isNull() || !value->isString())\n  \t{\n  \t    return YCPError (\"Bad source in Execute (.insmod, string module, string options)\");\n  \t}\n  \n  \tstring insmodcmd = \"/sbin/insmod \" + value->asString()->value();\n  \n  \tif (!arg.isNull() && arg->isString())\n  \t{\n  \t    insmodcmd += string (\" \") + arg->asString()->value();\n  \t}\n  \n  \treturn YCPBoolean (shellcommand (insmodcmd) == 0);\n      }\n  \n      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  \n      else if (cmd == \"modprobe\")\n      {\n  \t/**\n  \t * @builtin Execute (.target.modprobe, string module, string options) -> boolean\n  \t * Load module in target system.\n  \t *\n  \t * The return value is true or false, depending of the success.\n  \t *\n  \t * @example Execute (.target.modprobe, \"a_module\", \"an option\")\n  \t */\n  \n  \tif (value.isNull() || !value->isString())\n  \t{\n  \t    return YCPError (\"Bad source in Execute (.modprobe, string module, string options)\", YCPBoolean (false));\n  \t}\n  \n  \tstring modprobecmd = \"/sbin/modprobe \" + value->asString()->value();\n  \n  \tif (!arg.isNull() && arg->isString())\n  \t{\n  \t    modprobecmd += string (\" \") + arg->asString()->value();\n  \t}\n  \n  \treturn YCPBoolean (shellcommand (modprobecmd) == 0);\n      }\n  \n      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  \n      else if (cmd == \"kill\") {\n  \n  \t/**\n  \t * @builtin Execute(.target.kill, integer pid [, integer signal]) -> boolean\n  \t * Kill process with signal (SIGTERM if not specified).\n  \t *\n  \t * The return value is true or false, depending of the success.\n  \t *\n  \t * @example Execute (.target.kill, 1, 9)\n  \t */\n  \n  \tif (value.isNull() || !value->isInteger())\n  \t    return YCPError(\"Bad PID in Execute (.kill, integer pid, integer signal)\", YCPBoolean(false));\n  \n  \tint signal = 15;\n  \tint pid = value->asInteger()->value();\n  \n  \tif (!arg.isNull() && arg->isInteger())\n  \t    signal = arg->asInteger()->value();\n  \n  \treturn YCPBoolean (kill(pid,signal) != -1);\n      }\n  \n      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  \n      else if (cmd == \"control\")\n      {\n  \n  \tif (path->length()<2)\n  \t    return YCPError(string(\"Undefined subpath for Execute (.control.\"));\n  \n  \tif (path->component_str(1) == \"printer_reset\")\n  \t{\n  \n  \t    /**\n  \t     * @builtin Execute (.target.control.printer_reset, string device) -> boolean\n  \t     * Reset the given printer (trigger ioctl)\n  \t     *\n  \t     * The return value is true or false, depending of the success\n  \t     *\n  \t     */\n  \n  \t    if (value.isNull() || !value->isString())\n  \t    {\n  \t\treturn YCPError (\"Bad filename in Execute (.control.printer_reset, string device\");\n  \t    }\n  \n  \t    string device = value->asString()->value();\n  \n  \t    int fd = open(device.c_str(), O_RDWR);\n  \t    if (fd < 0)\n  \t    {\n  \t\treturn YCPError (string(\"Open failed: \\\"\" + device + \"\\\" \" + string(strerror(errno)?:\"\")));\n  \t    }\n  \n  \t    int ret = ioctl(fd, LPRESET, NULL);\n  \t    close(fd);\n  \n  \t    return YCPBoolean (ret == 0);\n  \t}\n  \n      }\n  \n      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  \n      return YCPError (string(\"Undefined subpath for Execute (\") + path->toString() + \")\");\n  }\n}"
  },
  {
    "function_name": "Write",
    "container": "SystemAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
    "lines": "655-864",
    "snippet": "YCPBoolean\nSystemAgent::Write (const YCPPath& path, const YCPValue& value,\n\t\t    const YCPValue& arg)\n{\n    y2debug (\"Write (%s)\", path->toString().c_str());\n\n    if (path->isRoot())\n    {\n\tycp2error (\"Write () called without sub-path\");\n\treturn YCPBoolean (false);\n    }\n\n    const string cmd = path->component_str (0); // just a shortcut\n\n    if (cmd == \"passwd\")\n    {\n\t/**\n\t * @builtin Write (.target.passwd.&lt;name&gt;, string cryptval) -> bool\n\t * .passwd can be used to set or modify the encrypted password\n\t * of an already existing user in /etc/passwd and /etc/shadow.\n\t *\n\t * This call returns true on success and false, if it fails.\n\t *\n\t * @example Write (.target.passwd.root, crypt (a_passwd))\n\t */\n\n\tif (path->length() != 2)\n\t{\n\t    ycp2error (\"Bad path argument in call to Write (.passwd.name)\");\n\t    return YCPBoolean (false);\n\t}\n\n\tif (value.isNull() || !value->isString())\n\t{\n\t    ycp2error (\"Bad password argument in call to Write (.passwd)\");\n\t    return YCPBoolean (false);\n\t}\n\n\tstring passwd = value->asString()->value();\n\n\tstring bashcommand =\n\t    string (\"/bin/echo '\") +\n\t    path->component_str (1).c_str () + \":\" + passwd +\n\t    \"' |/usr/sbin/chpasswd -e >/dev/null 2>&1\";\n\n\t// Don't write the password into the log - even though it's crypted\n\t// y2debug(\"Executing: '%s'\", bashcommand.c_str());\n\n\tint exitcode = system(bashcommand.c_str());\n\n\treturn YCPBoolean (WIFEXITED (exitcode) && WEXITSTATUS (exitcode) == 0);\n    }\n\n    else if (cmd == \"string\")\n    {\n\t/**\n\t * @builtin Write (.target.string, string filename, string value) -> boolean\n\t * Writes the string <tt>value</tt> into a file. If the file already\n\t * exists, the existing file is overwritten. The return value is\n\t * true, if the file has been written successfully.\n\t */\n\n\tif (value.isNull() || !value->isString())\n\t{\n\t    ycp2error (\"Bad filename arg for Write (.string ...)\");\n\t    return YCPBoolean (false);\n\t}\n\n\tif (arg.isNull() || !arg->isString())\n\t{\n\t    ycp2error (\"Bad string value for Write (.string ...)\");\n\t    return YCPBoolean (false);\n\t}\n\n\tstring filename = value->asString()->value();\n\tint fd = open(filename.c_str(), O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\tif (fd >= 0)\n\t{\n\t    string cont = arg->asString()->value();\n\t    const char *buffer = cont.c_str();\n\t    size_t length = cont.length();\n\t    size_t written = write(fd, buffer, length);\n\t    close(fd);\n\t    return YCPBoolean (written == length);\n\t}\n\tycp2error (\"Write (.string, \\\"%s\\\") failed: %s\", filename.c_str (), strerror (errno));\n\treturn YCPBoolean(false);\n    }\n\n    else if (cmd == \"byte\")\n    {\n\t/**\n\t * @builtin Write (.target.byte, string filename, byteblock) -> boolean\n\t * Write a byteblock into a file.\n\t */\n\n\tif (value.isNull () || !value->isString ())\n\t{\n\t    ycp2error (\"Bad filename arg for Write (.byte, ...)\");\n\t    return YCPBoolean (false);\n\t}\n\n\tif (arg.isNull () || !arg->isByteblock ())\n\t{\n\t    ycp2error (\"Bad value for Write (.byte, filename, byteblock)\");\n\t    return YCPBoolean (false);\n\t}\n\n\tstring filename = value->asString ()->value ();\n\tYCPByteblock byteblock = arg->asByteblock ();\n\n\tint fd = open (filename.c_str (), O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\tif (fd >= 0)\n\t{\n\t    size_t size = byteblock->size ();\n\t    size_t write_size = write (fd, byteblock->value (), size);\n\t    close (fd);\n\t    return YCPBoolean (write_size == size);\n\t}\n\n\tycp2error (\"Write (.byte, \\\"%s\\\") failed: %s\", filename.c_str (), strerror (errno));\n\treturn YCPBoolean (false);\n    }\n\n    else if (cmd == \"ycp\" || cmd == \"yast2\")\n    {\n\t/**\n\t * @builtin Write (.target.ycp, string filename, any value) -> boolean\n\t * Opens a file for writing and prints the value <tt>value</tt> in\n\t * YCP syntax to that file. Returns true, if the file has\n\t * been written, false otherwise. The newly created file gets\n\t * the mode 0644 minus umask. Furthermore any missing directory in the\n\t * pathname <tt>filename</tt> is created automatically.\n\t */\n\n\t/**\n\t * @builtin Write (.target.ycp, [ string filename, integer mode], any value) -> boolean\n\t * Opens a file for writing and prints the value <tt>value</tt> in\n\t * YCP syntax to that file. Returns true, if the file has\n\t * been written, false otherwise. The newly created file gets\n\t * the mode mode minus umask. Furthermore any missing directory in the\n\t * pathname <tt>filename</tt> is created automatically.\n\t */\n\n\t// either string or list\n\n\tif (value.isNull() || !(value->isString() || value->isList()))\n\t{\n\t    ycp2error (\"Bad arguments to Write (%s, string filename ...)\", cmd.c_str ());\n\t    return YCPBoolean (false);\n\t}\n\n\tstring filename;\n\tmode_t filemode = 0644;\n\n\tif (value->isString())\n\t{\n\t    filename = value->asString()->value();\n\t}\n\telse\n\t{\t\t\t// value is list\n\t    YCPList flist = value->asList();\n\t    if ((flist->size() != 2)\n\t\t|| (!flist->value(0)->isString())\n\t\t|| (!flist->value(1)->isInteger()))\n\t    {\n\t\tycp2error (\"Bad [filename, mode] list in call to Write (%s, [ string filename, integer mode ], ...)\",\n\t\t    cmd.c_str ());\n\t\treturn YCPBoolean (false);\n\t    }\n\t    filename = flist->value(0)->asString()->value();\n\t    filemode = (int)(flist->value(1)->asInteger()->value());\n\t}\n\n\tif (filename.length() == 0)\n\t{\n\t    ycp2error (\"Invalid empty filename in Write (%s, ...)\", cmd.c_str ());\n\t    return YCPBoolean (false);\n\t}\n\n\t// Create directory, if missing\n\tsize_t pos = 0;\n\twhile (pos = filename.find('/', pos + 1), pos != string::npos)\n\t    mkdir (filename.substr(0, pos).c_str(), 0775);\n\n\t// Remove file, if existing\n\tremove (filename.c_str());\n\n\tint fd = open (filename.c_str(), O_WRONLY | O_CREAT |  O_TRUNC , filemode);\n\tbool success = false;\n\tif (fd < 0)\n\t{\n\t    ycp2error (\"Error opening '%s': %s\", filename.c_str (), strerror (errno));\n\t    return YCPBoolean (false);\n\t}\n\n\t// string contents = (arg.isNull() ? \"\" : arg->toString());\n\tstring contents = (arg.isNull() ? \"\" : dump_value(0, arg));\n\tssize_t size = contents.length();\n\tif (size == write(fd, contents.c_str(), size)\n\t    && write(fd, \"\\n\", 1) == 1)\n\t    success = true;\n\tclose(fd);\n\n\treturn YCPBoolean(success);\n    }\n\n    ycp2error (\"Undefined subpath for Write (%s)\", path->toString ().c_str ());\n    return YCPBoolean (false);\n}",
    "includes": [
      "#include \"ShellCommand.h\"",
      "#include \"SystemAgent.h\"",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/pathsearch.h>",
      "#include <YCP.h>",
      "#include <stdexcept>",
      "#include <sstream>",
      "#include <string>",
      "#include <linux/lp.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <resolv.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "false"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Undefined subpath for Write (%s)\"",
            "path->toString ().c_str ()"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->toString",
          "args": [],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "\"\\n\"",
            "1"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "write_helper",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "1018-1077",
          "snippet": "int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n{\n    char * out_buffer;\n    string indent;\n    string indent2;\n    int readby = ini.getReadBy ();\n    if (!subindent.empty ())\n    {\n\tfor (int ii = 0; ii<depth - 1;ii++)\n\t    indent = indent + subindent;\n\tif (depth)\n\t    indent2 = indent + subindent;\n    }\n\n    if (ini.getComment ()[0])\n        of << ini.getComment();\n    if (readby>=0 && readby < (int)sections.size ())\n\t{\n\t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free (out_buffer);\n\t}\n    \n    IniIterator\n\tci = ini.getContainerBegin (),\n\tce = ini.getContainerEnd ();\n\n    for (;ci != ce; ++ci)\n\t{\n\t    if (ci->t () == SECTION)\n\t\t{\n\t\t    write_helper (ci->s (), of, depth + 1);\n\t\t    ci->s ().clean();\n\t\t}\n\t    else\n\t\t{\n\t\t    IniEntry&e = ci->e ();\n\t\t    if (e.getComment ()[0])\n\t\t\tof << e.getComment();\n\t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n\t\t\t// bnc#492859, a fixed buffer is too small\n\t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n\t\t\tof << indent2 << out_buffer << \"\\n\";\n\t\t\tfree(out_buffer);\n\t\t    }\n\t\t    e.clean();\n\t\t}\n\t}\n\n    if (ini.getEndComment ()[0])\n        of << indent << ini.getEndComment();\n    if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n\t{\n\t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free(out_buffer);\n\t}\n    ini.clean();\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n  {\n      char * out_buffer;\n      string indent;\n      string indent2;\n      int readby = ini.getReadBy ();\n      if (!subindent.empty ())\n      {\n  \tfor (int ii = 0; ii<depth - 1;ii++)\n  \t    indent = indent + subindent;\n  \tif (depth)\n  \t    indent2 = indent + subindent;\n      }\n  \n      if (ini.getComment ()[0])\n          of << ini.getComment();\n      if (readby>=0 && readby < (int)sections.size ())\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free (out_buffer);\n  \t}\n      \n      IniIterator\n  \tci = ini.getContainerBegin (),\n  \tce = ini.getContainerEnd ();\n  \n      for (;ci != ce; ++ci)\n  \t{\n  \t    if (ci->t () == SECTION)\n  \t\t{\n  \t\t    write_helper (ci->s (), of, depth + 1);\n  \t\t    ci->s ().clean();\n  \t\t}\n  \t    else\n  \t\t{\n  \t\t    IniEntry&e = ci->e ();\n  \t\t    if (e.getComment ()[0])\n  \t\t\tof << e.getComment();\n  \t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n  \t\t\t// bnc#492859, a fixed buffer is too small\n  \t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n  \t\t\tof << indent2 << out_buffer << \"\\n\";\n  \t\t\tfree(out_buffer);\n  \t\t    }\n  \t\t    e.clean();\n  \t\t}\n  \t}\n  \n      if (ini.getEndComment ()[0])\n          of << indent << ini.getEndComment();\n      if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n  \t{\n  \t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n  \t    of << indent << out_buffer << \"\\n\";\n  \t    free(out_buffer);\n  \t}\n      ini.clean();\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "contents.c_str",
          "args": [],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contents.length",
          "args": [],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_value",
          "args": [
            "0",
            "arg"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "dump_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
          "lines": "247-298",
          "snippet": "string\ndump_value (int level, const YCPValue& value)\n{\n    string ret = \"\";\n\n    if (value.isNull())\n\treturn \"\";\n\n    y2debug ( \"%s\\n\", value->toString ().c_str ());\n\n    switch (value->valuetype()) {\n\tcase YT_LIST:\n\t    {\n\t    YCPList list = value->asList ();\n\t    ret += \"[\";\n\t    for (int i = 0; i < list->size (); i++) {\n\t\tret += \"\\n\";\n\t\tret += indent_output (level+1);\n\t\tret += dump_value (level+1, list->value (i));\n\t\tif ( i != list->size()-1)\n\t\t    ret += \",\";\n\t    }\n\t    ret += \"\\n\";\n\t    ret += indent_output (level);\n\t    ret += \"]\";\n\t    }\n\t    break;\n\tcase YT_MAP:\n\t    {\n\t    YCPMap map = value->asMap ();\n\t    ret += \"$[\";\n\t    for (YCPMap::const_iterator i = map->begin(); i != map->end(); i++) {\n\t\tif ( i != map->begin () )\n\t\t    ret += \",\";\n\t\tret += \"\\n\";\n\t\tret += indent_output (level+1);\n\t\tret += dump_value (level+1, i->first);\n\t\tret += \" : \";\n\t\tret += dump_value (level+1, i->second);\n\t    }\n\t    ret += \"\\n\";\n\t    ret += indent_output (level);\n\t    ret += \"]\";\n\t    }\n\t    break;\n\tdefault:\n\t    ret = value->toString ().c_str ();\n\t    break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"ShellCommand.h\"",
            "#include \"SystemAgent.h\"",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/pathsearch.h>",
            "#include <YCP.h>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <string>",
            "#include <linux/lp.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <resolv.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstring\ndump_value (int level, const YCPValue& value)\n{\n    string ret = \"\";\n\n    if (value.isNull())\n\treturn \"\";\n\n    y2debug ( \"%s\\n\", value->toString ().c_str ());\n\n    switch (value->valuetype()) {\n\tcase YT_LIST:\n\t    {\n\t    YCPList list = value->asList ();\n\t    ret += \"[\";\n\t    for (int i = 0; i < list->size (); i++) {\n\t\tret += \"\\n\";\n\t\tret += indent_output (level+1);\n\t\tret += dump_value (level+1, list->value (i));\n\t\tif ( i != list->size()-1)\n\t\t    ret += \",\";\n\t    }\n\t    ret += \"\\n\";\n\t    ret += indent_output (level);\n\t    ret += \"]\";\n\t    }\n\t    break;\n\tcase YT_MAP:\n\t    {\n\t    YCPMap map = value->asMap ();\n\t    ret += \"$[\";\n\t    for (YCPMap::const_iterator i = map->begin(); i != map->end(); i++) {\n\t\tif ( i != map->begin () )\n\t\t    ret += \",\";\n\t\tret += \"\\n\";\n\t\tret += indent_output (level+1);\n\t\tret += dump_value (level+1, i->first);\n\t\tret += \" : \";\n\t\tret += dump_value (level+1, i->second);\n\t    }\n\t    ret += \"\\n\";\n\t    ret += indent_output (level);\n\t    ret += \"]\";\n\t    }\n\t    break;\n\tdefault:\n\t    ret = value->toString ().c_str ();\n\t    break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Error opening '%s': %s\"",
            "filename.c_str ()",
            "strerror (errno)"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename.c_str()",
            "O_WRONLY | O_CREAT |  O_TRUNC",
            "filemode"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove",
          "args": [
            "filename.c_str()"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "remove",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "104-113",
          "snippet": "void YCPMapRep::remove(const YCPValue& key)\n{\n    if (!key->isString() && !key->isInteger() && !key->isSymbol())\n    {\n        ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n        return;\n    }\n\n    stl_map.erase (key);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void YCPMapRep::remove(const YCPValue& key)\n  {\n      if (!key->isString() && !key->isInteger() && !key->isSymbol())\n      {\n          ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n          return;\n      }\n  \n      stl_map.erase (key);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "filename.substr(0, pos).c_str()",
            "0775"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "288-295",
          "snippet": "int PathInfo::mkdir( const Pathname & path, unsigned mode )\n{\n  DBG << \"mkdir \" << path << ' ' << stringutil::octstring( mode );\n  if ( ::mkdir( path.asString().c_str(), mode ) == -1 ) {\n    return _Log_Result( errno );\n  }\n  return _Log_Result( 0 );\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::mkdir( const Pathname & path, unsigned mode )\n  {\n    DBG << \"mkdir \" << path << ' ' << stringutil::octstring( mode );\n    if ( ::mkdir( path.asString().c_str(), mode ) == -1 ) {\n      return _Log_Result( errno );\n    }\n    return _Log_Result( 0 );\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "filename.substr",
          "args": [],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.substr",
          "args": [
            "0",
            "pos"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.find",
          "args": [
            "'/'",
            "pos + 1"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "YCPPathSearch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/pathsearch.cc",
          "lines": "287-321",
          "snippet": "string\nYCPPathSearch::find (Kind kind, const string& name)\n{\n    if (name[0] == '.'\n\t&& name[1] == '/')\n    {\n\tif (access (name.c_str(), R_OK) == 0)\n\t{\n\t    return name;\n\t}\n\treturn \"\";\n    }\n\n    initialize ();\n\n    std::list<string>& kindList = searchList[kind];\n    std::list<string>::iterator i = kindList.begin (), e = kindList.end ();\n    while (i != e)\n    {\n\tstring pathname = completeFilename (*i + '/' + name);\n\ty2debug (\"trying %s\", pathname.c_str ());\n\tif (access (pathname.c_str(), R_OK) == 0)\n\t{\n\t    y2debug (\"... success\");\n\t    // FIXME: this check is different for clients and for modules - see findy2\n\t    if( searchPrefixWarn && *i != kindList.back () ) {\n\t\ty2warning( \"Using special search prefix '%s' for '%s'\", i->c_str(), pathname.c_str() );\n\t    }\n\t    return pathname;\n\t}\n\n\t++i;\n    }\n    return \"\";\n}",
          "includes": [
            "#include \"pathsearch.h\"",
            "#include <ycp/y2log.h>",
            "#include <boost/algorithm/string.hpp>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool Y2PathSearch::searchPrefixWarn = true;",
            "std::list<string> YCPPathSearch::searchList[YCPPathSearch::num_Kind];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pathsearch.h\"\n#include <ycp/y2log.h>\n#include <boost/algorithm/string.hpp>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n\nbool Y2PathSearch::searchPrefixWarn = true;\nstd::list<string> YCPPathSearch::searchList[YCPPathSearch::num_Kind];\n\nYCPPathSearch {\n  string\n  YCPPathSearch::find (Kind kind, const string& name)\n  {\n      if (name[0] == '.'\n  \t&& name[1] == '/')\n      {\n  \tif (access (name.c_str(), R_OK) == 0)\n  \t{\n  \t    return name;\n  \t}\n  \treturn \"\";\n      }\n  \n      initialize ();\n  \n      std::list<string>& kindList = searchList[kind];\n      std::list<string>::iterator i = kindList.begin (), e = kindList.end ();\n      while (i != e)\n      {\n  \tstring pathname = completeFilename (*i + '/' + name);\n  \ty2debug (\"trying %s\", pathname.c_str ());\n  \tif (access (pathname.c_str(), R_OK) == 0)\n  \t{\n  \t    y2debug (\"... success\");\n  \t    // FIXME: this check is different for clients and for modules - see findy2\n  \t    if( searchPrefixWarn && *i != kindList.back () ) {\n  \t\ty2warning( \"Using special search prefix '%s' for '%s'\", i->c_str(), pathname.c_str() );\n  \t    }\n  \t    return pathname;\n  \t}\n  \n  \t++i;\n      }\n      return \"\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Invalid empty filename in Write (%s, ...)\"",
            "cmd.c_str ()"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd.c_str",
          "args": [],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flist->value",
          "args": [],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "flist->value",
          "args": [
            "1"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad [filename, mode] list in call to Write (%s, [ string filename, integer mode ], ...)\"",
            "cmd.c_str ()"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd.c_str",
          "args": [],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flist->size",
          "args": [],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asList",
          "args": [],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asString",
          "args": [],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->isString",
          "args": [],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad arguments to Write (%s, string filename ...)\"",
            "cmd.c_str ()"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd.c_str",
          "args": [],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->isList",
          "args": [],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Write (.byte, \\\"%s\\\") failed: %s\"",
            "filename.c_str ()",
            "strerror (errno)"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename.c_str ()",
            "O_WRONLY | O_CREAT | O_TRUNC",
            "0644"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg->asByteblock",
          "args": [],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "asByteblock",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "142-152",
          "snippet": "YCPByteblock\nYCPValueRep::asByteblock() const\n{\n    if (!isByteblock())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Byteblock!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPByteblock (static_cast<const YCPByteblockRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPByteblock\n  YCPValueRep::asByteblock() const\n  {\n      if (!isByteblock())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Byteblock!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPByteblock (static_cast<const YCPByteblockRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad value for Write (.byte, filename, byteblock)\""
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg->isByteblock",
          "args": [],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "isByteblock",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "66-66",
          "snippet": "bool YCPValueRep::isByteblock()   const { return valuetype() == YT_BYTEBLOCK; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isByteblock()   const { return valuetype() == YT_BYTEBLOCK; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad filename arg for Write (.byte, ...)\""
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Write (.string, \\\"%s\\\") failed: %s\"",
            "filename.c_str ()",
            "strerror (errno)"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cont.c_str",
          "args": [],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename.c_str()",
            "O_WRONLY | O_CREAT | O_TRUNC",
            "0644"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad string value for Write (.string ...)\""
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad filename arg for Write (.string ...)\""
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "exitcode"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "exitcode"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "bashcommand.c_str()"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bashcommand.c_str",
          "args": [],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [
            "1"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "component_str",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "161-165",
          "snippet": "string\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  string\n  YCPPathRep::component_str(long index) const\n  {\n      return components[index].component.asString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"/bin/echo '\""
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad password argument in call to Write (.passwd)\""
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad path argument in call to Write (.passwd.name)\""
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Write () called without sub-path\""
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->isRoot",
          "args": [],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "isRoot",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "83-87",
          "snippet": "bool\nYCPPathRep::isRoot() const\n{\n    return components.empty();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  bool\n  YCPPathRep::isRoot() const\n  {\n      return components.empty();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Write (%s)\"",
            "path->toString().c_str()"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nSystemAgent {\n  YCPBoolean\n  SystemAgent::Write (const YCPPath& path, const YCPValue& value,\n  \t\t    const YCPValue& arg)\n  {\n      y2debug (\"Write (%s)\", path->toString().c_str());\n  \n      if (path->isRoot())\n      {\n  \tycp2error (\"Write () called without sub-path\");\n  \treturn YCPBoolean (false);\n      }\n  \n      const string cmd = path->component_str (0); // just a shortcut\n  \n      if (cmd == \"passwd\")\n      {\n  \t/**\n  \t * @builtin Write (.target.passwd.&lt;name&gt;, string cryptval) -> bool\n  \t * .passwd can be used to set or modify the encrypted password\n  \t * of an already existing user in /etc/passwd and /etc/shadow.\n  \t *\n  \t * This call returns true on success and false, if it fails.\n  \t *\n  \t * @example Write (.target.passwd.root, crypt (a_passwd))\n  \t */\n  \n  \tif (path->length() != 2)\n  \t{\n  \t    ycp2error (\"Bad path argument in call to Write (.passwd.name)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tif (value.isNull() || !value->isString())\n  \t{\n  \t    ycp2error (\"Bad password argument in call to Write (.passwd)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tstring passwd = value->asString()->value();\n  \n  \tstring bashcommand =\n  \t    string (\"/bin/echo '\") +\n  \t    path->component_str (1).c_str () + \":\" + passwd +\n  \t    \"' |/usr/sbin/chpasswd -e >/dev/null 2>&1\";\n  \n  \t// Don't write the password into the log - even though it's crypted\n  \t// y2debug(\"Executing: '%s'\", bashcommand.c_str());\n  \n  \tint exitcode = system(bashcommand.c_str());\n  \n  \treturn YCPBoolean (WIFEXITED (exitcode) && WEXITSTATUS (exitcode) == 0);\n      }\n  \n      else if (cmd == \"string\")\n      {\n  \t/**\n  \t * @builtin Write (.target.string, string filename, string value) -> boolean\n  \t * Writes the string <tt>value</tt> into a file. If the file already\n  \t * exists, the existing file is overwritten. The return value is\n  \t * true, if the file has been written successfully.\n  \t */\n  \n  \tif (value.isNull() || !value->isString())\n  \t{\n  \t    ycp2error (\"Bad filename arg for Write (.string ...)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tif (arg.isNull() || !arg->isString())\n  \t{\n  \t    ycp2error (\"Bad string value for Write (.string ...)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tstring filename = value->asString()->value();\n  \tint fd = open(filename.c_str(), O_WRONLY | O_CREAT | O_TRUNC, 0644);\n  \tif (fd >= 0)\n  \t{\n  \t    string cont = arg->asString()->value();\n  \t    const char *buffer = cont.c_str();\n  \t    size_t length = cont.length();\n  \t    size_t written = write(fd, buffer, length);\n  \t    close(fd);\n  \t    return YCPBoolean (written == length);\n  \t}\n  \tycp2error (\"Write (.string, \\\"%s\\\") failed: %s\", filename.c_str (), strerror (errno));\n  \treturn YCPBoolean(false);\n      }\n  \n      else if (cmd == \"byte\")\n      {\n  \t/**\n  \t * @builtin Write (.target.byte, string filename, byteblock) -> boolean\n  \t * Write a byteblock into a file.\n  \t */\n  \n  \tif (value.isNull () || !value->isString ())\n  \t{\n  \t    ycp2error (\"Bad filename arg for Write (.byte, ...)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tif (arg.isNull () || !arg->isByteblock ())\n  \t{\n  \t    ycp2error (\"Bad value for Write (.byte, filename, byteblock)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tstring filename = value->asString ()->value ();\n  \tYCPByteblock byteblock = arg->asByteblock ();\n  \n  \tint fd = open (filename.c_str (), O_WRONLY | O_CREAT | O_TRUNC, 0644);\n  \tif (fd >= 0)\n  \t{\n  \t    size_t size = byteblock->size ();\n  \t    size_t write_size = write (fd, byteblock->value (), size);\n  \t    close (fd);\n  \t    return YCPBoolean (write_size == size);\n  \t}\n  \n  \tycp2error (\"Write (.byte, \\\"%s\\\") failed: %s\", filename.c_str (), strerror (errno));\n  \treturn YCPBoolean (false);\n      }\n  \n      else if (cmd == \"ycp\" || cmd == \"yast2\")\n      {\n  \t/**\n  \t * @builtin Write (.target.ycp, string filename, any value) -> boolean\n  \t * Opens a file for writing and prints the value <tt>value</tt> in\n  \t * YCP syntax to that file. Returns true, if the file has\n  \t * been written, false otherwise. The newly created file gets\n  \t * the mode 0644 minus umask. Furthermore any missing directory in the\n  \t * pathname <tt>filename</tt> is created automatically.\n  \t */\n  \n  \t/**\n  \t * @builtin Write (.target.ycp, [ string filename, integer mode], any value) -> boolean\n  \t * Opens a file for writing and prints the value <tt>value</tt> in\n  \t * YCP syntax to that file. Returns true, if the file has\n  \t * been written, false otherwise. The newly created file gets\n  \t * the mode mode minus umask. Furthermore any missing directory in the\n  \t * pathname <tt>filename</tt> is created automatically.\n  \t */\n  \n  \t// either string or list\n  \n  \tif (value.isNull() || !(value->isString() || value->isList()))\n  \t{\n  \t    ycp2error (\"Bad arguments to Write (%s, string filename ...)\", cmd.c_str ());\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tstring filename;\n  \tmode_t filemode = 0644;\n  \n  \tif (value->isString())\n  \t{\n  \t    filename = value->asString()->value();\n  \t}\n  \telse\n  \t{\t\t\t// value is list\n  \t    YCPList flist = value->asList();\n  \t    if ((flist->size() != 2)\n  \t\t|| (!flist->value(0)->isString())\n  \t\t|| (!flist->value(1)->isInteger()))\n  \t    {\n  \t\tycp2error (\"Bad [filename, mode] list in call to Write (%s, [ string filename, integer mode ], ...)\",\n  \t\t    cmd.c_str ());\n  \t\treturn YCPBoolean (false);\n  \t    }\n  \t    filename = flist->value(0)->asString()->value();\n  \t    filemode = (int)(flist->value(1)->asInteger()->value());\n  \t}\n  \n  \tif (filename.length() == 0)\n  \t{\n  \t    ycp2error (\"Invalid empty filename in Write (%s, ...)\", cmd.c_str ());\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \t// Create directory, if missing\n  \tsize_t pos = 0;\n  \twhile (pos = filename.find('/', pos + 1), pos != string::npos)\n  \t    mkdir (filename.substr(0, pos).c_str(), 0775);\n  \n  \t// Remove file, if existing\n  \tremove (filename.c_str());\n  \n  \tint fd = open (filename.c_str(), O_WRONLY | O_CREAT |  O_TRUNC , filemode);\n  \tbool success = false;\n  \tif (fd < 0)\n  \t{\n  \t    ycp2error (\"Error opening '%s': %s\", filename.c_str (), strerror (errno));\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \t// string contents = (arg.isNull() ? \"\" : arg->toString());\n  \tstring contents = (arg.isNull() ? \"\" : dump_value(0, arg));\n  \tssize_t size = contents.length();\n  \tif (size == write(fd, contents.c_str(), size)\n  \t    && write(fd, \"\\n\", 1) == 1)\n  \t    success = true;\n  \tclose(fd);\n  \n  \treturn YCPBoolean(success);\n      }\n  \n      ycp2error (\"Undefined subpath for Write (%s)\", path->toString ().c_str ());\n      return YCPBoolean (false);\n  }\n}"
  },
  {
    "function_name": "Read",
    "container": "SystemAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
    "lines": "303-649",
    "snippet": "YCPValue\nSystemAgent::Read (const YCPPath& path, const YCPValue& arg, const YCPValue&)\n{\n    y2debug (\"Read (%s)\", path->toString().c_str());\n\n    if (path->isRoot())\n    {\n\tycp2error (\"Read () called without sub-path\");\n\treturn YCPNull ();\n    }\n\n    const string cmd = path->component_str (0); // just a shortcut\n\n    /**\n     * @builtin intro\n     * Paths described here have to be prefixed by .target\n     * (e.g. <tt>SCR::Read (.target.tmpdir)</tt>). Only as an\n     * exception during the installation they can be prefixed by\n     * .local (e.g. <tt>WFM::Read (.local.tmpdir)</tt>).\n     */\n\n    if (cmd == \"tmpdir\")\n    {\n\t/**\n\t * @builtin Read (.target.tmpdir) -> string\n\t * Returns the (instance specific) directory for storing temporary\n\t * files. The directory (and its contents) will be removed by the\n\t * SystemAgent destructor (usually when yast2 exits)\n\t *\n\t * @example Read (.target.tmpdir) -> \"/some/temp/dir\"\n\t */\n\n\treturn YCPString (tempdir);\n    }\n\n    if (arg.isNull())\n    {\n\tycp2error (\"Filename arg for Read is nil\");\n\treturn YCPNull ();\n    }\n\n    YCPValue default_value = YCPNull();\n\n    string filename;\n\n    if (arg->isString())\n    {\n\tfilename = arg->asString()->value();\n    }\n    else if (arg->isList()\n\t     && (arg->asList()->size() == 2)\n\t     && (arg->asList()->value(0)->isString()))\n    {\n\tdefault_value = arg->asList()->value(1);\n\tfilename = arg->asList()->value(0)->asString()->value();\n    }\n    else\n    {\n\ty2error (\"Read (%s, %s) failed !\", cmd.c_str(), arg->toString().c_str());\n\tycp2error (\"Bad filename arg for Read (...)\");\n\treturn YCPNull ();\n    }\n\n    if (cmd == \"string\")\n    {\n\t/**\n\t * @builtin Read (.target.string, string filename) -> string\n\t * Opens an Ascii file and reads the contents to a single\n\t * string. Newlines are preserved.\n\t *\n\t * @example Read (.target.string, \"/some/file\") -> \"a contents\"\n\t */\n\n\tstring output;\n\tint ret = read_file_to_string (filename.c_str (), output);\n\tif (ret == 0)\n\t{\n\t    return YCPString (output);\n\t}\n\telse if (!default_value.isNull())\n\t{\n\t    return default_value;\n\t}\n\telse\n\t{\n\t    ycp2error (\"Read (.string, \\\"%s\\\") failed: %d\", filename.c_str (), ret);\n\t    return YCPNull ();\n\t}\n    }\n\n    else if (cmd == \"byte\")\n    {\n\t/**\n\t * @builtin Read (.target.byte, string filename) -> byteblock\n\t * Opens a binary file and reads its contents into a single byteblock.\n\t */\n\n\tint fd = open (filename.c_str (), O_RDONLY);\n\tif (fd == -1)\n\t{\n\t    if (!default_value.isNull())\n\t    {\n\t\treturn default_value;\n\t    }\n\t    else\n\t    {\n\t\treturn YCPError (string (\"Read (.byte, \\\"\") + filename +\n\t\t\t     \"\\\") failed: \" + strerror (errno));\n\t    }\n\t}\n\n\t// determine filesize\n\tstruct stat sb;\n\tfstat (fd, &sb);\n\tsize_t filesize = sb.st_size;\n\n\t// don't try to allocate this on the stack\n\tunsigned char *buffer = (unsigned char *) malloc (filesize);\n\n\tif (!buffer)\n\t{\n\t    close (fd);\n\t    return YCPError (string (\"Read (.byte, \\\"\") + filename +\n\t\t\t     \"\\\") failed: \" + strerror (errno));\n\t}\n\n\tsize_t read_bytes = read (fd, buffer, filesize);\n\tif (read_bytes != filesize)\n\t{\n\t    free (buffer);\n\t    close (fd);\n\t    return YCPError (string (\"Read (.byte, \\\"\") +\n\t\t\t     filename + \"\\\") failed: \" +\n\t\t\t     strerror (errno));\n\t}\n\n\tYCPByteblock ret = YCPByteblock (buffer, filesize);\n\tfree (buffer);\n\tclose (fd);\n\treturn ret;\n    }\n\n    else if (cmd == \"ycp\" || cmd == \"yast2\")\n    {\n\t/**\n\t * @builtin Read (.target.ycp, string filename) -> any\n\t * @builtin Read (.target.ycp, string filename, [any default = nil]) -> any\n\t * Opens a file that must be in YCP syntax and contain exactly\n\t * one value, parses that file and returns the parsed value.\n\t * Returns 'default', if the file didn't exist, was not readable or\n\t * didn't not contain a valid YCP value.\n\t * A warning in the log is omitted if a default value is given.\n\t */\n\n\t/**\n\t * @builtin Read (.target.yast2, string filename) -> any\n\t * @builtin Read (.target.yast2, string filename, [any default = nil]) -> any\n\t * Opens a file that must be in YCP syntax and contain exactly\n\t * one value, parses that file and returns the parsed value.\n\t * Returns default, if the file didn't exist, was not readable or\n\t * did not contain a valid YCP value.\n\t *\n\t * The purpose of this function is to load data located in\n\t * ydatadir. The data may also be located in any of the paths in\n\t * source/core/liby2/src/pathsearch.cc appended by \"data/\".\n\t * The filename must be relative to one of those paths.\n\t *\n\t * A warning in the log is omitted if a default value is given.\n\t */\n\n\tif (cmd == \"yast2\")\n\t{\n\t    string tmp = Y2PathSearch::findy2 (\"data/\" + filename); // FIXME use ydatadir\n\t    if (!tmp.empty ())\n\t    {\n\t\tfilename = tmp;\n\t    }\n\t    else\n\t    {\n\t\tif (!default_value.isNull ())\n\t\t{\n\t\t    return default_value;\n\t\t}\n\t\telse\n\t\t{\n\t\t    return YCPError (\"can't find '\" + filename + \"'\");\n\t\t}\n\t    }\n\t}\n\n\tint fd = open (filename.c_str (), O_RDONLY);\n\tif (fd < 0)\n\t{\n\t    if (!default_value.isNull())\n\t    {\n\t\treturn default_value;\n\t    }\n\t    else\n\t    {\n\t\treturn YCPError (\"Open file '\" + filename + \"' failed: \" + strerror (errno));\n\t    }\n\t}\n\tParser parser (fd, filename.c_str ());\n\tparser.setBuffered(); // Read from file. Buffering is always possible here\n\tYCodePtr p = parser.parse();\n\tclose(fd);\n\t\n\tif (!p)\n\t{\treturn YCPError (\"Parsing file '\" + filename + \"' failed\");\n\t}\n\t\n\tYCPValue contents = YCPNull ();\n\tif (p->isBlock ())\n\t{\n\t    contents = YCPCode (p);\n\t}\n\telse\n\t{\n\t    contents = p->evaluate (true);\n\t}\n\n\treturn !contents.isNull() ? contents : YCPVoid();\n    }\n\n    else if (cmd == \"dir\")\n    {\n\t/**\n\t * @builtin Read (.target.dir, string path) -> list\n\t * @builtin Read (.target.dir, [string path, list default]) -> list\n\t * Reads a directory. Returns a list of strings, one string for\n\t * each file contained in the directory path is pointing to.\n\t * The entries '.' and '..' are NOT returned. Returns nil and\n\t * doesn't log an error, if path does not point to a readable\n\t * directory.\n\t * If a default value is given, this is returned if path isn't\n\t * accessible.\n\t *\n\t * @example Read (.target.dir, \"/proc/self\") -> [ \"cmdline\", \"cwd\", \"environ\", ... ]\n\t */\n\n\tDIR *dir = opendir (filename.c_str());\n\tif (!dir)\n\t{\n\t    if (!default_value.isNull())\n\t    {\n\t\treturn default_value;\n\t    }\n\t    y2milestone (\"Can't access directory '%s': %s'\"\n\t\t, filename.c_str (), strerror (errno));\n\t    return YCPVoid ();\n\t}\n\n\tYCPList dirlist;\n\tstruct dirent *entry;\n\twhile ((entry = readdir (dir)))\n\t{\n\t    if (!strcmp(entry->d_name, \".\") || !(strcmp(entry->d_name, \"..\")))\n\t\tcontinue;\n\t    dirlist->add (YCPString (entry->d_name));\n\t}\n\tclosedir (dir);\n\treturn dirlist;\n    }\n\n    else if (cmd == \"size\")\n    {\n\t/**\n\t * @builtin Read (.target.size, string filename) -> integer\n\t * return current size of file\n\t * returns -1 if the file does not exist\n\t */\n\n\tstruct stat sb;\n\tlong long retval = stat (filename.c_str (), &sb);\n\tif (retval == 0)\n\t{\n\t    retval = sb.st_size;\n\t}\n\treturn YCPInteger (retval);\n    }\n\n    else if (cmd == \"stat\")\n    {\n\t/**\n\t * @builtin Read (.target.stat, string filename) -> map\n\t * Return a map with file information (see stat(2)). If\n\t * the file does not exist return an empty map.\n\t */\n\n\tYCPMap result;\n\n\tstruct stat sb;\n\tif (stat (filename.c_str (), &sb) == 0)\n\t{\n\t    result = stat2map (sb);\n\t}\n\n\treturn result;\n    }\n\n    else if (cmd == \"lstat\")\n    {\n\t/**\n\t * @builtin Read (.target.lstat, string filename) -> map\n\t * Return a map with file information (see stat(2)). If\n\t * the file does not exist return an empty map.\n\t */\n\n\tYCPMap result;\n\n\tstruct stat sb;\n\tif (lstat (filename.c_str (), &sb) == 0)\n\t{\n\t    result = stat2map (sb);\n\t}\n\n\treturn result;\n    }\n\n    else if (cmd == \"symlink\")\n    {\n\t/**\n\t * @builtin Read (.target.symlink, string filename) -> string\n\t *\n\t * Returns the content of the symbolic link filename. If the filename\n\t * does not exist or is no symbolic link, nil is returned and an error\n\t * logged.\n\t *\n\t * @example Read (.target.symlink, \"/var/X11R6/bin/X\")\n\t */\n\n\tconst int size = 1024;\n\tchar buffer[size];\n\tint ret = readlink (filename.c_str (), buffer, size - 1);\n\n\tif (ret == -1)\n\t{\n\t    return YCPError (string (\"failed to read symlink \") + filename +\n\t\t\t     \": \" + strerror (errno));\n\t}\n\n\tbuffer[ret] = '\\0';\n\treturn YCPString (buffer);\n    }\n\n    return YCPError (string(\"Undefined subpath for Read (\") + path->toString() + \")\");\n}",
    "includes": [
      "#include \"ShellCommand.h\"",
      "#include \"SystemAgent.h\"",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/pathsearch.h>",
      "#include <YCP.h>",
      "#include <stdexcept>",
      "#include <sstream>",
      "#include <string>",
      "#include <linux/lp.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <resolv.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "string(\"Undefined subpath for Read (\") + path->toString() + \")\""
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->toString",
          "args": [],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"Undefined subpath for Read (\""
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "buffer"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "string (\"failed to read symlink \") + filename +\n\t\t\t     \": \" + strerror (errno)"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readlink",
          "args": [
            "filename.c_str ()",
            "buffer",
            "size - 1"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat2map",
          "args": [
            "sb"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "stat2map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
          "lines": "171-198",
          "snippet": "static YCPMap\nstat2map (const struct stat& sb)\n{\n    YCPMap result;\n\n    result->add (YCPString (\"inode\"), YCPInteger (sb.st_ino));\n\n    result->add (YCPString (\"isreg\"), YCPBoolean (S_ISREG (sb.st_mode)));\n    result->add (YCPString (\"isdir\"), YCPBoolean (S_ISDIR (sb.st_mode)));\n    result->add (YCPString (\"ischr\"), YCPBoolean (S_ISCHR (sb.st_mode)));\n    result->add (YCPString (\"isblock\"), YCPBoolean (S_ISBLK (sb.st_mode)));\n    result->add (YCPString (\"isfifo\"), YCPBoolean (S_ISFIFO (sb.st_mode)));\n    result->add (YCPString (\"islink\"), YCPBoolean (S_ISLNK (sb.st_mode)));\n    result->add (YCPString (\"issock\"), YCPBoolean (S_ISSOCK (sb.st_mode)));\n\n    result->add (YCPString (\"nlink\"), YCPInteger (sb.st_nlink));\n\n    result->add (YCPString (\"uid\"), YCPInteger (sb.st_uid));\n    result->add (YCPString (\"gid\"), YCPInteger (sb.st_gid));\n\n    result->add (YCPString (\"size\"), YCPInteger (sb.st_size));\n\n    result->add (YCPString (\"atime\"), YCPInteger (sb.st_atime));\n    result->add (YCPString (\"mtime\"), YCPInteger (sb.st_mtime));\n    result->add (YCPString (\"ctime\"), YCPInteger (sb.st_ctime));\n\n    return result;\n}",
          "includes": [
            "#include \"ShellCommand.h\"",
            "#include \"SystemAgent.h\"",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/pathsearch.h>",
            "#include <YCP.h>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <string>",
            "#include <linux/lp.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <resolv.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic YCPMap\nstat2map (const struct stat& sb)\n{\n    YCPMap result;\n\n    result->add (YCPString (\"inode\"), YCPInteger (sb.st_ino));\n\n    result->add (YCPString (\"isreg\"), YCPBoolean (S_ISREG (sb.st_mode)));\n    result->add (YCPString (\"isdir\"), YCPBoolean (S_ISDIR (sb.st_mode)));\n    result->add (YCPString (\"ischr\"), YCPBoolean (S_ISCHR (sb.st_mode)));\n    result->add (YCPString (\"isblock\"), YCPBoolean (S_ISBLK (sb.st_mode)));\n    result->add (YCPString (\"isfifo\"), YCPBoolean (S_ISFIFO (sb.st_mode)));\n    result->add (YCPString (\"islink\"), YCPBoolean (S_ISLNK (sb.st_mode)));\n    result->add (YCPString (\"issock\"), YCPBoolean (S_ISSOCK (sb.st_mode)));\n\n    result->add (YCPString (\"nlink\"), YCPInteger (sb.st_nlink));\n\n    result->add (YCPString (\"uid\"), YCPInteger (sb.st_uid));\n    result->add (YCPString (\"gid\"), YCPInteger (sb.st_gid));\n\n    result->add (YCPString (\"size\"), YCPInteger (sb.st_size));\n\n    result->add (YCPString (\"atime\"), YCPInteger (sb.st_atime));\n    result->add (YCPString (\"mtime\"), YCPInteger (sb.st_mtime));\n    result->add (YCPString (\"ctime\"), YCPInteger (sb.st_ctime));\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "filename.c_str ()",
            "&sb"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "filename.c_str ()",
            "&sb"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPInteger",
          "args": [
            "retval"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "YCPInteger",
          "container": "YCPInteger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPInteger.cc",
          "lines": "142-145",
          "snippet": "YCPInteger::YCPInteger (bytecodeistream & str)\n    : YCPValue (new YCPIntegerRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/y2log.h\"\n\nYCPInteger {\n  YCPInteger::YCPInteger (bytecodeistream & str)\n      : YCPValue (new YCPIntegerRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "filename.c_str ()",
            "&sb"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirlist->add",
          "args": [
            "YCPString (entry->d_name)"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry->d_name",
            "\"..\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry->d_name",
            "\".\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2milestone",
          "args": [
            "\"Can't access directory '%s': %s'\"",
            "filename.c_str ()",
            "strerror (errno)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "default_value.isNull",
          "args": [],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "filename.c_str()"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contents.isNull",
          "args": [],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->evaluate",
          "args": [
            "true"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2AgentComp<Agent>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "91-166",
          "snippet": "YCPValue\nY2AgentComp<Agent>::evaluate (const YCPValue& v)\n{\n    y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n\n    if (!agent)\n\tgetSCRAgent ();\n\n    y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n\t\n    YCPValue value = v;\n    if (value->isCode ())\n    {\n\tYCodePtr c = v->asCode ()->code ();\n\n\t\n\tif ( c->kind () != YCode::yeTerm)\n\t{\n\t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n\t    value = value->asCode ()->evaluate ();\n\t    return value;\n\t}\n\n\tvalue = value->asCode ()->evaluate ();\n    }\n\t\n    if (value.isNull () || value->isVoid ())\n\treturn value;\n\n    y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n\n    if( value->isTerm () ) {\n\tYCPTerm term = value ->asTerm ();\n\tstring command = term->name ();\n\tYCPList args = term->args ();\n\n\t// evaluate the term in native functions\n\tif( command == \"Read\" ) {\n\t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n\t}\n\telse if( command == \"Write\" ) {\n\t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n\t}\n\telse if( command == \"Dir\" ) {\n\t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Error\" ) {\n\t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Execute\" ) {\n\t    y2debug( \"Execute, arg size is %d\", args->size() );\n\t    switch( args->size() ) {\n\t\tcase 1:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n\t\tcase 2:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n\t\tdefault:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n\t    }\n\t}\n\telse {\n\t    y2debug( \"Passing term to otherCommand\" );\n\t    return getSCRAgent ()-> otherCommand (term);\n\t}\n    }\n#if 0\n    if( value->isCode () ) {\n\ty2debug( \"Passing (evaluated) code to otherCommand\" );\n\treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n    }\n#endif\n\n    y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n\n    return YCPVoid();\n}",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp<Agent> {\n  YCPValue\n  Y2AgentComp<Agent>::evaluate (const YCPValue& v)\n  {\n      y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n  \n      if (!agent)\n  \tgetSCRAgent ();\n  \n      y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n  \t\n      YCPValue value = v;\n      if (value->isCode ())\n      {\n  \tYCodePtr c = v->asCode ()->code ();\n  \n  \t\n  \tif ( c->kind () != YCode::yeTerm)\n  \t{\n  \t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n  \t    value = value->asCode ()->evaluate ();\n  \t    return value;\n  \t}\n  \n  \tvalue = value->asCode ()->evaluate ();\n      }\n  \t\n      if (value.isNull () || value->isVoid ())\n  \treturn value;\n  \n      y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n  \n      if( value->isTerm () ) {\n  \tYCPTerm term = value ->asTerm ();\n  \tstring command = term->name ();\n  \tYCPList args = term->args ();\n  \n  \t// evaluate the term in native functions\n  \tif( command == \"Read\" ) {\n  \t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Write\" ) {\n  \t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Dir\" ) {\n  \t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Error\" ) {\n  \t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Execute\" ) {\n  \t    y2debug( \"Execute, arg size is %d\", args->size() );\n  \t    switch( args->size() ) {\n  \t\tcase 1:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n  \t\tcase 2:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n  \t\tdefault:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n  \t    }\n  \t}\n  \telse {\n  \t    y2debug( \"Passing term to otherCommand\" );\n  \t    return getSCRAgent ()-> otherCommand (term);\n  \t}\n      }\n  #if 0\n      if( value->isCode () ) {\n  \ty2debug( \"Passing (evaluated) code to otherCommand\" );\n  \treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n      }\n  #endif\n  \n      y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n  \n      return YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPCode",
          "args": [
            "p"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "YCPCode",
          "container": "YCPCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "103-107",
          "snippet": "YCPCode::YCPCode (bytecodeistream & str)\n    : YCPValue (YCPCode())\n{\n    (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPCode {\n  YCPCode::YCPCode (bytecodeistream & str)\n      : YCPValue (YCPCode())\n  {\n      (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->isBlock",
          "args": [],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "isBlock",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "73-77",
          "snippet": "bool\nYBreakpoint::isBlock () const\n{\n    return m_code->isBlock();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  bool\n  YBreakpoint::isBlock () const\n  {\n      return m_code->isBlock();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "\"Parsing file '\" + filename + \"' failed\""
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser.parse",
          "args": [],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "484-562",
          "snippet": "int IniParser::parse()\n{\n    if (multiple_files)\n    {\n\tglob_t do_files;\n\tint len = files.size ();\n\tint flags = 0;\n\tfor (int i = 0;i<len;i++)\n\t{\n\t    glob (files[i].c_str (),flags, NULL, &do_files);\n\t    flags = GLOB_APPEND;\n\t}\n\tchar**f = do_files.gl_pathv;\n\tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n\t{\n\t    int section_index = -1;\n\t    string section_name = *f;\n\t    //FIXME: create function out of it.\n\t    // do we have name rewrite rules?\n\t    for (size_t j = 0; j < rewrites.size (); j++)\n\t\t{\n\t\t    RegexMatch m (rewrites[j].rx, section_name);\n\t\t    if (m)\n\t\t    {\n\t\t\tsection_index = j;\n\t\t\tsection_name = m[1];\n\t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    // do we know about the file?\n\t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n\t    if (ff == multi_files.end())\n\t    {\n\t\t// new file\n\t\tif (scanner_start (*f))\n\t\t    y2error (\"Cannot open %s.\", *f);\n\t\telse\n\t\t{\n\t\t    FileDescr fdsc (*f);\n\t\t    multi_files[*f] = fdsc;\n\t\t    inifile.initSection (section_name, \"\", -1, section_index);\n\t\t    parse_helper(inifile.getSection(section_name.c_str()));\n\t\t    scanner_stop();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif ((*ff).second.changed ())\n\t\t{\n\t\t    if (scanner_start (*f))\n\t\t\ty2error (\"Cannot open %s.\", *f);\n\t\t    else\n\t\t    {\n\t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n\t\t\tFileDescr fdsc (*f);\n\t\t\tmulti_files [*f] = fdsc;\n\t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n\t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n\t\t\tscanner_stop();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tif (scanner_start (file.c_str()))\n\t    {\n\t\ty2error (\"Can not open %s.\", file.c_str());\n\t\treturn -1;\n\t    }\n\tparse_helper(inifile);\n\tscanner_stop();\n\ttimestamp = getTimeStamp ();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse()\n  {\n      if (multiple_files)\n      {\n  \tglob_t do_files;\n  \tint len = files.size ();\n  \tint flags = 0;\n  \tfor (int i = 0;i<len;i++)\n  \t{\n  \t    glob (files[i].c_str (),flags, NULL, &do_files);\n  \t    flags = GLOB_APPEND;\n  \t}\n  \tchar**f = do_files.gl_pathv;\n  \tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n  \t{\n  \t    int section_index = -1;\n  \t    string section_name = *f;\n  \t    //FIXME: create function out of it.\n  \t    // do we have name rewrite rules?\n  \t    for (size_t j = 0; j < rewrites.size (); j++)\n  \t\t{\n  \t\t    RegexMatch m (rewrites[j].rx, section_name);\n  \t\t    if (m)\n  \t\t    {\n  \t\t\tsection_index = j;\n  \t\t\tsection_name = m[1];\n  \t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \n  \t    // do we know about the file?\n  \t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n  \t    if (ff == multi_files.end())\n  \t    {\n  \t\t// new file\n  \t\tif (scanner_start (*f))\n  \t\t    y2error (\"Cannot open %s.\", *f);\n  \t\telse\n  \t\t{\n  \t\t    FileDescr fdsc (*f);\n  \t\t    multi_files[*f] = fdsc;\n  \t\t    inifile.initSection (section_name, \"\", -1, section_index);\n  \t\t    parse_helper(inifile.getSection(section_name.c_str()));\n  \t\t    scanner_stop();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif ((*ff).second.changed ())\n  \t\t{\n  \t\t    if (scanner_start (*f))\n  \t\t\ty2error (\"Cannot open %s.\", *f);\n  \t\t    else\n  \t\t    {\n  \t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n  \t\t\tFileDescr fdsc (*f);\n  \t\t\tmulti_files [*f] = fdsc;\n  \t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n  \t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n  \t\t\tscanner_stop();\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n      else\n      {\n  \tif (scanner_start (file.c_str()))\n  \t    {\n  \t\ty2error (\"Can not open %s.\", file.c_str());\n  \t\treturn -1;\n  \t    }\n  \tparse_helper(inifile);\n  \tscanner_stop();\n  \ttimestamp = getTimeStamp ();\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.setBuffered",
          "args": [],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "setBuffered",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "128-132",
          "snippet": "void\nScanner::setBuffered ()\n{\n    m_buffered = true;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  void\n  Scanner::setBuffered ()\n  {\n      m_buffered = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "\"Open file '\" + filename + \"' failed: \" + strerror (errno)"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "default_value.isNull",
          "args": [],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename.c_str ()",
            "O_RDONLY"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "\"can't find '\" + filename + \"'\""
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "default_value.isNull",
          "args": [],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmp.empty",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2PathSearch::findy2",
          "args": [
            "\"data/\" + filename"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buffer"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPByteblock",
          "args": [
            "buffer",
            "filesize"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "YCPByteblockRep",
          "container": "YCPByteblockRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPByteblock.cc",
          "lines": "38-43",
          "snippet": "YCPByteblockRep::YCPByteblockRep (bytecodeistream & str, long len)\n    : len (len)\n{\n    bytes = new unsigned char [len];\n    str.read ((char *)bytes, len);\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPByteblock.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPByteblock.h\"\n#include <ycp/y2log.h>\n\nYCPByteblockRep {\n  YCPByteblockRep::YCPByteblockRep (bytecodeistream & str, long len)\n      : len (len)\n  {\n      bytes = new unsigned char [len];\n      str.read ((char *)bytes, len);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "string (\"Read (.byte, \\\"\") +\n\t\t\t     filename + \"\\\") failed: \" +\n\t\t\t     strerror (errno)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buffer"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buffer",
            "filesize"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "read_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2crypt.cc",
          "lines": "25-50",
          "snippet": "static int\nread_loop (int fd, char* buffer, int count)\n{\n    int offset, block;\n\n    offset = 0;\n    while (count > 0)\n    {\n\tblock = read (fd, &buffer[offset], count);\n\n\tif (block < 0)\n\t{\n\t    if (errno == EINTR)\n\t\tcontinue;\n\t    return block;\n\t}\n\n\tif (!block)\n\t    return offset;\n\n\toffset += block;\n\tcount -= block;\n    }\n\n    return offset;\n}",
          "includes": [
            "#include \"y2crypt.h\"",
            "#include \"y2log.h\"",
            "#include <xcrypt.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2crypt.h\"\n#include \"y2log.h\"\n#include <xcrypt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int\nread_loop (int fd, char* buffer, int count)\n{\n    int offset, block;\n\n    offset = 0;\n    while (count > 0)\n    {\n\tblock = read (fd, &buffer[offset], count);\n\n\tif (block < 0)\n\t{\n\t    if (errno == EINTR)\n\t\tcontinue;\n\t    return block;\n\t}\n\n\tif (!block)\n\t    return offset;\n\n\toffset += block;\n\tcount -= block;\n    }\n\n    return offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "string (\"Read (.byte, \\\"\") + filename +\n\t\t\t     \"\\\") failed: \" + strerror (errno)"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "filesize"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&sb"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPError",
          "args": [
            "string (\"Read (.byte, \\\"\") + filename +\n\t\t\t     \"\\\") failed: \" + strerror (errno)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "default_value.isNull",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename.c_str ()",
            "O_RDONLY"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Read (.string, \\\"%s\\\") failed: %d\"",
            "filename.c_str ()",
            "ret"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "default_value.isNull",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_file_to_string",
          "args": [
            "filename.c_str ()",
            "output"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "read_file_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
          "lines": "145-165",
          "snippet": "static int read_file_to_string (const char* filename, string& output)\n{\n    int fd = open (filename, O_RDONLY);\n    output = \"\";\n    if (fd < 0)\n    {\n\treturn errno;\n    }\n\n    while (true)\n    {\n\tchar buffer[4096];\n\tssize_t bytes_read = read (fd, buffer, 4095);\n\tif (bytes_read <= 0)\n\t    break;\n\tbuffer[bytes_read] = 0; // 0 terminate string\n\toutput += buffer;\n    }\n    close(fd);\n    return 0;\n}",
          "includes": [
            "#include \"ShellCommand.h\"",
            "#include \"SystemAgent.h\"",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/pathsearch.h>",
            "#include <YCP.h>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <string>",
            "#include <linux/lp.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <resolv.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int read_file_to_string (const char* filename, string& output)\n{\n    int fd = open (filename, O_RDONLY);\n    output = \"\";\n    if (fd < 0)\n    {\n\treturn errno;\n    }\n\n    while (true)\n    {\n\tchar buffer[4096];\n\tssize_t bytes_read = read (fd, buffer, 4095);\n\tif (bytes_read <= 0)\n\t    break;\n\tbuffer[bytes_read] = 0; // 0 terminate string\n\toutput += buffer;\n    }\n    close(fd);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad filename arg for Read (...)\""
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Read (%s, %s) failed !\"",
            "cmd.c_str()",
            "arg->toString().c_str()"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd.c_str",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg->asList",
          "args": [],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg->asList",
          "args": [
            "0"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg->asList",
          "args": [
            "1"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg->asList",
          "args": [
            "0"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg->isList",
          "args": [],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg->asString",
          "args": [],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg->isString",
          "args": [],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Filename arg for Read is nil\""
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [
            "0"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "component_str",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "161-165",
          "snippet": "string\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  string\n  YCPPathRep::component_str(long index) const\n  {\n      return components[index].component.asString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Read () called without sub-path\""
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->isRoot",
          "args": [],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "isRoot",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "83-87",
          "snippet": "bool\nYCPPathRep::isRoot() const\n{\n    return components.empty();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  bool\n  YCPPathRep::isRoot() const\n  {\n      return components.empty();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Read (%s)\"",
            "path->toString().c_str()"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nSystemAgent {\n  YCPValue\n  SystemAgent::Read (const YCPPath& path, const YCPValue& arg, const YCPValue&)\n  {\n      y2debug (\"Read (%s)\", path->toString().c_str());\n  \n      if (path->isRoot())\n      {\n  \tycp2error (\"Read () called without sub-path\");\n  \treturn YCPNull ();\n      }\n  \n      const string cmd = path->component_str (0); // just a shortcut\n  \n      /**\n       * @builtin intro\n       * Paths described here have to be prefixed by .target\n       * (e.g. <tt>SCR::Read (.target.tmpdir)</tt>). Only as an\n       * exception during the installation they can be prefixed by\n       * .local (e.g. <tt>WFM::Read (.local.tmpdir)</tt>).\n       */\n  \n      if (cmd == \"tmpdir\")\n      {\n  \t/**\n  \t * @builtin Read (.target.tmpdir) -> string\n  \t * Returns the (instance specific) directory for storing temporary\n  \t * files. The directory (and its contents) will be removed by the\n  \t * SystemAgent destructor (usually when yast2 exits)\n  \t *\n  \t * @example Read (.target.tmpdir) -> \"/some/temp/dir\"\n  \t */\n  \n  \treturn YCPString (tempdir);\n      }\n  \n      if (arg.isNull())\n      {\n  \tycp2error (\"Filename arg for Read is nil\");\n  \treturn YCPNull ();\n      }\n  \n      YCPValue default_value = YCPNull();\n  \n      string filename;\n  \n      if (arg->isString())\n      {\n  \tfilename = arg->asString()->value();\n      }\n      else if (arg->isList()\n  \t     && (arg->asList()->size() == 2)\n  \t     && (arg->asList()->value(0)->isString()))\n      {\n  \tdefault_value = arg->asList()->value(1);\n  \tfilename = arg->asList()->value(0)->asString()->value();\n      }\n      else\n      {\n  \ty2error (\"Read (%s, %s) failed !\", cmd.c_str(), arg->toString().c_str());\n  \tycp2error (\"Bad filename arg for Read (...)\");\n  \treturn YCPNull ();\n      }\n  \n      if (cmd == \"string\")\n      {\n  \t/**\n  \t * @builtin Read (.target.string, string filename) -> string\n  \t * Opens an Ascii file and reads the contents to a single\n  \t * string. Newlines are preserved.\n  \t *\n  \t * @example Read (.target.string, \"/some/file\") -> \"a contents\"\n  \t */\n  \n  \tstring output;\n  \tint ret = read_file_to_string (filename.c_str (), output);\n  \tif (ret == 0)\n  \t{\n  \t    return YCPString (output);\n  \t}\n  \telse if (!default_value.isNull())\n  \t{\n  \t    return default_value;\n  \t}\n  \telse\n  \t{\n  \t    ycp2error (\"Read (.string, \\\"%s\\\") failed: %d\", filename.c_str (), ret);\n  \t    return YCPNull ();\n  \t}\n      }\n  \n      else if (cmd == \"byte\")\n      {\n  \t/**\n  \t * @builtin Read (.target.byte, string filename) -> byteblock\n  \t * Opens a binary file and reads its contents into a single byteblock.\n  \t */\n  \n  \tint fd = open (filename.c_str (), O_RDONLY);\n  \tif (fd == -1)\n  \t{\n  \t    if (!default_value.isNull())\n  \t    {\n  \t\treturn default_value;\n  \t    }\n  \t    else\n  \t    {\n  \t\treturn YCPError (string (\"Read (.byte, \\\"\") + filename +\n  \t\t\t     \"\\\") failed: \" + strerror (errno));\n  \t    }\n  \t}\n  \n  \t// determine filesize\n  \tstruct stat sb;\n  \tfstat (fd, &sb);\n  \tsize_t filesize = sb.st_size;\n  \n  \t// don't try to allocate this on the stack\n  \tunsigned char *buffer = (unsigned char *) malloc (filesize);\n  \n  \tif (!buffer)\n  \t{\n  \t    close (fd);\n  \t    return YCPError (string (\"Read (.byte, \\\"\") + filename +\n  \t\t\t     \"\\\") failed: \" + strerror (errno));\n  \t}\n  \n  \tsize_t read_bytes = read (fd, buffer, filesize);\n  \tif (read_bytes != filesize)\n  \t{\n  \t    free (buffer);\n  \t    close (fd);\n  \t    return YCPError (string (\"Read (.byte, \\\"\") +\n  \t\t\t     filename + \"\\\") failed: \" +\n  \t\t\t     strerror (errno));\n  \t}\n  \n  \tYCPByteblock ret = YCPByteblock (buffer, filesize);\n  \tfree (buffer);\n  \tclose (fd);\n  \treturn ret;\n      }\n  \n      else if (cmd == \"ycp\" || cmd == \"yast2\")\n      {\n  \t/**\n  \t * @builtin Read (.target.ycp, string filename) -> any\n  \t * @builtin Read (.target.ycp, string filename, [any default = nil]) -> any\n  \t * Opens a file that must be in YCP syntax and contain exactly\n  \t * one value, parses that file and returns the parsed value.\n  \t * Returns 'default', if the file didn't exist, was not readable or\n  \t * didn't not contain a valid YCP value.\n  \t * A warning in the log is omitted if a default value is given.\n  \t */\n  \n  \t/**\n  \t * @builtin Read (.target.yast2, string filename) -> any\n  \t * @builtin Read (.target.yast2, string filename, [any default = nil]) -> any\n  \t * Opens a file that must be in YCP syntax and contain exactly\n  \t * one value, parses that file and returns the parsed value.\n  \t * Returns default, if the file didn't exist, was not readable or\n  \t * did not contain a valid YCP value.\n  \t *\n  \t * The purpose of this function is to load data located in\n  \t * ydatadir. The data may also be located in any of the paths in\n  \t * source/core/liby2/src/pathsearch.cc appended by \"data/\".\n  \t * The filename must be relative to one of those paths.\n  \t *\n  \t * A warning in the log is omitted if a default value is given.\n  \t */\n  \n  \tif (cmd == \"yast2\")\n  \t{\n  \t    string tmp = Y2PathSearch::findy2 (\"data/\" + filename); // FIXME use ydatadir\n  \t    if (!tmp.empty ())\n  \t    {\n  \t\tfilename = tmp;\n  \t    }\n  \t    else\n  \t    {\n  \t\tif (!default_value.isNull ())\n  \t\t{\n  \t\t    return default_value;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t    return YCPError (\"can't find '\" + filename + \"'\");\n  \t\t}\n  \t    }\n  \t}\n  \n  \tint fd = open (filename.c_str (), O_RDONLY);\n  \tif (fd < 0)\n  \t{\n  \t    if (!default_value.isNull())\n  \t    {\n  \t\treturn default_value;\n  \t    }\n  \t    else\n  \t    {\n  \t\treturn YCPError (\"Open file '\" + filename + \"' failed: \" + strerror (errno));\n  \t    }\n  \t}\n  \tParser parser (fd, filename.c_str ());\n  \tparser.setBuffered(); // Read from file. Buffering is always possible here\n  \tYCodePtr p = parser.parse();\n  \tclose(fd);\n  \t\n  \tif (!p)\n  \t{\treturn YCPError (\"Parsing file '\" + filename + \"' failed\");\n  \t}\n  \t\n  \tYCPValue contents = YCPNull ();\n  \tif (p->isBlock ())\n  \t{\n  \t    contents = YCPCode (p);\n  \t}\n  \telse\n  \t{\n  \t    contents = p->evaluate (true);\n  \t}\n  \n  \treturn !contents.isNull() ? contents : YCPVoid();\n      }\n  \n      else if (cmd == \"dir\")\n      {\n  \t/**\n  \t * @builtin Read (.target.dir, string path) -> list\n  \t * @builtin Read (.target.dir, [string path, list default]) -> list\n  \t * Reads a directory. Returns a list of strings, one string for\n  \t * each file contained in the directory path is pointing to.\n  \t * The entries '.' and '..' are NOT returned. Returns nil and\n  \t * doesn't log an error, if path does not point to a readable\n  \t * directory.\n  \t * If a default value is given, this is returned if path isn't\n  \t * accessible.\n  \t *\n  \t * @example Read (.target.dir, \"/proc/self\") -> [ \"cmdline\", \"cwd\", \"environ\", ... ]\n  \t */\n  \n  \tDIR *dir = opendir (filename.c_str());\n  \tif (!dir)\n  \t{\n  \t    if (!default_value.isNull())\n  \t    {\n  \t\treturn default_value;\n  \t    }\n  \t    y2milestone (\"Can't access directory '%s': %s'\"\n  \t\t, filename.c_str (), strerror (errno));\n  \t    return YCPVoid ();\n  \t}\n  \n  \tYCPList dirlist;\n  \tstruct dirent *entry;\n  \twhile ((entry = readdir (dir)))\n  \t{\n  \t    if (!strcmp(entry->d_name, \".\") || !(strcmp(entry->d_name, \"..\")))\n  \t\tcontinue;\n  \t    dirlist->add (YCPString (entry->d_name));\n  \t}\n  \tclosedir (dir);\n  \treturn dirlist;\n      }\n  \n      else if (cmd == \"size\")\n      {\n  \t/**\n  \t * @builtin Read (.target.size, string filename) -> integer\n  \t * return current size of file\n  \t * returns -1 if the file does not exist\n  \t */\n  \n  \tstruct stat sb;\n  \tlong long retval = stat (filename.c_str (), &sb);\n  \tif (retval == 0)\n  \t{\n  \t    retval = sb.st_size;\n  \t}\n  \treturn YCPInteger (retval);\n      }\n  \n      else if (cmd == \"stat\")\n      {\n  \t/**\n  \t * @builtin Read (.target.stat, string filename) -> map\n  \t * Return a map with file information (see stat(2)). If\n  \t * the file does not exist return an empty map.\n  \t */\n  \n  \tYCPMap result;\n  \n  \tstruct stat sb;\n  \tif (stat (filename.c_str (), &sb) == 0)\n  \t{\n  \t    result = stat2map (sb);\n  \t}\n  \n  \treturn result;\n      }\n  \n      else if (cmd == \"lstat\")\n      {\n  \t/**\n  \t * @builtin Read (.target.lstat, string filename) -> map\n  \t * Return a map with file information (see stat(2)). If\n  \t * the file does not exist return an empty map.\n  \t */\n  \n  \tYCPMap result;\n  \n  \tstruct stat sb;\n  \tif (lstat (filename.c_str (), &sb) == 0)\n  \t{\n  \t    result = stat2map (sb);\n  \t}\n  \n  \treturn result;\n      }\n  \n      else if (cmd == \"symlink\")\n      {\n  \t/**\n  \t * @builtin Read (.target.symlink, string filename) -> string\n  \t *\n  \t * Returns the content of the symbolic link filename. If the filename\n  \t * does not exist or is no symbolic link, nil is returned and an error\n  \t * logged.\n  \t *\n  \t * @example Read (.target.symlink, \"/var/X11R6/bin/X\")\n  \t */\n  \n  \tconst int size = 1024;\n  \tchar buffer[size];\n  \tint ret = readlink (filename.c_str (), buffer, size - 1);\n  \n  \tif (ret == -1)\n  \t{\n  \t    return YCPError (string (\"failed to read symlink \") + filename +\n  \t\t\t     \": \" + strerror (errno));\n  \t}\n  \n  \tbuffer[ret] = '\\0';\n  \treturn YCPString (buffer);\n      }\n  \n      return YCPError (string(\"Undefined subpath for Read (\") + path->toString() + \")\");\n  }\n}"
  },
  {
    "function_name": "dump_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
    "lines": "247-298",
    "snippet": "string\ndump_value (int level, const YCPValue& value)\n{\n    string ret = \"\";\n\n    if (value.isNull())\n\treturn \"\";\n\n    y2debug ( \"%s\\n\", value->toString ().c_str ());\n\n    switch (value->valuetype()) {\n\tcase YT_LIST:\n\t    {\n\t    YCPList list = value->asList ();\n\t    ret += \"[\";\n\t    for (int i = 0; i < list->size (); i++) {\n\t\tret += \"\\n\";\n\t\tret += indent_output (level+1);\n\t\tret += dump_value (level+1, list->value (i));\n\t\tif ( i != list->size()-1)\n\t\t    ret += \",\";\n\t    }\n\t    ret += \"\\n\";\n\t    ret += indent_output (level);\n\t    ret += \"]\";\n\t    }\n\t    break;\n\tcase YT_MAP:\n\t    {\n\t    YCPMap map = value->asMap ();\n\t    ret += \"$[\";\n\t    for (YCPMap::const_iterator i = map->begin(); i != map->end(); i++) {\n\t\tif ( i != map->begin () )\n\t\t    ret += \",\";\n\t\tret += \"\\n\";\n\t\tret += indent_output (level+1);\n\t\tret += dump_value (level+1, i->first);\n\t\tret += \" : \";\n\t\tret += dump_value (level+1, i->second);\n\t    }\n\t    ret += \"\\n\";\n\t    ret += indent_output (level);\n\t    ret += \"]\";\n\t    }\n\t    break;\n\tdefault:\n\t    ret = value->toString ().c_str ();\n\t    break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"ShellCommand.h\"",
      "#include \"SystemAgent.h\"",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/pathsearch.h>",
      "#include <YCP.h>",
      "#include <stdexcept>",
      "#include <sstream>",
      "#include <string>",
      "#include <linux/lp.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <resolv.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "indent_output",
          "args": [
            "level"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "indent_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
          "lines": "235-242",
          "snippet": "string\nindent_output (int level)\n{\n    string ret = \"\";\n    while (level-- > 0)\n\tret += \"  \";\n    return ret;\n}",
          "includes": [
            "#include \"ShellCommand.h\"",
            "#include \"SystemAgent.h\"",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/pathsearch.h>",
            "#include <YCP.h>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <string>",
            "#include <linux/lp.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <resolv.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstring\nindent_output (int level)\n{\n    string ret = \"\";\n    while (level-- > 0)\n\tret += \"  \";\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_value",
          "args": [
            "level+1",
            "i->second"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "dump_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
          "lines": "247-298",
          "snippet": "string\ndump_value (int level, const YCPValue& value)\n{\n    string ret = \"\";\n\n    if (value.isNull())\n\treturn \"\";\n\n    y2debug ( \"%s\\n\", value->toString ().c_str ());\n\n    switch (value->valuetype()) {\n\tcase YT_LIST:\n\t    {\n\t    YCPList list = value->asList ();\n\t    ret += \"[\";\n\t    for (int i = 0; i < list->size (); i++) {\n\t\tret += \"\\n\";\n\t\tret += indent_output (level+1);\n\t\tret += dump_value (level+1, list->value (i));\n\t\tif ( i != list->size()-1)\n\t\t    ret += \",\";\n\t    }\n\t    ret += \"\\n\";\n\t    ret += indent_output (level);\n\t    ret += \"]\";\n\t    }\n\t    break;\n\tcase YT_MAP:\n\t    {\n\t    YCPMap map = value->asMap ();\n\t    ret += \"$[\";\n\t    for (YCPMap::const_iterator i = map->begin(); i != map->end(); i++) {\n\t\tif ( i != map->begin () )\n\t\t    ret += \",\";\n\t\tret += \"\\n\";\n\t\tret += indent_output (level+1);\n\t\tret += dump_value (level+1, i->first);\n\t\tret += \" : \";\n\t\tret += dump_value (level+1, i->second);\n\t    }\n\t    ret += \"\\n\";\n\t    ret += indent_output (level);\n\t    ret += \"]\";\n\t    }\n\t    break;\n\tdefault:\n\t    ret = value->toString ().c_str ();\n\t    break;\n    }\n\n    return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "map->begin",
          "args": [],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->end",
          "args": [],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asMap",
          "args": [],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->size",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list->value",
          "args": [
            "i"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asList",
          "args": [],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->valuetype",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "YCPSymbolRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "69-73",
          "snippet": "YCPValueType\nYCPSymbolRep::valuetype() const\n{\n    return YT_SYMBOL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbolRep {\n  YCPValueType\n  YCPSymbolRep::valuetype() const\n  {\n      return YT_SYMBOL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"%s\\n\"",
            "value->toString ().c_str ()"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstring\ndump_value (int level, const YCPValue& value)\n{\n    string ret = \"\";\n\n    if (value.isNull())\n\treturn \"\";\n\n    y2debug ( \"%s\\n\", value->toString ().c_str ());\n\n    switch (value->valuetype()) {\n\tcase YT_LIST:\n\t    {\n\t    YCPList list = value->asList ();\n\t    ret += \"[\";\n\t    for (int i = 0; i < list->size (); i++) {\n\t\tret += \"\\n\";\n\t\tret += indent_output (level+1);\n\t\tret += dump_value (level+1, list->value (i));\n\t\tif ( i != list->size()-1)\n\t\t    ret += \",\";\n\t    }\n\t    ret += \"\\n\";\n\t    ret += indent_output (level);\n\t    ret += \"]\";\n\t    }\n\t    break;\n\tcase YT_MAP:\n\t    {\n\t    YCPMap map = value->asMap ();\n\t    ret += \"$[\";\n\t    for (YCPMap::const_iterator i = map->begin(); i != map->end(); i++) {\n\t\tif ( i != map->begin () )\n\t\t    ret += \",\";\n\t\tret += \"\\n\";\n\t\tret += indent_output (level+1);\n\t\tret += dump_value (level+1, i->first);\n\t\tret += \" : \";\n\t\tret += dump_value (level+1, i->second);\n\t    }\n\t    ret += \"\\n\";\n\t    ret += indent_output (level);\n\t    ret += \"]\";\n\t    }\n\t    break;\n\tdefault:\n\t    ret = value->toString ().c_str ();\n\t    break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "indent_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
    "lines": "235-242",
    "snippet": "string\nindent_output (int level)\n{\n    string ret = \"\";\n    while (level-- > 0)\n\tret += \"  \";\n    return ret;\n}",
    "includes": [
      "#include \"ShellCommand.h\"",
      "#include \"SystemAgent.h\"",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/pathsearch.h>",
      "#include <YCP.h>",
      "#include <stdexcept>",
      "#include <sstream>",
      "#include <string>",
      "#include <linux/lp.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <resolv.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstring\nindent_output (int level)\n{\n    string ret = \"\";\n    while (level-- > 0)\n\tret += \"  \";\n    return ret;\n}"
  },
  {
    "function_name": "shellcommand_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
    "lines": "204-229",
    "snippet": "static YCPMap\nshellcommand_output (const string& script, const string& tempdir)\n{\n    int ret = shellcommand (script, tempdir);\n\n    string output_stdout;\n    int ret1 = read_file_to_string (string (tempdir + \"/stdout\").c_str (), output_stdout);\n    if (ret1 != 0)\n    {\n\ty2error (\"open for %s failed: %s/stdout\", tempdir.c_str (), strerror (ret1));\n    }\n\n    string output_stderr;\n    int ret2 = read_file_to_string (string (tempdir + \"/stderr\").c_str (), output_stderr);\n    if (ret2 != 0)\n    {\n\ty2error (\"open for %s failed: %s/stderr\", tempdir.c_str (), strerror (ret2));\n    }\n\n    YCPMap result;\n    result->add (YCPString (\"exit\"), YCPInteger (ret));\n    result->add (YCPString (\"stdout\"), YCPString (output_stdout));\n    result->add (YCPString (\"stderr\"), YCPString (output_stderr));\n\n    return result;\n}",
    "includes": [
      "#include \"ShellCommand.h\"",
      "#include \"SystemAgent.h\"",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/pathsearch.h>",
      "#include <YCP.h>",
      "#include <stdexcept>",
      "#include <sstream>",
      "#include <string>",
      "#include <linux/lp.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <resolv.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result->add",
          "args": [
            "YCPString (\"stderr\")",
            "YCPString (output_stderr)"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "50-76",
          "snippet": "void\nYCPMapRep::add (const YCPValue& key, const YCPValue& value)\n{\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn;\n    }\n\n    // Note: 'stl_map[key] = value' would create a temporary object using the\n    // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n    // 24.\n\n    YCPMap::iterator pos = stl_map.lower_bound(key);\n    if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n    {\n\tpos->second = value;\n    }\n    else\n    {\n\t// pos is just a hint but can avoid a second search through the map\n\tstl_map.insert(pos, YCPMap::value_type(key, value));\n    }\n\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void\n  YCPMapRep::add (const YCPValue& key, const YCPValue& value)\n  {\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn;\n      }\n  \n      // Note: 'stl_map[key] = value' would create a temporary object using the\n      // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n      // 24.\n  \n      YCPMap::iterator pos = stl_map.lower_bound(key);\n      if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n      {\n  \tpos->second = value;\n      }\n      else\n      {\n  \t// pos is just a hint but can avoid a second search through the map\n  \tstl_map.insert(pos, YCPMap::value_type(key, value));\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "output_stderr"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPInteger",
          "args": [
            "ret"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "YCPInteger",
          "container": "YCPInteger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPInteger.cc",
          "lines": "142-145",
          "snippet": "YCPInteger::YCPInteger (bytecodeistream & str)\n    : YCPValue (new YCPIntegerRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/y2log.h\"\n\nYCPInteger {\n  YCPInteger::YCPInteger (bytecodeistream & str)\n      : YCPValue (new YCPIntegerRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"open for %s failed: %s/stderr\"",
            "tempdir.c_str ()",
            "strerror (ret2)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "ret2"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tempdir.c_str",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_file_to_string",
          "args": [
            "string (tempdir + \"/stderr\").c_str ()",
            "output_stderr"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "read_file_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
          "lines": "145-165",
          "snippet": "static int read_file_to_string (const char* filename, string& output)\n{\n    int fd = open (filename, O_RDONLY);\n    output = \"\";\n    if (fd < 0)\n    {\n\treturn errno;\n    }\n\n    while (true)\n    {\n\tchar buffer[4096];\n\tssize_t bytes_read = read (fd, buffer, 4095);\n\tif (bytes_read <= 0)\n\t    break;\n\tbuffer[bytes_read] = 0; // 0 terminate string\n\toutput += buffer;\n    }\n    close(fd);\n    return 0;\n}",
          "includes": [
            "#include \"ShellCommand.h\"",
            "#include \"SystemAgent.h\"",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/pathsearch.h>",
            "#include <YCP.h>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <string>",
            "#include <linux/lp.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <resolv.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int read_file_to_string (const char* filename, string& output)\n{\n    int fd = open (filename, O_RDONLY);\n    output = \"\";\n    if (fd < 0)\n    {\n\treturn errno;\n    }\n\n    while (true)\n    {\n\tchar buffer[4096];\n\tssize_t bytes_read = read (fd, buffer, 4095);\n\tif (bytes_read <= 0)\n\t    break;\n\tbuffer[bytes_read] = 0; // 0 terminate string\n\toutput += buffer;\n    }\n    close(fd);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "tempdir + \"/stderr\""
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"open for %s failed: %s/stdout\"",
            "tempdir.c_str ()",
            "strerror (ret1)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "ret1"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tempdir.c_str",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shellcommand",
          "args": [
            "script",
            "tempdir"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "shellcommand_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
          "lines": "204-229",
          "snippet": "static YCPMap\nshellcommand_output (const string& script, const string& tempdir)\n{\n    int ret = shellcommand (script, tempdir);\n\n    string output_stdout;\n    int ret1 = read_file_to_string (string (tempdir + \"/stdout\").c_str (), output_stdout);\n    if (ret1 != 0)\n    {\n\ty2error (\"open for %s failed: %s/stdout\", tempdir.c_str (), strerror (ret1));\n    }\n\n    string output_stderr;\n    int ret2 = read_file_to_string (string (tempdir + \"/stderr\").c_str (), output_stderr);\n    if (ret2 != 0)\n    {\n\ty2error (\"open for %s failed: %s/stderr\", tempdir.c_str (), strerror (ret2));\n    }\n\n    YCPMap result;\n    result->add (YCPString (\"exit\"), YCPInteger (ret));\n    result->add (YCPString (\"stdout\"), YCPString (output_stdout));\n    result->add (YCPString (\"stderr\"), YCPString (output_stderr));\n\n    return result;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic YCPMap\nshellcommand_output (const string& script, const string& tempdir)\n{\n    int ret = shellcommand (script, tempdir);\n\n    string output_stdout;\n    int ret1 = read_file_to_string (string (tempdir + \"/stdout\").c_str (), output_stdout);\n    if (ret1 != 0)\n    {\n\ty2error (\"open for %s failed: %s/stdout\", tempdir.c_str (), strerror (ret1));\n    }\n\n    string output_stderr;\n    int ret2 = read_file_to_string (string (tempdir + \"/stderr\").c_str (), output_stderr);\n    if (ret2 != 0)\n    {\n\ty2error (\"open for %s failed: %s/stderr\", tempdir.c_str (), strerror (ret2));\n    }\n\n    YCPMap result;\n    result->add (YCPString (\"exit\"), YCPInteger (ret));\n    result->add (YCPString (\"stdout\"), YCPString (output_stdout));\n    result->add (YCPString (\"stderr\"), YCPString (output_stderr));\n\n    return result;\n}"
  },
  {
    "function_name": "stat2map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
    "lines": "171-198",
    "snippet": "static YCPMap\nstat2map (const struct stat& sb)\n{\n    YCPMap result;\n\n    result->add (YCPString (\"inode\"), YCPInteger (sb.st_ino));\n\n    result->add (YCPString (\"isreg\"), YCPBoolean (S_ISREG (sb.st_mode)));\n    result->add (YCPString (\"isdir\"), YCPBoolean (S_ISDIR (sb.st_mode)));\n    result->add (YCPString (\"ischr\"), YCPBoolean (S_ISCHR (sb.st_mode)));\n    result->add (YCPString (\"isblock\"), YCPBoolean (S_ISBLK (sb.st_mode)));\n    result->add (YCPString (\"isfifo\"), YCPBoolean (S_ISFIFO (sb.st_mode)));\n    result->add (YCPString (\"islink\"), YCPBoolean (S_ISLNK (sb.st_mode)));\n    result->add (YCPString (\"issock\"), YCPBoolean (S_ISSOCK (sb.st_mode)));\n\n    result->add (YCPString (\"nlink\"), YCPInteger (sb.st_nlink));\n\n    result->add (YCPString (\"uid\"), YCPInteger (sb.st_uid));\n    result->add (YCPString (\"gid\"), YCPInteger (sb.st_gid));\n\n    result->add (YCPString (\"size\"), YCPInteger (sb.st_size));\n\n    result->add (YCPString (\"atime\"), YCPInteger (sb.st_atime));\n    result->add (YCPString (\"mtime\"), YCPInteger (sb.st_mtime));\n    result->add (YCPString (\"ctime\"), YCPInteger (sb.st_ctime));\n\n    return result;\n}",
    "includes": [
      "#include \"ShellCommand.h\"",
      "#include \"SystemAgent.h\"",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/pathsearch.h>",
      "#include <YCP.h>",
      "#include <stdexcept>",
      "#include <sstream>",
      "#include <string>",
      "#include <linux/lp.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <resolv.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result->add",
          "args": [
            "YCPString (\"ctime\")",
            "YCPInteger (sb.st_ctime)"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "50-76",
          "snippet": "void\nYCPMapRep::add (const YCPValue& key, const YCPValue& value)\n{\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn;\n    }\n\n    // Note: 'stl_map[key] = value' would create a temporary object using the\n    // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n    // 24.\n\n    YCPMap::iterator pos = stl_map.lower_bound(key);\n    if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n    {\n\tpos->second = value;\n    }\n    else\n    {\n\t// pos is just a hint but can avoid a second search through the map\n\tstl_map.insert(pos, YCPMap::value_type(key, value));\n    }\n\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void\n  YCPMapRep::add (const YCPValue& key, const YCPValue& value)\n  {\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn;\n      }\n  \n      // Note: 'stl_map[key] = value' would create a temporary object using the\n      // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n      // 24.\n  \n      YCPMap::iterator pos = stl_map.lower_bound(key);\n      if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n      {\n  \tpos->second = value;\n      }\n      else\n      {\n  \t// pos is just a hint but can avoid a second search through the map\n  \tstl_map.insert(pos, YCPMap::value_type(key, value));\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPInteger",
          "args": [
            "sb.st_ctime"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "YCPInteger",
          "container": "YCPInteger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPInteger.cc",
          "lines": "142-145",
          "snippet": "YCPInteger::YCPInteger (bytecodeistream & str)\n    : YCPValue (new YCPIntegerRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/y2log.h\"\n\nYCPInteger {\n  YCPInteger::YCPInteger (bytecodeistream & str)\n      : YCPValue (new YCPIntegerRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "\"ctime\""
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "S_ISSOCK (sb.st_mode)"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "sb.st_mode"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "sb.st_mode"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "sb.st_mode"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "sb.st_mode"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "sb.st_mode"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sb.st_mode"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "sb.st_mode"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic YCPMap\nstat2map (const struct stat& sb)\n{\n    YCPMap result;\n\n    result->add (YCPString (\"inode\"), YCPInteger (sb.st_ino));\n\n    result->add (YCPString (\"isreg\"), YCPBoolean (S_ISREG (sb.st_mode)));\n    result->add (YCPString (\"isdir\"), YCPBoolean (S_ISDIR (sb.st_mode)));\n    result->add (YCPString (\"ischr\"), YCPBoolean (S_ISCHR (sb.st_mode)));\n    result->add (YCPString (\"isblock\"), YCPBoolean (S_ISBLK (sb.st_mode)));\n    result->add (YCPString (\"isfifo\"), YCPBoolean (S_ISFIFO (sb.st_mode)));\n    result->add (YCPString (\"islink\"), YCPBoolean (S_ISLNK (sb.st_mode)));\n    result->add (YCPString (\"issock\"), YCPBoolean (S_ISSOCK (sb.st_mode)));\n\n    result->add (YCPString (\"nlink\"), YCPInteger (sb.st_nlink));\n\n    result->add (YCPString (\"uid\"), YCPInteger (sb.st_uid));\n    result->add (YCPString (\"gid\"), YCPInteger (sb.st_gid));\n\n    result->add (YCPString (\"size\"), YCPInteger (sb.st_size));\n\n    result->add (YCPString (\"atime\"), YCPInteger (sb.st_atime));\n    result->add (YCPString (\"mtime\"), YCPInteger (sb.st_mtime));\n    result->add (YCPString (\"ctime\"), YCPInteger (sb.st_ctime));\n\n    return result;\n}"
  },
  {
    "function_name": "read_file_to_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
    "lines": "145-165",
    "snippet": "static int read_file_to_string (const char* filename, string& output)\n{\n    int fd = open (filename, O_RDONLY);\n    output = \"\";\n    if (fd < 0)\n    {\n\treturn errno;\n    }\n\n    while (true)\n    {\n\tchar buffer[4096];\n\tssize_t bytes_read = read (fd, buffer, 4095);\n\tif (bytes_read <= 0)\n\t    break;\n\tbuffer[bytes_read] = 0; // 0 terminate string\n\toutput += buffer;\n    }\n    close(fd);\n    return 0;\n}",
    "includes": [
      "#include \"ShellCommand.h\"",
      "#include \"SystemAgent.h\"",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/pathsearch.h>",
      "#include <YCP.h>",
      "#include <stdexcept>",
      "#include <sstream>",
      "#include <string>",
      "#include <linux/lp.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <resolv.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buffer",
            "4095"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "read_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2crypt.cc",
          "lines": "25-50",
          "snippet": "static int\nread_loop (int fd, char* buffer, int count)\n{\n    int offset, block;\n\n    offset = 0;\n    while (count > 0)\n    {\n\tblock = read (fd, &buffer[offset], count);\n\n\tif (block < 0)\n\t{\n\t    if (errno == EINTR)\n\t\tcontinue;\n\t    return block;\n\t}\n\n\tif (!block)\n\t    return offset;\n\n\toffset += block;\n\tcount -= block;\n    }\n\n    return offset;\n}",
          "includes": [
            "#include \"y2crypt.h\"",
            "#include \"y2log.h\"",
            "#include <xcrypt.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2crypt.h\"\n#include \"y2log.h\"\n#include <xcrypt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int\nread_loop (int fd, char* buffer, int count)\n{\n    int offset, block;\n\n    offset = 0;\n    while (count > 0)\n    {\n\tblock = read (fd, &buffer[offset], count);\n\n\tif (block < 0)\n\t{\n\t    if (errno == EINTR)\n\t\tcontinue;\n\t    return block;\n\t}\n\n\tif (!block)\n\t    return offset;\n\n\toffset += block;\n\tcount -= block;\n    }\n\n    return offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename",
            "O_RDONLY"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int read_file_to_string (const char* filename, string& output)\n{\n    int fd = open (filename, O_RDONLY);\n    output = \"\";\n    if (fd < 0)\n    {\n\treturn errno;\n    }\n\n    while (true)\n    {\n\tchar buffer[4096];\n\tssize_t bytes_read = read (fd, buffer, 4095);\n\tif (bytes_read <= 0)\n\t    break;\n\tbuffer[bytes_read] = 0; // 0 terminate string\n\toutput += buffer;\n    }\n    close(fd);\n    return 0;\n}"
  },
  {
    "function_name": "~SystemAgent",
    "container": "SystemAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
    "lines": "135-139",
    "snippet": "SystemAgent::~SystemAgent ()\n{\n    // remove temp directory and all its subdirectories.\n    remove_directory (tempdir.c_str(), 20);\n}",
    "includes": [
      "#include \"ShellCommand.h\"",
      "#include \"SystemAgent.h\"",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/pathsearch.h>",
      "#include <YCP.h>",
      "#include <stdexcept>",
      "#include <sstream>",
      "#include <string>",
      "#include <linux/lp.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <resolv.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_directory",
          "args": [
            "tempdir.c_str()",
            "20"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "remove_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
          "lines": "66-101",
          "snippet": "static void\nremove_directory (const string& path, int depth)\n{\n    struct stat buf;\n    if (!depth)     // check for too many nested directories\n\treturn;\n    if (lstat (path.c_str(), &buf)) // we do not want to follow symlinks\n    {\n\ty2error (\"Can't stat %s: %s\", path.c_str(), strerror(errno));\n\treturn;\n    }\n    if (S_ISDIR (buf.st_mode))\n    { // directory, process all files\n\tstring filename;\n\tstruct dirent **eps;\n\tint len;\n\n\tlen = scandir (path.c_str(), &eps, return_one, alphasort);\n\tif (len >= 0)\n\t{\n\t    int i;\n\t    for (i = 0; i < len; i++)\n\t    {\n\t\tfilename = path + '/' + eps[i]->d_name;\n\t\tremove_directory (filename, depth-1);\n\t    }\n\t}\n\telse\n\t{\n\t    y2error (\"Can't scandir %s: %s\", path.c_str(), strerror(errno));\n\t}\n    }\n    // remove file\n    y2debug (\"Removing temporary file %s\", path.c_str());\n    remove (path.c_str());\n}",
          "includes": [
            "#include \"ShellCommand.h\"",
            "#include \"SystemAgent.h\"",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/pathsearch.h>",
            "#include <YCP.h>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <string>",
            "#include <linux/lp.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <resolv.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void\nremove_directory (const string& path, int depth)\n{\n    struct stat buf;\n    if (!depth)     // check for too many nested directories\n\treturn;\n    if (lstat (path.c_str(), &buf)) // we do not want to follow symlinks\n    {\n\ty2error (\"Can't stat %s: %s\", path.c_str(), strerror(errno));\n\treturn;\n    }\n    if (S_ISDIR (buf.st_mode))\n    { // directory, process all files\n\tstring filename;\n\tstruct dirent **eps;\n\tint len;\n\n\tlen = scandir (path.c_str(), &eps, return_one, alphasort);\n\tif (len >= 0)\n\t{\n\t    int i;\n\t    for (i = 0; i < len; i++)\n\t    {\n\t\tfilename = path + '/' + eps[i]->d_name;\n\t\tremove_directory (filename, depth-1);\n\t    }\n\t}\n\telse\n\t{\n\t    y2error (\"Can't scandir %s: %s\", path.c_str(), strerror(errno));\n\t}\n    }\n    // remove file\n    y2debug (\"Removing temporary file %s\", path.c_str());\n    remove (path.c_str());\n}"
        }
      },
      {
        "call_info": {
          "callee": "tempdir.c_str",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nSystemAgent {\n  SystemAgent::~SystemAgent ()\n  {\n      // remove temp directory and all its subdirectories.\n      remove_directory (tempdir.c_str(), 20);\n  }\n}"
  },
  {
    "function_name": "SystemAgent",
    "container": "SystemAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
    "lines": "110-129",
    "snippet": "SystemAgent::SystemAgent ()\n{\n    // #237481: problems with pids with too many digits: 64bits: max 20 digits\n    char tmp1[19+20];\n    snprintf (tmp1, sizeof(tmp1), \"/tmp/YaST2-%05d-XXXXXX\", getpid ());\n\n    const char* tmp2 = mkdtemp (tmp1);\n    if (!tmp2)\n    {\n\tstd::ostringstream stm;\n\tstm << \"Cannot create temporary directory \" << tmp1 << ':'\n\t    << strerror (errno);\n\ty2error (\"%s\", stm.str().c_str());\n\t// #343258: terminate will print the uncaught exception too, unlike plain exit\n\tthrow std::runtime_error (stm.str());\n    }\n\n    tempdir = tmp2;\n    y2debug (\"tmp directory is %s\", tempdir.c_str ());\n}",
    "includes": [
      "#include \"ShellCommand.h\"",
      "#include \"SystemAgent.h\"",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/pathsearch.h>",
      "#include <YCP.h>",
      "#include <stdexcept>",
      "#include <sstream>",
      "#include <string>",
      "#include <linux/lp.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <resolv.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"tmp directory is %s\"",
            "tempdir.c_str ()"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tempdir.c_str",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::runtime_error",
          "args": [
            "stm.str()"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stm.str",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": "DirStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/Pathname.cc",
          "lines": "102-114",
          "snippet": "string str() {\n      if ( !bot )\n\treturn \"\";\n      string ret;\n      for ( Dir * d = bot; d; d = d->up ) {\n\tif ( d != bot )\n\t  ret += \"/\";\n\tret += d->name;\n      }\n      if ( ret.empty() )\n\treturn \"/\";\n      return ret;\n    }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <iostream>\n\nDirStack {\n  string str() {\n        if ( !bot )\n  \treturn \"\";\n        string ret;\n        for ( Dir * d = bot; d; d = d->up ) {\n  \tif ( d != bot )\n  \t  ret += \"/\";\n  \tret += d->name;\n        }\n        if ( ret.empty() )\n  \treturn \"/\";\n        return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"%s\"",
            "stm.str().c_str()"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdtemp",
          "args": [
            "tmp1"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmp1",
            "sizeof(tmp1)",
            "\"/tmp/YaST2-%05d-XXXXXX\"",
            "getpid ()"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "getpid",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/ExternalProgram.h",
          "lines": "109-109",
          "snippet": "pid_t getpid() { return pid; }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <y2util/ExternalDataSource.h>",
            "#include <string>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <y2util/ExternalDataSource.h>\n#include <string>\n#include <map>\n\nExternalProgram {\n  pid_t getpid() { return pid; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nSystemAgent {\n  SystemAgent::SystemAgent ()\n  {\n      // #237481: problems with pids with too many digits: 64bits: max 20 digits\n      char tmp1[19+20];\n      snprintf (tmp1, sizeof(tmp1), \"/tmp/YaST2-%05d-XXXXXX\", getpid ());\n  \n      const char* tmp2 = mkdtemp (tmp1);\n      if (!tmp2)\n      {\n  \tstd::ostringstream stm;\n  \tstm << \"Cannot create temporary directory \" << tmp1 << ':'\n  \t    << strerror (errno);\n  \ty2error (\"%s\", stm.str().c_str());\n  \t// #343258: terminate will print the uncaught exception too, unlike plain exit\n  \tthrow std::runtime_error (stm.str());\n      }\n  \n      tempdir = tmp2;\n      y2debug (\"tmp directory is %s\", tempdir.c_str ());\n  }\n}"
  },
  {
    "function_name": "remove_directory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
    "lines": "66-101",
    "snippet": "static void\nremove_directory (const string& path, int depth)\n{\n    struct stat buf;\n    if (!depth)     // check for too many nested directories\n\treturn;\n    if (lstat (path.c_str(), &buf)) // we do not want to follow symlinks\n    {\n\ty2error (\"Can't stat %s: %s\", path.c_str(), strerror(errno));\n\treturn;\n    }\n    if (S_ISDIR (buf.st_mode))\n    { // directory, process all files\n\tstring filename;\n\tstruct dirent **eps;\n\tint len;\n\n\tlen = scandir (path.c_str(), &eps, return_one, alphasort);\n\tif (len >= 0)\n\t{\n\t    int i;\n\t    for (i = 0; i < len; i++)\n\t    {\n\t\tfilename = path + '/' + eps[i]->d_name;\n\t\tremove_directory (filename, depth-1);\n\t    }\n\t}\n\telse\n\t{\n\t    y2error (\"Can't scandir %s: %s\", path.c_str(), strerror(errno));\n\t}\n    }\n    // remove file\n    y2debug (\"Removing temporary file %s\", path.c_str());\n    remove (path.c_str());\n}",
    "includes": [
      "#include \"ShellCommand.h\"",
      "#include \"SystemAgent.h\"",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/pathsearch.h>",
      "#include <YCP.h>",
      "#include <stdexcept>",
      "#include <sstream>",
      "#include <string>",
      "#include <linux/lp.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <resolv.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove",
          "args": [
            "path.c_str()"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "remove",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "104-113",
          "snippet": "void YCPMapRep::remove(const YCPValue& key)\n{\n    if (!key->isString() && !key->isInteger() && !key->isSymbol())\n    {\n        ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n        return;\n    }\n\n    stl_map.erase (key);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void YCPMapRep::remove(const YCPValue& key)\n  {\n      if (!key->isString() && !key->isInteger() && !key->isSymbol())\n      {\n          ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n          return;\n      }\n  \n      stl_map.erase (key);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "path.c_str",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Removing temporary file %s\"",
            "path.c_str()"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.c_str",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Can't scandir %s: %s\"",
            "path.c_str()",
            "strerror(errno)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.c_str",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_directory",
          "args": [
            "filename",
            "depth-1"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "remove_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
          "lines": "66-101",
          "snippet": "static void\nremove_directory (const string& path, int depth)\n{\n    struct stat buf;\n    if (!depth)     // check for too many nested directories\n\treturn;\n    if (lstat (path.c_str(), &buf)) // we do not want to follow symlinks\n    {\n\ty2error (\"Can't stat %s: %s\", path.c_str(), strerror(errno));\n\treturn;\n    }\n    if (S_ISDIR (buf.st_mode))\n    { // directory, process all files\n\tstring filename;\n\tstruct dirent **eps;\n\tint len;\n\n\tlen = scandir (path.c_str(), &eps, return_one, alphasort);\n\tif (len >= 0)\n\t{\n\t    int i;\n\t    for (i = 0; i < len; i++)\n\t    {\n\t\tfilename = path + '/' + eps[i]->d_name;\n\t\tremove_directory (filename, depth-1);\n\t    }\n\t}\n\telse\n\t{\n\t    y2error (\"Can't scandir %s: %s\", path.c_str(), strerror(errno));\n\t}\n    }\n    // remove file\n    y2debug (\"Removing temporary file %s\", path.c_str());\n    remove (path.c_str());\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "scandir",
          "args": [
            "path.c_str()",
            "&eps",
            "return_one",
            "alphasort"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.c_str",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "buf.st_mode"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Can't stat %s: %s\"",
            "path.c_str()",
            "strerror(errno)"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.c_str",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "path.c_str()",
            "&buf"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.c_str",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic void\nremove_directory (const string& path, int depth)\n{\n    struct stat buf;\n    if (!depth)     // check for too many nested directories\n\treturn;\n    if (lstat (path.c_str(), &buf)) // we do not want to follow symlinks\n    {\n\ty2error (\"Can't stat %s: %s\", path.c_str(), strerror(errno));\n\treturn;\n    }\n    if (S_ISDIR (buf.st_mode))\n    { // directory, process all files\n\tstring filename;\n\tstruct dirent **eps;\n\tint len;\n\n\tlen = scandir (path.c_str(), &eps, return_one, alphasort);\n\tif (len >= 0)\n\t{\n\t    int i;\n\t    for (i = 0; i < len; i++)\n\t    {\n\t\tfilename = path + '/' + eps[i]->d_name;\n\t\tremove_directory (filename, depth-1);\n\t    }\n\t}\n\telse\n\t{\n\t    y2error (\"Can't scandir %s: %s\", path.c_str(), strerror(errno));\n\t}\n    }\n    // remove file\n    y2debug (\"Removing temporary file %s\", path.c_str());\n    remove (path.c_str());\n}"
  },
  {
    "function_name": "return_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
    "lines": "47-57",
    "snippet": "static int return_one (const struct dirent *entry)\n{\n    if ('.' == entry->d_name[0])\n    {\n\tif ('\\0' == entry->d_name[1])\n\t    return 0;\n\tif ('.' == entry->d_name[1] && '\\0' == entry->d_name[2])\n\t    return 0;\n    }\n    return 1;\n}",
    "includes": [
      "#include \"ShellCommand.h\"",
      "#include \"SystemAgent.h\"",
      "#include <ycp/y2log.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/pathsearch.h>",
      "#include <YCP.h>",
      "#include <stdexcept>",
      "#include <sstream>",
      "#include <string>",
      "#include <linux/lp.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <resolv.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int return_one (const struct dirent *entry)\n{\n    if ('.' == entry->d_name[0])\n    {\n\tif ('\\0' == entry->d_name[1])\n\t    return 0;\n\tif ('.' == entry->d_name[1] && '\\0' == entry->d_name[2])\n\t    return 0;\n    }\n    return 1;\n}"
  }
]