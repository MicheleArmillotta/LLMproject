[
  {
    "function_name": "otherCommand",
    "container": "StdioSCRAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/scr/src/StdioSCRAgent.cc",
    "lines": "219-228",
    "snippet": "YCPValue\nStdioSCRAgent::otherCommand (const YCPTerm &term)\n{\n    if (! m_handler)\n\treturn YCPNull ();\n\t\n    y2error( \"This is StdioSCRAgent(%p)::otherCommand (unhandled)\", this );\n    \n    return YCPNull ();\n}",
    "includes": [
      "#include \"StdioSCRAgent.h\"",
      "#include <y2/Y2Component.h>",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"This is StdioSCRAgent(%p)::otherCommand (unhandled)\"",
            "this"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"StdioSCRAgent.h\"\n#include <y2/Y2Component.h>\n#include <ycp/y2log.h>\n\nStdioSCRAgent {\n  YCPValue\n  StdioSCRAgent::otherCommand (const YCPTerm &term)\n  {\n      if (! m_handler)\n  \treturn YCPNull ();\n  \t\n      y2error( \"This is StdioSCRAgent(%p)::otherCommand (unhandled)\", this );\n      \n      return YCPNull ();\n  }\n}"
  },
  {
    "function_name": "UnregisterAgent",
    "container": "StdioSCRAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/scr/src/StdioSCRAgent.cc",
    "lines": "191-215",
    "snippet": "YCPBoolean\nStdioSCRAgent::UnregisterAgent (const YCPPath& path) {\n    if (! m_handler)\n\treturn YCPNull ();\n\t\n    y2debug( \"This is StdioSCRAgent(%p)::UnregisterAgent\", this );\n\n    YCPTerm r ( \"UnregisterAgent\" );\n    r.add (path);\n    \n    YCPValue v = m_handler->evaluate (r);\n\n    if (v.isNull())\n    {\n\tycp2error (\"SCR::UnregisterAgent() failed\");\n\treturn YCPNull ();\n    }\n    if (!v->isBoolean ())\n    {\n\tycp2error (\"SCR::UnregisterAgent() did not return a boolean (%s)\", v->toString().c_str());\n\treturn YCPNull ();\n    }\n\n    return v->asBoolean();\n}",
    "includes": [
      "#include \"StdioSCRAgent.h\"",
      "#include <y2/Y2Component.h>",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v->asBoolean",
          "args": [],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "asBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "94-104",
          "snippet": "YCPBoolean\nYCPValueRep::asBoolean() const\n{\n    if (!isBoolean())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPBoolean\n  YCPValueRep::asBoolean() const\n  {\n      if (!isBoolean())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"SCR::UnregisterAgent() did not return a boolean (%s)\"",
            "v->toString().c_str()"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->toString",
          "args": [],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->isBoolean",
          "args": [],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "isBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "62-62",
          "snippet": "bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"SCR::UnregisterAgent() failed\""
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_handler->evaluate",
          "args": [
            "r"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2AgentComp<Agent>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "91-166",
          "snippet": "YCPValue\nY2AgentComp<Agent>::evaluate (const YCPValue& v)\n{\n    y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n\n    if (!agent)\n\tgetSCRAgent ();\n\n    y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n\t\n    YCPValue value = v;\n    if (value->isCode ())\n    {\n\tYCodePtr c = v->asCode ()->code ();\n\n\t\n\tif ( c->kind () != YCode::yeTerm)\n\t{\n\t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n\t    value = value->asCode ()->evaluate ();\n\t    return value;\n\t}\n\n\tvalue = value->asCode ()->evaluate ();\n    }\n\t\n    if (value.isNull () || value->isVoid ())\n\treturn value;\n\n    y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n\n    if( value->isTerm () ) {\n\tYCPTerm term = value ->asTerm ();\n\tstring command = term->name ();\n\tYCPList args = term->args ();\n\n\t// evaluate the term in native functions\n\tif( command == \"Read\" ) {\n\t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n\t}\n\telse if( command == \"Write\" ) {\n\t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n\t}\n\telse if( command == \"Dir\" ) {\n\t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Error\" ) {\n\t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Execute\" ) {\n\t    y2debug( \"Execute, arg size is %d\", args->size() );\n\t    switch( args->size() ) {\n\t\tcase 1:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n\t\tcase 2:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n\t\tdefault:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n\t    }\n\t}\n\telse {\n\t    y2debug( \"Passing term to otherCommand\" );\n\t    return getSCRAgent ()-> otherCommand (term);\n\t}\n    }\n#if 0\n    if( value->isCode () ) {\n\ty2debug( \"Passing (evaluated) code to otherCommand\" );\n\treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n    }\n#endif\n\n    y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n\n    return YCPVoid();\n}",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp<Agent> {\n  YCPValue\n  Y2AgentComp<Agent>::evaluate (const YCPValue& v)\n  {\n      y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n  \n      if (!agent)\n  \tgetSCRAgent ();\n  \n      y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n  \t\n      YCPValue value = v;\n      if (value->isCode ())\n      {\n  \tYCodePtr c = v->asCode ()->code ();\n  \n  \t\n  \tif ( c->kind () != YCode::yeTerm)\n  \t{\n  \t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n  \t    value = value->asCode ()->evaluate ();\n  \t    return value;\n  \t}\n  \n  \tvalue = value->asCode ()->evaluate ();\n      }\n  \t\n      if (value.isNull () || value->isVoid ())\n  \treturn value;\n  \n      y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n  \n      if( value->isTerm () ) {\n  \tYCPTerm term = value ->asTerm ();\n  \tstring command = term->name ();\n  \tYCPList args = term->args ();\n  \n  \t// evaluate the term in native functions\n  \tif( command == \"Read\" ) {\n  \t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Write\" ) {\n  \t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Dir\" ) {\n  \t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Error\" ) {\n  \t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Execute\" ) {\n  \t    y2debug( \"Execute, arg size is %d\", args->size() );\n  \t    switch( args->size() ) {\n  \t\tcase 1:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n  \t\tcase 2:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n  \t\tdefault:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n  \t    }\n  \t}\n  \telse {\n  \t    y2debug( \"Passing term to otherCommand\" );\n  \t    return getSCRAgent ()-> otherCommand (term);\n  \t}\n      }\n  #if 0\n      if( value->isCode () ) {\n  \ty2debug( \"Passing (evaluated) code to otherCommand\" );\n  \treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n      }\n  #endif\n  \n      y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n  \n      return YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r.add",
          "args": [
            "path"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"This is StdioSCRAgent(%p)::UnregisterAgent\"",
            "this"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"StdioSCRAgent.h\"\n#include <y2/Y2Component.h>\n#include <ycp/y2log.h>\n\nStdioSCRAgent {\n  YCPBoolean\n  StdioSCRAgent::UnregisterAgent (const YCPPath& path) {\n      if (! m_handler)\n  \treturn YCPNull ();\n  \t\n      y2debug( \"This is StdioSCRAgent(%p)::UnregisterAgent\", this );\n  \n      YCPTerm r ( \"UnregisterAgent\" );\n      r.add (path);\n      \n      YCPValue v = m_handler->evaluate (r);\n  \n      if (v.isNull())\n      {\n  \tycp2error (\"SCR::UnregisterAgent() failed\");\n  \treturn YCPNull ();\n      }\n      if (!v->isBoolean ())\n      {\n  \tycp2error (\"SCR::UnregisterAgent() did not return a boolean (%s)\", v->toString().c_str());\n  \treturn YCPNull ();\n      }\n  \n      return v->asBoolean();\n  }\n}"
  },
  {
    "function_name": "RegisterAgent",
    "container": "StdioSCRAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/scr/src/StdioSCRAgent.cc",
    "lines": "162-187",
    "snippet": "YCPBoolean\nStdioSCRAgent::RegisterAgent (const YCPPath& path, const YCPValue& value) {\n    if (! m_handler)\n\treturn YCPNull ();\n\t\n    y2debug( \"This is StdioSCRAgent(%p)::RegisterAgent\", this );\n\n    YCPTerm r ( \"RegisterAgent\" );\n    r.add (path);\n    r.add (value);\n    \n    YCPValue v = m_handler->evaluate (r);\n\n    if (v.isNull())\n    {\n\tycp2error (\"SCR::RegisterAgent() failed\");\n\treturn YCPNull ();\n    }\n    if (!v->isBoolean ())\n    {\n\tycp2error (\"SCR::RegisterAgent() did not return a boolean (%s)\", v->toString().c_str());\n\treturn YCPNull ();\n    }\n\n    return v->asBoolean();\n}",
    "includes": [
      "#include \"StdioSCRAgent.h\"",
      "#include <y2/Y2Component.h>",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v->asBoolean",
          "args": [],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "asBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "94-104",
          "snippet": "YCPBoolean\nYCPValueRep::asBoolean() const\n{\n    if (!isBoolean())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPBoolean\n  YCPValueRep::asBoolean() const\n  {\n      if (!isBoolean())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"SCR::RegisterAgent() did not return a boolean (%s)\"",
            "v->toString().c_str()"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->toString",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->isBoolean",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "isBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "62-62",
          "snippet": "bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"SCR::RegisterAgent() failed\""
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_handler->evaluate",
          "args": [
            "r"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2AgentComp<Agent>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "91-166",
          "snippet": "YCPValue\nY2AgentComp<Agent>::evaluate (const YCPValue& v)\n{\n    y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n\n    if (!agent)\n\tgetSCRAgent ();\n\n    y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n\t\n    YCPValue value = v;\n    if (value->isCode ())\n    {\n\tYCodePtr c = v->asCode ()->code ();\n\n\t\n\tif ( c->kind () != YCode::yeTerm)\n\t{\n\t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n\t    value = value->asCode ()->evaluate ();\n\t    return value;\n\t}\n\n\tvalue = value->asCode ()->evaluate ();\n    }\n\t\n    if (value.isNull () || value->isVoid ())\n\treturn value;\n\n    y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n\n    if( value->isTerm () ) {\n\tYCPTerm term = value ->asTerm ();\n\tstring command = term->name ();\n\tYCPList args = term->args ();\n\n\t// evaluate the term in native functions\n\tif( command == \"Read\" ) {\n\t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n\t}\n\telse if( command == \"Write\" ) {\n\t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n\t}\n\telse if( command == \"Dir\" ) {\n\t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Error\" ) {\n\t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Execute\" ) {\n\t    y2debug( \"Execute, arg size is %d\", args->size() );\n\t    switch( args->size() ) {\n\t\tcase 1:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n\t\tcase 2:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n\t\tdefault:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n\t    }\n\t}\n\telse {\n\t    y2debug( \"Passing term to otherCommand\" );\n\t    return getSCRAgent ()-> otherCommand (term);\n\t}\n    }\n#if 0\n    if( value->isCode () ) {\n\ty2debug( \"Passing (evaluated) code to otherCommand\" );\n\treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n    }\n#endif\n\n    y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n\n    return YCPVoid();\n}",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp<Agent> {\n  YCPValue\n  Y2AgentComp<Agent>::evaluate (const YCPValue& v)\n  {\n      y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n  \n      if (!agent)\n  \tgetSCRAgent ();\n  \n      y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n  \t\n      YCPValue value = v;\n      if (value->isCode ())\n      {\n  \tYCodePtr c = v->asCode ()->code ();\n  \n  \t\n  \tif ( c->kind () != YCode::yeTerm)\n  \t{\n  \t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n  \t    value = value->asCode ()->evaluate ();\n  \t    return value;\n  \t}\n  \n  \tvalue = value->asCode ()->evaluate ();\n      }\n  \t\n      if (value.isNull () || value->isVoid ())\n  \treturn value;\n  \n      y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n  \n      if( value->isTerm () ) {\n  \tYCPTerm term = value ->asTerm ();\n  \tstring command = term->name ();\n  \tYCPList args = term->args ();\n  \n  \t// evaluate the term in native functions\n  \tif( command == \"Read\" ) {\n  \t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Write\" ) {\n  \t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Dir\" ) {\n  \t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Error\" ) {\n  \t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Execute\" ) {\n  \t    y2debug( \"Execute, arg size is %d\", args->size() );\n  \t    switch( args->size() ) {\n  \t\tcase 1:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n  \t\tcase 2:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n  \t\tdefault:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n  \t    }\n  \t}\n  \telse {\n  \t    y2debug( \"Passing term to otherCommand\" );\n  \t    return getSCRAgent ()-> otherCommand (term);\n  \t}\n      }\n  #if 0\n      if( value->isCode () ) {\n  \ty2debug( \"Passing (evaluated) code to otherCommand\" );\n  \treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n      }\n  #endif\n  \n      y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n  \n      return YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r.add",
          "args": [
            "value"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"This is StdioSCRAgent(%p)::RegisterAgent\"",
            "this"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"StdioSCRAgent.h\"\n#include <y2/Y2Component.h>\n#include <ycp/y2log.h>\n\nStdioSCRAgent {\n  YCPBoolean\n  StdioSCRAgent::RegisterAgent (const YCPPath& path, const YCPValue& value) {\n      if (! m_handler)\n  \treturn YCPNull ();\n  \t\n      y2debug( \"This is StdioSCRAgent(%p)::RegisterAgent\", this );\n  \n      YCPTerm r ( \"RegisterAgent\" );\n      r.add (path);\n      r.add (value);\n      \n      YCPValue v = m_handler->evaluate (r);\n  \n      if (v.isNull())\n      {\n  \tycp2error (\"SCR::RegisterAgent() failed\");\n  \treturn YCPNull ();\n      }\n      if (!v->isBoolean ())\n      {\n  \tycp2error (\"SCR::RegisterAgent() did not return a boolean (%s)\", v->toString().c_str());\n  \treturn YCPNull ();\n      }\n  \n      return v->asBoolean();\n  }\n}"
  },
  {
    "function_name": "Error",
    "container": "StdioSCRAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/scr/src/StdioSCRAgent.cc",
    "lines": "136-159",
    "snippet": "YCPMap\nStdioSCRAgent::Error (const YCPPath &path)\n{\n    if (! m_handler)\n\treturn YCPNull ();\n\t\n    y2debug( \"This is StdioSCRAgent(%p)::Error\", this );\n    \n    YCPTerm r ( \"Error\" );\n    r.add (path);\n    \n    YCPValue v = m_handler->evaluate (r);\n    if (v.isNull())\n    {\n\tycp2error (\"SCR::Error() failed\");\n\treturn YCPNull ();\n    }\n    if (!v->isMap ())\n    {\n\tycp2error (\"SCR::Error() did not return a map\");\n\treturn YCPNull ();\n    }\n    return v->asMap ();\n}",
    "includes": [
      "#include \"StdioSCRAgent.h\"",
      "#include <y2/Y2Component.h>",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v->asMap",
          "args": [],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"SCR::Error() did not return a map\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->isMap",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "71-71",
          "snippet": "bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"SCR::Error() failed\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_handler->evaluate",
          "args": [
            "r"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2AgentComp<Agent>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "91-166",
          "snippet": "YCPValue\nY2AgentComp<Agent>::evaluate (const YCPValue& v)\n{\n    y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n\n    if (!agent)\n\tgetSCRAgent ();\n\n    y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n\t\n    YCPValue value = v;\n    if (value->isCode ())\n    {\n\tYCodePtr c = v->asCode ()->code ();\n\n\t\n\tif ( c->kind () != YCode::yeTerm)\n\t{\n\t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n\t    value = value->asCode ()->evaluate ();\n\t    return value;\n\t}\n\n\tvalue = value->asCode ()->evaluate ();\n    }\n\t\n    if (value.isNull () || value->isVoid ())\n\treturn value;\n\n    y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n\n    if( value->isTerm () ) {\n\tYCPTerm term = value ->asTerm ();\n\tstring command = term->name ();\n\tYCPList args = term->args ();\n\n\t// evaluate the term in native functions\n\tif( command == \"Read\" ) {\n\t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n\t}\n\telse if( command == \"Write\" ) {\n\t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n\t}\n\telse if( command == \"Dir\" ) {\n\t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Error\" ) {\n\t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Execute\" ) {\n\t    y2debug( \"Execute, arg size is %d\", args->size() );\n\t    switch( args->size() ) {\n\t\tcase 1:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n\t\tcase 2:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n\t\tdefault:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n\t    }\n\t}\n\telse {\n\t    y2debug( \"Passing term to otherCommand\" );\n\t    return getSCRAgent ()-> otherCommand (term);\n\t}\n    }\n#if 0\n    if( value->isCode () ) {\n\ty2debug( \"Passing (evaluated) code to otherCommand\" );\n\treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n    }\n#endif\n\n    y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n\n    return YCPVoid();\n}",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp<Agent> {\n  YCPValue\n  Y2AgentComp<Agent>::evaluate (const YCPValue& v)\n  {\n      y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n  \n      if (!agent)\n  \tgetSCRAgent ();\n  \n      y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n  \t\n      YCPValue value = v;\n      if (value->isCode ())\n      {\n  \tYCodePtr c = v->asCode ()->code ();\n  \n  \t\n  \tif ( c->kind () != YCode::yeTerm)\n  \t{\n  \t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n  \t    value = value->asCode ()->evaluate ();\n  \t    return value;\n  \t}\n  \n  \tvalue = value->asCode ()->evaluate ();\n      }\n  \t\n      if (value.isNull () || value->isVoid ())\n  \treturn value;\n  \n      y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n  \n      if( value->isTerm () ) {\n  \tYCPTerm term = value ->asTerm ();\n  \tstring command = term->name ();\n  \tYCPList args = term->args ();\n  \n  \t// evaluate the term in native functions\n  \tif( command == \"Read\" ) {\n  \t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Write\" ) {\n  \t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Dir\" ) {\n  \t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Error\" ) {\n  \t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Execute\" ) {\n  \t    y2debug( \"Execute, arg size is %d\", args->size() );\n  \t    switch( args->size() ) {\n  \t\tcase 1:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n  \t\tcase 2:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n  \t\tdefault:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n  \t    }\n  \t}\n  \telse {\n  \t    y2debug( \"Passing term to otherCommand\" );\n  \t    return getSCRAgent ()-> otherCommand (term);\n  \t}\n      }\n  #if 0\n      if( value->isCode () ) {\n  \ty2debug( \"Passing (evaluated) code to otherCommand\" );\n  \treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n      }\n  #endif\n  \n      y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n  \n      return YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r.add",
          "args": [
            "path"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"This is StdioSCRAgent(%p)::Error\"",
            "this"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"StdioSCRAgent.h\"\n#include <y2/Y2Component.h>\n#include <ycp/y2log.h>\n\nStdioSCRAgent {\n  YCPMap\n  StdioSCRAgent::Error (const YCPPath &path)\n  {\n      if (! m_handler)\n  \treturn YCPNull ();\n  \t\n      y2debug( \"This is StdioSCRAgent(%p)::Error\", this );\n      \n      YCPTerm r ( \"Error\" );\n      r.add (path);\n      \n      YCPValue v = m_handler->evaluate (r);\n      if (v.isNull())\n      {\n  \tycp2error (\"SCR::Error() failed\");\n  \treturn YCPNull ();\n      }\n      if (!v->isMap ())\n      {\n  \tycp2error (\"SCR::Error() did not return a map\");\n  \treturn YCPNull ();\n      }\n      return v->asMap ();\n  }\n}"
  },
  {
    "function_name": "Execute",
    "container": "StdioSCRAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/scr/src/StdioSCRAgent.cc",
    "lines": "111-133",
    "snippet": "YCPValue\nStdioSCRAgent::Execute (const YCPPath &path, const YCPValue &value,\n\t\t\t const YCPValue &arg)\n{\n    if (! m_handler)\n\treturn YCPNull ();\n\t\n    y2debug( \"This is StdioSCRAgent(%p)::Execute\", this );\n    \n    YCPTerm r ( \"Execute\" );\n    r.add (path);\n    if (!value.isNull ()) \n    {\n\tr.add (value);\n\t\n\tif (! arg.isNull ())\n\t{\n\t    r.add (arg);\n\t}\n    }\n    \n    return m_handler->evaluate (r);\n}",
    "includes": [
      "#include \"StdioSCRAgent.h\"",
      "#include <y2/Y2Component.h>",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_handler->evaluate",
          "args": [
            "r"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2AgentComp<Agent>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "91-166",
          "snippet": "YCPValue\nY2AgentComp<Agent>::evaluate (const YCPValue& v)\n{\n    y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n\n    if (!agent)\n\tgetSCRAgent ();\n\n    y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n\t\n    YCPValue value = v;\n    if (value->isCode ())\n    {\n\tYCodePtr c = v->asCode ()->code ();\n\n\t\n\tif ( c->kind () != YCode::yeTerm)\n\t{\n\t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n\t    value = value->asCode ()->evaluate ();\n\t    return value;\n\t}\n\n\tvalue = value->asCode ()->evaluate ();\n    }\n\t\n    if (value.isNull () || value->isVoid ())\n\treturn value;\n\n    y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n\n    if( value->isTerm () ) {\n\tYCPTerm term = value ->asTerm ();\n\tstring command = term->name ();\n\tYCPList args = term->args ();\n\n\t// evaluate the term in native functions\n\tif( command == \"Read\" ) {\n\t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n\t}\n\telse if( command == \"Write\" ) {\n\t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n\t}\n\telse if( command == \"Dir\" ) {\n\t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Error\" ) {\n\t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Execute\" ) {\n\t    y2debug( \"Execute, arg size is %d\", args->size() );\n\t    switch( args->size() ) {\n\t\tcase 1:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n\t\tcase 2:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n\t\tdefault:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n\t    }\n\t}\n\telse {\n\t    y2debug( \"Passing term to otherCommand\" );\n\t    return getSCRAgent ()-> otherCommand (term);\n\t}\n    }\n#if 0\n    if( value->isCode () ) {\n\ty2debug( \"Passing (evaluated) code to otherCommand\" );\n\treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n    }\n#endif\n\n    y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n\n    return YCPVoid();\n}",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp<Agent> {\n  YCPValue\n  Y2AgentComp<Agent>::evaluate (const YCPValue& v)\n  {\n      y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n  \n      if (!agent)\n  \tgetSCRAgent ();\n  \n      y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n  \t\n      YCPValue value = v;\n      if (value->isCode ())\n      {\n  \tYCodePtr c = v->asCode ()->code ();\n  \n  \t\n  \tif ( c->kind () != YCode::yeTerm)\n  \t{\n  \t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n  \t    value = value->asCode ()->evaluate ();\n  \t    return value;\n  \t}\n  \n  \tvalue = value->asCode ()->evaluate ();\n      }\n  \t\n      if (value.isNull () || value->isVoid ())\n  \treturn value;\n  \n      y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n  \n      if( value->isTerm () ) {\n  \tYCPTerm term = value ->asTerm ();\n  \tstring command = term->name ();\n  \tYCPList args = term->args ();\n  \n  \t// evaluate the term in native functions\n  \tif( command == \"Read\" ) {\n  \t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Write\" ) {\n  \t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Dir\" ) {\n  \t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Error\" ) {\n  \t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Execute\" ) {\n  \t    y2debug( \"Execute, arg size is %d\", args->size() );\n  \t    switch( args->size() ) {\n  \t\tcase 1:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n  \t\tcase 2:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n  \t\tdefault:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n  \t    }\n  \t}\n  \telse {\n  \t    y2debug( \"Passing term to otherCommand\" );\n  \t    return getSCRAgent ()-> otherCommand (term);\n  \t}\n      }\n  #if 0\n      if( value->isCode () ) {\n  \ty2debug( \"Passing (evaluated) code to otherCommand\" );\n  \treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n      }\n  #endif\n  \n      y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n  \n      return YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r.add",
          "args": [
            "arg"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"This is StdioSCRAgent(%p)::Execute\"",
            "this"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"StdioSCRAgent.h\"\n#include <y2/Y2Component.h>\n#include <ycp/y2log.h>\n\nStdioSCRAgent {\n  YCPValue\n  StdioSCRAgent::Execute (const YCPPath &path, const YCPValue &value,\n  \t\t\t const YCPValue &arg)\n  {\n      if (! m_handler)\n  \treturn YCPNull ();\n  \t\n      y2debug( \"This is StdioSCRAgent(%p)::Execute\", this );\n      \n      YCPTerm r ( \"Execute\" );\n      r.add (path);\n      if (!value.isNull ()) \n      {\n  \tr.add (value);\n  \t\n  \tif (! arg.isNull ())\n  \t{\n  \t    r.add (arg);\n  \t}\n      }\n      \n      return m_handler->evaluate (r);\n  }\n}"
  },
  {
    "function_name": "Dir",
    "container": "StdioSCRAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/scr/src/StdioSCRAgent.cc",
    "lines": "85-108",
    "snippet": "YCPList\nStdioSCRAgent::Dir (const YCPPath &path)\n{\n    if (! m_handler)\n\treturn YCPNull ();\n\t\n    y2debug( \"This is StdioSCRAgent(%p)::Dir\", this );\n    \n    YCPTerm r ( \"Dir\" );\n    r.add (path);\n    \n    YCPValue v = m_handler->evaluate (r);\n    if (v.isNull())\n    {\n\tycp2error (\"SCR::Dir() failed\");\n\treturn YCPNull ();\n    }\n    if (!v->isList ())\n    {\n\tycp2error (\"SCR::Dir() did not return a list\");\n\treturn YCPNull ();\n    }\n    return v->asList ();\n}",
    "includes": [
      "#include \"StdioSCRAgent.h\"",
      "#include <y2/Y2Component.h>",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v->asList",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"SCR::Dir() did not return a list\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->isList",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"SCR::Dir() failed\""
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_handler->evaluate",
          "args": [
            "r"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2AgentComp<Agent>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "91-166",
          "snippet": "YCPValue\nY2AgentComp<Agent>::evaluate (const YCPValue& v)\n{\n    y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n\n    if (!agent)\n\tgetSCRAgent ();\n\n    y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n\t\n    YCPValue value = v;\n    if (value->isCode ())\n    {\n\tYCodePtr c = v->asCode ()->code ();\n\n\t\n\tif ( c->kind () != YCode::yeTerm)\n\t{\n\t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n\t    value = value->asCode ()->evaluate ();\n\t    return value;\n\t}\n\n\tvalue = value->asCode ()->evaluate ();\n    }\n\t\n    if (value.isNull () || value->isVoid ())\n\treturn value;\n\n    y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n\n    if( value->isTerm () ) {\n\tYCPTerm term = value ->asTerm ();\n\tstring command = term->name ();\n\tYCPList args = term->args ();\n\n\t// evaluate the term in native functions\n\tif( command == \"Read\" ) {\n\t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n\t}\n\telse if( command == \"Write\" ) {\n\t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n\t}\n\telse if( command == \"Dir\" ) {\n\t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Error\" ) {\n\t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Execute\" ) {\n\t    y2debug( \"Execute, arg size is %d\", args->size() );\n\t    switch( args->size() ) {\n\t\tcase 1:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n\t\tcase 2:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n\t\tdefault:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n\t    }\n\t}\n\telse {\n\t    y2debug( \"Passing term to otherCommand\" );\n\t    return getSCRAgent ()-> otherCommand (term);\n\t}\n    }\n#if 0\n    if( value->isCode () ) {\n\ty2debug( \"Passing (evaluated) code to otherCommand\" );\n\treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n    }\n#endif\n\n    y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n\n    return YCPVoid();\n}",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp<Agent> {\n  YCPValue\n  Y2AgentComp<Agent>::evaluate (const YCPValue& v)\n  {\n      y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n  \n      if (!agent)\n  \tgetSCRAgent ();\n  \n      y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n  \t\n      YCPValue value = v;\n      if (value->isCode ())\n      {\n  \tYCodePtr c = v->asCode ()->code ();\n  \n  \t\n  \tif ( c->kind () != YCode::yeTerm)\n  \t{\n  \t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n  \t    value = value->asCode ()->evaluate ();\n  \t    return value;\n  \t}\n  \n  \tvalue = value->asCode ()->evaluate ();\n      }\n  \t\n      if (value.isNull () || value->isVoid ())\n  \treturn value;\n  \n      y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n  \n      if( value->isTerm () ) {\n  \tYCPTerm term = value ->asTerm ();\n  \tstring command = term->name ();\n  \tYCPList args = term->args ();\n  \n  \t// evaluate the term in native functions\n  \tif( command == \"Read\" ) {\n  \t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Write\" ) {\n  \t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Dir\" ) {\n  \t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Error\" ) {\n  \t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Execute\" ) {\n  \t    y2debug( \"Execute, arg size is %d\", args->size() );\n  \t    switch( args->size() ) {\n  \t\tcase 1:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n  \t\tcase 2:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n  \t\tdefault:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n  \t    }\n  \t}\n  \telse {\n  \t    y2debug( \"Passing term to otherCommand\" );\n  \t    return getSCRAgent ()-> otherCommand (term);\n  \t}\n      }\n  #if 0\n      if( value->isCode () ) {\n  \ty2debug( \"Passing (evaluated) code to otherCommand\" );\n  \treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n      }\n  #endif\n  \n      y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n  \n      return YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r.add",
          "args": [
            "path"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"This is StdioSCRAgent(%p)::Dir\"",
            "this"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"StdioSCRAgent.h\"\n#include <y2/Y2Component.h>\n#include <ycp/y2log.h>\n\nStdioSCRAgent {\n  YCPList\n  StdioSCRAgent::Dir (const YCPPath &path)\n  {\n      if (! m_handler)\n  \treturn YCPNull ();\n  \t\n      y2debug( \"This is StdioSCRAgent(%p)::Dir\", this );\n      \n      YCPTerm r ( \"Dir\" );\n      r.add (path);\n      \n      YCPValue v = m_handler->evaluate (r);\n      if (v.isNull())\n      {\n  \tycp2error (\"SCR::Dir() failed\");\n  \treturn YCPNull ();\n      }\n      if (!v->isList ())\n      {\n  \tycp2error (\"SCR::Dir() did not return a list\");\n  \treturn YCPNull ();\n      }\n      return v->asList ();\n  }\n}"
  },
  {
    "function_name": "Write",
    "container": "StdioSCRAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/scr/src/StdioSCRAgent.cc",
    "lines": "43-82",
    "snippet": "YCPBoolean\nStdioSCRAgent::Write (const YCPPath &path, const YCPValue &value,\n\t\t       const YCPValue &arg)\n{\n    if (! m_handler)\n\treturn YCPNull ();\n\t\n    y2debug( \"This is StdioSCRAgent(%p)::Write\", this );\n    \n    YCPTerm r ( \"Write\" );\n    r.add (path);\n    \n    if (!value.isNull ()) \n    {\n\tr.add (value);\n\t\n\tif (! arg.isNull ())\n\t{\n\t    r.add (arg);\n\t}\n    }\n    else\n    {\n\tr.add (YCPVoid ());\n    }\n    \n    YCPValue v = m_handler->evaluate (r);\n\n    if (v.isNull())\n    {\n\tycp2error (\"SCR::Write() failed\");\n\treturn YCPNull ();\n    }\n    if (!v->isBoolean ())\n    {\n\tycp2error (\"SCR::Write() did not return a boolean\");\n\treturn YCPNull ();\n    }\n    return v->asBoolean ();\n}",
    "includes": [
      "#include \"StdioSCRAgent.h\"",
      "#include <y2/Y2Component.h>",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v->asBoolean",
          "args": [],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "asBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "94-104",
          "snippet": "YCPBoolean\nYCPValueRep::asBoolean() const\n{\n    if (!isBoolean())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPBoolean\n  YCPValueRep::asBoolean() const\n  {\n      if (!isBoolean())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"SCR::Write() did not return a boolean\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->isBoolean",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "isBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "62-62",
          "snippet": "bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"SCR::Write() failed\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_handler->evaluate",
          "args": [
            "r"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2AgentComp<Agent>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "91-166",
          "snippet": "YCPValue\nY2AgentComp<Agent>::evaluate (const YCPValue& v)\n{\n    y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n\n    if (!agent)\n\tgetSCRAgent ();\n\n    y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n\t\n    YCPValue value = v;\n    if (value->isCode ())\n    {\n\tYCodePtr c = v->asCode ()->code ();\n\n\t\n\tif ( c->kind () != YCode::yeTerm)\n\t{\n\t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n\t    value = value->asCode ()->evaluate ();\n\t    return value;\n\t}\n\n\tvalue = value->asCode ()->evaluate ();\n    }\n\t\n    if (value.isNull () || value->isVoid ())\n\treturn value;\n\n    y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n\n    if( value->isTerm () ) {\n\tYCPTerm term = value ->asTerm ();\n\tstring command = term->name ();\n\tYCPList args = term->args ();\n\n\t// evaluate the term in native functions\n\tif( command == \"Read\" ) {\n\t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n\t}\n\telse if( command == \"Write\" ) {\n\t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n\t}\n\telse if( command == \"Dir\" ) {\n\t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Error\" ) {\n\t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Execute\" ) {\n\t    y2debug( \"Execute, arg size is %d\", args->size() );\n\t    switch( args->size() ) {\n\t\tcase 1:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n\t\tcase 2:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n\t\tdefault:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n\t    }\n\t}\n\telse {\n\t    y2debug( \"Passing term to otherCommand\" );\n\t    return getSCRAgent ()-> otherCommand (term);\n\t}\n    }\n#if 0\n    if( value->isCode () ) {\n\ty2debug( \"Passing (evaluated) code to otherCommand\" );\n\treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n    }\n#endif\n\n    y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n\n    return YCPVoid();\n}",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp<Agent> {\n  YCPValue\n  Y2AgentComp<Agent>::evaluate (const YCPValue& v)\n  {\n      y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n  \n      if (!agent)\n  \tgetSCRAgent ();\n  \n      y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n  \t\n      YCPValue value = v;\n      if (value->isCode ())\n      {\n  \tYCodePtr c = v->asCode ()->code ();\n  \n  \t\n  \tif ( c->kind () != YCode::yeTerm)\n  \t{\n  \t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n  \t    value = value->asCode ()->evaluate ();\n  \t    return value;\n  \t}\n  \n  \tvalue = value->asCode ()->evaluate ();\n      }\n  \t\n      if (value.isNull () || value->isVoid ())\n  \treturn value;\n  \n      y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n  \n      if( value->isTerm () ) {\n  \tYCPTerm term = value ->asTerm ();\n  \tstring command = term->name ();\n  \tYCPList args = term->args ();\n  \n  \t// evaluate the term in native functions\n  \tif( command == \"Read\" ) {\n  \t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Write\" ) {\n  \t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Dir\" ) {\n  \t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Error\" ) {\n  \t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Execute\" ) {\n  \t    y2debug( \"Execute, arg size is %d\", args->size() );\n  \t    switch( args->size() ) {\n  \t\tcase 1:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n  \t\tcase 2:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n  \t\tdefault:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n  \t    }\n  \t}\n  \telse {\n  \t    y2debug( \"Passing term to otherCommand\" );\n  \t    return getSCRAgent ()-> otherCommand (term);\n  \t}\n      }\n  #if 0\n      if( value->isCode () ) {\n  \ty2debug( \"Passing (evaluated) code to otherCommand\" );\n  \treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n      }\n  #endif\n  \n      y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n  \n      return YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r.add",
          "args": [
            "YCPVoid ()"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"This is StdioSCRAgent(%p)::Write\"",
            "this"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"StdioSCRAgent.h\"\n#include <y2/Y2Component.h>\n#include <ycp/y2log.h>\n\nStdioSCRAgent {\n  YCPBoolean\n  StdioSCRAgent::Write (const YCPPath &path, const YCPValue &value,\n  \t\t       const YCPValue &arg)\n  {\n      if (! m_handler)\n  \treturn YCPNull ();\n  \t\n      y2debug( \"This is StdioSCRAgent(%p)::Write\", this );\n      \n      YCPTerm r ( \"Write\" );\n      r.add (path);\n      \n      if (!value.isNull ()) \n      {\n  \tr.add (value);\n  \t\n  \tif (! arg.isNull ())\n  \t{\n  \t    r.add (arg);\n  \t}\n      }\n      else\n      {\n  \tr.add (YCPVoid ());\n      }\n      \n      YCPValue v = m_handler->evaluate (r);\n  \n      if (v.isNull())\n      {\n  \tycp2error (\"SCR::Write() failed\");\n  \treturn YCPNull ();\n      }\n      if (!v->isBoolean ())\n      {\n  \tycp2error (\"SCR::Write() did not return a boolean\");\n  \treturn YCPNull ();\n      }\n      return v->asBoolean ();\n  }\n}"
  },
  {
    "function_name": "Read",
    "container": "StdioSCRAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/scr/src/StdioSCRAgent.cc",
    "lines": "19-40",
    "snippet": "YCPValue\nStdioSCRAgent::Read (const YCPPath &path, const YCPValue &arg, const YCPValue &opt)\n{\n    if (! m_handler)\n\treturn YCPNull ();\n\t\n    y2debug( \"This is StdioSCRAgent(%p)::Read\", this );\n    \n    YCPTerm r ( \"Read\" );\n    r.add (path);\n    if (!arg.isNull ()) \n    {\n\tr.add (arg);\n\t\n\tif (! opt.isNull ())\n\t{\n\t    r.add (opt);\n\t}\n    }\n    \n    return m_handler->evaluate (r);\n}",
    "includes": [
      "#include \"StdioSCRAgent.h\"",
      "#include <y2/Y2Component.h>",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_handler->evaluate",
          "args": [
            "r"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2AgentComp<Agent>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "91-166",
          "snippet": "YCPValue\nY2AgentComp<Agent>::evaluate (const YCPValue& v)\n{\n    y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n\n    if (!agent)\n\tgetSCRAgent ();\n\n    y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n\t\n    YCPValue value = v;\n    if (value->isCode ())\n    {\n\tYCodePtr c = v->asCode ()->code ();\n\n\t\n\tif ( c->kind () != YCode::yeTerm)\n\t{\n\t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n\t    value = value->asCode ()->evaluate ();\n\t    return value;\n\t}\n\n\tvalue = value->asCode ()->evaluate ();\n    }\n\t\n    if (value.isNull () || value->isVoid ())\n\treturn value;\n\n    y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n\n    if( value->isTerm () ) {\n\tYCPTerm term = value ->asTerm ();\n\tstring command = term->name ();\n\tYCPList args = term->args ();\n\n\t// evaluate the term in native functions\n\tif( command == \"Read\" ) {\n\t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n\t}\n\telse if( command == \"Write\" ) {\n\t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n\t}\n\telse if( command == \"Dir\" ) {\n\t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Error\" ) {\n\t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Execute\" ) {\n\t    y2debug( \"Execute, arg size is %d\", args->size() );\n\t    switch( args->size() ) {\n\t\tcase 1:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n\t\tcase 2:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n\t\tdefault:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n\t    }\n\t}\n\telse {\n\t    y2debug( \"Passing term to otherCommand\" );\n\t    return getSCRAgent ()-> otherCommand (term);\n\t}\n    }\n#if 0\n    if( value->isCode () ) {\n\ty2debug( \"Passing (evaluated) code to otherCommand\" );\n\treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n    }\n#endif\n\n    y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n\n    return YCPVoid();\n}",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp<Agent> {\n  YCPValue\n  Y2AgentComp<Agent>::evaluate (const YCPValue& v)\n  {\n      y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n  \n      if (!agent)\n  \tgetSCRAgent ();\n  \n      y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n  \t\n      YCPValue value = v;\n      if (value->isCode ())\n      {\n  \tYCodePtr c = v->asCode ()->code ();\n  \n  \t\n  \tif ( c->kind () != YCode::yeTerm)\n  \t{\n  \t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n  \t    value = value->asCode ()->evaluate ();\n  \t    return value;\n  \t}\n  \n  \tvalue = value->asCode ()->evaluate ();\n      }\n  \t\n      if (value.isNull () || value->isVoid ())\n  \treturn value;\n  \n      y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n  \n      if( value->isTerm () ) {\n  \tYCPTerm term = value ->asTerm ();\n  \tstring command = term->name ();\n  \tYCPList args = term->args ();\n  \n  \t// evaluate the term in native functions\n  \tif( command == \"Read\" ) {\n  \t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Write\" ) {\n  \t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Dir\" ) {\n  \t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Error\" ) {\n  \t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Execute\" ) {\n  \t    y2debug( \"Execute, arg size is %d\", args->size() );\n  \t    switch( args->size() ) {\n  \t\tcase 1:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n  \t\tcase 2:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n  \t\tdefault:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n  \t    }\n  \t}\n  \telse {\n  \t    y2debug( \"Passing term to otherCommand\" );\n  \t    return getSCRAgent ()-> otherCommand (term);\n  \t}\n      }\n  #if 0\n      if( value->isCode () ) {\n  \ty2debug( \"Passing (evaluated) code to otherCommand\" );\n  \treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n      }\n  #endif\n  \n      y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n  \n      return YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r.add",
          "args": [
            "opt"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt.isNull",
          "args": [],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"This is StdioSCRAgent(%p)::Read\"",
            "this"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"StdioSCRAgent.h\"\n#include <y2/Y2Component.h>\n#include <ycp/y2log.h>\n\nStdioSCRAgent {\n  YCPValue\n  StdioSCRAgent::Read (const YCPPath &path, const YCPValue &arg, const YCPValue &opt)\n  {\n      if (! m_handler)\n  \treturn YCPNull ();\n  \t\n      y2debug( \"This is StdioSCRAgent(%p)::Read\", this );\n      \n      YCPTerm r ( \"Read\" );\n      r.add (path);\n      if (!arg.isNull ()) \n      {\n  \tr.add (arg);\n  \t\n  \tif (! opt.isNull ())\n  \t{\n  \t    r.add (opt);\n  \t}\n      }\n      \n      return m_handler->evaluate (r);\n  }\n}"
  }
]