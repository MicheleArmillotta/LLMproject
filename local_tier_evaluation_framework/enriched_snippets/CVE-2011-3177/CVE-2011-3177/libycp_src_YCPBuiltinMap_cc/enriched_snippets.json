[
  {
    "function_name": "YCPBuiltinMap",
    "container": "YCPBuiltinMap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMap.cc",
    "lines": "558-584",
    "snippet": "YCPBuiltinMap::YCPBuiltinMap ()\n{\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n#define ETC 0, NULL, constTypePtr(), NULL\n#define ETCf   NULL, constTypePtr(), NULL\n\t{ \"haskey\", \"boolean (const map <any,any>, const any)\",\t\t\t\t\t\t\t\t    (void *)m_haskey,                                                     ETC },\n\t{ \"mapmap\", \"map <flex3,flex4> (variable <flex1>, variable <flex2>, const map <flex1,flex2>, const block <map <flex3, flex4>>)\",  (void *)m_mapmap,\tDECL_LOOP|DECL_SYMBOL|DECL_FLEX, ETCf },\n\t{ \"maplist\",\"list <flex3> (variable <flex1>, variable <flex2>, const map <flex1,flex2>, const block <flex3>)\",\t    (void *)m_maplist,  DECL_LOOP|DECL_SYMBOL|DECL_FLEX,\t\t ETCf },\n\t{ \"filter\", \"map <flex1,flex2> (variable <flex1>, variable <flex2>, const map <flex1,flex2>, const block <boolean>)\",(void *)m_filter,\tDECL_LOOP|DECL_SYMBOL|DECL_FLEX,\t\t ETCf },\n\t{ \"union\",  \"map <any,any> (const map <any,any>, const map <any,any>)\",\t\t\t\t\t\t    (void *)m_unionmap,\t\t\t\t\t\t\t  ETC },\n\t{ \"+\",\t    \"map <any,any> (const map <any,any>, const map <any,any>)\",\t\t\t\t\t\t    (void *)m_unionmap,\t\t\t\t\t\t\t  ETC },\n\t{ \"add\",    \"map <flex1,flex2> (const map <flex1,flex2>, const flex1, const flex2)\",\t\t\t\t    (void *)m_addmap,\tDECL_FLEX,\t\t\t\t\t ETCf },\n\t{ \"change\", \"map <flex1,flex2> (const map <flex1,flex2>, const flex1, const flex2)\",\t\t\t\t    (void *)m_changemap,DECL_FLEX|DECL_DEPRECATED,                       ETCf },\n\t{ \"isempty\", \"boolean (const map <any,any>)\",\t\t\t\t\t\t\t\t\t    (void *)m_isempty,\t\t\t\t\t\t\t  ETC },\n\t{ \"size\",   \"integer (const map <any,any>)\",\t\t\t\t\t\t\t\t\t    (void *)m_size,\tDECL_NIL,\t\t\t\t\t ETCf },\n\t{ \"foreach\",\"flex1 (variable <flex2>, variable <flex3>, const map <flex2,flex3>, const block <flex1>)\",\t\t    (void *)m_foreach,\tDECL_LOOP|DECL_SYMBOL|DECL_FLEX,\t\t ETCf },\n\t{ \"tomap\",  \"map <any,any> (const any)\",\t\t\t\t\t\t\t\t\t    (void *)m_tomap,\tDECL_FLEX,\t\t\t\t\t ETCf },\n        { \"remove\", \"map <flex1,flex2> (const map <flex1,flex2>, const flex1)\", \t\t\t\t\t    (void *)m_remove,\tDECL_FLEX,\t\t\t\t\t ETCf },\n\t{ NULL, NULL, NULL, ETC }\n#undef ETC\n#undef ETCf\n\t// \"lookup\" is in parser.yy\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinMap\", declarations);\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPBuiltinMap.h\""
    ],
    "macros_used": [
      "#define ETCf   NULL, constTypePtr(), NULL",
      "#define ETC 0, NULL, constTypePtr(), NULL"
    ],
    "globals_used": [
      "extern StaticDeclaration static_declarations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_declarations.registerDeclarations",
          "args": [
            "\"YCPBuiltinMap\"",
            "declarations"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "registerDeclarations",
          "container": "StaticDeclaration",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/StaticDeclaration.cc",
          "lines": "87-237",
          "snippet": "void\nStaticDeclaration::registerDeclarations (const char *filename,\n\t\t\t\t\t declaration_t *declarations)\n{\n    if (declarations == 0)\n    {\n\treturn;\n    }\n\n    SymbolTable *table = m_declTable;\n    const Y2Namespace *name_space = 0;\n    static const Point *builtin_point = new Point (\"<builtin>\");\n    const Point *namespace_point = builtin_point;\t\t// declarations default to builtin\n    declaration_t *namespace_decl = 0;\n\n    std::pair <std::string, Y2Namespace *> *track_info = 0;\n\n    while (declarations->name != 0)\n    {\n#if DO_DEBUG\n\ty2debug( \"Registering %s\", declarations->name );\n#endif\n\tconst char *name = declarations->name;\n\n\tif (*name == 0)\t\t// exit on empty name\n\t    break;\n\n\tif ((declarations->flags & (DECL_WILD|DECL_SYMBOL)) == (DECL_WILD|DECL_SYMBOL))\n\t{\n\t    y2internal (\"Declaration of %s::%s combines wildcard and symbol\\n\", filename, name);\n\t}\n\telse if ((declarations->flags & DECL_NAMESPACE) != 0)\t\t// switch namespace\n\t{\n\t    // new namespace, clear possibly old track_info\n\t    if (track_info != 0)\n\t    {\n\t\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n\t\tm_active_predefined.push_back (*track_info);\n\t\ttrack_info = 0;\n\t    }\n#if DO_DEBUG\n\t    y2debug (\"NAMESPACE (%s)\", name);\n#endif\n            declarations->name_space = namespace_decl;\n\n\t    TableEntry *tentry = table->find (name);\n\t    if (tentry != 0\t\t\t\t\t\t// name already exists\n\t\t&& tentry->sentry()->isNamespace())\t\t\t//   as namespace\n\t    {\n\t\tname_space = tentry->sentry()->nameSpace();\n\t    }\n\t    else if (*name == 0)\t\t\t\t\t// reset namespace\n\t    {\n\t\ttable = m_declTable;\n\t\tname_space = 0;\n\t\tnamespace_point = builtin_point;\n\t    }\n\t    else\t\t\t\t\t\t\t// open up new namespace\n\t    {\n\t\tbool is_predefined = false;\n\n\t\tif (tentry != 0\n\t\t    && tentry->sentry()->isPredefined())\t\t//   replace predefined\n\t\t{\n\t\t    table->remove (tentry);\n\t\t    is_predefined = true;\n\t\t}\n\n\t\t// create definition container for namespace\n\t\tYBlock *block = new YBlock (filename, YBlock::b_namespace);\n\t\tblock->setName (string (name));\n\n\t\tY2Namespace *namespaceNamespace = (Y2Namespace *)block;\n\t\tnamespaceNamespace->createTable();\n\t\tSymbolTable *namespaceTable = block->table();\n\n\t\t// create SymbolEntry::c_namespace for the namespace to be entered into the global table\n\t\tSymbolEntryPtr sentry = new YSymbolEntry (name, Type::Unspec, namespaceTable);\n\n#if DO_DEBUG\n\t\ty2debug (\"Entered Namespace '%s' (block %p) into namespaceTable %p\", name, block, namespaceTable);\n#endif\n\n\t\t// enter into global table\n\t\tnamespace_point = new Point (filename);\n\t\ttable->enter (name, sentry, namespace_point);\n\n\t\t// all further definitions go into this namespace\n\t\t//   -> make it the new global table\n\t\ttable = namespaceTable;\n\t\tnamespace_decl = declarations;\n\n\t\tif (is_predefined)\n\t\t{\n\t\t    // save tracking info, trigger 'Import' _after_ all symbols have been added\n\t\t    track_info = new std::pair<std::string, Y2Namespace *> (name, namespaceNamespace);\n\t\t}\n\t    }\n\t}\n\telse\t// normal entry, not namespace\n\t{\n\t    declarations->name_space = namespace_decl;\n\t    string signature = declarations->signature;\n\n\t    constTypePtr type = Type::fromSignature (signature);\n\t    if (type == 0\n\t\t|| type->isError()\n\t\t|| type->isUnspec()\n\t\t|| type->isWildcard())\n\t    {\n\t\ty2error (\"Invalid signature %s::%s:'%s'\\n\", filename, name, signature.c_str());\n\t\treturn;\n\t    }\n\n#if DO_DEBUG\ny2debug(\"%s sig[%s] type[%s]\", name, signature.c_str(), type->toString().c_str());\n#endif\n#if 0\n\t    if (type->hasFlex()\n\t\t&& (declarations->flags & DECL_FLEX) == 0)\n\t    {\n\t\ty2error (\"%s:'%s' without DECL_FLEX\", name, declarations->signature);\n\t\treturn;\n\t    }\n#endif\n\t    declarations->type = type;\n\n\t    SymbolEntryPtr sentry = new YSymbolEntry (name, type, declarations, name_space);\n\t    declarations->tentry = table->enter (name, sentry, new Point (sentry, 0, namespace_point));\n\n#ifdef BUILTIN_STATISTICS\n\t    FILE *fout = fopen (\"/tmp/builtin-register.txt\", \"a\");\n\t    if (fout) {\n\t\tfprintf (fout, \"%s %s\\n\", declarations->name, declarations->signature);\n\t\tfclose (fout);\n\t    }\n#endif\n\t}\n\tdeclarations++;\n    }\n\n    // clear possibly old track_info\n    if (track_info != 0)\n    {\n\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n\tm_active_predefined.push_back (*track_info);\n\ttrack_info = 0;\n    }\n\n    return;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Import.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include <map>",
            "#include <string>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "static const char *predefined[] = {\n  \"UI\", \"WFM\", \"SCR\", \"Pkg\", 0\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <unistd.h>\n\n#define DO_DEBUG 0\n\nstatic const char *predefined[] = {\n  \"UI\", \"WFM\", \"SCR\", \"Pkg\", 0\n};\n\nStaticDeclaration {\n  void\n  StaticDeclaration::registerDeclarations (const char *filename,\n  \t\t\t\t\t declaration_t *declarations)\n  {\n      if (declarations == 0)\n      {\n  \treturn;\n      }\n  \n      SymbolTable *table = m_declTable;\n      const Y2Namespace *name_space = 0;\n      static const Point *builtin_point = new Point (\"<builtin>\");\n      const Point *namespace_point = builtin_point;\t\t// declarations default to builtin\n      declaration_t *namespace_decl = 0;\n  \n      std::pair <std::string, Y2Namespace *> *track_info = 0;\n  \n      while (declarations->name != 0)\n      {\n  #if DO_DEBUG\n  \ty2debug( \"Registering %s\", declarations->name );\n  #endif\n  \tconst char *name = declarations->name;\n  \n  \tif (*name == 0)\t\t// exit on empty name\n  \t    break;\n  \n  \tif ((declarations->flags & (DECL_WILD|DECL_SYMBOL)) == (DECL_WILD|DECL_SYMBOL))\n  \t{\n  \t    y2internal (\"Declaration of %s::%s combines wildcard and symbol\\n\", filename, name);\n  \t}\n  \telse if ((declarations->flags & DECL_NAMESPACE) != 0)\t\t// switch namespace\n  \t{\n  \t    // new namespace, clear possibly old track_info\n  \t    if (track_info != 0)\n  \t    {\n  \t\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n  \t\tm_active_predefined.push_back (*track_info);\n  \t\ttrack_info = 0;\n  \t    }\n  #if DO_DEBUG\n  \t    y2debug (\"NAMESPACE (%s)\", name);\n  #endif\n              declarations->name_space = namespace_decl;\n  \n  \t    TableEntry *tentry = table->find (name);\n  \t    if (tentry != 0\t\t\t\t\t\t// name already exists\n  \t\t&& tentry->sentry()->isNamespace())\t\t\t//   as namespace\n  \t    {\n  \t\tname_space = tentry->sentry()->nameSpace();\n  \t    }\n  \t    else if (*name == 0)\t\t\t\t\t// reset namespace\n  \t    {\n  \t\ttable = m_declTable;\n  \t\tname_space = 0;\n  \t\tnamespace_point = builtin_point;\n  \t    }\n  \t    else\t\t\t\t\t\t\t// open up new namespace\n  \t    {\n  \t\tbool is_predefined = false;\n  \n  \t\tif (tentry != 0\n  \t\t    && tentry->sentry()->isPredefined())\t\t//   replace predefined\n  \t\t{\n  \t\t    table->remove (tentry);\n  \t\t    is_predefined = true;\n  \t\t}\n  \n  \t\t// create definition container for namespace\n  \t\tYBlock *block = new YBlock (filename, YBlock::b_namespace);\n  \t\tblock->setName (string (name));\n  \n  \t\tY2Namespace *namespaceNamespace = (Y2Namespace *)block;\n  \t\tnamespaceNamespace->createTable();\n  \t\tSymbolTable *namespaceTable = block->table();\n  \n  \t\t// create SymbolEntry::c_namespace for the namespace to be entered into the global table\n  \t\tSymbolEntryPtr sentry = new YSymbolEntry (name, Type::Unspec, namespaceTable);\n  \n  #if DO_DEBUG\n  \t\ty2debug (\"Entered Namespace '%s' (block %p) into namespaceTable %p\", name, block, namespaceTable);\n  #endif\n  \n  \t\t// enter into global table\n  \t\tnamespace_point = new Point (filename);\n  \t\ttable->enter (name, sentry, namespace_point);\n  \n  \t\t// all further definitions go into this namespace\n  \t\t//   -> make it the new global table\n  \t\ttable = namespaceTable;\n  \t\tnamespace_decl = declarations;\n  \n  \t\tif (is_predefined)\n  \t\t{\n  \t\t    // save tracking info, trigger 'Import' _after_ all symbols have been added\n  \t\t    track_info = new std::pair<std::string, Y2Namespace *> (name, namespaceNamespace);\n  \t\t}\n  \t    }\n  \t}\n  \telse\t// normal entry, not namespace\n  \t{\n  \t    declarations->name_space = namespace_decl;\n  \t    string signature = declarations->signature;\n  \n  \t    constTypePtr type = Type::fromSignature (signature);\n  \t    if (type == 0\n  \t\t|| type->isError()\n  \t\t|| type->isUnspec()\n  \t\t|| type->isWildcard())\n  \t    {\n  \t\ty2error (\"Invalid signature %s::%s:'%s'\\n\", filename, name, signature.c_str());\n  \t\treturn;\n  \t    }\n  \n  #if DO_DEBUG\n  y2debug(\"%s sig[%s] type[%s]\", name, signature.c_str(), type->toString().c_str());\n  #endif\n  #if 0\n  \t    if (type->hasFlex()\n  \t\t&& (declarations->flags & DECL_FLEX) == 0)\n  \t    {\n  \t\ty2error (\"%s:'%s' without DECL_FLEX\", name, declarations->signature);\n  \t\treturn;\n  \t    }\n  #endif\n  \t    declarations->type = type;\n  \n  \t    SymbolEntryPtr sentry = new YSymbolEntry (name, type, declarations, name_space);\n  \t    declarations->tentry = table->enter (name, sentry, new Point (sentry, 0, namespace_point));\n  \n  #ifdef BUILTIN_STATISTICS\n  \t    FILE *fout = fopen (\"/tmp/builtin-register.txt\", \"a\");\n  \t    if (fout) {\n  \t\tfprintf (fout, \"%s %s\\n\", declarations->name, declarations->signature);\n  \t\tfclose (fout);\n  \t    }\n  #endif\n  \t}\n  \tdeclarations++;\n      }\n  \n      // clear possibly old track_info\n      if (track_info != 0)\n      {\n  \tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n  \tm_active_predefined.push_back (*track_info);\n  \ttrack_info = 0;\n      }\n  \n      return;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPBuiltinMap.h\"\n\n#define ETCf   NULL, constTypePtr(), NULL\n#define ETC 0, NULL, constTypePtr(), NULL\n\nextern StaticDeclaration static_declarations;\n\nYCPBuiltinMap {\n  YCPBuiltinMap::YCPBuiltinMap ()\n  {\n      // must be static, registerDeclarations saves a pointer to it!\n      static declaration_t declarations[] = {\n  #define ETC 0, NULL, constTypePtr(), NULL\n  #define ETCf   NULL, constTypePtr(), NULL\n  \t{ \"haskey\", \"boolean (const map <any,any>, const any)\",\t\t\t\t\t\t\t\t    (void *)m_haskey,                                                     ETC },\n  \t{ \"mapmap\", \"map <flex3,flex4> (variable <flex1>, variable <flex2>, const map <flex1,flex2>, const block <map <flex3, flex4>>)\",  (void *)m_mapmap,\tDECL_LOOP|DECL_SYMBOL|DECL_FLEX, ETCf },\n  \t{ \"maplist\",\"list <flex3> (variable <flex1>, variable <flex2>, const map <flex1,flex2>, const block <flex3>)\",\t    (void *)m_maplist,  DECL_LOOP|DECL_SYMBOL|DECL_FLEX,\t\t ETCf },\n  \t{ \"filter\", \"map <flex1,flex2> (variable <flex1>, variable <flex2>, const map <flex1,flex2>, const block <boolean>)\",(void *)m_filter,\tDECL_LOOP|DECL_SYMBOL|DECL_FLEX,\t\t ETCf },\n  \t{ \"union\",  \"map <any,any> (const map <any,any>, const map <any,any>)\",\t\t\t\t\t\t    (void *)m_unionmap,\t\t\t\t\t\t\t  ETC },\n  \t{ \"+\",\t    \"map <any,any> (const map <any,any>, const map <any,any>)\",\t\t\t\t\t\t    (void *)m_unionmap,\t\t\t\t\t\t\t  ETC },\n  \t{ \"add\",    \"map <flex1,flex2> (const map <flex1,flex2>, const flex1, const flex2)\",\t\t\t\t    (void *)m_addmap,\tDECL_FLEX,\t\t\t\t\t ETCf },\n  \t{ \"change\", \"map <flex1,flex2> (const map <flex1,flex2>, const flex1, const flex2)\",\t\t\t\t    (void *)m_changemap,DECL_FLEX|DECL_DEPRECATED,                       ETCf },\n  \t{ \"isempty\", \"boolean (const map <any,any>)\",\t\t\t\t\t\t\t\t\t    (void *)m_isempty,\t\t\t\t\t\t\t  ETC },\n  \t{ \"size\",   \"integer (const map <any,any>)\",\t\t\t\t\t\t\t\t\t    (void *)m_size,\tDECL_NIL,\t\t\t\t\t ETCf },\n  \t{ \"foreach\",\"flex1 (variable <flex2>, variable <flex3>, const map <flex2,flex3>, const block <flex1>)\",\t\t    (void *)m_foreach,\tDECL_LOOP|DECL_SYMBOL|DECL_FLEX,\t\t ETCf },\n  \t{ \"tomap\",  \"map <any,any> (const any)\",\t\t\t\t\t\t\t\t\t    (void *)m_tomap,\tDECL_FLEX,\t\t\t\t\t ETCf },\n          { \"remove\", \"map <flex1,flex2> (const map <flex1,flex2>, const flex1)\", \t\t\t\t\t    (void *)m_remove,\tDECL_FLEX,\t\t\t\t\t ETCf },\n  \t{ NULL, NULL, NULL, ETC }\n  #undef ETC\n  #undef ETCf\n  \t// \"lookup\" is in parser.yy\n      };\n  \n      static_declarations.registerDeclarations (\"YCPBuiltinMap\", declarations);\n  }\n}"
  },
  {
    "function_name": "m_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMap.cc",
    "lines": "491-534",
    "snippet": "static YCPValue\nm_remove (const YCPMap &map, const YCPValue &key)\n{\n    /**\n     * @builtin remove\n     * @id remove-map\n     * @short Remove key/value pair from a map\n     *\n     * @description\n     * Remove the value with the key <tt>KEY</tt> from a map. Returns\n     * unchanged map if the key is invalid.\n     *\n     * The yast2-core version < 2.17.16 returns nil if the key is invalid. This behavior\n     * has changed in version 2.17.16 to return unchanged map.\n     *\n     * @param map MAP\n     * @param any KEY\n     * @return map\n     *\n     * @usage remove($[1:2], 0) -> $[1:2]\n     * @usage remove($[1:2], 1) -> $[]\n     * @usage remove ($[1:2, 3:4], 1) -> $[3:4]\n     */\n\n    if (map.isNull ())\n\treturn YCPNull ();\n\t\n    if (key.isNull ())\n    {\n\tycp2error (\"Cannot use 'nil' as key in remove ()\");\n\treturn YCPNull ();\n    }\n\n    YCPMap ret = map;\n\n    if (!map->hasKey(key))\n    {\n        ycp2error ( \"Key %s for remove () does not exist\", key->toString ().c_str ());\n\treturn ret;\n    }\n    \n    ret->remove (key);\n    return ret;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPBuiltinMap.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret->remove",
          "args": [
            "key"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "remove",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "104-113",
          "snippet": "void YCPMapRep::remove(const YCPValue& key)\n{\n    if (!key->isString() && !key->isInteger() && !key->isSymbol())\n    {\n        ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n        return;\n    }\n\n    stl_map.erase (key);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void YCPMapRep::remove(const YCPValue& key)\n  {\n      if (!key->isString() && !key->isInteger() && !key->isSymbol())\n      {\n          ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n          return;\n      }\n  \n      stl_map.erase (key);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Key %s for remove () does not exist\"",
            "key->toString ().c_str ()"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key->toString",
          "args": [],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->hasKey",
          "args": [
            "key"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "hasKey",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "141-145",
          "snippet": "bool\nYCPMapRep::hasKey(const YCPValue& key) const\n{\n    return stl_map.find(key) != stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  bool\n  YCPMapRep::hasKey(const YCPValue& key) const\n  {\n      return stl_map.find(key) != stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Cannot use 'nil' as key in remove ()\""
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.isNull",
          "args": [],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map.isNull",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPBuiltinMap.h\"\n\nstatic YCPValue\nm_remove (const YCPMap &map, const YCPValue &key)\n{\n    /**\n     * @builtin remove\n     * @id remove-map\n     * @short Remove key/value pair from a map\n     *\n     * @description\n     * Remove the value with the key <tt>KEY</tt> from a map. Returns\n     * unchanged map if the key is invalid.\n     *\n     * The yast2-core version < 2.17.16 returns nil if the key is invalid. This behavior\n     * has changed in version 2.17.16 to return unchanged map.\n     *\n     * @param map MAP\n     * @param any KEY\n     * @return map\n     *\n     * @usage remove($[1:2], 0) -> $[1:2]\n     * @usage remove($[1:2], 1) -> $[]\n     * @usage remove ($[1:2, 3:4], 1) -> $[3:4]\n     */\n\n    if (map.isNull ())\n\treturn YCPNull ();\n\t\n    if (key.isNull ())\n    {\n\tycp2error (\"Cannot use 'nil' as key in remove ()\");\n\treturn YCPNull ();\n    }\n\n    YCPMap ret = map;\n\n    if (!map->hasKey(key))\n    {\n        ycp2error ( \"Key %s for remove () does not exist\", key->toString ().c_str ());\n\treturn ret;\n    }\n    \n    ret->remove (key);\n    return ret;\n}"
  },
  {
    "function_name": "m_tomap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMap.cc",
    "lines": "462-488",
    "snippet": "static YCPValue\nm_tomap (const YCPValue &v)\n{\n    /**\n     * @builtin tomap\n     * @short Converts a value to a map.\n     *\n     * @description\n     * If the value can't be converted to a map, nilmap is returned.\n     * Functionality partly replaced with retyping: <code>any a = $[1:1, 2:2];\n     * map m = (map) a;</code>\n     *\n     * @param any VALUE\n     * @return map\n     *\n     */\n\n    if (v.isNull())\n    {\n\treturn v;\n    }\n    if (v->valuetype() == YT_MAP)\n    {\n\treturn v->asMap();\n    }\n    return YCPNull();\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPBuiltinMap.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->asMap",
          "args": [],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->valuetype",
          "args": [],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "YCPSymbolRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "69-73",
          "snippet": "YCPValueType\nYCPSymbolRep::valuetype() const\n{\n    return YT_SYMBOL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbolRep {\n  YCPValueType\n  YCPSymbolRep::valuetype() const\n  {\n      return YT_SYMBOL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPBuiltinMap.h\"\n\nstatic YCPValue\nm_tomap (const YCPValue &v)\n{\n    /**\n     * @builtin tomap\n     * @short Converts a value to a map.\n     *\n     * @description\n     * If the value can't be converted to a map, nilmap is returned.\n     * Functionality partly replaced with retyping: <code>any a = $[1:1, 2:2];\n     * map m = (map) a;</code>\n     *\n     * @param any VALUE\n     * @return map\n     *\n     */\n\n    if (v.isNull())\n    {\n\treturn v;\n    }\n    if (v->valuetype() == YT_MAP)\n    {\n\treturn v->asMap();\n    }\n    return YCPNull();\n}"
  },
  {
    "function_name": "m_foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMap.cc",
    "lines": "411-459",
    "snippet": "static YCPValue\nm_foreach (const YCPValue &key, const YCPValue &val, const YCPMap &map, const YCPCode &expr)\n{\n    /**\n     * @builtin foreach\n     * @id foreach-map\n     * @short Process the content of a map\n     * @description\n     * For each key:value pair of the map <tt>MAP</tt> the expression\n     * <tt>EXPR</tt> is executed in a new block, where the variables\n     * <tt>KEY</tt> is bound to the key and <tt>VALUE</tt> is bound to the\n     * value. The return value of the last execution of exp is the value\n     * of the <tt>foreach</tt> construct.\n     * \n     * @param any KEY\n     * @param any VALUE\n     * @param map MAP\n     * @param any EXPR\n     * @return map\n     *\n     * @usage foreach (integer k, integer v, $[1:1,2:4,3:9], { y2debug(\"v = %1\", v); return v; }) -> 9 \n     */\n     \n    if (map.isNull ())\n\treturn YCPNull ();\n\n    SymbolEntryPtr k = key->asEntry()->entry();\n    SymbolEntryPtr v = val->asEntry()->entry();\n    YCPValue ret = YCPVoid();\n\n    for (YCPMap::const_iterator pos = map->begin(); pos != map->end(); ++pos)\n    {\n\tk->setValue (pos->first);\n\tv->setValue (pos->second);\n\n\tret = expr->evaluate ();\n\tif (ret.isNull())\n\t{\n\t    ycp2error (\"Bad foreach expression %s\", expr->toString ().c_str ());\n\t    return YCPNull ();\n\t}\n\tif (ret->isBreak())\n\t{\n\t    ret = YCPVoid();\n\t    break;\n\t}\n    }\n    return ret;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPBuiltinMap.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ret->isBreak",
          "args": [],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "isBreak",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "73-73",
          "snippet": "bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad foreach expression %s\"",
            "expr->toString ().c_str ()"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->toString",
          "args": [],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ret.isNull",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->evaluate",
          "args": [],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->setValue",
          "args": [
            "pos->second"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "IniEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "155-155",
          "snippet": "void setValue(const string&c)   { dirty = true; val = c;     }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniEntry {\n  void setValue(const string&c)   { dirty = true; val = c;     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->end",
          "args": [],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->begin",
          "args": [],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "val->asEntry",
          "args": [],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "asEntry",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "227-237",
          "snippet": "YCPEntry\nYCPValueRep::asEntry() const\n{\n    if (!isEntry())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPEntry (static_cast<const YCPEntryRep*>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPEntry\n  YCPValueRep::asEntry() const\n  {\n      if (!isEntry())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPEntry (static_cast<const YCPEntryRep*>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map.isNull",
          "args": [],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPBuiltinMap.h\"\n\nstatic YCPValue\nm_foreach (const YCPValue &key, const YCPValue &val, const YCPMap &map, const YCPCode &expr)\n{\n    /**\n     * @builtin foreach\n     * @id foreach-map\n     * @short Process the content of a map\n     * @description\n     * For each key:value pair of the map <tt>MAP</tt> the expression\n     * <tt>EXPR</tt> is executed in a new block, where the variables\n     * <tt>KEY</tt> is bound to the key and <tt>VALUE</tt> is bound to the\n     * value. The return value of the last execution of exp is the value\n     * of the <tt>foreach</tt> construct.\n     * \n     * @param any KEY\n     * @param any VALUE\n     * @param map MAP\n     * @param any EXPR\n     * @return map\n     *\n     * @usage foreach (integer k, integer v, $[1:1,2:4,3:9], { y2debug(\"v = %1\", v); return v; }) -> 9 \n     */\n     \n    if (map.isNull ())\n\treturn YCPNull ();\n\n    SymbolEntryPtr k = key->asEntry()->entry();\n    SymbolEntryPtr v = val->asEntry()->entry();\n    YCPValue ret = YCPVoid();\n\n    for (YCPMap::const_iterator pos = map->begin(); pos != map->end(); ++pos)\n    {\n\tk->setValue (pos->first);\n\tv->setValue (pos->second);\n\n\tret = expr->evaluate ();\n\tif (ret.isNull())\n\t{\n\t    ycp2error (\"Bad foreach expression %s\", expr->toString ().c_str ());\n\t    return YCPNull ();\n\t}\n\tif (ret->isBreak())\n\t{\n\t    ret = YCPVoid();\n\t    break;\n\t}\n    }\n    return ret;\n}"
  },
  {
    "function_name": "m_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMap.cc",
    "lines": "385-408",
    "snippet": "static YCPValue\nm_size (const YCPValue &map)\n{\n    /**\n     * @builtin size\n     * @id size-map\n     * @short Size of a map\n     *\n     * @description\n     * Returns the number of key/value pairs in the map <tt>MAP</tt>.\n     *\n     * @param map MAP\n     * @return integer\n     *\n     * @usage size($[\"a\":1, \"aa\":2, \"b\":3]) -> 3\n     */\n\n    if (map.isNull ()\n\t|| !map->isMap())\n    {\n\treturn YCPInteger (0LL);\n    }\n    return YCPInteger (map->asMap()->size ());\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPBuiltinMap.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPInteger",
          "args": [
            "map->asMap()->size ()"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "YCPInteger",
          "container": "YCPInteger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPInteger.cc",
          "lines": "142-145",
          "snippet": "YCPInteger::YCPInteger (bytecodeistream & str)\n    : YCPValue (new YCPIntegerRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/y2log.h\"\n\nYCPInteger {\n  YCPInteger::YCPInteger (bytecodeistream & str)\n      : YCPValue (new YCPIntegerRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->asMap",
          "args": [],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->isMap",
          "args": [],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "71-71",
          "snippet": "bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map.isNull",
          "args": [],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPBuiltinMap.h\"\n\nstatic YCPValue\nm_size (const YCPValue &map)\n{\n    /**\n     * @builtin size\n     * @id size-map\n     * @short Size of a map\n     *\n     * @description\n     * Returns the number of key/value pairs in the map <tt>MAP</tt>.\n     *\n     * @param map MAP\n     * @return integer\n     *\n     * @usage size($[\"a\":1, \"aa\":2, \"b\":3]) -> 3\n     */\n\n    if (map.isNull ()\n\t|| !map->isMap())\n    {\n\treturn YCPInteger (0LL);\n    }\n    return YCPInteger (map->asMap()->size ());\n}"
  },
  {
    "function_name": "m_isempty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMap.cc",
    "lines": "363-381",
    "snippet": "static YCPValue\nm_isempty(const YCPMap& m)\n{\n    /**\n     * @builtin isempty\n     * @id isempty-map\n     * @short Returns whether the map <tt>m</tt> is empty.\n     * @param map m Map\n     * @return boolean Emptiness of map <tt>m</tt>\n     *\n     * @description\n     * Notice that the map <tt>m</tt> must not be nil.\n     *\n     * @usage isempty($[]) -> true\n     * @usage isempty($[ `host : \"pandora\" ]) -> false\n     */\n\n    return YCPBoolean(m->isEmpty());\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPBuiltinMap.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "m->isEmpty()"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->isEmpty",
          "args": [],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "isEmpty",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "101-105",
          "snippet": "bool\nYCPTermRep::isEmpty() const\n{\n  return l->isEmpty();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  bool\n  YCPTermRep::isEmpty() const\n  {\n    return l->isEmpty();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPBuiltinMap.h\"\n\nstatic YCPValue\nm_isempty(const YCPMap& m)\n{\n    /**\n     * @builtin isempty\n     * @id isempty-map\n     * @short Returns whether the map <tt>m</tt> is empty.\n     * @param map m Map\n     * @return boolean Emptiness of map <tt>m</tt>\n     *\n     * @description\n     * Notice that the map <tt>m</tt> must not be nil.\n     *\n     * @usage isempty($[]) -> true\n     * @usage isempty($[ `host : \"pandora\" ]) -> false\n     */\n\n    return YCPBoolean(m->isEmpty());\n}"
  },
  {
    "function_name": "m_changemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMap.cc",
    "lines": "329-360",
    "snippet": "static YCPValue\nm_changemap (YCPMap &map, const YCPValue &key, const YCPValue &value)\n{\n    /**\n     * @builtin change\n     * @id change-map\n     * @short Change element pair in a map. Deprecated, use MAP[KEY] = VALUE.\n     * @description\n     * Before Code 9, this was used to change a map directly\n     * without creating a copy. Now it is a synonym for add.\n     *\n     * @param map MAP\n     * @param any KEY\n     * @param any VALUE\n     *\n     * @usage change ($[.a: 17, .b: 11], .b, nil) -> $[.a:17, .b:nil].\n     */\n\n    if (map.isNull ())\n\treturn YCPNull ();\n\t\n    if (key.isNull ())\n    {\n\tycp2error (\"Cannot use 'nil' as key in change ()\");\n\treturn YCPNull ();\n    }\n    \n    ycpinternal (\"Change does not work as expected! The argument is not passed by reference.\");\n\n    map->add (key, value);\n    return map;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPBuiltinMap.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->add",
          "args": [
            "key",
            "value"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "50-76",
          "snippet": "void\nYCPMapRep::add (const YCPValue& key, const YCPValue& value)\n{\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn;\n    }\n\n    // Note: 'stl_map[key] = value' would create a temporary object using the\n    // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n    // 24.\n\n    YCPMap::iterator pos = stl_map.lower_bound(key);\n    if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n    {\n\tpos->second = value;\n    }\n    else\n    {\n\t// pos is just a hint but can avoid a second search through the map\n\tstl_map.insert(pos, YCPMap::value_type(key, value));\n    }\n\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void\n  YCPMapRep::add (const YCPValue& key, const YCPValue& value)\n  {\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn;\n      }\n  \n      // Note: 'stl_map[key] = value' would create a temporary object using the\n      // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n      // 24.\n  \n      YCPMap::iterator pos = stl_map.lower_bound(key);\n      if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n      {\n  \tpos->second = value;\n      }\n      else\n      {\n  \t// pos is just a hint but can avoid a second search through the map\n  \tstl_map.insert(pos, YCPMap::value_type(key, value));\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycpinternal",
          "args": [
            "\"Change does not work as expected! The argument is not passed by reference.\""
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Cannot use 'nil' as key in change ()\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.isNull",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map.isNull",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPBuiltinMap.h\"\n\nstatic YCPValue\nm_changemap (YCPMap &map, const YCPValue &key, const YCPValue &value)\n{\n    /**\n     * @builtin change\n     * @id change-map\n     * @short Change element pair in a map. Deprecated, use MAP[KEY] = VALUE.\n     * @description\n     * Before Code 9, this was used to change a map directly\n     * without creating a copy. Now it is a synonym for add.\n     *\n     * @param map MAP\n     * @param any KEY\n     * @param any VALUE\n     *\n     * @usage change ($[.a: 17, .b: 11], .b, nil) -> $[.a:17, .b:nil].\n     */\n\n    if (map.isNull ())\n\treturn YCPNull ();\n\t\n    if (key.isNull ())\n    {\n\tycp2error (\"Cannot use 'nil' as key in change ()\");\n\treturn YCPNull ();\n    }\n    \n    ycpinternal (\"Change does not work as expected! The argument is not passed by reference.\");\n\n    map->add (key, value);\n    return map;\n}"
  },
  {
    "function_name": "m_addmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMap.cc",
    "lines": "292-326",
    "snippet": "static YCPValue\nm_addmap (const YCPMap &map, const YCPValue &key, const YCPValue &value)\n{\n    /**\n     * @builtin add \n     * @id add-map\n     * @short Add a key/value pair to a map\n     *\n     * @description\n     * Adds the key/value pair <tt>k : v</tt> to the map <tt>MAP</tt> and\n     * returns the newly Created map. If the key <tt>KEY</tt> exists in\n     * <tt>KEY</tt>, the old key/value pair is replaced with the new one.\n     * Functionality partly replaced with syntax: <code>map map m = $[\"a\":1];\n     * m[\"b\"] = 2; -> $[\"a\":1, \"b\":2]</code>\n     *\n     * @param map MAP\n     * @param any KEY\n     * @param any VALUE\n     * @return map\n     *\n     * @usage add ($[\"a\": 17, \"b\": 11], \"c\", 2) -> $[\"a\":17, \"b\":11, \"c\":2]\n     * @usage add ($[\"a\": 17, \"b\": 11], \"b\", 2) -> $[\"a\":17, \"b\":2]\n     */\n\n    if (map.isNull ())\n\treturn YCPNull ();\n\t\n    if (key.isNull ())\n    {\n\tycp2error (\"Cannot use 'nil' as key in add ()\");\n\treturn YCPNull ();\n    }\n\n    return map->functionalAdd (key, value);\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPBuiltinMap.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->functionalAdd",
          "args": [
            "key",
            "value"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "functionalAdd",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "79-101",
          "snippet": "YCPMap\nYCPMapRep::functionalAdd (const YCPValue& key, const YCPValue& value) const\n{\n    y2debug (\"YCPMapRep::functionalAdd ('%s', '%s', '%s')\", key->toString().c_str(), value->toString().c_str(), this->toString().c_str());\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn YCPNull ();\n    }\n\n    YCPMap newmap;\n\n    for (YCPMap::const_iterator pos = begin(); pos != end(); ++pos)\n    {\n\tnewmap->add(pos->first, pos->second);\n    }\n\n    newmap->add( key, value );\n\n    return newmap;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMap\n  YCPMapRep::functionalAdd (const YCPValue& key, const YCPValue& value) const\n  {\n      y2debug (\"YCPMapRep::functionalAdd ('%s', '%s', '%s')\", key->toString().c_str(), value->toString().c_str(), this->toString().c_str());\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn YCPNull ();\n      }\n  \n      YCPMap newmap;\n  \n      for (YCPMap::const_iterator pos = begin(); pos != end(); ++pos)\n      {\n  \tnewmap->add(pos->first, pos->second);\n      }\n  \n      newmap->add( key, value );\n  \n      return newmap;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Cannot use 'nil' as key in add ()\""
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.isNull",
          "args": [],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map.isNull",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPBuiltinMap.h\"\n\nstatic YCPValue\nm_addmap (const YCPMap &map, const YCPValue &key, const YCPValue &value)\n{\n    /**\n     * @builtin add \n     * @id add-map\n     * @short Add a key/value pair to a map\n     *\n     * @description\n     * Adds the key/value pair <tt>k : v</tt> to the map <tt>MAP</tt> and\n     * returns the newly Created map. If the key <tt>KEY</tt> exists in\n     * <tt>KEY</tt>, the old key/value pair is replaced with the new one.\n     * Functionality partly replaced with syntax: <code>map map m = $[\"a\":1];\n     * m[\"b\"] = 2; -> $[\"a\":1, \"b\":2]</code>\n     *\n     * @param map MAP\n     * @param any KEY\n     * @param any VALUE\n     * @return map\n     *\n     * @usage add ($[\"a\": 17, \"b\": 11], \"c\", 2) -> $[\"a\":17, \"b\":11, \"c\":2]\n     * @usage add ($[\"a\": 17, \"b\": 11], \"b\", 2) -> $[\"a\":17, \"b\":2]\n     */\n\n    if (map.isNull ())\n\treturn YCPNull ();\n\t\n    if (key.isNull ())\n    {\n\tycp2error (\"Cannot use 'nil' as key in add ()\");\n\treturn YCPNull ();\n    }\n\n    return map->functionalAdd (key, value);\n}"
  },
  {
    "function_name": "m_unionmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMap.cc",
    "lines": "252-289",
    "snippet": "static YCPValue\nm_unionmap (const YCPMap &map1, const YCPMap &map2)\n{\n    /**\n     * @builtin union\n     * @id union-map\n     * @short Union of 2 maps\n     * @description\n     * Interprets two maps as sets and returns a new map that has all\n     * elements of the first map <tt>MAP1</tt>and all of the second map\n     * <tt>MAP2</tt>. If elements have identical keys, values from\n     * <tt>MAP2</tt> overwrite elements from <tt>MAP1</tt>.\n     *\n     * @param map MAP1\n     * @param map MAP2\n     * @return map\n     *\n     * @usage union($[\"a\":1, \"b\":2], $[1:\"a\", 2:\"b\"]) -> $[1:\"a\", 2:\"b\", \"a\":1, \"b\":2]\n     * @usage union($[\"a\":1, \"b\":2], $[\"b\":10, \"c\":20]) -> $[\"a\":1, \"b\":10, \"c\":20]\n     */\n\n    if (map1.isNull () || map2.isNull ())\n\treturn YCPNull ();\n\n    YCPMap newmap;\n\n    for (int m = 0; m < 2; m++)\n    {\n\tYCPMap map = (m == 0 ? map1 : map2);\n\n\tfor (YCPMap::const_iterator pos = map->begin(); pos != map->end(); ++pos)\n\t{\n\t    newmap->add(pos->first, pos->second);\n\t}\n    }\n\n    return newmap;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPBuiltinMap.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "newmap->add",
          "args": [
            "pos->first",
            "pos->second"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "50-76",
          "snippet": "void\nYCPMapRep::add (const YCPValue& key, const YCPValue& value)\n{\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn;\n    }\n\n    // Note: 'stl_map[key] = value' would create a temporary object using the\n    // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n    // 24.\n\n    YCPMap::iterator pos = stl_map.lower_bound(key);\n    if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n    {\n\tpos->second = value;\n    }\n    else\n    {\n\t// pos is just a hint but can avoid a second search through the map\n\tstl_map.insert(pos, YCPMap::value_type(key, value));\n    }\n\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void\n  YCPMapRep::add (const YCPValue& key, const YCPValue& value)\n  {\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn;\n      }\n  \n      // Note: 'stl_map[key] = value' would create a temporary object using the\n      // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n      // 24.\n  \n      YCPMap::iterator pos = stl_map.lower_bound(key);\n      if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n      {\n  \tpos->second = value;\n      }\n      else\n      {\n  \t// pos is just a hint but can avoid a second search through the map\n  \tstl_map.insert(pos, YCPMap::value_type(key, value));\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->end",
          "args": [],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->begin",
          "args": [],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map2.isNull",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map1.isNull",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPBuiltinMap.h\"\n\nstatic YCPValue\nm_unionmap (const YCPMap &map1, const YCPMap &map2)\n{\n    /**\n     * @builtin union\n     * @id union-map\n     * @short Union of 2 maps\n     * @description\n     * Interprets two maps as sets and returns a new map that has all\n     * elements of the first map <tt>MAP1</tt>and all of the second map\n     * <tt>MAP2</tt>. If elements have identical keys, values from\n     * <tt>MAP2</tt> overwrite elements from <tt>MAP1</tt>.\n     *\n     * @param map MAP1\n     * @param map MAP2\n     * @return map\n     *\n     * @usage union($[\"a\":1, \"b\":2], $[1:\"a\", 2:\"b\"]) -> $[1:\"a\", 2:\"b\", \"a\":1, \"b\":2]\n     * @usage union($[\"a\":1, \"b\":2], $[\"b\":10, \"c\":20]) -> $[\"a\":1, \"b\":10, \"c\":20]\n     */\n\n    if (map1.isNull () || map2.isNull ())\n\treturn YCPNull ();\n\n    YCPMap newmap;\n\n    for (int m = 0; m < 2; m++)\n    {\n\tYCPMap map = (m == 0 ? map1 : map2);\n\n\tfor (YCPMap::const_iterator pos = map->begin(); pos != map->end(); ++pos)\n\t{\n\t    newmap->add(pos->first, pos->second);\n\t}\n    }\n\n    return newmap;\n}"
  },
  {
    "function_name": "m_maplist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMap.cc",
    "lines": "196-249",
    "snippet": "static YCPValue\nm_maplist (const YCPSymbol &key, const YCPSymbol &value,\n\t\t\t    const YCPMap &map, const YCPCode &expr)\n{\n    /**\n     * @builtin maplist \n     * @id maplist-map\n     * @short Maps an operation onto all elements key/value and create a list\n     * @description\n     * Maps an operation onto all elements key/value pairs of a map and thus creates\n     * a list.\n     *\n     * For each key/value pair of the map <tt>MAP</tt> the expression <tt>e</tt>\n     * is evaluated in a new block, where the variable <tt>KEY</tt>\n     * is assigned to the key and <tt>VALUE</tt> to the value of the pair.\n     * The result is the list of those evaluations.\n     * @param any KEY\n     * @param any VALUE\n     * @param map MAP\n     * @param block EXPR\n     * @return list\n     *\n     * @usage maplist (`k, `v, $[1:\"a\", 2:\"b\"], { return [k+10, v+\"x\"]; }) -> [ [11, \"ax\"], [ 12, \"bx\" ] ]\n     */\n\n    if (map.isNull ())\n\treturn YCPNull ();\n\n    YCPList ret;\n\n    SymbolEntryPtr k = key->asEntry()->entry();\n    SymbolEntryPtr v = value->asEntry()->entry();\n\n    for (YCPMap::const_iterator pos = map->begin(); pos != map->end(); ++pos)\n    {\n\tk->setValue (pos->first);\n\tv->setValue (pos->second);\n\n\tYCPValue v = expr->evaluate();\n\n\tif (v.isNull())\n\t{\n\t    ycp2error (\"Bad maplist expression %s\", expr->toString ().c_str ());\n\t    return YCPNull ();\n\t}\n\tif (v->isBreak())\n\t{\n\t    break;\n\t}\n\tret->add (v);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPBuiltinMap.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret->add",
          "args": [
            "v"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->isBreak",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "isBreak",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "73-73",
          "snippet": "bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad maplist expression %s\"",
            "expr->toString ().c_str ()"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->toString",
          "args": [],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->evaluate",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->setValue",
          "args": [
            "pos->second"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "IniEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "155-155",
          "snippet": "void setValue(const string&c)   { dirty = true; val = c;     }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniEntry {\n  void setValue(const string&c)   { dirty = true; val = c;     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->end",
          "args": [],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->begin",
          "args": [],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asEntry",
          "args": [],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "asEntry",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "227-237",
          "snippet": "YCPEntry\nYCPValueRep::asEntry() const\n{\n    if (!isEntry())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPEntry (static_cast<const YCPEntryRep*>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPEntry\n  YCPValueRep::asEntry() const\n  {\n      if (!isEntry())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPEntry (static_cast<const YCPEntryRep*>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map.isNull",
          "args": [],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPBuiltinMap.h\"\n\nstatic YCPValue\nm_maplist (const YCPSymbol &key, const YCPSymbol &value,\n\t\t\t    const YCPMap &map, const YCPCode &expr)\n{\n    /**\n     * @builtin maplist \n     * @id maplist-map\n     * @short Maps an operation onto all elements key/value and create a list\n     * @description\n     * Maps an operation onto all elements key/value pairs of a map and thus creates\n     * a list.\n     *\n     * For each key/value pair of the map <tt>MAP</tt> the expression <tt>e</tt>\n     * is evaluated in a new block, where the variable <tt>KEY</tt>\n     * is assigned to the key and <tt>VALUE</tt> to the value of the pair.\n     * The result is the list of those evaluations.\n     * @param any KEY\n     * @param any VALUE\n     * @param map MAP\n     * @param block EXPR\n     * @return list\n     *\n     * @usage maplist (`k, `v, $[1:\"a\", 2:\"b\"], { return [k+10, v+\"x\"]; }) -> [ [11, \"ax\"], [ 12, \"bx\" ] ]\n     */\n\n    if (map.isNull ())\n\treturn YCPNull ();\n\n    YCPList ret;\n\n    SymbolEntryPtr k = key->asEntry()->entry();\n    SymbolEntryPtr v = value->asEntry()->entry();\n\n    for (YCPMap::const_iterator pos = map->begin(); pos != map->end(); ++pos)\n    {\n\tk->setValue (pos->first);\n\tv->setValue (pos->second);\n\n\tYCPValue v = expr->evaluate();\n\n\tif (v.isNull())\n\t{\n\t    ycp2error (\"Bad maplist expression %s\", expr->toString ().c_str ());\n\t    return YCPNull ();\n\t}\n\tif (v->isBreak())\n\t{\n\t    break;\n\t}\n\tret->add (v);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "m_mapmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMap.cc",
    "lines": "130-193",
    "snippet": "static YCPValue\nm_mapmap (const YCPSymbol &key, const YCPSymbol &value,\n\t\t\t  const YCPMap &map, const YCPCode &expr)\n{\n    /**\n     * @builtin mapmap\n     * @short Maps an operation onto all key/value pairs of a map\n     *\n     * @description\n     * Maps an operation onto all key/value pairs of the map <tt>MAP</tt> and\n     * thus creates a new map. For each key/value pair of the map <tt>MAP</tt>\n     * the expression <tt>EXPR</tt> is evaluated in a new block, where the\n     * variable <tt>KEY</tt> is assigned to the key and <tt>VALUE</tt> to the value\n     * of the pair. The result is the map of those evaluations.\n     *\n     * The result of each evaluation <i>must</i> be a map with a single entry\n     * which will be added to the result map.\n     *\n     * @param any KEY\n     * @param any VALUE\n     * @param map MAP\n     * @param block EXPR\n     * @return map\n     *\n     * @usage mapmap (integer k, string v, $[1:\"a\", 2:\"b\"], { return ($[k+10 : v+\"x\"]); }) -> $[ 11:\"ax\", 12:\"bx\" ]\n     * @usage mapmap (integer k, string v, $[1:\"a\", 2:\"b\"], { integer a = k + 10; string b = v + \"x\"; return $[a:b]; }) -> $[ 11:\"ax\", 12:\"bx\" ]\n     */\n\n    if (map.isNull ())\n\treturn YCPNull ();\n\n    YCPMap expr_map;\n    YCPMap curr_map;\n    YCPMap ret;\n    SymbolEntryPtr k = key->asEntry()->entry();\n    SymbolEntryPtr v = value->asEntry()->entry();\n\n    for (YCPMap::const_iterator pos = map->begin (); pos != map->end (); ++pos)\n    {\n\tk->setValue (pos->first);\n\tv->setValue (pos->second);\n\n\tYCPValue curr_value = expr->evaluate ();\n\n\tif (!curr_value.isNull())\n\t{\n\t    if (curr_value->isBreak())\n\t    {\n\t\tbreak;\n\t    }\n\n\t    expr_map = curr_value->asMap();\n\t    YCPMap::const_iterator it = expr_map->begin();\n\t    ret->add(it->first, it->second);\n\t}\n\telse\n\t{\n\t    ycp2error (\"Bad mapmap expression %s\", expr->toString ().c_str ());\n\t    return YCPNull ();\n\t}\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPBuiltinMap.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad mapmap expression %s\"",
            "expr->toString ().c_str ()"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->toString",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ret->add",
          "args": [
            "it->first",
            "it->second"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "50-76",
          "snippet": "void\nYCPMapRep::add (const YCPValue& key, const YCPValue& value)\n{\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn;\n    }\n\n    // Note: 'stl_map[key] = value' would create a temporary object using the\n    // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n    // 24.\n\n    YCPMap::iterator pos = stl_map.lower_bound(key);\n    if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n    {\n\tpos->second = value;\n    }\n    else\n    {\n\t// pos is just a hint but can avoid a second search through the map\n\tstl_map.insert(pos, YCPMap::value_type(key, value));\n    }\n\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void\n  YCPMapRep::add (const YCPValue& key, const YCPValue& value)\n  {\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn;\n      }\n  \n      // Note: 'stl_map[key] = value' would create a temporary object using the\n      // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n      // 24.\n  \n      YCPMap::iterator pos = stl_map.lower_bound(key);\n      if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n      {\n  \tpos->second = value;\n      }\n      else\n      {\n  \t// pos is just a hint but can avoid a second search through the map\n  \tstl_map.insert(pos, YCPMap::value_type(key, value));\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expr_map->begin",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "curr_value->asMap",
          "args": [],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "curr_value->isBreak",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "isBreak",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "73-73",
          "snippet": "bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "curr_value.isNull",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->evaluate",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->setValue",
          "args": [
            "pos->second"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "IniEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "155-155",
          "snippet": "void setValue(const string&c)   { dirty = true; val = c;     }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniEntry {\n  void setValue(const string&c)   { dirty = true; val = c;     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->end",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asEntry",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "asEntry",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "227-237",
          "snippet": "YCPEntry\nYCPValueRep::asEntry() const\n{\n    if (!isEntry())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPEntry (static_cast<const YCPEntryRep*>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPEntry\n  YCPValueRep::asEntry() const\n  {\n      if (!isEntry())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPEntry (static_cast<const YCPEntryRep*>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map.isNull",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPBuiltinMap.h\"\n\nstatic YCPValue\nm_mapmap (const YCPSymbol &key, const YCPSymbol &value,\n\t\t\t  const YCPMap &map, const YCPCode &expr)\n{\n    /**\n     * @builtin mapmap\n     * @short Maps an operation onto all key/value pairs of a map\n     *\n     * @description\n     * Maps an operation onto all key/value pairs of the map <tt>MAP</tt> and\n     * thus creates a new map. For each key/value pair of the map <tt>MAP</tt>\n     * the expression <tt>EXPR</tt> is evaluated in a new block, where the\n     * variable <tt>KEY</tt> is assigned to the key and <tt>VALUE</tt> to the value\n     * of the pair. The result is the map of those evaluations.\n     *\n     * The result of each evaluation <i>must</i> be a map with a single entry\n     * which will be added to the result map.\n     *\n     * @param any KEY\n     * @param any VALUE\n     * @param map MAP\n     * @param block EXPR\n     * @return map\n     *\n     * @usage mapmap (integer k, string v, $[1:\"a\", 2:\"b\"], { return ($[k+10 : v+\"x\"]); }) -> $[ 11:\"ax\", 12:\"bx\" ]\n     * @usage mapmap (integer k, string v, $[1:\"a\", 2:\"b\"], { integer a = k + 10; string b = v + \"x\"; return $[a:b]; }) -> $[ 11:\"ax\", 12:\"bx\" ]\n     */\n\n    if (map.isNull ())\n\treturn YCPNull ();\n\n    YCPMap expr_map;\n    YCPMap curr_map;\n    YCPMap ret;\n    SymbolEntryPtr k = key->asEntry()->entry();\n    SymbolEntryPtr v = value->asEntry()->entry();\n\n    for (YCPMap::const_iterator pos = map->begin (); pos != map->end (); ++pos)\n    {\n\tk->setValue (pos->first);\n\tv->setValue (pos->second);\n\n\tYCPValue curr_value = expr->evaluate ();\n\n\tif (!curr_value.isNull())\n\t{\n\t    if (curr_value->isBreak())\n\t    {\n\t\tbreak;\n\t    }\n\n\t    expr_map = curr_value->asMap();\n\t    YCPMap::const_iterator it = expr_map->begin();\n\t    ret->add(it->first, it->second);\n\t}\n\telse\n\t{\n\t    ycp2error (\"Bad mapmap expression %s\", expr->toString ().c_str ());\n\t    return YCPNull ();\n\t}\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "m_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMap.cc",
    "lines": "69-127",
    "snippet": "static YCPValue\nm_filter (const YCPSymbol &key, const YCPSymbol &value,\n\t\t\t  const YCPMap &map, const YCPCode &expr)\n{\n    /**\n     * @builtin filter\n     * @id filter-map\n     * @short Filter a Map\n     * @description\n     * For each key/value pair of the map <tt>MAP</tt> the expression <tt>EXPR</tt>\n     * is evaluated in a new block, where the variable <tt>KEY</tt> is assigned\n     * to the key and <tt>VALUE</tt> to the value of the pair. If the expression\n     * evaluates to true, the key/value pair is appended to the returned map.\n     *\n     * @param any KEY\n     * @param any VALUE\n     * @param map MAP\n     * @param blocl EXPR\n     * @return map\n     * @usage filter (`k, `v, $[1:\"a\", 2:\"b\", 3:3, 5:5], { return (k == v); }) -> $[3:3, 5:5]\n     */\n\n    if (map.isNull ())\n\treturn YCPNull ();\n\n    YCPMap ret;\n    SymbolEntryPtr k = key->asEntry()->entry();\n    SymbolEntryPtr v = value->asEntry()->entry();\n\n    for (YCPMap::const_iterator pos = map->begin(); pos != map->end(); ++pos)\n    {\n\tk->setValue (pos->first);\n\tv->setValue (pos->second);\n\n\tYCPValue v = expr->evaluate ();\n\n\tif (v.isNull ())\n\t{\n\t    ycp2error (\"Bad filter expression %s\", expr->toString ().c_str ());\n\t    return YCPNull ();\n\t}\n        // nil == false\n        if (v->isVoid ())\n        {\n            ycp2error (\"The expression for 'filter' returned 'nil'\");\n            continue;\n        }\n\tif (v->isBreak())\n\t{\n\t    break;\n\t}\n\tif (v->asBoolean ()->value ())\n\t{\n\t    ret->add(pos->first, pos->second);\n\t}\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPBuiltinMap.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret->add",
          "args": [
            "pos->first",
            "pos->second"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "50-76",
          "snippet": "void\nYCPMapRep::add (const YCPValue& key, const YCPValue& value)\n{\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn;\n    }\n\n    // Note: 'stl_map[key] = value' would create a temporary object using the\n    // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n    // 24.\n\n    YCPMap::iterator pos = stl_map.lower_bound(key);\n    if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n    {\n\tpos->second = value;\n    }\n    else\n    {\n\t// pos is just a hint but can avoid a second search through the map\n\tstl_map.insert(pos, YCPMap::value_type(key, value));\n    }\n\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void\n  YCPMapRep::add (const YCPValue& key, const YCPValue& value)\n  {\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn;\n      }\n  \n      // Note: 'stl_map[key] = value' would create a temporary object using the\n      // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n      // 24.\n  \n      YCPMap::iterator pos = stl_map.lower_bound(key);\n      if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n      {\n  \tpos->second = value;\n      }\n      else\n      {\n  \t// pos is just a hint but can avoid a second search through the map\n  \tstl_map.insert(pos, YCPMap::value_type(key, value));\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->asBoolean",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "asBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "94-104",
          "snippet": "YCPBoolean\nYCPValueRep::asBoolean() const\n{\n    if (!isBoolean())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPBoolean\n  YCPValueRep::asBoolean() const\n  {\n      if (!isBoolean())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->isBreak",
          "args": [],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "isBreak",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "73-73",
          "snippet": "bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBreak()\t  const { return valuetype() == YT_BREAK; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"The expression for 'filter' returned 'nil'\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->isVoid",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad filter expression %s\"",
            "expr->toString ().c_str ()"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->toString",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->evaluate",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->setValue",
          "args": [
            "pos->second"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "IniEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "155-155",
          "snippet": "void setValue(const string&c)   { dirty = true; val = c;     }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniEntry {\n  void setValue(const string&c)   { dirty = true; val = c;     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->end",
          "args": [],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->begin",
          "args": [],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asEntry",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "asEntry",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "227-237",
          "snippet": "YCPEntry\nYCPValueRep::asEntry() const\n{\n    if (!isEntry())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPEntry (static_cast<const YCPEntryRep*>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPEntry\n  YCPValueRep::asEntry() const\n  {\n      if (!isEntry())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Entry !\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPEntry (static_cast<const YCPEntryRep*>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map.isNull",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPBuiltinMap.h\"\n\nstatic YCPValue\nm_filter (const YCPSymbol &key, const YCPSymbol &value,\n\t\t\t  const YCPMap &map, const YCPCode &expr)\n{\n    /**\n     * @builtin filter\n     * @id filter-map\n     * @short Filter a Map\n     * @description\n     * For each key/value pair of the map <tt>MAP</tt> the expression <tt>EXPR</tt>\n     * is evaluated in a new block, where the variable <tt>KEY</tt> is assigned\n     * to the key and <tt>VALUE</tt> to the value of the pair. If the expression\n     * evaluates to true, the key/value pair is appended to the returned map.\n     *\n     * @param any KEY\n     * @param any VALUE\n     * @param map MAP\n     * @param blocl EXPR\n     * @return map\n     * @usage filter (`k, `v, $[1:\"a\", 2:\"b\", 3:3, 5:5], { return (k == v); }) -> $[3:3, 5:5]\n     */\n\n    if (map.isNull ())\n\treturn YCPNull ();\n\n    YCPMap ret;\n    SymbolEntryPtr k = key->asEntry()->entry();\n    SymbolEntryPtr v = value->asEntry()->entry();\n\n    for (YCPMap::const_iterator pos = map->begin(); pos != map->end(); ++pos)\n    {\n\tk->setValue (pos->first);\n\tv->setValue (pos->second);\n\n\tYCPValue v = expr->evaluate ();\n\n\tif (v.isNull ())\n\t{\n\t    ycp2error (\"Bad filter expression %s\", expr->toString ().c_str ());\n\t    return YCPNull ();\n\t}\n        // nil == false\n        if (v->isVoid ())\n        {\n            ycp2error (\"The expression for 'filter' returned 'nil'\");\n            continue;\n        }\n\tif (v->isBreak())\n\t{\n\t    break;\n\t}\n\tif (v->asBoolean ()->value ())\n\t{\n\t    ret->add(pos->first, pos->second);\n\t}\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "m_haskey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMap.cc",
    "lines": "36-66",
    "snippet": "static YCPValue\nm_haskey (const YCPMap &map, const YCPValue &value)\n{\n    /**\n     * @builtin haskey\n     * @short Check if map has a certain key\n     *\n     * @description\n     * Determines whether the map <tt>MAP</tt> contains a pair with the\n     * key <tt>KEY</tt>. Returns true if this is true.\n     *\n     * @param map MAP\n     * @param any KEY\n     * @return boolean\n     *\n     * @usage haskey($[\"a\":1, \"b\":2], \"a\") -> true\n     * @usage haskey($[\"a\":1, \"b\":2], \"c\") -> false\n     */\n     \n    if (map.isNull ())\n    {\n\treturn YCPNull ();\n    }\t\n    if (value.isNull ())\n    {\n\tycp2error (\"Cannot use 'nil' as key in haskey ()\");\n\treturn YCPNull ();\n    }\n\n    return YCPBoolean(map->hasKey(value));\n}",
    "includes": [
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPSymbol.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPBuiltinMap.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "map->hasKey(value)"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->hasKey",
          "args": [
            "value"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "hasKey",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "141-145",
          "snippet": "bool\nYCPMapRep::hasKey(const YCPValue& key) const\n{\n    return stl_map.find(key) != stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  bool\n  YCPMapRep::hasKey(const YCPValue& key) const\n  {\n      return stl_map.find(key) != stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Cannot use 'nil' as key in haskey ()\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map.isNull",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPBuiltinMap.h\"\n\nstatic YCPValue\nm_haskey (const YCPMap &map, const YCPValue &value)\n{\n    /**\n     * @builtin haskey\n     * @short Check if map has a certain key\n     *\n     * @description\n     * Determines whether the map <tt>MAP</tt> contains a pair with the\n     * key <tt>KEY</tt>. Returns true if this is true.\n     *\n     * @param map MAP\n     * @param any KEY\n     * @return boolean\n     *\n     * @usage haskey($[\"a\":1, \"b\":2], \"a\") -> true\n     * @usage haskey($[\"a\":1, \"b\":2], \"c\") -> false\n     */\n     \n    if (map.isNull ())\n    {\n\treturn YCPNull ();\n    }\t\n    if (value.isNull ())\n    {\n\tycp2error (\"Cannot use 'nil' as key in haskey ()\");\n\treturn YCPNull ();\n    }\n\n    return YCPBoolean(map->hasKey(value));\n}"
  }
]