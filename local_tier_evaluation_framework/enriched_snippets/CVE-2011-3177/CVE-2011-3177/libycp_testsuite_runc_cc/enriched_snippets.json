[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runc.cc",
    "lines": "311-433",
    "snippet": "int main (int argc, char *argv[])\n{\n    int i = 0;\n\n    YCPPathSearch::initialize ();\n\n    for(;;)\n    {\n\tint option_index = 0;\n\n\tstatic struct option options[] =\n\t{\n\t    {\"help\", 0, 0, 'h'},\t\t\t// show help and exit\n\t    {\"version\", 0, 0, 'v'},\t\t\t// show version and exit\n\t    {\"recursive\", 0, 0, 'R'},\t\t\t// recursively\n\t    {\"quiet\", 0, 0, 'q'},\t\t\t// no output\n\t    {\"include-path\", 1, 0, 'I'},\t\t// where to find include files\n\t    {\"module-path\", 1, 0, 'M'},\t\t\t// where to find module files\n\t    {\"fsyntax-only\", 0, 0, 'E'},\t\t// parse only\n\t    {\"output\", 1, 0, 'o'},\t\t\t// output file\n\t    {\"compile\", 0, 0, 'c'},\t\t\t// compile to bytecode\n\t    {\"print\", 0, 0, 'p'},\t\t\t// print bytecode\n\t    {\"logfile\", 1, 0, 'l'},\t\t\t// print bytecode\n\t    {0, 0, 0, 0}\n\t};\n\n\tint c = getopt_long (argc, argv, \"h?vVpqrREcI:M:o:l:\", options, &option_index);\n\tif (c == EOF) break;\n\n\tswitch (c)\n\t{\n\t    case 'h':\n\t    case '?':\n\t\tprint_help (\"runc\");\n\t\texit (0);\n\t    case 'v':\n\t    case 'V':\n\t\tprint_version ();\n\t\texit (0);\n\t    case 'r':\n\t    case 'R':\n\t\tif (outname != 0)\n\t\t{\n\t\t    fprintf (stderr, \"-%c mutually exclusive with -c\\n\", c);\n\t\t    exit (1);\n\t\t}\n\t\trecursive = 1;\n\t\tbreak;\n\t    case 'p':\n\t\tprint = 1;\n\t\tbreak;\n\t    case 'q':\n\t\tquiet = 1;\n\t\tbreak;\n\t    case 'E':\n\t\tparse = 1;\n\t\tif (compile != 0)\n\t\t{\n\t\t    fprintf (stderr, \"-E mutually exclusive with -c\\n\");\n\t\t    exit (1);\n\t\t}\n\t\tbreak;\n\t    case 'c':\n\t\tcompile = 1;\n\t\tif (parse != 0)\n\t\t{\n\t\t    fprintf (stderr, \"-c mutually exclusive with -E\\n\");\n\t\t    exit (1);\n\t\t}\n\t\tbreak;\n\t    case 'I':\n\t\tYCPPathSearch::addPath (YCPPathSearch::Include, optarg);\n\t\tbreak;\n\t    case 'M':\n\t\tYCPPathSearch::addPath (YCPPathSearch::Module, optarg);\n\t\tbreak;\n\t    case 'l':\n\t\tset_log_filename (optarg);\n\t\tfclose (stderr);\n\t\tstderr = fopen (optarg, \"a+\");\n\t\tbreak;\n\t    case 'o':\n\t\tif (recursive)\n\t\t{\n\t\t    fprintf (stderr, \"-o mutually exclusive with -r\\n\");\n\t\t    exit (1);\n\t\t}\n\t\toutname = strdup (optarg);\n\t\tbreak;\n\t    default:\n\t\tfprintf (stderr,\"Try `%s -h' for more information.\\n\",argv[0]);\n\t\texit(1);\n\t}\n    }\n\n    if (compile == parse)\t\t// both are zero -> run\n    {\n\trun = 1;\n    }\n\n    if (optind == argc)\n    {\n\tfprintf (stderr, \"No input file or directory given\\n\");\n\texit (1);\n    }\n\t\n    for (i = optind; i < argc;i++)\n    {\n\tif (recursive)\n\t{\n\t    recurse (argv[i]);\n\t}\n\telse\n\t{\n\t    processfile (argv[i], outname);\n\t}\n    }\n\n    // this is for testsuite purpose only, so do not return a nonzero\n    // exit status. dejagnu will handle it by checking the error output\n\n    return 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <y2/Y2ComponentCreator.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *outname = 0;",
      "static int quiet = 0;",
      "static int recursive = 0;",
      "static int parse = 0;",
      "static int print = 0;",
      "static int compile = 0;",
      "static int run = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "processfile",
          "args": [
            "argv[i]",
            "outname"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "processfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runc.cc",
          "lines": "78-213",
          "snippet": "int\nprocessfile (const char *infname, char *outfname)\n{\n    if (infname == 0)\n    {\n\tfprintf (stderr, \"No input file given\\n\");\n\treturn 1;\n    }\n\n    if (parse || compile)\n    {\n\tif (!quiet) printf (\"parsing '%s'\\n\", infname);\n    }\n\n    if (compile\n\t&& outfname == 0)\n    {\n\tint len = strlen (infname);\n\tif (len > 4\n\t    && strcmp (infname + len - 4, \".ycp\") == 0)\n\t{\n\t    outfname = strdup (infname);\n\t    outfname[len-2] = 'b';\t// .ycp -> ybc\n\t    outfname[len-1] = 'c';\n\t    if (!quiet) printf (\"compiling to '%s'\\n\", outfname);\n\t}\n    }\n\n    if (run || print)\t// neither parse, nor compile -> run\n    {\n\tif (run)\n\t{\n\t    if (!quiet) printf (\"running '%s'\\n\", infname);\n\t}\n    }\n\n\n    if (parse || compile)\n    {\n\tif (parser == 0)\n\t{\n\t    parser = new Parser();\n\t}\n\tif (parser == 0)\n\t{\n\t    fprintf (stderr, \"Can't create parser\\n\");\n\t    return 1;\n\t}\n    }\n    \n    if (parser != 0)\n    {\n\tFILE *infile = fopen (infname, \"r\");\n\tif (infile == 0)\n\t{\n\t    fprintf (stderr, \"Can't  open \\\"%s\\\"\\n\", infname);\n\t    return 1;\n\t}\n\tparser->setInput (infile, infname);\n\tparser->setBuffered();\n\tSymbolTableDebug = 1;\n    }\n\n    YCodePtr c = 0;\n\n    if (parse || compile)\n    {\n\tif (!quiet) printf (\"parsing ...\\n\");\n\tc = parser->parse ();\n    }\n    else\n    {\n\tif (!quiet) printf (\"loading ...\\n\");\n\tc = Bytecode::readFile (infname);\n    }\n    if (!quiet) printf (\"done\\n\");\n\n    if (c == 0)\n    {\n\tfprintf (stderr, \"Fail: '%s'\\n\", infname);\n\treturn 1;\n    }\n\n    if (c->isError ())\n    {\n\tprintf (\"ERROR !\\n\");\n\tc->evaluate();\n\treturn 1;\n    }\n\n    std::ofstream outstream;\n\n    if (outfname != 0\n\t&& *outfname != '-'\n\t&& !outstream.is_open ())\n    {\n\toutstream.open (outfname, std::ios::out);\n    }\n\n    if (parse || print)\n    {\n\tif (!quiet) printf (\"Parsed:\\n\");\n\tif (outstream.is_open())\n\t{\n\t    outstream << c->toString();\n\t}\n\telse\n\t{\n\t    std::cout << c->toString();\n\t}\n    }\n    else if (compile)\n    {\n\tif (!quiet) printf (\"saving ...\\n\");\n\tBytecode::writeFile (c, string (outfname));\n    }\n    else\t// run\n    {\n\tif (!quiet) printf (\"running ...\\n\");\n\tYCPValue value = c->evaluate ();\n\n\tstring result = value.isNull() ? \"nil\" : value->toString();\n\tif (outstream.is_open())\n\t{\n\t    outstream << result << std::endl;\n\t}\n\telse\n\t{\n\t    std::cout << result << std::endl;\n\t}\n    }\n    \n    if (!quiet) printf (\"done\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <y2/Y2ComponentCreator.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int SymbolTableDebug;",
            "static Parser *parser = 0;",
            "static int quiet = 0;",
            "static int parse = 0;",
            "static int print = 0;",
            "static int compile = 0;",
            "static int run = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <fstream>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nextern int SymbolTableDebug;\nstatic Parser *parser = 0;\nstatic int quiet = 0;\nstatic int parse = 0;\nstatic int print = 0;\nstatic int compile = 0;\nstatic int run = 0;\n\nint\nprocessfile (const char *infname, char *outfname)\n{\n    if (infname == 0)\n    {\n\tfprintf (stderr, \"No input file given\\n\");\n\treturn 1;\n    }\n\n    if (parse || compile)\n    {\n\tif (!quiet) printf (\"parsing '%s'\\n\", infname);\n    }\n\n    if (compile\n\t&& outfname == 0)\n    {\n\tint len = strlen (infname);\n\tif (len > 4\n\t    && strcmp (infname + len - 4, \".ycp\") == 0)\n\t{\n\t    outfname = strdup (infname);\n\t    outfname[len-2] = 'b';\t// .ycp -> ybc\n\t    outfname[len-1] = 'c';\n\t    if (!quiet) printf (\"compiling to '%s'\\n\", outfname);\n\t}\n    }\n\n    if (run || print)\t// neither parse, nor compile -> run\n    {\n\tif (run)\n\t{\n\t    if (!quiet) printf (\"running '%s'\\n\", infname);\n\t}\n    }\n\n\n    if (parse || compile)\n    {\n\tif (parser == 0)\n\t{\n\t    parser = new Parser();\n\t}\n\tif (parser == 0)\n\t{\n\t    fprintf (stderr, \"Can't create parser\\n\");\n\t    return 1;\n\t}\n    }\n    \n    if (parser != 0)\n    {\n\tFILE *infile = fopen (infname, \"r\");\n\tif (infile == 0)\n\t{\n\t    fprintf (stderr, \"Can't  open \\\"%s\\\"\\n\", infname);\n\t    return 1;\n\t}\n\tparser->setInput (infile, infname);\n\tparser->setBuffered();\n\tSymbolTableDebug = 1;\n    }\n\n    YCodePtr c = 0;\n\n    if (parse || compile)\n    {\n\tif (!quiet) printf (\"parsing ...\\n\");\n\tc = parser->parse ();\n    }\n    else\n    {\n\tif (!quiet) printf (\"loading ...\\n\");\n\tc = Bytecode::readFile (infname);\n    }\n    if (!quiet) printf (\"done\\n\");\n\n    if (c == 0)\n    {\n\tfprintf (stderr, \"Fail: '%s'\\n\", infname);\n\treturn 1;\n    }\n\n    if (c->isError ())\n    {\n\tprintf (\"ERROR !\\n\");\n\tc->evaluate();\n\treturn 1;\n    }\n\n    std::ofstream outstream;\n\n    if (outfname != 0\n\t&& *outfname != '-'\n\t&& !outstream.is_open ())\n    {\n\toutstream.open (outfname, std::ios::out);\n    }\n\n    if (parse || print)\n    {\n\tif (!quiet) printf (\"Parsed:\\n\");\n\tif (outstream.is_open())\n\t{\n\t    outstream << c->toString();\n\t}\n\telse\n\t{\n\t    std::cout << c->toString();\n\t}\n    }\n    else if (compile)\n    {\n\tif (!quiet) printf (\"saving ...\\n\");\n\tBytecode::writeFile (c, string (outfname));\n    }\n    else\t// run\n    {\n\tif (!quiet) printf (\"running ...\\n\");\n\tYCPValue value = c->evaluate ();\n\n\tstring result = value.isNull() ? \"nil\" : value->toString();\n\tif (outstream.is_open())\n\t{\n\t    outstream << result << std::endl;\n\t}\n\telse\n\t{\n\t    std::cout << result << std::endl;\n\t}\n    }\n    \n    if (!quiet) printf (\"done\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recurse",
          "args": [
            "argv[i]"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "recurse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runc.cc",
          "lines": "220-286",
          "snippet": "int\nrecurse (const char *path)\n{\n    DIR *d;\n    struct dirent *dent;\n    struct stat st;\n    char *pp;\n    char name[1024];\n\n    if(!(d = opendir (path)))\n    {\n\tperror (path);\n\treturn 1;\n    }\n\n    /* fprintf (stderr,\"PATH: '%s'\\n\",path); */\n    while ((dent = readdir(d)))\n    {\n\tif (!(strcmp (dent->d_name, \".\")\n\t    && strcmp (dent->d_name, \"..\")))\n\t{\n\t    continue;\n\t}\n\tpp = (char*)malloc (strlen (path) + strlen (dent->d_name) + 30);\n\tif (!pp)\n\t{\n\t    perror (\"malloc\");\n\t    return 1;\n\t}\n\tstrcpy (pp,path);\n\tif (pp[strlen(pp)-1] != '/')\n\t{\n\t    strcat (pp, \"/\");\n\t}\n\tstrcat (pp, dent->d_name);\n\tif (lstat (pp, &st) == -1)\n\t{\n\t    perror (pp);\n\t    continue;\n\t}\n\tif (S_ISLNK (st.st_mode))\n\t{\n\t    continue;\n\t}\n\tif (S_ISDIR (st.st_mode))\n\t{\n\t    recurse (pp);\n\t}\n\tif (S_ISREG (st.st_mode))\n\t{\n\t    /* fprintf(stderr,\"FILE: %s%c%s\\n\",path,'/',dent->d_name); */\n\t    snprintf (name, sizeof (name), \"%s/%s\", path, dent->d_name);\n\n\t    if (strlen (name) > 4\n\t\t&& !strcmp (name+strlen(name)-4, \".ycp\"))\n\t    {\n\t\tif (processfile (name, NULL))\n\t\t{\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tfree (pp);\n    }\n    closedir (d);\n    return 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <y2/Y2ComponentCreator.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <fstream>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nint\nrecurse (const char *path)\n{\n    DIR *d;\n    struct dirent *dent;\n    struct stat st;\n    char *pp;\n    char name[1024];\n\n    if(!(d = opendir (path)))\n    {\n\tperror (path);\n\treturn 1;\n    }\n\n    /* fprintf (stderr,\"PATH: '%s'\\n\",path); */\n    while ((dent = readdir(d)))\n    {\n\tif (!(strcmp (dent->d_name, \".\")\n\t    && strcmp (dent->d_name, \"..\")))\n\t{\n\t    continue;\n\t}\n\tpp = (char*)malloc (strlen (path) + strlen (dent->d_name) + 30);\n\tif (!pp)\n\t{\n\t    perror (\"malloc\");\n\t    return 1;\n\t}\n\tstrcpy (pp,path);\n\tif (pp[strlen(pp)-1] != '/')\n\t{\n\t    strcat (pp, \"/\");\n\t}\n\tstrcat (pp, dent->d_name);\n\tif (lstat (pp, &st) == -1)\n\t{\n\t    perror (pp);\n\t    continue;\n\t}\n\tif (S_ISLNK (st.st_mode))\n\t{\n\t    continue;\n\t}\n\tif (S_ISDIR (st.st_mode))\n\t{\n\t    recurse (pp);\n\t}\n\tif (S_ISREG (st.st_mode))\n\t{\n\t    /* fprintf(stderr,\"FILE: %s%c%s\\n\",path,'/',dent->d_name); */\n\t    snprintf (name, sizeof (name), \"%s/%s\", path, dent->d_name);\n\n\t    if (strlen (name) > 4\n\t\t&& !strcmp (name+strlen(name)-4, \".ycp\"))\n\t    {\n\t\tif (processfile (name, NULL))\n\t\t{\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tfree (pp);\n    }\n    closedir (d);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"No input file or directory given\\n\""
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Try `%s -h' for more information.\\n\"",
            "argv[0]"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "optarg"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"-o mutually exclusive with -r\\n\""
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "optarg",
            "\"a+\""
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "stderr"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_log_filename",
          "args": [
            "optarg"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "set_log_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2changes.cc",
          "lines": "188-240",
          "snippet": "static void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2CHANGES_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2CHANGES_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2CHANGES_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2CHANGES_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2CHANGES_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2CHANGES_FALLBACK );\n\n\t\tlogname = Y2CHANGES_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2CHANGES_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2CHANGES_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2CHANGES_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2CHANGES_VAR_NUM\t\"Y2MAXLOGNUM\"",
            "#define Y2CHANGES_VAR_SIZE\t\"Y2MAXLOGSIZE\"",
            "#define Y2CHANGES_FALLBACK\t\"/y2changes\"",
            "#define Y2CHANGES_USER\t\"/.y2changes\"\t\t/* Relative to $HOME */",
            "#define Y2CHANGES_ROOT\tLOGDIR \"/y2changes\"",
            "#define Y2CHANGES_MAXNUM\t10\t\t\t/* Maximum logfiles number */",
            "#define Y2CHANGES_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */"
          ],
          "globals_used": [
            "static bool did_set_logname = false;",
            "static const char *logname;",
            "static off_t maxlogsize;",
            "static int   maxlognum;",
            "static bool log_to_file = true;",
            "static bool log_to_syslog = false;",
            "static FILE *Y2CHANGES_STDERR = stderr;",
            "static void shift_log_files(string filename);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/y2changes.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2CHANGES_VAR_NUM\t\"Y2MAXLOGNUM\"\n#define Y2CHANGES_VAR_SIZE\t\"Y2MAXLOGSIZE\"\n#define Y2CHANGES_FALLBACK\t\"/y2changes\"\n#define Y2CHANGES_USER\t\"/.y2changes\"\t\t/* Relative to $HOME */\n#define Y2CHANGES_ROOT\tLOGDIR \"/y2changes\"\n#define Y2CHANGES_MAXNUM\t10\t\t\t/* Maximum logfiles number */\n#define Y2CHANGES_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */\n\nstatic bool did_set_logname = false;\nstatic const char *logname;\nstatic off_t maxlogsize;\nstatic int   maxlognum;\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic FILE *Y2CHANGES_STDERR = stderr;\nstatic void shift_log_files(string filename);\n\nstatic void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2CHANGES_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2CHANGES_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2CHANGES_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2CHANGES_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2CHANGES_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2CHANGES_FALLBACK );\n\n\t\tlogname = Y2CHANGES_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2CHANGES_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2CHANGES_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2CHANGES_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPPathSearch::addPath",
          "args": [
            "YCPPathSearch::Module",
            "optarg"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "addPath",
          "container": "YCPPathSearch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/pathsearch.cc",
          "lines": "343-349",
          "snippet": "void\nYCPPathSearch::addPath (Kind kind, const string& path)\n{\n    std::list<string>& l = searchList[kind];\n    if (std::find(l.begin(), l.end(), path) == l.end())\n\tl.push_front(path);\n}",
          "includes": [
            "#include \"pathsearch.h\"",
            "#include <ycp/y2log.h>",
            "#include <boost/algorithm/string.hpp>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "std::list<string> YCPPathSearch::searchList[YCPPathSearch::num_Kind];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pathsearch.h\"\n#include <ycp/y2log.h>\n#include <boost/algorithm/string.hpp>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n\nstd::list<string> YCPPathSearch::searchList[YCPPathSearch::num_Kind];\n\nYCPPathSearch {\n  void\n  YCPPathSearch::addPath (Kind kind, const string& path)\n  {\n      std::list<string>& l = searchList[kind];\n      if (std::find(l.begin(), l.end(), path) == l.end())\n  \tl.push_front(path);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"-c mutually exclusive with -E\\n\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"-E mutually exclusive with -c\\n\""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"-%c mutually exclusive with -c\\n\"",
            "c"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_version",
          "args": [],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "print_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runc.cc",
          "lines": "302-306",
          "snippet": "void print_version()\n{\n    printf (\"runc (libycp %s)\\n\", VERSION);\n    printf (\"Standalone YCP bytecode compiler\\n\");\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <y2/Y2ComponentCreator.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <fstream>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nvoid print_version()\n{\n    printf (\"runc (libycp %s)\\n\", VERSION);\n    printf (\"Standalone YCP bytecode compiler\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_help",
          "args": [
            "\"runc\""
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "print_help",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runc.cc",
          "lines": "291-297",
          "snippet": "void print_help (const char *name)\n{\n    printf (\"Usage:\\n\");\n    printf (\"  %s [-h] [--help]\\n\", name);\n    printf (\"  %s [-v] [--version]\\n\", name);\n    printf (\"  %s [-q] [-R] {-I include-path} {-M module-path} {-l logfile} {-c|-E|-p} {-o output} <filename>\\n\", name);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <y2/Y2ComponentCreator.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <fstream>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nvoid print_help (const char *name)\n{\n    printf (\"Usage:\\n\");\n    printf (\"  %s [-h] [--help]\\n\", name);\n    printf (\"  %s [-v] [--version]\\n\", name);\n    printf (\"  %s [-q] [-R] {-I include-path} {-M module-path} {-l logfile} {-c|-E|-p} {-o output} <filename>\\n\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt_long",
          "args": [
            "argc",
            "argv",
            "\"h?vVpqrREcI:M:o:l:\"",
            "options",
            "&option_index"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPPathSearch::initialize",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "initialize",
          "container": "YCPPathSearch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/pathsearch.cc",
          "lines": "274-284",
          "snippet": "void\nYCPPathSearch::initialize ()\n{\n    if (! initialized)\n    {\n\tinitialize (Client, \"/clients\");\n\tinitialize (Include, \"/include\");\n\tinitialize (Module, \"/modules\");\n\tinitialized = true;\n    }\n}",
          "includes": [
            "#include \"pathsearch.h\"",
            "#include <ycp/y2log.h>",
            "#include <boost/algorithm/string.hpp>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool YCPPathSearch::initialized = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pathsearch.h\"\n#include <ycp/y2log.h>\n#include <boost/algorithm/string.hpp>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n\nbool YCPPathSearch::initialized = false;\n\nYCPPathSearch {\n  void\n  YCPPathSearch::initialize ()\n  {\n      if (! initialized)\n      {\n  \tinitialize (Client, \"/clients\");\n  \tinitialize (Include, \"/include\");\n  \tinitialize (Module, \"/modules\");\n  \tinitialized = true;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <fstream>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic char *outname = 0;\nstatic int quiet = 0;\nstatic int recursive = 0;\nstatic int parse = 0;\nstatic int print = 0;\nstatic int compile = 0;\nstatic int run = 0;\n\nint main (int argc, char *argv[])\n{\n    int i = 0;\n\n    YCPPathSearch::initialize ();\n\n    for(;;)\n    {\n\tint option_index = 0;\n\n\tstatic struct option options[] =\n\t{\n\t    {\"help\", 0, 0, 'h'},\t\t\t// show help and exit\n\t    {\"version\", 0, 0, 'v'},\t\t\t// show version and exit\n\t    {\"recursive\", 0, 0, 'R'},\t\t\t// recursively\n\t    {\"quiet\", 0, 0, 'q'},\t\t\t// no output\n\t    {\"include-path\", 1, 0, 'I'},\t\t// where to find include files\n\t    {\"module-path\", 1, 0, 'M'},\t\t\t// where to find module files\n\t    {\"fsyntax-only\", 0, 0, 'E'},\t\t// parse only\n\t    {\"output\", 1, 0, 'o'},\t\t\t// output file\n\t    {\"compile\", 0, 0, 'c'},\t\t\t// compile to bytecode\n\t    {\"print\", 0, 0, 'p'},\t\t\t// print bytecode\n\t    {\"logfile\", 1, 0, 'l'},\t\t\t// print bytecode\n\t    {0, 0, 0, 0}\n\t};\n\n\tint c = getopt_long (argc, argv, \"h?vVpqrREcI:M:o:l:\", options, &option_index);\n\tif (c == EOF) break;\n\n\tswitch (c)\n\t{\n\t    case 'h':\n\t    case '?':\n\t\tprint_help (\"runc\");\n\t\texit (0);\n\t    case 'v':\n\t    case 'V':\n\t\tprint_version ();\n\t\texit (0);\n\t    case 'r':\n\t    case 'R':\n\t\tif (outname != 0)\n\t\t{\n\t\t    fprintf (stderr, \"-%c mutually exclusive with -c\\n\", c);\n\t\t    exit (1);\n\t\t}\n\t\trecursive = 1;\n\t\tbreak;\n\t    case 'p':\n\t\tprint = 1;\n\t\tbreak;\n\t    case 'q':\n\t\tquiet = 1;\n\t\tbreak;\n\t    case 'E':\n\t\tparse = 1;\n\t\tif (compile != 0)\n\t\t{\n\t\t    fprintf (stderr, \"-E mutually exclusive with -c\\n\");\n\t\t    exit (1);\n\t\t}\n\t\tbreak;\n\t    case 'c':\n\t\tcompile = 1;\n\t\tif (parse != 0)\n\t\t{\n\t\t    fprintf (stderr, \"-c mutually exclusive with -E\\n\");\n\t\t    exit (1);\n\t\t}\n\t\tbreak;\n\t    case 'I':\n\t\tYCPPathSearch::addPath (YCPPathSearch::Include, optarg);\n\t\tbreak;\n\t    case 'M':\n\t\tYCPPathSearch::addPath (YCPPathSearch::Module, optarg);\n\t\tbreak;\n\t    case 'l':\n\t\tset_log_filename (optarg);\n\t\tfclose (stderr);\n\t\tstderr = fopen (optarg, \"a+\");\n\t\tbreak;\n\t    case 'o':\n\t\tif (recursive)\n\t\t{\n\t\t    fprintf (stderr, \"-o mutually exclusive with -r\\n\");\n\t\t    exit (1);\n\t\t}\n\t\toutname = strdup (optarg);\n\t\tbreak;\n\t    default:\n\t\tfprintf (stderr,\"Try `%s -h' for more information.\\n\",argv[0]);\n\t\texit(1);\n\t}\n    }\n\n    if (compile == parse)\t\t// both are zero -> run\n    {\n\trun = 1;\n    }\n\n    if (optind == argc)\n    {\n\tfprintf (stderr, \"No input file or directory given\\n\");\n\texit (1);\n    }\n\t\n    for (i = optind; i < argc;i++)\n    {\n\tif (recursive)\n\t{\n\t    recurse (argv[i]);\n\t}\n\telse\n\t{\n\t    processfile (argv[i], outname);\n\t}\n    }\n\n    // this is for testsuite purpose only, so do not return a nonzero\n    // exit status. dejagnu will handle it by checking the error output\n\n    return 0;\n}"
  },
  {
    "function_name": "print_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runc.cc",
    "lines": "302-306",
    "snippet": "void print_version()\n{\n    printf (\"runc (libycp %s)\\n\", VERSION);\n    printf (\"Standalone YCP bytecode compiler\\n\");\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <y2/Y2ComponentCreator.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Standalone YCP bytecode compiler\\n\""
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"runc (libycp %s)\\n\"",
            "VERSION"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <fstream>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nvoid print_version()\n{\n    printf (\"runc (libycp %s)\\n\", VERSION);\n    printf (\"Standalone YCP bytecode compiler\\n\");\n}"
  },
  {
    "function_name": "print_help",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runc.cc",
    "lines": "291-297",
    "snippet": "void print_help (const char *name)\n{\n    printf (\"Usage:\\n\");\n    printf (\"  %s [-h] [--help]\\n\", name);\n    printf (\"  %s [-v] [--version]\\n\", name);\n    printf (\"  %s [-q] [-R] {-I include-path} {-M module-path} {-l logfile} {-c|-E|-p} {-o output} <filename>\\n\", name);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <y2/Y2ComponentCreator.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  %s [-q] [-R] {-I include-path} {-M module-path} {-l logfile} {-c|-E|-p} {-o output} <filename>\\n\"",
            "name"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  %s [-v] [--version]\\n\"",
            "name"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  %s [-h] [--help]\\n\"",
            "name"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Usage:\\n\""
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <fstream>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nvoid print_help (const char *name)\n{\n    printf (\"Usage:\\n\");\n    printf (\"  %s [-h] [--help]\\n\", name);\n    printf (\"  %s [-v] [--version]\\n\", name);\n    printf (\"  %s [-q] [-R] {-I include-path} {-M module-path} {-l logfile} {-c|-E|-p} {-o output} <filename>\\n\", name);\n}"
  },
  {
    "function_name": "recurse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runc.cc",
    "lines": "220-286",
    "snippet": "int\nrecurse (const char *path)\n{\n    DIR *d;\n    struct dirent *dent;\n    struct stat st;\n    char *pp;\n    char name[1024];\n\n    if(!(d = opendir (path)))\n    {\n\tperror (path);\n\treturn 1;\n    }\n\n    /* fprintf (stderr,\"PATH: '%s'\\n\",path); */\n    while ((dent = readdir(d)))\n    {\n\tif (!(strcmp (dent->d_name, \".\")\n\t    && strcmp (dent->d_name, \"..\")))\n\t{\n\t    continue;\n\t}\n\tpp = (char*)malloc (strlen (path) + strlen (dent->d_name) + 30);\n\tif (!pp)\n\t{\n\t    perror (\"malloc\");\n\t    return 1;\n\t}\n\tstrcpy (pp,path);\n\tif (pp[strlen(pp)-1] != '/')\n\t{\n\t    strcat (pp, \"/\");\n\t}\n\tstrcat (pp, dent->d_name);\n\tif (lstat (pp, &st) == -1)\n\t{\n\t    perror (pp);\n\t    continue;\n\t}\n\tif (S_ISLNK (st.st_mode))\n\t{\n\t    continue;\n\t}\n\tif (S_ISDIR (st.st_mode))\n\t{\n\t    recurse (pp);\n\t}\n\tif (S_ISREG (st.st_mode))\n\t{\n\t    /* fprintf(stderr,\"FILE: %s%c%s\\n\",path,'/',dent->d_name); */\n\t    snprintf (name, sizeof (name), \"%s/%s\", path, dent->d_name);\n\n\t    if (strlen (name) > 4\n\t\t&& !strcmp (name+strlen(name)-4, \".ycp\"))\n\t    {\n\t\tif (processfile (name, NULL))\n\t\t{\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tfree (pp);\n    }\n    closedir (d);\n    return 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <y2/Y2ComponentCreator.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "d"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pp"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "processfile",
          "args": [
            "name",
            "NULL"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "processfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runc.cc",
          "lines": "78-213",
          "snippet": "int\nprocessfile (const char *infname, char *outfname)\n{\n    if (infname == 0)\n    {\n\tfprintf (stderr, \"No input file given\\n\");\n\treturn 1;\n    }\n\n    if (parse || compile)\n    {\n\tif (!quiet) printf (\"parsing '%s'\\n\", infname);\n    }\n\n    if (compile\n\t&& outfname == 0)\n    {\n\tint len = strlen (infname);\n\tif (len > 4\n\t    && strcmp (infname + len - 4, \".ycp\") == 0)\n\t{\n\t    outfname = strdup (infname);\n\t    outfname[len-2] = 'b';\t// .ycp -> ybc\n\t    outfname[len-1] = 'c';\n\t    if (!quiet) printf (\"compiling to '%s'\\n\", outfname);\n\t}\n    }\n\n    if (run || print)\t// neither parse, nor compile -> run\n    {\n\tif (run)\n\t{\n\t    if (!quiet) printf (\"running '%s'\\n\", infname);\n\t}\n    }\n\n\n    if (parse || compile)\n    {\n\tif (parser == 0)\n\t{\n\t    parser = new Parser();\n\t}\n\tif (parser == 0)\n\t{\n\t    fprintf (stderr, \"Can't create parser\\n\");\n\t    return 1;\n\t}\n    }\n    \n    if (parser != 0)\n    {\n\tFILE *infile = fopen (infname, \"r\");\n\tif (infile == 0)\n\t{\n\t    fprintf (stderr, \"Can't  open \\\"%s\\\"\\n\", infname);\n\t    return 1;\n\t}\n\tparser->setInput (infile, infname);\n\tparser->setBuffered();\n\tSymbolTableDebug = 1;\n    }\n\n    YCodePtr c = 0;\n\n    if (parse || compile)\n    {\n\tif (!quiet) printf (\"parsing ...\\n\");\n\tc = parser->parse ();\n    }\n    else\n    {\n\tif (!quiet) printf (\"loading ...\\n\");\n\tc = Bytecode::readFile (infname);\n    }\n    if (!quiet) printf (\"done\\n\");\n\n    if (c == 0)\n    {\n\tfprintf (stderr, \"Fail: '%s'\\n\", infname);\n\treturn 1;\n    }\n\n    if (c->isError ())\n    {\n\tprintf (\"ERROR !\\n\");\n\tc->evaluate();\n\treturn 1;\n    }\n\n    std::ofstream outstream;\n\n    if (outfname != 0\n\t&& *outfname != '-'\n\t&& !outstream.is_open ())\n    {\n\toutstream.open (outfname, std::ios::out);\n    }\n\n    if (parse || print)\n    {\n\tif (!quiet) printf (\"Parsed:\\n\");\n\tif (outstream.is_open())\n\t{\n\t    outstream << c->toString();\n\t}\n\telse\n\t{\n\t    std::cout << c->toString();\n\t}\n    }\n    else if (compile)\n    {\n\tif (!quiet) printf (\"saving ...\\n\");\n\tBytecode::writeFile (c, string (outfname));\n    }\n    else\t// run\n    {\n\tif (!quiet) printf (\"running ...\\n\");\n\tYCPValue value = c->evaluate ();\n\n\tstring result = value.isNull() ? \"nil\" : value->toString();\n\tif (outstream.is_open())\n\t{\n\t    outstream << result << std::endl;\n\t}\n\telse\n\t{\n\t    std::cout << result << std::endl;\n\t}\n    }\n    \n    if (!quiet) printf (\"done\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <y2/Y2ComponentCreator.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int SymbolTableDebug;",
            "static Parser *parser = 0;",
            "static int quiet = 0;",
            "static int parse = 0;",
            "static int print = 0;",
            "static int compile = 0;",
            "static int run = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <fstream>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nextern int SymbolTableDebug;\nstatic Parser *parser = 0;\nstatic int quiet = 0;\nstatic int parse = 0;\nstatic int print = 0;\nstatic int compile = 0;\nstatic int run = 0;\n\nint\nprocessfile (const char *infname, char *outfname)\n{\n    if (infname == 0)\n    {\n\tfprintf (stderr, \"No input file given\\n\");\n\treturn 1;\n    }\n\n    if (parse || compile)\n    {\n\tif (!quiet) printf (\"parsing '%s'\\n\", infname);\n    }\n\n    if (compile\n\t&& outfname == 0)\n    {\n\tint len = strlen (infname);\n\tif (len > 4\n\t    && strcmp (infname + len - 4, \".ycp\") == 0)\n\t{\n\t    outfname = strdup (infname);\n\t    outfname[len-2] = 'b';\t// .ycp -> ybc\n\t    outfname[len-1] = 'c';\n\t    if (!quiet) printf (\"compiling to '%s'\\n\", outfname);\n\t}\n    }\n\n    if (run || print)\t// neither parse, nor compile -> run\n    {\n\tif (run)\n\t{\n\t    if (!quiet) printf (\"running '%s'\\n\", infname);\n\t}\n    }\n\n\n    if (parse || compile)\n    {\n\tif (parser == 0)\n\t{\n\t    parser = new Parser();\n\t}\n\tif (parser == 0)\n\t{\n\t    fprintf (stderr, \"Can't create parser\\n\");\n\t    return 1;\n\t}\n    }\n    \n    if (parser != 0)\n    {\n\tFILE *infile = fopen (infname, \"r\");\n\tif (infile == 0)\n\t{\n\t    fprintf (stderr, \"Can't  open \\\"%s\\\"\\n\", infname);\n\t    return 1;\n\t}\n\tparser->setInput (infile, infname);\n\tparser->setBuffered();\n\tSymbolTableDebug = 1;\n    }\n\n    YCodePtr c = 0;\n\n    if (parse || compile)\n    {\n\tif (!quiet) printf (\"parsing ...\\n\");\n\tc = parser->parse ();\n    }\n    else\n    {\n\tif (!quiet) printf (\"loading ...\\n\");\n\tc = Bytecode::readFile (infname);\n    }\n    if (!quiet) printf (\"done\\n\");\n\n    if (c == 0)\n    {\n\tfprintf (stderr, \"Fail: '%s'\\n\", infname);\n\treturn 1;\n    }\n\n    if (c->isError ())\n    {\n\tprintf (\"ERROR !\\n\");\n\tc->evaluate();\n\treturn 1;\n    }\n\n    std::ofstream outstream;\n\n    if (outfname != 0\n\t&& *outfname != '-'\n\t&& !outstream.is_open ())\n    {\n\toutstream.open (outfname, std::ios::out);\n    }\n\n    if (parse || print)\n    {\n\tif (!quiet) printf (\"Parsed:\\n\");\n\tif (outstream.is_open())\n\t{\n\t    outstream << c->toString();\n\t}\n\telse\n\t{\n\t    std::cout << c->toString();\n\t}\n    }\n    else if (compile)\n    {\n\tif (!quiet) printf (\"saving ...\\n\");\n\tBytecode::writeFile (c, string (outfname));\n    }\n    else\t// run\n    {\n\tif (!quiet) printf (\"running ...\\n\");\n\tYCPValue value = c->evaluate ();\n\n\tstring result = value.isNull() ? \"nil\" : value->toString();\n\tif (outstream.is_open())\n\t{\n\t    outstream << result << std::endl;\n\t}\n\telse\n\t{\n\t    std::cout << result << std::endl;\n\t}\n    }\n    \n    if (!quiet) printf (\"done\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name+strlen(name)-4",
            "\".ycp\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "sizeof (name)",
            "\"%s/%s\"",
            "path",
            "dent->d_name"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recurse",
          "args": [
            "pp"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "recurse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runc.cc",
          "lines": "220-286",
          "snippet": "int\nrecurse (const char *path)\n{\n    DIR *d;\n    struct dirent *dent;\n    struct stat st;\n    char *pp;\n    char name[1024];\n\n    if(!(d = opendir (path)))\n    {\n\tperror (path);\n\treturn 1;\n    }\n\n    /* fprintf (stderr,\"PATH: '%s'\\n\",path); */\n    while ((dent = readdir(d)))\n    {\n\tif (!(strcmp (dent->d_name, \".\")\n\t    && strcmp (dent->d_name, \"..\")))\n\t{\n\t    continue;\n\t}\n\tpp = (char*)malloc (strlen (path) + strlen (dent->d_name) + 30);\n\tif (!pp)\n\t{\n\t    perror (\"malloc\");\n\t    return 1;\n\t}\n\tstrcpy (pp,path);\n\tif (pp[strlen(pp)-1] != '/')\n\t{\n\t    strcat (pp, \"/\");\n\t}\n\tstrcat (pp, dent->d_name);\n\tif (lstat (pp, &st) == -1)\n\t{\n\t    perror (pp);\n\t    continue;\n\t}\n\tif (S_ISLNK (st.st_mode))\n\t{\n\t    continue;\n\t}\n\tif (S_ISDIR (st.st_mode))\n\t{\n\t    recurse (pp);\n\t}\n\tif (S_ISREG (st.st_mode))\n\t{\n\t    /* fprintf(stderr,\"FILE: %s%c%s\\n\",path,'/',dent->d_name); */\n\t    snprintf (name, sizeof (name), \"%s/%s\", path, dent->d_name);\n\n\t    if (strlen (name) > 4\n\t\t&& !strcmp (name+strlen(name)-4, \".ycp\"))\n\t    {\n\t\tif (processfile (name, NULL))\n\t\t{\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tfree (pp);\n    }\n    closedir (d);\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "st.st_mode"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "pp"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "pp",
            "&st"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "pp",
            "dent->d_name"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "pp",
            "\"/\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pp"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "pp",
            "path"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"malloc\""
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen (path) + strlen (dent->d_name) + 30"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dent->d_name"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dent->d_name",
            "\"..\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dent->d_name",
            "\".\""
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "d"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "path"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "path"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <fstream>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nint\nrecurse (const char *path)\n{\n    DIR *d;\n    struct dirent *dent;\n    struct stat st;\n    char *pp;\n    char name[1024];\n\n    if(!(d = opendir (path)))\n    {\n\tperror (path);\n\treturn 1;\n    }\n\n    /* fprintf (stderr,\"PATH: '%s'\\n\",path); */\n    while ((dent = readdir(d)))\n    {\n\tif (!(strcmp (dent->d_name, \".\")\n\t    && strcmp (dent->d_name, \"..\")))\n\t{\n\t    continue;\n\t}\n\tpp = (char*)malloc (strlen (path) + strlen (dent->d_name) + 30);\n\tif (!pp)\n\t{\n\t    perror (\"malloc\");\n\t    return 1;\n\t}\n\tstrcpy (pp,path);\n\tif (pp[strlen(pp)-1] != '/')\n\t{\n\t    strcat (pp, \"/\");\n\t}\n\tstrcat (pp, dent->d_name);\n\tif (lstat (pp, &st) == -1)\n\t{\n\t    perror (pp);\n\t    continue;\n\t}\n\tif (S_ISLNK (st.st_mode))\n\t{\n\t    continue;\n\t}\n\tif (S_ISDIR (st.st_mode))\n\t{\n\t    recurse (pp);\n\t}\n\tif (S_ISREG (st.st_mode))\n\t{\n\t    /* fprintf(stderr,\"FILE: %s%c%s\\n\",path,'/',dent->d_name); */\n\t    snprintf (name, sizeof (name), \"%s/%s\", path, dent->d_name);\n\n\t    if (strlen (name) > 4\n\t\t&& !strcmp (name+strlen(name)-4, \".ycp\"))\n\t    {\n\t\tif (processfile (name, NULL))\n\t\t{\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tfree (pp);\n    }\n    closedir (d);\n    return 0;\n}"
  },
  {
    "function_name": "processfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runc.cc",
    "lines": "78-213",
    "snippet": "int\nprocessfile (const char *infname, char *outfname)\n{\n    if (infname == 0)\n    {\n\tfprintf (stderr, \"No input file given\\n\");\n\treturn 1;\n    }\n\n    if (parse || compile)\n    {\n\tif (!quiet) printf (\"parsing '%s'\\n\", infname);\n    }\n\n    if (compile\n\t&& outfname == 0)\n    {\n\tint len = strlen (infname);\n\tif (len > 4\n\t    && strcmp (infname + len - 4, \".ycp\") == 0)\n\t{\n\t    outfname = strdup (infname);\n\t    outfname[len-2] = 'b';\t// .ycp -> ybc\n\t    outfname[len-1] = 'c';\n\t    if (!quiet) printf (\"compiling to '%s'\\n\", outfname);\n\t}\n    }\n\n    if (run || print)\t// neither parse, nor compile -> run\n    {\n\tif (run)\n\t{\n\t    if (!quiet) printf (\"running '%s'\\n\", infname);\n\t}\n    }\n\n\n    if (parse || compile)\n    {\n\tif (parser == 0)\n\t{\n\t    parser = new Parser();\n\t}\n\tif (parser == 0)\n\t{\n\t    fprintf (stderr, \"Can't create parser\\n\");\n\t    return 1;\n\t}\n    }\n    \n    if (parser != 0)\n    {\n\tFILE *infile = fopen (infname, \"r\");\n\tif (infile == 0)\n\t{\n\t    fprintf (stderr, \"Can't  open \\\"%s\\\"\\n\", infname);\n\t    return 1;\n\t}\n\tparser->setInput (infile, infname);\n\tparser->setBuffered();\n\tSymbolTableDebug = 1;\n    }\n\n    YCodePtr c = 0;\n\n    if (parse || compile)\n    {\n\tif (!quiet) printf (\"parsing ...\\n\");\n\tc = parser->parse ();\n    }\n    else\n    {\n\tif (!quiet) printf (\"loading ...\\n\");\n\tc = Bytecode::readFile (infname);\n    }\n    if (!quiet) printf (\"done\\n\");\n\n    if (c == 0)\n    {\n\tfprintf (stderr, \"Fail: '%s'\\n\", infname);\n\treturn 1;\n    }\n\n    if (c->isError ())\n    {\n\tprintf (\"ERROR !\\n\");\n\tc->evaluate();\n\treturn 1;\n    }\n\n    std::ofstream outstream;\n\n    if (outfname != 0\n\t&& *outfname != '-'\n\t&& !outstream.is_open ())\n    {\n\toutstream.open (outfname, std::ios::out);\n    }\n\n    if (parse || print)\n    {\n\tif (!quiet) printf (\"Parsed:\\n\");\n\tif (outstream.is_open())\n\t{\n\t    outstream << c->toString();\n\t}\n\telse\n\t{\n\t    std::cout << c->toString();\n\t}\n    }\n    else if (compile)\n    {\n\tif (!quiet) printf (\"saving ...\\n\");\n\tBytecode::writeFile (c, string (outfname));\n    }\n    else\t// run\n    {\n\tif (!quiet) printf (\"running ...\\n\");\n\tYCPValue value = c->evaluate ();\n\n\tstring result = value.isNull() ? \"nil\" : value->toString();\n\tif (outstream.is_open())\n\t{\n\t    outstream << result << std::endl;\n\t}\n\telse\n\t{\n\t    std::cout << result << std::endl;\n\t}\n    }\n    \n    if (!quiet) printf (\"done\\n\");\n\n    return 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <y2/Y2ComponentCreator.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern int SymbolTableDebug;",
      "static Parser *parser = 0;",
      "static int quiet = 0;",
      "static int parse = 0;",
      "static int print = 0;",
      "static int compile = 0;",
      "static int run = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"done\\n\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outstream.is_open",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->evaluate",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"running ...\\n\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::writeFile",
          "args": [
            "c",
            "string (outfname)"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "writeFile",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "1175-1197",
          "snippet": "bool\nBytecode::writeFile (const YCodePtr code, const string & filename)\n{\n    // clear errno first\n    errno = 0;\n\n#if DO_DEBUG\n//    y2debug (\"Bytecode::writeFile (%s)\", filename.c_str());\n#endif\n    std::ofstream outstream (filename.c_str());\n    if (!outstream.is_open ())\n    {\n\ty2error (\"Failed to write '%s': %s\", filename.c_str(), strerror (errno));\n\treturn false;\n    }\n\n    string header =  string (YaST_BYTECODE_HEADER YaST_BYTECODE_MAJOR \".\" YaST_BYTECODE_MINOR \".\" YaST_BYTECODE_RELEASE);\n    outstream.write (header.c_str(), header.size() + 1);\t// including trailing \\0\n\n    code->toStream (outstream);\n\n    return ! outstream.fail ();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define YaST_BYTECODE_RELEASE \"0\"",
            "#define YaST_BYTECODE_MINOR \"4\"",
            "#define YaST_BYTECODE_MAJOR \"1\"",
            "#define YaST_BYTECODE_HEADER \"YaST bytecode \"",
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define YaST_BYTECODE_RELEASE \"0\"\n#define YaST_BYTECODE_MINOR \"4\"\n#define YaST_BYTECODE_MAJOR \"1\"\n#define YaST_BYTECODE_HEADER \"YaST bytecode \"\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::writeFile (const YCodePtr code, const string & filename)\n  {\n      // clear errno first\n      errno = 0;\n  \n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::writeFile (%s)\", filename.c_str());\n  #endif\n      std::ofstream outstream (filename.c_str());\n      if (!outstream.is_open ())\n      {\n  \ty2error (\"Failed to write '%s': %s\", filename.c_str(), strerror (errno));\n  \treturn false;\n      }\n  \n      string header =  string (YaST_BYTECODE_HEADER YaST_BYTECODE_MAJOR \".\" YaST_BYTECODE_MINOR \".\" YaST_BYTECODE_RELEASE);\n      outstream.write (header.c_str(), header.size() + 1);\t// including trailing \\0\n  \n      code->toStream (outstream);\n  \n      return ! outstream.fail ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "outfname"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"saving ...\\n\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->toString",
          "args": [],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1693-1713",
          "snippet": "string\nFunctionType::toString () const\n{\n    string ret = preToString() + m_returntype->toString () + \" (\";\n\n    if (m_arguments)\n    {\n\tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > 0)\n\t    {\n\t\tret += \", \";\n\t    }\n\t    ret += m_arguments->parameterType(index)->toString();\n\t}\n    }\n\n    ret += \")\";\n    ret += postToString();\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  string\n  FunctionType::toString () const\n  {\n      string ret = preToString() + m_returntype->toString () + \" (\";\n  \n      if (m_arguments)\n      {\n  \tfor (unsigned int index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > 0)\n  \t    {\n  \t\tret += \", \";\n  \t    }\n  \t    ret += m_arguments->parameterType(index)->toString();\n  \t}\n      }\n  \n      ret += \")\";\n      ret += postToString();\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "outstream.is_open",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Parsed:\\n\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outstream.open",
          "args": [
            "outfname",
            "std::ios::out"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outstream.is_open",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->evaluate",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR !\\n\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->isError",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "isError",
          "container": "YCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "76-80",
          "snippet": "bool\nYCode::isError() const\n{\n    return false; \t\t// TODO unused in practice?\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  bool\n  YCode::isError() const\n  {\n      return false; \t\t// TODO unused in practice?\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Fail: '%s'\\n\"",
            "infname"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"done\\n\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readFile",
          "args": [
            "infname"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "readFile",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "1129-1171",
          "snippet": "YCodePtr\nBytecode::readFile (const string & filename)\n{\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readFile (%s)\", filename.c_str());\n#endif\n    bytecodeistream instream (filename);\n    if (!instream.is_open ())\n    {\n\ty2error (\"Failed to open '%s': %s\", filename.c_str(), strerror (errno));\n\treturn 0;\n    }\n    // check YaST_BYTECODE_HEADER\n    if ( \n\tinstream.isVersion (\n\t    atoi (YaST_BYTECODE_MAJOR)\n\t    , atoi (YaST_BYTECODE_MINOR)\n\t    , atoi (YaST_BYTECODE_RELEASE))\n\t||\n\tinstream.isVersion (1,3,2) )\t// 9.1/SLES9\n    {\n#if DO_DEBUG\n//\ty2debug (\"Header accepted\");\n#endif\n\n\ttry\n\t{\n\t    return readCode (instream);\n\t}\n\tcatch (const Bytecode::Invalid&)\n\t{\n\t    // there are memory leaks all over the place now\n\t    y2error (\"Caught invalid bytecode in '%s'\", filename.c_str());\n\t    return 0;\n\t}\n    }\n\n    y2error (\"Unsupported version %d.%d.%d\"\n\t, instream.major ()\n\t, instream.minor ()\n\t, instream.release ());\n    return 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define YaST_BYTECODE_RELEASE \"0\"",
            "#define YaST_BYTECODE_MINOR \"4\"",
            "#define YaST_BYTECODE_MAJOR \"1\"",
            "#define YaST_BYTECODE_HEADER \"YaST bytecode \"",
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define YaST_BYTECODE_RELEASE \"0\"\n#define YaST_BYTECODE_MINOR \"4\"\n#define YaST_BYTECODE_MAJOR \"1\"\n#define YaST_BYTECODE_HEADER \"YaST bytecode \"\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readFile (const string & filename)\n  {\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readFile (%s)\", filename.c_str());\n  #endif\n      bytecodeistream instream (filename);\n      if (!instream.is_open ())\n      {\n  \ty2error (\"Failed to open '%s': %s\", filename.c_str(), strerror (errno));\n  \treturn 0;\n      }\n      // check YaST_BYTECODE_HEADER\n      if ( \n  \tinstream.isVersion (\n  \t    atoi (YaST_BYTECODE_MAJOR)\n  \t    , atoi (YaST_BYTECODE_MINOR)\n  \t    , atoi (YaST_BYTECODE_RELEASE))\n  \t||\n  \tinstream.isVersion (1,3,2) )\t// 9.1/SLES9\n      {\n  #if DO_DEBUG\n  //\ty2debug (\"Header accepted\");\n  #endif\n  \n  \ttry\n  \t{\n  \t    return readCode (instream);\n  \t}\n  \tcatch (const Bytecode::Invalid&)\n  \t{\n  \t    // there are memory leaks all over the place now\n  \t    y2error (\"Caught invalid bytecode in '%s'\", filename.c_str());\n  \t    return 0;\n  \t}\n      }\n  \n      y2error (\"Unsupported version %d.%d.%d\"\n  \t, instream.major ()\n  \t, instream.minor ()\n  \t, instream.release ());\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"loading ...\\n\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->parse",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "484-562",
          "snippet": "int IniParser::parse()\n{\n    if (multiple_files)\n    {\n\tglob_t do_files;\n\tint len = files.size ();\n\tint flags = 0;\n\tfor (int i = 0;i<len;i++)\n\t{\n\t    glob (files[i].c_str (),flags, NULL, &do_files);\n\t    flags = GLOB_APPEND;\n\t}\n\tchar**f = do_files.gl_pathv;\n\tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n\t{\n\t    int section_index = -1;\n\t    string section_name = *f;\n\t    //FIXME: create function out of it.\n\t    // do we have name rewrite rules?\n\t    for (size_t j = 0; j < rewrites.size (); j++)\n\t\t{\n\t\t    RegexMatch m (rewrites[j].rx, section_name);\n\t\t    if (m)\n\t\t    {\n\t\t\tsection_index = j;\n\t\t\tsection_name = m[1];\n\t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    // do we know about the file?\n\t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n\t    if (ff == multi_files.end())\n\t    {\n\t\t// new file\n\t\tif (scanner_start (*f))\n\t\t    y2error (\"Cannot open %s.\", *f);\n\t\telse\n\t\t{\n\t\t    FileDescr fdsc (*f);\n\t\t    multi_files[*f] = fdsc;\n\t\t    inifile.initSection (section_name, \"\", -1, section_index);\n\t\t    parse_helper(inifile.getSection(section_name.c_str()));\n\t\t    scanner_stop();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif ((*ff).second.changed ())\n\t\t{\n\t\t    if (scanner_start (*f))\n\t\t\ty2error (\"Cannot open %s.\", *f);\n\t\t    else\n\t\t    {\n\t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n\t\t\tFileDescr fdsc (*f);\n\t\t\tmulti_files [*f] = fdsc;\n\t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n\t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n\t\t\tscanner_stop();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tif (scanner_start (file.c_str()))\n\t    {\n\t\ty2error (\"Can not open %s.\", file.c_str());\n\t\treturn -1;\n\t    }\n\tparse_helper(inifile);\n\tscanner_stop();\n\ttimestamp = getTimeStamp ();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse()\n  {\n      if (multiple_files)\n      {\n  \tglob_t do_files;\n  \tint len = files.size ();\n  \tint flags = 0;\n  \tfor (int i = 0;i<len;i++)\n  \t{\n  \t    glob (files[i].c_str (),flags, NULL, &do_files);\n  \t    flags = GLOB_APPEND;\n  \t}\n  \tchar**f = do_files.gl_pathv;\n  \tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n  \t{\n  \t    int section_index = -1;\n  \t    string section_name = *f;\n  \t    //FIXME: create function out of it.\n  \t    // do we have name rewrite rules?\n  \t    for (size_t j = 0; j < rewrites.size (); j++)\n  \t\t{\n  \t\t    RegexMatch m (rewrites[j].rx, section_name);\n  \t\t    if (m)\n  \t\t    {\n  \t\t\tsection_index = j;\n  \t\t\tsection_name = m[1];\n  \t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \n  \t    // do we know about the file?\n  \t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n  \t    if (ff == multi_files.end())\n  \t    {\n  \t\t// new file\n  \t\tif (scanner_start (*f))\n  \t\t    y2error (\"Cannot open %s.\", *f);\n  \t\telse\n  \t\t{\n  \t\t    FileDescr fdsc (*f);\n  \t\t    multi_files[*f] = fdsc;\n  \t\t    inifile.initSection (section_name, \"\", -1, section_index);\n  \t\t    parse_helper(inifile.getSection(section_name.c_str()));\n  \t\t    scanner_stop();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif ((*ff).second.changed ())\n  \t\t{\n  \t\t    if (scanner_start (*f))\n  \t\t\ty2error (\"Cannot open %s.\", *f);\n  \t\t    else\n  \t\t    {\n  \t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n  \t\t\tFileDescr fdsc (*f);\n  \t\t\tmulti_files [*f] = fdsc;\n  \t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n  \t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n  \t\t\tscanner_stop();\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n      else\n      {\n  \tif (scanner_start (file.c_str()))\n  \t    {\n  \t\ty2error (\"Can not open %s.\", file.c_str());\n  \t\treturn -1;\n  \t    }\n  \tparse_helper(inifile);\n  \tscanner_stop();\n  \ttimestamp = getTimeStamp ();\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"parsing ...\\n\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->setBuffered",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "setBuffered",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "128-132",
          "snippet": "void\nScanner::setBuffered ()\n{\n    m_buffered = true;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  void\n  Scanner::setBuffered ()\n  {\n      m_buffered = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->setInput",
          "args": [
            "infile",
            "infname"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "setInput",
          "container": "Parser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Parser.cc",
          "lines": "108-115",
          "snippet": "void\nParser::setInput(int fd, const char *filename)\n{\n    if (m_scanner) delete m_scanner;\n    m_scanner = new Scanner (fd, filename);\n    if (m_buffered) m_scanner->setBuffered ();\n    m_at_eof = false;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Parser.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Parser.h\"\n#include <stdlib.h>\n\nParser {\n  void\n  Parser::setInput(int fd, const char *filename)\n  {\n      if (m_scanner) delete m_scanner;\n      m_scanner = new Scanner (fd, filename);\n      if (m_buffered) m_scanner->setBuffered ();\n      m_at_eof = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Can't  open \\\"%s\\\"\\n\"",
            "infname"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "infname",
            "\"r\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Can't create parser\\n\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"running '%s'\\n\"",
            "infname"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"compiling to '%s'\\n\"",
            "outfname"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "infname"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "infname + len - 4",
            "\".ycp\""
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "infname"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"parsing '%s'\\n\"",
            "infname"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"No input file given\\n\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <fstream>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nextern int SymbolTableDebug;\nstatic Parser *parser = 0;\nstatic int quiet = 0;\nstatic int parse = 0;\nstatic int print = 0;\nstatic int compile = 0;\nstatic int run = 0;\n\nint\nprocessfile (const char *infname, char *outfname)\n{\n    if (infname == 0)\n    {\n\tfprintf (stderr, \"No input file given\\n\");\n\treturn 1;\n    }\n\n    if (parse || compile)\n    {\n\tif (!quiet) printf (\"parsing '%s'\\n\", infname);\n    }\n\n    if (compile\n\t&& outfname == 0)\n    {\n\tint len = strlen (infname);\n\tif (len > 4\n\t    && strcmp (infname + len - 4, \".ycp\") == 0)\n\t{\n\t    outfname = strdup (infname);\n\t    outfname[len-2] = 'b';\t// .ycp -> ybc\n\t    outfname[len-1] = 'c';\n\t    if (!quiet) printf (\"compiling to '%s'\\n\", outfname);\n\t}\n    }\n\n    if (run || print)\t// neither parse, nor compile -> run\n    {\n\tif (run)\n\t{\n\t    if (!quiet) printf (\"running '%s'\\n\", infname);\n\t}\n    }\n\n\n    if (parse || compile)\n    {\n\tif (parser == 0)\n\t{\n\t    parser = new Parser();\n\t}\n\tif (parser == 0)\n\t{\n\t    fprintf (stderr, \"Can't create parser\\n\");\n\t    return 1;\n\t}\n    }\n    \n    if (parser != 0)\n    {\n\tFILE *infile = fopen (infname, \"r\");\n\tif (infile == 0)\n\t{\n\t    fprintf (stderr, \"Can't  open \\\"%s\\\"\\n\", infname);\n\t    return 1;\n\t}\n\tparser->setInput (infile, infname);\n\tparser->setBuffered();\n\tSymbolTableDebug = 1;\n    }\n\n    YCodePtr c = 0;\n\n    if (parse || compile)\n    {\n\tif (!quiet) printf (\"parsing ...\\n\");\n\tc = parser->parse ();\n    }\n    else\n    {\n\tif (!quiet) printf (\"loading ...\\n\");\n\tc = Bytecode::readFile (infname);\n    }\n    if (!quiet) printf (\"done\\n\");\n\n    if (c == 0)\n    {\n\tfprintf (stderr, \"Fail: '%s'\\n\", infname);\n\treturn 1;\n    }\n\n    if (c->isError ())\n    {\n\tprintf (\"ERROR !\\n\");\n\tc->evaluate();\n\treturn 1;\n    }\n\n    std::ofstream outstream;\n\n    if (outfname != 0\n\t&& *outfname != '-'\n\t&& !outstream.is_open ())\n    {\n\toutstream.open (outfname, std::ios::out);\n    }\n\n    if (parse || print)\n    {\n\tif (!quiet) printf (\"Parsed:\\n\");\n\tif (outstream.is_open())\n\t{\n\t    outstream << c->toString();\n\t}\n\telse\n\t{\n\t    std::cout << c->toString();\n\t}\n    }\n    else if (compile)\n    {\n\tif (!quiet) printf (\"saving ...\\n\");\n\tBytecode::writeFile (c, string (outfname));\n    }\n    else\t// run\n    {\n\tif (!quiet) printf (\"running ...\\n\");\n\tYCPValue value = c->evaluate ();\n\n\tstring result = value.isNull() ? \"nil\" : value->toString();\n\tif (outstream.is_open())\n\t{\n\t    outstream << result << std::endl;\n\t}\n\telse\n\t{\n\t    std::cout << result << std::endl;\n\t}\n    }\n    \n    if (!quiet) printf (\"done\\n\");\n\n    return 0;\n}"
  },
  {
    "function_name": "isServerCreator",
    "container": "TestY2CC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runc.cc",
    "lines": "56-56",
    "snippet": "virtual bool isServerCreator () const { return true;}",
    "includes": [
      "#include \"config.h\"",
      "#include <y2/Y2ComponentCreator.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <fstream>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nTestY2CC {\n  virtual bool isServerCreator () const { return true;}\n}"
  },
  {
    "function_name": "TestY2CC",
    "container": "TestY2CC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runc.cc",
    "lines": "50-50",
    "snippet": "TestY2CC() : Y2ComponentCreator(Y2ComponentBroker::SCRIPT) {}",
    "includes": [
      "#include \"config.h\"",
      "#include <y2/Y2ComponentCreator.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <fstream>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nTestY2CC {\n  TestY2CC() : Y2ComponentCreator(Y2ComponentBroker::SCRIPT) {}\n}"
  },
  {
    "function_name": "name",
    "container": "TestY2Component",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/runc.cc",
    "lines": "42-42",
    "snippet": "virtual string name () const { return \"test\";}",
    "includes": [
      "#include \"config.h\"",
      "#include <y2/Y2ComponentCreator.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/YBlock.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <y2/Y2ComponentCreator.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <ycp/Bytecode.h>\n#include <ycp/YBlock.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <fstream>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nTestY2Component {\n  virtual string name () const { return \"test\";}\n}"
  }
]