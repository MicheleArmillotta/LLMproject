[
  {
    "function_name": "YCPPath",
    "container": "YCPPath",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "402-418",
    "snippet": "YCPPath::YCPPath (bytecodeistream & str)\n    : YCPValue (new YCPPathRep (fromStream(str).c_str()))\n{\n#if 0\n    u_int32_t count = Bytecode::readInt32 (str);\n    if (str.good())\n    {\n\tYCPPathRep *p = new YCPPathRep ();\n\tfor (unsigned c = 0; c < count; c++)\n\t{\n\t    p->append (YCPPathRep::Component (str));\n\t}\n\tif (str.good())\n\t    element = p;\n    }\n#endif\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "str.good",
          "args": [],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->append",
          "args": [
            "YCPPathRep::Component (str)"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "append",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "106-113",
          "snippet": "void\nYCPPathRep::append(string c)\n{\n    Component added;\n    added.component = Ustring (*SymbolEntry::_nameHash, c);\n    added.complex = true;  //it would be nicer if we checked if it is really complex, but this is faster\n    components.push_back(added);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  void\n  YCPPathRep::append(string c)\n  {\n      Component added;\n      added.component = Ustring (*SymbolEntry::_nameHash, c);\n      added.complex = true;  //it would be nicer if we checked if it is really complex, but this is faster\n      components.push_back(added);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPPathRep::Component",
          "args": [
            "str"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "Component",
          "container": "YCPPathRep::Component",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "319-328",
          "snippet": "YCPPathRep::Component::Component(bytecodeistream & str)\n    : component (SymbolEntry::emptyUstring)\n{\n    char v;\n    if (str.get (v))\n    {\n\tcomplex = (v != '\\x00');\n\tcomponent = Bytecode::readUstring (str);\n    }\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  Component {\n    YCPPathRep::Component::Component(bytecodeistream & str)\n        : component (SymbolEntry::emptyUstring)\n    {\n        char v;\n        if (str.get (v))\n        {\n    \tcomplex = (v != '\\x00');\n    \tcomponent = Bytecode::readUstring (str);\n        }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.good",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readInt32",
          "args": [
            "str"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fromStream",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fromStream",
          "args": [
            "str"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "fromStream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "394-400",
          "snippet": "static string\nfromStream (bytecodeistream & str)\n{\n    string s;\n    Bytecode::readString (str, s);\n    return s;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nstatic string\nfromStream (bytecodeistream & str)\n{\n    string s;\n    Bytecode::readString (str, s);\n    return s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPath {\n  YCPPath::YCPPath (bytecodeistream & str)\n      : YCPValue (new YCPPathRep (fromStream(str).c_str()))\n  {\n  #if 0\n      u_int32_t count = Bytecode::readInt32 (str);\n      if (str.good())\n      {\n  \tYCPPathRep *p = new YCPPathRep ();\n  \tfor (unsigned c = 0; c < count; c++)\n  \t{\n  \t    p->append (YCPPathRep::Component (str));\n  \t}\n  \tif (str.good())\n  \t    element = p;\n      }\n  #endif\n  }\n}"
  },
  {
    "function_name": "fromStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "394-400",
    "snippet": "static string\nfromStream (bytecodeistream & str)\n{\n    string s;\n    Bytecode::readString (str, s);\n    return s;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readString",
          "args": [
            "str",
            "s"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "readString",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "229-247",
          "snippet": "bool\nBytecode::readString (bytecodeistream & streamref, string & stringref)\n{\n    bool ret = false;\n    stringref.erase();\n    u_int32_t len = readInt32 (streamref);\n    if (len > 0)\n    {\n\tchar *buf = new char [len+1];\n\tif (streamref.read (buf, len))\n\t{\n\t    buf[len] = 0;\n\t    stringref = string (buf);\n\t    ret = true;\n\t}\n\tdelete [] buf;\n    }\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  bool\n  Bytecode::readString (bytecodeistream & streamref, string & stringref)\n  {\n      bool ret = false;\n      stringref.erase();\n      u_int32_t len = readInt32 (streamref);\n      if (len > 0)\n      {\n  \tchar *buf = new char [len+1];\n  \tif (streamref.read (buf, len))\n  \t{\n  \t    buf[len] = 0;\n  \t    stringref = string (buf);\n  \t    ret = true;\n  \t}\n  \tdelete [] buf;\n      }\n      return ret;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nstatic string\nfromStream (bytecodeistream & str)\n{\n    string s;\n    Bytecode::readString (str, s);\n    return s;\n}"
  },
  {
    "function_name": "Component",
    "container": "YCPPathRep::Component",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "319-328",
    "snippet": "YCPPathRep::Component::Component(bytecodeistream & str)\n    : component (SymbolEntry::emptyUstring)\n{\n    char v;\n    if (str.get (v))\n    {\n\tcomplex = (v != '\\x00');\n\tcomponent = Bytecode::readUstring (str);\n    }\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readUstring",
          "args": [
            "str"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "readUstring",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "263-279",
          "snippet": "Ustring\nBytecode::readUstring (bytecodeistream & streamref)\n{\n    u_int32_t len = readInt32 (streamref);\n    Ustring ret = Ustring (*SymbolEntry::_nameHash, \"\");\n    if (len > 0)\n    {\n\tchar *buf = new char [len+1];\n\tif (streamref.read (buf, len))\n\t{\n\t    buf[len] = 0;\n\t    ret = Ustring (*SymbolEntry::_nameHash, buf);\n\t}\n\tdelete [] buf;\n    }\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  Ustring\n  Bytecode::readUstring (bytecodeistream & streamref)\n  {\n      u_int32_t len = readInt32 (streamref);\n      Ustring ret = Ustring (*SymbolEntry::_nameHash, \"\");\n      if (len > 0)\n      {\n  \tchar *buf = new char [len+1];\n  \tif (streamref.read (buf, len))\n  \t{\n  \t    buf[len] = 0;\n  \t    ret = Ustring (*SymbolEntry::_nameHash, buf);\n  \t}\n  \tdelete [] buf;\n      }\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.get",
          "args": [
            "v"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  Component {\n    YCPPathRep::Component::Component(bytecodeistream & str)\n        : component (SymbolEntry::emptyUstring)\n    {\n        char v;\n        if (str.get (v))\n        {\n    \tcomplex = (v != '\\x00');\n    \tcomponent = Bytecode::readUstring (str);\n        }\n    }\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YCPPathRep::Component",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "278-311",
    "snippet": "string\nYCPPathRep::Component::toString() const\n{\n    if (!complex)\n\treturn component.asString();\n    string s = \"\\\"\";\n    for (const char*c = component->c_str();*c;c++)\n    {\n\tswitch (*c)\n\t{\n\t    case '\"': s+= \"\\\\\\\"\"; break;\n\t    case '\\\\':    s+= \"\\\\\\\\\";  break;\n\t    case '\\n':    s+= \"\\\\n\";   break;\n\t    case '\\t':    s+= \"\\\\t\";   break;\n\t    case '\\r':    s+= \"\\\\r\";   break;\n\t    case '\\b':    s+= \"\\\\b\";   break;\n\t    case '\\f':    s+= \"\\\\f\";   break;\n\t    default:\n\t    {\n\t\tif (isprint (*c))\n\t\t    s+= *c;\n\t\telse\n\t\t{\n\t\t    char buf[5];\n\t\t    snprintf (buf, 4, \"%02X\", *(unsigned char*)c);\n\t\t    s += \"\\\\x\";\n\t\t    s += buf;\n\t\t}\n\t    }\n\t}\n    }\n    s+= '\"';\n    return s;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "4",
            "\"%02X\"",
            "*(unsigned char*)c"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isprint",
          "args": [
            "*c"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "component->c_str",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "component.asString",
          "args": [],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  Component {\n    string\n    YCPPathRep::Component::toString() const\n    {\n        if (!complex)\n    \treturn component.asString();\n        string s = \"\\\"\";\n        for (const char*c = component->c_str();*c;c++)\n        {\n    \tswitch (*c)\n    \t{\n    \t    case '\"': s+= \"\\\\\\\"\"; break;\n    \t    case '\\\\':    s+= \"\\\\\\\\\";  break;\n    \t    case '\\n':    s+= \"\\\\n\";   break;\n    \t    case '\\t':    s+= \"\\\\t\";   break;\n    \t    case '\\r':    s+= \"\\\\r\";   break;\n    \t    case '\\b':    s+= \"\\\\b\";   break;\n    \t    case '\\f':    s+= \"\\\\f\";   break;\n    \t    default:\n    \t    {\n    \t\tif (isprint (*c))\n    \t\t    s+= *c;\n    \t\telse\n    \t\t{\n    \t\t    char buf[5];\n    \t\t    snprintf (buf, 4, \"%02X\", *(unsigned char*)c);\n    \t\t    s += \"\\\\x\";\n    \t\t    s += buf;\n    \t\t}\n    \t    }\n    \t}\n        }\n        s+= '\"';\n        return s;\n    }\n  }\n}"
  },
  {
    "function_name": "Component",
    "container": "YCPPathRep::Component",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "204-275",
    "snippet": "YCPPathRep::Component::Component(string s)\n    : component (SymbolEntry::emptyUstring)\n{\n    string comp;\n    if (s[0] == '\"')\n    {\n\tchar num;\n\tcomplex = true;\n\tcomp.erase();\n\tfor (const char*c = s.c_str()+1;*c;c++)\n\t{\n\t    if ('\\\\' == *c)\n\t    {\n\t\t// handles \\\\, \\n, \\t, \\r, \\b, \\f, \\x00, \\\"\n\t\tc++;\n\t\tswitch (*c)\n\t\t{\n\t\t\tcase '\\0':\n\t\t\t    // this should never happen because scanner gives us\n\t\t\t    // value that ends up with \" (not with \\)\n\t\t\t    comp+= '\\\\';\n\t\t\t    return;\n\t\t\tcase '\\\\':   comp+= '\\\\';   break;\n\t\t\tcase 'n':    comp+= '\\n';   break;\n\t\t\tcase 't':    comp+= '\\t';   break;\n\t\t\tcase 'r':    comp+= '\\r';   break;\n\t\t\tcase 'b':    comp+= '\\b';   break;\n\t\t\tcase 'f':    comp+= '\\f';   break;\n\t\t\tcase '\"':    comp+= '\"';    break;\n\t\t\tcase 'x':\n\t\t\t    // there must be at least one number\n\t\t\t    // we know that there is at least \" and \\0 so this is safe\n\t\t\t    num = 0;\n\t\t\t    if (isxdigit(*(c+1)) && isxdigit(*(c+2)))\n\t\t\t\t{\n\t\t\t\t    num =\n\t\t\t\t\t(isdigit(*(c+2)) ? *(c+2)-'0' : isupper(*(c+2)) ? *(c+2)-'A'+10 : *(c+2)-'a'+10)\n\t\t\t\t\t|\n\t\t\t\t\t((isdigit(*(c+1)) ? *(c+1)-'0' : isupper(*(c+1)) ? *(c+1)-'A'+10 : *(c+1)-'a'+10) << 4)\n\t\t\t\t\t;\n\t\t\t\t    c+= 2;\n\t\t\t\t}\n\t\t\t    else if (isxdigit(*(c+1)))\n\t\t\t\t{\n\t\t\t\t    num =\n\t\t\t\t\tisdigit(*(c+1)) ? *(c+1)-'0' : isupper(*(c+1)) ? *(c+1)-'A'+10 : *(c+1)-'a'+10\n\t\t\t\t\t;\n\t\t\t\t    c++;\n\t\t\t\t}\n\t\t\t    if (!num)\n\t\t\t\tycp2error(\"\\\\x00 not allowed in path constant. Skipping.\");\n\t\t\t    comp+= num;\n\t\t\t    break;\n\t\t\tdefault:\n\t\t\t    comp+= *c;\n\t\t\t}\n\t    }\n\t    else if ('\"' == *c)\n\t    {  // this must be \" at the end. Return anyway to save some comparison\n\t\tbreak;\n\t    }\n\t    else\n\t\tcomp+= *c;\n\t}\n    }\n    else\n    {\n\tcomp = s;\n\tcomplex = string::npos == comp.find_first_not_of (\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-\") ? false : true;\n    }\n    component = Ustring (*SymbolEntry::_nameHash, comp);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Ustring",
          "args": [
            "*SymbolEntry::_nameHash",
            "comp"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comp.find_first_not_of",
          "args": [
            "\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"\\\\x00 not allowed in path constant. Skipping.\""
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isupper",
          "args": [
            "*(c+1)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*(c+1)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "*(c+1)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isupper",
          "args": [
            "*(c+1)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*(c+1)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isupper",
          "args": [
            "*(c+2)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*(c+2)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "*(c+2)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "*(c+1)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.c_str",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comp.erase",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  Component {\n    YCPPathRep::Component::Component(string s)\n        : component (SymbolEntry::emptyUstring)\n    {\n        string comp;\n        if (s[0] == '\"')\n        {\n    \tchar num;\n    \tcomplex = true;\n    \tcomp.erase();\n    \tfor (const char*c = s.c_str()+1;*c;c++)\n    \t{\n    \t    if ('\\\\' == *c)\n    \t    {\n    \t\t// handles \\\\, \\n, \\t, \\r, \\b, \\f, \\x00, \\\"\n    \t\tc++;\n    \t\tswitch (*c)\n    \t\t{\n    \t\t\tcase '\\0':\n    \t\t\t    // this should never happen because scanner gives us\n    \t\t\t    // value that ends up with \" (not with \\)\n    \t\t\t    comp+= '\\\\';\n    \t\t\t    return;\n    \t\t\tcase '\\\\':   comp+= '\\\\';   break;\n    \t\t\tcase 'n':    comp+= '\\n';   break;\n    \t\t\tcase 't':    comp+= '\\t';   break;\n    \t\t\tcase 'r':    comp+= '\\r';   break;\n    \t\t\tcase 'b':    comp+= '\\b';   break;\n    \t\t\tcase 'f':    comp+= '\\f';   break;\n    \t\t\tcase '\"':    comp+= '\"';    break;\n    \t\t\tcase 'x':\n    \t\t\t    // there must be at least one number\n    \t\t\t    // we know that there is at least \" and \\0 so this is safe\n    \t\t\t    num = 0;\n    \t\t\t    if (isxdigit(*(c+1)) && isxdigit(*(c+2)))\n    \t\t\t\t{\n    \t\t\t\t    num =\n    \t\t\t\t\t(isdigit(*(c+2)) ? *(c+2)-'0' : isupper(*(c+2)) ? *(c+2)-'A'+10 : *(c+2)-'a'+10)\n    \t\t\t\t\t|\n    \t\t\t\t\t((isdigit(*(c+1)) ? *(c+1)-'0' : isupper(*(c+1)) ? *(c+1)-'A'+10 : *(c+1)-'a'+10) << 4)\n    \t\t\t\t\t;\n    \t\t\t\t    c+= 2;\n    \t\t\t\t}\n    \t\t\t    else if (isxdigit(*(c+1)))\n    \t\t\t\t{\n    \t\t\t\t    num =\n    \t\t\t\t\tisdigit(*(c+1)) ? *(c+1)-'0' : isupper(*(c+1)) ? *(c+1)-'A'+10 : *(c+1)-'a'+10\n    \t\t\t\t\t;\n    \t\t\t\t    c++;\n    \t\t\t\t}\n    \t\t\t    if (!num)\n    \t\t\t\tycp2error(\"\\\\x00 not allowed in path constant. Skipping.\");\n    \t\t\t    comp+= num;\n    \t\t\t    break;\n    \t\t\tdefault:\n    \t\t\t    comp+= *c;\n    \t\t\t}\n    \t    }\n    \t    else if ('\"' == *c)\n    \t    {  // this must be \" at the end. Return anyway to save some comparison\n    \t\tbreak;\n    \t    }\n    \t    else\n    \t\tcomp+= *c;\n    \t}\n        }\n        else\n        {\n    \tcomp = s;\n    \tcomplex = string::npos == comp.find_first_not_of (\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-\") ? false : true;\n        }\n        component = Ustring (*SymbolEntry::_nameHash, comp);\n    }\n  }\n}"
  },
  {
    "function_name": "valuetype",
    "container": "YCPPathRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "197-201",
    "snippet": "YCPValueType\nYCPPathRep::valuetype() const\n{\n    return YT_PATH;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  YCPValueType\n  YCPPathRep::valuetype() const\n  {\n      return YT_PATH;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YCPPathRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "183-194",
    "snippet": "string\nYCPPathRep::toString() const\n{\n    if (components.empty()) return \".\";\n    string v;\n    for (unsigned c=0; c<components.size(); c++)\n    {\n\tv += \".\";\n\tv += components[c].toString();\n    }\n    return v;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "components[c].toString",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YCPPathRep::Component",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "278-311",
          "snippet": "string\nYCPPathRep::Component::toString() const\n{\n    if (!complex)\n\treturn component.asString();\n    string s = \"\\\"\";\n    for (const char*c = component->c_str();*c;c++)\n    {\n\tswitch (*c)\n\t{\n\t    case '\"': s+= \"\\\\\\\"\"; break;\n\t    case '\\\\':    s+= \"\\\\\\\\\";  break;\n\t    case '\\n':    s+= \"\\\\n\";   break;\n\t    case '\\t':    s+= \"\\\\t\";   break;\n\t    case '\\r':    s+= \"\\\\r\";   break;\n\t    case '\\b':    s+= \"\\\\b\";   break;\n\t    case '\\f':    s+= \"\\\\f\";   break;\n\t    default:\n\t    {\n\t\tif (isprint (*c))\n\t\t    s+= *c;\n\t\telse\n\t\t{\n\t\t    char buf[5];\n\t\t    snprintf (buf, 4, \"%02X\", *(unsigned char*)c);\n\t\t    s += \"\\\\x\";\n\t\t    s += buf;\n\t\t}\n\t    }\n\t}\n    }\n    s+= '\"';\n    return s;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  Component {\n    string\n    YCPPathRep::Component::toString() const\n    {\n        if (!complex)\n    \treturn component.asString();\n        string s = \"\\\"\";\n        for (const char*c = component->c_str();*c;c++)\n        {\n    \tswitch (*c)\n    \t{\n    \t    case '\"': s+= \"\\\\\\\"\"; break;\n    \t    case '\\\\':    s+= \"\\\\\\\\\";  break;\n    \t    case '\\n':    s+= \"\\\\n\";   break;\n    \t    case '\\t':    s+= \"\\\\t\";   break;\n    \t    case '\\r':    s+= \"\\\\r\";   break;\n    \t    case '\\b':    s+= \"\\\\b\";   break;\n    \t    case '\\f':    s+= \"\\\\f\";   break;\n    \t    default:\n    \t    {\n    \t\tif (isprint (*c))\n    \t\t    s+= *c;\n    \t\telse\n    \t\t{\n    \t\t    char buf[5];\n    \t\t    snprintf (buf, 4, \"%02X\", *(unsigned char*)c);\n    \t\t    s += \"\\\\x\";\n    \t\t    s += buf;\n    \t\t}\n    \t    }\n    \t}\n        }\n        s+= '\"';\n        return s;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "components.size",
          "args": [],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "components.empty",
          "args": [],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  string\n  YCPPathRep::toString() const\n  {\n      if (components.empty()) return \".\";\n      string v;\n      for (unsigned c=0; c<components.size(); c++)\n      {\n  \tv += \".\";\n  \tv += components[c].toString();\n      }\n      return v;\n  }\n}"
  },
  {
    "function_name": "compare",
    "container": "YCPPathRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "168-180",
    "snippet": "YCPOrder\nYCPPathRep::compare(const YCPPath& p) const\n{\n    for (unsigned c=0; c<components.size(); c++)\n    {\n\tif (p->components.size() <= c) return YO_GREATER;\n\tint comp = components[c].compare(p->components[c]);\n\tif (comp < 0) return YO_LESS;\n\telse if (comp > 0) return YO_GREATER;\n    }\n    if ( components.size() == p->components.size() ) return YO_EQUAL;\n    return components.size() < p->components.size() ? YO_LESS : YO_GREATER;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p->components.size",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "components[c].compare",
          "args": [
            "p->components[c]"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "compare",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "168-180",
          "snippet": "YCPOrder\nYCPPathRep::compare(const YCPPath& p) const\n{\n    for (unsigned c=0; c<components.size(); c++)\n    {\n\tif (p->components.size() <= c) return YO_GREATER;\n\tint comp = components[c].compare(p->components[c]);\n\tif (comp < 0) return YO_LESS;\n\telse if (comp > 0) return YO_GREATER;\n    }\n    if ( components.size() == p->components.size() ) return YO_EQUAL;\n    return components.size() < p->components.size() ? YO_LESS : YO_GREATER;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  YCPOrder\n  YCPPathRep::compare(const YCPPath& p) const\n  {\n      for (unsigned c=0; c<components.size(); c++)\n      {\n  \tif (p->components.size() <= c) return YO_GREATER;\n  \tint comp = components[c].compare(p->components[c]);\n  \tif (comp < 0) return YO_LESS;\n  \telse if (comp > 0) return YO_GREATER;\n      }\n      if ( components.size() == p->components.size() ) return YO_EQUAL;\n      return components.size() < p->components.size() ? YO_LESS : YO_GREATER;\n  }\n}"
  },
  {
    "function_name": "component_str",
    "container": "YCPPathRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "161-165",
    "snippet": "string\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "components[index].component.asString",
          "args": [],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  string\n  YCPPathRep::component_str(long index) const\n  {\n      return components[index].component.asString();\n  }\n}"
  },
  {
    "function_name": "prefix",
    "container": "YCPPathRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "151-158",
    "snippet": "YCPPath\nYCPPathRep::prefix(long index) const\n{\n    YCPPath ret;\n    for (int i = 0; i < index; ++i)\n\tret->append(components[i]);\n    return ret;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret->append",
          "args": [
            "components[i]"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "append",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "106-113",
          "snippet": "void\nYCPPathRep::append(string c)\n{\n    Component added;\n    added.component = Ustring (*SymbolEntry::_nameHash, c);\n    added.complex = true;  //it would be nicer if we checked if it is really complex, but this is faster\n    components.push_back(added);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  void\n  YCPPathRep::append(string c)\n  {\n      Component added;\n      added.component = Ustring (*SymbolEntry::_nameHash, c);\n      added.complex = true;  //it would be nicer if we checked if it is really complex, but this is faster\n      components.push_back(added);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  YCPPath\n  YCPPathRep::prefix(long index) const\n  {\n      YCPPath ret;\n      for (int i = 0; i < index; ++i)\n  \tret->append(components[i]);\n      return ret;\n  }\n}"
  },
  {
    "function_name": "at",
    "container": "YCPPathRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "142-149",
    "snippet": "YCPPath\nYCPPathRep::at(long index) const\n{\n    YCPPath postfix;\n    for (int i=index; i<length(); i++)\n\tpostfix->append(components[i]);\n    return postfix;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "postfix->append",
          "args": [
            "components[i]"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "append",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "106-113",
          "snippet": "void\nYCPPathRep::append(string c)\n{\n    Component added;\n    added.component = Ustring (*SymbolEntry::_nameHash, c);\n    added.complex = true;  //it would be nicer if we checked if it is really complex, but this is faster\n    components.push_back(added);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  void\n  YCPPathRep::append(string c)\n  {\n      Component added;\n      added.component = Ustring (*SymbolEntry::_nameHash, c);\n      added.complex = true;  //it would be nicer if we checked if it is really complex, but this is faster\n      components.push_back(added);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "length",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  YCPPath\n  YCPPathRep::at(long index) const\n  {\n      YCPPath postfix;\n      for (int i=index; i<length(); i++)\n  \tpostfix->append(components[i]);\n      return postfix;\n  }\n}"
  },
  {
    "function_name": "isPrefixOf",
    "container": "YCPPathRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "131-139",
    "snippet": "bool\nYCPPathRep::isPrefixOf(const YCPPath& path) const\n{\n    if (length() > path->length()) return false;\n\n    for (int c=0; c<length(); c++)\n\tif (component_str(c) != path->component_str(c)) return false;\n    return true;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path->component_str",
          "args": [
            "c"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "component_str",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "161-165",
          "snippet": "string\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  string\n  YCPPathRep::component_str(long index) const\n  {\n      return components[index].component.asString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "length",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  bool\n  YCPPathRep::isPrefixOf(const YCPPath& path) const\n  {\n      if (length() > path->length()) return false;\n  \n      for (int c=0; c<length(); c++)\n  \tif (component_str(c) != path->component_str(c)) return false;\n      return true;\n  }\n}"
  },
  {
    "function_name": "length",
    "container": "YCPPathRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "124-128",
    "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "components.size",
          "args": [],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
  },
  {
    "function_name": "select",
    "container": "YCPPathRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "116-121",
    "snippet": "YCPValue\nYCPPathRep::select(const YCPValue& val)\n{\n    return val; \n    // TODO: do real operation\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  YCPValue\n  YCPPathRep::select(const YCPValue& val)\n  {\n      return val; \n      // TODO: do real operation\n  }\n}"
  },
  {
    "function_name": "append",
    "container": "YCPPathRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "106-113",
    "snippet": "void\nYCPPathRep::append(string c)\n{\n    Component added;\n    added.component = Ustring (*SymbolEntry::_nameHash, c);\n    added.complex = true;  //it would be nicer if we checked if it is really complex, but this is faster\n    components.push_back(added);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "components.push_back",
          "args": [
            "added"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Ustring",
          "args": [
            "*SymbolEntry::_nameHash",
            "c"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  void\n  YCPPathRep::append(string c)\n  {\n      Component added;\n      added.component = Ustring (*SymbolEntry::_nameHash, c);\n      added.complex = true;  //it would be nicer if we checked if it is really complex, but this is faster\n      components.push_back(added);\n  }\n}"
  },
  {
    "function_name": "append",
    "container": "YCPPathRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "99-103",
    "snippet": "void\nYCPPathRep::append(const Component&c)\n{\n    components.push_back(c);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "components.push_back",
          "args": [
            "c"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  void\n  YCPPathRep::append(const Component&c)\n  {\n      components.push_back(c);\n  }\n}"
  },
  {
    "function_name": "append",
    "container": "YCPPathRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "90-96",
    "snippet": "void\nYCPPathRep::append(const YCPPath&p)\n{\n    int len = p->length();\n    for (int i = 0; i<len; i++)\n\tcomponents.push_back (p->components[i]);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "components.push_back",
          "args": [
            "p->components[i]"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->length",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  void\n  YCPPathRep::append(const YCPPath&p)\n  {\n      int len = p->length();\n      for (int i = 0; i<len; i++)\n  \tcomponents.push_back (p->components[i]);\n  }\n}"
  },
  {
    "function_name": "isRoot",
    "container": "YCPPathRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "83-87",
    "snippet": "bool\nYCPPathRep::isRoot() const\n{\n    return components.empty();\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "components.empty",
          "args": [],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  bool\n  YCPPathRep::isRoot() const\n  {\n      return components.empty();\n  }\n}"
  },
  {
    "function_name": "YCPPathRep",
    "container": "YCPPathRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "33-80",
    "snippet": "YCPPathRep::YCPPathRep(const char *r)\n{\n    if (strcmp (r, \".\") == 0)\n\treturn; // Root path is empty\n\n    string p;\n    enum { dot, simple, complex_first, complex } state = dot;\n    const char*start = NULL;\n    for (const char*c = r; *c; c++)\n    {\n\tswitch (state)\n\t{\n\tcase dot: // there must be .\" or .[a-zA-Z0-9_]. Scanner guarantees this.\n\t    state = ('\"' == *(c+1)) ? complex_first : simple;\n\t    start = c+1;\n\t    break;\n\tcase simple:\n\t    if ('.' == *(c+1)\n\t\t|| '\\0' == *(c+1))\n\t    {\n\t\tif ('-' == *start\n\t\t    || '-' == *c)\n\t\t{\n\t\t    ycp2error (\"bad path constant: dash before/after dot not allowed\");\n\t\t    components.clear();\n\t\t    return;\n\t\t}\n\t\tp.assign (start, c-start+1);\n\t\tcomponents.push_back (Component(p));\n\t\tstate = dot;\n\t    }\n\t    break;\n\tcase complex_first:\n\t    state = complex;\n\t    break;\n\tcase complex:\n\t    if ('\\\\'==*c)\n\t\tc++;\n\t    else if ('\"' == *c)\n\t    {\t// end of component\n\t\tp.assign (start,c-start+1);\n\t\tcomponents.push_back (Component(p));\n\t\tstate = dot;\n\t    }\n\t    break;\n\t}\n    }\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "components.push_back",
          "args": [
            "Component(p)"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Component",
          "args": [
            "p"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "Component",
          "container": "YCPPathRep::Component",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "319-328",
          "snippet": "YCPPathRep::Component::Component(bytecodeistream & str)\n    : component (SymbolEntry::emptyUstring)\n{\n    char v;\n    if (str.get (v))\n    {\n\tcomplex = (v != '\\x00');\n\tcomponent = Bytecode::readUstring (str);\n    }\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  Component {\n    YCPPathRep::Component::Component(bytecodeistream & str)\n        : component (SymbolEntry::emptyUstring)\n    {\n        char v;\n        if (str.get (v))\n        {\n    \tcomplex = (v != '\\x00');\n    \tcomponent = Bytecode::readUstring (str);\n        }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "p.assign",
          "args": [
            "start",
            "c-start+1"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.assign",
          "args": [
            "start",
            "c-start+1"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "components.clear",
          "args": [],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/PathInfo.h",
          "lines": "461-461",
          "snippet": "void clear() { _devino.clear(); }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <map>",
            "#include <set>",
            "#include <list>",
            "#include <iosfwd>",
            "#include <cerrno>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <map>\n#include <set>\n#include <list>\n#include <iosfwd>\n#include <cerrno>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid clear() { _devino.clear(); }"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"bad path constant: dash before/after dot not allowed\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "r",
            "\".\""
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  YCPPathRep::YCPPathRep(const char *r)\n  {\n      if (strcmp (r, \".\") == 0)\n  \treturn; // Root path is empty\n  \n      string p;\n      enum { dot, simple, complex_first, complex } state = dot;\n      const char*start = NULL;\n      for (const char*c = r; *c; c++)\n      {\n  \tswitch (state)\n  \t{\n  \tcase dot: // there must be .\" or .[a-zA-Z0-9_]. Scanner guarantees this.\n  \t    state = ('\"' == *(c+1)) ? complex_first : simple;\n  \t    start = c+1;\n  \t    break;\n  \tcase simple:\n  \t    if ('.' == *(c+1)\n  \t\t|| '\\0' == *(c+1))\n  \t    {\n  \t\tif ('-' == *start\n  \t\t    || '-' == *c)\n  \t\t{\n  \t\t    ycp2error (\"bad path constant: dash before/after dot not allowed\");\n  \t\t    components.clear();\n  \t\t    return;\n  \t\t}\n  \t\tp.assign (start, c-start+1);\n  \t\tcomponents.push_back (Component(p));\n  \t\tstate = dot;\n  \t    }\n  \t    break;\n  \tcase complex_first:\n  \t    state = complex;\n  \t    break;\n  \tcase complex:\n  \t    if ('\\\\'==*c)\n  \t\tc++;\n  \t    else if ('\"' == *c)\n  \t    {\t// end of component\n  \t\tp.assign (start,c-start+1);\n  \t\tcomponents.push_back (Component(p));\n  \t\tstate = dot;\n  \t    }\n  \t    break;\n  \t}\n      }\n  }\n}"
  },
  {
    "function_name": "YCPPathRep",
    "container": "YCPPathRep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
    "lines": "28-30",
    "snippet": "YCPPathRep::YCPPathRep()\n{\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/YCPPath.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  YCPPathRep::YCPPathRep()\n  {\n  }\n}"
  }
]