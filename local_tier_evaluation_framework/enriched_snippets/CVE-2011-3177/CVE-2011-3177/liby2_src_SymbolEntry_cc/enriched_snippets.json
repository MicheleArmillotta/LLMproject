[
  {
    "function_name": "toString",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "262-349",
    "snippet": "string \nSymbolEntry::toString (bool with_type) const\n{\n    string s = (with_type && m_global) ? \"global \" : \"\";\n#if DO_DEBUG\n    y2debug (\"SymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n    y2debug (\"SymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n#endif\n    switch (m_category)\n    {\n\tcase c_unspec:\n\t{\n\t    return s + catString() + \" '\" + m_type->toString() + \" \" + m_name.asString() + \"'\";\n\t}\n\tbreak;\n\tcase c_module:\n\t{\n\t    return s + catString() + \" \\\"\" + m_name.asString() + \"\\\"\";\n\t}\n\tbreak;\n\tcase c_variable:\n\tcase c_reference:\n\tcase c_function:\n\t{\n#if DO_DEBUG\n\t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n#endif\n\t    if (with_type)\n\t    {\n\t\tconstFunctionTypePtr ftype = m_type;\n\t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n\t\t\n\t\tif (m_global\n\t\t    && m_namespace != 0\n\t\t    && !m_namespace->name().empty())\n\t\t{\n\t\t    s += (m_namespace->name() + \"::\");\n\t\t}\n\t\ts += m_name.asString();\n\t\tif (m_category == c_function)\n\t\t{\n\t\t    constFunctionTypePtr type = (constFunctionTypePtr)m_type;\n\t\t    \n\t\t    // are there any parameters\n\t\t    if (type->parameters())\n\t\t    {\n\t\t\ts += \" \" + type->parameters ()->toString ();\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\ts += \" ()\";\n\t\t    }\n\t\t}\n\t\treturn s;\n\t    }\n\t    else\n\t    {\n\t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n\t\treturn s;\n\t    }\n\t}\n\tcase c_typedef:\n\t{\n\t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n\t}\n\tbreak;\n\tcase c_const:\n\t{\n\t    return s + m_type->toString() + \" \" + m_name.asString();\n\t}\n\tbreak;\n\tcase c_namespace:\n\tcase c_self:\n\tcase c_filename:\n\tcase c_predefined:\n\t{\n\t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"category %d ?\", m_category);\n\t}\n\tbreak;\n    }\n\n    return \"?SymbolEntry?\";\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"category %d ?\"",
            "m_category"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name.asString",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "catString",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "catString",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "213-259",
          "snippet": "string \nSymbolEntry::catString () const\n{\n    switch (m_category)\n    {\n\tcase c_unspec:\n\t    return \"unspecified\";\n\tbreak;\n\tcase c_module:\n\t    return \"module\";\n\tbreak;\n\tcase c_variable:\n\t    return \"variable\";\n\tbreak;\n\tcase c_reference:\n\t    return \"reference\";\n\tbreak;\n\tcase c_function:\n\t    return \"function\";\n\tbreak;\n\tcase c_builtin:\n\t    return \"builtin\";\n\tbreak;\n\tcase c_typedef:\n\t    return \"typedef\";\n\tbreak;\n\tcase c_const:\n\t    return \"const\";\n\tbreak;\n\tcase c_namespace:\n\t    return \"namespace\";\n\tbreak;\n\tcase c_self:\n\t    return \"self\";\n\tbreak;\n\tcase c_filename:\n\t    return \"filename\";\n\tbreak;\n\tcase c_predefined:\n\t    return \"predefined\";\n\tbreak;\n\tdefault:\n\tbreak;\n    }\n\n    return \"?cat?\";\n}",
          "includes": [
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  string \n  SymbolEntry::catString () const\n  {\n      switch (m_category)\n      {\n  \tcase c_unspec:\n  \t    return \"unspecified\";\n  \tbreak;\n  \tcase c_module:\n  \t    return \"module\";\n  \tbreak;\n  \tcase c_variable:\n  \t    return \"variable\";\n  \tbreak;\n  \tcase c_reference:\n  \t    return \"reference\";\n  \tbreak;\n  \tcase c_function:\n  \t    return \"function\";\n  \tbreak;\n  \tcase c_builtin:\n  \t    return \"builtin\";\n  \tbreak;\n  \tcase c_typedef:\n  \t    return \"typedef\";\n  \tbreak;\n  \tcase c_const:\n  \t    return \"const\";\n  \tbreak;\n  \tcase c_namespace:\n  \t    return \"namespace\";\n  \tbreak;\n  \tcase c_self:\n  \t    return \"self\";\n  \tbreak;\n  \tcase c_filename:\n  \t    return \"filename\";\n  \tbreak;\n  \tcase c_predefined:\n  \t    return \"predefined\";\n  \tbreak;\n  \tdefault:\n  \tbreak;\n      }\n  \n      return \"?cat?\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_type->toString",
          "args": [],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "76-88",
          "snippet": "string\nY2Namespace::toString () const\n{\n    if (m_table == 0)\n    {\n\treturn \"<empty>\";\n    }\n\n    SymbolTable* t = m_table;\n    string s = t->toString ();\n\n    return s + symbolsToString ();\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  string\n  Y2Namespace::toString () const\n  {\n      if (m_table == 0)\n      {\n  \treturn \"<empty>\";\n      }\n  \n      SymbolTable* t = m_table;\n      string s = t->toString ();\n  \n      return s + symbolsToString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "(m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\""
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_namespace->name",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "62-66",
          "snippet": "const string\nY2Namespace::name () const\n{\n    return \"\";\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  const string\n  Y2Namespace::name () const\n  {\n      return \"\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->parameters",
          "args": [],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "parameters",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1686-1690",
          "snippet": "constTupleTypePtr\nFunctionType::parameters () const\n{\n    return m_arguments;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  constTupleTypePtr\n  FunctionType::parameters () const\n  {\n      return m_arguments;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftype->returnType",
          "args": [],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "returnType",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "513-513",
          "snippet": "constTypePtr returnType () const { return m_returntype; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nFunctionType {\n  constTypePtr returnType () const { return m_returntype; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"m_namespace %p[%s], m_global %d, with_type %d\"",
            "m_namespace",
            "m_namespace ? m_namespace->name().c_str() : \"\"",
            "m_global",
            "with_type"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"SymbolEntry::toString %p: with_type %d, cat %s, name '%s'\"",
            "this",
            "with_type",
            "catString().c_str()",
            "m_name.asString().c_str()"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"SymbolEntry::toString %p: name '%s'\"",
            "this",
            "m_name.asString().c_str()"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\n#define DO_DEBUG 0\n\nSymbolEntry {\n  string \n  SymbolEntry::toString (bool with_type) const\n  {\n      string s = (with_type && m_global) ? \"global \" : \"\";\n  #if DO_DEBUG\n      y2debug (\"SymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n      y2debug (\"SymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n  #endif\n      switch (m_category)\n      {\n  \tcase c_unspec:\n  \t{\n  \t    return s + catString() + \" '\" + m_type->toString() + \" \" + m_name.asString() + \"'\";\n  \t}\n  \tbreak;\n  \tcase c_module:\n  \t{\n  \t    return s + catString() + \" \\\"\" + m_name.asString() + \"\\\"\";\n  \t}\n  \tbreak;\n  \tcase c_variable:\n  \tcase c_reference:\n  \tcase c_function:\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n  #endif\n  \t    if (with_type)\n  \t    {\n  \t\tconstFunctionTypePtr ftype = m_type;\n  \t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n  \t\t\n  \t\tif (m_global\n  \t\t    && m_namespace != 0\n  \t\t    && !m_namespace->name().empty())\n  \t\t{\n  \t\t    s += (m_namespace->name() + \"::\");\n  \t\t}\n  \t\ts += m_name.asString();\n  \t\tif (m_category == c_function)\n  \t\t{\n  \t\t    constFunctionTypePtr type = (constFunctionTypePtr)m_type;\n  \t\t    \n  \t\t    // are there any parameters\n  \t\t    if (type->parameters())\n  \t\t    {\n  \t\t\ts += \" \" + type->parameters ()->toString ();\n  \t\t    }\n  \t\t    else\n  \t\t    {\n  \t\t\ts += \" ()\";\n  \t\t    }\n  \t\t}\n  \t\treturn s;\n  \t    }\n  \t    else\n  \t    {\n  \t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n  \t\treturn s;\n  \t    }\n  \t}\n  \tcase c_typedef:\n  \t{\n  \t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n  \t}\n  \tbreak;\n  \tcase c_const:\n  \t{\n  \t    return s + m_type->toString() + \" \" + m_name.asString();\n  \t}\n  \tbreak;\n  \tcase c_namespace:\n  \tcase c_self:\n  \tcase c_filename:\n  \tcase c_predefined:\n  \t{\n  \t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"category %d ?\", m_category);\n  \t}\n  \tbreak;\n      }\n  \n      return \"?SymbolEntry?\";\n  }\n}"
  },
  {
    "function_name": "catString",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "213-259",
    "snippet": "string \nSymbolEntry::catString () const\n{\n    switch (m_category)\n    {\n\tcase c_unspec:\n\t    return \"unspecified\";\n\tbreak;\n\tcase c_module:\n\t    return \"module\";\n\tbreak;\n\tcase c_variable:\n\t    return \"variable\";\n\tbreak;\n\tcase c_reference:\n\t    return \"reference\";\n\tbreak;\n\tcase c_function:\n\t    return \"function\";\n\tbreak;\n\tcase c_builtin:\n\t    return \"builtin\";\n\tbreak;\n\tcase c_typedef:\n\t    return \"typedef\";\n\tbreak;\n\tcase c_const:\n\t    return \"const\";\n\tbreak;\n\tcase c_namespace:\n\t    return \"namespace\";\n\tbreak;\n\tcase c_self:\n\t    return \"self\";\n\tbreak;\n\tcase c_filename:\n\t    return \"filename\";\n\tbreak;\n\tcase c_predefined:\n\t    return \"predefined\";\n\tbreak;\n\tdefault:\n\tbreak;\n    }\n\n    return \"?cat?\";\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  string \n  SymbolEntry::catString () const\n  {\n      switch (m_category)\n      {\n  \tcase c_unspec:\n  \t    return \"unspecified\";\n  \tbreak;\n  \tcase c_module:\n  \t    return \"module\";\n  \tbreak;\n  \tcase c_variable:\n  \t    return \"variable\";\n  \tbreak;\n  \tcase c_reference:\n  \t    return \"reference\";\n  \tbreak;\n  \tcase c_function:\n  \t    return \"function\";\n  \tbreak;\n  \tcase c_builtin:\n  \t    return \"builtin\";\n  \tbreak;\n  \tcase c_typedef:\n  \t    return \"typedef\";\n  \tbreak;\n  \tcase c_const:\n  \t    return \"const\";\n  \tbreak;\n  \tcase c_namespace:\n  \t    return \"namespace\";\n  \tbreak;\n  \tcase c_self:\n  \t    return \"self\";\n  \tbreak;\n  \tcase c_filename:\n  \t    return \"filename\";\n  \tbreak;\n  \tcase c_predefined:\n  \t    return \"predefined\";\n  \tbreak;\n  \tdefault:\n  \tbreak;\n      }\n  \n      return \"?cat?\";\n  }\n}"
  },
  {
    "function_name": "setGlobal",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "206-210",
    "snippet": "void\nSymbolEntry::setGlobal (bool global)\n{\n    m_global = global;\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  void\n  SymbolEntry::setGlobal (bool global)\n  {\n      m_global = global;\n  }\n}"
  },
  {
    "function_name": "setType",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "198-203",
    "snippet": "void\nSymbolEntry::setType (constTypePtr type)\n{\n    m_type = type;\n    return;\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  void\n  SymbolEntry::setType (constTypePtr type)\n  {\n      m_type = type;\n      return;\n  }\n}"
  },
  {
    "function_name": "type",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "191-195",
    "snippet": "constTypePtr\nSymbolEntry::type () const\n{\n    return m_type;\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  constTypePtr\n  SymbolEntry::type () const\n  {\n      return m_type;\n  }\n}"
  },
  {
    "function_name": "setCategory",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "183-188",
    "snippet": "void\nSymbolEntry::setCategory (SymbolEntry::category_t cat)\n{\n    m_category = cat;\n    return;\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  void\n  SymbolEntry::setCategory (SymbolEntry::category_t cat)\n  {\n      m_category = cat;\n      return;\n  }\n}"
  },
  {
    "function_name": "category",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "176-180",
    "snippet": "SymbolEntry::category_t \nSymbolEntry::category () const\n{\n    return m_category;\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  SymbolEntry::category_t \n  SymbolEntry::category () const\n  {\n      return m_category;\n  }\n}"
  },
  {
    "function_name": "pop",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "159-167",
    "snippet": "void\nSymbolEntry::pop ()\n{\n    if (! m_recurse_stack)\n\treturn;\n\n    m_value = m_recurse_stack->top ();\n    m_recurse_stack->pop ();\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_recurse_stack->pop",
          "args": [],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "pop",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "159-167",
          "snippet": "void\nSymbolEntry::pop ()\n{\n    if (! m_recurse_stack)\n\treturn;\n\n    m_value = m_recurse_stack->top ();\n    m_recurse_stack->pop ();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "m_recurse_stack->top",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  void\n  SymbolEntry::pop ()\n  {\n      if (! m_recurse_stack)\n  \treturn;\n  \n      m_value = m_recurse_stack->top ();\n      m_recurse_stack->pop ();\n  }\n}"
  },
  {
    "function_name": "push",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "149-157",
    "snippet": "void\nSymbolEntry::push ()\n{\n    if (! m_recurse_stack)\n    {\n\tm_recurse_stack = new valuestack_t;\n    }\n    m_recurse_stack->push (m_value);\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_recurse_stack->push",
          "args": [
            "m_value"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  void\n  SymbolEntry::push ()\n  {\n      if (! m_recurse_stack)\n      {\n  \tm_recurse_stack = new valuestack_t;\n      }\n      m_recurse_stack->push (m_value);\n  }\n}"
  },
  {
    "function_name": "value",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "136-147",
    "snippet": "YCPValue\nSymbolEntry::value () const\n{\n    if ((m_category == c_reference)\n\t&& !m_value.isNull()\n\t&& m_value->isReference())\n    {\n\ty2debug (\"DE-REFERENCE\");\n\treturn m_value->asReference()->entry()->value();\n    }\n    return m_value;\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_value->asReference",
          "args": [],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "asReference",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "239-249",
          "snippet": "YCPReference\nYCPValueRep::asReference() const\n{\n    if (!isReference())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Reference!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPReference (static_cast<const YCPReferenceRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPReference\n  YCPValueRep::asReference() const\n  {\n      if (!isReference())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Reference!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPReference (static_cast<const YCPReferenceRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"DE-REFERENCE\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_value->isReference",
          "args": [],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "isReference",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/include/y2/SymbolEntry.h",
          "lines": "132-132",
          "snippet": "bool isReference () const { return m_category == c_reference; }",
          "includes": [
            "#include <stack>",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/RepDef.h>",
            "#include <y2util/Ustring.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stack>\n#include \"ycp/Type.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/RepDef.h>\n#include <y2util/Ustring.h>\n\nSymbolEntry {\n  bool isReference () const { return m_category == c_reference; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_value.isNull",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  YCPValue\n  SymbolEntry::value () const\n  {\n      if ((m_category == c_reference)\n  \t&& !m_value.isNull()\n  \t&& m_value->isReference())\n      {\n  \ty2debug (\"DE-REFERENCE\");\n  \treturn m_value->asReference()->entry()->value();\n      }\n      return m_value;\n  }\n}"
  },
  {
    "function_name": "setValue",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "104-133",
    "snippet": "YCPValue\nSymbolEntry::setValue (YCPValue value)\n{\n    y2debug (\"SymbolEntry::setValue (%s@%p = '%s')\", m_name.asString().c_str(), this, value.isNull() ? \"nil\" : value->toString().c_str());\n    if (!value.isNull()\n\t&& (m_category == c_reference))\n    {\n\ty2debug (\"C_REFERENCE\");\n\tif (value->isReference())\n\t{\n\t    return m_value = value;\n\t}\n\n\tif (m_value.isNull()\n\t    || !m_value->isReference())\n\t{\n\t    y2error (\"Setting uninitialized reference\");\n\t    return YCPNull ();\n\t}\n\treturn m_value->asReference()->entry()->setValue (value);\n    }\n    \n    // use YCPVoid for nil to avoid problems with function references\n    if (value.isNull ())\n    {\n\tvalue = YCPVoid ();\n    }\n\t\n    return m_value = value;\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_value->asReference",
          "args": [
            "value"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_value->asReference",
          "args": [],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "asReference",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "239-249",
          "snippet": "YCPReference\nYCPValueRep::asReference() const\n{\n    if (!isReference())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Reference!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPReference (static_cast<const YCPReferenceRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPReference\n  YCPValueRep::asReference() const\n  {\n      if (!isReference())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Reference!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPReference (static_cast<const YCPReferenceRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Setting uninitialized reference\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_value->isReference",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "isReference",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/include/y2/SymbolEntry.h",
          "lines": "132-132",
          "snippet": "bool isReference () const { return m_category == c_reference; }",
          "includes": [
            "#include <stack>",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/RepDef.h>",
            "#include <y2util/Ustring.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stack>\n#include \"ycp/Type.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/RepDef.h>\n#include <y2util/Ustring.h>\n\nSymbolEntry {\n  bool isReference () const { return m_category == c_reference; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_value.isNull",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"C_REFERENCE\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"SymbolEntry::setValue (%s@%p = '%s')\"",
            "m_name.asString().c_str()",
            "this",
            "value.isNull() ? \"nil\" : value->toString().c_str()"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "76-88",
          "snippet": "string\nY2Namespace::toString () const\n{\n    if (m_table == 0)\n    {\n\treturn \"<empty>\";\n    }\n\n    SymbolTable* t = m_table;\n    string s = t->toString ();\n\n    return s + symbolsToString ();\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  string\n  Y2Namespace::toString () const\n  {\n      if (m_table == 0)\n      {\n  \treturn \"<empty>\";\n      }\n  \n      SymbolTable* t = m_table;\n      string s = t->toString ();\n  \n      return s + symbolsToString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name.asString",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  YCPValue\n  SymbolEntry::setValue (YCPValue value)\n  {\n      y2debug (\"SymbolEntry::setValue (%s@%p = '%s')\", m_name.asString().c_str(), this, value.isNull() ? \"nil\" : value->toString().c_str());\n      if (!value.isNull()\n  \t&& (m_category == c_reference))\n      {\n  \ty2debug (\"C_REFERENCE\");\n  \tif (value->isReference())\n  \t{\n  \t    return m_value = value;\n  \t}\n  \n  \tif (m_value.isNull()\n  \t    || !m_value->isReference())\n  \t{\n  \t    y2error (\"Setting uninitialized reference\");\n  \t    return YCPNull ();\n  \t}\n  \treturn m_value->asReference()->entry()->setValue (value);\n      }\n      \n      // use YCPVoid for nil to avoid problems with function references\n      if (value.isNull ())\n      {\n  \tvalue = YCPVoid ();\n      }\n  \t\n      return m_value = value;\n  }\n}"
  },
  {
    "function_name": "setPosition",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "96-101",
    "snippet": "void\nSymbolEntry::setPosition (unsigned int position)\n{\n    m_position = position;\n    return;\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  void\n  SymbolEntry::setPosition (unsigned int position)\n  {\n      m_position = position;\n      return;\n  }\n}"
  },
  {
    "function_name": "position",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "89-93",
    "snippet": "unsigned int\nSymbolEntry::position () const\n{\n    return m_position;\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  unsigned int\n  SymbolEntry::position () const\n  {\n      return m_position;\n  }\n}"
  },
  {
    "function_name": "isGlobal",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "82-86",
    "snippet": "bool\nSymbolEntry::isGlobal () const\n{\n    return m_global;\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  bool\n  SymbolEntry::isGlobal () const\n  {\n      return m_global;\n  }\n}"
  },
  {
    "function_name": "setNamespace",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "75-79",
    "snippet": "void\nSymbolEntry::setNamespace (const Y2Namespace *name_space)\n{\n    m_namespace = name_space;\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  void\n  SymbolEntry::setNamespace (const Y2Namespace *name_space)\n  {\n      m_namespace = name_space;\n  }\n}"
  },
  {
    "function_name": "~SymbolEntry",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "64-66",
    "snippet": "SymbolEntry::~SymbolEntry ()\n{\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  SymbolEntry::~SymbolEntry ()\n  {\n  }\n}"
  },
  {
    "function_name": "SymbolEntry",
    "container": "SymbolEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "52-62",
    "snippet": "SymbolEntry::SymbolEntry (const Y2Namespace* name_space, unsigned int position, const char *name, category_t cat, constTypePtr type)\n    : m_global ((cat == c_global)||(cat == c_filename))\n    , m_namespace (name_space)\n    , m_position (position)\n    , m_name ( Ustring ( *( _nameHash ? _nameHash : (_nameHash = new UstringHash)), name) )\n    , m_category ((cat == c_filename) ? cat : (m_global ? c_unspec : cat))\n    , m_type (type)\n    , m_value (YCPNull())\n    , m_recurse_stack (NULL)\n{\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "UstringHash* SymbolEntry::_nameHash = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Ustring",
          "args": [
            "*( _nameHash ? _nameHash : (_nameHash = new UstringHash))",
            "name"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nUstringHash* SymbolEntry::_nameHash = NULL;\n\nSymbolEntry {\n  SymbolEntry::SymbolEntry (const Y2Namespace* name_space, unsigned int position, const char *name, category_t cat, constTypePtr type)\n      : m_global ((cat == c_global)||(cat == c_filename))\n      , m_namespace (name_space)\n      , m_position (position)\n      , m_name ( Ustring ( *( _nameHash ? _nameHash : (_nameHash = new UstringHash)), name) )\n      , m_category ((cat == c_filename) ? cat : (m_global ? c_unspec : cat))\n      , m_type (type)\n      , m_value (YCPNull())\n      , m_recurse_stack (NULL)\n  {\n  }\n}"
  },
  {
    "function_name": "__UUsage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
    "lines": "42-45",
    "snippet": "void __UUsage ()\n{\n//    fprintf (stderr, \"%d Ustrings using %ld bytes\\n\", SymbolEntry::_nameHash.size(), SymbolEntry::_nameHash.sum());\n}",
    "includes": [
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"y2/SymbolEntry.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <string>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "UstringHash* SymbolEntry::_nameHash = NULL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nUstringHash* SymbolEntry::_nameHash = NULL;\n\nvoid __UUsage ()\n{\n//    fprintf (stderr, \"%d Ustrings using %ld bytes\\n\", SymbolEntry::_nameHash.size(), SymbolEntry::_nameHash.sum());\n}"
  }
]