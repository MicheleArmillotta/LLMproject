[
  {
    "function_name": "writeFile",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "1175-1197",
    "snippet": "bool\nBytecode::writeFile (const YCodePtr code, const string & filename)\n{\n    // clear errno first\n    errno = 0;\n\n#if DO_DEBUG\n//    y2debug (\"Bytecode::writeFile (%s)\", filename.c_str());\n#endif\n    std::ofstream outstream (filename.c_str());\n    if (!outstream.is_open ())\n    {\n\ty2error (\"Failed to write '%s': %s\", filename.c_str(), strerror (errno));\n\treturn false;\n    }\n\n    string header =  string (YaST_BYTECODE_HEADER YaST_BYTECODE_MAJOR \".\" YaST_BYTECODE_MINOR \".\" YaST_BYTECODE_RELEASE);\n    outstream.write (header.c_str(), header.size() + 1);\t// including trailing \\0\n\n    code->toStream (outstream);\n\n    return ! outstream.fail ();\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [
      "#define YaST_BYTECODE_RELEASE \"0\"",
      "#define YaST_BYTECODE_MINOR \"4\"",
      "#define YaST_BYTECODE_MAJOR \"1\"",
      "#define YaST_BYTECODE_HEADER \"YaST bytecode \"",
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "outstream.fail",
          "args": [],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "code->toStream",
          "args": [
            "outstream"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outstream.write",
          "args": [
            "header.c_str()",
            "header.size() + 1"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "header.size",
          "args": [],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "header.c_str",
          "args": [],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "YaST_BYTECODE_HEADER YaST_BYTECODE_MAJOR \".\" YaST_BYTECODE_MINOR \".\" YaST_BYTECODE_RELEASE"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "readUstring",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "263-279",
          "snippet": "Ustring\nBytecode::readUstring (bytecodeistream & streamref)\n{\n    u_int32_t len = readInt32 (streamref);\n    Ustring ret = Ustring (*SymbolEntry::_nameHash, \"\");\n    if (len > 0)\n    {\n\tchar *buf = new char [len+1];\n\tif (streamref.read (buf, len))\n\t{\n\t    buf[len] = 0;\n\t    ret = Ustring (*SymbolEntry::_nameHash, buf);\n\t}\n\tdelete [] buf;\n    }\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  Ustring\n  Bytecode::readUstring (bytecodeistream & streamref)\n  {\n      u_int32_t len = readInt32 (streamref);\n      Ustring ret = Ustring (*SymbolEntry::_nameHash, \"\");\n      if (len > 0)\n      {\n  \tchar *buf = new char [len+1];\n  \tif (streamref.read (buf, len))\n  \t{\n  \t    buf[len] = 0;\n  \t    ret = Ustring (*SymbolEntry::_nameHash, buf);\n  \t}\n  \tdelete [] buf;\n      }\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Failed to write '%s': %s\"",
            "filename.c_str()",
            "strerror (errno)"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outstream.is_open",
          "args": [],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define YaST_BYTECODE_RELEASE \"0\"\n#define YaST_BYTECODE_MINOR \"4\"\n#define YaST_BYTECODE_MAJOR \"1\"\n#define YaST_BYTECODE_HEADER \"YaST bytecode \"\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::writeFile (const YCodePtr code, const string & filename)\n  {\n      // clear errno first\n      errno = 0;\n  \n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::writeFile (%s)\", filename.c_str());\n  #endif\n      std::ofstream outstream (filename.c_str());\n      if (!outstream.is_open ())\n      {\n  \ty2error (\"Failed to write '%s': %s\", filename.c_str(), strerror (errno));\n  \treturn false;\n      }\n  \n      string header =  string (YaST_BYTECODE_HEADER YaST_BYTECODE_MAJOR \".\" YaST_BYTECODE_MINOR \".\" YaST_BYTECODE_RELEASE);\n      outstream.write (header.c_str(), header.size() + 1);\t// including trailing \\0\n  \n      code->toStream (outstream);\n  \n      return ! outstream.fail ();\n  }\n}"
  },
  {
    "function_name": "readFile",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "1129-1171",
    "snippet": "YCodePtr\nBytecode::readFile (const string & filename)\n{\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readFile (%s)\", filename.c_str());\n#endif\n    bytecodeistream instream (filename);\n    if (!instream.is_open ())\n    {\n\ty2error (\"Failed to open '%s': %s\", filename.c_str(), strerror (errno));\n\treturn 0;\n    }\n    // check YaST_BYTECODE_HEADER\n    if ( \n\tinstream.isVersion (\n\t    atoi (YaST_BYTECODE_MAJOR)\n\t    , atoi (YaST_BYTECODE_MINOR)\n\t    , atoi (YaST_BYTECODE_RELEASE))\n\t||\n\tinstream.isVersion (1,3,2) )\t// 9.1/SLES9\n    {\n#if DO_DEBUG\n//\ty2debug (\"Header accepted\");\n#endif\n\n\ttry\n\t{\n\t    return readCode (instream);\n\t}\n\tcatch (const Bytecode::Invalid&)\n\t{\n\t    // there are memory leaks all over the place now\n\t    y2error (\"Caught invalid bytecode in '%s'\", filename.c_str());\n\t    return 0;\n\t}\n    }\n\n    y2error (\"Unsupported version %d.%d.%d\"\n\t, instream.major ()\n\t, instream.minor ()\n\t, instream.release ());\n    return 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [
      "#define YaST_BYTECODE_RELEASE \"0\"",
      "#define YaST_BYTECODE_MINOR \"4\"",
      "#define YaST_BYTECODE_MAJOR \"1\"",
      "#define YaST_BYTECODE_HEADER \"YaST bytecode \"",
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unsupported version %d.%d.%d\"",
            "instream.major ()",
            "instream.minor ()",
            "instream.release ()"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instream.release",
          "args": [],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "release",
          "container": "bytecodeistream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Bytecode.h",
          "lines": "52-52",
          "snippet": "int release () const { return m_release; }",
          "includes": [
            "#include <fstream>",
            "#include <map>",
            "#include <string>",
            "#include <iosfwd>",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPValue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <map>\n#include <string>\n#include <iosfwd>\n#include \"ycp/Type.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPValue.h\"\n\nbytecodeistream {\n  int release () const { return m_release; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "instream.minor",
          "args": [],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "minor",
          "container": "bytecodeistream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Bytecode.h",
          "lines": "51-51",
          "snippet": "int minor () const { return m_minor; }",
          "includes": [
            "#include <fstream>",
            "#include <map>",
            "#include <string>",
            "#include <iosfwd>",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPValue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <map>\n#include <string>\n#include <iosfwd>\n#include \"ycp/Type.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPValue.h\"\n\nbytecodeistream {\n  int minor () const { return m_minor; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "instream.major",
          "args": [],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "major",
          "container": "bytecodeistream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Bytecode.h",
          "lines": "50-50",
          "snippet": "int major () const { return m_major; }",
          "includes": [
            "#include <fstream>",
            "#include <map>",
            "#include <string>",
            "#include <iosfwd>",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPValue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <map>\n#include <string>\n#include <iosfwd>\n#include \"ycp/Type.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPValue.h\"\n\nbytecodeistream {\n  int major () const { return m_major; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Caught invalid bytecode in '%s'\"",
            "filename.c_str()"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readCode",
          "args": [
            "instream"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "instream.isVersion",
          "args": [
            "1",
            "3",
            "2"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "isVersion",
          "container": "bytecodeistream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "96-101",
          "snippet": "bool bytecodeistream::isVersion (int major, int minor, int release)\n{\n    return (major == m_major) \n\t&& (minor == m_minor) \n\t&& (release == m_release);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nbytecodeistream {\n  bool bytecodeistream::isVersion (int major, int minor, int release)\n  {\n      return (major == m_major) \n  \t&& (minor == m_minor) \n  \t&& (release == m_release);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "YaST_BYTECODE_RELEASE"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "YaST_BYTECODE_MINOR"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "YaST_BYTECODE_MAJOR"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Failed to open '%s': %s\"",
            "filename.c_str()",
            "strerror (errno)"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instream.is_open",
          "args": [],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define YaST_BYTECODE_RELEASE \"0\"\n#define YaST_BYTECODE_MINOR \"4\"\n#define YaST_BYTECODE_MAJOR \"1\"\n#define YaST_BYTECODE_HEADER \"YaST bytecode \"\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readFile (const string & filename)\n  {\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readFile (%s)\", filename.c_str());\n  #endif\n      bytecodeistream instream (filename);\n      if (!instream.is_open ())\n      {\n  \ty2error (\"Failed to open '%s': %s\", filename.c_str(), strerror (errno));\n  \treturn 0;\n      }\n      // check YaST_BYTECODE_HEADER\n      if ( \n  \tinstream.isVersion (\n  \t    atoi (YaST_BYTECODE_MAJOR)\n  \t    , atoi (YaST_BYTECODE_MINOR)\n  \t    , atoi (YaST_BYTECODE_RELEASE))\n  \t||\n  \tinstream.isVersion (1,3,2) )\t// 9.1/SLES9\n      {\n  #if DO_DEBUG\n  //\ty2debug (\"Header accepted\");\n  #endif\n  \n  \ttry\n  \t{\n  \t    return readCode (instream);\n  \t}\n  \tcatch (const Bytecode::Invalid&)\n  \t{\n  \t    // there are memory leaks all over the place now\n  \t    y2error (\"Caught invalid bytecode in '%s'\", filename.c_str());\n  \t    return 0;\n  \t}\n      }\n  \n      y2error (\"Unsupported version %d.%d.%d\"\n  \t, instream.major ()\n  \t, instream.minor ()\n  \t, instream.release ());\n      return 0;\n  }\n}"
  },
  {
    "function_name": "readModule",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "1073-1125",
    "snippet": "YBlockPtr \nBytecode::readModule (const string & mname)\n{\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readModule (%s) \", mname.c_str ());\n#endif\n\n    // TODO better error reporting?\n    // like: could not find foo.ycp in /modules, /a/modules.\n    // It will return an empty string on failure\n\n    string filename = YCPPathSearch::findModule (mname);\n    if (filename.empty())\n    {\n\tycperror (\"Module '%s' not found\", mname.c_str());\n\treturn 0;\n    }\n    \n    if (! m_bytecodeCache)\n    {\n\tm_bytecodeCache = new map <string, YBlockPtr>;\n    }\n\n    // check the cache\n    if (m_bytecodeCache->find (mname) != m_bytecodeCache->end ())\n    {\n#if DO_DEBUG\n//\ty2debug (\"Bytecode cache hit: %s\", mname.c_str ());\n#endif\n\n\treturn m_bytecodeCache->find (mname)->second;\n    }\n    \n    int tare_id = Bytecode::tareStack ();\t\t\t// current nesting level is 0 for this module\n    YBlockPtr block = (YBlockPtr)Bytecode::readFile (filename);\n\n    if (block == NULL)\n    {\n\treturn NULL;\n    }\n\n    Bytecode::untareStack (tare_id);\n\n    if (!block->isModule())\n    {\n\ty2error (\"'%s' is no module\", filename.c_str());\n\treturn NULL;\n    }\n\n    m_bytecodeCache->insert (std::make_pair (mname, block));\n\n    return block;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "map <string, YBlockPtr>* Bytecode::m_bytecodeCache = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_bytecodeCache->insert",
          "args": [
            "std::make_pair (mname, block)"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "mname",
            "block"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"'%s' is no module\"",
            "filename.c_str()"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block->isModule",
          "args": [],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "isModule",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YBlock.h",
          "lines": "205-205",
          "snippet": "bool isModule () const\t{ return (m_kind == b_module); }",
          "includes": [
            "#include \"ycp/YStatement.h\"",
            "#include <y2/Y2Namespace.h>",
            "#include <y2util/Ustring.h>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YStatement.h\"\n#include <y2/Y2Namespace.h>\n#include <y2util/Ustring.h>\n#include <list>\n#include <string>\n\nYBlock {\n  bool isModule () const\t{ return (m_kind == b_module); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::untareStack",
          "args": [
            "tare_id"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "untareStack",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "727-735",
          "snippet": "void\nBytecode::untareStack (int tare_id)\n{\n#if DO_DEBUG\n//    y2debug (\"Bytecode::untareStack() level %d, size %d, current tare %d, tare_id %d\", m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level, tare_id);\n#endif\n    m_namespace_tare_level -= tare_id;\n    return;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "int Bytecode::m_namespace_nesting_level = -1;",
            "int Bytecode::m_namespace_nesting_array_size = 0;",
            "int Bytecode::m_namespace_tare_level = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nint Bytecode::m_namespace_nesting_level = -1;\nint Bytecode::m_namespace_nesting_array_size = 0;\nint Bytecode::m_namespace_tare_level = 0;\n\nBytecode {\n  void\n  Bytecode::untareStack (int tare_id)\n  {\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::untareStack() level %d, size %d, current tare %d, tare_id %d\", m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level, tare_id);\n  #endif\n      m_namespace_tare_level -= tare_id;\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readFile",
          "args": [
            "filename"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "readFile",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "1129-1171",
          "snippet": "YCodePtr\nBytecode::readFile (const string & filename)\n{\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readFile (%s)\", filename.c_str());\n#endif\n    bytecodeistream instream (filename);\n    if (!instream.is_open ())\n    {\n\ty2error (\"Failed to open '%s': %s\", filename.c_str(), strerror (errno));\n\treturn 0;\n    }\n    // check YaST_BYTECODE_HEADER\n    if ( \n\tinstream.isVersion (\n\t    atoi (YaST_BYTECODE_MAJOR)\n\t    , atoi (YaST_BYTECODE_MINOR)\n\t    , atoi (YaST_BYTECODE_RELEASE))\n\t||\n\tinstream.isVersion (1,3,2) )\t// 9.1/SLES9\n    {\n#if DO_DEBUG\n//\ty2debug (\"Header accepted\");\n#endif\n\n\ttry\n\t{\n\t    return readCode (instream);\n\t}\n\tcatch (const Bytecode::Invalid&)\n\t{\n\t    // there are memory leaks all over the place now\n\t    y2error (\"Caught invalid bytecode in '%s'\", filename.c_str());\n\t    return 0;\n\t}\n    }\n\n    y2error (\"Unsupported version %d.%d.%d\"\n\t, instream.major ()\n\t, instream.minor ()\n\t, instream.release ());\n    return 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define YaST_BYTECODE_RELEASE \"0\"",
            "#define YaST_BYTECODE_MINOR \"4\"",
            "#define YaST_BYTECODE_MAJOR \"1\"",
            "#define YaST_BYTECODE_HEADER \"YaST bytecode \"",
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define YaST_BYTECODE_RELEASE \"0\"\n#define YaST_BYTECODE_MINOR \"4\"\n#define YaST_BYTECODE_MAJOR \"1\"\n#define YaST_BYTECODE_HEADER \"YaST bytecode \"\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readFile (const string & filename)\n  {\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readFile (%s)\", filename.c_str());\n  #endif\n      bytecodeistream instream (filename);\n      if (!instream.is_open ())\n      {\n  \ty2error (\"Failed to open '%s': %s\", filename.c_str(), strerror (errno));\n  \treturn 0;\n      }\n      // check YaST_BYTECODE_HEADER\n      if ( \n  \tinstream.isVersion (\n  \t    atoi (YaST_BYTECODE_MAJOR)\n  \t    , atoi (YaST_BYTECODE_MINOR)\n  \t    , atoi (YaST_BYTECODE_RELEASE))\n  \t||\n  \tinstream.isVersion (1,3,2) )\t// 9.1/SLES9\n      {\n  #if DO_DEBUG\n  //\ty2debug (\"Header accepted\");\n  #endif\n  \n  \ttry\n  \t{\n  \t    return readCode (instream);\n  \t}\n  \tcatch (const Bytecode::Invalid&)\n  \t{\n  \t    // there are memory leaks all over the place now\n  \t    y2error (\"Caught invalid bytecode in '%s'\", filename.c_str());\n  \t    return 0;\n  \t}\n      }\n  \n      y2error (\"Unsupported version %d.%d.%d\"\n  \t, instream.major ()\n  \t, instream.minor ()\n  \t, instream.release ());\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::tareStack",
          "args": [],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "tareStack",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "715-724",
          "snippet": "int\nBytecode::tareStack ()\n{\n    int tare = m_namespace_nesting_level - m_namespace_tare_level + 1;\n#if DO_DEBUG\n//    y2debug (\"Bytecode::tareStack() level %d, size %d, current tare %d, tare_id %d\", m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level, tare);\n#endif\n    m_namespace_tare_level = m_namespace_nesting_level + 1;\n    return tare;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "int Bytecode::m_namespace_nesting_level = -1;",
            "int Bytecode::m_namespace_nesting_array_size = 0;",
            "int Bytecode::m_namespace_tare_level = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nint Bytecode::m_namespace_nesting_level = -1;\nint Bytecode::m_namespace_nesting_array_size = 0;\nint Bytecode::m_namespace_tare_level = 0;\n\nBytecode {\n  int\n  Bytecode::tareStack ()\n  {\n      int tare = m_namespace_nesting_level - m_namespace_tare_level + 1;\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::tareStack() level %d, size %d, current tare %d, tare_id %d\", m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level, tare);\n  #endif\n      m_namespace_tare_level = m_namespace_nesting_level + 1;\n      return tare;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_bytecodeCache->find",
          "args": [
            "mname"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_bytecodeCache->end",
          "args": [],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_bytecodeCache->find",
          "args": [
            "mname"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycperror",
          "args": [
            "\"Module '%s' not found\"",
            "mname.c_str()"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mname.c_str",
          "args": [],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.empty",
          "args": [],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPPathSearch::findModule",
          "args": [
            "mname"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nmap <string, YBlockPtr>* Bytecode::m_bytecodeCache = NULL;\n\nBytecode {\n  YBlockPtr \n  Bytecode::readModule (const string & mname)\n  {\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readModule (%s) \", mname.c_str ());\n  #endif\n  \n      // TODO better error reporting?\n      // like: could not find foo.ycp in /modules, /a/modules.\n      // It will return an empty string on failure\n  \n      string filename = YCPPathSearch::findModule (mname);\n      if (filename.empty())\n      {\n  \tycperror (\"Module '%s' not found\", mname.c_str());\n  \treturn 0;\n      }\n      \n      if (! m_bytecodeCache)\n      {\n  \tm_bytecodeCache = new map <string, YBlockPtr>;\n      }\n  \n      // check the cache\n      if (m_bytecodeCache->find (mname) != m_bytecodeCache->end ())\n      {\n  #if DO_DEBUG\n  //\ty2debug (\"Bytecode cache hit: %s\", mname.c_str ());\n  #endif\n  \n  \treturn m_bytecodeCache->find (mname)->second;\n      }\n      \n      int tare_id = Bytecode::tareStack ();\t\t\t// current nesting level is 0 for this module\n      YBlockPtr block = (YBlockPtr)Bytecode::readFile (filename);\n  \n      if (block == NULL)\n      {\n  \treturn NULL;\n      }\n  \n      Bytecode::untareStack (tare_id);\n  \n      if (!block->isModule())\n      {\n  \ty2error (\"'%s' is no module\", filename.c_str());\n  \treturn NULL;\n      }\n  \n      m_bytecodeCache->insert (std::make_pair (mname, block));\n  \n      return block;\n  }\n}"
  },
  {
    "function_name": "readCode",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "822-1062",
    "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unknown code %d\"",
            "code"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YECall::readCall",
          "args": [
            "str"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "readCall",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2700-2745",
          "snippet": "YECallPtr YECall::readCall (bytecodeistream & str)\n{\n    YECallPtr res = 0;\n\n    SymbolEntryPtr sentry = Bytecode::readEntry (str);\n    \n    if (!sentry)\n    {\n\treturn 0;\n    }\n    \n    if (str.isVersion (1,3,2) && sentry->isVariable ())\n    {\n\t// it is a function pointer from SLES9/9.1\n\tres = new YEFunctionPointer (0);\n    }\n    else\n    {\n\t// it is direct function call\n\tres = new YEFunction (0);\n    }\n    \n    res->m_sentry = sentry;\n    \n    // read the parameters\n    u_int32_t count = Bytecode::readInt32 (str);\n    \n    if (count>0)\n    {\n\tres->m_parameters = new YCodePtr[count];\n\n\tfor (uint i = 0 ; i < count; i++)\n\t{\n\t    res->m_parameters[i] = Bytecode::readCode (str);\n\t    if (res->m_parameters[i] == 0)\n\t    {\n\t\ty2error (\"parameter code read failed for %d\", i);\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n    res->m_next_param_id = count;\n\n    return res;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  YECallPtr YECall::readCall (bytecodeistream & str)\n  {\n      YECallPtr res = 0;\n  \n      SymbolEntryPtr sentry = Bytecode::readEntry (str);\n      \n      if (!sentry)\n      {\n  \treturn 0;\n      }\n      \n      if (str.isVersion (1,3,2) && sentry->isVariable ())\n      {\n  \t// it is a function pointer from SLES9/9.1\n  \tres = new YEFunctionPointer (0);\n      }\n      else\n      {\n  \t// it is direct function call\n  \tres = new YEFunction (0);\n      }\n      \n      res->m_sentry = sentry;\n      \n      // read the parameters\n      u_int32_t count = Bytecode::readInt32 (str);\n      \n      if (count>0)\n      {\n  \tres->m_parameters = new YCodePtr[count];\n  \n  \tfor (uint i = 0 ; i < count; i++)\n  \t{\n  \t    res->m_parameters[i] = Bytecode::readCode (str);\n  \t    if (res->m_parameters[i] == 0)\n  \t    {\n  \t\ty2error (\"parameter code read failed for %d\", i);\n  \t\treturn 0;\n  \t    }\n  \t}\n      }\n  \n      res->m_next_param_id = count;\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unable to read constant, check the compilation of the module\""
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str.isVersion",
          "args": [
            "1",
            "3",
            "2"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "isVersion",
          "container": "bytecodeistream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "96-101",
          "snippet": "bool bytecodeistream::isVersion (int major, int minor, int release)\n{\n    return (major == m_major) \n\t&& (minor == m_minor) \n\t&& (release == m_release);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nbytecodeistream {\n  bool bytecodeistream::isVersion (int major, int minor, int release)\n  {\n      return (major == m_major) \n  \t&& (minor == m_minor) \n  \t&& (release == m_release);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Can't read from stream\""
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str.get",
          "args": [
            "code"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
  },
  {
    "function_name": "readEntry",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "762-815",
    "snippet": "SymbolEntryPtr \nBytecode::readEntry (bytecodeistream & str)\n{\n    // read reference to namespaces (namespace_id) symbol table (position)\n    int namespace_id = Bytecode::readInt32 (str);\n    int position = Bytecode::readInt32 (str);\n\n    if (namespace_id == -1)\n    {\n#if DO_DEBUG\n\ty2debug( \"Special entry without namespace\" );\n#endif\n\t// FIXME: this may be wrong\n\treturn 0;\n    }\n\n    // get namespace pointer and SymbolEntry within namespace\n    const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n    if (name_space == 0)\n    {\n\ty2error (\"invalid namespace %d for entry\", namespace_id);\n\treturn 0;\n    }\n\n    SymbolEntryPtr sentry;\n    if (position < 0)\t\t\t\t// it's an Xref !\n    {\n\tSymbolTable *table = name_space->table();\n\tif (table == 0)\n\t{\n\t    ycp2error (\"No table associated to xref namespace\\n\");\n\t    exit (1);\n\t}\n\tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n#if DO_DEBUG\n\ty2debug (\"get reference %d from table %p\", position, table);\n#endif\n\tsentry = table->getXRef(position);\n    }\n    else\n    {\n\tsentry = name_space->symbolEntry (position);\n    }\n\n    if (sentry == 0)\n    {\n\ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n\treturn 0;\n    }\n#if DO_DEBUG\n    y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n#endif\n    return sentry;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\"",
            "namespace_id",
            "name_space",
            "name_space->name().c_str()",
            "position",
            "sentry->toString().c_str()"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sentry->toString",
          "args": [],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "name_space->name",
          "args": [],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Import",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Import.cc",
          "lines": "189-193",
          "snippet": "string\nImport::name () const\n{\n    return m_name;\n}",
          "includes": [
            "#include \"y2/Y2ComponentBroker.h\"",
            "#include \"y2/Y2Component.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/Import.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2ComponentBroker.h\"\n#include \"y2/Y2Component.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/Import.h\"\n#include <libintl.h>\n\nImport {\n  string\n  Import::name () const\n  {\n      return m_name;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"invalid entry %d for namespace (%s)\"",
            "position",
            "name_space->name().c_str()"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_space->symbolEntry",
          "args": [
            "position"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "symbolEntry",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "118-126",
          "snippet": "SymbolEntryPtr \nY2Namespace::symbolEntry (unsigned int position) const\n{\n    if (position >= m_symbolcount)\n    {\n\treturn 0;\n    }\n    return m_symbols[position];\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  SymbolEntryPtr \n  Y2Namespace::symbolEntry (unsigned int position) const\n  {\n      if (position >= m_symbolcount)\n      {\n  \treturn 0;\n      }\n      return m_symbols[position];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "table->getXRef",
          "args": [
            "position"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "getXRef",
          "container": "SymbolTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "368-383",
          "snippet": "SymbolEntryPtr \nSymbolTable::getXRef (unsigned int position) const\n{\n    if (!m_xrefs || m_xrefs->empty())\n    {\n\ty2error (\"SymbolTable[%p]::getXRefs empty !\", this);\n\treturn 0;\n    }\n    std::vector<TableEntry *> *refs = m_xrefs->top();\n    if (position >= refs->size())\n    {\n\ty2error (\"SymbolTable[%p]::getXRefs position %u >= size %zu !\", this, position, refs->size());\n\treturn 0;\n    }\n    return (*refs)[position]->sentry();\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nSymbolTable {\n  SymbolEntryPtr \n  SymbolTable::getXRef (unsigned int position) const\n  {\n      if (!m_xrefs || m_xrefs->empty())\n      {\n  \ty2error (\"SymbolTable[%p]::getXRefs empty !\", this);\n  \treturn 0;\n      }\n      std::vector<TableEntry *> *refs = m_xrefs->top();\n      if (position >= refs->size())\n      {\n  \ty2error (\"SymbolTable[%p]::getXRefs position %u >= size %zu !\", this, position, refs->size());\n  \treturn 0;\n      }\n      return (*refs)[position]->sentry();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"get reference %d from table %p\"",
            "position",
            "table"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"No table associated to xref namespace\\n\""
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_space->table",
          "args": [],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"invalid namespace %d for entry\"",
            "namespace_id"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::namespacePtr",
          "args": [
            "namespace_id"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Special entry without namespace\""
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readInt32",
          "args": [
            "str"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  SymbolEntryPtr \n  Bytecode::readEntry (bytecodeistream & str)\n  {\n      // read reference to namespaces (namespace_id) symbol table (position)\n      int namespace_id = Bytecode::readInt32 (str);\n      int position = Bytecode::readInt32 (str);\n  \n      if (namespace_id == -1)\n      {\n  #if DO_DEBUG\n  \ty2debug( \"Special entry without namespace\" );\n  #endif\n  \t// FIXME: this may be wrong\n  \treturn 0;\n      }\n  \n      // get namespace pointer and SymbolEntry within namespace\n      const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n      if (name_space == 0)\n      {\n  \ty2error (\"invalid namespace %d for entry\", namespace_id);\n  \treturn 0;\n      }\n  \n      SymbolEntryPtr sentry;\n      if (position < 0)\t\t\t\t// it's an Xref !\n      {\n  \tSymbolTable *table = name_space->table();\n  \tif (table == 0)\n  \t{\n  \t    ycp2error (\"No table associated to xref namespace\\n\");\n  \t    exit (1);\n  \t}\n  \tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n  #if DO_DEBUG\n  \ty2debug (\"get reference %d from table %p\", position, table);\n  #endif\n  \tsentry = table->getXRef(position);\n      }\n      else\n      {\n  \tsentry = name_space->symbolEntry (position);\n      }\n  \n      if (sentry == 0)\n      {\n  \ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n  \treturn 0;\n      }\n  #if DO_DEBUG\n      y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n  #endif\n      return sentry;\n  }\n}"
  },
  {
    "function_name": "untareStack",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "727-735",
    "snippet": "void\nBytecode::untareStack (int tare_id)\n{\n#if DO_DEBUG\n//    y2debug (\"Bytecode::untareStack() level %d, size %d, current tare %d, tare_id %d\", m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level, tare_id);\n#endif\n    m_namespace_tare_level -= tare_id;\n    return;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "int Bytecode::m_namespace_nesting_level = -1;",
      "int Bytecode::m_namespace_nesting_array_size = 0;",
      "int Bytecode::m_namespace_tare_level = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nint Bytecode::m_namespace_nesting_level = -1;\nint Bytecode::m_namespace_nesting_array_size = 0;\nint Bytecode::m_namespace_tare_level = 0;\n\nBytecode {\n  void\n  Bytecode::untareStack (int tare_id)\n  {\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::untareStack() level %d, size %d, current tare %d, tare_id %d\", m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level, tare_id);\n  #endif\n      m_namespace_tare_level -= tare_id;\n      return;\n  }\n}"
  },
  {
    "function_name": "tareStack",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "715-724",
    "snippet": "int\nBytecode::tareStack ()\n{\n    int tare = m_namespace_nesting_level - m_namespace_tare_level + 1;\n#if DO_DEBUG\n//    y2debug (\"Bytecode::tareStack() level %d, size %d, current tare %d, tare_id %d\", m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level, tare);\n#endif\n    m_namespace_tare_level = m_namespace_nesting_level + 1;\n    return tare;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "int Bytecode::m_namespace_nesting_level = -1;",
      "int Bytecode::m_namespace_nesting_array_size = 0;",
      "int Bytecode::m_namespace_tare_level = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nint Bytecode::m_namespace_nesting_level = -1;\nint Bytecode::m_namespace_nesting_array_size = 0;\nint Bytecode::m_namespace_tare_level = 0;\n\nBytecode {\n  int\n  Bytecode::tareStack ()\n  {\n      int tare = m_namespace_nesting_level - m_namespace_tare_level + 1;\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::tareStack() level %d, size %d, current tare %d, tare_id %d\", m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level, tare);\n  #endif\n      m_namespace_tare_level = m_namespace_nesting_level + 1;\n      return tare;\n  }\n}"
  },
  {
    "function_name": "popUptoNamespace",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "683-710",
    "snippet": "void\nBytecode::popUptoNamespace (const Y2Namespace *name_space)\n{\n#if DO_DEBUG\n    y2debug (\"Bytecode::popUptoNamespace (%p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n#endif\n    if (name_space == 0)\n    {\n\ty2error (\"Bytecode::popUptoNamespace (%p) NULL\", name_space);\n\treturn;\n    }\n\n    while (m_namespace_nesting_level >= m_namespace_tare_level)\n    {\n\tconst Y2Namespace *top_space = m_namespace_nesting_array[m_namespace_nesting_level].name_space;\n\tif (m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs)\n\t{\n\t    top_space->table()->closeXRefs();\n\t}\n\tm_namespace_nesting_level--;\n\tif (top_space == name_space)\n\t{\n\t    return;\n\t}\n    }\n    y2error (\"Bytecode::popUptoNamespace (%p) empty stack\", name_space);\n    return;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "int Bytecode::m_namespace_nesting_level = -1;",
      "int Bytecode::m_namespace_nesting_array_size = 0;",
      "int Bytecode::m_namespace_tare_level = 0;",
      "Bytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bytecode::popUptoNamespace (%p) empty stack\"",
            "name_space"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "top_space->table",
          "args": [],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "top_space->table",
          "args": [],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bytecode::popUptoNamespace (%p) NULL\"",
            "name_space"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Bytecode::popUptoNamespace (%p), level %d, size %d, tare %d\"",
            "name_space",
            "m_namespace_nesting_level",
            "m_namespace_nesting_array_size",
            "m_namespace_tare_level"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nint Bytecode::m_namespace_nesting_level = -1;\nint Bytecode::m_namespace_nesting_array_size = 0;\nint Bytecode::m_namespace_tare_level = 0;\nBytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;\n\nBytecode {\n  void\n  Bytecode::popUptoNamespace (const Y2Namespace *name_space)\n  {\n  #if DO_DEBUG\n      y2debug (\"Bytecode::popUptoNamespace (%p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n  #endif\n      if (name_space == 0)\n      {\n  \ty2error (\"Bytecode::popUptoNamespace (%p) NULL\", name_space);\n  \treturn;\n      }\n  \n      while (m_namespace_nesting_level >= m_namespace_tare_level)\n      {\n  \tconst Y2Namespace *top_space = m_namespace_nesting_array[m_namespace_nesting_level].name_space;\n  \tif (m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs)\n  \t{\n  \t    top_space->table()->closeXRefs();\n  \t}\n  \tm_namespace_nesting_level--;\n  \tif (top_space == name_space)\n  \t{\n  \t    return;\n  \t}\n      }\n      y2error (\"Bytecode::popUptoNamespace (%p) empty stack\", name_space);\n      return;\n  }\n}"
  },
  {
    "function_name": "popNamespace",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "650-679",
    "snippet": "int\nBytecode::popNamespace (const Y2Namespace *name_space)\n{\n#if DO_DEBUG\n    y2debug (\"Bytecode::popNamespace (%p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n#endif\n    if (name_space == 0)\n    {\n\ty2error (\"Bytecode::popNamespace (%p) NULL\", name_space);\n\treturn -1;\n    }\n\n    if (m_namespace_nesting_level < m_namespace_tare_level)\n    {\n\ty2error (\"Bytecode::popNamespace (%p) empty stack\", name_space);\n    }\n    else if (m_namespace_nesting_array[m_namespace_nesting_level].name_space != name_space)\n    {\n\ty2error (\"Bytecode::popNamespace (%p) not top of stack [%d]%p\", name_space, m_namespace_nesting_level, m_namespace_nesting_array[m_namespace_nesting_level].name_space);\n    }\n    else\n    {\n\tif (m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs)\n\t{\n\t    name_space->table()->closeXRefs();\n\t}\n\tm_namespace_nesting_level--;\n    }\n    return 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "int Bytecode::m_namespace_nesting_level = -1;",
      "int Bytecode::m_namespace_nesting_array_size = 0;",
      "int Bytecode::m_namespace_tare_level = 0;",
      "Bytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "name_space->table",
          "args": [],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_space->table",
          "args": [],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bytecode::popNamespace (%p) not top of stack [%d]%p\"",
            "name_space",
            "m_namespace_nesting_level",
            "m_namespace_nesting_array[m_namespace_nesting_level].name_space"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bytecode::popNamespace (%p) empty stack\"",
            "name_space"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bytecode::popNamespace (%p) NULL\"",
            "name_space"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Bytecode::popNamespace (%p), level %d, size %d, tare %d\"",
            "name_space",
            "m_namespace_nesting_level",
            "m_namespace_nesting_array_size",
            "m_namespace_tare_level"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nint Bytecode::m_namespace_nesting_level = -1;\nint Bytecode::m_namespace_nesting_array_size = 0;\nint Bytecode::m_namespace_tare_level = 0;\nBytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;\n\nBytecode {\n  int\n  Bytecode::popNamespace (const Y2Namespace *name_space)\n  {\n  #if DO_DEBUG\n      y2debug (\"Bytecode::popNamespace (%p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n  #endif\n      if (name_space == 0)\n      {\n  \ty2error (\"Bytecode::popNamespace (%p) NULL\", name_space);\n  \treturn -1;\n      }\n  \n      if (m_namespace_nesting_level < m_namespace_tare_level)\n      {\n  \ty2error (\"Bytecode::popNamespace (%p) empty stack\", name_space);\n      }\n      else if (m_namespace_nesting_array[m_namespace_nesting_level].name_space != name_space)\n      {\n  \ty2error (\"Bytecode::popNamespace (%p) not top of stack [%d]%p\", name_space, m_namespace_nesting_level, m_namespace_nesting_array[m_namespace_nesting_level].name_space);\n      }\n      else\n      {\n  \tif (m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs)\n  \t{\n  \t    name_space->table()->closeXRefs();\n  \t}\n  \tm_namespace_nesting_level--;\n      }\n      return 0;\n  }\n}"
  },
  {
    "function_name": "pushNamespace",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "619-645",
    "snippet": "int\nBytecode::pushNamespace (const Y2Namespace *name_space, bool with_xrefs)\n{\n    if (name_space == 0)\n    {\n\ty2error (\"Bytecode::pushNamespace (%p) NULL\", name_space);\n\treturn -1;\n    }\n\n    m_namespace_nesting_level++;\n    if (m_namespace_nesting_array_size <= m_namespace_nesting_level)\n    {\n\tm_namespace_nesting_array_size += 16;\n\tm_namespace_nesting_array = (namespaceentry_t *)realloc (m_namespace_nesting_array, sizeof (namespaceentry_t) * m_namespace_nesting_array_size);\n    }\n#if DO_DEBUG\n    y2debug (\"Bytecode::pushNamespace (%p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n#endif\n    m_namespace_nesting_array[m_namespace_nesting_level].name_space = name_space;\n    m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs = with_xrefs;\n    if (with_xrefs)\n    {\n\tname_space->table()->openXRefs();\n    }\n\n    return m_namespace_nesting_level-m_namespace_tare_level;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "int Bytecode::m_namespace_nesting_level = -1;",
      "int Bytecode::m_namespace_nesting_array_size = 0;",
      "int Bytecode::m_namespace_tare_level = 0;",
      "Bytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "name_space->table",
          "args": [],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_space->table",
          "args": [],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Bytecode::pushNamespace (%p), level %d, size %d, tare %d\"",
            "name_space",
            "m_namespace_nesting_level",
            "m_namespace_nesting_array_size",
            "m_namespace_tare_level"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "m_namespace_nesting_array",
            "sizeof (namespaceentry_t) * m_namespace_nesting_array_size"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bytecode::pushNamespace (%p) NULL\"",
            "name_space"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nint Bytecode::m_namespace_nesting_level = -1;\nint Bytecode::m_namespace_nesting_array_size = 0;\nint Bytecode::m_namespace_tare_level = 0;\nBytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;\n\nBytecode {\n  int\n  Bytecode::pushNamespace (const Y2Namespace *name_space, bool with_xrefs)\n  {\n      if (name_space == 0)\n      {\n  \ty2error (\"Bytecode::pushNamespace (%p) NULL\", name_space);\n  \treturn -1;\n      }\n  \n      m_namespace_nesting_level++;\n      if (m_namespace_nesting_array_size <= m_namespace_nesting_level)\n      {\n  \tm_namespace_nesting_array_size += 16;\n  \tm_namespace_nesting_array = (namespaceentry_t *)realloc (m_namespace_nesting_array, sizeof (namespaceentry_t) * m_namespace_nesting_array_size);\n      }\n  #if DO_DEBUG\n      y2debug (\"Bytecode::pushNamespace (%p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n  #endif\n      m_namespace_nesting_array[m_namespace_nesting_level].name_space = name_space;\n      m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs = with_xrefs;\n      if (with_xrefs)\n      {\n  \tname_space->table()->openXRefs();\n      }\n  \n      return m_namespace_nesting_level-m_namespace_tare_level;\n  }\n}"
  },
  {
    "function_name": "namespaceId",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "585-597",
    "snippet": "int\nBytecode::namespaceId (const Y2Namespace *name_space)\n{\n    for (int i = m_namespace_tare_level; i <= m_namespace_nesting_level; i++)\n    {\n\tif (m_namespace_nesting_array[i].name_space == name_space)\n\t{\n\t    return i - m_namespace_tare_level;\n\t}\n    }\n    y2error (\"No ID for %p, level %d\", name_space, m_namespace_nesting_level);\n    return -1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int Bytecode::m_namespace_nesting_level = -1;",
      "int Bytecode::m_namespace_tare_level = 0;",
      "Bytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"No ID for %p, level %d\"",
            "name_space",
            "m_namespace_nesting_level"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nint Bytecode::m_namespace_nesting_level = -1;\nint Bytecode::m_namespace_tare_level = 0;\nBytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;\n\nBytecode {\n  int\n  Bytecode::namespaceId (const Y2Namespace *name_space)\n  {\n      for (int i = m_namespace_tare_level; i <= m_namespace_nesting_level; i++)\n      {\n  \tif (m_namespace_nesting_array[i].name_space == name_space)\n  \t{\n  \t    return i - m_namespace_tare_level;\n  \t}\n      }\n      y2error (\"No ID for %p, level %d\", name_space, m_namespace_nesting_level);\n      return -1;\n  }\n}"
  },
  {
    "function_name": "readYCodelist",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "540-578",
    "snippet": "bool\nBytecode::readYCodelist (bytecodeistream & str, ycodelist_t **anchor)\n{\n    u_int32_t count = readInt32 (str);\n\n#if DO_DEBUG\n    y2debug (\"Bytecode::readYCodelist %d entries\", count);\n#endif\n\n    ycodelist_t *last = 0;\n\n    while (count-- > 0)\n    {\n\tycodelist_t *element = new ycodelist_t;\n\n\telement->code = Bytecode::readCode (str);\n\telement->next = 0;\n\n\tif (element->code == 0)\n\t{\n\t    y2error (\"Bytecode::readYCodelist failed\");\n\t    delete element;\n\t    return false;\n\t}\n\n\tif (*anchor == 0)\t\t// anchor undefined\n\t{\n\t    *anchor = element;\n\t}\n\telse\n\t{\n\t    last->next = element;\n\t}\n\n\tlast = element;\n    }\n\n    return str.good();\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "str.good",
          "args": [],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bytecode::readYCodelist failed\""
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Bytecode::readYCodelist %d entries\"",
            "count"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readInt32",
          "args": [
            "str"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readYCodelist (bytecodeistream & str, ycodelist_t **anchor)\n  {\n      u_int32_t count = readInt32 (str);\n  \n  #if DO_DEBUG\n      y2debug (\"Bytecode::readYCodelist %d entries\", count);\n  #endif\n  \n      ycodelist_t *last = 0;\n  \n      while (count-- > 0)\n      {\n  \tycodelist_t *element = new ycodelist_t;\n  \n  \telement->code = Bytecode::readCode (str);\n  \telement->next = 0;\n  \n  \tif (element->code == 0)\n  \t{\n  \t    y2error (\"Bytecode::readYCodelist failed\");\n  \t    delete element;\n  \t    return false;\n  \t}\n  \n  \tif (*anchor == 0)\t\t// anchor undefined\n  \t{\n  \t    *anchor = element;\n  \t}\n  \telse\n  \t{\n  \t    last->next = element;\n  \t}\n  \n  \tlast = element;\n      }\n  \n      return str.good();\n  }\n}"
  },
  {
    "function_name": "readValue",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "419-500",
    "snippet": "YCPValue\nBytecode::readValue (bytecodeistream & str)\n{\n    char vt;\n    if (str.get (vt))\n    {\n\tswitch (vt)\n\t{\n\t    case YT_VOID:\n\t    {\n\t\treturn YCPVoid (str);\n\t    }\n\t    break;\n\t    case YT_BOOLEAN:\n\t    {\n\t\treturn YCPBoolean (str);\n\t    }\n\t    break;\n\t    case YT_INTEGER:\n\t    {\n\t\treturn YCPInteger (str);\n\t    }\n\t    break;\n\t    case YT_FLOAT:\n\t    {\n\t\treturn YCPFloat (str);\n\t    }\n\t    break;\n\t    case YT_STRING:\n\t    {\n\t\treturn YCPString (str);\n\t    }\n\t    break;\n\t    case YT_BYTEBLOCK:\n\t    {\n\t\treturn YCPByteblock (str);\n\t    }\n\t    break;\n\t    case YT_PATH:\n\t    {\n\t\treturn YCPPath (str);\n\t    }\n\t    break;\n\t    case YT_SYMBOL:\n\t    {\n\t\treturn YCPSymbol (str);\n\t    }\n\t    break;\n\t    case YT_LIST:\n\t    {\n\t\treturn YCPList (str);\n\t    }\n\t    break;\n\t    case YT_MAP:\n\t    {\n\t\treturn YCPMap (str);\n\t    }\n\t    break;\n\t    case YT_TERM:\n\t    {\n\t\treturn YCPTerm (str);\n\t    }\n\t    break;\n\t    case YT_CODE:\n\t    {\n\t\treturn YCPCode (str);\n\t    }\n\t    break;\n\t    default:\n\t    {\n\t\ty2error (\"readValue stream code %d\", vt);\n\t\tbreak;\n\t    }\n\t}\n    }\n    else\n    {\n\ty2warning (\"readValue(%d:%s) NIL\", (int)vt, YCode::toString((YCode::ykind)vt).c_str());\n    }\n\n    return YCPNull();\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"readValue(%d:%s) NIL\"",
            "(int)vt",
            "YCode::toString((YCode::ykind)vt).c_str()"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCode::toString",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "182-186",
          "snippet": "string\nYCode::toString() const\n{\n    return toString (kind ());\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  string\n  YCode::toString() const\n  {\n      return toString (kind ());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"readValue stream code %d\"",
            "vt"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPCode",
          "args": [
            "str"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "YCPCode",
          "container": "YCPCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "103-107",
          "snippet": "YCPCode::YCPCode (bytecodeistream & str)\n    : YCPValue (YCPCode())\n{\n    (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPCode {\n  YCPCode::YCPCode (bytecodeistream & str)\n      : YCPValue (YCPCode())\n  {\n      (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPTerm",
          "args": [
            "str"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "YCPTerm",
          "container": "YCPTerm",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "178-194",
          "snippet": "YCPTerm::YCPTerm (bytecodeistream & str)\n    : YCPValue (YCPTerm(\"no-name-so-far\"))\n{\n    string s;\n    if (Bytecode::readString (str, s))\n    {\n\tYCPList list (str);\n\tif (!list.isNull())\n\t{\n\t    (const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->setName(s);\n\t    for (int i = 0 ; i < list->size () ; i++)\n\t    {\n\t\t(const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->add (list->value (i));\n\t    }\n\t}\n    }\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTerm {\n  YCPTerm::YCPTerm (bytecodeistream & str)\n      : YCPValue (YCPTerm(\"no-name-so-far\"))\n  {\n      string s;\n      if (Bytecode::readString (str, s))\n      {\n  \tYCPList list (str);\n  \tif (!list.isNull())\n  \t{\n  \t    (const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->setName(s);\n  \t    for (int i = 0 ; i < list->size () ; i++)\n  \t    {\n  \t\t(const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->add (list->value (i));\n  \t    }\n  \t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPMap",
          "args": [
            "str"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "YCPMap",
          "container": "YCPMap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "261-274",
          "snippet": "YCPMap::YCPMap(bytecodeistream & str)\n    : YCPValue (YCPMap())\n{\n    u_int32_t len = Bytecode::readInt32 (str);\n    if (str.good())\n    {\n\tfor (unsigned index=0; index < len; index++)\n\t{\n\t    YCPValue key = Bytecode::readValue (str);\n\t    YCPValue value = Bytecode::readValue (str);\n\t    (*this)->add (key, value);\n\t}\n    }\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMap {\n  YCPMap::YCPMap(bytecodeistream & str)\n      : YCPValue (YCPMap())\n  {\n      u_int32_t len = Bytecode::readInt32 (str);\n      if (str.good())\n      {\n  \tfor (unsigned index=0; index < len; index++)\n  \t{\n  \t    YCPValue key = Bytecode::readValue (str);\n  \t    YCPValue value = Bytecode::readValue (str);\n  \t    (*this)->add (key, value);\n  \t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPList",
          "args": [
            "str"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "YCPList",
          "container": "YCPList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "303-316",
          "snippet": "YCPList::YCPList(bytecodeistream & str)\n    : YCPValue (YCPList())\n{\n    u_int32_t len = Bytecode::readInt32 (str);\n    if (str.good())\n    {\n\t(const_cast<YCPListRep*>(static_cast<const YCPListRep*>(element)))->reserve (len);\n\tfor (unsigned index = 0; index < len; index++)\n\t{\n\t    YCPValue value = Bytecode::readValue (str);\n\t    (const_cast<YCPListRep*>(static_cast<const YCPListRep*>(element)))->set (index, value);\n\t}\n    }\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPList {\n  YCPList::YCPList(bytecodeistream & str)\n      : YCPValue (YCPList())\n  {\n      u_int32_t len = Bytecode::readInt32 (str);\n      if (str.good())\n      {\n  \t(const_cast<YCPListRep*>(static_cast<const YCPListRep*>(element)))->reserve (len);\n  \tfor (unsigned index = 0; index < len; index++)\n  \t{\n  \t    YCPValue value = Bytecode::readValue (str);\n  \t    (const_cast<YCPListRep*>(static_cast<const YCPListRep*>(element)))->set (index, value);\n  \t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPSymbol",
          "args": [
            "str"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "YCPSymbol",
          "container": "YCPSymbol",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "104-107",
          "snippet": "YCPSymbol::YCPSymbol (bytecodeistream & str)\n    : YCPValue (new YCPSymbolRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbol {\n  YCPSymbol::YCPSymbol (bytecodeistream & str)\n      : YCPValue (new YCPSymbolRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPPath",
          "args": [
            "str"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "YCPPath",
          "container": "YCPPath",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "402-418",
          "snippet": "YCPPath::YCPPath (bytecodeistream & str)\n    : YCPValue (new YCPPathRep (fromStream(str).c_str()))\n{\n#if 0\n    u_int32_t count = Bytecode::readInt32 (str);\n    if (str.good())\n    {\n\tYCPPathRep *p = new YCPPathRep ();\n\tfor (unsigned c = 0; c < count; c++)\n\t{\n\t    p->append (YCPPathRep::Component (str));\n\t}\n\tif (str.good())\n\t    element = p;\n    }\n#endif\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPath {\n  YCPPath::YCPPath (bytecodeistream & str)\n      : YCPValue (new YCPPathRep (fromStream(str).c_str()))\n  {\n  #if 0\n      u_int32_t count = Bytecode::readInt32 (str);\n      if (str.good())\n      {\n  \tYCPPathRep *p = new YCPPathRep ();\n  \tfor (unsigned c = 0; c < count; c++)\n  \t{\n  \t    p->append (YCPPathRep::Component (str));\n  \t}\n  \tif (str.good())\n  \t    element = p;\n      }\n  #endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPByteblock",
          "args": [
            "str"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "YCPByteblock",
          "container": "YCPByteblock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPByteblock.cc",
          "lines": "161-164",
          "snippet": "YCPByteblock::YCPByteblock (bytecodeistream & str)\n    : YCPValue (new YCPByteblockRep (str, fromStream (str)))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPByteblock.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPByteblock.h\"\n#include <ycp/y2log.h>\n\nYCPByteblock {\n  YCPByteblock::YCPByteblock (bytecodeistream & str)\n      : YCPValue (new YCPByteblockRep (str, fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "str"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "YCPString",
          "container": "YCPString",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "152-155",
          "snippet": "YCPString::YCPString (bytecodeistream & str)\n    : YCPValue (new YCPStringRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPString {\n  YCPString::YCPString (bytecodeistream & str)\n      : YCPValue (new YCPStringRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPFloat",
          "args": [
            "str"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "YCPFloat",
          "container": "YCPFloat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPFloat.cc",
          "lines": "119-122",
          "snippet": "YCPFloat::YCPFloat (bytecodeistream & str)\n    : YCPValue (new YCPFloatRep (fromStream (str).c_str()))\n{\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/y2log.h\"\n#include <ctype.h>\n\nYCPFloat {\n  YCPFloat::YCPFloat (bytecodeistream & str)\n      : YCPValue (new YCPFloatRep (fromStream (str).c_str()))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPInteger",
          "args": [
            "str"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "YCPInteger",
          "container": "YCPInteger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPInteger.cc",
          "lines": "142-145",
          "snippet": "YCPInteger::YCPInteger (bytecodeistream & str)\n    : YCPValue (new YCPIntegerRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/y2log.h\"\n\nYCPInteger {\n  YCPInteger::YCPInteger (bytecodeistream & str)\n      : YCPValue (new YCPIntegerRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "str"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [
            "str"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "77-80",
          "snippet": "YCPVoid::YCPVoid (bytecodeistream &)\n    : YCPValue ( *(nil ? nil : (nil = new YCPVoid(new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid (bytecodeistream &)\n      : YCPValue ( *(nil ? nil : (nil = new YCPVoid(new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.get",
          "args": [
            "vt"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  YCPValue\n  Bytecode::readValue (bytecodeistream & str)\n  {\n      char vt;\n      if (str.get (vt))\n      {\n  \tswitch (vt)\n  \t{\n  \t    case YT_VOID:\n  \t    {\n  \t\treturn YCPVoid (str);\n  \t    }\n  \t    break;\n  \t    case YT_BOOLEAN:\n  \t    {\n  \t\treturn YCPBoolean (str);\n  \t    }\n  \t    break;\n  \t    case YT_INTEGER:\n  \t    {\n  \t\treturn YCPInteger (str);\n  \t    }\n  \t    break;\n  \t    case YT_FLOAT:\n  \t    {\n  \t\treturn YCPFloat (str);\n  \t    }\n  \t    break;\n  \t    case YT_STRING:\n  \t    {\n  \t\treturn YCPString (str);\n  \t    }\n  \t    break;\n  \t    case YT_BYTEBLOCK:\n  \t    {\n  \t\treturn YCPByteblock (str);\n  \t    }\n  \t    break;\n  \t    case YT_PATH:\n  \t    {\n  \t\treturn YCPPath (str);\n  \t    }\n  \t    break;\n  \t    case YT_SYMBOL:\n  \t    {\n  \t\treturn YCPSymbol (str);\n  \t    }\n  \t    break;\n  \t    case YT_LIST:\n  \t    {\n  \t\treturn YCPList (str);\n  \t    }\n  \t    break;\n  \t    case YT_MAP:\n  \t    {\n  \t\treturn YCPMap (str);\n  \t    }\n  \t    break;\n  \t    case YT_TERM:\n  \t    {\n  \t\treturn YCPTerm (str);\n  \t    }\n  \t    break;\n  \t    case YT_CODE:\n  \t    {\n  \t\treturn YCPCode (str);\n  \t    }\n  \t    break;\n  \t    default:\n  \t    {\n  \t\ty2error (\"readValue stream code %d\", vt);\n  \t\tbreak;\n  \t    }\n  \t}\n      }\n      else\n      {\n  \ty2warning (\"readValue(%d:%s) NIL\", (int)vt, YCode::toString((YCode::ykind)vt).c_str());\n      }\n  \n      return YCPNull();\n  }\n}"
  },
  {
    "function_name": "readType",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "349-387",
    "snippet": "TypePtr\nBytecode::readType (bytecodeistream & str)\n{\n    int kind = readInt32 (str);\n#if DO_DEBUG\ny2debug (\"Bytecode::readType(%d)\", kind);\n#endif\n    switch ((Type::tkind)kind)\n    {\n\tcase Type::UnspecT:\n\tcase Type::ErrorT:\n\tcase Type::AnyT:\n\tcase Type::BooleanT:\n\tcase Type::ByteblockT:\n\tcase Type::FloatT:\n\tcase Type::IntegerT:\n\tcase Type::LocaleT:\n\tcase Type::PathT:\n\tcase Type::StringT:\n\tcase Type::SymbolT:\n\tcase Type::TermT:\n\tcase Type::VoidT:\n\tcase Type::WildcardT:\n\tcase Type::FlexT:\n\tcase Type::NilT:\n\t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n\tbreak;\n\n\tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n\tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n\tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n\tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n\tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n\tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n\tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n    }\n    y2error (\"Unhandled type kind %d\", kind);\n    return Type::Error->clone();\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Type::Error->clone",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "clone",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1842-1854",
          "snippet": "TypePtr\nFunctionType::clone () const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType (index));\n\t}\n    }\n    return tp;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  TypePtr\n  FunctionType::clone () const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType (index));\n  \t}\n      }\n      return tp;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Unhandled type kind %d\"",
            "kind"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new FunctionType (str)"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new TupleType (str)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new MapType (str)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new ListType (str)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new BlockType (str)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new VariableType (str)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new NFlexType (str)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TypePtr",
          "args": [
            "new Type ((Type::tkind)kind, str)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Bytecode::readType(%d)\"",
            "kind"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readInt32",
          "args": [
            "str"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  TypePtr\n  Bytecode::readType (bytecodeistream & str)\n  {\n      int kind = readInt32 (str);\n  #if DO_DEBUG\n  y2debug (\"Bytecode::readType(%d)\", kind);\n  #endif\n      switch ((Type::tkind)kind)\n      {\n  \tcase Type::UnspecT:\n  \tcase Type::ErrorT:\n  \tcase Type::AnyT:\n  \tcase Type::BooleanT:\n  \tcase Type::ByteblockT:\n  \tcase Type::FloatT:\n  \tcase Type::IntegerT:\n  \tcase Type::LocaleT:\n  \tcase Type::PathT:\n  \tcase Type::StringT:\n  \tcase Type::SymbolT:\n  \tcase Type::TermT:\n  \tcase Type::VoidT:\n  \tcase Type::WildcardT:\n  \tcase Type::FlexT:\n  \tcase Type::NilT:\n  \t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n  \tbreak;\n  \n  \tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n  \tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n  \tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n  \tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n  \tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n  \tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n  \tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n      }\n      y2error (\"Unhandled type kind %d\", kind);\n      return Type::Error->clone();\n  }\n}"
  },
  {
    "function_name": "readUstring",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "263-279",
    "snippet": "Ustring\nBytecode::readUstring (bytecodeistream & streamref)\n{\n    u_int32_t len = readInt32 (streamref);\n    Ustring ret = Ustring (*SymbolEntry::_nameHash, \"\");\n    if (len > 0)\n    {\n\tchar *buf = new char [len+1];\n\tif (streamref.read (buf, len))\n\t{\n\t    buf[len] = 0;\n\t    ret = Ustring (*SymbolEntry::_nameHash, buf);\n\t}\n\tdelete [] buf;\n    }\n    return ret;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Ustring",
          "args": [
            "*SymbolEntry::_nameHash",
            "buf"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "streamref.read",
          "args": [
            "buf",
            "len"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Ustring",
          "args": [
            "*SymbolEntry::_nameHash",
            "\"\""
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readInt32",
          "args": [
            "streamref"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  Ustring\n  Bytecode::readUstring (bytecodeistream & streamref)\n  {\n      u_int32_t len = readInt32 (streamref);\n      Ustring ret = Ustring (*SymbolEntry::_nameHash, \"\");\n      if (len > 0)\n      {\n  \tchar *buf = new char [len+1];\n  \tif (streamref.read (buf, len))\n  \t{\n  \t    buf[len] = 0;\n  \t    ret = Ustring (*SymbolEntry::_nameHash, buf);\n  \t}\n  \tdelete [] buf;\n      }\n      return ret;\n  }\n}"
  },
  {
    "function_name": "readString",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "229-247",
    "snippet": "bool\nBytecode::readString (bytecodeistream & streamref, string & stringref)\n{\n    bool ret = false;\n    stringref.erase();\n    u_int32_t len = readInt32 (streamref);\n    if (len > 0)\n    {\n\tchar *buf = new char [len+1];\n\tif (streamref.read (buf, len))\n\t{\n\t    buf[len] = 0;\n\t    stringref = string (buf);\n\t    ret = true;\n\t}\n\tdelete [] buf;\n    }\n    return ret;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "string",
          "args": [
            "buf"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "readUstring",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "263-279",
          "snippet": "Ustring\nBytecode::readUstring (bytecodeistream & streamref)\n{\n    u_int32_t len = readInt32 (streamref);\n    Ustring ret = Ustring (*SymbolEntry::_nameHash, \"\");\n    if (len > 0)\n    {\n\tchar *buf = new char [len+1];\n\tif (streamref.read (buf, len))\n\t{\n\t    buf[len] = 0;\n\t    ret = Ustring (*SymbolEntry::_nameHash, buf);\n\t}\n\tdelete [] buf;\n    }\n    return ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  Ustring\n  Bytecode::readUstring (bytecodeistream & streamref)\n  {\n      u_int32_t len = readInt32 (streamref);\n      Ustring ret = Ustring (*SymbolEntry::_nameHash, \"\");\n      if (len > 0)\n      {\n  \tchar *buf = new char [len+1];\n  \tif (streamref.read (buf, len))\n  \t{\n  \t    buf[len] = 0;\n  \t    ret = Ustring (*SymbolEntry::_nameHash, buf);\n  \t}\n  \tdelete [] buf;\n      }\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "streamref.read",
          "args": [
            "buf",
            "len"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readInt32",
          "args": [
            "streamref"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stringref.erase",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  bool\n  Bytecode::readString (bytecodeistream & streamref, string & stringref)\n  {\n      bool ret = false;\n      stringref.erase();\n      u_int32_t len = readInt32 (streamref);\n      if (len > 0)\n      {\n  \tchar *buf = new char [len+1];\n  \tif (streamref.read (buf, len))\n  \t{\n  \t    buf[len] = 0;\n  \t    stringref = string (buf);\n  \t    ret = true;\n  \t}\n  \tdelete [] buf;\n      }\n      return ret;\n  }\n}"
  },
  {
    "function_name": "readInt32",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "189-213",
    "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "str.read",
          "args": [
            "v",
            "5"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
  },
  {
    "function_name": "readBool",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "158-172",
    "snippet": "bool\nBytecode::readBool (bytecodeistream & str)\n{\n    char c;\n    str.get (c);\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n#endif\n\n    if (c != 0)\n    {\n\treturn true;\n    }\n    return false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "str.get",
          "args": [
            "c"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readBool (bytecodeistream & str)\n  {\n      char c;\n      str.get (c);\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n  #endif\n  \n      if (c != 0)\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "namespaceInit",
    "container": "Bytecode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "131-146",
    "snippet": "void\nBytecode::namespaceInit ()\n{\n#if DO_DEBUG\n    y2debug (\"Reinitialize namespaces\");\n#endif\n    if (Bytecode::m_namespace_nesting_array)\n    {\n\tfree (Bytecode::m_namespace_nesting_array);\n    }\n    \n    Bytecode::m_namespace_nesting_array = 0;\n    Bytecode::m_namespace_nesting_level = -1;\n    Bytecode::m_namespace_nesting_array_size = 0;\n    Bytecode::m_namespace_tare_level = 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [
      "int Bytecode::m_namespace_nesting_level = -1;",
      "int Bytecode::m_namespace_nesting_array_size = 0;",
      "int Bytecode::m_namespace_tare_level = 0;",
      "Bytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "Bytecode::m_namespace_nesting_array"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Reinitialize namespaces\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nint Bytecode::m_namespace_nesting_level = -1;\nint Bytecode::m_namespace_nesting_array_size = 0;\nint Bytecode::m_namespace_tare_level = 0;\nBytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;\n\nBytecode {\n  void\n  Bytecode::namespaceInit ()\n  {\n  #if DO_DEBUG\n      y2debug (\"Reinitialize namespaces\");\n  #endif\n      if (Bytecode::m_namespace_nesting_array)\n      {\n  \tfree (Bytecode::m_namespace_nesting_array);\n      }\n      \n      Bytecode::m_namespace_nesting_array = 0;\n      Bytecode::m_namespace_nesting_level = -1;\n      Bytecode::m_namespace_nesting_array_size = 0;\n      Bytecode::m_namespace_tare_level = 0;\n  }\n}"
  },
  {
    "function_name": "isVersionAtMost",
    "container": "bytecodeistream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "103-124",
    "snippet": "bool bytecodeistream::isVersionAtMost (int major, int minor, int release)\n{\n    if (m_major > major)\n    {\n\treturn false;\n    }\n    \n    if (m_major == major)\n    {\n\tif (m_minor > minor)\n\t{\n\t    return false;\n\t}\n\t\n\tif ( (m_minor == minor) && (m_release > release))\n\t{\n\t    return false;\n\t}\n    }\n\n    return true;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nbytecodeistream {\n  bool bytecodeistream::isVersionAtMost (int major, int minor, int release)\n  {\n      if (m_major > major)\n      {\n  \treturn false;\n      }\n      \n      if (m_major == major)\n      {\n  \tif (m_minor > minor)\n  \t{\n  \t    return false;\n  \t}\n  \t\n  \tif ( (m_minor == minor) && (m_release > release))\n  \t{\n  \t    return false;\n  \t}\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "isVersion",
    "container": "bytecodeistream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "96-101",
    "snippet": "bool bytecodeistream::isVersion (int major, int minor, int release)\n{\n    return (major == m_major) \n\t&& (minor == m_minor) \n\t&& (release == m_release);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nbytecodeistream {\n  bool bytecodeistream::isVersion (int major, int minor, int release)\n  {\n      return (major == m_major) \n  \t&& (minor == m_minor) \n  \t&& (release == m_release);\n  }\n}"
  },
  {
    "function_name": "bytecodeistream",
    "container": "bytecodeistream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "68-94",
    "snippet": "bytecodeistream::bytecodeistream (string filename)\n    : std::ifstream (filename.c_str ())\n    , m_major (-1)\n    , m_minor (-1)\n    , m_release (-1)\n{\n    if (!is_open ())\n    {\n\ty2error (\"Failed to open '%s': %s\", filename.c_str(), strerror (errno));\n\treturn;\n    }\n    // read YaST_BYTECODE_HEADER\n\n    char header[sizeof(YaST_BYTECODE_HEADER)+1];\n    int headerlen = strlen (YaST_BYTECODE_HEADER);\n    read (header, headerlen);\n    header[headerlen] = 0;\n    if (strcmp (header, YaST_BYTECODE_HEADER) != 0)\n    {\n\ty2error (\"Not a bytecode file '%s'[%s]\", filename.c_str(), header);\n\treturn;\n    }\n\n    m_major = readInt (*this);\n    m_minor = readInt (*this);\n    m_release = readInt (*this);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [
      "#define YaST_BYTECODE_HEADER \"YaST bytecode \""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readInt",
          "args": [
            "*this"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Not a bytecode file '%s'[%s]\"",
            "filename.c_str()",
            "header"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "header",
            "YaST_BYTECODE_HEADER"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "header",
            "headerlen"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "readYCodelist",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "540-578",
          "snippet": "bool\nBytecode::readYCodelist (bytecodeistream & str, ycodelist_t **anchor)\n{\n    u_int32_t count = readInt32 (str);\n\n#if DO_DEBUG\n    y2debug (\"Bytecode::readYCodelist %d entries\", count);\n#endif\n\n    ycodelist_t *last = 0;\n\n    while (count-- > 0)\n    {\n\tycodelist_t *element = new ycodelist_t;\n\n\telement->code = Bytecode::readCode (str);\n\telement->next = 0;\n\n\tif (element->code == 0)\n\t{\n\t    y2error (\"Bytecode::readYCodelist failed\");\n\t    delete element;\n\t    return false;\n\t}\n\n\tif (*anchor == 0)\t\t// anchor undefined\n\t{\n\t    *anchor = element;\n\t}\n\telse\n\t{\n\t    last->next = element;\n\t}\n\n\tlast = element;\n    }\n\n    return str.good();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readYCodelist (bytecodeistream & str, ycodelist_t **anchor)\n  {\n      u_int32_t count = readInt32 (str);\n  \n  #if DO_DEBUG\n      y2debug (\"Bytecode::readYCodelist %d entries\", count);\n  #endif\n  \n      ycodelist_t *last = 0;\n  \n      while (count-- > 0)\n      {\n  \tycodelist_t *element = new ycodelist_t;\n  \n  \telement->code = Bytecode::readCode (str);\n  \telement->next = 0;\n  \n  \tif (element->code == 0)\n  \t{\n  \t    y2error (\"Bytecode::readYCodelist failed\");\n  \t    delete element;\n  \t    return false;\n  \t}\n  \n  \tif (*anchor == 0)\t\t// anchor undefined\n  \t{\n  \t    *anchor = element;\n  \t}\n  \telse\n  \t{\n  \t    last->next = element;\n  \t}\n  \n  \tlast = element;\n      }\n  \n      return str.good();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "YaST_BYTECODE_HEADER"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Failed to open '%s': %s\"",
            "filename.c_str()",
            "strerror (errno)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_open",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define YaST_BYTECODE_HEADER \"YaST bytecode \"\n\nbytecodeistream {\n  bytecodeistream::bytecodeistream (string filename)\n      : std::ifstream (filename.c_str ())\n      , m_major (-1)\n      , m_minor (-1)\n      , m_release (-1)\n  {\n      if (!is_open ())\n      {\n  \ty2error (\"Failed to open '%s': %s\", filename.c_str(), strerror (errno));\n  \treturn;\n      }\n      // read YaST_BYTECODE_HEADER\n  \n      char header[sizeof(YaST_BYTECODE_HEADER)+1];\n      int headerlen = strlen (YaST_BYTECODE_HEADER);\n      read (header, headerlen);\n      header[headerlen] = 0;\n      if (strcmp (header, YaST_BYTECODE_HEADER) != 0)\n      {\n  \ty2error (\"Not a bytecode file '%s'[%s]\", filename.c_str(), header);\n  \treturn;\n      }\n  \n      m_major = readInt (*this);\n      m_minor = readInt (*this);\n      m_release = readInt (*this);\n  }\n}"
  },
  {
    "function_name": "readInt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
    "lines": "48-65",
    "snippet": "static int\nreadInt (bytecodeistream & str)\n{\n    int i = 0;\n\n    char c;\n\n    for (;;)\n    {\n\tstr.get (c);\n\tif (!isdigit (c))\n\t    break;\n\ti *= 10;\n\ti += (c - '0');\n    }\n\n    return i;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <fstream>",
      "#include \"ycp/pathsearch.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"y2/Y2Namespace.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCode.h\"",
      "#include \"YCP.h\"",
      "#include \"ycp/Bytecode.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "c"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str.get",
          "args": [
            "c"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nstatic int\nreadInt (bytecodeistream & str)\n{\n    int i = 0;\n\n    char c;\n\n    for (;;)\n    {\n\tstr.get (c);\n\tif (!isdigit (c))\n\t    break;\n\ti *= 10;\n\ti += (c - '0');\n    }\n\n    return i;\n}"
  }
]