[
  {
    "function_name": "MuDumpVal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/MemUsage.cc",
    "lines": "99-102",
    "snippet": "void MuDumpVal (const char *name)\n{\n    MemUsage::MuDumpVal (name);\n}",
    "includes": [
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <cstdio>",
      "#include <string>",
      "#include <map>",
      "#include <stdlib.h>",
      "#include \"y2util/MemUsage.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemUsage::MuDumpVal",
          "args": [
            "name"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "MuDumpVal",
          "container": "MemUsage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/MemUsage.cc",
          "lines": "79-92",
          "snippet": "void MemUsage::MuDumpVal (const char *aname)\n{\n    data::iterator\n\tii = m_mu_instances->begin (),\n\tie = m_mu_instances->end ();\n    for (; ii != ie; ++ii)\n    {\n\tstd::string dname = demangle (typeid (**ii).name ());\n\tif (dname == aname)\n\t{\n\t    fprintf (stderr, \"p *(%s *)%p\\n\", aname, *ii);\n\t}\n    }\n}",
          "includes": [
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <cstdio>",
            "#include <string>",
            "#include <map>",
            "#include <stdlib.h>",
            "#include \"y2util/MemUsage.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemUsage::data* MemUsage::m_mu_instances = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cxxabi.h>\n#include <typeinfo>\n#include <cstdio>\n#include <string>\n#include <map>\n#include <stdlib.h>\n#include \"y2util/MemUsage.h\"\n\nMemUsage::data* MemUsage::m_mu_instances = 0;\n\nMemUsage {\n  void MemUsage::MuDumpVal (const char *aname)\n  {\n      data::iterator\n  \tii = m_mu_instances->begin (),\n  \tie = m_mu_instances->end ();\n      for (; ii != ie; ++ii)\n      {\n  \tstd::string dname = demangle (typeid (**ii).name ());\n  \tif (dname == aname)\n  \t{\n  \t    fprintf (stderr, \"p *(%s *)%p\\n\", aname, *ii);\n  \t}\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cxxabi.h>\n#include <typeinfo>\n#include <cstdio>\n#include <string>\n#include <map>\n#include <stdlib.h>\n#include \"y2util/MemUsage.h\"\n\nvoid MuDumpVal (const char *name)\n{\n    MemUsage::MuDumpVal (name);\n}"
  },
  {
    "function_name": "MuDump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/MemUsage.cc",
    "lines": "94-97",
    "snippet": "void MuDump ()\n{\n    MemUsage::MuDump ();\n}",
    "includes": [
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <cstdio>",
      "#include <string>",
      "#include <map>",
      "#include <stdlib.h>",
      "#include \"y2util/MemUsage.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemUsage::MuDump",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "MuDump",
          "container": "MemUsage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/MemUsage.cc",
          "lines": "42-76",
          "snippet": "void MemUsage::MuDump ()\n{\n    fprintf (stderr, \"MemUsage dump:\\n\");\n    std::map <std::string, int> m_mu_count;\n    std::map <std::string, int> m_mu_size;\n    // determine the type of each instance. now it is possible\n    // because we are not in the constructor\n    data::iterator\n\tii = m_mu_instances->begin (),\n\tie = m_mu_instances->end ();\n    for (; ii != ie; ++ii)\n    {\n\tconst char * name = typeid (**ii).name ();\n\tstd::string dename = demangle (name);\n\tif (m_mu_size.find (dename) == m_mu_size.end())\n\t{\n\t    m_mu_size[dename] = (**ii).mem_size();\n\t}\n\t++ m_mu_count[dename];\n    }\n\n    std::map <std::string, int>::iterator\n\ti = m_mu_count.begin (),\n\te = m_mu_count.end ();\n    unsigned long sum = 0;\n    for (; i != e; ++i)\n    {\n\tint size = m_mu_size[i->first];\n\tunsigned long mem = i->second * size;\n\tsum += mem;\n\tfprintf (stderr, \"%9d <%5d> [%9lu] %s\\n\", i->second, size, mem, i->first.c_str ());\n    }\n    fprintf (stderr, \"%9lu Total bytes\\n\", sum);\n\n}",
          "includes": [
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <cstdio>",
            "#include <string>",
            "#include <map>",
            "#include <stdlib.h>",
            "#include \"y2util/MemUsage.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemUsage::data* MemUsage::m_mu_instances = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cxxabi.h>\n#include <typeinfo>\n#include <cstdio>\n#include <string>\n#include <map>\n#include <stdlib.h>\n#include \"y2util/MemUsage.h\"\n\nMemUsage::data* MemUsage::m_mu_instances = 0;\n\nMemUsage {\n  void MemUsage::MuDump ()\n  {\n      fprintf (stderr, \"MemUsage dump:\\n\");\n      std::map <std::string, int> m_mu_count;\n      std::map <std::string, int> m_mu_size;\n      // determine the type of each instance. now it is possible\n      // because we are not in the constructor\n      data::iterator\n  \tii = m_mu_instances->begin (),\n  \tie = m_mu_instances->end ();\n      for (; ii != ie; ++ii)\n      {\n  \tconst char * name = typeid (**ii).name ();\n  \tstd::string dename = demangle (name);\n  \tif (m_mu_size.find (dename) == m_mu_size.end())\n  \t{\n  \t    m_mu_size[dename] = (**ii).mem_size();\n  \t}\n  \t++ m_mu_count[dename];\n      }\n  \n      std::map <std::string, int>::iterator\n  \ti = m_mu_count.begin (),\n  \te = m_mu_count.end ();\n      unsigned long sum = 0;\n      for (; i != e; ++i)\n      {\n  \tint size = m_mu_size[i->first];\n  \tunsigned long mem = i->second * size;\n  \tsum += mem;\n  \tfprintf (stderr, \"%9d <%5d> [%9lu] %s\\n\", i->second, size, mem, i->first.c_str ());\n      }\n      fprintf (stderr, \"%9lu Total bytes\\n\", sum);\n  \n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cxxabi.h>\n#include <typeinfo>\n#include <cstdio>\n#include <string>\n#include <map>\n#include <stdlib.h>\n#include \"y2util/MemUsage.h\"\n\nvoid MuDump ()\n{\n    MemUsage::MuDump ();\n}"
  },
  {
    "function_name": "MuDumpVal",
    "container": "MemUsage",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/MemUsage.cc",
    "lines": "79-92",
    "snippet": "void MemUsage::MuDumpVal (const char *aname)\n{\n    data::iterator\n\tii = m_mu_instances->begin (),\n\tie = m_mu_instances->end ();\n    for (; ii != ie; ++ii)\n    {\n\tstd::string dname = demangle (typeid (**ii).name ());\n\tif (dname == aname)\n\t{\n\t    fprintf (stderr, \"p *(%s *)%p\\n\", aname, *ii);\n\t}\n    }\n}",
    "includes": [
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <cstdio>",
      "#include <string>",
      "#include <map>",
      "#include <stdlib.h>",
      "#include \"y2util/MemUsage.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "MemUsage::data* MemUsage::m_mu_instances = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"p *(%s *)%p\\n\"",
            "aname",
            "*ii"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "demangle",
          "args": [
            "typeid (**ii).name ()"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "demangle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/MemUsage.cc",
          "lines": "32-40",
          "snippet": "static std::string demangle (const char *sym)\n{\n    std::string ret;\n    int status;\n    char *dsym = abi::__cxa_demangle (sym, NULL, NULL, &status);\n    ret = status == 0? dsym: sym;\n    free (dsym);\n    return ret;\n}",
          "includes": [
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <cstdio>",
            "#include <string>",
            "#include <map>",
            "#include <stdlib.h>",
            "#include \"y2util/MemUsage.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cxxabi.h>\n#include <typeinfo>\n#include <cstdio>\n#include <string>\n#include <map>\n#include <stdlib.h>\n#include \"y2util/MemUsage.h\"\n\nstatic std::string demangle (const char *sym)\n{\n    std::string ret;\n    int status;\n    char *dsym = abi::__cxa_demangle (sym, NULL, NULL, &status);\n    ret = status == 0? dsym: sym;\n    free (dsym);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "typeid",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeid",
          "args": [
            "**ii"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_mu_instances->end",
          "args": [],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_mu_instances->begin",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cxxabi.h>\n#include <typeinfo>\n#include <cstdio>\n#include <string>\n#include <map>\n#include <stdlib.h>\n#include \"y2util/MemUsage.h\"\n\nMemUsage::data* MemUsage::m_mu_instances = 0;\n\nMemUsage {\n  void MemUsage::MuDumpVal (const char *aname)\n  {\n      data::iterator\n  \tii = m_mu_instances->begin (),\n  \tie = m_mu_instances->end ();\n      for (; ii != ie; ++ii)\n      {\n  \tstd::string dname = demangle (typeid (**ii).name ());\n  \tif (dname == aname)\n  \t{\n  \t    fprintf (stderr, \"p *(%s *)%p\\n\", aname, *ii);\n  \t}\n      }\n  }\n}"
  },
  {
    "function_name": "MuDump",
    "container": "MemUsage",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/MemUsage.cc",
    "lines": "42-76",
    "snippet": "void MemUsage::MuDump ()\n{\n    fprintf (stderr, \"MemUsage dump:\\n\");\n    std::map <std::string, int> m_mu_count;\n    std::map <std::string, int> m_mu_size;\n    // determine the type of each instance. now it is possible\n    // because we are not in the constructor\n    data::iterator\n\tii = m_mu_instances->begin (),\n\tie = m_mu_instances->end ();\n    for (; ii != ie; ++ii)\n    {\n\tconst char * name = typeid (**ii).name ();\n\tstd::string dename = demangle (name);\n\tif (m_mu_size.find (dename) == m_mu_size.end())\n\t{\n\t    m_mu_size[dename] = (**ii).mem_size();\n\t}\n\t++ m_mu_count[dename];\n    }\n\n    std::map <std::string, int>::iterator\n\ti = m_mu_count.begin (),\n\te = m_mu_count.end ();\n    unsigned long sum = 0;\n    for (; i != e; ++i)\n    {\n\tint size = m_mu_size[i->first];\n\tunsigned long mem = i->second * size;\n\tsum += mem;\n\tfprintf (stderr, \"%9d <%5d> [%9lu] %s\\n\", i->second, size, mem, i->first.c_str ());\n    }\n    fprintf (stderr, \"%9lu Total bytes\\n\", sum);\n\n}",
    "includes": [
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <cstdio>",
      "#include <string>",
      "#include <map>",
      "#include <stdlib.h>",
      "#include \"y2util/MemUsage.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "MemUsage::data* MemUsage::m_mu_instances = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%9lu Total bytes\\n\"",
            "sum"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%9d <%5d> [%9lu] %s\\n\"",
            "i->second",
            "size",
            "mem",
            "i->first.c_str ()"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->first.c_str",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_mu_count.end",
          "args": [],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_mu_count.begin",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_mu_size.find",
          "args": [
            "dename"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "demangle",
          "args": [
            "name"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "demangle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/MemUsage.cc",
          "lines": "32-40",
          "snippet": "static std::string demangle (const char *sym)\n{\n    std::string ret;\n    int status;\n    char *dsym = abi::__cxa_demangle (sym, NULL, NULL, &status);\n    ret = status == 0? dsym: sym;\n    free (dsym);\n    return ret;\n}",
          "includes": [
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <cstdio>",
            "#include <string>",
            "#include <map>",
            "#include <stdlib.h>",
            "#include \"y2util/MemUsage.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cxxabi.h>\n#include <typeinfo>\n#include <cstdio>\n#include <string>\n#include <map>\n#include <stdlib.h>\n#include \"y2util/MemUsage.h\"\n\nstatic std::string demangle (const char *sym)\n{\n    std::string ret;\n    int status;\n    char *dsym = abi::__cxa_demangle (sym, NULL, NULL, &status);\n    ret = status == 0? dsym: sym;\n    free (dsym);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "typeid",
          "args": [],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeid",
          "args": [
            "**ii"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"MemUsage dump:\\n\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cxxabi.h>\n#include <typeinfo>\n#include <cstdio>\n#include <string>\n#include <map>\n#include <stdlib.h>\n#include \"y2util/MemUsage.h\"\n\nMemUsage::data* MemUsage::m_mu_instances = 0;\n\nMemUsage {\n  void MemUsage::MuDump ()\n  {\n      fprintf (stderr, \"MemUsage dump:\\n\");\n      std::map <std::string, int> m_mu_count;\n      std::map <std::string, int> m_mu_size;\n      // determine the type of each instance. now it is possible\n      // because we are not in the constructor\n      data::iterator\n  \tii = m_mu_instances->begin (),\n  \tie = m_mu_instances->end ();\n      for (; ii != ie; ++ii)\n      {\n  \tconst char * name = typeid (**ii).name ();\n  \tstd::string dename = demangle (name);\n  \tif (m_mu_size.find (dename) == m_mu_size.end())\n  \t{\n  \t    m_mu_size[dename] = (**ii).mem_size();\n  \t}\n  \t++ m_mu_count[dename];\n      }\n  \n      std::map <std::string, int>::iterator\n  \ti = m_mu_count.begin (),\n  \te = m_mu_count.end ();\n      unsigned long sum = 0;\n      for (; i != e; ++i)\n      {\n  \tint size = m_mu_size[i->first];\n  \tunsigned long mem = i->second * size;\n  \tsum += mem;\n  \tfprintf (stderr, \"%9d <%5d> [%9lu] %s\\n\", i->second, size, mem, i->first.c_str ());\n      }\n      fprintf (stderr, \"%9lu Total bytes\\n\", sum);\n  \n  }\n}"
  },
  {
    "function_name": "demangle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/MemUsage.cc",
    "lines": "32-40",
    "snippet": "static std::string demangle (const char *sym)\n{\n    std::string ret;\n    int status;\n    char *dsym = abi::__cxa_demangle (sym, NULL, NULL, &status);\n    ret = status == 0? dsym: sym;\n    free (dsym);\n    return ret;\n}",
    "includes": [
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <cstdio>",
      "#include <string>",
      "#include <map>",
      "#include <stdlib.h>",
      "#include \"y2util/MemUsage.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dsym"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abi::__cxa_demangle",
          "args": [
            "sym",
            "NULL",
            "NULL",
            "&status"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cxxabi.h>\n#include <typeinfo>\n#include <cstdio>\n#include <string>\n#include <map>\n#include <stdlib.h>\n#include \"y2util/MemUsage.h\"\n\nstatic std::string demangle (const char *sym)\n{\n    std::string ret;\n    int status;\n    char *dsym = abi::__cxa_demangle (sym, NULL, NULL, &status);\n    ret = status == 0? dsym: sym;\n    free (dsym);\n    return ret;\n}"
  }
]