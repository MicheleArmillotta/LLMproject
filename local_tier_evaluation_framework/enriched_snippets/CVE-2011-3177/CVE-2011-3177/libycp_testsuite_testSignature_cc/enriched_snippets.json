[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/testSignature.cc",
    "lines": "47-108",
    "snippet": "int\nmain ()\n{\n#if 1\n    fromSig (\"any\", Type::Any, \"\");\t\t\t// any\n    fromSig (\"boolean\", Type::Boolean, \"\");\t\t// boolean\n    fromSig (\"byteblock\", Type::Byteblock, \"\");\t// byteblock\n    fromSig (\"float\", Type::Float, \"\");\t\t// float\n    fromSig (\"integer\", Type::Integer, \"\");\t\t// integer\n    fromSig (\"locale\", Type::Locale,\"\");\t\t// locale\n    fromSig (\"path\", Type::Path, \"\");\t\t// path\n    fromSig (\"string\", Type::String, \"\");\t\t// string\n    fromSig (\"symbol\", Type::Symbol, \"\");\t\t// symbol\n    fromSig (\"term\", Type::Term, \"\");\t\t// term\n    fromSig (\"void\", Type::Void, \"\");\t\t// void\n\n    fromSig (\"const integer\", Type::Unspec, \"const integer\");\n    fromSig (\"integer &\", Type::Unspec, \"integer &\");\n    fromSig (\"variable <integer >\", Type::Unspec, \"variable <integer>\");\n\n    fromSig (\"const integer &\", Type::Unspec, \"const integer &\");\n    fromSig (\"const integer &\", Type::Unspec, \"const integer &\");\n\n    fromSig (\"block <integer >\", Type::Unspec, \"block <integer>\");\n    fromSig (\"list <string >\", Type::Unspec, \"list <string>\");\n    fromSig (\"map <symbol, float >\", Type::Unspec, \"map <symbol, float>\");\n\n    fromSig (\"tuple <path, byteblock, term >\", Type::Unspec, \"tuple <path, byteblock, term>\");\n#endif\n\n    fromSig (\"list <list <integer >>\", Type::Unspec, \"list <list <integer>>\");\n#if 1\n    fromSig (\"block <list <integer >>\", Type::Unspec, \"block <list <integer>>\");\n    fromSig (\"list <block <integer >>\", Type::Unspec, \"list <block <integer>>\");\n\n    fromSig (\"integer ()\", Type::Unspec, \"integer ()\");\n\n    fromSig (\"integer (boolean )\", Type::Unspec, \"integer (boolean)\");\n    fromSig (\"integer (float, string )\", Type::Unspec, \"integer (float, string)\");\n\n    fromSig (\"integer & (float, string )\", Type::Unspec, \"integer & (float, string)\");\n\n    fromSig (\"integer (float &, string )\", Type::Unspec, \"integer (float &, string)\");\n    fromSig (\"integer (float, string &)\", Type::Unspec, \"integer (float, string &)\");\n\n    fromSig (\"integer (block <list <integer >>)\", Type::Unspec, \"integer (block <list <integer>>)\");\n    fromSig (\"list <integer >(list <integer >)\", Type::Unspec, \"list <integer> (list <integer>)\");\n\n    fromSig (\"const block <integer (float )> &\", Type::Unspec, \"const block <integer (float)> &\");\n\n    fromSig (\"boolean (list <flex> , flex)\", Type::Unspec, \"boolean (list <<flex>>, <flex>)\");\n    fromSig (\"list <flex> (variable <flex>, list <flex>, block <boolean >)\", Type::Unspec, \"list <<flex>> (variable <<flex>>, list <<flex>>, block <boolean>)\");\n    fromSig (\"list <flex> (list <flex >)\", Type::Unspec, \"list <<flex>> (list <<flex>>)\");\n    fromSig (\"void (string,  ...)\", Type::Unspec, \"void (string, ...)\");\n    fromSig (\"list <flex> (list <list <flex>>)\", Type::Unspec, \"list <<flex>> (list <list <<flex>>>)\");\n#endif\n    // list <list <string> > BLAH (map <string, string>)\n    // The return type is constructed, so \"(\" can't be used\n\n    // Even worse, a function returning a function pointer\n    // integer (string) BLAH (boolean)\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fromSig",
          "args": [
            "\"list <flex> (list <list <flex>>)\"",
            "Type::Unspec",
            "\"list <<flex>> (list <list <<flex>>>)\""
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "fromSig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/testSignature.cc",
          "lines": "20-44",
          "snippet": "void\nfromSig (const char *s, constTypePtr t, string ts)\n{\n    constTypePtr i = Type::fromSignature (s);\n\n    if (ts.empty()) ts = t->toString();\n\n    if (i == 0)\n    {\n\tfprintf (stderr, \"Failed (\\\"%s\\\" != \\\"%s\\\")\\n\", s, ts.c_str()); fflush (stderr);\n\treturn;\n    }\n\n    string is = i->toString();\n    if (is != ts)\n    {\n\tprintf (\"Expect: \\\"%s\\\" -> '%s'\\n\", s, ts.c_str());\n\tprintf (\"Got   : \\\"%s\\\" -> '%s'\\n\", s, is.c_str());\n    }\n    else\n    {\n\tprintf (\"Ok: %s\\n\", is.c_str());\n    }\n    return;\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nvoid\nfromSig (const char *s, constTypePtr t, string ts)\n{\n    constTypePtr i = Type::fromSignature (s);\n\n    if (ts.empty()) ts = t->toString();\n\n    if (i == 0)\n    {\n\tfprintf (stderr, \"Failed (\\\"%s\\\" != \\\"%s\\\")\\n\", s, ts.c_str()); fflush (stderr);\n\treturn;\n    }\n\n    string is = i->toString();\n    if (is != ts)\n    {\n\tprintf (\"Expect: \\\"%s\\\" -> '%s'\\n\", s, ts.c_str());\n\tprintf (\"Got   : \\\"%s\\\" -> '%s'\\n\", s, is.c_str());\n    }\n    else\n    {\n\tprintf (\"Ok: %s\\n\", is.c_str());\n    }\n    return;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nint\nmain ()\n{\n#if 1\n    fromSig (\"any\", Type::Any, \"\");\t\t\t// any\n    fromSig (\"boolean\", Type::Boolean, \"\");\t\t// boolean\n    fromSig (\"byteblock\", Type::Byteblock, \"\");\t// byteblock\n    fromSig (\"float\", Type::Float, \"\");\t\t// float\n    fromSig (\"integer\", Type::Integer, \"\");\t\t// integer\n    fromSig (\"locale\", Type::Locale,\"\");\t\t// locale\n    fromSig (\"path\", Type::Path, \"\");\t\t// path\n    fromSig (\"string\", Type::String, \"\");\t\t// string\n    fromSig (\"symbol\", Type::Symbol, \"\");\t\t// symbol\n    fromSig (\"term\", Type::Term, \"\");\t\t// term\n    fromSig (\"void\", Type::Void, \"\");\t\t// void\n\n    fromSig (\"const integer\", Type::Unspec, \"const integer\");\n    fromSig (\"integer &\", Type::Unspec, \"integer &\");\n    fromSig (\"variable <integer >\", Type::Unspec, \"variable <integer>\");\n\n    fromSig (\"const integer &\", Type::Unspec, \"const integer &\");\n    fromSig (\"const integer &\", Type::Unspec, \"const integer &\");\n\n    fromSig (\"block <integer >\", Type::Unspec, \"block <integer>\");\n    fromSig (\"list <string >\", Type::Unspec, \"list <string>\");\n    fromSig (\"map <symbol, float >\", Type::Unspec, \"map <symbol, float>\");\n\n    fromSig (\"tuple <path, byteblock, term >\", Type::Unspec, \"tuple <path, byteblock, term>\");\n#endif\n\n    fromSig (\"list <list <integer >>\", Type::Unspec, \"list <list <integer>>\");\n#if 1\n    fromSig (\"block <list <integer >>\", Type::Unspec, \"block <list <integer>>\");\n    fromSig (\"list <block <integer >>\", Type::Unspec, \"list <block <integer>>\");\n\n    fromSig (\"integer ()\", Type::Unspec, \"integer ()\");\n\n    fromSig (\"integer (boolean )\", Type::Unspec, \"integer (boolean)\");\n    fromSig (\"integer (float, string )\", Type::Unspec, \"integer (float, string)\");\n\n    fromSig (\"integer & (float, string )\", Type::Unspec, \"integer & (float, string)\");\n\n    fromSig (\"integer (float &, string )\", Type::Unspec, \"integer (float &, string)\");\n    fromSig (\"integer (float, string &)\", Type::Unspec, \"integer (float, string &)\");\n\n    fromSig (\"integer (block <list <integer >>)\", Type::Unspec, \"integer (block <list <integer>>)\");\n    fromSig (\"list <integer >(list <integer >)\", Type::Unspec, \"list <integer> (list <integer>)\");\n\n    fromSig (\"const block <integer (float )> &\", Type::Unspec, \"const block <integer (float)> &\");\n\n    fromSig (\"boolean (list <flex> , flex)\", Type::Unspec, \"boolean (list <<flex>>, <flex>)\");\n    fromSig (\"list <flex> (variable <flex>, list <flex>, block <boolean >)\", Type::Unspec, \"list <<flex>> (variable <<flex>>, list <<flex>>, block <boolean>)\");\n    fromSig (\"list <flex> (list <flex >)\", Type::Unspec, \"list <<flex>> (list <<flex>>)\");\n    fromSig (\"void (string,  ...)\", Type::Unspec, \"void (string, ...)\");\n    fromSig (\"list <flex> (list <list <flex>>)\", Type::Unspec, \"list <<flex>> (list <list <<flex>>>)\");\n#endif\n    // list <list <string> > BLAH (map <string, string>)\n    // The return type is constructed, so \"(\" can't be used\n\n    // Even worse, a function returning a function pointer\n    // integer (string) BLAH (boolean)\n}"
  },
  {
    "function_name": "fromSig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/testsuite/testSignature.cc",
    "lines": "20-44",
    "snippet": "void\nfromSig (const char *s, constTypePtr t, string ts)\n{\n    constTypePtr i = Type::fromSignature (s);\n\n    if (ts.empty()) ts = t->toString();\n\n    if (i == 0)\n    {\n\tfprintf (stderr, \"Failed (\\\"%s\\\" != \\\"%s\\\")\\n\", s, ts.c_str()); fflush (stderr);\n\treturn;\n    }\n\n    string is = i->toString();\n    if (is != ts)\n    {\n\tprintf (\"Expect: \\\"%s\\\" -> '%s'\\n\", s, ts.c_str());\n\tprintf (\"Got   : \\\"%s\\\" -> '%s'\\n\", s, is.c_str());\n    }\n    else\n    {\n\tprintf (\"Ok: %s\\n\", is.c_str());\n    }\n    return;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/Type.h\"",
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"ycp/y2log.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Ok: %s\\n\"",
            "is.c_str()"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is.c_str",
          "args": [],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Got   : \\\"%s\\\" -> '%s'\\n\"",
            "s",
            "is.c_str()"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is.c_str",
          "args": [],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Expect: \\\"%s\\\" -> '%s'\\n\"",
            "s",
            "ts.c_str()"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ts.c_str",
          "args": [],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->toString",
          "args": [],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed (\\\"%s\\\" != \\\"%s\\\")\\n\"",
            "s",
            "ts.c_str()"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ts.c_str",
          "args": [],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ts.empty",
          "args": [],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Type::fromSignature",
          "args": [
            "s"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "fromSignature",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/TypeStatics.cc",
          "lines": "280-512",
          "snippet": "constTypePtr\nType::fromSignature (const char ** signature)\n{\n    if ((signature == 0)\n\t|| (*signature == 0))\n    {\n\treturn 0;\n    }\n    if (**signature == 0)\n    {\n\treturn Type::Unspec;\n    }\n\n    constTypePtr t = 0;\n\n    bool as_const = false;\n\n    const char *signature_copy = *signature;\n    const char *signature_start = *signature;\n\n//    y2debug (\"Type::fromSignature (\\\"%s\\\")\\n\", *signature);\n\n    int k = nextToken (signature);\n\n    if (k == -1)\t\t// const\n    {\n//\ty2debug (\"Const !\");\n\tas_const = true;\n\tsignature_copy = *signature;\n\tk = nextToken (signature);\n    }\n\n    char next = 0;\n\n    switch (k)\n    {\n\tcase AnyT:\t\tt = (as_const) ? Type::ConstAny : Type::Any; break;\n\tcase BooleanT:\t\tt = (as_const) ? Type::ConstBoolean : Type::Boolean; break;\n\tcase ByteblockT:\tt = (as_const) ? Type::ConstByteblock : Type::Byteblock; break;\n\tcase ErrorT:\t\tt = Type::Error; break;\n\tcase FlexT:\t\tt = (as_const) ? Type::ConstFlex : Type::Flex; break;\n\tcase FloatT:\t\tt = (as_const) ? Type::ConstFloat : Type::Float; break;\n\tcase IntegerT:\t\tt = (as_const) ? Type::ConstInteger : Type::Integer; break;\n\tcase LocaleT:\t\tt = (as_const) ? Type::ConstLocale : Type::Locale; break;\n\tcase PathT:\t\tt = (as_const) ? Type::ConstPath : Type::Path; break;\n\tcase StringT:\t\tt = (as_const) ? Type::ConstString : Type::String; break;\n\tcase SymbolT:\t\tt = (as_const) ? Type::ConstSymbol : Type::Symbol; break;\n\tcase TermT:\t\tt = (as_const) ? Type::ConstTerm : Type::Term; break;\n\tcase VoidT:\t\tt = (as_const) ? Type::ConstVoid : Type::Void; break;\n\tcase WildcardT:\t\tt = Type::Wildcard; break;\n\n\t// codes\n\tcase VariableT:\t\tk = VariableT; next = '<'; break;\n\tcase '(':\t\tk = FunctionT; break;\n\n\t// constructors\n\tcase BlockT:\t\tk = BlockT; next = '<'; break;\n\tcase ListT:\t\tk = ListT; next = '<'; break;\n\tcase MapT:\t\tk = MapT; next = '<'; break;\n\tcase TupleT:\t\tk = TupleT; next = '<'; break;\n\tdefault:\n\t    if (k < -100)\n\t    {\n\t\tswitch (k)\n\t\t{\n\t\t    case -101:\tt = (as_const) ? Type::ConstNFlex1 : Type::NFlex1; break;\n\t\t    case -102:\tt = (as_const) ? Type::ConstNFlex2 : Type::NFlex2; break;\n\t\t    case -103:\tt = (as_const) ? Type::ConstNFlex3 : Type::NFlex3; break;\n\t\t    case -104:\tt = (as_const) ? Type::ConstNFlex4 : Type::NFlex4; break;\n\t\t    default:\tt = NFlexTypePtr (new NFlexType (-(k+100))); break;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ty2error (\"Builtin signature code %d [%s] not handled\\n\", **signature, signature_start);\n\t    }\n\tbreak;\n    }\n\n    signature_copy = *signature;\n\n    if (next != 0)\n    {\n\tif (nextToken (signature) != next)\n\t{\n\t    y2error (\"Expecting '%c' at '%s' [Complete signature is '%s']\\n\", next, signature_copy, signature_start);\n\t    return 0;\n\t}\n    }\n\n    if (t == 0)\t\t\t// no base type yet\n    {\n//\ty2debug (\"k %d, signature '%s'\", k, *signature);\n\tif (k == UnspecT)\t// no nothing\n\t{\n\t    y2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n\t    return 0;\n\t}\n\n\tsignature_copy = *signature;\n\tconstTypePtr t1 = fromSignature (signature);\n\n\tif (t1 == 0)\n\t{\n\t    y2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n\t    return 0;\n\t}\n//\ty2debug (\"t1 '%s', k %d, signature '%s'\", t1->toString().c_str(), k, *signature);\n\n\tswitch (k)\n\t{\n\t    case VariableT: t = VariableTypePtr (new VariableType (t1, as_const)); next = '>'; break;\n\t    case BlockT:    t = BlockTypePtr (new BlockType (t1, as_const)); next = '>'; break;\n\t    case ListT:\t    t = ListTypePtr (new ListType (t1, as_const)); next = '>'; break;\n\t    case MapT:\n\t    {\n\t\tsignature_copy = *signature;\n\n\t\tif (nextToken (signature) != ',')\n\t\t{\n\t\t    y2error (\"Expected ',' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n\t\t    return 0;\n\t\t}\n\n\t\tconstTypePtr t2 = fromSignature (signature);\n\t\tif (t2 == 0)\n\t\t{\n\t\t    y2debug (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n\t\t    return 0;\n\t\t}\n\n\t\tt = MapTypePtr (new MapType (t1, t2, as_const));\n\t\tnext = '>'; \n\t    }\n\t    break;\n\t    case TupleT:    t = TupleTypePtr (new TupleType (t1, as_const)); next = 0; break;\n\t    case FunctionT: t = FunctionTypePtr (new FunctionType (t1, as_const)); next = 0; break;\n\t    default:\n\t\ty2error (\"Post-Kind '%d'[%c] not handled\\n\", k, isprint (k) ? k : '?');\n\t\treturn 0;\n\t    break;\n\t}\n\n\tif (next != 0)\n\t{\n\t    if (nextToken (signature) != next)\n\t    {\n\t\ty2error (\"Expected '%c' at '%s' [Complete signature is '%s']\\n\", next, signature_copy, signature_start);\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n    if (t == 0)\n    {\n\treturn 0;\n    }\n\n//    y2debug (\"t '%s', signature '%s', k %d\", t->toString().c_str(), *signature, k);\n\n    signature_copy = *signature;\n    if (**signature == '&')\n    {\n\tTypePtr tr = t->clone();\n\ttr->asReference();\n\tt = tr;\n\tdo { (*signature)++; } while (isspace (**signature));\n    }\n\n    // check for function, it's postfix !\n\n    if (**signature == '(')\n    {\n//\ty2debug (\"function!\");\n\tFunctionTypePtr f (new FunctionType (t, as_const));\n\n\tdo\n\t{\n\t    do { (*signature)++; } while (isspace (**signature));\n\t    if (**signature == ')')\n\t    {\n\t\tbreak;\n\t    }\n\t    signature_copy = *signature;\n\t    constTypePtr t1 = fromSignature (signature);\n\t    if (t1 == 0)\n\t    {\n\t\t*signature = signature_copy;\n\t\tbreak;\n\t    }\n\n\t    f->concat (t1);\n\t}\n\twhile (**signature == ',');\n\n\tif (**signature != ')')\n\t{\n\t    y2error (\"Expected ')' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n\t    return 0;\n\t}\n\n\t(*signature)++;\n\tt = f;\n    }\n    else if (k == TupleT)\n    {\n\tTupleTypePtr tt = t->clone();\n//\ty2debug (\"tuple! '%s', signature '%s'\", tt->toString().c_str(), *signature);\n\twhile (**signature == ',')\n\t{\n\t    (*signature)++;\n\t    signature_copy = *signature;\n\t    constTypePtr t1 = fromSignature (signature);\n\t    if (t1 == 0)\n\t    {\n\t\ty2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n\t\treturn 0;\n\t    }\n\n\t    tt->concat (t1);\n\t}\n\tif (**signature != '>')\n\t{\n\t    y2error (\"Expected '>' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n\t    return 0;\n\t}\n\tt = tt;\n    }\n\n//    y2debug (\"Type::fromSignature Done: '%s' -> '%s' [%s]\\n\", signature_start, t->toString().c_str(), *signature);\n\n    return t;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  constTypePtr\n  Type::fromSignature (const char ** signature)\n  {\n      if ((signature == 0)\n  \t|| (*signature == 0))\n      {\n  \treturn 0;\n      }\n      if (**signature == 0)\n      {\n  \treturn Type::Unspec;\n      }\n  \n      constTypePtr t = 0;\n  \n      bool as_const = false;\n  \n      const char *signature_copy = *signature;\n      const char *signature_start = *signature;\n  \n  //    y2debug (\"Type::fromSignature (\\\"%s\\\")\\n\", *signature);\n  \n      int k = nextToken (signature);\n  \n      if (k == -1)\t\t// const\n      {\n  //\ty2debug (\"Const !\");\n  \tas_const = true;\n  \tsignature_copy = *signature;\n  \tk = nextToken (signature);\n      }\n  \n      char next = 0;\n  \n      switch (k)\n      {\n  \tcase AnyT:\t\tt = (as_const) ? Type::ConstAny : Type::Any; break;\n  \tcase BooleanT:\t\tt = (as_const) ? Type::ConstBoolean : Type::Boolean; break;\n  \tcase ByteblockT:\tt = (as_const) ? Type::ConstByteblock : Type::Byteblock; break;\n  \tcase ErrorT:\t\tt = Type::Error; break;\n  \tcase FlexT:\t\tt = (as_const) ? Type::ConstFlex : Type::Flex; break;\n  \tcase FloatT:\t\tt = (as_const) ? Type::ConstFloat : Type::Float; break;\n  \tcase IntegerT:\t\tt = (as_const) ? Type::ConstInteger : Type::Integer; break;\n  \tcase LocaleT:\t\tt = (as_const) ? Type::ConstLocale : Type::Locale; break;\n  \tcase PathT:\t\tt = (as_const) ? Type::ConstPath : Type::Path; break;\n  \tcase StringT:\t\tt = (as_const) ? Type::ConstString : Type::String; break;\n  \tcase SymbolT:\t\tt = (as_const) ? Type::ConstSymbol : Type::Symbol; break;\n  \tcase TermT:\t\tt = (as_const) ? Type::ConstTerm : Type::Term; break;\n  \tcase VoidT:\t\tt = (as_const) ? Type::ConstVoid : Type::Void; break;\n  \tcase WildcardT:\t\tt = Type::Wildcard; break;\n  \n  \t// codes\n  \tcase VariableT:\t\tk = VariableT; next = '<'; break;\n  \tcase '(':\t\tk = FunctionT; break;\n  \n  \t// constructors\n  \tcase BlockT:\t\tk = BlockT; next = '<'; break;\n  \tcase ListT:\t\tk = ListT; next = '<'; break;\n  \tcase MapT:\t\tk = MapT; next = '<'; break;\n  \tcase TupleT:\t\tk = TupleT; next = '<'; break;\n  \tdefault:\n  \t    if (k < -100)\n  \t    {\n  \t\tswitch (k)\n  \t\t{\n  \t\t    case -101:\tt = (as_const) ? Type::ConstNFlex1 : Type::NFlex1; break;\n  \t\t    case -102:\tt = (as_const) ? Type::ConstNFlex2 : Type::NFlex2; break;\n  \t\t    case -103:\tt = (as_const) ? Type::ConstNFlex3 : Type::NFlex3; break;\n  \t\t    case -104:\tt = (as_const) ? Type::ConstNFlex4 : Type::NFlex4; break;\n  \t\t    default:\tt = NFlexTypePtr (new NFlexType (-(k+100))); break;\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\ty2error (\"Builtin signature code %d [%s] not handled\\n\", **signature, signature_start);\n  \t    }\n  \tbreak;\n      }\n  \n      signature_copy = *signature;\n  \n      if (next != 0)\n      {\n  \tif (nextToken (signature) != next)\n  \t{\n  \t    y2error (\"Expecting '%c' at '%s' [Complete signature is '%s']\\n\", next, signature_copy, signature_start);\n  \t    return 0;\n  \t}\n      }\n  \n      if (t == 0)\t\t\t// no base type yet\n      {\n  //\ty2debug (\"k %d, signature '%s'\", k, *signature);\n  \tif (k == UnspecT)\t// no nothing\n  \t{\n  \t    y2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n  \t    return 0;\n  \t}\n  \n  \tsignature_copy = *signature;\n  \tconstTypePtr t1 = fromSignature (signature);\n  \n  \tif (t1 == 0)\n  \t{\n  \t    y2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n  \t    return 0;\n  \t}\n  //\ty2debug (\"t1 '%s', k %d, signature '%s'\", t1->toString().c_str(), k, *signature);\n  \n  \tswitch (k)\n  \t{\n  \t    case VariableT: t = VariableTypePtr (new VariableType (t1, as_const)); next = '>'; break;\n  \t    case BlockT:    t = BlockTypePtr (new BlockType (t1, as_const)); next = '>'; break;\n  \t    case ListT:\t    t = ListTypePtr (new ListType (t1, as_const)); next = '>'; break;\n  \t    case MapT:\n  \t    {\n  \t\tsignature_copy = *signature;\n  \n  \t\tif (nextToken (signature) != ',')\n  \t\t{\n  \t\t    y2error (\"Expected ',' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n  \t\t    return 0;\n  \t\t}\n  \n  \t\tconstTypePtr t2 = fromSignature (signature);\n  \t\tif (t2 == 0)\n  \t\t{\n  \t\t    y2debug (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n  \t\t    return 0;\n  \t\t}\n  \n  \t\tt = MapTypePtr (new MapType (t1, t2, as_const));\n  \t\tnext = '>'; \n  \t    }\n  \t    break;\n  \t    case TupleT:    t = TupleTypePtr (new TupleType (t1, as_const)); next = 0; break;\n  \t    case FunctionT: t = FunctionTypePtr (new FunctionType (t1, as_const)); next = 0; break;\n  \t    default:\n  \t\ty2error (\"Post-Kind '%d'[%c] not handled\\n\", k, isprint (k) ? k : '?');\n  \t\treturn 0;\n  \t    break;\n  \t}\n  \n  \tif (next != 0)\n  \t{\n  \t    if (nextToken (signature) != next)\n  \t    {\n  \t\ty2error (\"Expected '%c' at '%s' [Complete signature is '%s']\\n\", next, signature_copy, signature_start);\n  \t\treturn 0;\n  \t    }\n  \t}\n      }\n  \n      if (t == 0)\n      {\n  \treturn 0;\n      }\n  \n  //    y2debug (\"t '%s', signature '%s', k %d\", t->toString().c_str(), *signature, k);\n  \n      signature_copy = *signature;\n      if (**signature == '&')\n      {\n  \tTypePtr tr = t->clone();\n  \ttr->asReference();\n  \tt = tr;\n  \tdo { (*signature)++; } while (isspace (**signature));\n      }\n  \n      // check for function, it's postfix !\n  \n      if (**signature == '(')\n      {\n  //\ty2debug (\"function!\");\n  \tFunctionTypePtr f (new FunctionType (t, as_const));\n  \n  \tdo\n  \t{\n  \t    do { (*signature)++; } while (isspace (**signature));\n  \t    if (**signature == ')')\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    signature_copy = *signature;\n  \t    constTypePtr t1 = fromSignature (signature);\n  \t    if (t1 == 0)\n  \t    {\n  \t\t*signature = signature_copy;\n  \t\tbreak;\n  \t    }\n  \n  \t    f->concat (t1);\n  \t}\n  \twhile (**signature == ',');\n  \n  \tif (**signature != ')')\n  \t{\n  \t    y2error (\"Expected ')' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n  \t    return 0;\n  \t}\n  \n  \t(*signature)++;\n  \tt = f;\n      }\n      else if (k == TupleT)\n      {\n  \tTupleTypePtr tt = t->clone();\n  //\ty2debug (\"tuple! '%s', signature '%s'\", tt->toString().c_str(), *signature);\n  \twhile (**signature == ',')\n  \t{\n  \t    (*signature)++;\n  \t    signature_copy = *signature;\n  \t    constTypePtr t1 = fromSignature (signature);\n  \t    if (t1 == 0)\n  \t    {\n  \t\ty2error (\"Unknown type at '%s' [Complete signature is '%s']!\\n\", signature_copy, signature_start);\n  \t\treturn 0;\n  \t    }\n  \n  \t    tt->concat (t1);\n  \t}\n  \tif (**signature != '>')\n  \t{\n  \t    y2error (\"Expected '>' at '%s' [Complete signature is '%s']\\n\", signature_copy, signature_start);\n  \t    return 0;\n  \t}\n  \tt = tt;\n      }\n  \n  //    y2debug (\"Type::fromSignature Done: '%s' -> '%s' [%s]\\n\", signature_start, t->toString().c_str(), *signature);\n  \n      return t;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nvoid\nfromSig (const char *s, constTypePtr t, string ts)\n{\n    constTypePtr i = Type::fromSignature (s);\n\n    if (ts.empty()) ts = t->toString();\n\n    if (i == 0)\n    {\n\tfprintf (stderr, \"Failed (\\\"%s\\\" != \\\"%s\\\")\\n\", s, ts.c_str()); fflush (stderr);\n\treturn;\n    }\n\n    string is = i->toString();\n    if (is != ts)\n    {\n\tprintf (\"Expect: \\\"%s\\\" -> '%s'\\n\", s, ts.c_str());\n\tprintf (\"Got   : \\\"%s\\\" -> '%s'\\n\", s, is.c_str());\n    }\n    else\n    {\n\tprintf (\"Ok: %s\\n\", is.c_str());\n    }\n    return;\n}"
  }
]