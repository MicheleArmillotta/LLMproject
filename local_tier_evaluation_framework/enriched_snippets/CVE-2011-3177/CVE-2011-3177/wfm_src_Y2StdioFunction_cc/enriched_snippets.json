[
  {
    "function_name": "name",
    "container": "Y2StdioFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/wfm/src/Y2StdioFunction.cc",
    "lines": "184-188",
    "snippet": "string\nY2StdioFunction::name () const\n{\n    return m_name;\n}",
    "includes": [
      "#include \"ycp/SymbolTable.h\"",
      "#include \"Y2SystemNamespace.h\"",
      "#include <y2/Y2ProgramComponent.h>",
      "#include <ycp/YCPString.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>",
      "#include \"Y2StdioFunction.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"Y2SystemNamespace.h\"\n#include <y2/Y2ProgramComponent.h>\n#include <ycp/YCPString.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n#include \"Y2StdioFunction.h\"\n\nY2StdioFunction {\n  string\n  Y2StdioFunction::name () const\n  {\n      return m_name;\n  }\n}"
  },
  {
    "function_name": "reset",
    "container": "Y2StdioFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/wfm/src/Y2StdioFunction.cc",
    "lines": "171-180",
    "snippet": "bool \nY2StdioFunction::reset ()\n{\n    for (int i = 0; i < m_type->parameterCount (); i++)\n    {\n\tm_parameters[i] = YCPNull ();\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"ycp/SymbolTable.h\"",
      "#include \"Y2SystemNamespace.h\"",
      "#include <y2/Y2ProgramComponent.h>",
      "#include <ycp/YCPString.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>",
      "#include \"Y2StdioFunction.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_type->parameterCount",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"Y2SystemNamespace.h\"\n#include <y2/Y2ProgramComponent.h>\n#include <ycp/YCPString.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n#include \"Y2StdioFunction.h\"\n\nY2StdioFunction {\n  bool \n  Y2StdioFunction::reset ()\n  {\n      for (int i = 0; i < m_type->parameterCount (); i++)\n      {\n  \tm_parameters[i] = YCPNull ();\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "evaluateCall",
    "container": "Y2StdioFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/wfm/src/Y2StdioFunction.cc",
    "lines": "133-168",
    "snippet": "YCPValue \nY2StdioFunction::evaluateCall ()\n{\n    y2milestone (\"Evaluating remote call to '%s::%s'\"\n\t, m_namespace.c_str (), m_name.c_str ());\n\n    // FIXME: ensure connected\n\n    string params = \"\";\n    \n    if (m_type->parameterCount () > 0)\n    {\n\tparams = m_parameters[0]->toString ();\n\tfor (int i = 1 ; i < m_type->parameterCount (); i++)\n\t{\n\t    params += \", \" + m_parameters[i]->toString ();\n\t}\n    }\n    \n    string call = string (\"{ import \\\"\") + m_namespace\n\t+ \"\\\"; return \" + m_namespace + \"::\" \n\t+ m_name + \"(\" + params + \"); }\";\n\n#if DO_DEBUG\n    y2debug (\"Going to evaluate a call: %s\", call.c_str ());\n#endif\n    \n    Y2ProgramComponent* sender = dynamic_cast<Y2ProgramComponent*>(m_sender);\n\n    // send command\n    sender->sendToExternal (call);\n\n    // get answer\n    YCPValue retval = sender->receiveFromExternal();\n    return !retval.isNull() ? retval : YCPVoid();\n}",
    "includes": [
      "#include \"ycp/SymbolTable.h\"",
      "#include \"Y2SystemNamespace.h\"",
      "#include <y2/Y2ProgramComponent.h>",
      "#include <ycp/YCPString.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>",
      "#include \"Y2StdioFunction.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "retval.isNull",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sender->receiveFromExternal",
          "args": [],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "receiveFromExternal",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "355-383",
          "snippet": "YCPValue Y2ProgramComponent::receiveFromExternal ()\n{\n    while (true)\n    {\n\tif (!externalProgramOK ())\n\t{\n\t    y2error (\"External program %s died unexpectedly\", bin_file.c_str ());\n\t    return YCPNull ();\n\t}\n\n\tYCodePtr c = parser.parse ();\n\t\n\tif (c == NULL || c->isError())\n\t{\n\t    y2error (\"External program %s returned invalid data. (No other error means no data at all)\", bin_file.c_str ());\n\t    return YCPNull ();\n\t}\n\t\n\t// evaluate, but not as constant\n\tYCPValue ret = c->evaluate (true);\n\tif (ret.isNull ())\n\t{\n\t    y2milestone (\"External program returned executable code, executing\");\n\t    ret = c->evaluate (false);\n\t}\n\n\treturn ret;\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  YCPValue Y2ProgramComponent::receiveFromExternal ()\n  {\n      while (true)\n      {\n  \tif (!externalProgramOK ())\n  \t{\n  \t    y2error (\"External program %s died unexpectedly\", bin_file.c_str ());\n  \t    return YCPNull ();\n  \t}\n  \n  \tYCodePtr c = parser.parse ();\n  \t\n  \tif (c == NULL || c->isError())\n  \t{\n  \t    y2error (\"External program %s returned invalid data. (No other error means no data at all)\", bin_file.c_str ());\n  \t    return YCPNull ();\n  \t}\n  \t\n  \t// evaluate, but not as constant\n  \tYCPValue ret = c->evaluate (true);\n  \tif (ret.isNull ())\n  \t{\n  \t    y2milestone (\"External program returned executable code, executing\");\n  \t    ret = c->evaluate (false);\n  \t}\n  \n  \treturn ret;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sender->sendToExternal",
          "args": [
            "call"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "sendToExternal",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "392-427",
          "snippet": "void Y2ProgramComponent::sendToExternal(const string& value)\n{\n    if (!externalProgramOK())\n    {\n\ty2error (\"External program %s died unexpectedly\", bin_file.c_str());\n    }\n\n    char *v = NULL;\n\n    if (is_non_y2)  v = strdup(value.c_str());   // no brackets\n    else            v = strdup((\"(\" + value + \")\").c_str());\n\n    bool error = (write(to_external[1], v, strlen(v)) < 0);\n    if (error)\n    {\n\ty2debug (\"Error writing to external program %s: Couldn't send %s (%s)\", bin_file.c_str(), v, strerror (errno));\n\tterminateExternalProgram();\n    }\n    free(v);\n\n    // We send an additional linefeed. This makes it more conveniant for non\n    // Y2 programs, for example that shell can do a read to get one value. For\n    // Y2 programs it increases the readability if you want to dump and debug\n    // the whole stream.\n\n    // We MUST NOT trigger an error, if the sending of the linefeed is not\n    // successful. This sporadically happens after we send a module the last\n    // return just before the module has done its work and terminates. It then\n    // justs sends the result(..) message, and closes down without reading the\n    // linefeed. The pipe breaks down and the sending fails. But as long as we\n    // don't collect the process by calling wait4, we can still read the\n    // result (..) from the input pipe, which is very important. Otherwise the\n    // result value would be dropped.\n\n    write(to_external[1], \"\\n\", 1);\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::sendToExternal(const string& value)\n  {\n      if (!externalProgramOK())\n      {\n  \ty2error (\"External program %s died unexpectedly\", bin_file.c_str());\n      }\n  \n      char *v = NULL;\n  \n      if (is_non_y2)  v = strdup(value.c_str());   // no brackets\n      else            v = strdup((\"(\" + value + \")\").c_str());\n  \n      bool error = (write(to_external[1], v, strlen(v)) < 0);\n      if (error)\n      {\n  \ty2debug (\"Error writing to external program %s: Couldn't send %s (%s)\", bin_file.c_str(), v, strerror (errno));\n  \tterminateExternalProgram();\n      }\n      free(v);\n  \n      // We send an additional linefeed. This makes it more conveniant for non\n      // Y2 programs, for example that shell can do a read to get one value. For\n      // Y2 programs it increases the readability if you want to dump and debug\n      // the whole stream.\n  \n      // We MUST NOT trigger an error, if the sending of the linefeed is not\n      // successful. This sporadically happens after we send a module the last\n      // return just before the module has done its work and terminates. It then\n      // justs sends the result(..) message, and closes down without reading the\n      // linefeed. The pipe breaks down and the sending fails. But as long as we\n      // don't collect the process by calling wait4, we can still read the\n      // result (..) from the input pipe, which is very important. Otherwise the\n      // result value would be dropped.\n  \n      write(to_external[1], \"\\n\", 1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dynamic_cast<Y2ProgramComponent*>",
          "args": [
            "m_sender"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Going to evaluate a call: %s\"",
            "call.c_str ()"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call.c_str",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"{ import \\\"\""
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_parameters[i]->toString",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_type->parameterCount",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2milestone",
          "args": [
            "\"Evaluating remote call to '%s::%s'\"",
            "m_namespace.c_str ()",
            "m_name.c_str ()"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name.c_str",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_namespace.c_str",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"Y2SystemNamespace.h\"\n#include <y2/Y2ProgramComponent.h>\n#include <ycp/YCPString.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n#include \"Y2StdioFunction.h\"\n\n#define DO_DEBUG 0\n\nY2StdioFunction {\n  YCPValue \n  Y2StdioFunction::evaluateCall ()\n  {\n      y2milestone (\"Evaluating remote call to '%s::%s'\"\n  \t, m_namespace.c_str (), m_name.c_str ());\n  \n      // FIXME: ensure connected\n  \n      string params = \"\";\n      \n      if (m_type->parameterCount () > 0)\n      {\n  \tparams = m_parameters[0]->toString ();\n  \tfor (int i = 1 ; i < m_type->parameterCount (); i++)\n  \t{\n  \t    params += \", \" + m_parameters[i]->toString ();\n  \t}\n      }\n      \n      string call = string (\"{ import \\\"\") + m_namespace\n  \t+ \"\\\"; return \" + m_namespace + \"::\" \n  \t+ m_name + \"(\" + params + \"); }\";\n  \n  #if DO_DEBUG\n      y2debug (\"Going to evaluate a call: %s\", call.c_str ());\n  #endif\n      \n      Y2ProgramComponent* sender = dynamic_cast<Y2ProgramComponent*>(m_sender);\n  \n      // send command\n      sender->sendToExternal (call);\n  \n      // get answer\n      YCPValue retval = sender->receiveFromExternal();\n      return !retval.isNull() ? retval : YCPVoid();\n  }\n}"
  },
  {
    "function_name": "finishParameters",
    "container": "Y2StdioFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/wfm/src/Y2StdioFunction.cc",
    "lines": "116-130",
    "snippet": "bool \nY2StdioFunction::finishParameters ()\n{\n    for (int i = 0 ; i < m_type->parameterCount (); i++)\n    {\n\tif (m_parameters [i].isNull ())\n\t{\n\t    y2error (\"Missing parameter %d to %s::%s\",\n\t         i, m_namespace.c_str(), m_name.c_str ());\n\t    return false;\n\t}\n    }\n\t\t\t\t\t\t\t\t\t         // FIXME\n    return true;\n}",
    "includes": [
      "#include \"ycp/SymbolTable.h\"",
      "#include \"Y2SystemNamespace.h\"",
      "#include <y2/Y2ProgramComponent.h>",
      "#include <ycp/YCPString.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>",
      "#include \"Y2StdioFunction.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Missing parameter %d to %s::%s\"",
            "i",
            "m_namespace.c_str()",
            "m_name.c_str ()"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name.c_str",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_namespace.c_str",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_parameters [i].isNull",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_type->parameterCount",
          "args": [],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"Y2SystemNamespace.h\"\n#include <y2/Y2ProgramComponent.h>\n#include <ycp/YCPString.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n#include \"Y2StdioFunction.h\"\n\nY2StdioFunction {\n  bool \n  Y2StdioFunction::finishParameters ()\n  {\n      for (int i = 0 ; i < m_type->parameterCount (); i++)\n      {\n  \tif (m_parameters [i].isNull ())\n  \t{\n  \t    y2error (\"Missing parameter %d to %s::%s\",\n  \t         i, m_namespace.c_str(), m_name.c_str ());\n  \t    return false;\n  \t}\n      }\n  \t\t\t\t\t\t\t\t\t         // FIXME\n      return true;\n  }\n}"
  },
  {
    "function_name": "appendParameter",
    "container": "Y2StdioFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/wfm/src/Y2StdioFunction.cc",
    "lines": "83-113",
    "snippet": "bool \nY2StdioFunction::appendParameter (const YCPValue& arg)\n{\n    if (arg.isNull())\n    {\n\tycp2error (\"NULL parameter to %s::%s\", m_namespace.c_str(), m_name.c_str ());\n\treturn false;\n    }\n\t\t\t    \n    // FIXME: check the type\n\t\t\t\t\n    // lookup the first non-set parameter\n    for (int i = 0 ; i < m_type->parameterCount (); i++)\n    {\n\tif (m_parameters[i].isNull ())\n\t{\n#if DO_DEBUG\n\t    y2debug (\"Assigning parameter %d: %s\", i, arg->toString ().c_str ());\n#endif\n\t    m_parameters[i] = arg;\n\t    return true;\n\t}\n    }\n\n    // Our caller should report the place\n    // in a script where this happened\n    ycp2error (\"Excessive parameter to %s::%s\"\n\t, m_namespace.c_str(), m_name.c_str ());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t        // FIXME\n    return false;\n}",
    "includes": [
      "#include \"ycp/SymbolTable.h\"",
      "#include \"Y2SystemNamespace.h\"",
      "#include <y2/Y2ProgramComponent.h>",
      "#include <ycp/YCPString.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>",
      "#include \"Y2StdioFunction.h\""
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Excessive parameter to %s::%s\"",
            "m_namespace.c_str()",
            "m_name.c_str ()"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name.c_str",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_namespace.c_str",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Assigning parameter %d: %s\"",
            "i",
            "arg->toString ().c_str ()"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg->toString",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_parameters[i].isNull",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_type->parameterCount",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"NULL parameter to %s::%s\"",
            "m_namespace.c_str()",
            "m_name.c_str ()"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name.c_str",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_namespace.c_str",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"Y2SystemNamespace.h\"\n#include <y2/Y2ProgramComponent.h>\n#include <ycp/YCPString.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n#include \"Y2StdioFunction.h\"\n\n#define DO_DEBUG 0\n\nY2StdioFunction {\n  bool \n  Y2StdioFunction::appendParameter (const YCPValue& arg)\n  {\n      if (arg.isNull())\n      {\n  \tycp2error (\"NULL parameter to %s::%s\", m_namespace.c_str(), m_name.c_str ());\n  \treturn false;\n      }\n  \t\t\t    \n      // FIXME: check the type\n  \t\t\t\t\n      // lookup the first non-set parameter\n      for (int i = 0 ; i < m_type->parameterCount (); i++)\n      {\n  \tif (m_parameters[i].isNull ())\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"Assigning parameter %d: %s\", i, arg->toString ().c_str ());\n  #endif\n  \t    m_parameters[i] = arg;\n  \t    return true;\n  \t}\n      }\n  \n      // Our caller should report the place\n      // in a script where this happened\n      ycp2error (\"Excessive parameter to %s::%s\"\n  \t, m_namespace.c_str(), m_name.c_str ());\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t        // FIXME\n      return false;\n  }\n}"
  },
  {
    "function_name": "wantedParameterType",
    "container": "Y2StdioFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/wfm/src/Y2StdioFunction.cc",
    "lines": "75-80",
    "snippet": "constTypePtr \nY2StdioFunction::wantedParameterType () const\n{\n    y2internal (\"Somebody asking for a parameter type redirector\");\n    return Type::Any;\n}",
    "includes": [
      "#include \"ycp/SymbolTable.h\"",
      "#include \"Y2SystemNamespace.h\"",
      "#include <y2/Y2ProgramComponent.h>",
      "#include <ycp/YCPString.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>",
      "#include \"Y2StdioFunction.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2internal",
          "args": [
            "\"Somebody asking for a parameter type redirector\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"Y2SystemNamespace.h\"\n#include <y2/Y2ProgramComponent.h>\n#include <ycp/YCPString.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n#include \"Y2StdioFunction.h\"\n\nY2StdioFunction {\n  constTypePtr \n  Y2StdioFunction::wantedParameterType () const\n  {\n      y2internal (\"Somebody asking for a parameter type redirector\");\n      return Type::Any;\n  }\n}"
  },
  {
    "function_name": "attachParameter",
    "container": "Y2StdioFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/wfm/src/Y2StdioFunction.cc",
    "lines": "61-73",
    "snippet": "bool \nY2StdioFunction::attachParameter (const YCPValue& arg, const int pos)\n{\n    if (pos < 0 || pos > m_type->parameterCount ())\n    {\n\ty2error (\"Attaching parameter to function '%s::%s' at incorrect position: %d\"\n\t    , m_namespace.c_str(), m_name.c_str (), pos );\n\treturn false;\n    }\n\n    m_parameters[pos] = arg;\n    return true;\n}",
    "includes": [
      "#include \"ycp/SymbolTable.h\"",
      "#include \"Y2SystemNamespace.h\"",
      "#include <y2/Y2ProgramComponent.h>",
      "#include <ycp/YCPString.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>",
      "#include \"Y2StdioFunction.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Attaching parameter to function '%s::%s' at incorrect position: %d\"",
            "m_namespace.c_str()",
            "m_name.c_str ()",
            "pos"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_name.c_str",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_namespace.c_str",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_type->parameterCount",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"Y2SystemNamespace.h\"\n#include <y2/Y2ProgramComponent.h>\n#include <ycp/YCPString.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n#include \"Y2StdioFunction.h\"\n\nY2StdioFunction {\n  bool \n  Y2StdioFunction::attachParameter (const YCPValue& arg, const int pos)\n  {\n      if (pos < 0 || pos > m_type->parameterCount ())\n      {\n  \ty2error (\"Attaching parameter to function '%s::%s' at incorrect position: %d\"\n  \t    , m_namespace.c_str(), m_name.c_str (), pos );\n  \treturn false;\n      }\n  \n      m_parameters[pos] = arg;\n      return true;\n  }\n}"
  },
  {
    "function_name": "~Y2StdioFunction",
    "container": "Y2StdioFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/wfm/src/Y2StdioFunction.cc",
    "lines": "56-59",
    "snippet": "Y2StdioFunction::~Y2StdioFunction ()\n{\n    delete[] m_parameters;\n}",
    "includes": [
      "#include \"ycp/SymbolTable.h\"",
      "#include \"Y2SystemNamespace.h\"",
      "#include <y2/Y2ProgramComponent.h>",
      "#include <ycp/YCPString.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>",
      "#include \"Y2StdioFunction.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"Y2SystemNamespace.h\"\n#include <y2/Y2ProgramComponent.h>\n#include <ycp/YCPString.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n#include \"Y2StdioFunction.h\"\n\nY2StdioFunction {\n  Y2StdioFunction::~Y2StdioFunction ()\n  {\n      delete[] m_parameters;\n  }\n}"
  },
  {
    "function_name": "Y2StdioFunction",
    "container": "Y2StdioFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/wfm/src/Y2StdioFunction.cc",
    "lines": "39-54",
    "snippet": "Y2StdioFunction::Y2StdioFunction (string ns, string name\n    , constFunctionTypePtr type, Y2ProgramComponent* sender) :\n    m_namespace (ns)\n    , m_name (name)\n    , m_type (type)\n    , m_sender (sender)\n{\n    uint count = type->parameterCount ();\n   \n    m_parameters = new YCPValue[count];\n      \n    for (uint i=0; i < count; i++)\n    {\n\tm_parameters[i] = YCPNull ();\n    }\n}",
    "includes": [
      "#include \"ycp/SymbolTable.h\"",
      "#include \"Y2SystemNamespace.h\"",
      "#include <y2/Y2ProgramComponent.h>",
      "#include <ycp/YCPString.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>",
      "#include \"Y2StdioFunction.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->parameterCount",
          "args": [],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"Y2SystemNamespace.h\"\n#include <y2/Y2ProgramComponent.h>\n#include <ycp/YCPString.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n#include \"Y2StdioFunction.h\"\n\nY2StdioFunction {\n  Y2StdioFunction::Y2StdioFunction (string ns, string name\n      , constFunctionTypePtr type, Y2ProgramComponent* sender) :\n      m_namespace (ns)\n      , m_name (name)\n      , m_type (type)\n      , m_sender (sender)\n  {\n      uint count = type->parameterCount ();\n     \n      m_parameters = new YCPValue[count];\n        \n      for (uint i=0; i < count; i++)\n      {\n  \tm_parameters[i] = YCPNull ();\n      }\n  }\n}"
  }
]