[
  {
    "function_name": "crypt_pass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2crypt.cc",
    "lines": "99-191",
    "snippet": "bool\ncrypt_pass (string unencrypted, crypt_t use_crypt, string* encrypted)\n{\n    struct crypt_data output;\n    memset (&output, 0, sizeof (output));\n\n    char* salt;\n    char* newencrypted = 0;\n\n    switch (use_crypt)\n    {\n\tcase CRYPT:\n \t    salt = make_crypt_salt (\"\", 0);\n\t    if (!salt)\n\t    {\n\t\ty2error (\"Cannot create salt for standard crypt\");\n\t\treturn false;\n\t    }\n\t    newencrypted = xcrypt_r (unencrypted.c_str (), salt, &output);\n\t    free (salt);\n\t    break;\n\n\tcase MD5:\n\t    salt = make_crypt_salt (\"$1$\", 0);\n\t    if (!salt)\n\t    {\n\t\ty2error (\"Cannot create salt for MD5 crypt\");\n\t\treturn false;\n\t    }\n\t    newencrypted = xcrypt_r (unencrypted.c_str (), salt, &output);\n\t    free (salt);\n\t    break;\n\n\tcase BIGCRYPT:\n\t    salt = make_crypt_salt (\"\", 0);\n\t    if (!salt)\n\t    {\n\t\ty2error (\"Cannot create salt for bigcrypt\");\n\t\treturn false;\n\t    }\n\t    newencrypted = bigcrypt (unencrypted.c_str (), salt);\n\t    free (salt);\n\t    break;\n\n\tcase BLOWFISH:\n\t    salt = make_crypt_salt (\"$2y$\", 0);\n\t    if (!salt)\n\t    {\n\t\ty2error (\"Cannot create salt for blowfish crypt\");\n\t\treturn false;\n\t    }\n\t    newencrypted = xcrypt_r (unencrypted.c_str (), salt, &output);\n\t    free (salt);\n\t    break;\n\n\tcase SHA256:\n\t    salt = make_crypt_salt (\"$5$\", 0);\n\t    if (!salt)\n\t    {\n\t\ty2error (\"Cannot create salt for sha256 crypt\");\n\t\treturn false;\n\t    }\n\t    newencrypted = xcrypt_r (unencrypted.c_str (), salt, &output);\n\t    free (salt);\n\t    break;\n\n\tcase SHA512:\n\t    salt = make_crypt_salt (\"$6$\", 0);\n\t    if (!salt)\n\t    {\n\t\ty2error (\"Cannot create salt for sha512 crypt\");\n\t\treturn false;\n\t    }\n\t    newencrypted = xcrypt_r (unencrypted.c_str (), salt, &output);\n\t    free (salt);\n\t    break;\n\n\tdefault:\n\t    y2error (\"Don't know crypt type %d\", use_crypt);\n\t    return false;\n    }\n\n    if (!newencrypted\n    /* catch retval magic by ow-crypt/libxcrypt */\n    || !strcmp(newencrypted, \"*0\") || !strcmp(newencrypted, \"*1\"))\n    {\n\ty2error (\"crypt_r () returns 0 pointer\");\n\treturn false;\n    }\n\n    *encrypted = string (newencrypted);\n    return true;\n}",
    "includes": [
      "#include \"y2crypt.h\"",
      "#include \"y2log.h\"",
      "#include <xcrypt.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "string",
          "args": [
            "newencrypted"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"crypt_r () returns 0 pointer\""
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "newencrypted",
            "\"*1\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "newencrypted",
            "\"*0\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Don't know crypt type %d\"",
            "use_crypt"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "salt"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcrypt_r",
          "args": [
            "unencrypted.c_str ()",
            "salt",
            "&output"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unencrypted.c_str",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Cannot create salt for sha512 crypt\""
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_crypt_salt",
          "args": [
            "\"$6$\"",
            "0"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "salt"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcrypt_r",
          "args": [
            "unencrypted.c_str ()",
            "salt",
            "&output"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unencrypted.c_str",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Cannot create salt for sha256 crypt\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_crypt_salt",
          "args": [
            "\"$5$\"",
            "0"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "salt"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcrypt_r",
          "args": [
            "unencrypted.c_str ()",
            "salt",
            "&output"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unencrypted.c_str",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Cannot create salt for blowfish crypt\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_crypt_salt",
          "args": [
            "\"$2y$\"",
            "0"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "salt"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bigcrypt",
          "args": [
            "unencrypted.c_str ()",
            "salt"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unencrypted.c_str",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Cannot create salt for bigcrypt\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_crypt_salt",
          "args": [
            "\"\"",
            "0"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "salt"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcrypt_r",
          "args": [
            "unencrypted.c_str ()",
            "salt",
            "&output"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unencrypted.c_str",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Cannot create salt for MD5 crypt\""
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_crypt_salt",
          "args": [
            "\"$1$\"",
            "0"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "salt"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcrypt_r",
          "args": [
            "unencrypted.c_str ()",
            "salt",
            "&output"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unencrypted.c_str",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Cannot create salt for standard crypt\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_crypt_salt",
          "args": [
            "\"\"",
            "0"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&output",
            "0",
            "sizeof (output)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"y2crypt.h\"\n#include \"y2log.h\"\n#include <xcrypt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n\nbool\ncrypt_pass (string unencrypted, crypt_t use_crypt, string* encrypted)\n{\n    struct crypt_data output;\n    memset (&output, 0, sizeof (output));\n\n    char* salt;\n    char* newencrypted = 0;\n\n    switch (use_crypt)\n    {\n\tcase CRYPT:\n \t    salt = make_crypt_salt (\"\", 0);\n\t    if (!salt)\n\t    {\n\t\ty2error (\"Cannot create salt for standard crypt\");\n\t\treturn false;\n\t    }\n\t    newencrypted = xcrypt_r (unencrypted.c_str (), salt, &output);\n\t    free (salt);\n\t    break;\n\n\tcase MD5:\n\t    salt = make_crypt_salt (\"$1$\", 0);\n\t    if (!salt)\n\t    {\n\t\ty2error (\"Cannot create salt for MD5 crypt\");\n\t\treturn false;\n\t    }\n\t    newencrypted = xcrypt_r (unencrypted.c_str (), salt, &output);\n\t    free (salt);\n\t    break;\n\n\tcase BIGCRYPT:\n\t    salt = make_crypt_salt (\"\", 0);\n\t    if (!salt)\n\t    {\n\t\ty2error (\"Cannot create salt for bigcrypt\");\n\t\treturn false;\n\t    }\n\t    newencrypted = bigcrypt (unencrypted.c_str (), salt);\n\t    free (salt);\n\t    break;\n\n\tcase BLOWFISH:\n\t    salt = make_crypt_salt (\"$2y$\", 0);\n\t    if (!salt)\n\t    {\n\t\ty2error (\"Cannot create salt for blowfish crypt\");\n\t\treturn false;\n\t    }\n\t    newencrypted = xcrypt_r (unencrypted.c_str (), salt, &output);\n\t    free (salt);\n\t    break;\n\n\tcase SHA256:\n\t    salt = make_crypt_salt (\"$5$\", 0);\n\t    if (!salt)\n\t    {\n\t\ty2error (\"Cannot create salt for sha256 crypt\");\n\t\treturn false;\n\t    }\n\t    newencrypted = xcrypt_r (unencrypted.c_str (), salt, &output);\n\t    free (salt);\n\t    break;\n\n\tcase SHA512:\n\t    salt = make_crypt_salt (\"$6$\", 0);\n\t    if (!salt)\n\t    {\n\t\ty2error (\"Cannot create salt for sha512 crypt\");\n\t\treturn false;\n\t    }\n\t    newencrypted = xcrypt_r (unencrypted.c_str (), salt, &output);\n\t    free (salt);\n\t    break;\n\n\tdefault:\n\t    y2error (\"Don't know crypt type %d\", use_crypt);\n\t    return false;\n    }\n\n    if (!newencrypted\n    /* catch retval magic by ow-crypt/libxcrypt */\n    || !strcmp(newencrypted, \"*0\") || !strcmp(newencrypted, \"*1\"))\n    {\n\ty2error (\"crypt_r () returns 0 pointer\");\n\treturn false;\n    }\n\n    *encrypted = string (newencrypted);\n    return true;\n}"
  },
  {
    "function_name": "read_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2crypt.cc",
    "lines": "25-50",
    "snippet": "static int\nread_loop (int fd, char* buffer, int count)\n{\n    int offset, block;\n\n    offset = 0;\n    while (count > 0)\n    {\n\tblock = read (fd, &buffer[offset], count);\n\n\tif (block < 0)\n\t{\n\t    if (errno == EINTR)\n\t\tcontinue;\n\t    return block;\n\t}\n\n\tif (!block)\n\t    return offset;\n\n\toffset += block;\n\tcount -= block;\n    }\n\n    return offset;\n}",
    "includes": [
      "#include \"y2crypt.h\"",
      "#include \"y2log.h\"",
      "#include <xcrypt.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "&buffer[offset]",
            "count"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "read_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/y2crypt.cc",
          "lines": "25-50",
          "snippet": "static int\nread_loop (int fd, char* buffer, int count)\n{\n    int offset, block;\n\n    offset = 0;\n    while (count > 0)\n    {\n\tblock = read (fd, &buffer[offset], count);\n\n\tif (block < 0)\n\t{\n\t    if (errno == EINTR)\n\t\tcontinue;\n\t    return block;\n\t}\n\n\tif (!block)\n\t    return offset;\n\n\toffset += block;\n\tcount -= block;\n    }\n\n    return offset;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"y2crypt.h\"\n#include \"y2log.h\"\n#include <xcrypt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int\nread_loop (int fd, char* buffer, int count)\n{\n    int offset, block;\n\n    offset = 0;\n    while (count > 0)\n    {\n\tblock = read (fd, &buffer[offset], count);\n\n\tif (block < 0)\n\t{\n\t    if (errno == EINTR)\n\t\tcontinue;\n\t    return block;\n\t}\n\n\tif (!block)\n\t    return offset;\n\n\toffset += block;\n\tcount -= block;\n    }\n\n    return offset;\n}"
  }
]