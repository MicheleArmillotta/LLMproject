[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/ShellCommand.cc",
    "lines": "245-263",
    "snippet": "int\nmain ()\n{\n    int r = 123456;\n    fprintf (stdout, \"Oret=%d\\n\", r);\n    fprintf (stderr, \"Eret=%d\\n\", r);\n\n    set_log_filename (\"-\");\n    y2debug (\"START\");\n\n    //r = shellcommand_background(\"sleep 5; echo x1x; echo y2y >&2; exit 3;\");\n    //r = shellcommand(\"echo x1x; echo y2y >&2; exit 3;\", \"/tmp\");\n    r = shellcommand (\"echo x1x; echo y2y >&2; exit 3;\");\n    y2debug (\"--ret=%d\", r);\n\n    fprintf (stdout, \"Oret=%d\\n\", r);\n    fprintf (stderr, \"Eret=%d\\n\", r);\n    return r;\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include \"ShellCommand.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Eret=%d\\n\"",
            "r"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Oret=%d\\n\"",
            "r"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"--ret=%d\"",
            "r"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shellcommand",
          "args": [
            "\"echo x1x; echo y2y >&2; exit 3;\""
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "shellcommand_background",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/ShellCommand.cc",
          "lines": "193-221",
          "snippet": "int\nshellcommand_background (const string &command)\n{\n\n    if (!getenv (\"Y2DEBUGSHELL\") && !getenv (\"Y2DEBUGALL\"))\n    {\n\tsystem (string (command + \" >/dev/null 2>&1 &\").c_str ());\n\t// FIXME execl (\"/bin/sh\", \"-c\", command.c_str(), NULL);\n\treturn 0;\n    }\n\n    /* fork the child */\n    pid_t child = fork ();\n    if (child == -1)\n    {\n\ty2error(\"fork failed: %s\", strerror(errno));\n\treturn -1;\n    }\n\n    /* child process */\n    if (!child)\n    {\n\tshellcommand (command, \"\");\n\t_exit (0);\n    }\n\n    /* return success */\n    return 0;\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include \"ShellCommand.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include \"ShellCommand.h\"\n#include \"ycp/y2log.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string>\n#include <stdio.h>\n#include <errno.h>\n\nint\nshellcommand_background (const string &command)\n{\n\n    if (!getenv (\"Y2DEBUGSHELL\") && !getenv (\"Y2DEBUGALL\"))\n    {\n\tsystem (string (command + \" >/dev/null 2>&1 &\").c_str ());\n\t// FIXME execl (\"/bin/sh\", \"-c\", command.c_str(), NULL);\n\treturn 0;\n    }\n\n    /* fork the child */\n    pid_t child = fork ();\n    if (child == -1)\n    {\n\ty2error(\"fork failed: %s\", strerror(errno));\n\treturn -1;\n    }\n\n    /* child process */\n    if (!child)\n    {\n\tshellcommand (command, \"\");\n\t_exit (0);\n    }\n\n    /* return success */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"START\""
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_log_filename",
          "args": [
            "\"-\""
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "set_log_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2changes.cc",
          "lines": "188-240",
          "snippet": "static void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2CHANGES_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2CHANGES_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2CHANGES_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2CHANGES_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2CHANGES_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2CHANGES_FALLBACK );\n\n\t\tlogname = Y2CHANGES_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2CHANGES_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2CHANGES_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2CHANGES_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2CHANGES_VAR_NUM\t\"Y2MAXLOGNUM\"",
            "#define Y2CHANGES_VAR_SIZE\t\"Y2MAXLOGSIZE\"",
            "#define Y2CHANGES_FALLBACK\t\"/y2changes\"",
            "#define Y2CHANGES_USER\t\"/.y2changes\"\t\t/* Relative to $HOME */",
            "#define Y2CHANGES_ROOT\tLOGDIR \"/y2changes\"",
            "#define Y2CHANGES_MAXNUM\t10\t\t\t/* Maximum logfiles number */",
            "#define Y2CHANGES_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */"
          ],
          "globals_used": [
            "static bool did_set_logname = false;",
            "static const char *logname;",
            "static off_t maxlogsize;",
            "static int   maxlognum;",
            "static bool log_to_file = true;",
            "static bool log_to_syslog = false;",
            "static FILE *Y2CHANGES_STDERR = stderr;",
            "static void shift_log_files(string filename);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/y2changes.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2CHANGES_VAR_NUM\t\"Y2MAXLOGNUM\"\n#define Y2CHANGES_VAR_SIZE\t\"Y2MAXLOGSIZE\"\n#define Y2CHANGES_FALLBACK\t\"/y2changes\"\n#define Y2CHANGES_USER\t\"/.y2changes\"\t\t/* Relative to $HOME */\n#define Y2CHANGES_ROOT\tLOGDIR \"/y2changes\"\n#define Y2CHANGES_MAXNUM\t10\t\t\t/* Maximum logfiles number */\n#define Y2CHANGES_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */\n\nstatic bool did_set_logname = false;\nstatic const char *logname;\nstatic off_t maxlogsize;\nstatic int   maxlognum;\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic FILE *Y2CHANGES_STDERR = stderr;\nstatic void shift_log_files(string filename);\n\nstatic void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2CHANGES_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2CHANGES_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2CHANGES_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2CHANGES_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2CHANGES_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2CHANGES_FALLBACK );\n\n\t\tlogname = Y2CHANGES_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2CHANGES_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2CHANGES_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2CHANGES_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Eret=%d\\n\"",
            "r"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Oret=%d\\n\"",
            "r"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include \"ShellCommand.h\"\n#include \"ycp/y2log.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string>\n#include <stdio.h>\n#include <errno.h>\n\nint\nmain ()\n{\n    int r = 123456;\n    fprintf (stdout, \"Oret=%d\\n\", r);\n    fprintf (stderr, \"Eret=%d\\n\", r);\n\n    set_log_filename (\"-\");\n    y2debug (\"START\");\n\n    //r = shellcommand_background(\"sleep 5; echo x1x; echo y2y >&2; exit 3;\");\n    //r = shellcommand(\"echo x1x; echo y2y >&2; exit 3;\", \"/tmp\");\n    r = shellcommand (\"echo x1x; echo y2y >&2; exit 3;\");\n    y2debug (\"--ret=%d\", r);\n\n    fprintf (stdout, \"Oret=%d\\n\", r);\n    fprintf (stderr, \"Eret=%d\\n\", r);\n    return r;\n}"
  },
  {
    "function_name": "shellcommand_background",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/ShellCommand.cc",
    "lines": "193-221",
    "snippet": "int\nshellcommand_background (const string &command)\n{\n\n    if (!getenv (\"Y2DEBUGSHELL\") && !getenv (\"Y2DEBUGALL\"))\n    {\n\tsystem (string (command + \" >/dev/null 2>&1 &\").c_str ());\n\t// FIXME execl (\"/bin/sh\", \"-c\", command.c_str(), NULL);\n\treturn 0;\n    }\n\n    /* fork the child */\n    pid_t child = fork ();\n    if (child == -1)\n    {\n\ty2error(\"fork failed: %s\", strerror(errno));\n\treturn -1;\n    }\n\n    /* child process */\n    if (!child)\n    {\n\tshellcommand (command, \"\");\n\t_exit (0);\n    }\n\n    /* return success */\n    return 0;\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include \"ShellCommand.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "0"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shellcommand",
          "args": [
            "command",
            "\"\""
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "shellcommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/ShellCommand.cc",
          "lines": "28-186",
          "snippet": "int\nshellcommand (const string &command, const string &tempdir)\n{\n    y2debug (\"shellcommand start\");\n\n    int ret = 0;\n\n    int pipe1[2];\n    if (pipe (pipe1))\n    {\n\ty2error (\"pipe failed, errno: %d\", errno);\n\treturn -1;\n    }\n\n    fflush (0);\n    pid_t log2 = fork ();\n\n    if (log2 == -1)\n    {\n\ty2error (\"fork failed, errno: %d\", errno);\n\treturn -1;\n    }\n    else if (log2)\n    {\n\t/* parent: collect stderr */\n\n\tFILE *err = 0;\n\tif (!tempdir.empty ())\n\t    err = fopen ((tempdir + \"/stderr\").c_str (), \"w\");\n\n\tchar s1[1024];\n\tFILE *stream1 = fdopen (pipe1[0], \"r\");\n\tif (stream1 == 0)\n\t{\n\t    y2error (\"stream1 fdopen error\");\n\t    return -1;\n\t}\n\tclose (pipe1[1]);\n\n\twhile (fgets (s1, 1024, stream1))\n\t{\n\t    if (err)\n\t\tfputs (s1, err);\n\n\t    /* Yes, this should be y2error but some external\n\t     * programs print normal messages via stderr\n\t     * bug reports are filed but who knows if such programs\n\t     * ever get fixed. Thus we set this temporarily to\n\t     * y2warning.\n\t     */\n\t    y2error (\"%s\", s1);\n\t}\n\n\tfclose (stream1);\n\n\tif (err)\n\t    fclose (err);\n    }\n    else\n    {\n\t/* 1st child: fork the command and collect stdout */\n\n\tExternalProgram::renumber_fd (pipe1[1], 2);\n\tclose (pipe1[0]);\n\n\tint pipe2[2];\n\tif (pipe (pipe2))\n\t{\n\t    y2error (\"pipe failed, errno: %d\", errno);\n\t    _exit (1);\n\t}\n\n\tfflush (0);\n\tpid_t child = fork ();\n\n\tif (child == -1)\n\t{\n\t    y2error (\"fork failed, errno: %d\", errno);\n\t    _exit (1);\n\t}\n\telse if (child)\n\t{\n\t    /* parent (1st child): collect stdout */\n\n\t    FILE *out = 0;\n\t    if (!tempdir.empty ())\n\t\tout = fopen ((tempdir + \"/stdout\").c_str (), \"w\");\n\n\t    char s2[1024];\n\t    FILE *stream2 = fdopen (pipe2[0], \"r\");\n\t    if (stream2 == 0)\n\t    {\n\t        y2error (\"stream2 fdopen error\");\n\t\t_exit (1);\n\t    }\n\t    close (pipe2[1]);\n\n\t    while (fgets (s2, 1024, stream2))\n\t    {\n\t\tif (out)\n\t\t    fputs (s2, out);\n\t\t//bnc#493152#c24\n\t\t//y2debug (\"%s\", s2);\n\t    }\n\n\t    fclose (stream2);\n\n\t    if (out)\n\t\tfclose (out);\n\n\t}\n\telse\n\t{\n\t    /* child of child: run the command */\n\n\t    ExternalProgram::renumber_fd (pipe2[1], 1);\n\t    close (pipe2[0]);\n\n\t    // #223602\n\t    // close all file descriptors above stderr\n\t    for ( int i = getdtablesize() - 1; i > 2; --i ) {\n\t\tclose( i );\n\t    }\n\t    \n\t    ret = system (command.c_str ());\n\t    if (WIFEXITED (ret))\n\t\tret = WEXITSTATUS (ret);\n\t    else\n\t\tret = WTERMSIG (ret) + 128;\n\n\t    //y2debug (\"Exit status is %d\", ret);\n\n\t    if (!tempdir.empty ())\n\t    {\n\t\tFILE *ex = fopen ((tempdir + \"/exit\").c_str (), \"w\");\n\t\tif (ex)\n\t\t{\n\t\t    fprintf (ex, \"%d\\n\", ret);\n\t\t    fclose (ex);\n\t\t}\n\t    }\n\n\t    _exit (ret);\n\t}\n\n\twaitpid (child, &ret, 0);\n\tif (WIFEXITED (ret))\n\t    _exit (WEXITSTATUS (ret));\n\t_exit (WTERMSIG (ret) + 128);\n    }\n\n    waitpid (log2, &ret, 0);\n\n    y2debug (\"shellcommand end\");\n\n    if (WIFEXITED (ret))\n\treturn WEXITSTATUS (ret);\n    return WTERMSIG (ret) + 128;\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include \"ShellCommand.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include \"ShellCommand.h\"\n#include \"ycp/y2log.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string>\n#include <stdio.h>\n#include <errno.h>\n\nint\nshellcommand (const string &command, const string &tempdir)\n{\n    y2debug (\"shellcommand start\");\n\n    int ret = 0;\n\n    int pipe1[2];\n    if (pipe (pipe1))\n    {\n\ty2error (\"pipe failed, errno: %d\", errno);\n\treturn -1;\n    }\n\n    fflush (0);\n    pid_t log2 = fork ();\n\n    if (log2 == -1)\n    {\n\ty2error (\"fork failed, errno: %d\", errno);\n\treturn -1;\n    }\n    else if (log2)\n    {\n\t/* parent: collect stderr */\n\n\tFILE *err = 0;\n\tif (!tempdir.empty ())\n\t    err = fopen ((tempdir + \"/stderr\").c_str (), \"w\");\n\n\tchar s1[1024];\n\tFILE *stream1 = fdopen (pipe1[0], \"r\");\n\tif (stream1 == 0)\n\t{\n\t    y2error (\"stream1 fdopen error\");\n\t    return -1;\n\t}\n\tclose (pipe1[1]);\n\n\twhile (fgets (s1, 1024, stream1))\n\t{\n\t    if (err)\n\t\tfputs (s1, err);\n\n\t    /* Yes, this should be y2error but some external\n\t     * programs print normal messages via stderr\n\t     * bug reports are filed but who knows if such programs\n\t     * ever get fixed. Thus we set this temporarily to\n\t     * y2warning.\n\t     */\n\t    y2error (\"%s\", s1);\n\t}\n\n\tfclose (stream1);\n\n\tif (err)\n\t    fclose (err);\n    }\n    else\n    {\n\t/* 1st child: fork the command and collect stdout */\n\n\tExternalProgram::renumber_fd (pipe1[1], 2);\n\tclose (pipe1[0]);\n\n\tint pipe2[2];\n\tif (pipe (pipe2))\n\t{\n\t    y2error (\"pipe failed, errno: %d\", errno);\n\t    _exit (1);\n\t}\n\n\tfflush (0);\n\tpid_t child = fork ();\n\n\tif (child == -1)\n\t{\n\t    y2error (\"fork failed, errno: %d\", errno);\n\t    _exit (1);\n\t}\n\telse if (child)\n\t{\n\t    /* parent (1st child): collect stdout */\n\n\t    FILE *out = 0;\n\t    if (!tempdir.empty ())\n\t\tout = fopen ((tempdir + \"/stdout\").c_str (), \"w\");\n\n\t    char s2[1024];\n\t    FILE *stream2 = fdopen (pipe2[0], \"r\");\n\t    if (stream2 == 0)\n\t    {\n\t        y2error (\"stream2 fdopen error\");\n\t\t_exit (1);\n\t    }\n\t    close (pipe2[1]);\n\n\t    while (fgets (s2, 1024, stream2))\n\t    {\n\t\tif (out)\n\t\t    fputs (s2, out);\n\t\t//bnc#493152#c24\n\t\t//y2debug (\"%s\", s2);\n\t    }\n\n\t    fclose (stream2);\n\n\t    if (out)\n\t\tfclose (out);\n\n\t}\n\telse\n\t{\n\t    /* child of child: run the command */\n\n\t    ExternalProgram::renumber_fd (pipe2[1], 1);\n\t    close (pipe2[0]);\n\n\t    // #223602\n\t    // close all file descriptors above stderr\n\t    for ( int i = getdtablesize() - 1; i > 2; --i ) {\n\t\tclose( i );\n\t    }\n\t    \n\t    ret = system (command.c_str ());\n\t    if (WIFEXITED (ret))\n\t\tret = WEXITSTATUS (ret);\n\t    else\n\t\tret = WTERMSIG (ret) + 128;\n\n\t    //y2debug (\"Exit status is %d\", ret);\n\n\t    if (!tempdir.empty ())\n\t    {\n\t\tFILE *ex = fopen ((tempdir + \"/exit\").c_str (), \"w\");\n\t\tif (ex)\n\t\t{\n\t\t    fprintf (ex, \"%d\\n\", ret);\n\t\t    fclose (ex);\n\t\t}\n\t    }\n\n\t    _exit (ret);\n\t}\n\n\twaitpid (child, &ret, 0);\n\tif (WIFEXITED (ret))\n\t    _exit (WEXITSTATUS (ret));\n\t_exit (WTERMSIG (ret) + 128);\n    }\n\n    waitpid (log2, &ret, 0);\n\n    y2debug (\"shellcommand end\");\n\n    if (WIFEXITED (ret))\n\treturn WEXITSTATUS (ret);\n    return WTERMSIG (ret) + 128;\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"fork failed: %s\"",
            "strerror(errno)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "string (command + \" >/dev/null 2>&1 &\").c_str ()"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "command + \" >/dev/null 2>&1 &\""
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"Y2DEBUGALL\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"Y2DEBUGSHELL\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include \"ShellCommand.h\"\n#include \"ycp/y2log.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string>\n#include <stdio.h>\n#include <errno.h>\n\nint\nshellcommand_background (const string &command)\n{\n\n    if (!getenv (\"Y2DEBUGSHELL\") && !getenv (\"Y2DEBUGALL\"))\n    {\n\tsystem (string (command + \" >/dev/null 2>&1 &\").c_str ());\n\t// FIXME execl (\"/bin/sh\", \"-c\", command.c_str(), NULL);\n\treturn 0;\n    }\n\n    /* fork the child */\n    pid_t child = fork ();\n    if (child == -1)\n    {\n\ty2error(\"fork failed: %s\", strerror(errno));\n\treturn -1;\n    }\n\n    /* child process */\n    if (!child)\n    {\n\tshellcommand (command, \"\");\n\t_exit (0);\n    }\n\n    /* return success */\n    return 0;\n}"
  },
  {
    "function_name": "shellcommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/ShellCommand.cc",
    "lines": "28-186",
    "snippet": "int\nshellcommand (const string &command, const string &tempdir)\n{\n    y2debug (\"shellcommand start\");\n\n    int ret = 0;\n\n    int pipe1[2];\n    if (pipe (pipe1))\n    {\n\ty2error (\"pipe failed, errno: %d\", errno);\n\treturn -1;\n    }\n\n    fflush (0);\n    pid_t log2 = fork ();\n\n    if (log2 == -1)\n    {\n\ty2error (\"fork failed, errno: %d\", errno);\n\treturn -1;\n    }\n    else if (log2)\n    {\n\t/* parent: collect stderr */\n\n\tFILE *err = 0;\n\tif (!tempdir.empty ())\n\t    err = fopen ((tempdir + \"/stderr\").c_str (), \"w\");\n\n\tchar s1[1024];\n\tFILE *stream1 = fdopen (pipe1[0], \"r\");\n\tif (stream1 == 0)\n\t{\n\t    y2error (\"stream1 fdopen error\");\n\t    return -1;\n\t}\n\tclose (pipe1[1]);\n\n\twhile (fgets (s1, 1024, stream1))\n\t{\n\t    if (err)\n\t\tfputs (s1, err);\n\n\t    /* Yes, this should be y2error but some external\n\t     * programs print normal messages via stderr\n\t     * bug reports are filed but who knows if such programs\n\t     * ever get fixed. Thus we set this temporarily to\n\t     * y2warning.\n\t     */\n\t    y2error (\"%s\", s1);\n\t}\n\n\tfclose (stream1);\n\n\tif (err)\n\t    fclose (err);\n    }\n    else\n    {\n\t/* 1st child: fork the command and collect stdout */\n\n\tExternalProgram::renumber_fd (pipe1[1], 2);\n\tclose (pipe1[0]);\n\n\tint pipe2[2];\n\tif (pipe (pipe2))\n\t{\n\t    y2error (\"pipe failed, errno: %d\", errno);\n\t    _exit (1);\n\t}\n\n\tfflush (0);\n\tpid_t child = fork ();\n\n\tif (child == -1)\n\t{\n\t    y2error (\"fork failed, errno: %d\", errno);\n\t    _exit (1);\n\t}\n\telse if (child)\n\t{\n\t    /* parent (1st child): collect stdout */\n\n\t    FILE *out = 0;\n\t    if (!tempdir.empty ())\n\t\tout = fopen ((tempdir + \"/stdout\").c_str (), \"w\");\n\n\t    char s2[1024];\n\t    FILE *stream2 = fdopen (pipe2[0], \"r\");\n\t    if (stream2 == 0)\n\t    {\n\t        y2error (\"stream2 fdopen error\");\n\t\t_exit (1);\n\t    }\n\t    close (pipe2[1]);\n\n\t    while (fgets (s2, 1024, stream2))\n\t    {\n\t\tif (out)\n\t\t    fputs (s2, out);\n\t\t//bnc#493152#c24\n\t\t//y2debug (\"%s\", s2);\n\t    }\n\n\t    fclose (stream2);\n\n\t    if (out)\n\t\tfclose (out);\n\n\t}\n\telse\n\t{\n\t    /* child of child: run the command */\n\n\t    ExternalProgram::renumber_fd (pipe2[1], 1);\n\t    close (pipe2[0]);\n\n\t    // #223602\n\t    // close all file descriptors above stderr\n\t    for ( int i = getdtablesize() - 1; i > 2; --i ) {\n\t\tclose( i );\n\t    }\n\t    \n\t    ret = system (command.c_str ());\n\t    if (WIFEXITED (ret))\n\t\tret = WEXITSTATUS (ret);\n\t    else\n\t\tret = WTERMSIG (ret) + 128;\n\n\t    //y2debug (\"Exit status is %d\", ret);\n\n\t    if (!tempdir.empty ())\n\t    {\n\t\tFILE *ex = fopen ((tempdir + \"/exit\").c_str (), \"w\");\n\t\tif (ex)\n\t\t{\n\t\t    fprintf (ex, \"%d\\n\", ret);\n\t\t    fclose (ex);\n\t\t}\n\t    }\n\n\t    _exit (ret);\n\t}\n\n\twaitpid (child, &ret, 0);\n\tif (WIFEXITED (ret))\n\t    _exit (WEXITSTATUS (ret));\n\t_exit (WTERMSIG (ret) + 128);\n    }\n\n    waitpid (log2, &ret, 0);\n\n    y2debug (\"shellcommand end\");\n\n    if (WIFEXITED (ret))\n\treturn WEXITSTATUS (ret);\n    return WTERMSIG (ret) + 128;\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include \"ShellCommand.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "ret"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "ret"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "ret"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"shellcommand end\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "log2",
            "&ret",
            "0"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "WTERMSIG (ret) + 128"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "ret"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "WEXITSTATUS (ret)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "ret"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "ret"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "&ret",
            "0"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "ret"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "ex"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ex",
            "\"%d\\n\"",
            "ret"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "(tempdir + \"/exit\").c_str ()",
            "\"w\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tempdir.empty",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "ret"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "ret"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "ret"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "command.c_str ()"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command.c_str",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "i"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getdtablesize",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipe2[0]"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExternalProgram::renumber_fd",
          "args": [
            "pipe2[1]",
            "1"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "renumber_fd",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "425-435",
          "snippet": "void ExternalProgram::renumber_fd (int origfd, int newfd)\n{\n    // It may happen that origfd is already the one we want\n    // (Although in our circumstances, that would mean somebody has closed\n    // our stdin or stdout... weird but has appened to Cray, #49797)\n    if (origfd != newfd)\n    {\n\tdup2 (origfd, newfd);\n\t::close (origfd);\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  void ExternalProgram::renumber_fd (int origfd, int newfd)\n  {\n      // It may happen that origfd is already the one we want\n      // (Although in our circumstances, that would mean somebody has closed\n      // our stdin or stdout... weird but has appened to Cray, #49797)\n      if (origfd != newfd)\n      {\n  \tdup2 (origfd, newfd);\n  \t::close (origfd);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "out"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "stream2"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "s2",
            "out"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "s2",
            "1024",
            "stream2"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipe2[1]"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"stream2 fdopen error\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "pipe2[0]",
            "\"r\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "(tempdir + \"/stdout\").c_str ()",
            "\"w\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"fork failed, errno: %d\"",
            "errno"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "0"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"pipe failed, errno: %d\"",
            "errno"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipe2"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipe1[0]"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "err"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "stream1"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"%s\"",
            "s1"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "s1",
            "err"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "s1",
            "1024",
            "stream1"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipe1[1]"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"stream1 fdopen error\""
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "pipe1[0]",
            "\"r\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "(tempdir + \"/stderr\").c_str ()",
            "\"w\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"fork failed, errno: %d\"",
            "errno"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "0"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"pipe failed, errno: %d\"",
            "errno"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipe1"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"shellcommand start\""
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include \"ShellCommand.h\"\n#include \"ycp/y2log.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string>\n#include <stdio.h>\n#include <errno.h>\n\nint\nshellcommand (const string &command, const string &tempdir)\n{\n    y2debug (\"shellcommand start\");\n\n    int ret = 0;\n\n    int pipe1[2];\n    if (pipe (pipe1))\n    {\n\ty2error (\"pipe failed, errno: %d\", errno);\n\treturn -1;\n    }\n\n    fflush (0);\n    pid_t log2 = fork ();\n\n    if (log2 == -1)\n    {\n\ty2error (\"fork failed, errno: %d\", errno);\n\treturn -1;\n    }\n    else if (log2)\n    {\n\t/* parent: collect stderr */\n\n\tFILE *err = 0;\n\tif (!tempdir.empty ())\n\t    err = fopen ((tempdir + \"/stderr\").c_str (), \"w\");\n\n\tchar s1[1024];\n\tFILE *stream1 = fdopen (pipe1[0], \"r\");\n\tif (stream1 == 0)\n\t{\n\t    y2error (\"stream1 fdopen error\");\n\t    return -1;\n\t}\n\tclose (pipe1[1]);\n\n\twhile (fgets (s1, 1024, stream1))\n\t{\n\t    if (err)\n\t\tfputs (s1, err);\n\n\t    /* Yes, this should be y2error but some external\n\t     * programs print normal messages via stderr\n\t     * bug reports are filed but who knows if such programs\n\t     * ever get fixed. Thus we set this temporarily to\n\t     * y2warning.\n\t     */\n\t    y2error (\"%s\", s1);\n\t}\n\n\tfclose (stream1);\n\n\tif (err)\n\t    fclose (err);\n    }\n    else\n    {\n\t/* 1st child: fork the command and collect stdout */\n\n\tExternalProgram::renumber_fd (pipe1[1], 2);\n\tclose (pipe1[0]);\n\n\tint pipe2[2];\n\tif (pipe (pipe2))\n\t{\n\t    y2error (\"pipe failed, errno: %d\", errno);\n\t    _exit (1);\n\t}\n\n\tfflush (0);\n\tpid_t child = fork ();\n\n\tif (child == -1)\n\t{\n\t    y2error (\"fork failed, errno: %d\", errno);\n\t    _exit (1);\n\t}\n\telse if (child)\n\t{\n\t    /* parent (1st child): collect stdout */\n\n\t    FILE *out = 0;\n\t    if (!tempdir.empty ())\n\t\tout = fopen ((tempdir + \"/stdout\").c_str (), \"w\");\n\n\t    char s2[1024];\n\t    FILE *stream2 = fdopen (pipe2[0], \"r\");\n\t    if (stream2 == 0)\n\t    {\n\t        y2error (\"stream2 fdopen error\");\n\t\t_exit (1);\n\t    }\n\t    close (pipe2[1]);\n\n\t    while (fgets (s2, 1024, stream2))\n\t    {\n\t\tif (out)\n\t\t    fputs (s2, out);\n\t\t//bnc#493152#c24\n\t\t//y2debug (\"%s\", s2);\n\t    }\n\n\t    fclose (stream2);\n\n\t    if (out)\n\t\tfclose (out);\n\n\t}\n\telse\n\t{\n\t    /* child of child: run the command */\n\n\t    ExternalProgram::renumber_fd (pipe2[1], 1);\n\t    close (pipe2[0]);\n\n\t    // #223602\n\t    // close all file descriptors above stderr\n\t    for ( int i = getdtablesize() - 1; i > 2; --i ) {\n\t\tclose( i );\n\t    }\n\t    \n\t    ret = system (command.c_str ());\n\t    if (WIFEXITED (ret))\n\t\tret = WEXITSTATUS (ret);\n\t    else\n\t\tret = WTERMSIG (ret) + 128;\n\n\t    //y2debug (\"Exit status is %d\", ret);\n\n\t    if (!tempdir.empty ())\n\t    {\n\t\tFILE *ex = fopen ((tempdir + \"/exit\").c_str (), \"w\");\n\t\tif (ex)\n\t\t{\n\t\t    fprintf (ex, \"%d\\n\", ret);\n\t\t    fclose (ex);\n\t\t}\n\t    }\n\n\t    _exit (ret);\n\t}\n\n\twaitpid (child, &ret, 0);\n\tif (WIFEXITED (ret))\n\t    _exit (WEXITSTATUS (ret));\n\t_exit (WTERMSIG (ret) + 128);\n    }\n\n    waitpid (log2, &ret, 0);\n\n    y2debug (\"shellcommand end\");\n\n    if (WIFEXITED (ret))\n\treturn WEXITSTATUS (ret);\n    return WTERMSIG (ret) + 128;\n}"
  }
]