[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "1145-1488",
    "snippet": "int main(int argc, char *argv[])\n{\n    int i = 0, ret = 0;\n\n    bool log_set = false;\n\n    YCPPathSearch::initialize ();\n\n    // list of -I / -M pathes\n    //   will be pushed to YCPPathSearch later to keep correct order\n    //   (the last added path to YCPPathSearch will be searched first)\n    std::list<std::string> modpathes;\n    std::list<std::string> incpathes;\n\n    for(;;)\n    {\n\tint option_index = 0;\n\n\tstatic struct option options[] =\n\t{\n\t    {\"compile\", 0, 0, 'c'},\t\t\t// compile to bytecode\n\t    {\"no-implicit-imports\", 0, 0, 'd'},\t\t// don't preload implicit namespaces\n\t    {\"fsyntax-only\", 0, 0, 'E'},\t\t// parse only\n\t    {\"freshen\", 0, 0, 'f'},\t\t\t// freshen .ybc files\n\t    {\"Force\", 0, 0, 'F'},\t\t\t// force recompile of all dependant files\n\t    {\"help\", 0, 0, 'h'},\t\t\t// show help and exit\n\t    {\"include-path\", 1, 0, 'I'},\t\t// where to find include files\n\t    {\"module-path\", 1, 0, 'M'},\t\t\t// where to find module files\n\t    {\"no-std-includes\", 0, 0, 257},\t\t// drop all built-in include pathes\n\t    {\"no-std-modules\", 0, 0, 258},\t\t// drop all built-in module pathes\n\t    {\"nostdincludes\", 0, 0, 257},\t\t// drop all built-in include pathes\n\t    {\"nostdmodules\", 0, 0, 258},\t\t// drop all built-in module pathes\n\t    {\"log-file\", 1, 0, 'l'},\t\t\t// specify log file\n\t    {\"logfile\", 1, 0, 'l'},\t\t\t// specify log file\n\t    {\"no-std-path\", 0, 0, 'n'},\t\t\t// no standard pathes\n\t    {\"no-std-paths\", 0, 0, 'n'},\t\t// no standard pathes\n\t    {\"output\", 1, 0, 'o'},\t\t\t// output file\n\t    {\"print\", 0, 0, 'p'},\t\t\t// read & print bytecode\n\t    {\"run\", 0, 0, 'r'},\t\t\t\t// read & run bytecode\n\t    {\"quiet\", 0, 0, 'q'},\t\t\t// no output\n\t    {\"recursive\", 0, 0, 'R'},\t\t\t// recursively\n\t    {\"test\", 0, 0, 't'},\t\t\t// lots of output\n\t    {\"ui\", 1, 0, 'u' },\t\t\t\t// UI to start in combination with 'r'\n\t    {\"version\", 0, 0, 'v'},\t\t\t// show version and exit\n\t    {\"xml\", 0, 0, 'x'},\t\t\t\t// output XML insteaf of Bytecode\n\t    {0, 0, 0, 0}\n\t};\n\n\tint c = getopt_long (argc, argv, \"h?vxVnpqrtRdEcFfI:M:o:l:u:\", options, &option_index);\n\tif (c == EOF) break;\n\n\tswitch (c)\n\t{\n\t    case 257:\n\t\tYCPPathSearch::clearPaths (YCPPathSearch::Include);\n\t    break;\n\t    case 258:\n\t\tYCPPathSearch::clearPaths (YCPPathSearch::Module);\n\t    break;\n\t    case 'h':\n\t    case '?':\n\t\tprint_help (\"ycpc\");\n\t\texit (0);\n\t    case 'v':\n\t    case 'V':\n\t\tprint_version ();\n\t\texit (0);\n\t    case 'r':\n\t\tread_n_run = 1;\n\t\tbreak;\n\t    case 'R':\n\t\tif (outname != NULL)\n\t\t{\n\t\t    fprintf (stderr, \"-%c mutually exclusive with -c\\n\", c);\n\t\t    exit (1);\n\t\t}\n\t\trecursive = 1;\n\t\tbreak;\n\t    case 'q':\n\t\tquiet = 1;\n\t\tbreak;\n\t    case 'E':\n\t\tparse = 1;\n\t\tif (compile != 0)\n\t\t{\n\t\t    fprintf (stderr, \"-E mutually exclusive with -c\\n\");\n\t\t    exit (1);\n\t\t}\n\t\tbreak;\n\t    case 'c':\n\t\tcompile = 1;\n\t\tif (parse != 0)\n\t\t{\n\t\t    fprintf (stderr, \"-c mutually exclusive with -E\\n\");\n\t\t    exit (1);\n\t\t}\n\t\tbreak;\n\t    case 'f':\n\t\tfreshen = 1;\n\t\tbreak;\n\t    case 'F':\n\t\tforce = 1;\n\t\tbreak;\n\t    case 'I':\n\t\tincpathes.push_front (string (optarg));\t\t// push to front so first one is last in list\n\t\tbreak;\n\t    case 'M':\n\t\tmodpathes.push_front (string (optarg));\t\t// dito\n\t\tbreak;\n\t    case 'l':\n\t\tset_log_filename (optarg);\n\t\tlog_set = true;\n\t\tbreak;\n\t    case 'o':\n\t\tif (recursive)\n\t\t{\n\t\t    fprintf (stderr, \"-o mutually exclusive with -r\\n\");\n\t\t    exit (1);\n\t\t}\n\t\toutname = strdup (optarg);\n\t\tbreak;\n\t    case 'd':\n\t\tno_implicit_namespaces = 1;\n\t\tbreak;\n\t    case 'n':\n\t\tno_std_path = 1;\n\t\tbreak;\n\t    case 't':\n\t\tverbose += 1;\n\t\tbreak;\n\t    case 'p':\n\t\tread_n_print = 1;\n\t\tbreak;\n\t    case 'u':\n\t\tui_name = strdup (optarg);\n\t\tbreak;\n\t    case 'x':\n\t\tto_xml = 1;\n\t\tbreak;\n\t    default:\n\t\tfprintf (stderr, \"Try `%s -h' for more information.\\n\", argv[0]);\n\t\texit(1);\n\t}\n    }\n\n    // setup log\n    if (!log_set)\n    {\n\t// user didn't setup log, use stdout\n\tset_log_filename(\"-\");\n    }\n    set_log_simple_mode (true);\n\n    // add include and module pathes to YCPPathSearch so that the argument order is kept\n\n    std::list<std::string>::iterator pathit;\n    for (pathit = incpathes.begin(); pathit != incpathes.end(); pathit++)\n    {\n\tYCPPathSearch::addPath (YCPPathSearch::Include, pathit->c_str());\n    }\n    for (pathit = modpathes.begin(); pathit != modpathes.end(); pathit++)\n    {\n\tYCPPathSearch::addPath (YCPPathSearch::Module, pathit->c_str());\n    }\n\n    // register builtins\n    SCR scr;\n    WFM wfm;\n\n    if ((compile == parse)\t\t// both are zero\n\t&& (compile == freshen)\n\t&& (compile == read_n_print)\n\t&& (compile == read_n_run))\n    {\n\tfprintf (stderr, \"-c, -E, -f, -p or -r must be given\\n\");\n\texit (1);\n    }\n\n    if (optind == argc)\n    {\n\tfprintf (stderr, \"No input file or directory given\\n\");\n\texit (1);\n    }\n\n    if (read_n_run\t\t\t// if no explicit UI name given for run\n\t&& ui_name == 0)\t\t//   try to determine one according to $DISPLAY\n    {\n\tchar *display = getenv (\"DISPLAY\");\n\tif (display == 0\n\t    || *display == 0)\n\t{\n\t    ui_name = UI_NCURSES_NAME;\n\t}\n\telse\n\t{\n\t    ui_name = UI_QT_NAME;\n\t}\n    }\n\n    std::list <FileDep> deplist;\n\n    for (i = optind; i < argc;i++)\n    {\n\tif (freshen)\n\t{\n\t    std::list <FileDep> depdir = makeDirList (argv[i]);\n\n\t    if (depdir.empty())\n\t    {\n\t\tfprintf (stderr, \"Can't check dependencies below %s\\nNot a directory ?\\n\", argv[i]);\n\t\treturn 1;\n\t    }\n\n\t    std::list<FileDep>::iterator it;\n\n\t    for (it = depdir.begin(); it != depdir.end(); it++)\n\t    {\n\t\tif (verbose > 1) printf (\"Add %s to deplist\\n\", it->path().c_str());\n\t\tdeplist.push_back (*it);\n\t    }\n\t}\n\telse if (recursive)\n\t{\n\t    if (!compile)\n\t    {\n\t\tif (recurse (argv[i]))\n\t\t{\n\t\t    ret = 1;\n\t\t}\n\t        continue;\n\t    }\n\t    \n\t    ret = compilefile (argv[i], 0);\n\n\t    if (ret == 1)\n\t    {\n\t\tfprintf (stderr, \"Compilation of '%s' failed: %s\\n\", argv[i], strerror (errno));\n\t\tbreak;\n\t    }\n\t    else if (ret == 2)\n\t    {\n\t\tfprintf (stderr, \"Compilation of '%s' failed\\n\", argv[i]);\n\t\tbreak;\n\t    }\n\t    ret = 0;\n\t}\n\telse\n\t{\n\t    if (processfile (argv[i], outname))\n\t    {\n\t\tret = 1;\n\t    }\n\t}\n    }\n\n    if (freshen)\n    {\n\tstd::map <std::string, std::list <FileDep> > depmap = makeDependMap (deplist);\n\n\tif (verbose) printf (\"Map generated, %zu entries, computing order\\n\", depmap.size());\n\n\tif (depmap.empty())\n\t{\n\t    fprintf (stderr, \"No files or dependencies found\\n\");\n\t    return 1;\n\t}\n\n\t// loop over all modules and generated a fake module \"*\" which depends on all other modules\n\n\tstd::map <std::string, std::list <FileDep> >::iterator modit;\n\tdeplist.clear();\n\tfor (modit = depmap.begin(); modit != depmap.end(); modit++)\n\t{\n\t    if (verbose > 2) printf (\"Entry %s \", modit->first.c_str());\n\t    if (modit->second.empty())\n\t    {\n\t\tfprintf (stderr, \"Entry '%s' has no description\\n\", modit->first.c_str());\n\t\tcontinue;\n\t    }\n\t    if (verbose > 2) printf (\" -> %s\\n\", modit->second.front().toString().c_str());\n\t    if (modit->second.front().is_module())\n\t    {\n\t\tdeplist.push_back (modit->second.front());\n\t\tif (verbose > 1) printf (\"Module %s\\n\", modit->first.c_str());\n\t    }\n\t}\n\tdepmap[\"*\"] = deplist;\n\n\tdeplist = depTree (\"*\", depmap);\n\n\tif (deplist.empty())\n\t{\n\t    fprintf (stderr, \"No depencies found\\n\");\n\t    exit (1);\n\t}\n\tstd::list <FileDep>::iterator depit;\n\n\tdepit = deplist.end();\n\tdepit--;\t\t\t\t\t// get last element, existance is guaranteed\n\ttime_t starttime = depit->bintime() == 0 ? depit->srctime() : depit->bintime();\n\tstring startname = depit->name();\n\n\tfor (depit = deplist.begin(); depit != deplist.end(); depit++)\n\t{\n\t    if (depit->srctime() > starttime)\n\t    {\n\t\tprintf (\"%s is newer than %s\\n\", depit->toString().c_str(), startname.c_str());\n\t\ttime (&starttime);\n\t    }\n\n\t    if (!depit->is_module())\n\t    {\n\t\tcontinue;\n\t    }\n\t    if (compile)\n\t    {\n\t\terrno = 0;\n\t\t\n\t\tret = compilefile (depit->path().c_str(), NULL);\n\t\tif (ret == 1)\n\t\t{\n\t\t    fprintf (stderr, \"Compilation failed for %s: %s\\n\", depit->path().c_str(), strerror (errno));\n\t\t    break;\n\t\t}\n\t\telse if (ret == 2)\n\t\t{\n\t\t    fprintf (stderr, \"Compilation failed for %s\\n\", depit->path().c_str());\n\t\t    break;\n\t\t}\n\n\t\tret = 0;\n\t    }\n\t    else\n\t    {\n\t\tprintf (\"%s\\n\", depit->name().c_str());\n\t    }\n\t}\n    }\n    else\n    {\n        if (verbose) printf (\"Done\\n\");\n    }\n    return ret;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [
      "#define UI_NCURSES_NAME \"ncurses\"",
      "#define UI_QT_NAME \"qt\""
    ],
    "globals_used": [
      "static char *outname = NULL;",
      "static int quiet = 0;",
      "static int verbose = 0;",
      "static int no_std_path = 0;",
      "static int recursive = 0;",
      "static int parse = 0;",
      "static int compile = 0;",
      "static int to_xml = 0;",
      "static int read_n_print = 0;",
      "static int read_n_run = 0;",
      "static int freshen = 0;",
      "static int force = 0;",
      "static int no_implicit_namespaces = 0;",
      "static const char *ui_name = 0;",
      "static recurseT *recurseStart (const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Done\\n\""
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "depit->name().c_str()"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depit->name",
          "args": [],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2AgentComp",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "44-44",
          "snippet": "string name () const { return my_name; }",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp {\n  string name () const { return my_name; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Compilation failed for %s\\n\"",
            "depit->path().c_str()"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depit->path",
          "args": [],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depit->path",
          "args": [],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Compilation failed for %s: %s\\n\"",
            "depit->path().c_str()",
            "strerror (errno)"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depit->path",
          "args": [],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depit->path",
          "args": [],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compilefile",
          "args": [
            "depit->path().c_str()",
            "NULL"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "compilefile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "905-944",
          "snippet": "int\ncompilefile (const char *infname, const char *outfname)\n{\n    string ofname = infname;\n\n    if (outfname != NULL)\n    {\n\tofname = outfname;\n    }\n    else\n    {\n\tint len = ofname.size ();\n\tif (len > 4 && ofname.substr (len-4, 4) == \".ycp\")\n\t{\n\t    ofname = ofname.replace (len-4, 4, to_xml ? \".xml\" : \".ybc\");\n\t}\n\telse\n\t{\n\t    ofname += to_xml ? \".xml\" : \".ybc\";\n\t}\n    }\n    progress (\"compiling to '%s'\\n\", ofname.c_str ());\n\n    YCodePtr c = parsefile (infname);\n\n    if (c != NULL )\n    {\n\tprogress (\"saving ...\\n\");\n\tint result = 0;\n\tif (to_xml) {\n\t    result = Xmlcode::writeFile (c, ofname);\n\t}\n\telse {\n\t    result = Bytecode::writeFile (c, ofname);\n\t}\n\treturn result ? 0 : 1;\n    }\n\n    return 2;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int to_xml = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic int to_xml = 0;\n\nint\ncompilefile (const char *infname, const char *outfname)\n{\n    string ofname = infname;\n\n    if (outfname != NULL)\n    {\n\tofname = outfname;\n    }\n    else\n    {\n\tint len = ofname.size ();\n\tif (len > 4 && ofname.substr (len-4, 4) == \".ycp\")\n\t{\n\t    ofname = ofname.replace (len-4, 4, to_xml ? \".xml\" : \".ybc\");\n\t}\n\telse\n\t{\n\t    ofname += to_xml ? \".xml\" : \".ybc\";\n\t}\n    }\n    progress (\"compiling to '%s'\\n\", ofname.c_str ());\n\n    YCodePtr c = parsefile (infname);\n\n    if (c != NULL )\n    {\n\tprogress (\"saving ...\\n\");\n\tint result = 0;\n\tif (to_xml) {\n\t    result = Xmlcode::writeFile (c, ofname);\n\t}\n\telse {\n\t    result = Bytecode::writeFile (c, ofname);\n\t}\n\treturn result ? 0 : 1;\n    }\n\n    return 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "depit->path",
          "args": [],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depit->path",
          "args": [],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depit->is_module",
          "args": [],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "is_module",
          "container": "FileDep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "319-323",
          "snippet": "bool\nFileDep::is_module () const\n{\n    return m_is_module;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nFileDep {\n  bool\n  FileDep::is_module () const\n  {\n      return m_is_module;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "&starttime"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s is newer than %s\\n\"",
            "depit->toString().c_str()",
            "startname.c_str()"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "startname.c_str",
          "args": [],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depit->toString",
          "args": [],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FileDep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "326-333",
          "snippet": "std::string\nFileDep::toString () const\n{\n    return string (m_is_module ? \"module \\\"\" : \"include \\\"\")\n\t    + m_name\n\t    + string (\"\\\" at '\")\n\t    + m_path + string (\"'\");\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nFileDep {\n  std::string\n  FileDep::toString () const\n  {\n      return string (m_is_module ? \"module \\\"\" : \"include \\\"\")\n  \t    + m_name\n  \t    + string (\"\\\" at '\")\n  \t    + m_path + string (\"'\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "depit->srctime",
          "args": [],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "srctime",
          "container": "FileDep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "298-302",
          "snippet": "time_t\nFileDep::srctime () const\n{\n    return m_srctime;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nFileDep {\n  time_t\n  FileDep::srctime () const\n  {\n      return m_srctime;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "deplist.end",
          "args": [],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "deplist.begin",
          "args": [],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "depit->bintime",
          "args": [],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "bintime",
          "container": "FileDep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "305-309",
          "snippet": "time_t\nFileDep::bintime () const\n{\n    return m_bintime;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nFileDep {\n  time_t\n  FileDep::bintime () const\n  {\n      return m_bintime;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"No depencies found\\n\""
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deplist.empty",
          "args": [],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "depTree",
          "args": [
            "\"*\"",
            "depmap"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "depTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "711-802",
          "snippet": "std::list<FileDep>\ndepTree (std::string module, const std::map<std::string, std::list<FileDep> > & depmap)\n{\n    static std::map<std::string, int> seenmap;\n    std::list<FileDep> ret;\n\n    if (verbose > 1) printf (\"depTree (%s)\\n\", module.c_str());\n\n    if (module.empty())\n    {\n\tif (verbose > 1) printf (\"initialize\\n\");\n\tseenmap.clear();\n\tif (depmap.empty())\n\t{\n\t    fprintf (stderr, \"No dependencies found\\n\");\n\t}\n\treturn ret;\n    }\n\n    if (seenmap.find (module) != seenmap.end())\t\t// already seen this module\n    {\n\tif (verbose > 1) printf (\"-- already seen %s\\n\", module.c_str());\n\treturn ret;\n    }\n\n    seenmap[module] = 1;\n\n    std::map<std::string, std::list<FileDep> >::const_iterator it = depmap.find (module);\n\n    if (it == depmap.end())\n    {\n\tfprintf (stderr, \"Can't find '%s' in dependency map\\n\", module.c_str());\n\treturn ret;\n    }\n\n    if (verbose > 1) printf (\"\\nCheck '%s': \", module.c_str()); fflush (stdout);\n\n    std::list<FileDep> dl = it->second;\t\t// get <mod> <imp> <imp> <imp> list\n\n    if (dl.size() == 0)\n    {\n\tfprintf (stderr, \"%s not a module ?\\n\", module.c_str());\n\treturn ret;\n    }\n    else if (dl.size() < 2)\t\t\t\t// no further dependencies\n    {\n\tif (verbose > 1) printf (\"-- leaf\\n\");\n\treturn ret;\n    }\n\n    // recurse dependencies\n\n    // first push all dependencies for the current module\n\n    std::list<FileDep>::iterator dli = dl.begin();\n    dli++;\t\t\t\t\t\t// skip initial module\n\n    while (dli != dl.end())\n    {\n\tstd::string name = dli->name();\n\tif (seenmap.find (name) == seenmap.end())\t\t// not seen this name before\n\t{\n\t    if (verbose > 1) printf (\"%s -> %s: \", module.c_str(), name.c_str());\n\t    std::list<FileDep> l = depTree (name, depmap);\t// recusion point\n\t    if (verbose > 1) printf (\"%s -> %s done\\n\", module.c_str(), name.c_str());\n\n\t    std::list<FileDep>::iterator it;\n\t    for (it = l.begin(); it != l.end(); it++)\n\t    {\n\t\tret.push_back (*it);\n\t    }\n\n\t    // then push the current name\n\n\t    ret.push_back (*dli);\n\t}\n\n\tdli++;\n    }\n\n    if (verbose > 1)\n    {\n\tprintf (\"(%s:\", module.c_str()); fflush (stdout);\n\tstd::list<FileDep>::iterator rit;\n\tfor (rit = ret.begin(); rit != ret.end(); rit++)\n\t{\n\t    printf (\" %s\", rit->name().c_str());\n\t}\n\tprintf (\")\\n\");\n    }\n    return ret;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int verbose = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic int verbose = 0;\n\nstd::list<FileDep>\ndepTree (std::string module, const std::map<std::string, std::list<FileDep> > & depmap)\n{\n    static std::map<std::string, int> seenmap;\n    std::list<FileDep> ret;\n\n    if (verbose > 1) printf (\"depTree (%s)\\n\", module.c_str());\n\n    if (module.empty())\n    {\n\tif (verbose > 1) printf (\"initialize\\n\");\n\tseenmap.clear();\n\tif (depmap.empty())\n\t{\n\t    fprintf (stderr, \"No dependencies found\\n\");\n\t}\n\treturn ret;\n    }\n\n    if (seenmap.find (module) != seenmap.end())\t\t// already seen this module\n    {\n\tif (verbose > 1) printf (\"-- already seen %s\\n\", module.c_str());\n\treturn ret;\n    }\n\n    seenmap[module] = 1;\n\n    std::map<std::string, std::list<FileDep> >::const_iterator it = depmap.find (module);\n\n    if (it == depmap.end())\n    {\n\tfprintf (stderr, \"Can't find '%s' in dependency map\\n\", module.c_str());\n\treturn ret;\n    }\n\n    if (verbose > 1) printf (\"\\nCheck '%s': \", module.c_str()); fflush (stdout);\n\n    std::list<FileDep> dl = it->second;\t\t// get <mod> <imp> <imp> <imp> list\n\n    if (dl.size() == 0)\n    {\n\tfprintf (stderr, \"%s not a module ?\\n\", module.c_str());\n\treturn ret;\n    }\n    else if (dl.size() < 2)\t\t\t\t// no further dependencies\n    {\n\tif (verbose > 1) printf (\"-- leaf\\n\");\n\treturn ret;\n    }\n\n    // recurse dependencies\n\n    // first push all dependencies for the current module\n\n    std::list<FileDep>::iterator dli = dl.begin();\n    dli++;\t\t\t\t\t\t// skip initial module\n\n    while (dli != dl.end())\n    {\n\tstd::string name = dli->name();\n\tif (seenmap.find (name) == seenmap.end())\t\t// not seen this name before\n\t{\n\t    if (verbose > 1) printf (\"%s -> %s: \", module.c_str(), name.c_str());\n\t    std::list<FileDep> l = depTree (name, depmap);\t// recusion point\n\t    if (verbose > 1) printf (\"%s -> %s done\\n\", module.c_str(), name.c_str());\n\n\t    std::list<FileDep>::iterator it;\n\t    for (it = l.begin(); it != l.end(); it++)\n\t    {\n\t\tret.push_back (*it);\n\t    }\n\n\t    // then push the current name\n\n\t    ret.push_back (*dli);\n\t}\n\n\tdli++;\n    }\n\n    if (verbose > 1)\n    {\n\tprintf (\"(%s:\", module.c_str()); fflush (stdout);\n\tstd::list<FileDep>::iterator rit;\n\tfor (rit = ret.begin(); rit != ret.end(); rit++)\n\t{\n\t    printf (\" %s\", rit->name().c_str());\n\t}\n\tprintf (\")\\n\");\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Module %s\\n\"",
            "modit->first.c_str()"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modit->first.c_str",
          "args": [],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deplist.push_back",
          "args": [
            "modit->second.front()"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modit->second.front",
          "args": [],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modit->second.front",
          "args": [],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modit->second.front",
          "args": [],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" -> %s\\n\"",
            "modit->second.front().toString().c_str()"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modit->second.front",
          "args": [],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modit->second.front",
          "args": [],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modit->second.front",
          "args": [],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Entry '%s' has no description\\n\"",
            "modit->first.c_str()"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modit->first.c_str",
          "args": [],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Entry %s \"",
            "modit->first.c_str()"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modit->first.c_str",
          "args": [],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deplist.clear",
          "args": [],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/PathInfo.h",
          "lines": "461-461",
          "snippet": "void clear() { _devino.clear(); }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <map>",
            "#include <set>",
            "#include <list>",
            "#include <iosfwd>",
            "#include <cerrno>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <map>\n#include <set>\n#include <list>\n#include <iosfwd>\n#include <cerrno>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid clear() { _devino.clear(); }"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"No files or dependencies found\\n\""
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Map generated, %zu entries, computing order\\n\"",
            "depmap.size()"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depmap.size",
          "args": [],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeDependMap",
          "args": [
            "deplist"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "makeDependMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "609-702",
          "snippet": "std::map <std::string, std::list <FileDep> >\nmakeDependMap (const std::list<FileDep> & dep)\n{\n    if (verbose) printf (\"makeDependMap (), %zu files\\n\", dep.size());\n\n    std::map <std::string, std::list <FileDep> > depmap;\n\n    if (dep.empty())\n    {\n\tfprintf (stderr, \"makeDependMap, empty input!\\n\");\n\treturn depmap;\n    }\n\n    std::list<FileDep>::const_iterator depit;\n    std::list<FileDep> resolved;\n\n    for (depit = dep.begin(); depit != dep.end(); depit++)\n    {\n\tresolved = parseFile (depit->path().c_str(), depit->name().c_str());\n\tif (resolved.empty())\n\t{\n\t    fprintf (stderr, \"Couldn't parse file '%s'\\n\", depit->path().c_str());\n\t    continue;\n\t}\n\n\tdepmap[resolved.front().name()] = resolved;\n\n\tif (verbose > 2)\n\t{\n\t    printf (\"Map %s: %zu entries\\n\", resolved.front().name().c_str(), resolved.size());\n\t}\n\n\tif (verbose > 1)\n\t{\n\t    std::list<FileDep>::iterator resit = resolved.begin();\n\t    printf (\"%s needs \", resit->toString().c_str());\n\t    resit++;\n\t    if (resit == resolved.end())\n\t    {\n\t\tprintf (\"nothing\");\n\t    }\n\t    else while (resit != resolved.end())\n\t    {\n\t\tprintf (\"\\n\\t%s\", resit->toString().c_str());\n\t\tresit++;\n\t    }\n\t    printf (\"\\n\");\n\t}\n    }\n\n    // now go through all map entries and resolve them\n    std::map <std::string, std::list <FileDep> >::iterator mapit;\n    bool found_unsolved = true;\n    while (found_unsolved)\n    {\n\tstd::list<FileDep>::iterator depit;\n\n\tfound_unsolved = false;\n\n\tif (depmap.empty())\n\t{\n\t    fprintf (stderr, \"Empty map ?!\\n\");\n\t    break;\n\t}\n\n\tfor (mapit = depmap.begin(); mapit != depmap.end(); mapit++)\n\t{\n\t    if (mapit->second.empty())\n\t    {\n\t\tfprintf (stderr, \"Map entry %s empty !\\n\", mapit->first.c_str());\n\t\tbreak;\n\t    }\n\t    for (depit = mapit->second.begin(); depit != mapit->second.end(); depit++)\n\t    {\n\t\tif (depmap.find (depit->name()) == depmap.end())\n\t\t{\n\t\t    resolved = parseFile (depit->path().c_str(), depit->name().c_str());\n\t\t    if (resolved.empty())\n\t\t    {\n\t\t\tfprintf (stderr, \"Couldn't parse file '%s'\\n\", depit->path().c_str());\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (verbose > 1) printf (\"Solved %s as %s\\n\", depit->name().c_str(), resolved.front().name().c_str());\n\t\t    depmap[resolved.front().name()] = resolved;\n\t\t    found_unsolved = true;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (found_unsolved) break;\n\t}\n    }\n\n    return depmap;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int verbose = 0;",
            "static int parse = 0;",
            "static recurseT *recurseStart (const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic int verbose = 0;\nstatic int parse = 0;\nstatic recurseT *recurseStart (const char *path);\n\nstd::map <std::string, std::list <FileDep> >\nmakeDependMap (const std::list<FileDep> & dep)\n{\n    if (verbose) printf (\"makeDependMap (), %zu files\\n\", dep.size());\n\n    std::map <std::string, std::list <FileDep> > depmap;\n\n    if (dep.empty())\n    {\n\tfprintf (stderr, \"makeDependMap, empty input!\\n\");\n\treturn depmap;\n    }\n\n    std::list<FileDep>::const_iterator depit;\n    std::list<FileDep> resolved;\n\n    for (depit = dep.begin(); depit != dep.end(); depit++)\n    {\n\tresolved = parseFile (depit->path().c_str(), depit->name().c_str());\n\tif (resolved.empty())\n\t{\n\t    fprintf (stderr, \"Couldn't parse file '%s'\\n\", depit->path().c_str());\n\t    continue;\n\t}\n\n\tdepmap[resolved.front().name()] = resolved;\n\n\tif (verbose > 2)\n\t{\n\t    printf (\"Map %s: %zu entries\\n\", resolved.front().name().c_str(), resolved.size());\n\t}\n\n\tif (verbose > 1)\n\t{\n\t    std::list<FileDep>::iterator resit = resolved.begin();\n\t    printf (\"%s needs \", resit->toString().c_str());\n\t    resit++;\n\t    if (resit == resolved.end())\n\t    {\n\t\tprintf (\"nothing\");\n\t    }\n\t    else while (resit != resolved.end())\n\t    {\n\t\tprintf (\"\\n\\t%s\", resit->toString().c_str());\n\t\tresit++;\n\t    }\n\t    printf (\"\\n\");\n\t}\n    }\n\n    // now go through all map entries and resolve them\n    std::map <std::string, std::list <FileDep> >::iterator mapit;\n    bool found_unsolved = true;\n    while (found_unsolved)\n    {\n\tstd::list<FileDep>::iterator depit;\n\n\tfound_unsolved = false;\n\n\tif (depmap.empty())\n\t{\n\t    fprintf (stderr, \"Empty map ?!\\n\");\n\t    break;\n\t}\n\n\tfor (mapit = depmap.begin(); mapit != depmap.end(); mapit++)\n\t{\n\t    if (mapit->second.empty())\n\t    {\n\t\tfprintf (stderr, \"Map entry %s empty !\\n\", mapit->first.c_str());\n\t\tbreak;\n\t    }\n\t    for (depit = mapit->second.begin(); depit != mapit->second.end(); depit++)\n\t    {\n\t\tif (depmap.find (depit->name()) == depmap.end())\n\t\t{\n\t\t    resolved = parseFile (depit->path().c_str(), depit->name().c_str());\n\t\t    if (resolved.empty())\n\t\t    {\n\t\t\tfprintf (stderr, \"Couldn't parse file '%s'\\n\", depit->path().c_str());\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (verbose > 1) printf (\"Solved %s as %s\\n\", depit->name().c_str(), resolved.front().name().c_str());\n\t\t    depmap[resolved.front().name()] = resolved;\n\t\t    found_unsolved = true;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (found_unsolved) break;\n\t}\n    }\n\n    return depmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "processfile",
          "args": [
            "argv[i]",
            "outname"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "processfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "992-1046",
          "snippet": "int\nprocessfile (const char *infname, const char *outfname)\n{\n    if (compile)\n    {\n\treturn compilefile (infname, outfname);\n    }\n\n    if (parse)\n    {\n\tYCodePtr c = parsefile (infname);\n\n\tif (c == NULL) return 1;\n\n\tif (quiet) return 0;\n\n\treturn printcode (outfname, c);\n    }\n\n    if (read_n_print)\n    {\n\tprogress (\"Reading: %s\\n\", infname);\n\tYCodePtr c = Bytecode::readFile (infname);\n\tif (c == 0)\n\t{\n\t    progress (\"Bytecode read failed\\n\");\n\t    return 1;\n\t}\n\n\tprogress (\"Result:\\n\");\n\n\treturn printcode (outfname, c);\n    }\n\n    if (read_n_run)\n    {\n\tprogress (\"Reading:\\n\");\n\tYCodePtr c = Bytecode::readFile (infname);\n\tprogress (\"Running:\\n\");\n\n\tY2Component *server = Y2ComponentBroker::createServer (ui_name);\n\tif (!server)\n\t{\n\t    fprintf (stderr, \"Can't start UI component '%s'\", ui_name);\n\t    return 1;\n\t}\n\n\tYCPValue result = c->evaluate();\n\tprogress (\"Result:\\n\");\n\n\treturn printcode (outfname, result);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int quiet = 0;",
            "static int parse = 0;",
            "static int compile = 0;",
            "static int read_n_print = 0;",
            "static int read_n_run = 0;",
            "static const char *ui_name = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic int quiet = 0;\nstatic int parse = 0;\nstatic int compile = 0;\nstatic int read_n_print = 0;\nstatic int read_n_run = 0;\nstatic const char *ui_name = 0;\n\nint\nprocessfile (const char *infname, const char *outfname)\n{\n    if (compile)\n    {\n\treturn compilefile (infname, outfname);\n    }\n\n    if (parse)\n    {\n\tYCodePtr c = parsefile (infname);\n\n\tif (c == NULL) return 1;\n\n\tif (quiet) return 0;\n\n\treturn printcode (outfname, c);\n    }\n\n    if (read_n_print)\n    {\n\tprogress (\"Reading: %s\\n\", infname);\n\tYCodePtr c = Bytecode::readFile (infname);\n\tif (c == 0)\n\t{\n\t    progress (\"Bytecode read failed\\n\");\n\t    return 1;\n\t}\n\n\tprogress (\"Result:\\n\");\n\n\treturn printcode (outfname, c);\n    }\n\n    if (read_n_run)\n    {\n\tprogress (\"Reading:\\n\");\n\tYCodePtr c = Bytecode::readFile (infname);\n\tprogress (\"Running:\\n\");\n\n\tY2Component *server = Y2ComponentBroker::createServer (ui_name);\n\tif (!server)\n\t{\n\t    fprintf (stderr, \"Can't start UI component '%s'\", ui_name);\n\t    return 1;\n\t}\n\n\tYCPValue result = c->evaluate();\n\tprogress (\"Result:\\n\");\n\n\treturn printcode (outfname, result);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Compilation of '%s' failed\\n\"",
            "argv[i]"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Compilation of '%s' failed: %s\\n\"",
            "argv[i]",
            "strerror (errno)"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recurse",
          "args": [
            "argv[i]"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "recurse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "1053-1093",
          "snippet": "int\nrecurse (const char *path)\n{\n    recurseT *handle, *next;\n\n    handle = recurseStart (path);\n    if (handle == 0)\n    {\n\treturn -1;\n    }\n\n    struct stat st;\n    int extpos;\t\t\t// position of file extension\n    int ret = 0;\n\n    while (handle)\n    {\n\tnext = recurseNext (handle, &st);\n\tif (next == 0)\n\t{\n\t    recurseEnd (handle);\n\t    handle = 0;\n\t    break;\n\t}\n\thandle = next;\n\n\textpos = handle->length + strlen (handle->path + handle->length) - 4;\n\tif (strcmp (handle->path + extpos, \".ycp\") == 0)\n\t{\n\t    if (processfile (handle->path, NULL))\n\t\tret = 1;\n\t}\n    }\n\n    if (handle)\n    {\n\trecurseEnd (handle);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static recurseT *recurseStart (const char *path);",
            "static recurseT *recurseNext (recurseT *handle, struct stat *st = 0);",
            "static void recurseEnd (recurseT *handle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic recurseT *recurseStart (const char *path);\nstatic recurseT *recurseNext (recurseT *handle, struct stat *st = 0);\nstatic void recurseEnd (recurseT *handle);\n\nint\nrecurse (const char *path)\n{\n    recurseT *handle, *next;\n\n    handle = recurseStart (path);\n    if (handle == 0)\n    {\n\treturn -1;\n    }\n\n    struct stat st;\n    int extpos;\t\t\t// position of file extension\n    int ret = 0;\n\n    while (handle)\n    {\n\tnext = recurseNext (handle, &st);\n\tif (next == 0)\n\t{\n\t    recurseEnd (handle);\n\t    handle = 0;\n\t    break;\n\t}\n\thandle = next;\n\n\textpos = handle->length + strlen (handle->path + handle->length) - 4;\n\tif (strcmp (handle->path + extpos, \".ycp\") == 0)\n\t{\n\t    if (processfile (handle->path, NULL))\n\t\tret = 1;\n\t}\n    }\n\n    if (handle)\n    {\n\trecurseEnd (handle);\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Add %s to deplist\\n\"",
            "it->path().c_str()"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it->path",
          "args": [],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it->path",
          "args": [],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Can't check dependencies below %s\\nNot a directory ?\\n\"",
            "argv[i]"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeDirList",
          "args": [
            "argv[i]"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "makeDirList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "542-600",
          "snippet": "std::list <FileDep>\nmakeDirList (const char *dir)\n{\n    std::list <FileDep> deplist;\n\n    struct stat st;\n\n    if (lstat (dir, &st) == -1)\t\t\t\t// not existant, not accessible\n    {\n\tperror (dir);\n\treturn deplist;\n    }\n\n    if (S_ISREG (st.st_mode))\t\t\t\t// a single file\n    {\n\tdeplist.push_back (FileDep (\"\", dir, false, false, 0, 0));\n\treturn deplist;\n    }\n\n    if (!S_ISDIR (st.st_mode))\n    {\n\tfprintf (stderr, \"Not a file or directory: %s\\n\", dir);\n\treturn deplist;\n    }\n\n    if (verbose) printf (\"List files below '%s'\\n\", dir);\n\n    recurseT *handle, *next;\n\n    handle = recurseStart (dir);\n    if (handle == 0)\n    {\n\treturn deplist;\n    }\n\n    int extpos;\n\n    while (handle)\n    {\n\tnext = recurseNext (handle, &st);\n\tif (next == 0)\n\t{\n\t    recurseEnd (handle);\n\t    handle = 0;\n\t    break;\n\t}\n\thandle = next;\n\n\textpos = handle->length + strlen (handle->path + handle->length) - 4;\n\tif (strcmp (handle->path + extpos, \".ycp\") == 0)\n\t{\n\t    deplist.push_back (FileDep (\"\", handle->path, false, false, 0, 0));\n\t    if (verbose) printf (\"%s\\n\", handle->path);\n\t}\n    }\n\n    if (verbose) printf (\"directory %s listed, %zu files\\n\", dir, deplist.size());\n    return deplist;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int verbose = 0;",
            "static recurseT *recurseStart (const char *path);",
            "static recurseT *recurseNext (recurseT *handle, struct stat *st = 0);",
            "static void recurseEnd (recurseT *handle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic int verbose = 0;\nstatic recurseT *recurseStart (const char *path);\nstatic recurseT *recurseNext (recurseT *handle, struct stat *st = 0);\nstatic void recurseEnd (recurseT *handle);\n\nstd::list <FileDep>\nmakeDirList (const char *dir)\n{\n    std::list <FileDep> deplist;\n\n    struct stat st;\n\n    if (lstat (dir, &st) == -1)\t\t\t\t// not existant, not accessible\n    {\n\tperror (dir);\n\treturn deplist;\n    }\n\n    if (S_ISREG (st.st_mode))\t\t\t\t// a single file\n    {\n\tdeplist.push_back (FileDep (\"\", dir, false, false, 0, 0));\n\treturn deplist;\n    }\n\n    if (!S_ISDIR (st.st_mode))\n    {\n\tfprintf (stderr, \"Not a file or directory: %s\\n\", dir);\n\treturn deplist;\n    }\n\n    if (verbose) printf (\"List files below '%s'\\n\", dir);\n\n    recurseT *handle, *next;\n\n    handle = recurseStart (dir);\n    if (handle == 0)\n    {\n\treturn deplist;\n    }\n\n    int extpos;\n\n    while (handle)\n    {\n\tnext = recurseNext (handle, &st);\n\tif (next == 0)\n\t{\n\t    recurseEnd (handle);\n\t    handle = 0;\n\t    break;\n\t}\n\thandle = next;\n\n\textpos = handle->length + strlen (handle->path + handle->length) - 4;\n\tif (strcmp (handle->path + extpos, \".ycp\") == 0)\n\t{\n\t    deplist.push_back (FileDep (\"\", handle->path, false, false, 0, 0));\n\t    if (verbose) printf (\"%s\\n\", handle->path);\n\t}\n    }\n\n    if (verbose) printf (\"directory %s listed, %zu files\\n\", dir, deplist.size());\n    return deplist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"No input file or directory given\\n\""
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"-c, -E, -f, -p or -r must be given\\n\""
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPPathSearch::addPath",
          "args": [
            "YCPPathSearch::Module",
            "pathit->c_str()"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "addPath",
          "container": "YCPPathSearch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/pathsearch.cc",
          "lines": "343-349",
          "snippet": "void\nYCPPathSearch::addPath (Kind kind, const string& path)\n{\n    std::list<string>& l = searchList[kind];\n    if (std::find(l.begin(), l.end(), path) == l.end())\n\tl.push_front(path);\n}",
          "includes": [
            "#include \"pathsearch.h\"",
            "#include <ycp/y2log.h>",
            "#include <boost/algorithm/string.hpp>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "std::list<string> YCPPathSearch::searchList[YCPPathSearch::num_Kind];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pathsearch.h\"\n#include <ycp/y2log.h>\n#include <boost/algorithm/string.hpp>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n\nstd::list<string> YCPPathSearch::searchList[YCPPathSearch::num_Kind];\n\nYCPPathSearch {\n  void\n  YCPPathSearch::addPath (Kind kind, const string& path)\n  {\n      std::list<string>& l = searchList[kind];\n      if (std::find(l.begin(), l.end(), path) == l.end())\n  \tl.push_front(path);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathit->c_str",
          "args": [],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathit->c_str",
          "args": [],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_log_simple_mode",
          "args": [
            "true"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "set_log_simple_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "589-591",
          "snippet": "void set_log_simple_mode(bool simple) {\n    log_simple = simple;\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool log_simple = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic bool log_simple = false;\n\nvoid set_log_simple_mode(bool simple) {\n    log_simple = simple;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_log_filename",
          "args": [
            "\"-\""
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "set_log_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2changes.cc",
          "lines": "188-240",
          "snippet": "static void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2CHANGES_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2CHANGES_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2CHANGES_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2CHANGES_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2CHANGES_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2CHANGES_FALLBACK );\n\n\t\tlogname = Y2CHANGES_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2CHANGES_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2CHANGES_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2CHANGES_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2CHANGES_VAR_NUM\t\"Y2MAXLOGNUM\"",
            "#define Y2CHANGES_VAR_SIZE\t\"Y2MAXLOGSIZE\"",
            "#define Y2CHANGES_FALLBACK\t\"/y2changes\"",
            "#define Y2CHANGES_USER\t\"/.y2changes\"\t\t/* Relative to $HOME */",
            "#define Y2CHANGES_ROOT\tLOGDIR \"/y2changes\"",
            "#define Y2CHANGES_MAXNUM\t10\t\t\t/* Maximum logfiles number */",
            "#define Y2CHANGES_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */"
          ],
          "globals_used": [
            "static bool did_set_logname = false;",
            "static const char *logname;",
            "static off_t maxlogsize;",
            "static int   maxlognum;",
            "static bool log_to_file = true;",
            "static bool log_to_syslog = false;",
            "static FILE *Y2CHANGES_STDERR = stderr;",
            "static void shift_log_files(string filename);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/y2changes.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2CHANGES_VAR_NUM\t\"Y2MAXLOGNUM\"\n#define Y2CHANGES_VAR_SIZE\t\"Y2MAXLOGSIZE\"\n#define Y2CHANGES_FALLBACK\t\"/y2changes\"\n#define Y2CHANGES_USER\t\"/.y2changes\"\t\t/* Relative to $HOME */\n#define Y2CHANGES_ROOT\tLOGDIR \"/y2changes\"\n#define Y2CHANGES_MAXNUM\t10\t\t\t/* Maximum logfiles number */\n#define Y2CHANGES_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */\n\nstatic bool did_set_logname = false;\nstatic const char *logname;\nstatic off_t maxlogsize;\nstatic int   maxlognum;\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic FILE *Y2CHANGES_STDERR = stderr;\nstatic void shift_log_files(string filename);\n\nstatic void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2CHANGES_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2CHANGES_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2CHANGES_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2CHANGES_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2CHANGES_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2CHANGES_FALLBACK );\n\n\t\tlogname = Y2CHANGES_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2CHANGES_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2CHANGES_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2CHANGES_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Try `%s -h' for more information.\\n\"",
            "argv[0]"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "optarg"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "optarg"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"-o mutually exclusive with -r\\n\""
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modpathes.push_front",
          "args": [
            "string (optarg)"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "optarg"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "incpathes.push_front",
          "args": [
            "string (optarg)"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"-c mutually exclusive with -E\\n\""
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"-E mutually exclusive with -c\\n\""
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"-%c mutually exclusive with -c\\n\"",
            "c"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_version",
          "args": [],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "print_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "1136-1140",
          "snippet": "void print_version()\n{\n    printf (\"ycpc (libycp %s)\\n\", VERSION);\n    printf (\"Standalone YCP bytecode compiler\\n\");\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nvoid print_version()\n{\n    printf (\"ycpc (libycp %s)\\n\", VERSION);\n    printf (\"Standalone YCP bytecode compiler\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_help",
          "args": [
            "\"ycpc\""
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "print_help",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "1101-1131",
          "snippet": "void print_help (const char *name)\n{\n#define opt_fmt \"\\t%-25s %s\\n\"\n    printf (\"Usage:\\n\");\n    printf (\"  %s [-h] [--help]\\n\", name);\n    printf (\"  %s [-v] [--version]\\n\", name);\n    printf (\"  %s <command> [<option>]... <filename>...\\n\", name);\n    printf (\"  %s\\n\", \"Commands:\");\n    printf (opt_fmt, \"-c, --compile\", \"compile to bytecode\");\n    printf (opt_fmt, \"-E, --fsyntax-only\", \"check syntax and print (unless -q)\");\n    printf (opt_fmt, \"-f, --freshen\", \"freshen .ybc files\");\n    printf (opt_fmt, \"-p, --print\", \"read and print bytecode\");\n    printf (opt_fmt, \"-r, --run\", \"read and run bytecode\");\n    printf (\"  Options:\\n\");\n    printf (opt_fmt, \"-l, --log-file <name>\", \"log file, - means stderr\");\t// common\n    printf (opt_fmt, \"-q, --quiet\", \"no output\");\n    printf (opt_fmt, \"-t, --test\", \"more output (-tt, -ttt)\");\n    printf (\"\\n\");\n    printf (opt_fmt, \"-d, --no-implicit-imports\", \"don't preload implicit namespaces\");\n    printf (opt_fmt, \"-F, --Force\", \"force recompilation of all dependant files\");\n    printf (opt_fmt, \"-I, --include-path\", \"where to find include files\");\n    printf (opt_fmt, \"-M, --module-path\", \"where to find module files\");\n    printf (opt_fmt, \"--no-std-includes\", \"drop all built-in include paths\");\n    printf (opt_fmt, \"--no-std-modules\", \"drop all built-in module paths\");\n    printf (opt_fmt, \"-n, --no-std-paths\", \"no standard paths\");\n    printf (opt_fmt, \"-o, --output\", \"output file for -c, -E, -p, -r\");\n    printf (opt_fmt, \"-R, --recursive\", \"operate recursively\");\n    printf (opt_fmt, \"-u, --ui {ncurses|qt}\", \"UI to start in combination with 'r'\");\n//    printf (opt_fmt, \"-, --\", \"\");\n#undef opt_fmt\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [
            "#define opt_fmt \"\\t%-25s %s\\n\""
          ],
          "globals_used": [
            "static int quiet = 0;",
            "static int recursive = 0;",
            "static int compile = 0;",
            "static int freshen = 0;",
            "static int force = 0;",
            "static recurseT *recurseStart (const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\n#define opt_fmt \"\\t%-25s %s\\n\"\n\nstatic int quiet = 0;\nstatic int recursive = 0;\nstatic int compile = 0;\nstatic int freshen = 0;\nstatic int force = 0;\nstatic recurseT *recurseStart (const char *path);\n\nvoid print_help (const char *name)\n{\n#define opt_fmt \"\\t%-25s %s\\n\"\n    printf (\"Usage:\\n\");\n    printf (\"  %s [-h] [--help]\\n\", name);\n    printf (\"  %s [-v] [--version]\\n\", name);\n    printf (\"  %s <command> [<option>]... <filename>...\\n\", name);\n    printf (\"  %s\\n\", \"Commands:\");\n    printf (opt_fmt, \"-c, --compile\", \"compile to bytecode\");\n    printf (opt_fmt, \"-E, --fsyntax-only\", \"check syntax and print (unless -q)\");\n    printf (opt_fmt, \"-f, --freshen\", \"freshen .ybc files\");\n    printf (opt_fmt, \"-p, --print\", \"read and print bytecode\");\n    printf (opt_fmt, \"-r, --run\", \"read and run bytecode\");\n    printf (\"  Options:\\n\");\n    printf (opt_fmt, \"-l, --log-file <name>\", \"log file, - means stderr\");\t// common\n    printf (opt_fmt, \"-q, --quiet\", \"no output\");\n    printf (opt_fmt, \"-t, --test\", \"more output (-tt, -ttt)\");\n    printf (\"\\n\");\n    printf (opt_fmt, \"-d, --no-implicit-imports\", \"don't preload implicit namespaces\");\n    printf (opt_fmt, \"-F, --Force\", \"force recompilation of all dependant files\");\n    printf (opt_fmt, \"-I, --include-path\", \"where to find include files\");\n    printf (opt_fmt, \"-M, --module-path\", \"where to find module files\");\n    printf (opt_fmt, \"--no-std-includes\", \"drop all built-in include paths\");\n    printf (opt_fmt, \"--no-std-modules\", \"drop all built-in module paths\");\n    printf (opt_fmt, \"-n, --no-std-paths\", \"no standard paths\");\n    printf (opt_fmt, \"-o, --output\", \"output file for -c, -E, -p, -r\");\n    printf (opt_fmt, \"-R, --recursive\", \"operate recursively\");\n    printf (opt_fmt, \"-u, --ui {ncurses|qt}\", \"UI to start in combination with 'r'\");\n//    printf (opt_fmt, \"-, --\", \"\");\n#undef opt_fmt\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPPathSearch::clearPaths",
          "args": [
            "YCPPathSearch::Module"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "clearPaths",
          "container": "YCPPathSearch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/pathsearch.cc",
          "lines": "352-356",
          "snippet": "void\nYCPPathSearch::clearPaths (Kind kind)\n{\n    searchList[kind].clear();\n}",
          "includes": [
            "#include \"pathsearch.h\"",
            "#include <ycp/y2log.h>",
            "#include <boost/algorithm/string.hpp>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "std::list<string> YCPPathSearch::searchList[YCPPathSearch::num_Kind];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pathsearch.h\"\n#include <ycp/y2log.h>\n#include <boost/algorithm/string.hpp>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n\nstd::list<string> YCPPathSearch::searchList[YCPPathSearch::num_Kind];\n\nYCPPathSearch {\n  void\n  YCPPathSearch::clearPaths (Kind kind)\n  {\n      searchList[kind].clear();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt_long",
          "args": [
            "argc",
            "argv",
            "\"h?vxVnpqrtRdEcFfI:M:o:l:u:\"",
            "options",
            "&option_index"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPPathSearch::initialize",
          "args": [],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "initialize",
          "container": "YCPPathSearch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/pathsearch.cc",
          "lines": "274-284",
          "snippet": "void\nYCPPathSearch::initialize ()\n{\n    if (! initialized)\n    {\n\tinitialize (Client, \"/clients\");\n\tinitialize (Include, \"/include\");\n\tinitialize (Module, \"/modules\");\n\tinitialized = true;\n    }\n}",
          "includes": [
            "#include \"pathsearch.h\"",
            "#include <ycp/y2log.h>",
            "#include <boost/algorithm/string.hpp>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool YCPPathSearch::initialized = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pathsearch.h\"\n#include <ycp/y2log.h>\n#include <boost/algorithm/string.hpp>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n\nbool YCPPathSearch::initialized = false;\n\nYCPPathSearch {\n  void\n  YCPPathSearch::initialize ()\n  {\n      if (! initialized)\n      {\n  \tinitialize (Client, \"/clients\");\n  \tinitialize (Include, \"/include\");\n  \tinitialize (Module, \"/modules\");\n  \tinitialized = true;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\n#define UI_NCURSES_NAME \"ncurses\"\n#define UI_QT_NAME \"qt\"\n\nstatic char *outname = NULL;\nstatic int quiet = 0;\nstatic int verbose = 0;\nstatic int no_std_path = 0;\nstatic int recursive = 0;\nstatic int parse = 0;\nstatic int compile = 0;\nstatic int to_xml = 0;\nstatic int read_n_print = 0;\nstatic int read_n_run = 0;\nstatic int freshen = 0;\nstatic int force = 0;\nstatic int no_implicit_namespaces = 0;\nstatic const char *ui_name = 0;\nstatic recurseT *recurseStart (const char *path);\n\nint main(int argc, char *argv[])\n{\n    int i = 0, ret = 0;\n\n    bool log_set = false;\n\n    YCPPathSearch::initialize ();\n\n    // list of -I / -M pathes\n    //   will be pushed to YCPPathSearch later to keep correct order\n    //   (the last added path to YCPPathSearch will be searched first)\n    std::list<std::string> modpathes;\n    std::list<std::string> incpathes;\n\n    for(;;)\n    {\n\tint option_index = 0;\n\n\tstatic struct option options[] =\n\t{\n\t    {\"compile\", 0, 0, 'c'},\t\t\t// compile to bytecode\n\t    {\"no-implicit-imports\", 0, 0, 'd'},\t\t// don't preload implicit namespaces\n\t    {\"fsyntax-only\", 0, 0, 'E'},\t\t// parse only\n\t    {\"freshen\", 0, 0, 'f'},\t\t\t// freshen .ybc files\n\t    {\"Force\", 0, 0, 'F'},\t\t\t// force recompile of all dependant files\n\t    {\"help\", 0, 0, 'h'},\t\t\t// show help and exit\n\t    {\"include-path\", 1, 0, 'I'},\t\t// where to find include files\n\t    {\"module-path\", 1, 0, 'M'},\t\t\t// where to find module files\n\t    {\"no-std-includes\", 0, 0, 257},\t\t// drop all built-in include pathes\n\t    {\"no-std-modules\", 0, 0, 258},\t\t// drop all built-in module pathes\n\t    {\"nostdincludes\", 0, 0, 257},\t\t// drop all built-in include pathes\n\t    {\"nostdmodules\", 0, 0, 258},\t\t// drop all built-in module pathes\n\t    {\"log-file\", 1, 0, 'l'},\t\t\t// specify log file\n\t    {\"logfile\", 1, 0, 'l'},\t\t\t// specify log file\n\t    {\"no-std-path\", 0, 0, 'n'},\t\t\t// no standard pathes\n\t    {\"no-std-paths\", 0, 0, 'n'},\t\t// no standard pathes\n\t    {\"output\", 1, 0, 'o'},\t\t\t// output file\n\t    {\"print\", 0, 0, 'p'},\t\t\t// read & print bytecode\n\t    {\"run\", 0, 0, 'r'},\t\t\t\t// read & run bytecode\n\t    {\"quiet\", 0, 0, 'q'},\t\t\t// no output\n\t    {\"recursive\", 0, 0, 'R'},\t\t\t// recursively\n\t    {\"test\", 0, 0, 't'},\t\t\t// lots of output\n\t    {\"ui\", 1, 0, 'u' },\t\t\t\t// UI to start in combination with 'r'\n\t    {\"version\", 0, 0, 'v'},\t\t\t// show version and exit\n\t    {\"xml\", 0, 0, 'x'},\t\t\t\t// output XML insteaf of Bytecode\n\t    {0, 0, 0, 0}\n\t};\n\n\tint c = getopt_long (argc, argv, \"h?vxVnpqrtRdEcFfI:M:o:l:u:\", options, &option_index);\n\tif (c == EOF) break;\n\n\tswitch (c)\n\t{\n\t    case 257:\n\t\tYCPPathSearch::clearPaths (YCPPathSearch::Include);\n\t    break;\n\t    case 258:\n\t\tYCPPathSearch::clearPaths (YCPPathSearch::Module);\n\t    break;\n\t    case 'h':\n\t    case '?':\n\t\tprint_help (\"ycpc\");\n\t\texit (0);\n\t    case 'v':\n\t    case 'V':\n\t\tprint_version ();\n\t\texit (0);\n\t    case 'r':\n\t\tread_n_run = 1;\n\t\tbreak;\n\t    case 'R':\n\t\tif (outname != NULL)\n\t\t{\n\t\t    fprintf (stderr, \"-%c mutually exclusive with -c\\n\", c);\n\t\t    exit (1);\n\t\t}\n\t\trecursive = 1;\n\t\tbreak;\n\t    case 'q':\n\t\tquiet = 1;\n\t\tbreak;\n\t    case 'E':\n\t\tparse = 1;\n\t\tif (compile != 0)\n\t\t{\n\t\t    fprintf (stderr, \"-E mutually exclusive with -c\\n\");\n\t\t    exit (1);\n\t\t}\n\t\tbreak;\n\t    case 'c':\n\t\tcompile = 1;\n\t\tif (parse != 0)\n\t\t{\n\t\t    fprintf (stderr, \"-c mutually exclusive with -E\\n\");\n\t\t    exit (1);\n\t\t}\n\t\tbreak;\n\t    case 'f':\n\t\tfreshen = 1;\n\t\tbreak;\n\t    case 'F':\n\t\tforce = 1;\n\t\tbreak;\n\t    case 'I':\n\t\tincpathes.push_front (string (optarg));\t\t// push to front so first one is last in list\n\t\tbreak;\n\t    case 'M':\n\t\tmodpathes.push_front (string (optarg));\t\t// dito\n\t\tbreak;\n\t    case 'l':\n\t\tset_log_filename (optarg);\n\t\tlog_set = true;\n\t\tbreak;\n\t    case 'o':\n\t\tif (recursive)\n\t\t{\n\t\t    fprintf (stderr, \"-o mutually exclusive with -r\\n\");\n\t\t    exit (1);\n\t\t}\n\t\toutname = strdup (optarg);\n\t\tbreak;\n\t    case 'd':\n\t\tno_implicit_namespaces = 1;\n\t\tbreak;\n\t    case 'n':\n\t\tno_std_path = 1;\n\t\tbreak;\n\t    case 't':\n\t\tverbose += 1;\n\t\tbreak;\n\t    case 'p':\n\t\tread_n_print = 1;\n\t\tbreak;\n\t    case 'u':\n\t\tui_name = strdup (optarg);\n\t\tbreak;\n\t    case 'x':\n\t\tto_xml = 1;\n\t\tbreak;\n\t    default:\n\t\tfprintf (stderr, \"Try `%s -h' for more information.\\n\", argv[0]);\n\t\texit(1);\n\t}\n    }\n\n    // setup log\n    if (!log_set)\n    {\n\t// user didn't setup log, use stdout\n\tset_log_filename(\"-\");\n    }\n    set_log_simple_mode (true);\n\n    // add include and module pathes to YCPPathSearch so that the argument order is kept\n\n    std::list<std::string>::iterator pathit;\n    for (pathit = incpathes.begin(); pathit != incpathes.end(); pathit++)\n    {\n\tYCPPathSearch::addPath (YCPPathSearch::Include, pathit->c_str());\n    }\n    for (pathit = modpathes.begin(); pathit != modpathes.end(); pathit++)\n    {\n\tYCPPathSearch::addPath (YCPPathSearch::Module, pathit->c_str());\n    }\n\n    // register builtins\n    SCR scr;\n    WFM wfm;\n\n    if ((compile == parse)\t\t// both are zero\n\t&& (compile == freshen)\n\t&& (compile == read_n_print)\n\t&& (compile == read_n_run))\n    {\n\tfprintf (stderr, \"-c, -E, -f, -p or -r must be given\\n\");\n\texit (1);\n    }\n\n    if (optind == argc)\n    {\n\tfprintf (stderr, \"No input file or directory given\\n\");\n\texit (1);\n    }\n\n    if (read_n_run\t\t\t// if no explicit UI name given for run\n\t&& ui_name == 0)\t\t//   try to determine one according to $DISPLAY\n    {\n\tchar *display = getenv (\"DISPLAY\");\n\tif (display == 0\n\t    || *display == 0)\n\t{\n\t    ui_name = UI_NCURSES_NAME;\n\t}\n\telse\n\t{\n\t    ui_name = UI_QT_NAME;\n\t}\n    }\n\n    std::list <FileDep> deplist;\n\n    for (i = optind; i < argc;i++)\n    {\n\tif (freshen)\n\t{\n\t    std::list <FileDep> depdir = makeDirList (argv[i]);\n\n\t    if (depdir.empty())\n\t    {\n\t\tfprintf (stderr, \"Can't check dependencies below %s\\nNot a directory ?\\n\", argv[i]);\n\t\treturn 1;\n\t    }\n\n\t    std::list<FileDep>::iterator it;\n\n\t    for (it = depdir.begin(); it != depdir.end(); it++)\n\t    {\n\t\tif (verbose > 1) printf (\"Add %s to deplist\\n\", it->path().c_str());\n\t\tdeplist.push_back (*it);\n\t    }\n\t}\n\telse if (recursive)\n\t{\n\t    if (!compile)\n\t    {\n\t\tif (recurse (argv[i]))\n\t\t{\n\t\t    ret = 1;\n\t\t}\n\t        continue;\n\t    }\n\t    \n\t    ret = compilefile (argv[i], 0);\n\n\t    if (ret == 1)\n\t    {\n\t\tfprintf (stderr, \"Compilation of '%s' failed: %s\\n\", argv[i], strerror (errno));\n\t\tbreak;\n\t    }\n\t    else if (ret == 2)\n\t    {\n\t\tfprintf (stderr, \"Compilation of '%s' failed\\n\", argv[i]);\n\t\tbreak;\n\t    }\n\t    ret = 0;\n\t}\n\telse\n\t{\n\t    if (processfile (argv[i], outname))\n\t    {\n\t\tret = 1;\n\t    }\n\t}\n    }\n\n    if (freshen)\n    {\n\tstd::map <std::string, std::list <FileDep> > depmap = makeDependMap (deplist);\n\n\tif (verbose) printf (\"Map generated, %zu entries, computing order\\n\", depmap.size());\n\n\tif (depmap.empty())\n\t{\n\t    fprintf (stderr, \"No files or dependencies found\\n\");\n\t    return 1;\n\t}\n\n\t// loop over all modules and generated a fake module \"*\" which depends on all other modules\n\n\tstd::map <std::string, std::list <FileDep> >::iterator modit;\n\tdeplist.clear();\n\tfor (modit = depmap.begin(); modit != depmap.end(); modit++)\n\t{\n\t    if (verbose > 2) printf (\"Entry %s \", modit->first.c_str());\n\t    if (modit->second.empty())\n\t    {\n\t\tfprintf (stderr, \"Entry '%s' has no description\\n\", modit->first.c_str());\n\t\tcontinue;\n\t    }\n\t    if (verbose > 2) printf (\" -> %s\\n\", modit->second.front().toString().c_str());\n\t    if (modit->second.front().is_module())\n\t    {\n\t\tdeplist.push_back (modit->second.front());\n\t\tif (verbose > 1) printf (\"Module %s\\n\", modit->first.c_str());\n\t    }\n\t}\n\tdepmap[\"*\"] = deplist;\n\n\tdeplist = depTree (\"*\", depmap);\n\n\tif (deplist.empty())\n\t{\n\t    fprintf (stderr, \"No depencies found\\n\");\n\t    exit (1);\n\t}\n\tstd::list <FileDep>::iterator depit;\n\n\tdepit = deplist.end();\n\tdepit--;\t\t\t\t\t// get last element, existance is guaranteed\n\ttime_t starttime = depit->bintime() == 0 ? depit->srctime() : depit->bintime();\n\tstring startname = depit->name();\n\n\tfor (depit = deplist.begin(); depit != deplist.end(); depit++)\n\t{\n\t    if (depit->srctime() > starttime)\n\t    {\n\t\tprintf (\"%s is newer than %s\\n\", depit->toString().c_str(), startname.c_str());\n\t\ttime (&starttime);\n\t    }\n\n\t    if (!depit->is_module())\n\t    {\n\t\tcontinue;\n\t    }\n\t    if (compile)\n\t    {\n\t\terrno = 0;\n\t\t\n\t\tret = compilefile (depit->path().c_str(), NULL);\n\t\tif (ret == 1)\n\t\t{\n\t\t    fprintf (stderr, \"Compilation failed for %s: %s\\n\", depit->path().c_str(), strerror (errno));\n\t\t    break;\n\t\t}\n\t\telse if (ret == 2)\n\t\t{\n\t\t    fprintf (stderr, \"Compilation failed for %s\\n\", depit->path().c_str());\n\t\t    break;\n\t\t}\n\n\t\tret = 0;\n\t    }\n\t    else\n\t    {\n\t\tprintf (\"%s\\n\", depit->name().c_str());\n\t    }\n\t}\n    }\n    else\n    {\n        if (verbose) printf (\"Done\\n\");\n    }\n    return ret;\n}"
  },
  {
    "function_name": "print_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "1136-1140",
    "snippet": "void print_version()\n{\n    printf (\"ycpc (libycp %s)\\n\", VERSION);\n    printf (\"Standalone YCP bytecode compiler\\n\");\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Standalone YCP bytecode compiler\\n\""
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ycpc (libycp %s)\\n\"",
            "VERSION"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nvoid print_version()\n{\n    printf (\"ycpc (libycp %s)\\n\", VERSION);\n    printf (\"Standalone YCP bytecode compiler\\n\");\n}"
  },
  {
    "function_name": "print_help",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "1101-1131",
    "snippet": "void print_help (const char *name)\n{\n#define opt_fmt \"\\t%-25s %s\\n\"\n    printf (\"Usage:\\n\");\n    printf (\"  %s [-h] [--help]\\n\", name);\n    printf (\"  %s [-v] [--version]\\n\", name);\n    printf (\"  %s <command> [<option>]... <filename>...\\n\", name);\n    printf (\"  %s\\n\", \"Commands:\");\n    printf (opt_fmt, \"-c, --compile\", \"compile to bytecode\");\n    printf (opt_fmt, \"-E, --fsyntax-only\", \"check syntax and print (unless -q)\");\n    printf (opt_fmt, \"-f, --freshen\", \"freshen .ybc files\");\n    printf (opt_fmt, \"-p, --print\", \"read and print bytecode\");\n    printf (opt_fmt, \"-r, --run\", \"read and run bytecode\");\n    printf (\"  Options:\\n\");\n    printf (opt_fmt, \"-l, --log-file <name>\", \"log file, - means stderr\");\t// common\n    printf (opt_fmt, \"-q, --quiet\", \"no output\");\n    printf (opt_fmt, \"-t, --test\", \"more output (-tt, -ttt)\");\n    printf (\"\\n\");\n    printf (opt_fmt, \"-d, --no-implicit-imports\", \"don't preload implicit namespaces\");\n    printf (opt_fmt, \"-F, --Force\", \"force recompilation of all dependant files\");\n    printf (opt_fmt, \"-I, --include-path\", \"where to find include files\");\n    printf (opt_fmt, \"-M, --module-path\", \"where to find module files\");\n    printf (opt_fmt, \"--no-std-includes\", \"drop all built-in include paths\");\n    printf (opt_fmt, \"--no-std-modules\", \"drop all built-in module paths\");\n    printf (opt_fmt, \"-n, --no-std-paths\", \"no standard paths\");\n    printf (opt_fmt, \"-o, --output\", \"output file for -c, -E, -p, -r\");\n    printf (opt_fmt, \"-R, --recursive\", \"operate recursively\");\n    printf (opt_fmt, \"-u, --ui {ncurses|qt}\", \"UI to start in combination with 'r'\");\n//    printf (opt_fmt, \"-, --\", \"\");\n#undef opt_fmt\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [
      "#define opt_fmt \"\\t%-25s %s\\n\""
    ],
    "globals_used": [
      "static int quiet = 0;",
      "static int recursive = 0;",
      "static int compile = 0;",
      "static int freshen = 0;",
      "static int force = 0;",
      "static recurseT *recurseStart (const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"-u, --ui {ncurses|qt}\"",
            "\"UI to start in combination with 'r'\""
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"-R, --recursive\"",
            "\"operate recursively\""
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"-o, --output\"",
            "\"output file for -c, -E, -p, -r\""
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"-n, --no-std-paths\"",
            "\"no standard paths\""
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"--no-std-modules\"",
            "\"drop all built-in module paths\""
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"--no-std-includes\"",
            "\"drop all built-in include paths\""
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"-M, --module-path\"",
            "\"where to find module files\""
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"-I, --include-path\"",
            "\"where to find include files\""
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"-F, --Force\"",
            "\"force recompilation of all dependant files\""
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"-d, --no-implicit-imports\"",
            "\"don't preload implicit namespaces\""
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"-t, --test\"",
            "\"more output (-tt, -ttt)\""
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"-q, --quiet\"",
            "\"no output\""
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"-l, --log-file <name>\"",
            "\"log file, - means stderr\""
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  Options:\\n\""
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"-r, --run\"",
            "\"read and run bytecode\""
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"-p, --print\"",
            "\"read and print bytecode\""
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"-f, --freshen\"",
            "\"freshen .ybc files\""
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"-E, --fsyntax-only\"",
            "\"check syntax and print (unless -q)\""
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "opt_fmt",
            "\"-c, --compile\"",
            "\"compile to bytecode\""
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  %s\\n\"",
            "\"Commands:\""
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  %s <command> [<option>]... <filename>...\\n\"",
            "name"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  %s [-v] [--version]\\n\"",
            "name"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  %s [-h] [--help]\\n\"",
            "name"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Usage:\\n\""
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\n#define opt_fmt \"\\t%-25s %s\\n\"\n\nstatic int quiet = 0;\nstatic int recursive = 0;\nstatic int compile = 0;\nstatic int freshen = 0;\nstatic int force = 0;\nstatic recurseT *recurseStart (const char *path);\n\nvoid print_help (const char *name)\n{\n#define opt_fmt \"\\t%-25s %s\\n\"\n    printf (\"Usage:\\n\");\n    printf (\"  %s [-h] [--help]\\n\", name);\n    printf (\"  %s [-v] [--version]\\n\", name);\n    printf (\"  %s <command> [<option>]... <filename>...\\n\", name);\n    printf (\"  %s\\n\", \"Commands:\");\n    printf (opt_fmt, \"-c, --compile\", \"compile to bytecode\");\n    printf (opt_fmt, \"-E, --fsyntax-only\", \"check syntax and print (unless -q)\");\n    printf (opt_fmt, \"-f, --freshen\", \"freshen .ybc files\");\n    printf (opt_fmt, \"-p, --print\", \"read and print bytecode\");\n    printf (opt_fmt, \"-r, --run\", \"read and run bytecode\");\n    printf (\"  Options:\\n\");\n    printf (opt_fmt, \"-l, --log-file <name>\", \"log file, - means stderr\");\t// common\n    printf (opt_fmt, \"-q, --quiet\", \"no output\");\n    printf (opt_fmt, \"-t, --test\", \"more output (-tt, -ttt)\");\n    printf (\"\\n\");\n    printf (opt_fmt, \"-d, --no-implicit-imports\", \"don't preload implicit namespaces\");\n    printf (opt_fmt, \"-F, --Force\", \"force recompilation of all dependant files\");\n    printf (opt_fmt, \"-I, --include-path\", \"where to find include files\");\n    printf (opt_fmt, \"-M, --module-path\", \"where to find module files\");\n    printf (opt_fmt, \"--no-std-includes\", \"drop all built-in include paths\");\n    printf (opt_fmt, \"--no-std-modules\", \"drop all built-in module paths\");\n    printf (opt_fmt, \"-n, --no-std-paths\", \"no standard paths\");\n    printf (opt_fmt, \"-o, --output\", \"output file for -c, -E, -p, -r\");\n    printf (opt_fmt, \"-R, --recursive\", \"operate recursively\");\n    printf (opt_fmt, \"-u, --ui {ncurses|qt}\", \"UI to start in combination with 'r'\");\n//    printf (opt_fmt, \"-, --\", \"\");\n#undef opt_fmt\n}"
  },
  {
    "function_name": "recurse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "1053-1093",
    "snippet": "int\nrecurse (const char *path)\n{\n    recurseT *handle, *next;\n\n    handle = recurseStart (path);\n    if (handle == 0)\n    {\n\treturn -1;\n    }\n\n    struct stat st;\n    int extpos;\t\t\t// position of file extension\n    int ret = 0;\n\n    while (handle)\n    {\n\tnext = recurseNext (handle, &st);\n\tif (next == 0)\n\t{\n\t    recurseEnd (handle);\n\t    handle = 0;\n\t    break;\n\t}\n\thandle = next;\n\n\textpos = handle->length + strlen (handle->path + handle->length) - 4;\n\tif (strcmp (handle->path + extpos, \".ycp\") == 0)\n\t{\n\t    if (processfile (handle->path, NULL))\n\t\tret = 1;\n\t}\n    }\n\n    if (handle)\n    {\n\trecurseEnd (handle);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static recurseT *recurseStart (const char *path);",
      "static recurseT *recurseNext (recurseT *handle, struct stat *st = 0);",
      "static void recurseEnd (recurseT *handle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "recurseEnd",
          "args": [
            "handle"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "recurseEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "150-156",
          "snippet": "static void\nrecurseEnd (recurseT *handle)\n{\n    closedir (handle->d);\n    free (handle);\n    return;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void recurseEnd (recurseT *handle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic void recurseEnd (recurseT *handle);\n\nstatic void\nrecurseEnd (recurseT *handle)\n{\n    closedir (handle->d);\n    free (handle);\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "processfile",
          "args": [
            "handle->path",
            "NULL"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "processfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "992-1046",
          "snippet": "int\nprocessfile (const char *infname, const char *outfname)\n{\n    if (compile)\n    {\n\treturn compilefile (infname, outfname);\n    }\n\n    if (parse)\n    {\n\tYCodePtr c = parsefile (infname);\n\n\tif (c == NULL) return 1;\n\n\tif (quiet) return 0;\n\n\treturn printcode (outfname, c);\n    }\n\n    if (read_n_print)\n    {\n\tprogress (\"Reading: %s\\n\", infname);\n\tYCodePtr c = Bytecode::readFile (infname);\n\tif (c == 0)\n\t{\n\t    progress (\"Bytecode read failed\\n\");\n\t    return 1;\n\t}\n\n\tprogress (\"Result:\\n\");\n\n\treturn printcode (outfname, c);\n    }\n\n    if (read_n_run)\n    {\n\tprogress (\"Reading:\\n\");\n\tYCodePtr c = Bytecode::readFile (infname);\n\tprogress (\"Running:\\n\");\n\n\tY2Component *server = Y2ComponentBroker::createServer (ui_name);\n\tif (!server)\n\t{\n\t    fprintf (stderr, \"Can't start UI component '%s'\", ui_name);\n\t    return 1;\n\t}\n\n\tYCPValue result = c->evaluate();\n\tprogress (\"Result:\\n\");\n\n\treturn printcode (outfname, result);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int quiet = 0;",
            "static int parse = 0;",
            "static int compile = 0;",
            "static int read_n_print = 0;",
            "static int read_n_run = 0;",
            "static const char *ui_name = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic int quiet = 0;\nstatic int parse = 0;\nstatic int compile = 0;\nstatic int read_n_print = 0;\nstatic int read_n_run = 0;\nstatic const char *ui_name = 0;\n\nint\nprocessfile (const char *infname, const char *outfname)\n{\n    if (compile)\n    {\n\treturn compilefile (infname, outfname);\n    }\n\n    if (parse)\n    {\n\tYCodePtr c = parsefile (infname);\n\n\tif (c == NULL) return 1;\n\n\tif (quiet) return 0;\n\n\treturn printcode (outfname, c);\n    }\n\n    if (read_n_print)\n    {\n\tprogress (\"Reading: %s\\n\", infname);\n\tYCodePtr c = Bytecode::readFile (infname);\n\tif (c == 0)\n\t{\n\t    progress (\"Bytecode read failed\\n\");\n\t    return 1;\n\t}\n\n\tprogress (\"Result:\\n\");\n\n\treturn printcode (outfname, c);\n    }\n\n    if (read_n_run)\n    {\n\tprogress (\"Reading:\\n\");\n\tYCodePtr c = Bytecode::readFile (infname);\n\tprogress (\"Running:\\n\");\n\n\tY2Component *server = Y2ComponentBroker::createServer (ui_name);\n\tif (!server)\n\t{\n\t    fprintf (stderr, \"Can't start UI component '%s'\", ui_name);\n\t    return 1;\n\t}\n\n\tYCPValue result = c->evaluate();\n\tprogress (\"Result:\\n\");\n\n\treturn printcode (outfname, result);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "handle->path + extpos",
            "\".ycp\""
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "handle->path + handle->length"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recurseNext",
          "args": [
            "handle",
            "&st"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recurseStart",
          "args": [
            "path"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic recurseT *recurseStart (const char *path);\nstatic recurseT *recurseNext (recurseT *handle, struct stat *st = 0);\nstatic void recurseEnd (recurseT *handle);\n\nint\nrecurse (const char *path)\n{\n    recurseT *handle, *next;\n\n    handle = recurseStart (path);\n    if (handle == 0)\n    {\n\treturn -1;\n    }\n\n    struct stat st;\n    int extpos;\t\t\t// position of file extension\n    int ret = 0;\n\n    while (handle)\n    {\n\tnext = recurseNext (handle, &st);\n\tif (next == 0)\n\t{\n\t    recurseEnd (handle);\n\t    handle = 0;\n\t    break;\n\t}\n\thandle = next;\n\n\textpos = handle->length + strlen (handle->path + handle->length) - 4;\n\tif (strcmp (handle->path + extpos, \".ycp\") == 0)\n\t{\n\t    if (processfile (handle->path, NULL))\n\t\tret = 1;\n\t}\n    }\n\n    if (handle)\n    {\n\trecurseEnd (handle);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "processfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "992-1046",
    "snippet": "int\nprocessfile (const char *infname, const char *outfname)\n{\n    if (compile)\n    {\n\treturn compilefile (infname, outfname);\n    }\n\n    if (parse)\n    {\n\tYCodePtr c = parsefile (infname);\n\n\tif (c == NULL) return 1;\n\n\tif (quiet) return 0;\n\n\treturn printcode (outfname, c);\n    }\n\n    if (read_n_print)\n    {\n\tprogress (\"Reading: %s\\n\", infname);\n\tYCodePtr c = Bytecode::readFile (infname);\n\tif (c == 0)\n\t{\n\t    progress (\"Bytecode read failed\\n\");\n\t    return 1;\n\t}\n\n\tprogress (\"Result:\\n\");\n\n\treturn printcode (outfname, c);\n    }\n\n    if (read_n_run)\n    {\n\tprogress (\"Reading:\\n\");\n\tYCodePtr c = Bytecode::readFile (infname);\n\tprogress (\"Running:\\n\");\n\n\tY2Component *server = Y2ComponentBroker::createServer (ui_name);\n\tif (!server)\n\t{\n\t    fprintf (stderr, \"Can't start UI component '%s'\", ui_name);\n\t    return 1;\n\t}\n\n\tYCPValue result = c->evaluate();\n\tprogress (\"Result:\\n\");\n\n\treturn printcode (outfname, result);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int quiet = 0;",
      "static int parse = 0;",
      "static int compile = 0;",
      "static int read_n_print = 0;",
      "static int read_n_run = 0;",
      "static const char *ui_name = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printcode",
          "args": [
            "outfname",
            "result"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "printcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "954-985",
          "snippet": "int printcode (const char *outfname, const toStringAble & c)\n{\n    std::ofstream outstream;\n\n    // print out the result\n    if (outfname != NULL\n\t&& *outfname != '-')\n    {\n\toutstream.open (outfname, std::ios::out);\n    }\n\n    if (!outstream.is_open ())\n    {\n\tif ((outfname != NULL) && (*outfname != '-'))\n\t{\n\t    fprintf (stderr, \"Can't write ''%s''\\n\", (outfname==0)?\"<unknown>\":outfname);\n\t    return 1;\n\t}\n    }\n\n    progress (\"Parsed:\\n\");\n    if (outstream.is_open())\n    {\n\toutstream << c->toString() << endl;\n    }\n    else\n    {\n\tstd::cout << c->toString() << endl;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nint printcode (const char *outfname, const toStringAble & c)\n{\n    std::ofstream outstream;\n\n    // print out the result\n    if (outfname != NULL\n\t&& *outfname != '-')\n    {\n\toutstream.open (outfname, std::ios::out);\n    }\n\n    if (!outstream.is_open ())\n    {\n\tif ((outfname != NULL) && (*outfname != '-'))\n\t{\n\t    fprintf (stderr, \"Can't write ''%s''\\n\", (outfname==0)?\"<unknown>\":outfname);\n\t    return 1;\n\t}\n    }\n\n    progress (\"Parsed:\\n\");\n    if (outstream.is_open())\n    {\n\toutstream << c->toString() << endl;\n    }\n    else\n    {\n\tstd::cout << c->toString() << endl;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "progress",
          "args": [
            "\"Result:\\n\""
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->evaluate",
          "args": [],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Can't start UI component '%s'\"",
            "ui_name"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2ComponentBroker::createServer",
          "args": [
            "ui_name"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "progress",
          "args": [
            "\"Running:\\n\""
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readFile",
          "args": [
            "infname"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "readFile",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "1129-1171",
          "snippet": "YCodePtr\nBytecode::readFile (const string & filename)\n{\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readFile (%s)\", filename.c_str());\n#endif\n    bytecodeistream instream (filename);\n    if (!instream.is_open ())\n    {\n\ty2error (\"Failed to open '%s': %s\", filename.c_str(), strerror (errno));\n\treturn 0;\n    }\n    // check YaST_BYTECODE_HEADER\n    if ( \n\tinstream.isVersion (\n\t    atoi (YaST_BYTECODE_MAJOR)\n\t    , atoi (YaST_BYTECODE_MINOR)\n\t    , atoi (YaST_BYTECODE_RELEASE))\n\t||\n\tinstream.isVersion (1,3,2) )\t// 9.1/SLES9\n    {\n#if DO_DEBUG\n//\ty2debug (\"Header accepted\");\n#endif\n\n\ttry\n\t{\n\t    return readCode (instream);\n\t}\n\tcatch (const Bytecode::Invalid&)\n\t{\n\t    // there are memory leaks all over the place now\n\t    y2error (\"Caught invalid bytecode in '%s'\", filename.c_str());\n\t    return 0;\n\t}\n    }\n\n    y2error (\"Unsupported version %d.%d.%d\"\n\t, instream.major ()\n\t, instream.minor ()\n\t, instream.release ());\n    return 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define YaST_BYTECODE_RELEASE \"0\"",
            "#define YaST_BYTECODE_MINOR \"4\"",
            "#define YaST_BYTECODE_MAJOR \"1\"",
            "#define YaST_BYTECODE_HEADER \"YaST bytecode \"",
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define YaST_BYTECODE_RELEASE \"0\"\n#define YaST_BYTECODE_MINOR \"4\"\n#define YaST_BYTECODE_MAJOR \"1\"\n#define YaST_BYTECODE_HEADER \"YaST bytecode \"\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readFile (const string & filename)\n  {\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readFile (%s)\", filename.c_str());\n  #endif\n      bytecodeistream instream (filename);\n      if (!instream.is_open ())\n      {\n  \ty2error (\"Failed to open '%s': %s\", filename.c_str(), strerror (errno));\n  \treturn 0;\n      }\n      // check YaST_BYTECODE_HEADER\n      if ( \n  \tinstream.isVersion (\n  \t    atoi (YaST_BYTECODE_MAJOR)\n  \t    , atoi (YaST_BYTECODE_MINOR)\n  \t    , atoi (YaST_BYTECODE_RELEASE))\n  \t||\n  \tinstream.isVersion (1,3,2) )\t// 9.1/SLES9\n      {\n  #if DO_DEBUG\n  //\ty2debug (\"Header accepted\");\n  #endif\n  \n  \ttry\n  \t{\n  \t    return readCode (instream);\n  \t}\n  \tcatch (const Bytecode::Invalid&)\n  \t{\n  \t    // there are memory leaks all over the place now\n  \t    y2error (\"Caught invalid bytecode in '%s'\", filename.c_str());\n  \t    return 0;\n  \t}\n      }\n  \n      y2error (\"Unsupported version %d.%d.%d\"\n  \t, instream.major ()\n  \t, instream.minor ()\n  \t, instream.release ());\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "progress",
          "args": [
            "\"Reading:\\n\""
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "progress",
          "args": [
            "\"Result:\\n\""
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "progress",
          "args": [
            "\"Bytecode read failed\\n\""
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "progress",
          "args": [
            "\"Reading: %s\\n\"",
            "infname"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsefile",
          "args": [
            "infname"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "parsefile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "825-893",
          "snippet": "YCodePtr\nparsefile (const char *infname)\n{\n    if (infname == NULL)\n    {\n\tfprintf (stderr, \"No input file given\\n\");\n\treturn NULL;\n    }\n\n    if (parser == NULL)\n    {\n\tparser = new Parser();\n\n\tif (parser == NULL)\n\t{\n\t    fprintf (stderr, \"Can't create parser\\n\");\n\t    return NULL;\n\t}\n    }\n\n    FILE *infile;\n    if (!strcmp (infname, \"-\"))\n    {\n\tinfile = stdin;\n    }\n    else\n    {\n\tinfile = fopen (infname, \"r\");\n    }\n\n    if (infile == NULL)\n    {\n\tfprintf (stderr, \"Can't read '%s'\\n\", infname);\n\treturn NULL;\n    }\n\n    progress (\"parsing '%s'\\n\", infname);\n\n    parser->setInput (infile, infname);\n    parser->setBuffered();\n\n    if (verbose > 2) SymbolTableDebug = 1;\n\n    YCodePtr c = NULL;\n\n    c = parser->parse ();\n    \n    int ln = parser->scanner ()->lineNumber ();\n    \n    if (! parser->atEOF () && parser->scanner ()->yylex () != END_OF_FILE)\n    {\n\tee.setFilename (parser->scanner ()->filename ());\n\tee.setLinenumber (ln);\n\tycperror (\"Unreachable code at the end of file\");\n\tc = NULL;\n    }\n\n    fclose (infile);\n\n    if (c == NULL || c->isError ())\n    {\n\tprogress (\"Error\\n\");\n\treturn NULL;\n    }\n\n    progress (\"done\\n\");\n\n    return c;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int SymbolTableDebug;",
            "static Parser *parser = NULL;",
            "extern ExecutionEnvironment ee;",
            "static int verbose = 0;",
            "static int parse = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nextern int SymbolTableDebug;\nstatic Parser *parser = NULL;\nextern ExecutionEnvironment ee;\nstatic int verbose = 0;\nstatic int parse = 0;\n\nYCodePtr\nparsefile (const char *infname)\n{\n    if (infname == NULL)\n    {\n\tfprintf (stderr, \"No input file given\\n\");\n\treturn NULL;\n    }\n\n    if (parser == NULL)\n    {\n\tparser = new Parser();\n\n\tif (parser == NULL)\n\t{\n\t    fprintf (stderr, \"Can't create parser\\n\");\n\t    return NULL;\n\t}\n    }\n\n    FILE *infile;\n    if (!strcmp (infname, \"-\"))\n    {\n\tinfile = stdin;\n    }\n    else\n    {\n\tinfile = fopen (infname, \"r\");\n    }\n\n    if (infile == NULL)\n    {\n\tfprintf (stderr, \"Can't read '%s'\\n\", infname);\n\treturn NULL;\n    }\n\n    progress (\"parsing '%s'\\n\", infname);\n\n    parser->setInput (infile, infname);\n    parser->setBuffered();\n\n    if (verbose > 2) SymbolTableDebug = 1;\n\n    YCodePtr c = NULL;\n\n    c = parser->parse ();\n    \n    int ln = parser->scanner ()->lineNumber ();\n    \n    if (! parser->atEOF () && parser->scanner ()->yylex () != END_OF_FILE)\n    {\n\tee.setFilename (parser->scanner ()->filename ());\n\tee.setLinenumber (ln);\n\tycperror (\"Unreachable code at the end of file\");\n\tc = NULL;\n    }\n\n    fclose (infile);\n\n    if (c == NULL || c->isError ())\n    {\n\tprogress (\"Error\\n\");\n\treturn NULL;\n    }\n\n    progress (\"done\\n\");\n\n    return c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compilefile",
          "args": [
            "infname",
            "outfname"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "compilefile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "905-944",
          "snippet": "int\ncompilefile (const char *infname, const char *outfname)\n{\n    string ofname = infname;\n\n    if (outfname != NULL)\n    {\n\tofname = outfname;\n    }\n    else\n    {\n\tint len = ofname.size ();\n\tif (len > 4 && ofname.substr (len-4, 4) == \".ycp\")\n\t{\n\t    ofname = ofname.replace (len-4, 4, to_xml ? \".xml\" : \".ybc\");\n\t}\n\telse\n\t{\n\t    ofname += to_xml ? \".xml\" : \".ybc\";\n\t}\n    }\n    progress (\"compiling to '%s'\\n\", ofname.c_str ());\n\n    YCodePtr c = parsefile (infname);\n\n    if (c != NULL )\n    {\n\tprogress (\"saving ...\\n\");\n\tint result = 0;\n\tif (to_xml) {\n\t    result = Xmlcode::writeFile (c, ofname);\n\t}\n\telse {\n\t    result = Bytecode::writeFile (c, ofname);\n\t}\n\treturn result ? 0 : 1;\n    }\n\n    return 2;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int to_xml = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic int to_xml = 0;\n\nint\ncompilefile (const char *infname, const char *outfname)\n{\n    string ofname = infname;\n\n    if (outfname != NULL)\n    {\n\tofname = outfname;\n    }\n    else\n    {\n\tint len = ofname.size ();\n\tif (len > 4 && ofname.substr (len-4, 4) == \".ycp\")\n\t{\n\t    ofname = ofname.replace (len-4, 4, to_xml ? \".xml\" : \".ybc\");\n\t}\n\telse\n\t{\n\t    ofname += to_xml ? \".xml\" : \".ybc\";\n\t}\n    }\n    progress (\"compiling to '%s'\\n\", ofname.c_str ());\n\n    YCodePtr c = parsefile (infname);\n\n    if (c != NULL )\n    {\n\tprogress (\"saving ...\\n\");\n\tint result = 0;\n\tif (to_xml) {\n\t    result = Xmlcode::writeFile (c, ofname);\n\t}\n\telse {\n\t    result = Bytecode::writeFile (c, ofname);\n\t}\n\treturn result ? 0 : 1;\n    }\n\n    return 2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic int quiet = 0;\nstatic int parse = 0;\nstatic int compile = 0;\nstatic int read_n_print = 0;\nstatic int read_n_run = 0;\nstatic const char *ui_name = 0;\n\nint\nprocessfile (const char *infname, const char *outfname)\n{\n    if (compile)\n    {\n\treturn compilefile (infname, outfname);\n    }\n\n    if (parse)\n    {\n\tYCodePtr c = parsefile (infname);\n\n\tif (c == NULL) return 1;\n\n\tif (quiet) return 0;\n\n\treturn printcode (outfname, c);\n    }\n\n    if (read_n_print)\n    {\n\tprogress (\"Reading: %s\\n\", infname);\n\tYCodePtr c = Bytecode::readFile (infname);\n\tif (c == 0)\n\t{\n\t    progress (\"Bytecode read failed\\n\");\n\t    return 1;\n\t}\n\n\tprogress (\"Result:\\n\");\n\n\treturn printcode (outfname, c);\n    }\n\n    if (read_n_run)\n    {\n\tprogress (\"Reading:\\n\");\n\tYCodePtr c = Bytecode::readFile (infname);\n\tprogress (\"Running:\\n\");\n\n\tY2Component *server = Y2ComponentBroker::createServer (ui_name);\n\tif (!server)\n\t{\n\t    fprintf (stderr, \"Can't start UI component '%s'\", ui_name);\n\t    return 1;\n\t}\n\n\tYCPValue result = c->evaluate();\n\tprogress (\"Result:\\n\");\n\n\treturn printcode (outfname, result);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "printcode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "954-985",
    "snippet": "int printcode (const char *outfname, const toStringAble & c)\n{\n    std::ofstream outstream;\n\n    // print out the result\n    if (outfname != NULL\n\t&& *outfname != '-')\n    {\n\toutstream.open (outfname, std::ios::out);\n    }\n\n    if (!outstream.is_open ())\n    {\n\tif ((outfname != NULL) && (*outfname != '-'))\n\t{\n\t    fprintf (stderr, \"Can't write ''%s''\\n\", (outfname==0)?\"<unknown>\":outfname);\n\t    return 1;\n\t}\n    }\n\n    progress (\"Parsed:\\n\");\n    if (outstream.is_open())\n    {\n\toutstream << c->toString() << endl;\n    }\n    else\n    {\n\tstd::cout << c->toString() << endl;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->toString",
          "args": [],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FileDep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "326-333",
          "snippet": "std::string\nFileDep::toString () const\n{\n    return string (m_is_module ? \"module \\\"\" : \"include \\\"\")\n\t    + m_name\n\t    + string (\"\\\" at '\")\n\t    + m_path + string (\"'\");\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nFileDep {\n  std::string\n  FileDep::toString () const\n  {\n      return string (m_is_module ? \"module \\\"\" : \"include \\\"\")\n  \t    + m_name\n  \t    + string (\"\\\" at '\")\n  \t    + m_path + string (\"'\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "outstream.is_open",
          "args": [],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "progress",
          "args": [
            "\"Parsed:\\n\""
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Can't write ''%s''\\n\"",
            "(outfname==0)?\"<unknown>\":outfname"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outstream.is_open",
          "args": [],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outstream.open",
          "args": [
            "outfname",
            "std::ios::out"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nint printcode (const char *outfname, const toStringAble & c)\n{\n    std::ofstream outstream;\n\n    // print out the result\n    if (outfname != NULL\n\t&& *outfname != '-')\n    {\n\toutstream.open (outfname, std::ios::out);\n    }\n\n    if (!outstream.is_open ())\n    {\n\tif ((outfname != NULL) && (*outfname != '-'))\n\t{\n\t    fprintf (stderr, \"Can't write ''%s''\\n\", (outfname==0)?\"<unknown>\":outfname);\n\t    return 1;\n\t}\n    }\n\n    progress (\"Parsed:\\n\");\n    if (outstream.is_open())\n    {\n\toutstream << c->toString() << endl;\n    }\n    else\n    {\n\tstd::cout << c->toString() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "compilefile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "905-944",
    "snippet": "int\ncompilefile (const char *infname, const char *outfname)\n{\n    string ofname = infname;\n\n    if (outfname != NULL)\n    {\n\tofname = outfname;\n    }\n    else\n    {\n\tint len = ofname.size ();\n\tif (len > 4 && ofname.substr (len-4, 4) == \".ycp\")\n\t{\n\t    ofname = ofname.replace (len-4, 4, to_xml ? \".xml\" : \".ybc\");\n\t}\n\telse\n\t{\n\t    ofname += to_xml ? \".xml\" : \".ybc\";\n\t}\n    }\n    progress (\"compiling to '%s'\\n\", ofname.c_str ());\n\n    YCodePtr c = parsefile (infname);\n\n    if (c != NULL )\n    {\n\tprogress (\"saving ...\\n\");\n\tint result = 0;\n\tif (to_xml) {\n\t    result = Xmlcode::writeFile (c, ofname);\n\t}\n\telse {\n\t    result = Bytecode::writeFile (c, ofname);\n\t}\n\treturn result ? 0 : 1;\n    }\n\n    return 2;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int to_xml = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::writeFile",
          "args": [
            "c",
            "ofname"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "writeFile",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "1175-1197",
          "snippet": "bool\nBytecode::writeFile (const YCodePtr code, const string & filename)\n{\n    // clear errno first\n    errno = 0;\n\n#if DO_DEBUG\n//    y2debug (\"Bytecode::writeFile (%s)\", filename.c_str());\n#endif\n    std::ofstream outstream (filename.c_str());\n    if (!outstream.is_open ())\n    {\n\ty2error (\"Failed to write '%s': %s\", filename.c_str(), strerror (errno));\n\treturn false;\n    }\n\n    string header =  string (YaST_BYTECODE_HEADER YaST_BYTECODE_MAJOR \".\" YaST_BYTECODE_MINOR \".\" YaST_BYTECODE_RELEASE);\n    outstream.write (header.c_str(), header.size() + 1);\t// including trailing \\0\n\n    code->toStream (outstream);\n\n    return ! outstream.fail ();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define YaST_BYTECODE_RELEASE \"0\"",
            "#define YaST_BYTECODE_MINOR \"4\"",
            "#define YaST_BYTECODE_MAJOR \"1\"",
            "#define YaST_BYTECODE_HEADER \"YaST bytecode \"",
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define YaST_BYTECODE_RELEASE \"0\"\n#define YaST_BYTECODE_MINOR \"4\"\n#define YaST_BYTECODE_MAJOR \"1\"\n#define YaST_BYTECODE_HEADER \"YaST bytecode \"\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::writeFile (const YCodePtr code, const string & filename)\n  {\n      // clear errno first\n      errno = 0;\n  \n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::writeFile (%s)\", filename.c_str());\n  #endif\n      std::ofstream outstream (filename.c_str());\n      if (!outstream.is_open ())\n      {\n  \ty2error (\"Failed to write '%s': %s\", filename.c_str(), strerror (errno));\n  \treturn false;\n      }\n  \n      string header =  string (YaST_BYTECODE_HEADER YaST_BYTECODE_MAJOR \".\" YaST_BYTECODE_MINOR \".\" YaST_BYTECODE_RELEASE);\n      outstream.write (header.c_str(), header.size() + 1);\t// including trailing \\0\n  \n      code->toStream (outstream);\n  \n      return ! outstream.fail ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Xmlcode::writeFile",
          "args": [
            "c",
            "ofname"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "writeFile",
          "container": "Xmlcode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
          "lines": "824-842",
          "snippet": "bool\nXmlcode::writeFile( const YCodePtr code, const string & filename)\n{\n    // clear errno first\n    errno = 0;\n\n    std::ofstream outstream( filename.c_str());\n    if( !outstream.is_open( ))\n    {\n\ty2error( \"Failed to write '%s': %s\", filename.c_str(), strerror( errno));\n\treturn false;\n    }\n\n    outstream << \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\";\n    outstream << \"<ycp version=\\\"2.15.8.39280\\\">\\n\";\n    code->toXml( outstream, 2 );\n    outstream << \"</ycp>\\n\";\n    return ! outstream.fail( );\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Xmlcode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\nXmlcode {\n  bool\n  Xmlcode::writeFile( const YCodePtr code, const string & filename)\n  {\n      // clear errno first\n      errno = 0;\n  \n      std::ofstream outstream( filename.c_str());\n      if( !outstream.is_open( ))\n      {\n  \ty2error( \"Failed to write '%s': %s\", filename.c_str(), strerror( errno));\n  \treturn false;\n      }\n  \n      outstream << \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\";\n      outstream << \"<ycp version=\\\"2.15.8.39280\\\">\\n\";\n      code->toXml( outstream, 2 );\n      outstream << \"</ycp>\\n\";\n      return ! outstream.fail( );\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "progress",
          "args": [
            "\"saving ...\\n\""
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsefile",
          "args": [
            "infname"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "parsefile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "825-893",
          "snippet": "YCodePtr\nparsefile (const char *infname)\n{\n    if (infname == NULL)\n    {\n\tfprintf (stderr, \"No input file given\\n\");\n\treturn NULL;\n    }\n\n    if (parser == NULL)\n    {\n\tparser = new Parser();\n\n\tif (parser == NULL)\n\t{\n\t    fprintf (stderr, \"Can't create parser\\n\");\n\t    return NULL;\n\t}\n    }\n\n    FILE *infile;\n    if (!strcmp (infname, \"-\"))\n    {\n\tinfile = stdin;\n    }\n    else\n    {\n\tinfile = fopen (infname, \"r\");\n    }\n\n    if (infile == NULL)\n    {\n\tfprintf (stderr, \"Can't read '%s'\\n\", infname);\n\treturn NULL;\n    }\n\n    progress (\"parsing '%s'\\n\", infname);\n\n    parser->setInput (infile, infname);\n    parser->setBuffered();\n\n    if (verbose > 2) SymbolTableDebug = 1;\n\n    YCodePtr c = NULL;\n\n    c = parser->parse ();\n    \n    int ln = parser->scanner ()->lineNumber ();\n    \n    if (! parser->atEOF () && parser->scanner ()->yylex () != END_OF_FILE)\n    {\n\tee.setFilename (parser->scanner ()->filename ());\n\tee.setLinenumber (ln);\n\tycperror (\"Unreachable code at the end of file\");\n\tc = NULL;\n    }\n\n    fclose (infile);\n\n    if (c == NULL || c->isError ())\n    {\n\tprogress (\"Error\\n\");\n\treturn NULL;\n    }\n\n    progress (\"done\\n\");\n\n    return c;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int SymbolTableDebug;",
            "static Parser *parser = NULL;",
            "extern ExecutionEnvironment ee;",
            "static int verbose = 0;",
            "static int parse = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nextern int SymbolTableDebug;\nstatic Parser *parser = NULL;\nextern ExecutionEnvironment ee;\nstatic int verbose = 0;\nstatic int parse = 0;\n\nYCodePtr\nparsefile (const char *infname)\n{\n    if (infname == NULL)\n    {\n\tfprintf (stderr, \"No input file given\\n\");\n\treturn NULL;\n    }\n\n    if (parser == NULL)\n    {\n\tparser = new Parser();\n\n\tif (parser == NULL)\n\t{\n\t    fprintf (stderr, \"Can't create parser\\n\");\n\t    return NULL;\n\t}\n    }\n\n    FILE *infile;\n    if (!strcmp (infname, \"-\"))\n    {\n\tinfile = stdin;\n    }\n    else\n    {\n\tinfile = fopen (infname, \"r\");\n    }\n\n    if (infile == NULL)\n    {\n\tfprintf (stderr, \"Can't read '%s'\\n\", infname);\n\treturn NULL;\n    }\n\n    progress (\"parsing '%s'\\n\", infname);\n\n    parser->setInput (infile, infname);\n    parser->setBuffered();\n\n    if (verbose > 2) SymbolTableDebug = 1;\n\n    YCodePtr c = NULL;\n\n    c = parser->parse ();\n    \n    int ln = parser->scanner ()->lineNumber ();\n    \n    if (! parser->atEOF () && parser->scanner ()->yylex () != END_OF_FILE)\n    {\n\tee.setFilename (parser->scanner ()->filename ());\n\tee.setLinenumber (ln);\n\tycperror (\"Unreachable code at the end of file\");\n\tc = NULL;\n    }\n\n    fclose (infile);\n\n    if (c == NULL || c->isError ())\n    {\n\tprogress (\"Error\\n\");\n\treturn NULL;\n    }\n\n    progress (\"done\\n\");\n\n    return c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "progress",
          "args": [
            "\"compiling to '%s'\\n\"",
            "ofname.c_str ()"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ofname.c_str",
          "args": [],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ofname.replace",
          "args": [
            "len-4",
            "4",
            "to_xml ? \".xml\" : \".ybc\""
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ofname.substr",
          "args": [
            "len-4",
            "4"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ofname.size",
          "args": [],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic int to_xml = 0;\n\nint\ncompilefile (const char *infname, const char *outfname)\n{\n    string ofname = infname;\n\n    if (outfname != NULL)\n    {\n\tofname = outfname;\n    }\n    else\n    {\n\tint len = ofname.size ();\n\tif (len > 4 && ofname.substr (len-4, 4) == \".ycp\")\n\t{\n\t    ofname = ofname.replace (len-4, 4, to_xml ? \".xml\" : \".ybc\");\n\t}\n\telse\n\t{\n\t    ofname += to_xml ? \".xml\" : \".ybc\";\n\t}\n    }\n    progress (\"compiling to '%s'\\n\", ofname.c_str ());\n\n    YCodePtr c = parsefile (infname);\n\n    if (c != NULL )\n    {\n\tprogress (\"saving ...\\n\");\n\tint result = 0;\n\tif (to_xml) {\n\t    result = Xmlcode::writeFile (c, ofname);\n\t}\n\telse {\n\t    result = Bytecode::writeFile (c, ofname);\n\t}\n\treturn result ? 0 : 1;\n    }\n\n    return 2;\n}"
  },
  {
    "function_name": "parsefile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "825-893",
    "snippet": "YCodePtr\nparsefile (const char *infname)\n{\n    if (infname == NULL)\n    {\n\tfprintf (stderr, \"No input file given\\n\");\n\treturn NULL;\n    }\n\n    if (parser == NULL)\n    {\n\tparser = new Parser();\n\n\tif (parser == NULL)\n\t{\n\t    fprintf (stderr, \"Can't create parser\\n\");\n\t    return NULL;\n\t}\n    }\n\n    FILE *infile;\n    if (!strcmp (infname, \"-\"))\n    {\n\tinfile = stdin;\n    }\n    else\n    {\n\tinfile = fopen (infname, \"r\");\n    }\n\n    if (infile == NULL)\n    {\n\tfprintf (stderr, \"Can't read '%s'\\n\", infname);\n\treturn NULL;\n    }\n\n    progress (\"parsing '%s'\\n\", infname);\n\n    parser->setInput (infile, infname);\n    parser->setBuffered();\n\n    if (verbose > 2) SymbolTableDebug = 1;\n\n    YCodePtr c = NULL;\n\n    c = parser->parse ();\n    \n    int ln = parser->scanner ()->lineNumber ();\n    \n    if (! parser->atEOF () && parser->scanner ()->yylex () != END_OF_FILE)\n    {\n\tee.setFilename (parser->scanner ()->filename ());\n\tee.setLinenumber (ln);\n\tycperror (\"Unreachable code at the end of file\");\n\tc = NULL;\n    }\n\n    fclose (infile);\n\n    if (c == NULL || c->isError ())\n    {\n\tprogress (\"Error\\n\");\n\treturn NULL;\n    }\n\n    progress (\"done\\n\");\n\n    return c;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern int SymbolTableDebug;",
      "static Parser *parser = NULL;",
      "extern ExecutionEnvironment ee;",
      "static int verbose = 0;",
      "static int parse = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "progress",
          "args": [
            "\"done\\n\""
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "progress",
          "args": [
            "\"Error\\n\""
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->isError",
          "args": [],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "isError",
          "container": "YCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "76-80",
          "snippet": "bool\nYCode::isError() const\n{\n    return false; \t\t// TODO unused in practice?\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  bool\n  YCode::isError() const\n  {\n      return false; \t\t// TODO unused in practice?\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "infile"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycperror",
          "args": [
            "\"Unreachable code at the end of file\""
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee.setLinenumber",
          "args": [
            "ln"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "setLinenumber",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "48-52",
          "snippet": "void\nExecutionEnvironment::setLinenumber (int line)\n{\n    m_linenumber = line;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  void\n  ExecutionEnvironment::setLinenumber (int line)\n  {\n      m_linenumber = line;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.setFilename",
          "args": [
            "parser->scanner ()->filename ()"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "setFilename",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "87-96",
          "snippet": "void\nYCPDebugger::setFilename (const char *filename)\n{\n    y2debug (\"setFilename (%s)\\n\", filename);\n    if (filename)\n    {\n\tm_filename = filename;\n    }\n    return;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::setFilename (const char *filename)\n  {\n      y2debug (\"setFilename (%s)\\n\", filename);\n      if (filename)\n      {\n  \tm_filename = filename;\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->scanner",
          "args": [],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->scanner",
          "args": [],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->scanner",
          "args": [],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->scanner",
          "args": [],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->atEOF",
          "args": [],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "atEOF",
          "container": "Parser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Parser.cc",
          "lines": "134-138",
          "snippet": "bool\nParser::atEOF()\n{\n    return m_at_eof;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Parser.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Parser.h\"\n#include <stdlib.h>\n\nParser {\n  bool\n  Parser::atEOF()\n  {\n      return m_at_eof;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->scanner",
          "args": [],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->scanner",
          "args": [],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->parse",
          "args": [],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "IniParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "484-562",
          "snippet": "int IniParser::parse()\n{\n    if (multiple_files)\n    {\n\tglob_t do_files;\n\tint len = files.size ();\n\tint flags = 0;\n\tfor (int i = 0;i<len;i++)\n\t{\n\t    glob (files[i].c_str (),flags, NULL, &do_files);\n\t    flags = GLOB_APPEND;\n\t}\n\tchar**f = do_files.gl_pathv;\n\tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n\t{\n\t    int section_index = -1;\n\t    string section_name = *f;\n\t    //FIXME: create function out of it.\n\t    // do we have name rewrite rules?\n\t    for (size_t j = 0; j < rewrites.size (); j++)\n\t\t{\n\t\t    RegexMatch m (rewrites[j].rx, section_name);\n\t\t    if (m)\n\t\t    {\n\t\t\tsection_index = j;\n\t\t\tsection_name = m[1];\n\t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t    // do we know about the file?\n\t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n\t    if (ff == multi_files.end())\n\t    {\n\t\t// new file\n\t\tif (scanner_start (*f))\n\t\t    y2error (\"Cannot open %s.\", *f);\n\t\telse\n\t\t{\n\t\t    FileDescr fdsc (*f);\n\t\t    multi_files[*f] = fdsc;\n\t\t    inifile.initSection (section_name, \"\", -1, section_index);\n\t\t    parse_helper(inifile.getSection(section_name.c_str()));\n\t\t    scanner_stop();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif ((*ff).second.changed ())\n\t\t{\n\t\t    if (scanner_start (*f))\n\t\t\ty2error (\"Cannot open %s.\", *f);\n\t\t    else\n\t\t    {\n\t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n\t\t\tFileDescr fdsc (*f);\n\t\t\tmulti_files [*f] = fdsc;\n\t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n\t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n\t\t\tscanner_stop();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tif (scanner_start (file.c_str()))\n\t    {\n\t\ty2error (\"Can not open %s.\", file.c_str());\n\t\treturn -1;\n\t    }\n\tparse_helper(inifile);\n\tscanner_stop();\n\ttimestamp = getTimeStamp ();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::parse()\n  {\n      if (multiple_files)\n      {\n  \tglob_t do_files;\n  \tint len = files.size ();\n  \tint flags = 0;\n  \tfor (int i = 0;i<len;i++)\n  \t{\n  \t    glob (files[i].c_str (),flags, NULL, &do_files);\n  \t    flags = GLOB_APPEND;\n  \t}\n  \tchar**f = do_files.gl_pathv;\n  \tfor (unsigned int i = 0;i<do_files.gl_pathc;i++, f++)\n  \t{\n  \t    int section_index = -1;\n  \t    string section_name = *f;\n  \t    //FIXME: create function out of it.\n  \t    // do we have name rewrite rules?\n  \t    for (size_t j = 0; j < rewrites.size (); j++)\n  \t\t{\n  \t\t    RegexMatch m (rewrites[j].rx, section_name);\n  \t\t    if (m)\n  \t\t    {\n  \t\t\tsection_index = j;\n  \t\t\tsection_name = m[1];\n  \t\t\ty2debug (\"Rewriting %s to %s\", *f, section_name.c_str());\n  \t\t\tbreak;\n  \t\t    }\n  \t\t}\n  \n  \t    // do we know about the file?\n  \t    map<string,FileDescr>::iterator ff = multi_files.find (*f);\n  \t    if (ff == multi_files.end())\n  \t    {\n  \t\t// new file\n  \t\tif (scanner_start (*f))\n  \t\t    y2error (\"Cannot open %s.\", *f);\n  \t\telse\n  \t\t{\n  \t\t    FileDescr fdsc (*f);\n  \t\t    multi_files[*f] = fdsc;\n  \t\t    inifile.initSection (section_name, \"\", -1, section_index);\n  \t\t    parse_helper(inifile.getSection(section_name.c_str()));\n  \t\t    scanner_stop();\n  \t\t}\n  \t    }\n  \t    else\n  \t    {\n  \t\tif ((*ff).second.changed ())\n  \t\t{\n  \t\t    if (scanner_start (*f))\n  \t\t\ty2error (\"Cannot open %s.\", *f);\n  \t\t    else\n  \t\t    {\n  \t\t\ty2debug (\"File %s changed. Reloading.\", *f);\n  \t\t\tFileDescr fdsc (*f);\n  \t\t\tmulti_files [*f] = fdsc;\n  \t\t\tinifile.initSection (section_name, \"\", -1, section_index);\n  \t\t\tparse_helper(inifile.getSection(section_name.c_str()));\n  \t\t\tscanner_stop();\n  \t\t    }\n  \t\t}\n  \t    }\n  \t}\n      }\n      else\n      {\n  \tif (scanner_start (file.c_str()))\n  \t    {\n  \t\ty2error (\"Can not open %s.\", file.c_str());\n  \t\treturn -1;\n  \t    }\n  \tparse_helper(inifile);\n  \tscanner_stop();\n  \ttimestamp = getTimeStamp ();\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->setBuffered",
          "args": [],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "setBuffered",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "128-132",
          "snippet": "void\nScanner::setBuffered ()\n{\n    m_buffered = true;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  void\n  Scanner::setBuffered ()\n  {\n      m_buffered = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->setInput",
          "args": [
            "infile",
            "infname"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "setInput",
          "container": "Parser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Parser.cc",
          "lines": "108-115",
          "snippet": "void\nParser::setInput(int fd, const char *filename)\n{\n    if (m_scanner) delete m_scanner;\n    m_scanner = new Scanner (fd, filename);\n    if (m_buffered) m_scanner->setBuffered ();\n    m_at_eof = false;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include \"ycp/Parser.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include \"ycp/Parser.h\"\n#include <stdlib.h>\n\nParser {\n  void\n  Parser::setInput(int fd, const char *filename)\n  {\n      if (m_scanner) delete m_scanner;\n      m_scanner = new Scanner (fd, filename);\n      if (m_buffered) m_scanner->setBuffered ();\n      m_at_eof = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "progress",
          "args": [
            "\"parsing '%s'\\n\"",
            "infname"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Can't read '%s'\\n\"",
            "infname"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "infname",
            "\"r\""
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "infname",
            "\"-\""
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Can't create parser\\n\""
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"No input file given\\n\""
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nextern int SymbolTableDebug;\nstatic Parser *parser = NULL;\nextern ExecutionEnvironment ee;\nstatic int verbose = 0;\nstatic int parse = 0;\n\nYCodePtr\nparsefile (const char *infname)\n{\n    if (infname == NULL)\n    {\n\tfprintf (stderr, \"No input file given\\n\");\n\treturn NULL;\n    }\n\n    if (parser == NULL)\n    {\n\tparser = new Parser();\n\n\tif (parser == NULL)\n\t{\n\t    fprintf (stderr, \"Can't create parser\\n\");\n\t    return NULL;\n\t}\n    }\n\n    FILE *infile;\n    if (!strcmp (infname, \"-\"))\n    {\n\tinfile = stdin;\n    }\n    else\n    {\n\tinfile = fopen (infname, \"r\");\n    }\n\n    if (infile == NULL)\n    {\n\tfprintf (stderr, \"Can't read '%s'\\n\", infname);\n\treturn NULL;\n    }\n\n    progress (\"parsing '%s'\\n\", infname);\n\n    parser->setInput (infile, infname);\n    parser->setBuffered();\n\n    if (verbose > 2) SymbolTableDebug = 1;\n\n    YCodePtr c = NULL;\n\n    c = parser->parse ();\n    \n    int ln = parser->scanner ()->lineNumber ();\n    \n    if (! parser->atEOF () && parser->scanner ()->yylex () != END_OF_FILE)\n    {\n\tee.setFilename (parser->scanner ()->filename ());\n\tee.setLinenumber (ln);\n\tycperror (\"Unreachable code at the end of file\");\n\tc = NULL;\n    }\n\n    fclose (infile);\n\n    if (c == NULL || c->isError ())\n    {\n\tprogress (\"Error\\n\");\n\treturn NULL;\n    }\n\n    progress (\"done\\n\");\n\n    return c;\n}"
  },
  {
    "function_name": "recompileAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "812-816",
    "snippet": "int\nrecompileAll (const std::list<std::string> & deplist, const char *depend)\n{\n    return 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nint\nrecompileAll (const std::list<std::string> & deplist, const char *depend)\n{\n    return 0;\n}"
  },
  {
    "function_name": "depTree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "711-802",
    "snippet": "std::list<FileDep>\ndepTree (std::string module, const std::map<std::string, std::list<FileDep> > & depmap)\n{\n    static std::map<std::string, int> seenmap;\n    std::list<FileDep> ret;\n\n    if (verbose > 1) printf (\"depTree (%s)\\n\", module.c_str());\n\n    if (module.empty())\n    {\n\tif (verbose > 1) printf (\"initialize\\n\");\n\tseenmap.clear();\n\tif (depmap.empty())\n\t{\n\t    fprintf (stderr, \"No dependencies found\\n\");\n\t}\n\treturn ret;\n    }\n\n    if (seenmap.find (module) != seenmap.end())\t\t// already seen this module\n    {\n\tif (verbose > 1) printf (\"-- already seen %s\\n\", module.c_str());\n\treturn ret;\n    }\n\n    seenmap[module] = 1;\n\n    std::map<std::string, std::list<FileDep> >::const_iterator it = depmap.find (module);\n\n    if (it == depmap.end())\n    {\n\tfprintf (stderr, \"Can't find '%s' in dependency map\\n\", module.c_str());\n\treturn ret;\n    }\n\n    if (verbose > 1) printf (\"\\nCheck '%s': \", module.c_str()); fflush (stdout);\n\n    std::list<FileDep> dl = it->second;\t\t// get <mod> <imp> <imp> <imp> list\n\n    if (dl.size() == 0)\n    {\n\tfprintf (stderr, \"%s not a module ?\\n\", module.c_str());\n\treturn ret;\n    }\n    else if (dl.size() < 2)\t\t\t\t// no further dependencies\n    {\n\tif (verbose > 1) printf (\"-- leaf\\n\");\n\treturn ret;\n    }\n\n    // recurse dependencies\n\n    // first push all dependencies for the current module\n\n    std::list<FileDep>::iterator dli = dl.begin();\n    dli++;\t\t\t\t\t\t// skip initial module\n\n    while (dli != dl.end())\n    {\n\tstd::string name = dli->name();\n\tif (seenmap.find (name) == seenmap.end())\t\t// not seen this name before\n\t{\n\t    if (verbose > 1) printf (\"%s -> %s: \", module.c_str(), name.c_str());\n\t    std::list<FileDep> l = depTree (name, depmap);\t// recusion point\n\t    if (verbose > 1) printf (\"%s -> %s done\\n\", module.c_str(), name.c_str());\n\n\t    std::list<FileDep>::iterator it;\n\t    for (it = l.begin(); it != l.end(); it++)\n\t    {\n\t\tret.push_back (*it);\n\t    }\n\n\t    // then push the current name\n\n\t    ret.push_back (*dli);\n\t}\n\n\tdli++;\n    }\n\n    if (verbose > 1)\n    {\n\tprintf (\"(%s:\", module.c_str()); fflush (stdout);\n\tstd::list<FileDep>::iterator rit;\n\tfor (rit = ret.begin(); rit != ret.end(); rit++)\n\t{\n\t    printf (\" %s\", rit->name().c_str());\n\t}\n\tprintf (\")\\n\");\n    }\n    return ret;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int verbose = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\")\\n\""
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" %s\"",
            "rit->name().c_str()"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rit->name",
          "args": [],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2AgentComp",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "44-44",
          "snippet": "string name () const { return my_name; }",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp {\n  string name () const { return my_name; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ret.end",
          "args": [],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ret.begin",
          "args": [],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"(%s:\"",
            "module.c_str()"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret.push_back",
          "args": [
            "*dli"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s -> %s done\\n\"",
            "module.c_str()",
            "name.c_str()"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depTree",
          "args": [
            "name",
            "depmap"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "depTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "711-802",
          "snippet": "std::list<FileDep>\ndepTree (std::string module, const std::map<std::string, std::list<FileDep> > & depmap)\n{\n    static std::map<std::string, int> seenmap;\n    std::list<FileDep> ret;\n\n    if (verbose > 1) printf (\"depTree (%s)\\n\", module.c_str());\n\n    if (module.empty())\n    {\n\tif (verbose > 1) printf (\"initialize\\n\");\n\tseenmap.clear();\n\tif (depmap.empty())\n\t{\n\t    fprintf (stderr, \"No dependencies found\\n\");\n\t}\n\treturn ret;\n    }\n\n    if (seenmap.find (module) != seenmap.end())\t\t// already seen this module\n    {\n\tif (verbose > 1) printf (\"-- already seen %s\\n\", module.c_str());\n\treturn ret;\n    }\n\n    seenmap[module] = 1;\n\n    std::map<std::string, std::list<FileDep> >::const_iterator it = depmap.find (module);\n\n    if (it == depmap.end())\n    {\n\tfprintf (stderr, \"Can't find '%s' in dependency map\\n\", module.c_str());\n\treturn ret;\n    }\n\n    if (verbose > 1) printf (\"\\nCheck '%s': \", module.c_str()); fflush (stdout);\n\n    std::list<FileDep> dl = it->second;\t\t// get <mod> <imp> <imp> <imp> list\n\n    if (dl.size() == 0)\n    {\n\tfprintf (stderr, \"%s not a module ?\\n\", module.c_str());\n\treturn ret;\n    }\n    else if (dl.size() < 2)\t\t\t\t// no further dependencies\n    {\n\tif (verbose > 1) printf (\"-- leaf\\n\");\n\treturn ret;\n    }\n\n    // recurse dependencies\n\n    // first push all dependencies for the current module\n\n    std::list<FileDep>::iterator dli = dl.begin();\n    dli++;\t\t\t\t\t\t// skip initial module\n\n    while (dli != dl.end())\n    {\n\tstd::string name = dli->name();\n\tif (seenmap.find (name) == seenmap.end())\t\t// not seen this name before\n\t{\n\t    if (verbose > 1) printf (\"%s -> %s: \", module.c_str(), name.c_str());\n\t    std::list<FileDep> l = depTree (name, depmap);\t// recusion point\n\t    if (verbose > 1) printf (\"%s -> %s done\\n\", module.c_str(), name.c_str());\n\n\t    std::list<FileDep>::iterator it;\n\t    for (it = l.begin(); it != l.end(); it++)\n\t    {\n\t\tret.push_back (*it);\n\t    }\n\n\t    // then push the current name\n\n\t    ret.push_back (*dli);\n\t}\n\n\tdli++;\n    }\n\n    if (verbose > 1)\n    {\n\tprintf (\"(%s:\", module.c_str()); fflush (stdout);\n\tstd::list<FileDep>::iterator rit;\n\tfor (rit = ret.begin(); rit != ret.end(); rit++)\n\t{\n\t    printf (\" %s\", rit->name().c_str());\n\t}\n\tprintf (\")\\n\");\n    }\n    return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s -> %s: \"",
            "module.c_str()",
            "name.c_str()"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seenmap.find",
          "args": [
            "name"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"-- leaf\\n\""
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl.size",
          "args": [],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s not a module ?\\n\"",
            "module.c_str()"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nCheck '%s': \"",
            "module.c_str()"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Can't find '%s' in dependency map\\n\"",
            "module.c_str()"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depmap.find",
          "args": [
            "module"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"-- already seen %s\\n\"",
            "module.c_str()"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seenmap.find",
          "args": [
            "module"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"No dependencies found\\n\""
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depmap.empty",
          "args": [],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "seenmap.clear",
          "args": [],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/PathInfo.h",
          "lines": "461-461",
          "snippet": "void clear() { _devino.clear(); }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <map>",
            "#include <set>",
            "#include <list>",
            "#include <iosfwd>",
            "#include <cerrno>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <map>\n#include <set>\n#include <list>\n#include <iosfwd>\n#include <cerrno>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid clear() { _devino.clear(); }"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"initialize\\n\""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"depTree (%s)\\n\"",
            "module.c_str()"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic int verbose = 0;\n\nstd::list<FileDep>\ndepTree (std::string module, const std::map<std::string, std::list<FileDep> > & depmap)\n{\n    static std::map<std::string, int> seenmap;\n    std::list<FileDep> ret;\n\n    if (verbose > 1) printf (\"depTree (%s)\\n\", module.c_str());\n\n    if (module.empty())\n    {\n\tif (verbose > 1) printf (\"initialize\\n\");\n\tseenmap.clear();\n\tif (depmap.empty())\n\t{\n\t    fprintf (stderr, \"No dependencies found\\n\");\n\t}\n\treturn ret;\n    }\n\n    if (seenmap.find (module) != seenmap.end())\t\t// already seen this module\n    {\n\tif (verbose > 1) printf (\"-- already seen %s\\n\", module.c_str());\n\treturn ret;\n    }\n\n    seenmap[module] = 1;\n\n    std::map<std::string, std::list<FileDep> >::const_iterator it = depmap.find (module);\n\n    if (it == depmap.end())\n    {\n\tfprintf (stderr, \"Can't find '%s' in dependency map\\n\", module.c_str());\n\treturn ret;\n    }\n\n    if (verbose > 1) printf (\"\\nCheck '%s': \", module.c_str()); fflush (stdout);\n\n    std::list<FileDep> dl = it->second;\t\t// get <mod> <imp> <imp> <imp> list\n\n    if (dl.size() == 0)\n    {\n\tfprintf (stderr, \"%s not a module ?\\n\", module.c_str());\n\treturn ret;\n    }\n    else if (dl.size() < 2)\t\t\t\t// no further dependencies\n    {\n\tif (verbose > 1) printf (\"-- leaf\\n\");\n\treturn ret;\n    }\n\n    // recurse dependencies\n\n    // first push all dependencies for the current module\n\n    std::list<FileDep>::iterator dli = dl.begin();\n    dli++;\t\t\t\t\t\t// skip initial module\n\n    while (dli != dl.end())\n    {\n\tstd::string name = dli->name();\n\tif (seenmap.find (name) == seenmap.end())\t\t// not seen this name before\n\t{\n\t    if (verbose > 1) printf (\"%s -> %s: \", module.c_str(), name.c_str());\n\t    std::list<FileDep> l = depTree (name, depmap);\t// recusion point\n\t    if (verbose > 1) printf (\"%s -> %s done\\n\", module.c_str(), name.c_str());\n\n\t    std::list<FileDep>::iterator it;\n\t    for (it = l.begin(); it != l.end(); it++)\n\t    {\n\t\tret.push_back (*it);\n\t    }\n\n\t    // then push the current name\n\n\t    ret.push_back (*dli);\n\t}\n\n\tdli++;\n    }\n\n    if (verbose > 1)\n    {\n\tprintf (\"(%s:\", module.c_str()); fflush (stdout);\n\tstd::list<FileDep>::iterator rit;\n\tfor (rit = ret.begin(); rit != ret.end(); rit++)\n\t{\n\t    printf (\" %s\", rit->name().c_str());\n\t}\n\tprintf (\")\\n\");\n    }\n    return ret;\n}"
  },
  {
    "function_name": "makeDependMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "609-702",
    "snippet": "std::map <std::string, std::list <FileDep> >\nmakeDependMap (const std::list<FileDep> & dep)\n{\n    if (verbose) printf (\"makeDependMap (), %zu files\\n\", dep.size());\n\n    std::map <std::string, std::list <FileDep> > depmap;\n\n    if (dep.empty())\n    {\n\tfprintf (stderr, \"makeDependMap, empty input!\\n\");\n\treturn depmap;\n    }\n\n    std::list<FileDep>::const_iterator depit;\n    std::list<FileDep> resolved;\n\n    for (depit = dep.begin(); depit != dep.end(); depit++)\n    {\n\tresolved = parseFile (depit->path().c_str(), depit->name().c_str());\n\tif (resolved.empty())\n\t{\n\t    fprintf (stderr, \"Couldn't parse file '%s'\\n\", depit->path().c_str());\n\t    continue;\n\t}\n\n\tdepmap[resolved.front().name()] = resolved;\n\n\tif (verbose > 2)\n\t{\n\t    printf (\"Map %s: %zu entries\\n\", resolved.front().name().c_str(), resolved.size());\n\t}\n\n\tif (verbose > 1)\n\t{\n\t    std::list<FileDep>::iterator resit = resolved.begin();\n\t    printf (\"%s needs \", resit->toString().c_str());\n\t    resit++;\n\t    if (resit == resolved.end())\n\t    {\n\t\tprintf (\"nothing\");\n\t    }\n\t    else while (resit != resolved.end())\n\t    {\n\t\tprintf (\"\\n\\t%s\", resit->toString().c_str());\n\t\tresit++;\n\t    }\n\t    printf (\"\\n\");\n\t}\n    }\n\n    // now go through all map entries and resolve them\n    std::map <std::string, std::list <FileDep> >::iterator mapit;\n    bool found_unsolved = true;\n    while (found_unsolved)\n    {\n\tstd::list<FileDep>::iterator depit;\n\n\tfound_unsolved = false;\n\n\tif (depmap.empty())\n\t{\n\t    fprintf (stderr, \"Empty map ?!\\n\");\n\t    break;\n\t}\n\n\tfor (mapit = depmap.begin(); mapit != depmap.end(); mapit++)\n\t{\n\t    if (mapit->second.empty())\n\t    {\n\t\tfprintf (stderr, \"Map entry %s empty !\\n\", mapit->first.c_str());\n\t\tbreak;\n\t    }\n\t    for (depit = mapit->second.begin(); depit != mapit->second.end(); depit++)\n\t    {\n\t\tif (depmap.find (depit->name()) == depmap.end())\n\t\t{\n\t\t    resolved = parseFile (depit->path().c_str(), depit->name().c_str());\n\t\t    if (resolved.empty())\n\t\t    {\n\t\t\tfprintf (stderr, \"Couldn't parse file '%s'\\n\", depit->path().c_str());\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (verbose > 1) printf (\"Solved %s as %s\\n\", depit->name().c_str(), resolved.front().name().c_str());\n\t\t    depmap[resolved.front().name()] = resolved;\n\t\t    found_unsolved = true;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (found_unsolved) break;\n\t}\n    }\n\n    return depmap;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int verbose = 0;",
      "static int parse = 0;",
      "static recurseT *recurseStart (const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "resolved.front",
          "args": [],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolved.front",
          "args": [],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Solved %s as %s\\n\"",
            "depit->name().c_str()",
            "resolved.front().name().c_str()"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolved.front",
          "args": [],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolved.front",
          "args": [],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolved.front",
          "args": [],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depit->name",
          "args": [],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2AgentComp",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "44-44",
          "snippet": "string name () const { return my_name; }",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp {\n  string name () const { return my_name; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Couldn't parse file '%s'\\n\"",
            "depit->path().c_str()"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depit->path",
          "args": [],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depit->path",
          "args": [],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolved.empty",
          "args": [],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseFile",
          "args": [
            "depit->path().c_str()",
            "depit->name().c_str()"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "parseFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "397-533",
          "snippet": "std::list <FileDep>\nparseFile (const char *path, const char *expected)\n{\n    if (verbose > 1) printf (\"List dependencies for '%s'\\n\", path);\n\n#define LBUFSIZE 8192\n    char lbuf[LBUFSIZE];\n\n    std::list <FileDep> deplist;\n\n    FILE *f = fopen (path, \"r\");\n    if (f == 0)\n    {\n\tperror (path);\n\treturn deplist;\n    }\n\n    char *lptr;\n    int lcount = 0;\n\n    bool have_module = false;\n\n    while (fgets (lbuf, LBUFSIZE-1, f) != 0)\n    {\n\tlcount++;\n\tlptr = lbuf;\n\twhile (isblank (*lptr)) lptr++;\n\n\tif ((*lptr == 'm')\n\t    && (strncmp (lptr + 1, \"odule\", 5) == 0))\t\t// module\n\t{\n\t    lptr += 6;\n\t    while (isblank (*lptr)) lptr++;\n\t    if (*lptr++ != '\"') continue;\n\t    char *name = lptr;\n\t    while (*lptr)\n\t    {\n\t\tif (*lptr == '\"')\n\t\t    break;\n\t\tlptr++;\n\t    }\n\t    *lptr++ = 0;\n\t    while (isblank (*lptr)) lptr++;\n\t    if (*lptr != ';') continue;\n\n\t    if (!deplist.empty())\n\t    {\n\t\tfprintf (stderr, \"Bad file '%s':\\nmodule statement at wrong postion\\nLine %d:[%s]\", path, lcount, lbuf);\n\t\tfprintf (stderr, \"Have already: %s\\n\", deplist.front().toString().c_str());\n\t\tdeplist.clear();\n\t\treturn deplist;\n\t    }\n\n\t    if (*expected\n\t\t&& strcmp (name, expected) != 0)\n\t    {\n\t\tfprintf (stderr, \"Module file %s does not have expected name '%s' but '%s'\\n\", path, expected, name);\n\t\treturn deplist;\n\t    }\n\t    have_module = true;\n\t    deplist.push_back (FileDep (name, path, true, false, 0, 0));\n\t}\n\telse if (*lptr == 'i')\n\t{\n\t    if (strncmp (lptr + 1, \"mport\", 5) == 0)\t\t// import\n\t    {\n\t\tlptr += 6;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr++ != '\"') continue;\n\t\tchar *name = lptr;\n\t\twhile (*lptr)\n\t\t{\n\t\t    if (*lptr == '\"')\n\t\t\tbreak;\n\t\t    lptr++;\n\t\t}\n\t\t*lptr++ = 0;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr != ';') continue;\n\n\t\tFileDep fd = resolveDep (name, true);\n\t\tif (fd.path().empty())\n\t\t{\n\t\t    fprintf (stderr, \"*** Error: Can't find module %s\\n\", name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    deplist.push_back (fd);\n\t\t}\n\t    }\n\t    else if (strncmp (lptr + 1, \"nclude\", 6) == 0)\t\t// include\n\t    {\n\t\tlptr += 7;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr++ != '\"') continue;\n\t\tchar *name = lptr;\n\t\twhile (*lptr)\n\t\t{\n\t\t    if (*lptr == '\"')\n\t\t    {\n\t\t\tbreak;\n\t\t    }\n\t\t    lptr++;\n\t\t}\n\t\t*lptr++ = 0;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr != ';') continue;\n\n\t\tFileDep fd = resolveDep (name, false);\n\t\tif (fd.path().empty())\n\t\t{\n\t\t    fprintf (stderr, \"*** Error: Can't find include %s\\n\", name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    deplist.push_back (fd);\n\t\t}\n\t    }\n\t} // 'i'include / 'i'mport\n    }\n\n    fclose (f);\n\n    // if no 'module' found -> generate fake include FileDep\n    if (!have_module)\n    {\n\tif (*expected == 0)\n\t{\n\t    fprintf (stderr, \"%s is not a module\\n\", path);\n\t    exit (1);\n\t}\n\tdeplist.push_front (FileDep (expected, path, false, false, 0, 0));\n    }\n\n    if (verbose > 1) printf (\"parseFile (%s) done\\n\", path);\n    return deplist;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [
            "#define LBUFSIZE 8192"
          ],
          "globals_used": [
            "static int verbose = 0;",
            "static recurseT *recurseStart (const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\n#define LBUFSIZE 8192\n\nstatic int verbose = 0;\nstatic recurseT *recurseStart (const char *path);\n\nstd::list <FileDep>\nparseFile (const char *path, const char *expected)\n{\n    if (verbose > 1) printf (\"List dependencies for '%s'\\n\", path);\n\n#define LBUFSIZE 8192\n    char lbuf[LBUFSIZE];\n\n    std::list <FileDep> deplist;\n\n    FILE *f = fopen (path, \"r\");\n    if (f == 0)\n    {\n\tperror (path);\n\treturn deplist;\n    }\n\n    char *lptr;\n    int lcount = 0;\n\n    bool have_module = false;\n\n    while (fgets (lbuf, LBUFSIZE-1, f) != 0)\n    {\n\tlcount++;\n\tlptr = lbuf;\n\twhile (isblank (*lptr)) lptr++;\n\n\tif ((*lptr == 'm')\n\t    && (strncmp (lptr + 1, \"odule\", 5) == 0))\t\t// module\n\t{\n\t    lptr += 6;\n\t    while (isblank (*lptr)) lptr++;\n\t    if (*lptr++ != '\"') continue;\n\t    char *name = lptr;\n\t    while (*lptr)\n\t    {\n\t\tif (*lptr == '\"')\n\t\t    break;\n\t\tlptr++;\n\t    }\n\t    *lptr++ = 0;\n\t    while (isblank (*lptr)) lptr++;\n\t    if (*lptr != ';') continue;\n\n\t    if (!deplist.empty())\n\t    {\n\t\tfprintf (stderr, \"Bad file '%s':\\nmodule statement at wrong postion\\nLine %d:[%s]\", path, lcount, lbuf);\n\t\tfprintf (stderr, \"Have already: %s\\n\", deplist.front().toString().c_str());\n\t\tdeplist.clear();\n\t\treturn deplist;\n\t    }\n\n\t    if (*expected\n\t\t&& strcmp (name, expected) != 0)\n\t    {\n\t\tfprintf (stderr, \"Module file %s does not have expected name '%s' but '%s'\\n\", path, expected, name);\n\t\treturn deplist;\n\t    }\n\t    have_module = true;\n\t    deplist.push_back (FileDep (name, path, true, false, 0, 0));\n\t}\n\telse if (*lptr == 'i')\n\t{\n\t    if (strncmp (lptr + 1, \"mport\", 5) == 0)\t\t// import\n\t    {\n\t\tlptr += 6;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr++ != '\"') continue;\n\t\tchar *name = lptr;\n\t\twhile (*lptr)\n\t\t{\n\t\t    if (*lptr == '\"')\n\t\t\tbreak;\n\t\t    lptr++;\n\t\t}\n\t\t*lptr++ = 0;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr != ';') continue;\n\n\t\tFileDep fd = resolveDep (name, true);\n\t\tif (fd.path().empty())\n\t\t{\n\t\t    fprintf (stderr, \"*** Error: Can't find module %s\\n\", name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    deplist.push_back (fd);\n\t\t}\n\t    }\n\t    else if (strncmp (lptr + 1, \"nclude\", 6) == 0)\t\t// include\n\t    {\n\t\tlptr += 7;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr++ != '\"') continue;\n\t\tchar *name = lptr;\n\t\twhile (*lptr)\n\t\t{\n\t\t    if (*lptr == '\"')\n\t\t    {\n\t\t\tbreak;\n\t\t    }\n\t\t    lptr++;\n\t\t}\n\t\t*lptr++ = 0;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr != ';') continue;\n\n\t\tFileDep fd = resolveDep (name, false);\n\t\tif (fd.path().empty())\n\t\t{\n\t\t    fprintf (stderr, \"*** Error: Can't find include %s\\n\", name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    deplist.push_back (fd);\n\t\t}\n\t    }\n\t} // 'i'include / 'i'mport\n    }\n\n    fclose (f);\n\n    // if no 'module' found -> generate fake include FileDep\n    if (!have_module)\n    {\n\tif (*expected == 0)\n\t{\n\t    fprintf (stderr, \"%s is not a module\\n\", path);\n\t    exit (1);\n\t}\n\tdeplist.push_front (FileDep (expected, path, false, false, 0, 0));\n    }\n\n    if (verbose > 1) printf (\"parseFile (%s) done\\n\", path);\n    return deplist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "depit->path",
          "args": [],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depit->path",
          "args": [],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depmap.end",
          "args": [],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "depmap.find",
          "args": [
            "depit->name()"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapit->second.begin",
          "args": [],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Map entry %s empty !\\n\"",
            "mapit->first.c_str()"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapit->first.c_str",
          "args": [],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Empty map ?!\\n\""
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\\t%s\"",
            "resit->toString().c_str()"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resit->toString",
          "args": [],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "FileDep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "326-333",
          "snippet": "std::string\nFileDep::toString () const\n{\n    return string (m_is_module ? \"module \\\"\" : \"include \\\"\")\n\t    + m_name\n\t    + string (\"\\\" at '\")\n\t    + m_path + string (\"'\");\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nFileDep {\n  std::string\n  FileDep::toString () const\n  {\n      return string (m_is_module ? \"module \\\"\" : \"include \\\"\")\n  \t    + m_name\n  \t    + string (\"\\\" at '\")\n  \t    + m_path + string (\"'\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"nothing\""
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s needs \"",
            "resit->toString().c_str()"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Map %s: %zu entries\\n\"",
            "resolved.front().name().c_str()",
            "resolved.size()"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolved.size",
          "args": [],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "resolved.front",
          "args": [],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolved.front",
          "args": [],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolved.front",
          "args": [],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolved.front",
          "args": [],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolved.front",
          "args": [],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Couldn't parse file '%s'\\n\"",
            "depit->path().c_str()"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depit->path",
          "args": [],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depit->path",
          "args": [],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depit->path",
          "args": [],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depit->path",
          "args": [],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"makeDependMap, empty input!\\n\""
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"makeDependMap (), %zu files\\n\"",
            "dep.size()"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic int verbose = 0;\nstatic int parse = 0;\nstatic recurseT *recurseStart (const char *path);\n\nstd::map <std::string, std::list <FileDep> >\nmakeDependMap (const std::list<FileDep> & dep)\n{\n    if (verbose) printf (\"makeDependMap (), %zu files\\n\", dep.size());\n\n    std::map <std::string, std::list <FileDep> > depmap;\n\n    if (dep.empty())\n    {\n\tfprintf (stderr, \"makeDependMap, empty input!\\n\");\n\treturn depmap;\n    }\n\n    std::list<FileDep>::const_iterator depit;\n    std::list<FileDep> resolved;\n\n    for (depit = dep.begin(); depit != dep.end(); depit++)\n    {\n\tresolved = parseFile (depit->path().c_str(), depit->name().c_str());\n\tif (resolved.empty())\n\t{\n\t    fprintf (stderr, \"Couldn't parse file '%s'\\n\", depit->path().c_str());\n\t    continue;\n\t}\n\n\tdepmap[resolved.front().name()] = resolved;\n\n\tif (verbose > 2)\n\t{\n\t    printf (\"Map %s: %zu entries\\n\", resolved.front().name().c_str(), resolved.size());\n\t}\n\n\tif (verbose > 1)\n\t{\n\t    std::list<FileDep>::iterator resit = resolved.begin();\n\t    printf (\"%s needs \", resit->toString().c_str());\n\t    resit++;\n\t    if (resit == resolved.end())\n\t    {\n\t\tprintf (\"nothing\");\n\t    }\n\t    else while (resit != resolved.end())\n\t    {\n\t\tprintf (\"\\n\\t%s\", resit->toString().c_str());\n\t\tresit++;\n\t    }\n\t    printf (\"\\n\");\n\t}\n    }\n\n    // now go through all map entries and resolve them\n    std::map <std::string, std::list <FileDep> >::iterator mapit;\n    bool found_unsolved = true;\n    while (found_unsolved)\n    {\n\tstd::list<FileDep>::iterator depit;\n\n\tfound_unsolved = false;\n\n\tif (depmap.empty())\n\t{\n\t    fprintf (stderr, \"Empty map ?!\\n\");\n\t    break;\n\t}\n\n\tfor (mapit = depmap.begin(); mapit != depmap.end(); mapit++)\n\t{\n\t    if (mapit->second.empty())\n\t    {\n\t\tfprintf (stderr, \"Map entry %s empty !\\n\", mapit->first.c_str());\n\t\tbreak;\n\t    }\n\t    for (depit = mapit->second.begin(); depit != mapit->second.end(); depit++)\n\t    {\n\t\tif (depmap.find (depit->name()) == depmap.end())\n\t\t{\n\t\t    resolved = parseFile (depit->path().c_str(), depit->name().c_str());\n\t\t    if (resolved.empty())\n\t\t    {\n\t\t\tfprintf (stderr, \"Couldn't parse file '%s'\\n\", depit->path().c_str());\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (verbose > 1) printf (\"Solved %s as %s\\n\", depit->name().c_str(), resolved.front().name().c_str());\n\t\t    depmap[resolved.front().name()] = resolved;\n\t\t    found_unsolved = true;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (found_unsolved) break;\n\t}\n    }\n\n    return depmap;\n}"
  },
  {
    "function_name": "makeDirList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "542-600",
    "snippet": "std::list <FileDep>\nmakeDirList (const char *dir)\n{\n    std::list <FileDep> deplist;\n\n    struct stat st;\n\n    if (lstat (dir, &st) == -1)\t\t\t\t// not existant, not accessible\n    {\n\tperror (dir);\n\treturn deplist;\n    }\n\n    if (S_ISREG (st.st_mode))\t\t\t\t// a single file\n    {\n\tdeplist.push_back (FileDep (\"\", dir, false, false, 0, 0));\n\treturn deplist;\n    }\n\n    if (!S_ISDIR (st.st_mode))\n    {\n\tfprintf (stderr, \"Not a file or directory: %s\\n\", dir);\n\treturn deplist;\n    }\n\n    if (verbose) printf (\"List files below '%s'\\n\", dir);\n\n    recurseT *handle, *next;\n\n    handle = recurseStart (dir);\n    if (handle == 0)\n    {\n\treturn deplist;\n    }\n\n    int extpos;\n\n    while (handle)\n    {\n\tnext = recurseNext (handle, &st);\n\tif (next == 0)\n\t{\n\t    recurseEnd (handle);\n\t    handle = 0;\n\t    break;\n\t}\n\thandle = next;\n\n\textpos = handle->length + strlen (handle->path + handle->length) - 4;\n\tif (strcmp (handle->path + extpos, \".ycp\") == 0)\n\t{\n\t    deplist.push_back (FileDep (\"\", handle->path, false, false, 0, 0));\n\t    if (verbose) printf (\"%s\\n\", handle->path);\n\t}\n    }\n\n    if (verbose) printf (\"directory %s listed, %zu files\\n\", dir, deplist.size());\n    return deplist;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int verbose = 0;",
      "static recurseT *recurseStart (const char *path);",
      "static recurseT *recurseNext (recurseT *handle, struct stat *st = 0);",
      "static void recurseEnd (recurseT *handle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"directory %s listed, %zu files\\n\"",
            "dir",
            "deplist.size()"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deplist.size",
          "args": [],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "handle->path"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deplist.push_back",
          "args": [
            "FileDep (\"\", handle->path, false, false, 0, 0)"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FileDep",
          "args": [
            "\"\"",
            "handle->path",
            "false",
            "false",
            "0",
            "0"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "FileDep",
          "container": "FileDep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "273-281",
          "snippet": "FileDep::FileDep (const std::string & name, const std::string & path, bool is_module, bool have_source, time_t srctime, time_t bintime)\n    : m_name (name)\n    , m_path (path)\n    , m_is_module (is_module)\n    , m_have_source (have_source)\n    , m_srctime (srctime)\n    , m_bintime (bintime)\n{\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static recurseT *recurseStart (const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic recurseT *recurseStart (const char *path);\n\nFileDep {\n  FileDep::FileDep (const std::string & name, const std::string & path, bool is_module, bool have_source, time_t srctime, time_t bintime)\n      : m_name (name)\n      , m_path (path)\n      , m_is_module (is_module)\n      , m_have_source (have_source)\n      , m_srctime (srctime)\n      , m_bintime (bintime)\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "handle->path + extpos",
            "\".ycp\""
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "handle->path + handle->length"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recurseEnd",
          "args": [
            "handle"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "recurseEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "150-156",
          "snippet": "static void\nrecurseEnd (recurseT *handle)\n{\n    closedir (handle->d);\n    free (handle);\n    return;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void recurseEnd (recurseT *handle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic void recurseEnd (recurseT *handle);\n\nstatic void\nrecurseEnd (recurseT *handle)\n{\n    closedir (handle->d);\n    free (handle);\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recurseNext",
          "args": [
            "handle",
            "&st"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recurseStart",
          "args": [
            "dir"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"List files below '%s'\\n\"",
            "dir"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Not a file or directory: %s\\n\"",
            "dir"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "dir"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "dir",
            "&st"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic int verbose = 0;\nstatic recurseT *recurseStart (const char *path);\nstatic recurseT *recurseNext (recurseT *handle, struct stat *st = 0);\nstatic void recurseEnd (recurseT *handle);\n\nstd::list <FileDep>\nmakeDirList (const char *dir)\n{\n    std::list <FileDep> deplist;\n\n    struct stat st;\n\n    if (lstat (dir, &st) == -1)\t\t\t\t// not existant, not accessible\n    {\n\tperror (dir);\n\treturn deplist;\n    }\n\n    if (S_ISREG (st.st_mode))\t\t\t\t// a single file\n    {\n\tdeplist.push_back (FileDep (\"\", dir, false, false, 0, 0));\n\treturn deplist;\n    }\n\n    if (!S_ISDIR (st.st_mode))\n    {\n\tfprintf (stderr, \"Not a file or directory: %s\\n\", dir);\n\treturn deplist;\n    }\n\n    if (verbose) printf (\"List files below '%s'\\n\", dir);\n\n    recurseT *handle, *next;\n\n    handle = recurseStart (dir);\n    if (handle == 0)\n    {\n\treturn deplist;\n    }\n\n    int extpos;\n\n    while (handle)\n    {\n\tnext = recurseNext (handle, &st);\n\tif (next == 0)\n\t{\n\t    recurseEnd (handle);\n\t    handle = 0;\n\t    break;\n\t}\n\thandle = next;\n\n\textpos = handle->length + strlen (handle->path + handle->length) - 4;\n\tif (strcmp (handle->path + extpos, \".ycp\") == 0)\n\t{\n\t    deplist.push_back (FileDep (\"\", handle->path, false, false, 0, 0));\n\t    if (verbose) printf (\"%s\\n\", handle->path);\n\t}\n    }\n\n    if (verbose) printf (\"directory %s listed, %zu files\\n\", dir, deplist.size());\n    return deplist;\n}"
  },
  {
    "function_name": "parseFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "397-533",
    "snippet": "std::list <FileDep>\nparseFile (const char *path, const char *expected)\n{\n    if (verbose > 1) printf (\"List dependencies for '%s'\\n\", path);\n\n#define LBUFSIZE 8192\n    char lbuf[LBUFSIZE];\n\n    std::list <FileDep> deplist;\n\n    FILE *f = fopen (path, \"r\");\n    if (f == 0)\n    {\n\tperror (path);\n\treturn deplist;\n    }\n\n    char *lptr;\n    int lcount = 0;\n\n    bool have_module = false;\n\n    while (fgets (lbuf, LBUFSIZE-1, f) != 0)\n    {\n\tlcount++;\n\tlptr = lbuf;\n\twhile (isblank (*lptr)) lptr++;\n\n\tif ((*lptr == 'm')\n\t    && (strncmp (lptr + 1, \"odule\", 5) == 0))\t\t// module\n\t{\n\t    lptr += 6;\n\t    while (isblank (*lptr)) lptr++;\n\t    if (*lptr++ != '\"') continue;\n\t    char *name = lptr;\n\t    while (*lptr)\n\t    {\n\t\tif (*lptr == '\"')\n\t\t    break;\n\t\tlptr++;\n\t    }\n\t    *lptr++ = 0;\n\t    while (isblank (*lptr)) lptr++;\n\t    if (*lptr != ';') continue;\n\n\t    if (!deplist.empty())\n\t    {\n\t\tfprintf (stderr, \"Bad file '%s':\\nmodule statement at wrong postion\\nLine %d:[%s]\", path, lcount, lbuf);\n\t\tfprintf (stderr, \"Have already: %s\\n\", deplist.front().toString().c_str());\n\t\tdeplist.clear();\n\t\treturn deplist;\n\t    }\n\n\t    if (*expected\n\t\t&& strcmp (name, expected) != 0)\n\t    {\n\t\tfprintf (stderr, \"Module file %s does not have expected name '%s' but '%s'\\n\", path, expected, name);\n\t\treturn deplist;\n\t    }\n\t    have_module = true;\n\t    deplist.push_back (FileDep (name, path, true, false, 0, 0));\n\t}\n\telse if (*lptr == 'i')\n\t{\n\t    if (strncmp (lptr + 1, \"mport\", 5) == 0)\t\t// import\n\t    {\n\t\tlptr += 6;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr++ != '\"') continue;\n\t\tchar *name = lptr;\n\t\twhile (*lptr)\n\t\t{\n\t\t    if (*lptr == '\"')\n\t\t\tbreak;\n\t\t    lptr++;\n\t\t}\n\t\t*lptr++ = 0;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr != ';') continue;\n\n\t\tFileDep fd = resolveDep (name, true);\n\t\tif (fd.path().empty())\n\t\t{\n\t\t    fprintf (stderr, \"*** Error: Can't find module %s\\n\", name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    deplist.push_back (fd);\n\t\t}\n\t    }\n\t    else if (strncmp (lptr + 1, \"nclude\", 6) == 0)\t\t// include\n\t    {\n\t\tlptr += 7;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr++ != '\"') continue;\n\t\tchar *name = lptr;\n\t\twhile (*lptr)\n\t\t{\n\t\t    if (*lptr == '\"')\n\t\t    {\n\t\t\tbreak;\n\t\t    }\n\t\t    lptr++;\n\t\t}\n\t\t*lptr++ = 0;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr != ';') continue;\n\n\t\tFileDep fd = resolveDep (name, false);\n\t\tif (fd.path().empty())\n\t\t{\n\t\t    fprintf (stderr, \"*** Error: Can't find include %s\\n\", name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    deplist.push_back (fd);\n\t\t}\n\t    }\n\t} // 'i'include / 'i'mport\n    }\n\n    fclose (f);\n\n    // if no 'module' found -> generate fake include FileDep\n    if (!have_module)\n    {\n\tif (*expected == 0)\n\t{\n\t    fprintf (stderr, \"%s is not a module\\n\", path);\n\t    exit (1);\n\t}\n\tdeplist.push_front (FileDep (expected, path, false, false, 0, 0));\n    }\n\n    if (verbose > 1) printf (\"parseFile (%s) done\\n\", path);\n    return deplist;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [
      "#define LBUFSIZE 8192"
    ],
    "globals_used": [
      "static int verbose = 0;",
      "static recurseT *recurseStart (const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"parseFile (%s) done\\n\"",
            "path"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deplist.push_front",
          "args": [
            "FileDep (expected, path, false, false, 0, 0)"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FileDep",
          "args": [
            "expected",
            "path",
            "false",
            "false",
            "0",
            "0"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "FileDep",
          "container": "FileDep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "273-281",
          "snippet": "FileDep::FileDep (const std::string & name, const std::string & path, bool is_module, bool have_source, time_t srctime, time_t bintime)\n    : m_name (name)\n    , m_path (path)\n    , m_is_module (is_module)\n    , m_have_source (have_source)\n    , m_srctime (srctime)\n    , m_bintime (bintime)\n{\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static recurseT *recurseStart (const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic recurseT *recurseStart (const char *path);\n\nFileDep {\n  FileDep::FileDep (const std::string & name, const std::string & path, bool is_module, bool have_source, time_t srctime, time_t bintime)\n      : m_name (name)\n      , m_path (path)\n      , m_is_module (is_module)\n      , m_have_source (have_source)\n      , m_srctime (srctime)\n      , m_bintime (bintime)\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s is not a module\\n\"",
            "path"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deplist.push_back",
          "args": [
            "fd"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"*** Error: Can't find include %s\\n\"",
            "name"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd.path",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd.path",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolveDep",
          "args": [
            "name",
            "false"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "resolveDep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "340-382",
          "snippet": "FileDep\nresolveDep (const char *name, bool as_module)\n{\n    if (verbose > 1) printf (\"resolveDep (%s %s)\", as_module ? \"import\" : \"include\", name);\n    std::string srcpath;\n    time_t srctime = 0;\n    std::string binpath;\n    time_t bintime = 0;\n    bool have_source = true;\n    struct stat st;\n\n    if (as_module)\n    {\n\tsrcpath = YCPPathSearch::findModule (name, true);\t// find source code for module\n\tif (srcpath.empty())\n\t{\n\t    have_source = false;\n\t}\n\telse if (stat (srcpath.c_str(), &st) == 0)\n\t{\n\t    srctime = st.st_mtime;\n\t}\n\tbinpath = YCPPathSearch::findModule (name);\t\t// find binary code for module\n\tif (!binpath.empty()\n\t    && stat (binpath.c_str(), &st) == 0)\n\t{\n\t    bintime = st.st_mtime;\n\t}\n    }\n    else\n    {\n\tsrcpath = YCPPathSearch::findInclude (name);\n\tif (!srcpath.empty()\n\t    && stat (srcpath.c_str(), &st) == 0)\n\t{\n\t    srctime = st.st_mtime;\n\t}\n    }\n\n    if (verbose > 1) printf (\" -> '%s'\\n\", srcpath.c_str());\n\n    return FileDep (name, have_source ? srcpath : binpath, as_module, have_source, srctime, bintime);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int verbose = 0;",
            "static recurseT *recurseNext (recurseT *handle, struct stat *st = 0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic int verbose = 0;\nstatic recurseT *recurseNext (recurseT *handle, struct stat *st = 0);\n\nFileDep\nresolveDep (const char *name, bool as_module)\n{\n    if (verbose > 1) printf (\"resolveDep (%s %s)\", as_module ? \"import\" : \"include\", name);\n    std::string srcpath;\n    time_t srctime = 0;\n    std::string binpath;\n    time_t bintime = 0;\n    bool have_source = true;\n    struct stat st;\n\n    if (as_module)\n    {\n\tsrcpath = YCPPathSearch::findModule (name, true);\t// find source code for module\n\tif (srcpath.empty())\n\t{\n\t    have_source = false;\n\t}\n\telse if (stat (srcpath.c_str(), &st) == 0)\n\t{\n\t    srctime = st.st_mtime;\n\t}\n\tbinpath = YCPPathSearch::findModule (name);\t\t// find binary code for module\n\tif (!binpath.empty()\n\t    && stat (binpath.c_str(), &st) == 0)\n\t{\n\t    bintime = st.st_mtime;\n\t}\n    }\n    else\n    {\n\tsrcpath = YCPPathSearch::findInclude (name);\n\tif (!srcpath.empty()\n\t    && stat (srcpath.c_str(), &st) == 0)\n\t{\n\t    srctime = st.st_mtime;\n\t}\n    }\n\n    if (verbose > 1) printf (\" -> '%s'\\n\", srcpath.c_str());\n\n    return FileDep (name, have_source ? srcpath : binpath, as_module, have_source, srctime, bintime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isblank",
          "args": [
            "*lptr"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isblank",
          "args": [
            "*lptr"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "lptr + 1",
            "\"nclude\"",
            "6"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"*** Error: Can't find module %s\\n\"",
            "name"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd.path",
          "args": [],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd.path",
          "args": [],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isblank",
          "args": [
            "*lptr"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isblank",
          "args": [
            "*lptr"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "lptr + 1",
            "\"mport\"",
            "5"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Module file %s does not have expected name '%s' but '%s'\\n\"",
            "path",
            "expected",
            "name"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "expected"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deplist.clear",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/PathInfo.h",
          "lines": "461-461",
          "snippet": "void clear() { _devino.clear(); }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <map>",
            "#include <set>",
            "#include <list>",
            "#include <iosfwd>",
            "#include <cerrno>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <map>\n#include <set>\n#include <list>\n#include <iosfwd>\n#include <cerrno>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid clear() { _devino.clear(); }"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Have already: %s\\n\"",
            "deplist.front().toString().c_str()"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deplist.front",
          "args": [],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deplist.front",
          "args": [],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deplist.front",
          "args": [],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Bad file '%s':\\nmodule statement at wrong postion\\nLine %d:[%s]\"",
            "path",
            "lcount",
            "lbuf"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deplist.empty",
          "args": [],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isblank",
          "args": [
            "*lptr"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isblank",
          "args": [
            "*lptr"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "lptr + 1",
            "\"odule\"",
            "5"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isblank",
          "args": [
            "*lptr"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "lbuf",
            "LBUFSIZE-1",
            "f"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "path"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"r\""
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"List dependencies for '%s'\\n\"",
            "path"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\n#define LBUFSIZE 8192\n\nstatic int verbose = 0;\nstatic recurseT *recurseStart (const char *path);\n\nstd::list <FileDep>\nparseFile (const char *path, const char *expected)\n{\n    if (verbose > 1) printf (\"List dependencies for '%s'\\n\", path);\n\n#define LBUFSIZE 8192\n    char lbuf[LBUFSIZE];\n\n    std::list <FileDep> deplist;\n\n    FILE *f = fopen (path, \"r\");\n    if (f == 0)\n    {\n\tperror (path);\n\treturn deplist;\n    }\n\n    char *lptr;\n    int lcount = 0;\n\n    bool have_module = false;\n\n    while (fgets (lbuf, LBUFSIZE-1, f) != 0)\n    {\n\tlcount++;\n\tlptr = lbuf;\n\twhile (isblank (*lptr)) lptr++;\n\n\tif ((*lptr == 'm')\n\t    && (strncmp (lptr + 1, \"odule\", 5) == 0))\t\t// module\n\t{\n\t    lptr += 6;\n\t    while (isblank (*lptr)) lptr++;\n\t    if (*lptr++ != '\"') continue;\n\t    char *name = lptr;\n\t    while (*lptr)\n\t    {\n\t\tif (*lptr == '\"')\n\t\t    break;\n\t\tlptr++;\n\t    }\n\t    *lptr++ = 0;\n\t    while (isblank (*lptr)) lptr++;\n\t    if (*lptr != ';') continue;\n\n\t    if (!deplist.empty())\n\t    {\n\t\tfprintf (stderr, \"Bad file '%s':\\nmodule statement at wrong postion\\nLine %d:[%s]\", path, lcount, lbuf);\n\t\tfprintf (stderr, \"Have already: %s\\n\", deplist.front().toString().c_str());\n\t\tdeplist.clear();\n\t\treturn deplist;\n\t    }\n\n\t    if (*expected\n\t\t&& strcmp (name, expected) != 0)\n\t    {\n\t\tfprintf (stderr, \"Module file %s does not have expected name '%s' but '%s'\\n\", path, expected, name);\n\t\treturn deplist;\n\t    }\n\t    have_module = true;\n\t    deplist.push_back (FileDep (name, path, true, false, 0, 0));\n\t}\n\telse if (*lptr == 'i')\n\t{\n\t    if (strncmp (lptr + 1, \"mport\", 5) == 0)\t\t// import\n\t    {\n\t\tlptr += 6;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr++ != '\"') continue;\n\t\tchar *name = lptr;\n\t\twhile (*lptr)\n\t\t{\n\t\t    if (*lptr == '\"')\n\t\t\tbreak;\n\t\t    lptr++;\n\t\t}\n\t\t*lptr++ = 0;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr != ';') continue;\n\n\t\tFileDep fd = resolveDep (name, true);\n\t\tif (fd.path().empty())\n\t\t{\n\t\t    fprintf (stderr, \"*** Error: Can't find module %s\\n\", name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    deplist.push_back (fd);\n\t\t}\n\t    }\n\t    else if (strncmp (lptr + 1, \"nclude\", 6) == 0)\t\t// include\n\t    {\n\t\tlptr += 7;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr++ != '\"') continue;\n\t\tchar *name = lptr;\n\t\twhile (*lptr)\n\t\t{\n\t\t    if (*lptr == '\"')\n\t\t    {\n\t\t\tbreak;\n\t\t    }\n\t\t    lptr++;\n\t\t}\n\t\t*lptr++ = 0;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr != ';') continue;\n\n\t\tFileDep fd = resolveDep (name, false);\n\t\tif (fd.path().empty())\n\t\t{\n\t\t    fprintf (stderr, \"*** Error: Can't find include %s\\n\", name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    deplist.push_back (fd);\n\t\t}\n\t    }\n\t} // 'i'include / 'i'mport\n    }\n\n    fclose (f);\n\n    // if no 'module' found -> generate fake include FileDep\n    if (!have_module)\n    {\n\tif (*expected == 0)\n\t{\n\t    fprintf (stderr, \"%s is not a module\\n\", path);\n\t    exit (1);\n\t}\n\tdeplist.push_front (FileDep (expected, path, false, false, 0, 0));\n    }\n\n    if (verbose > 1) printf (\"parseFile (%s) done\\n\", path);\n    return deplist;\n}"
  },
  {
    "function_name": "resolveDep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "340-382",
    "snippet": "FileDep\nresolveDep (const char *name, bool as_module)\n{\n    if (verbose > 1) printf (\"resolveDep (%s %s)\", as_module ? \"import\" : \"include\", name);\n    std::string srcpath;\n    time_t srctime = 0;\n    std::string binpath;\n    time_t bintime = 0;\n    bool have_source = true;\n    struct stat st;\n\n    if (as_module)\n    {\n\tsrcpath = YCPPathSearch::findModule (name, true);\t// find source code for module\n\tif (srcpath.empty())\n\t{\n\t    have_source = false;\n\t}\n\telse if (stat (srcpath.c_str(), &st) == 0)\n\t{\n\t    srctime = st.st_mtime;\n\t}\n\tbinpath = YCPPathSearch::findModule (name);\t\t// find binary code for module\n\tif (!binpath.empty()\n\t    && stat (binpath.c_str(), &st) == 0)\n\t{\n\t    bintime = st.st_mtime;\n\t}\n    }\n    else\n    {\n\tsrcpath = YCPPathSearch::findInclude (name);\n\tif (!srcpath.empty()\n\t    && stat (srcpath.c_str(), &st) == 0)\n\t{\n\t    srctime = st.st_mtime;\n\t}\n    }\n\n    if (verbose > 1) printf (\" -> '%s'\\n\", srcpath.c_str());\n\n    return FileDep (name, have_source ? srcpath : binpath, as_module, have_source, srctime, bintime);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int verbose = 0;",
      "static recurseT *recurseNext (recurseT *handle, struct stat *st = 0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FileDep",
          "args": [
            "name",
            "have_source ? srcpath : binpath",
            "as_module",
            "have_source",
            "srctime",
            "bintime"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "FileDep",
          "container": "FileDep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "273-281",
          "snippet": "FileDep::FileDep (const std::string & name, const std::string & path, bool is_module, bool have_source, time_t srctime, time_t bintime)\n    : m_name (name)\n    , m_path (path)\n    , m_is_module (is_module)\n    , m_have_source (have_source)\n    , m_srctime (srctime)\n    , m_bintime (bintime)\n{\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static recurseT *recurseStart (const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic recurseT *recurseStart (const char *path);\n\nFileDep {\n  FileDep::FileDep (const std::string & name, const std::string & path, bool is_module, bool have_source, time_t srctime, time_t bintime)\n      : m_name (name)\n      , m_path (path)\n      , m_is_module (is_module)\n      , m_have_source (have_source)\n      , m_srctime (srctime)\n      , m_bintime (bintime)\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" -> '%s'\\n\"",
            "srcpath.c_str()"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcpath.c_str",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "srcpath.c_str()",
            "&st"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcpath.c_str",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcpath.empty",
          "args": [],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPPathSearch::findInclude",
          "args": [
            "name"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "findInclude",
          "container": "YCPPathSearch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/pathsearch.cc",
          "lines": "324-328",
          "snippet": "string\nYCPPathSearch::findInclude (const string& name)\n{\n    return find (Include, name);\n}",
          "includes": [
            "#include \"pathsearch.h\"",
            "#include <ycp/y2log.h>",
            "#include <boost/algorithm/string.hpp>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pathsearch.h\"\n#include <ycp/y2log.h>\n#include <boost/algorithm/string.hpp>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n\nYCPPathSearch {\n  string\n  YCPPathSearch::findInclude (const string& name)\n  {\n      return find (Include, name);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "binpath.c_str()",
            "&st"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "binpath.c_str",
          "args": [],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPPathSearch::findModule",
          "args": [
            "name"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "srcpath.c_str()",
            "&st"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcpath.c_str",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPPathSearch::findModule",
          "args": [
            "name",
            "true"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "findModule",
          "container": "YCPPathSearch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/pathsearch.cc",
          "lines": "331-340",
          "snippet": "string\nYCPPathSearch::findModule (string name, bool the_source)\n{\n    string extension = (the_source ? \".ycp\" : \".ybc\");\n    if (!boost::ends_with(name, extension))\n    {\n\tname += extension;\n    }\n    return find (Module, name);\n}",
          "includes": [
            "#include \"pathsearch.h\"",
            "#include <ycp/y2log.h>",
            "#include <boost/algorithm/string.hpp>",
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pathsearch.h\"\n#include <ycp/y2log.h>\n#include <boost/algorithm/string.hpp>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n\nYCPPathSearch {\n  string\n  YCPPathSearch::findModule (string name, bool the_source)\n  {\n      string extension = (the_source ? \".ycp\" : \".ybc\");\n      if (!boost::ends_with(name, extension))\n      {\n  \tname += extension;\n      }\n      return find (Module, name);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"resolveDep (%s %s)\"",
            "as_module ? \"import\" : \"include\"",
            "name"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic int verbose = 0;\nstatic recurseT *recurseNext (recurseT *handle, struct stat *st = 0);\n\nFileDep\nresolveDep (const char *name, bool as_module)\n{\n    if (verbose > 1) printf (\"resolveDep (%s %s)\", as_module ? \"import\" : \"include\", name);\n    std::string srcpath;\n    time_t srctime = 0;\n    std::string binpath;\n    time_t bintime = 0;\n    bool have_source = true;\n    struct stat st;\n\n    if (as_module)\n    {\n\tsrcpath = YCPPathSearch::findModule (name, true);\t// find source code for module\n\tif (srcpath.empty())\n\t{\n\t    have_source = false;\n\t}\n\telse if (stat (srcpath.c_str(), &st) == 0)\n\t{\n\t    srctime = st.st_mtime;\n\t}\n\tbinpath = YCPPathSearch::findModule (name);\t\t// find binary code for module\n\tif (!binpath.empty()\n\t    && stat (binpath.c_str(), &st) == 0)\n\t{\n\t    bintime = st.st_mtime;\n\t}\n    }\n    else\n    {\n\tsrcpath = YCPPathSearch::findInclude (name);\n\tif (!srcpath.empty()\n\t    && stat (srcpath.c_str(), &st) == 0)\n\t{\n\t    srctime = st.st_mtime;\n\t}\n    }\n\n    if (verbose > 1) printf (\" -> '%s'\\n\", srcpath.c_str());\n\n    return FileDep (name, have_source ? srcpath : binpath, as_module, have_source, srctime, bintime);\n}"
  },
  {
    "function_name": "toString",
    "container": "FileDep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "326-333",
    "snippet": "std::string\nFileDep::toString () const\n{\n    return string (m_is_module ? \"module \\\"\" : \"include \\\"\")\n\t    + m_name\n\t    + string (\"\\\" at '\")\n\t    + m_path + string (\"'\");\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"'\""
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nFileDep {\n  std::string\n  FileDep::toString () const\n  {\n      return string (m_is_module ? \"module \\\"\" : \"include \\\"\")\n  \t    + m_name\n  \t    + string (\"\\\" at '\")\n  \t    + m_path + string (\"'\");\n  }\n}"
  },
  {
    "function_name": "is_module",
    "container": "FileDep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "319-323",
    "snippet": "bool\nFileDep::is_module () const\n{\n    return m_is_module;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nFileDep {\n  bool\n  FileDep::is_module () const\n  {\n      return m_is_module;\n  }\n}"
  },
  {
    "function_name": "setPath",
    "container": "FileDep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "312-316",
    "snippet": "void\nFileDep::setPath (const std::string & path)\n{\n    m_path = path;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static recurseT *recurseStart (const char *path);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic recurseT *recurseStart (const char *path);\n\nFileDep {\n  void\n  FileDep::setPath (const std::string & path)\n  {\n      m_path = path;\n  }\n}"
  },
  {
    "function_name": "bintime",
    "container": "FileDep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "305-309",
    "snippet": "time_t\nFileDep::bintime () const\n{\n    return m_bintime;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nFileDep {\n  time_t\n  FileDep::bintime () const\n  {\n      return m_bintime;\n  }\n}"
  },
  {
    "function_name": "srctime",
    "container": "FileDep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "298-302",
    "snippet": "time_t\nFileDep::srctime () const\n{\n    return m_srctime;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nFileDep {\n  time_t\n  FileDep::srctime () const\n  {\n      return m_srctime;\n  }\n}"
  },
  {
    "function_name": "FileDep",
    "container": "FileDep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "273-281",
    "snippet": "FileDep::FileDep (const std::string & name, const std::string & path, bool is_module, bool have_source, time_t srctime, time_t bintime)\n    : m_name (name)\n    , m_path (path)\n    , m_is_module (is_module)\n    , m_have_source (have_source)\n    , m_srctime (srctime)\n    , m_bintime (bintime)\n{\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static recurseT *recurseStart (const char *path);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic recurseT *recurseStart (const char *path);\n\nFileDep {\n  FileDep::FileDep (const std::string & name, const std::string & path, bool is_module, bool have_source, time_t srctime, time_t bintime)\n      : m_name (name)\n      , m_path (path)\n      , m_is_module (is_module)\n      , m_have_source (have_source)\n      , m_srctime (srctime)\n      , m_bintime (bintime)\n  {\n  }\n}"
  },
  {
    "function_name": "FileDep",
    "container": "FileDep",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "261-261",
    "snippet": "FileDep () {}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nFileDep {\n  FileDep () {}\n}"
  },
  {
    "function_name": "recurseEnd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
    "lines": "150-156",
    "snippet": "static void\nrecurseEnd (recurseT *handle)\n{\n    closedir (handle->d);\n    free (handle);\n    return;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <WFM.h>",
      "#include <scr/SCR.h>",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <y2/Y2Component.h>",
      "#include <ycp/pathsearch.h>",
      "#include <../../libycp/src/parser.h>",
      "#include <ycp/y2log.h>",
      "#include <ycp/Import.h>",
      "#include <ycp/Xmlcode.h>",
      "#include <ycp/Bytecode.h>",
      "#include <ycp/Parser.h>",
      "#include <ycp/YCode.h>",
      "#include <YCP.h>",
      "#include <map>",
      "#include <list>",
      "#include <fstream>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <utime.h>",
      "#include <stdio.h>",
      "#include <getopt.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void recurseEnd (recurseT *handle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "handle"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "handle->d"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\nstatic void recurseEnd (recurseT *handle);\n\nstatic void\nrecurseEnd (recurseT *handle)\n{\n    closedir (handle->d);\n    free (handle);\n    return;\n}"
  }
]