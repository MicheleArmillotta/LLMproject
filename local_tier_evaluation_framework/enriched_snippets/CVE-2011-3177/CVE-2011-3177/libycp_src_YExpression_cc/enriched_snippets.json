[
  {
    "function_name": "name",
    "container": "Y2YCPFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3503-3507",
    "snippet": "string\nY2YCPFunction::name () const\n{\n    return m_sentry->name ();\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_sentry->name",
          "args": [],
          "line": 3506
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3503-3507",
          "snippet": "string\nY2YCPFunction::name () const\n{\n    return m_sentry->name ();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  string\n  Y2YCPFunction::name () const\n  {\n      return m_sentry->name ();\n  }\n}"
  },
  {
    "function_name": "reset",
    "container": "Y2YCPFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3491-3500",
    "snippet": "bool\nY2YCPFunction::reset ()\n{\n    for (int i=0; i<((constFunctionTypePtr)(m_sentry->type ()))->parameterCount (); i++)\n    {\n\tm_parameters[i] = YCPNull ();\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "m_sentry->type ()"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->type",
          "args": [],
          "line": 3494
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  bool\n  Y2YCPFunction::reset ()\n  {\n      for (int i=0; i<((constFunctionTypePtr)(m_sentry->type ()))->parameterCount (); i++)\n      {\n  \tm_parameters[i] = YCPNull ();\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "qualifiedName",
    "container": "Y2YCPFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3482-3489",
    "snippet": "string\nY2YCPFunction::qualifiedName () const\n{\n    string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n\t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n\t\"\";\n    return n + m_sentry->name ();\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_sentry->name",
          "args": [],
          "line": 3488
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3503-3507",
          "snippet": "string\nY2YCPFunction::name () const\n{\n    return m_sentry->name ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  string\n  Y2YCPFunction::name () const\n  {\n      return m_sentry->name ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"::\""
          ],
          "line": 3486
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_sentry->nameSpace",
          "args": [],
          "line": 3486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->nameSpace",
          "args": [],
          "line": 3486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->nameSpace",
          "args": [],
          "line": 3485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->nameSpace",
          "args": [],
          "line": 3485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->nameSpace",
          "args": [],
          "line": 3485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->nameSpace",
          "args": [],
          "line": 3485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  string\n  Y2YCPFunction::qualifiedName () const\n  {\n      string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n  \t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n  \t\"\";\n      return n + m_sentry->name ();\n  }\n}"
  },
  {
    "function_name": "finishParameters",
    "container": "Y2YCPFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3466-3479",
    "snippet": "bool\nY2YCPFunction::finishParameters ()\n{\n    for (int i = 0 ; i < ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount (); i++)\n    {\n\tif (m_parameters [i].isNull ())\n\t{\n\t    y2error (\"Missing parameter %d to %s\",\n\t\t i, qualifiedName ().c_str ());\n\t    return false;\n\t}\n    }\n    return true;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Missing parameter %d to %s\"",
            "i",
            "qualifiedName ().c_str ()"
          ],
          "line": 3473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qualifiedName",
          "args": [],
          "line": 3474
        },
        "resolved": true,
        "details": {
          "function_name": "qualifiedName",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3482-3489",
          "snippet": "string\nY2YCPFunction::qualifiedName () const\n{\n    string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n\t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n\t\"\";\n    return n + m_sentry->name ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  string\n  Y2YCPFunction::qualifiedName () const\n  {\n      string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n  \t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n  \t\"\";\n      return n + m_sentry->name ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_parameters [i].isNull",
          "args": [],
          "line": 3471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "m_sentry->type ()"
          ],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->type",
          "args": [],
          "line": 3469
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  bool\n  Y2YCPFunction::finishParameters ()\n  {\n      for (int i = 0 ; i < ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount (); i++)\n      {\n  \tif (m_parameters [i].isNull ())\n  \t{\n  \t    y2error (\"Missing parameter %d to %s\",\n  \t\t i, qualifiedName ().c_str ());\n  \t    return false;\n  \t}\n      }\n      return true;\n  }\n}"
  },
  {
    "function_name": "appendParameter",
    "container": "Y2YCPFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3434-3463",
    "snippet": "bool\nY2YCPFunction::appendParameter (const YCPValue& arg)\n{\n    if (arg.isNull())\n    {\n\tycp2error (\"NULL parameter to %s\", qualifiedName ().c_str ());\n\treturn false;\n    }\n\n    // FIXME: check the type\n    \n    // lookup the first non-set parameter\n    for (int i = 0 ; i < ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount (); i++)\n    {\n\tif (m_parameters[i].isNull ())\n\t{\n#if DO_DEBUG\n\t    y2debug (\"Assigning parameter %d: %s\", i, arg->toString ().c_str ());\n#endif\t    \n\t    m_parameters[i] = arg;\n\t    return true;\n\t}\n    }\n    \n    // Our caller should report the place\n    // in a script where this happened\n    ycp2error (\"Excessive parameter to %s\", qualifiedName ().c_str ());\n\n    return false;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Excessive parameter to %s\"",
            "qualifiedName ().c_str ()"
          ],
          "line": 3460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qualifiedName",
          "args": [],
          "line": 3460
        },
        "resolved": true,
        "details": {
          "function_name": "qualifiedName",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3482-3489",
          "snippet": "string\nY2YCPFunction::qualifiedName () const\n{\n    string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n\t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n\t\"\";\n    return n + m_sentry->name ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  string\n  Y2YCPFunction::qualifiedName () const\n  {\n      string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n  \t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n  \t\"\";\n      return n + m_sentry->name ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Assigning parameter %d: %s\"",
            "i",
            "arg->toString ().c_str ()"
          ],
          "line": 3451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg->toString",
          "args": [],
          "line": 3451
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_parameters[i].isNull",
          "args": [],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 3446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "m_sentry->type ()"
          ],
          "line": 3446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->type",
          "args": [],
          "line": 3446
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"NULL parameter to %s\"",
            "qualifiedName ().c_str ()"
          ],
          "line": 3439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nY2YCPFunction {\n  bool\n  Y2YCPFunction::appendParameter (const YCPValue& arg)\n  {\n      if (arg.isNull())\n      {\n  \tycp2error (\"NULL parameter to %s\", qualifiedName ().c_str ());\n  \treturn false;\n      }\n  \n      // FIXME: check the type\n      \n      // lookup the first non-set parameter\n      for (int i = 0 ; i < ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount (); i++)\n      {\n  \tif (m_parameters[i].isNull ())\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"Assigning parameter %d: %s\", i, arg->toString ().c_str ());\n  #endif\t    \n  \t    m_parameters[i] = arg;\n  \t    return true;\n  \t}\n      }\n      \n      // Our caller should report the place\n      // in a script where this happened\n      ycp2error (\"Excessive parameter to %s\", qualifiedName ().c_str ());\n  \n      return false;\n  }\n}"
  },
  {
    "function_name": "attachParameter",
    "container": "Y2YCPFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3421-3431",
    "snippet": "bool\nY2YCPFunction::attachParameter (const YCPValue& arg, int pos)\n{\n    if (pos < 0 || pos > ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount () )\n    {\n\ty2error (\"Attaching parameter to function '%s' at incorrect position: %d\", m_sentry->toString().c_str(), pos );\n\treturn false;\n    }\n    m_parameters[pos] = arg;\n    return true;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Attaching parameter to function '%s' at incorrect position: %d\"",
            "m_sentry->toString().c_str()",
            "pos"
          ],
          "line": 3426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->toString",
          "args": [],
          "line": 3426
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pos < 0 || pos >",
          "args": [],
          "line": 3424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pos < 0 || pos >",
          "args": [
            "(constFunctionTypePtr)(m_sentry->type ())"
          ],
          "line": 3424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "m_sentry->type ()"
          ],
          "line": 3424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->type",
          "args": [],
          "line": 3424
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  bool\n  Y2YCPFunction::attachParameter (const YCPValue& arg, int pos)\n  {\n      if (pos < 0 || pos > ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount () )\n      {\n  \ty2error (\"Attaching parameter to function '%s' at incorrect position: %d\", m_sentry->toString().c_str(), pos );\n  \treturn false;\n      }\n      m_parameters[pos] = arg;\n      return true;\n  }\n}"
  },
  {
    "function_name": "wantedParameterType",
    "container": "Y2YCPFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3391-3418",
    "snippet": "constTypePtr\nY2YCPFunction::wantedParameterType () const\n{\n    if (m_sentry->code ()->kind() != YCode::ycFunction)\n    {\n\treturn Type::Unspec;\n    }\n    YFunctionPtr func_f = m_sentry->code ();\n\n    // find out number of already done parameters\n    for (int i = 0 ; i < ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount (); i++)\n    {\n\tif (m_parameters[i].isNull ())\n\t{\n\t    // returns NULL if actual_count is out of bounds\n\t    SymbolEntryPtr param_se = func_f->parameter (i);\n\n\t    // this is for value conversion purposes. if this is an excess\n\t    // parameter, we don't care about the type now since\n\t    // attachParameter will complain anyway\n    \t    constTypePtr param_tp = param_se ? param_se->type () : Type::Any;\n\t    return param_tp;\n\t}\n    }\n    \n    // all parameters done\n    return Type::Unspec;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "param_se->type",
          "args": [],
          "line": 3411
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "func_f->parameter",
          "args": [
            "i"
          ],
          "line": 3406
        },
        "resolved": true,
        "details": {
          "function_name": "parameter",
          "container": "YFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "682-686",
          "snippet": "SymbolEntryPtr\nYFunction::parameter (unsigned int position) const\n{\n    return (m_declaration ? m_declaration->symbolEntry (position) : 0);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  SymbolEntryPtr\n  YFunction::parameter (unsigned int position) const\n  {\n      return (m_declaration ? m_declaration->symbolEntry (position) : 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_parameters[i].isNull",
          "args": [],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "m_sentry->type ()"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->code",
          "args": [],
          "line": 3398
        },
        "resolved": true,
        "details": {
          "function_name": "code",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "139-147",
          "snippet": "YCodePtr\nYSymbolEntry::code () const\n{\n    if (m_category == c_builtin || m_category == c_module)\n    {\n\treturn 0;\n    }\n    return m_code;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nYSymbolEntry {\n  YCodePtr\n  YSymbolEntry::code () const\n  {\n      if (m_category == c_builtin || m_category == c_module)\n      {\n  \treturn 0;\n      }\n      return m_code;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  constTypePtr\n  Y2YCPFunction::wantedParameterType () const\n  {\n      if (m_sentry->code ()->kind() != YCode::ycFunction)\n      {\n  \treturn Type::Unspec;\n      }\n      YFunctionPtr func_f = m_sentry->code ();\n  \n      // find out number of already done parameters\n      for (int i = 0 ; i < ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount (); i++)\n      {\n  \tif (m_parameters[i].isNull ())\n  \t{\n  \t    // returns NULL if actual_count is out of bounds\n  \t    SymbolEntryPtr param_se = func_f->parameter (i);\n  \n  \t    // this is for value conversion purposes. if this is an excess\n  \t    // parameter, we don't care about the type now since\n  \t    // attachParameter will complain anyway\n      \t    constTypePtr param_tp = param_se ? param_se->type () : Type::Any;\n  \t    return param_tp;\n  \t}\n      }\n      \n      // all parameters done\n      return Type::Unspec;\n  }\n}"
  },
  {
    "function_name": "evaluateCall",
    "container": "Y2YCPFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3306-3388",
    "snippet": "YCPValue\nY2YCPFunction::evaluateCall ()\n{\n#if DO_DEBUG\n//    y2debug (\"Y2YCPFunction::evaluateCall (%s)\\n\", toString().c_str());\n#endif\n\n    YFunctionPtr func = (YFunctionPtr)(m_sentry->code());\n\n    // push parameter values for recursion\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tfunc->parameter (p)->push ();\n    }\n\n    // push also local parameters\n    YCodePtr definition = func->definition ();\n\n    if (definition == 0)\n    {\n\tycp2error (\"Function '%s' is only declared, but not defined yet.\", m_sentry->toString().c_str());\n\treturn YCPNull();\n    }\n\n    if (definition->isBlock())\n    {\n//       ((YBlockPtr)definition)->pushToStack ();\n    }\n\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tYCPValue value = m_parameters[p];\n\n\tif (value.isNull())\n\t{\n\t    ycp2error (\"Parameter not specified (%d)\", p);\n\n\t    // cleanup: pop parameter values for recursion\n\t    for (unsigned int p = 0; p < func->parameterCount(); p++)\n\t    {\n\t\tfunc->parameter (p)->pop ();\n\t    }\n\n\t    return value;\n\t}\n\t\n\tSymbolEntryPtr formalp = func->parameter (p);\n#if DO_DEBUG\n\ty2debug (\"formalp (%s) = (%s)\", formalp->toString().c_str(), value->toString().c_str());\n#endif\n\n\tformalp->setValue (value);\n    }\n    \n    extern ExecutionEnvironment ee;\n\n    // save the context info\n    int linenumber = ee.linenumber ();\n    string filename = ee.filename ();\n\n    YCPValue value = definition->evaluate ();\n\n    if (definition->isBlock())\n    {\n       // pop also local parameters\n//       ((YBlockPtr)definition)->popFromStack ();\n    }\n\n    // restore the context info\n    ee.setLinenumber (linenumber);\n    ee.setFilename (filename);\n\n    // pop parameter values for recursion\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tfunc->parameter (p)->pop ();\n    }\n\n#if DO_DEBUG\n    y2debug(\"evaluate done (%s) = '%s'\", definition->toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n    return value;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"evaluate done (%s) = '%s'\"",
            "definition->toString().c_str()",
            "value.isNull() ? \"NULL\" : value->toString().c_str()"
          ],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 3385
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func->parameter",
          "args": [],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func->parameter",
          "args": [
            "p"
          ],
          "line": 3381
        },
        "resolved": true,
        "details": {
          "function_name": "parameter",
          "container": "YFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "682-686",
          "snippet": "SymbolEntryPtr\nYFunction::parameter (unsigned int position) const\n{\n    return (m_declaration ? m_declaration->symbolEntry (position) : 0);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  SymbolEntryPtr\n  YFunction::parameter (unsigned int position) const\n  {\n      return (m_declaration ? m_declaration->symbolEntry (position) : 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "func->parameterCount",
          "args": [],
          "line": 3379
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.setFilename",
          "args": [
            "filename"
          ],
          "line": 3376
        },
        "resolved": true,
        "details": {
          "function_name": "setFilename",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "87-96",
          "snippet": "void\nYCPDebugger::setFilename (const char *filename)\n{\n    y2debug (\"setFilename (%s)\\n\", filename);\n    if (filename)\n    {\n\tm_filename = filename;\n    }\n    return;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::setFilename (const char *filename)\n  {\n      y2debug (\"setFilename (%s)\\n\", filename);\n      if (filename)\n      {\n  \tm_filename = filename;\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.setLinenumber",
          "args": [
            "linenumber"
          ],
          "line": 3375
        },
        "resolved": true,
        "details": {
          "function_name": "setLinenumber",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "48-52",
          "snippet": "void\nExecutionEnvironment::setLinenumber (int line)\n{\n    m_linenumber = line;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  void\n  ExecutionEnvironment::setLinenumber (int line)\n  {\n      m_linenumber = line;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "definition->isBlock",
          "args": [],
          "line": 3368
        },
        "resolved": true,
        "details": {
          "function_name": "isBlock",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "73-77",
          "snippet": "bool\nYBreakpoint::isBlock () const\n{\n    return m_code->isBlock();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  bool\n  YBreakpoint::isBlock () const\n  {\n      return m_code->isBlock();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "definition->evaluate",
          "args": [],
          "line": 3366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee.filename",
          "args": [],
          "line": 3364
        },
        "resolved": true,
        "details": {
          "function_name": "filename",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "335-339",
          "snippet": "string\nScanner::filename () const\n{\n    return m_filename;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  string\n  Scanner::filename () const\n  {\n      return m_filename;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.linenumber",
          "args": [],
          "line": 3363
        },
        "resolved": true,
        "details": {
          "function_name": "linenumber",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "41-45",
          "snippet": "int\nExecutionEnvironment::linenumber () const\n{\n    return m_linenumber;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  int\n  ExecutionEnvironment::linenumber () const\n  {\n      return m_linenumber;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "formalp->setValue",
          "args": [
            "value"
          ],
          "line": 3357
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "IniEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.h",
          "lines": "155-155",
          "snippet": "void setValue(const string&c)   { dirty = true; val = c;     }",
          "includes": [
            "#include <YCP.h>",
            "#include <vector>",
            "#include <list>",
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <YCP.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\n\nIniEntry {\n  void setValue(const string&c)   { dirty = true; val = c;     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"formalp (%s) = (%s)\"",
            "formalp->toString().c_str()",
            "value->toString().c_str()"
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func->parameter",
          "args": [],
          "line": 3346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Parameter not specified (%d)\"",
            "p"
          ],
          "line": 3341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 3339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 3327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Function '%s' is only declared, but not defined yet.\"",
            "m_sentry->toString().c_str()"
          ],
          "line": 3326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func->definition",
          "args": [],
          "line": 3322
        },
        "resolved": true,
        "details": {
          "function_name": "definition",
          "container": "YFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "602-606",
          "snippet": "YCodePtr\nYFunction::definition() const\n{\n    return m_definition;\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYFunction {\n  YCodePtr\n  YFunction::definition() const\n  {\n      return m_definition;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "func->parameter",
          "args": [],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "m_sentry->code()"
          ],
          "line": 3313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->code",
          "args": [],
          "line": 3313
        },
        "resolved": true,
        "details": {
          "function_name": "code",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "139-147",
          "snippet": "YCodePtr\nYSymbolEntry::code () const\n{\n    if (m_category == c_builtin || m_category == c_module)\n    {\n\treturn 0;\n    }\n    return m_code;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nYSymbolEntry {\n  YCodePtr\n  YSymbolEntry::code () const\n  {\n      if (m_category == c_builtin || m_category == c_module)\n      {\n  \treturn 0;\n      }\n      return m_code;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nY2YCPFunction {\n  YCPValue\n  Y2YCPFunction::evaluateCall ()\n  {\n  #if DO_DEBUG\n  //    y2debug (\"Y2YCPFunction::evaluateCall (%s)\\n\", toString().c_str());\n  #endif\n  \n      YFunctionPtr func = (YFunctionPtr)(m_sentry->code());\n  \n      // push parameter values for recursion\n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tfunc->parameter (p)->push ();\n      }\n  \n      // push also local parameters\n      YCodePtr definition = func->definition ();\n  \n      if (definition == 0)\n      {\n  \tycp2error (\"Function '%s' is only declared, but not defined yet.\", m_sentry->toString().c_str());\n  \treturn YCPNull();\n      }\n  \n      if (definition->isBlock())\n      {\n  //       ((YBlockPtr)definition)->pushToStack ();\n      }\n  \n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tYCPValue value = m_parameters[p];\n  \n  \tif (value.isNull())\n  \t{\n  \t    ycp2error (\"Parameter not specified (%d)\", p);\n  \n  \t    // cleanup: pop parameter values for recursion\n  \t    for (unsigned int p = 0; p < func->parameterCount(); p++)\n  \t    {\n  \t\tfunc->parameter (p)->pop ();\n  \t    }\n  \n  \t    return value;\n  \t}\n  \t\n  \tSymbolEntryPtr formalp = func->parameter (p);\n  #if DO_DEBUG\n  \ty2debug (\"formalp (%s) = (%s)\", formalp->toString().c_str(), value->toString().c_str());\n  #endif\n  \n  \tformalp->setValue (value);\n      }\n      \n      extern ExecutionEnvironment ee;\n  \n      // save the context info\n      int linenumber = ee.linenumber ();\n      string filename = ee.filename ();\n  \n      YCPValue value = definition->evaluate ();\n  \n      if (definition->isBlock())\n      {\n         // pop also local parameters\n  //       ((YBlockPtr)definition)->popFromStack ();\n      }\n  \n      // restore the context info\n      ee.setLinenumber (linenumber);\n      ee.setFilename (filename);\n  \n      // pop parameter values for recursion\n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tfunc->parameter (p)->pop ();\n      }\n  \n  #if DO_DEBUG\n      y2debug(\"evaluate done (%s) = '%s'\", definition->toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n      return value;\n  }\n}"
  },
  {
    "function_name": "~Y2YCPFunction",
    "container": "Y2YCPFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3300-3303",
    "snippet": "Y2YCPFunction::~Y2YCPFunction ()\n{\n    delete[] m_parameters;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  Y2YCPFunction::~Y2YCPFunction ()\n  {\n      delete[] m_parameters;\n  }\n}"
  },
  {
    "function_name": "Y2YCPFunction",
    "container": "Y2YCPFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3279-3297",
    "snippet": "Y2YCPFunction::Y2YCPFunction (YSymbolEntryPtr entry)\n    : Y2Function ()\n    , m_sentry (entry)\n    , m_parameters (NULL)\n{\n#if DO_DEBUG\n    y2debug (\"Y2YCPFunction[%p] (%s)\", this, entry->toString().c_str());\n#endif\n    // cleanup an array for the parameters\n    \n    uint count = ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount ();\n    \n    m_parameters = new YCPValue[count];\n    \n    for (uint i=0; i < count; i++)\n    {\n\tm_parameters[i] = YCPNull ();\n    }\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "m_sentry->type ()"
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->type",
          "args": [],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Y2YCPFunction[%p] (%s)\"",
            "this",
            "entry->toString().c_str()"
          ],
          "line": 3285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry->toString",
          "args": [],
          "line": 3285
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nY2YCPFunction {\n  Y2YCPFunction::Y2YCPFunction (YSymbolEntryPtr entry)\n      : Y2Function ()\n      , m_sentry (entry)\n      , m_parameters (NULL)\n  {\n  #if DO_DEBUG\n      y2debug (\"Y2YCPFunction[%p] (%s)\", this, entry->toString().c_str());\n  #endif\n      // cleanup an array for the parameters\n      \n      uint count = ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount ();\n      \n      m_parameters = new YCPValue[count];\n      \n      for (uint i=0; i < count; i++)\n      {\n  \tm_parameters[i] = YCPNull ();\n      }\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YEFunctionPointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3191-3273",
    "snippet": "YCPValue\nYEFunctionPointer::evaluate (bool cse)\n{\n    if (cse)\n    {\n\treturn YCPNull();\n    }\n\n#if DO_DEBUG\n    y2debug (\"YEFunctionPointer::evaluate (%s)\\n\", toString().c_str());\n#endif\n\n    YCPValue ptr = m_sentry->value ();\n    if (ptr.isNull () || ! ptr->isReference ())\n    {\n\tycp2error (\"Function pointer (%s) is %s\"\n\t    , m_sentry->toString().c_str()\n\t    , ptr.isNull () ? \"NULL\" : ptr->toString ().c_str ());\n\treturn YCPVoid ();\n    }\n    \n    SymbolEntryPtr ptr_sentry = ptr->asReference ()->entry ();\n\n    Y2Namespace* ns = const_cast<Y2Namespace*> (ptr_sentry->nameSpace ());\n\n    m_functioncall = ns->createFunctionCall (\n\tptr_sentry->name (),\n\tptr_sentry->type ()\n    );\n    \n    if (!m_functioncall)\n    {\n\ty2internal (\"Cannot get function call object for %s\", m_sentry->toString().c_str());\n\treturn YCPVoid ();\n    }\n\n    // FIXME: this could fail    \n    m_functioncall->reset ();\n    \n    YCPValue m_params [m_next_param_id];\n\n    for (unsigned int p = 0; p < m_next_param_id ; p++)\n    {\n\t// FIXME, check for symbol or block type and suppress evaluation\n\n\tYCPValue value = m_parameters[p]->evaluate ();\n\n\tif (value.isNull())\n\t{\n\t    ycp2error (\"Parameter eval failed (%s)\", m_parameters[p]->toString().c_str());\n\t    return value;\n\t}\n\t\n#if DO_DEBUG\n\ty2debug (\"parameter %d = (%s)\", p, value->toString().c_str());\n#endif\n\n\tm_params [p] = value;\n    }\n\n    // set the parameters for Y2Function\n    for (unsigned int p = 0; p < m_next_param_id ; p++)\n    {\n\tm_functioncall->attachParameter (m_params[p], p);\n    }\n    \n    extern ExecutionEnvironment ee;\n\n    // save the context info\n    int linenumber = ee.linenumber ();\n    string filename = ee.filename ();\n\n    YCPValue value = m_functioncall->evaluateCall ();\n\n    // restore the context info\n    ee.setLinenumber (linenumber);\n    ee.setFilename (filename);\n\n#if DO_DEBUG\n    y2debug(\"evaluate done (%s) = '%s'\", qualifiedName ().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n    return value;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"evaluate done (%s) = '%s'\"",
            "qualifiedName ().c_str()",
            "value.isNull() ? \"NULL\" : value->toString().c_str()"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 3270
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qualifiedName",
          "args": [],
          "line": 3270
        },
        "resolved": true,
        "details": {
          "function_name": "qualifiedName",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3482-3489",
          "snippet": "string\nY2YCPFunction::qualifiedName () const\n{\n    string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n\t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n\t\"\";\n    return n + m_sentry->name ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  string\n  Y2YCPFunction::qualifiedName () const\n  {\n      string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n  \t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n  \t\"\";\n      return n + m_sentry->name ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.setFilename",
          "args": [
            "filename"
          ],
          "line": 3267
        },
        "resolved": true,
        "details": {
          "function_name": "setFilename",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "87-96",
          "snippet": "void\nYCPDebugger::setFilename (const char *filename)\n{\n    y2debug (\"setFilename (%s)\\n\", filename);\n    if (filename)\n    {\n\tm_filename = filename;\n    }\n    return;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::setFilename (const char *filename)\n  {\n      y2debug (\"setFilename (%s)\\n\", filename);\n      if (filename)\n      {\n  \tm_filename = filename;\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.setLinenumber",
          "args": [
            "linenumber"
          ],
          "line": 3266
        },
        "resolved": true,
        "details": {
          "function_name": "setLinenumber",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "48-52",
          "snippet": "void\nExecutionEnvironment::setLinenumber (int line)\n{\n    m_linenumber = line;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  void\n  ExecutionEnvironment::setLinenumber (int line)\n  {\n      m_linenumber = line;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_functioncall->evaluateCall",
          "args": [],
          "line": 3263
        },
        "resolved": true,
        "details": {
          "function_name": "evaluateCall",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3306-3388",
          "snippet": "YCPValue\nY2YCPFunction::evaluateCall ()\n{\n#if DO_DEBUG\n//    y2debug (\"Y2YCPFunction::evaluateCall (%s)\\n\", toString().c_str());\n#endif\n\n    YFunctionPtr func = (YFunctionPtr)(m_sentry->code());\n\n    // push parameter values for recursion\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tfunc->parameter (p)->push ();\n    }\n\n    // push also local parameters\n    YCodePtr definition = func->definition ();\n\n    if (definition == 0)\n    {\n\tycp2error (\"Function '%s' is only declared, but not defined yet.\", m_sentry->toString().c_str());\n\treturn YCPNull();\n    }\n\n    if (definition->isBlock())\n    {\n//       ((YBlockPtr)definition)->pushToStack ();\n    }\n\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tYCPValue value = m_parameters[p];\n\n\tif (value.isNull())\n\t{\n\t    ycp2error (\"Parameter not specified (%d)\", p);\n\n\t    // cleanup: pop parameter values for recursion\n\t    for (unsigned int p = 0; p < func->parameterCount(); p++)\n\t    {\n\t\tfunc->parameter (p)->pop ();\n\t    }\n\n\t    return value;\n\t}\n\t\n\tSymbolEntryPtr formalp = func->parameter (p);\n#if DO_DEBUG\n\ty2debug (\"formalp (%s) = (%s)\", formalp->toString().c_str(), value->toString().c_str());\n#endif\n\n\tformalp->setValue (value);\n    }\n    \n    extern ExecutionEnvironment ee;\n\n    // save the context info\n    int linenumber = ee.linenumber ();\n    string filename = ee.filename ();\n\n    YCPValue value = definition->evaluate ();\n\n    if (definition->isBlock())\n    {\n       // pop also local parameters\n//       ((YBlockPtr)definition)->popFromStack ();\n    }\n\n    // restore the context info\n    ee.setLinenumber (linenumber);\n    ee.setFilename (filename);\n\n    // pop parameter values for recursion\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tfunc->parameter (p)->pop ();\n    }\n\n#if DO_DEBUG\n    y2debug(\"evaluate done (%s) = '%s'\", definition->toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n    return value;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nY2YCPFunction {\n  YCPValue\n  Y2YCPFunction::evaluateCall ()\n  {\n  #if DO_DEBUG\n  //    y2debug (\"Y2YCPFunction::evaluateCall (%s)\\n\", toString().c_str());\n  #endif\n  \n      YFunctionPtr func = (YFunctionPtr)(m_sentry->code());\n  \n      // push parameter values for recursion\n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tfunc->parameter (p)->push ();\n      }\n  \n      // push also local parameters\n      YCodePtr definition = func->definition ();\n  \n      if (definition == 0)\n      {\n  \tycp2error (\"Function '%s' is only declared, but not defined yet.\", m_sentry->toString().c_str());\n  \treturn YCPNull();\n      }\n  \n      if (definition->isBlock())\n      {\n  //       ((YBlockPtr)definition)->pushToStack ();\n      }\n  \n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tYCPValue value = m_parameters[p];\n  \n  \tif (value.isNull())\n  \t{\n  \t    ycp2error (\"Parameter not specified (%d)\", p);\n  \n  \t    // cleanup: pop parameter values for recursion\n  \t    for (unsigned int p = 0; p < func->parameterCount(); p++)\n  \t    {\n  \t\tfunc->parameter (p)->pop ();\n  \t    }\n  \n  \t    return value;\n  \t}\n  \t\n  \tSymbolEntryPtr formalp = func->parameter (p);\n  #if DO_DEBUG\n  \ty2debug (\"formalp (%s) = (%s)\", formalp->toString().c_str(), value->toString().c_str());\n  #endif\n  \n  \tformalp->setValue (value);\n      }\n      \n      extern ExecutionEnvironment ee;\n  \n      // save the context info\n      int linenumber = ee.linenumber ();\n      string filename = ee.filename ();\n  \n      YCPValue value = definition->evaluate ();\n  \n      if (definition->isBlock())\n      {\n         // pop also local parameters\n  //       ((YBlockPtr)definition)->popFromStack ();\n      }\n  \n      // restore the context info\n      ee.setLinenumber (linenumber);\n      ee.setFilename (filename);\n  \n      // pop parameter values for recursion\n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tfunc->parameter (p)->pop ();\n      }\n  \n  #if DO_DEBUG\n      y2debug(\"evaluate done (%s) = '%s'\", definition->toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.filename",
          "args": [],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "filename",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "335-339",
          "snippet": "string\nScanner::filename () const\n{\n    return m_filename;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  string\n  Scanner::filename () const\n  {\n      return m_filename;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.linenumber",
          "args": [],
          "line": 3260
        },
        "resolved": true,
        "details": {
          "function_name": "linenumber",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "41-45",
          "snippet": "int\nExecutionEnvironment::linenumber () const\n{\n    return m_linenumber;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  int\n  ExecutionEnvironment::linenumber () const\n  {\n      return m_linenumber;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_functioncall->attachParameter",
          "args": [
            "m_params[p]",
            "p"
          ],
          "line": 3254
        },
        "resolved": true,
        "details": {
          "function_name": "attachParameter",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3421-3431",
          "snippet": "bool\nY2YCPFunction::attachParameter (const YCPValue& arg, int pos)\n{\n    if (pos < 0 || pos > ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount () )\n    {\n\ty2error (\"Attaching parameter to function '%s' at incorrect position: %d\", m_sentry->toString().c_str(), pos );\n\treturn false;\n    }\n    m_parameters[pos] = arg;\n    return true;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  bool\n  Y2YCPFunction::attachParameter (const YCPValue& arg, int pos)\n  {\n      if (pos < 0 || pos > ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount () )\n      {\n  \ty2error (\"Attaching parameter to function '%s' at incorrect position: %d\", m_sentry->toString().c_str(), pos );\n  \treturn false;\n      }\n      m_parameters[pos] = arg;\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"parameter %d = (%s)\"",
            "p",
            "value->toString().c_str()"
          ],
          "line": 3245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Parameter eval failed (%s)\"",
            "m_parameters[p]->toString().c_str()"
          ],
          "line": 3240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 3238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_parameters[p]->evaluate",
          "args": [],
          "line": 3236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_functioncall->reset",
          "args": [],
          "line": 3228
        },
        "resolved": true,
        "details": {
          "function_name": "reset",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3491-3500",
          "snippet": "bool\nY2YCPFunction::reset ()\n{\n    for (int i=0; i<((constFunctionTypePtr)(m_sentry->type ()))->parameterCount (); i++)\n    {\n\tm_parameters[i] = YCPNull ();\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  bool\n  Y2YCPFunction::reset ()\n  {\n      for (int i=0; i<((constFunctionTypePtr)(m_sentry->type ()))->parameterCount (); i++)\n      {\n  \tm_parameters[i] = YCPNull ();\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 3224
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2internal",
          "args": [
            "\"Cannot get function call object for %s\"",
            "m_sentry->toString().c_str()"
          ],
          "line": 3223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns->createFunctionCall",
          "args": [
            "ptr_sentry->name ()",
            "ptr_sentry->type ()"
          ],
          "line": 3216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_sentry->type",
          "args": [],
          "line": 3218
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr_sentry->name",
          "args": [],
          "line": 3217
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3503-3507",
          "snippet": "string\nY2YCPFunction::name () const\n{\n    return m_sentry->name ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  string\n  Y2YCPFunction::name () const\n  {\n      return m_sentry->name ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<Y2Namespace*>",
          "args": [
            "ptr_sentry->nameSpace ()"
          ],
          "line": 3214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_sentry->nameSpace",
          "args": [],
          "line": 3214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr->asReference",
          "args": [],
          "line": 3212
        },
        "resolved": true,
        "details": {
          "function_name": "asReference",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "239-249",
          "snippet": "YCPReference\nYCPValueRep::asReference() const\n{\n    if (!isReference())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Reference!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPReference (static_cast<const YCPReferenceRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPReference\n  YCPValueRep::asReference() const\n  {\n      if (!isReference())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Reference!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPReference (static_cast<const YCPReferenceRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Function pointer (%s) is %s\"",
            "m_sentry->toString().c_str()",
            "ptr.isNull () ? \"NULL\" : ptr->toString ().c_str ()"
          ],
          "line": 3206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr.isNull",
          "args": [],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr->isReference",
          "args": [],
          "line": 3204
        },
        "resolved": true,
        "details": {
          "function_name": "isReference",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "76-76",
          "snippet": "bool YCPValueRep::isReference()\t  const { return valuetype() == YT_REFERENCE; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isReference()\t  const { return valuetype() == YT_REFERENCE; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr.isNull",
          "args": [],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->value",
          "args": [],
          "line": 3203
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEFunctionPointer::evaluate (%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 3200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEFunctionPointer {\n  YCPValue\n  YEFunctionPointer::evaluate (bool cse)\n  {\n      if (cse)\n      {\n  \treturn YCPNull();\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"YEFunctionPointer::evaluate (%s)\\n\", toString().c_str());\n  #endif\n  \n      YCPValue ptr = m_sentry->value ();\n      if (ptr.isNull () || ! ptr->isReference ())\n      {\n  \tycp2error (\"Function pointer (%s) is %s\"\n  \t    , m_sentry->toString().c_str()\n  \t    , ptr.isNull () ? \"NULL\" : ptr->toString ().c_str ());\n  \treturn YCPVoid ();\n      }\n      \n      SymbolEntryPtr ptr_sentry = ptr->asReference ()->entry ();\n  \n      Y2Namespace* ns = const_cast<Y2Namespace*> (ptr_sentry->nameSpace ());\n  \n      m_functioncall = ns->createFunctionCall (\n  \tptr_sentry->name (),\n  \tptr_sentry->type ()\n      );\n      \n      if (!m_functioncall)\n      {\n  \ty2internal (\"Cannot get function call object for %s\", m_sentry->toString().c_str());\n  \treturn YCPVoid ();\n      }\n  \n      // FIXME: this could fail    \n      m_functioncall->reset ();\n      \n      YCPValue m_params [m_next_param_id];\n  \n      for (unsigned int p = 0; p < m_next_param_id ; p++)\n      {\n  \t// FIXME, check for symbol or block type and suppress evaluation\n  \n  \tYCPValue value = m_parameters[p]->evaluate ();\n  \n  \tif (value.isNull())\n  \t{\n  \t    ycp2error (\"Parameter eval failed (%s)\", m_parameters[p]->toString().c_str());\n  \t    return value;\n  \t}\n  \t\n  #if DO_DEBUG\n  \ty2debug (\"parameter %d = (%s)\", p, value->toString().c_str());\n  #endif\n  \n  \tm_params [p] = value;\n      }\n  \n      // set the parameters for Y2Function\n      for (unsigned int p = 0; p < m_next_param_id ; p++)\n      {\n  \tm_functioncall->attachParameter (m_params[p], p);\n      }\n      \n      extern ExecutionEnvironment ee;\n  \n      // save the context info\n      int linenumber = ee.linenumber ();\n      string filename = ee.filename ();\n  \n      YCPValue value = m_functioncall->evaluateCall ();\n  \n      // restore the context info\n      ee.setLinenumber (linenumber);\n      ee.setFilename (filename);\n  \n  #if DO_DEBUG\n      y2debug(\"evaluate done (%s) = '%s'\", qualifiedName ().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n      return value;\n  }\n}"
  },
  {
    "function_name": "YEFunctionPointer",
    "container": "YEFunctionPointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3185-3188",
    "snippet": "YEFunctionPointer::YEFunctionPointer (bytecodeistream & str)\n    : YECall (str)\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEFunctionPointer {\n  YEFunctionPointer::YEFunctionPointer (bytecodeistream & str)\n      : YECall (str)\n  {\n  }\n}"
  },
  {
    "function_name": "YEFunctionPointer",
    "container": "YEFunctionPointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3176-3182",
    "snippet": "YEFunctionPointer::YEFunctionPointer (TableEntry* entry)\n    : YECall (entry)\n{\n#if DO_DEBUG\n    y2debug (\"YEFunctionPointer[%p] (%s)\", this, entry ? entry->sentry()->toString().c_str() : \"nil\");\n#endif\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEFunctionPointer[%p] (%s)\"",
            "this",
            "entry ? entry->sentry()->toString().c_str() : \"nil\""
          ],
          "line": 3180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry->sentry",
          "args": [],
          "line": 3180
        },
        "resolved": true,
        "details": {
          "function_name": "sentry",
          "container": "TableEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "97-101",
          "snippet": "SymbolEntryPtr \nTableEntry::sentry() const\n{\n    return m_entry;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  SymbolEntryPtr \n  TableEntry::sentry() const\n  {\n      return m_entry;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEFunctionPointer {\n  YEFunctionPointer::YEFunctionPointer (TableEntry* entry)\n      : YECall (entry)\n  {\n  #if DO_DEBUG\n      y2debug (\"YEFunctionPointer[%p] (%s)\", this, entry ? entry->sentry()->toString().c_str() : \"nil\");\n  #endif\n  }\n}"
  },
  {
    "function_name": "finalize",
    "container": "YEFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3152-3170",
    "snippet": "constTypePtr\nYEFunction::finalize()\n{\n    constTypePtr res = YECall::finalize ();\n    \n    if (res != 0)\n    {\n\treturn res;\n    }\n    \n    m_functioncall = const_cast<Y2Namespace*>(m_sentry->nameSpace())->createFunctionCall (m_sentry->name (), m_sentry->type ());\n    if (m_functioncall == 0)\n    {\n\ty2error (\"Cannot create a function call for %s\", m_sentry->toString ().c_str ());\n\treturn Type::Error;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Cannot create a function call for %s\"",
            "m_sentry->toString ().c_str ()"
          ],
          "line": 3165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->toString",
          "args": [],
          "line": 3165
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<Y2Namespace*>",
          "args": [
            "m_sentry->name ()",
            "m_sentry->type ()"
          ],
          "line": 3162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->type",
          "args": [],
          "line": 3162
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_sentry->name",
          "args": [],
          "line": 3162
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3503-3507",
          "snippet": "string\nY2YCPFunction::name () const\n{\n    return m_sentry->name ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  string\n  Y2YCPFunction::name () const\n  {\n      return m_sentry->name ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<Y2Namespace*>",
          "args": [
            "m_sentry->nameSpace()"
          ],
          "line": 3162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->nameSpace",
          "args": [],
          "line": 3162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YECall::finalize",
          "args": [],
          "line": 3155
        },
        "resolved": true,
        "details": {
          "function_name": "finalize",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2830-2953",
          "snippet": "constTypePtr\nYECall::finalize()\n{\n    TableEntry* entry = m_entry;\n\n    while (entry)\n    {\n\t// now check the parameters really. if they don't match,\n\t// lookup also the overloaded ones    \n\tSymbolEntryPtr sentry = entry->sentry ();\n\n\t// prepare the overloaded one, if exists\n\tTableEntry* next_overloaded = entry->next_overloaded ();\n\n\t// retrieve function type for formal parameter list\n\tconstFunctionTypePtr ftype = sentry->type();\n\t\n\t// not the correct number of parameters?\n\tif ((int)m_next_param_id != ftype->parameterCount())\n\t{\n\t    // try to continue with the next one\n\t    entry = next_overloaded;\n\t    continue;\n\t}\n    \n\tbool accept = true;\n\t// ok, check whether types match\n\tfor (uint check_count = 0; check_count < m_next_param_id ; check_count++)\n\t{\n\t    constTypePtr expected_type = ftype->parameterType (check_count);\n\t    YCodePtr code = m_parameters[check_count];\n\t    constTypePtr type = m_parameter_types[check_count];\n\t    \n\t    // if the parameter type is block, find out the type for the actual param\n\t    if (expected_type->isBlock ())\n\t    {\n\t\tif (code->isBlock ())\n\t\t{\n\t\t    type = new BlockType(type->isUnspec () ? Type::Void : type);\n\t\t}\n\t    }\n\n#if DO_DEBUG\n\t    y2debug (\"checking parameter %d type: expected '%s', given '%s'\", check_count, expected_type->toString().c_str(), type->toString().c_str());\n#endif\n\n\t    int match = type->match (expected_type);\n\t    if (match < 0)\n\t    {\n#if DO_DEBUG\n\t\ty2debug (\"type mismatch\");\n#endif\n\t\t// type mismatch\n\t\tentry = next_overloaded;\n\t\taccept = false;\n\t\tbreak;\n\t    }\n\n\t    if (expected_type->isReference())\t// function expects a reference\n\t    {\n\t\tif (! code->isReferenceable())\t// but the actual parameter isn't referenceable\n\t\t{\n\t\t    y2debug (\"Can't take reference of '%s'\", code->toString().c_str());\n\t\t    entry = next_overloaded;\n\t\t    accept = false;\n\t\t    break;\n\t\t}\n\t\telse if (match > 0)\n\t\t{\n#if DO_DEBUG\n\t\t    y2debug (\"Can't reference to type propagation '%s' -> '%s'\", type->toString().c_str(), expected_type->toString().c_str());\n#endif\t\t    \n\t\t    entry = next_overloaded;\n\t\t    accept = false;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\t\n\tif (accept)\n\t{\n#if DO_DEBUG\n\t    y2debug (\"Accepting for: %s\", entry->sentry()->toString().c_str());\n#endif\n\t    // adapt the code (add propagation/references if needed)\n\t    for (uint check_count = 0 ; check_count < m_next_param_id; check_count++ )\n\t    {\n\t\tconstTypePtr expected_type = ftype->parameterType (check_count);\n\t\tconstTypePtr type = m_parameters[check_count]->type ();\n\t    \n\t\t// if the parameter type is block, find out the type for the actual param\n\t\tif (expected_type->isBlock ())\n\t\t{\n\t\t    if (m_parameters[check_count]->isBlock ())\n\t\t    {\n\t\t\ttype = new BlockType(type->isUnspec () ? Type::Void : type);\n\t\t    }\n\t\t}\n\n\t\tint match = type->match (expected_type);\n\n\t\tif (expected_type->isReference())\t// function expects a reference\n\t\t{\n\t\t    YEVariablePtr var = (YEVariablePtr)(m_parameters[check_count]);\n\t\t    m_parameters[check_count] = new YEReference (var->entry());\n\t\t}\n\n\t\tif (match > 0)\t\t\t\t// propagation\n\t\t{\n\t\t    m_parameters[check_count] = new YEPropagate (m_parameters[check_count], type, expected_type);\n\t\t}\n\t    }\n\t    \n\t    // update the sentry\n\t    m_entry = entry;\n\t    m_sentry = m_entry->sentry ();\n\n\t    return 0;\n\t}\n    }\n\n    // none was accepted;\n    return Type::Error;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  constTypePtr\n  YECall::finalize()\n  {\n      TableEntry* entry = m_entry;\n  \n      while (entry)\n      {\n  \t// now check the parameters really. if they don't match,\n  \t// lookup also the overloaded ones    \n  \tSymbolEntryPtr sentry = entry->sentry ();\n  \n  \t// prepare the overloaded one, if exists\n  \tTableEntry* next_overloaded = entry->next_overloaded ();\n  \n  \t// retrieve function type for formal parameter list\n  \tconstFunctionTypePtr ftype = sentry->type();\n  \t\n  \t// not the correct number of parameters?\n  \tif ((int)m_next_param_id != ftype->parameterCount())\n  \t{\n  \t    // try to continue with the next one\n  \t    entry = next_overloaded;\n  \t    continue;\n  \t}\n      \n  \tbool accept = true;\n  \t// ok, check whether types match\n  \tfor (uint check_count = 0; check_count < m_next_param_id ; check_count++)\n  \t{\n  \t    constTypePtr expected_type = ftype->parameterType (check_count);\n  \t    YCodePtr code = m_parameters[check_count];\n  \t    constTypePtr type = m_parameter_types[check_count];\n  \t    \n  \t    // if the parameter type is block, find out the type for the actual param\n  \t    if (expected_type->isBlock ())\n  \t    {\n  \t\tif (code->isBlock ())\n  \t\t{\n  \t\t    type = new BlockType(type->isUnspec () ? Type::Void : type);\n  \t\t}\n  \t    }\n  \n  #if DO_DEBUG\n  \t    y2debug (\"checking parameter %d type: expected '%s', given '%s'\", check_count, expected_type->toString().c_str(), type->toString().c_str());\n  #endif\n  \n  \t    int match = type->match (expected_type);\n  \t    if (match < 0)\n  \t    {\n  #if DO_DEBUG\n  \t\ty2debug (\"type mismatch\");\n  #endif\n  \t\t// type mismatch\n  \t\tentry = next_overloaded;\n  \t\taccept = false;\n  \t\tbreak;\n  \t    }\n  \n  \t    if (expected_type->isReference())\t// function expects a reference\n  \t    {\n  \t\tif (! code->isReferenceable())\t// but the actual parameter isn't referenceable\n  \t\t{\n  \t\t    y2debug (\"Can't take reference of '%s'\", code->toString().c_str());\n  \t\t    entry = next_overloaded;\n  \t\t    accept = false;\n  \t\t    break;\n  \t\t}\n  \t\telse if (match > 0)\n  \t\t{\n  #if DO_DEBUG\n  \t\t    y2debug (\"Can't reference to type propagation '%s' -> '%s'\", type->toString().c_str(), expected_type->toString().c_str());\n  #endif\t\t    \n  \t\t    entry = next_overloaded;\n  \t\t    accept = false;\n  \t\t    break;\n  \t\t}\n  \t    }\n  \t}\n  \t\n  \tif (accept)\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"Accepting for: %s\", entry->sentry()->toString().c_str());\n  #endif\n  \t    // adapt the code (add propagation/references if needed)\n  \t    for (uint check_count = 0 ; check_count < m_next_param_id; check_count++ )\n  \t    {\n  \t\tconstTypePtr expected_type = ftype->parameterType (check_count);\n  \t\tconstTypePtr type = m_parameters[check_count]->type ();\n  \t    \n  \t\t// if the parameter type is block, find out the type for the actual param\n  \t\tif (expected_type->isBlock ())\n  \t\t{\n  \t\t    if (m_parameters[check_count]->isBlock ())\n  \t\t    {\n  \t\t\ttype = new BlockType(type->isUnspec () ? Type::Void : type);\n  \t\t    }\n  \t\t}\n  \n  \t\tint match = type->match (expected_type);\n  \n  \t\tif (expected_type->isReference())\t// function expects a reference\n  \t\t{\n  \t\t    YEVariablePtr var = (YEVariablePtr)(m_parameters[check_count]);\n  \t\t    m_parameters[check_count] = new YEReference (var->entry());\n  \t\t}\n  \n  \t\tif (match > 0)\t\t\t\t// propagation\n  \t\t{\n  \t\t    m_parameters[check_count] = new YEPropagate (m_parameters[check_count], type, expected_type);\n  \t\t}\n  \t    }\n  \t    \n  \t    // update the sentry\n  \t    m_entry = entry;\n  \t    m_sentry = m_entry->sentry ();\n  \n  \t    return 0;\n  \t}\n      }\n  \n      // none was accepted;\n      return Type::Error;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEFunction {\n  constTypePtr\n  YEFunction::finalize()\n  {\n      constTypePtr res = YECall::finalize ();\n      \n      if (res != 0)\n      {\n  \treturn res;\n      }\n      \n      m_functioncall = const_cast<Y2Namespace*>(m_sentry->nameSpace())->createFunctionCall (m_sentry->name (), m_sentry->type ());\n      if (m_functioncall == 0)\n      {\n  \ty2error (\"Cannot create a function call for %s\", m_sentry->toString ().c_str ());\n  \treturn Type::Error;\n      }\n  \n      return 0;\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YEFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3057-3141",
    "snippet": "YCPValue\nYEFunction::evaluate (bool cse)\n{\n    if (cse)\n    {\n\treturn YCPNull();\n    }\n\n#if DO_DEBUG\n    y2debug (\"YEFunction::evaluate (%s)\\n\", toString().c_str());\n#endif\n\n    \n    if (!m_functioncall)\n    {\n\tm_functioncall = const_cast<Y2Namespace*>(m_sentry->nameSpace())->createFunctionCall (m_sentry->name (), m_sentry->type ());\n\tif (m_functioncall == 0)\n\t{\n\t    y2error (\"Cannot create a function call for %s\", m_sentry->toString ().c_str ());\n\t    return YCPVoid ();\n        }\n    }\n    else\n    {\n\tif (! m_functioncall->reset ())\n\t{\n\t    y2error (\"failed to reset function call parameters for %s\", m_sentry->toString ().c_str ());\n\t    return YCPVoid ();\n\t}\n    }\n    \n    YCPValue evaluated_params [m_next_param_id];\n\n    for (unsigned int p = 0; p < m_next_param_id ; p++)\n    {\n\t// FIXME, check for symbol or block type and suppress evaluation\n\n\tYCPValue value = m_parameters[p]->evaluate ();\n\n\tif (value.isNull())\n\t{\n\t    ycp2error (\"Parameter eval failed (%s)\", m_parameters[p]->toString().c_str());\n\t    return value;\n\t}\n\t\n#if DO_DEBUG\n\ty2debug (\"parameter %d = (%s)\", p, value->toString().c_str());\n#endif\n\n\tevaluated_params [p] = value;\n    }\n\n    // set the parameters for Y2Function\n    for (unsigned int p = 0; p < m_next_param_id ; p++)\n    {\n\tm_functioncall->attachParameter (evaluated_params[p], p);\n    }\n    \n    extern ExecutionEnvironment ee;\n\n    // save the context info\n    int linenumber = ee.linenumber ();\n    string filename = ee.filename ();\n\n    if (ee.endlessRecursion ())\n    {\n\tycp2error (\"Returning nil instead of calling the function.\");\n\treturn YCPVoid ();\n    }\n\n    ee.pushframe ((YECallPtr)this, evaluated_params);\n\n    YCPValue value = m_functioncall->evaluateCall ();\n\n    // restore the context info\n    ee.setLinenumber (linenumber);\n    ee.setFilename (filename);\n    \n    ee.popframe ();\n\n#if DO_DEBUG\n    y2debug(\"evaluate done (%s) = '%s'\", qualifiedName ().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n    return value;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"evaluate done (%s) = '%s'\"",
            "qualifiedName ().c_str()",
            "value.isNull() ? \"NULL\" : value->toString().c_str()"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 3138
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qualifiedName",
          "args": [],
          "line": 3138
        },
        "resolved": true,
        "details": {
          "function_name": "qualifiedName",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3482-3489",
          "snippet": "string\nY2YCPFunction::qualifiedName () const\n{\n    string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n\t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n\t\"\";\n    return n + m_sentry->name ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  string\n  Y2YCPFunction::qualifiedName () const\n  {\n      string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n  \t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n  \t\"\";\n      return n + m_sentry->name ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.popframe",
          "args": [],
          "line": 3135
        },
        "resolved": true,
        "details": {
          "function_name": "popframe",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "112-120",
          "snippet": "void\nExecutionEnvironment::popframe ()\n{\n    y2debug (\"Pop frame %p\", m_backtrace.back ());\n    const CallFrame* frame = m_backtrace.back ();\n    m_backtrace.pop_back ();\n    // backtrace( LOG_MILESTONE, 0 );\n    delete frame;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  void\n  ExecutionEnvironment::popframe ()\n  {\n      y2debug (\"Pop frame %p\", m_backtrace.back ());\n      const CallFrame* frame = m_backtrace.back ();\n      m_backtrace.pop_back ();\n      // backtrace( LOG_MILESTONE, 0 );\n      delete frame;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.setFilename",
          "args": [
            "filename"
          ],
          "line": 3133
        },
        "resolved": true,
        "details": {
          "function_name": "setFilename",
          "container": "YCPDebugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPDebugger.cc",
          "lines": "87-96",
          "snippet": "void\nYCPDebugger::setFilename (const char *filename)\n{\n    y2debug (\"setFilename (%s)\\n\", filename);\n    if (filename)\n    {\n\tm_filename = filename;\n    }\n    return;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/YCPDebugger.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCode.h\"\n#include \"ycp/YCPDebugger.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nYCPDebugger {\n  void\n  YCPDebugger::setFilename (const char *filename)\n  {\n      y2debug (\"setFilename (%s)\\n\", filename);\n      if (filename)\n      {\n  \tm_filename = filename;\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.setLinenumber",
          "args": [
            "linenumber"
          ],
          "line": 3132
        },
        "resolved": true,
        "details": {
          "function_name": "setLinenumber",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "48-52",
          "snippet": "void\nExecutionEnvironment::setLinenumber (int line)\n{\n    m_linenumber = line;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  void\n  ExecutionEnvironment::setLinenumber (int line)\n  {\n      m_linenumber = line;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_functioncall->evaluateCall",
          "args": [],
          "line": 3129
        },
        "resolved": true,
        "details": {
          "function_name": "evaluateCall",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3306-3388",
          "snippet": "YCPValue\nY2YCPFunction::evaluateCall ()\n{\n#if DO_DEBUG\n//    y2debug (\"Y2YCPFunction::evaluateCall (%s)\\n\", toString().c_str());\n#endif\n\n    YFunctionPtr func = (YFunctionPtr)(m_sentry->code());\n\n    // push parameter values for recursion\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tfunc->parameter (p)->push ();\n    }\n\n    // push also local parameters\n    YCodePtr definition = func->definition ();\n\n    if (definition == 0)\n    {\n\tycp2error (\"Function '%s' is only declared, but not defined yet.\", m_sentry->toString().c_str());\n\treturn YCPNull();\n    }\n\n    if (definition->isBlock())\n    {\n//       ((YBlockPtr)definition)->pushToStack ();\n    }\n\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tYCPValue value = m_parameters[p];\n\n\tif (value.isNull())\n\t{\n\t    ycp2error (\"Parameter not specified (%d)\", p);\n\n\t    // cleanup: pop parameter values for recursion\n\t    for (unsigned int p = 0; p < func->parameterCount(); p++)\n\t    {\n\t\tfunc->parameter (p)->pop ();\n\t    }\n\n\t    return value;\n\t}\n\t\n\tSymbolEntryPtr formalp = func->parameter (p);\n#if DO_DEBUG\n\ty2debug (\"formalp (%s) = (%s)\", formalp->toString().c_str(), value->toString().c_str());\n#endif\n\n\tformalp->setValue (value);\n    }\n    \n    extern ExecutionEnvironment ee;\n\n    // save the context info\n    int linenumber = ee.linenumber ();\n    string filename = ee.filename ();\n\n    YCPValue value = definition->evaluate ();\n\n    if (definition->isBlock())\n    {\n       // pop also local parameters\n//       ((YBlockPtr)definition)->popFromStack ();\n    }\n\n    // restore the context info\n    ee.setLinenumber (linenumber);\n    ee.setFilename (filename);\n\n    // pop parameter values for recursion\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tfunc->parameter (p)->pop ();\n    }\n\n#if DO_DEBUG\n    y2debug(\"evaluate done (%s) = '%s'\", definition->toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n    return value;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nY2YCPFunction {\n  YCPValue\n  Y2YCPFunction::evaluateCall ()\n  {\n  #if DO_DEBUG\n  //    y2debug (\"Y2YCPFunction::evaluateCall (%s)\\n\", toString().c_str());\n  #endif\n  \n      YFunctionPtr func = (YFunctionPtr)(m_sentry->code());\n  \n      // push parameter values for recursion\n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tfunc->parameter (p)->push ();\n      }\n  \n      // push also local parameters\n      YCodePtr definition = func->definition ();\n  \n      if (definition == 0)\n      {\n  \tycp2error (\"Function '%s' is only declared, but not defined yet.\", m_sentry->toString().c_str());\n  \treturn YCPNull();\n      }\n  \n      if (definition->isBlock())\n      {\n  //       ((YBlockPtr)definition)->pushToStack ();\n      }\n  \n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tYCPValue value = m_parameters[p];\n  \n  \tif (value.isNull())\n  \t{\n  \t    ycp2error (\"Parameter not specified (%d)\", p);\n  \n  \t    // cleanup: pop parameter values for recursion\n  \t    for (unsigned int p = 0; p < func->parameterCount(); p++)\n  \t    {\n  \t\tfunc->parameter (p)->pop ();\n  \t    }\n  \n  \t    return value;\n  \t}\n  \t\n  \tSymbolEntryPtr formalp = func->parameter (p);\n  #if DO_DEBUG\n  \ty2debug (\"formalp (%s) = (%s)\", formalp->toString().c_str(), value->toString().c_str());\n  #endif\n  \n  \tformalp->setValue (value);\n      }\n      \n      extern ExecutionEnvironment ee;\n  \n      // save the context info\n      int linenumber = ee.linenumber ();\n      string filename = ee.filename ();\n  \n      YCPValue value = definition->evaluate ();\n  \n      if (definition->isBlock())\n      {\n         // pop also local parameters\n  //       ((YBlockPtr)definition)->popFromStack ();\n      }\n  \n      // restore the context info\n      ee.setLinenumber (linenumber);\n      ee.setFilename (filename);\n  \n      // pop parameter values for recursion\n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tfunc->parameter (p)->pop ();\n      }\n  \n  #if DO_DEBUG\n      y2debug(\"evaluate done (%s) = '%s'\", definition->toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.pushframe",
          "args": [
            "(YECallPtr)this",
            "evaluated_params"
          ],
          "line": 3127
        },
        "resolved": true,
        "details": {
          "function_name": "pushframe",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "102-109",
          "snippet": "void\nExecutionEnvironment::pushframe (YECallPtr function, YCPValue m_params[])\n{\n    y2debug (\"Push frame %s\", function->entry()->name());\n    CallFrame* frame = new CallFrame (filename(), linenumber (), function, m_params);\n    m_backtrace.push_back (frame);\n    // backtrace( LOG_MILESTONE, 0 );\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  void\n  ExecutionEnvironment::pushframe (YECallPtr function, YCPValue m_params[])\n  {\n      y2debug (\"Push frame %s\", function->entry()->name());\n      CallFrame* frame = new CallFrame (filename(), linenumber (), function, m_params);\n      m_backtrace.push_back (frame);\n      // backtrace( LOG_MILESTONE, 0 );\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 3124
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Returning nil instead of calling the function.\""
          ],
          "line": 3123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee.endlessRecursion",
          "args": [],
          "line": 3121
        },
        "resolved": true,
        "details": {
          "function_name": "endlessRecursion",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "91-100",
          "snippet": "bool\nExecutionEnvironment::endlessRecursion ()\n{\n    if (m_backtrace.size () == m_recursion_limit)\n    {\n\ty2error (\"Recursion limit of %zd call frames reached. Set the environment variable %s to change this\", m_recursion_limit, Y2RECURSIONLIMIT);\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * Y2RECURSIONLIMIT = \"Y2RECURSIONLIMIT\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nstatic const char * Y2RECURSIONLIMIT = \"Y2RECURSIONLIMIT\";\n\nExecutionEnvironment {\n  bool\n  ExecutionEnvironment::endlessRecursion ()\n  {\n      if (m_backtrace.size () == m_recursion_limit)\n      {\n  \ty2error (\"Recursion limit of %zd call frames reached. Set the environment variable %s to change this\", m_recursion_limit, Y2RECURSIONLIMIT);\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.filename",
          "args": [],
          "line": 3119
        },
        "resolved": true,
        "details": {
          "function_name": "filename",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "335-339",
          "snippet": "string\nScanner::filename () const\n{\n    return m_filename;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  string\n  Scanner::filename () const\n  {\n      return m_filename;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.linenumber",
          "args": [],
          "line": 3118
        },
        "resolved": true,
        "details": {
          "function_name": "linenumber",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "41-45",
          "snippet": "int\nExecutionEnvironment::linenumber () const\n{\n    return m_linenumber;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  int\n  ExecutionEnvironment::linenumber () const\n  {\n      return m_linenumber;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_functioncall->attachParameter",
          "args": [
            "evaluated_params[p]",
            "p"
          ],
          "line": 3112
        },
        "resolved": true,
        "details": {
          "function_name": "attachParameter",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3421-3431",
          "snippet": "bool\nY2YCPFunction::attachParameter (const YCPValue& arg, int pos)\n{\n    if (pos < 0 || pos > ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount () )\n    {\n\ty2error (\"Attaching parameter to function '%s' at incorrect position: %d\", m_sentry->toString().c_str(), pos );\n\treturn false;\n    }\n    m_parameters[pos] = arg;\n    return true;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  bool\n  Y2YCPFunction::attachParameter (const YCPValue& arg, int pos)\n  {\n      if (pos < 0 || pos > ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount () )\n      {\n  \ty2error (\"Attaching parameter to function '%s' at incorrect position: %d\", m_sentry->toString().c_str(), pos );\n  \treturn false;\n      }\n      m_parameters[pos] = arg;\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"parameter %d = (%s)\"",
            "p",
            "value->toString().c_str()"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Parameter eval failed (%s)\"",
            "m_parameters[p]->toString().c_str()"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_parameters[p]->evaluate",
          "args": [],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"failed to reset function call parameters for %s\"",
            "m_sentry->toString ().c_str ()"
          ],
          "line": 3083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_functioncall->reset",
          "args": [],
          "line": 3081
        },
        "resolved": true,
        "details": {
          "function_name": "reset",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3491-3500",
          "snippet": "bool\nY2YCPFunction::reset ()\n{\n    for (int i=0; i<((constFunctionTypePtr)(m_sentry->type ()))->parameterCount (); i++)\n    {\n\tm_parameters[i] = YCPNull ();\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  bool\n  Y2YCPFunction::reset ()\n  {\n      for (int i=0; i<((constFunctionTypePtr)(m_sentry->type ()))->parameterCount (); i++)\n      {\n  \tm_parameters[i] = YCPNull ();\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Cannot create a function call for %s\"",
            "m_sentry->toString ().c_str ()"
          ],
          "line": 3075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<Y2Namespace*>",
          "args": [
            "m_sentry->name ()",
            "m_sentry->type ()"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->type",
          "args": [],
          "line": 3072
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_sentry->name",
          "args": [],
          "line": 3072
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3503-3507",
          "snippet": "string\nY2YCPFunction::name () const\n{\n    return m_sentry->name ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  string\n  Y2YCPFunction::name () const\n  {\n      return m_sentry->name ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<Y2Namespace*>",
          "args": [
            "m_sentry->nameSpace()"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->nameSpace",
          "args": [],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEFunction::evaluate (%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 3062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEFunction {\n  YCPValue\n  YEFunction::evaluate (bool cse)\n  {\n      if (cse)\n      {\n  \treturn YCPNull();\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"YEFunction::evaluate (%s)\\n\", toString().c_str());\n  #endif\n  \n      \n      if (!m_functioncall)\n      {\n  \tm_functioncall = const_cast<Y2Namespace*>(m_sentry->nameSpace())->createFunctionCall (m_sentry->name (), m_sentry->type ());\n  \tif (m_functioncall == 0)\n  \t{\n  \t    y2error (\"Cannot create a function call for %s\", m_sentry->toString ().c_str ());\n  \t    return YCPVoid ();\n          }\n      }\n      else\n      {\n  \tif (! m_functioncall->reset ())\n  \t{\n  \t    y2error (\"failed to reset function call parameters for %s\", m_sentry->toString ().c_str ());\n  \t    return YCPVoid ();\n  \t}\n      }\n      \n      YCPValue evaluated_params [m_next_param_id];\n  \n      for (unsigned int p = 0; p < m_next_param_id ; p++)\n      {\n  \t// FIXME, check for symbol or block type and suppress evaluation\n  \n  \tYCPValue value = m_parameters[p]->evaluate ();\n  \n  \tif (value.isNull())\n  \t{\n  \t    ycp2error (\"Parameter eval failed (%s)\", m_parameters[p]->toString().c_str());\n  \t    return value;\n  \t}\n  \t\n  #if DO_DEBUG\n  \ty2debug (\"parameter %d = (%s)\", p, value->toString().c_str());\n  #endif\n  \n  \tevaluated_params [p] = value;\n      }\n  \n      // set the parameters for Y2Function\n      for (unsigned int p = 0; p < m_next_param_id ; p++)\n      {\n  \tm_functioncall->attachParameter (evaluated_params[p], p);\n      }\n      \n      extern ExecutionEnvironment ee;\n  \n      // save the context info\n      int linenumber = ee.linenumber ();\n      string filename = ee.filename ();\n  \n      if (ee.endlessRecursion ())\n      {\n  \tycp2error (\"Returning nil instead of calling the function.\");\n  \treturn YCPVoid ();\n      }\n  \n      ee.pushframe ((YECallPtr)this, evaluated_params);\n  \n      YCPValue value = m_functioncall->evaluateCall ();\n  \n      // restore the context info\n      ee.setLinenumber (linenumber);\n      ee.setFilename (filename);\n      \n      ee.popframe ();\n  \n  #if DO_DEBUG\n      y2debug(\"evaluate done (%s) = '%s'\", qualifiedName ().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n      return value;\n  }\n}"
  },
  {
    "function_name": "YEFunction",
    "container": "YEFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3045-3054",
    "snippet": "YEFunction::YEFunction (bytecodeistream & str)\n    : YECall (str)\n{\n    m_functioncall = const_cast<Y2Namespace*>(m_sentry->nameSpace())->createFunctionCall (m_sentry->name (), m_sentry->type ());\n    if (m_functioncall == 0)\n    {\n\ty2error (\"Cannot create a function call for %s\", m_sentry->toString ().c_str ());\n\tthrow Bytecode::Invalid();\n    }\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::Invalid",
          "args": [],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Cannot create a function call for %s\"",
            "m_sentry->toString ().c_str ()"
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->toString",
          "args": [],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<Y2Namespace*>",
          "args": [
            "m_sentry->name ()",
            "m_sentry->type ()"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->type",
          "args": [],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_sentry->name",
          "args": [],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3503-3507",
          "snippet": "string\nY2YCPFunction::name () const\n{\n    return m_sentry->name ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  string\n  Y2YCPFunction::name () const\n  {\n      return m_sentry->name ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<Y2Namespace*>",
          "args": [
            "m_sentry->nameSpace()"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->nameSpace",
          "args": [],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEFunction {\n  YEFunction::YEFunction (bytecodeistream & str)\n      : YECall (str)\n  {\n      m_functioncall = const_cast<Y2Namespace*>(m_sentry->nameSpace())->createFunctionCall (m_sentry->name (), m_sentry->type ());\n      if (m_functioncall == 0)\n      {\n  \ty2error (\"Cannot create a function call for %s\", m_sentry->toString ().c_str ());\n  \tthrow Bytecode::Invalid();\n      }\n  }\n}"
  },
  {
    "function_name": "YEFunction",
    "container": "YEFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3036-3042",
    "snippet": "YEFunction::YEFunction (TableEntry* entry)\n    : YECall (entry)\n{\n#if DO_DEBUG\n    y2debug (\"YEFunction[%p] (%s)\", this, entry ? entry->sentry()->toString().c_str() : \"nil\");\n#endif\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEFunction[%p] (%s)\"",
            "this",
            "entry ? entry->sentry()->toString().c_str() : \"nil\""
          ],
          "line": 3040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry->sentry",
          "args": [],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "sentry",
          "container": "TableEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "97-101",
          "snippet": "SymbolEntryPtr \nTableEntry::sentry() const\n{\n    return m_entry;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  SymbolEntryPtr \n  TableEntry::sentry() const\n  {\n      return m_entry;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEFunction {\n  YEFunction::YEFunction (TableEntry* entry)\n      : YECall (entry)\n  {\n  #if DO_DEBUG\n      y2debug (\"YEFunction[%p] (%s)\", this, entry ? entry->sentry()->toString().c_str() : \"nil\");\n  #endif\n  }\n}"
  },
  {
    "function_name": "qualifiedName",
    "container": "YECall",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3024-3031",
    "snippet": "string\nYECall::qualifiedName () const\n{\n    string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n\t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n\t\"\";\n    return n + m_sentry->name ();\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_sentry->name",
          "args": [],
          "line": 3030
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3503-3507",
          "snippet": "string\nY2YCPFunction::name () const\n{\n    return m_sentry->name ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  string\n  Y2YCPFunction::name () const\n  {\n      return m_sentry->name ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"::\""
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_sentry->nameSpace",
          "args": [],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->nameSpace",
          "args": [],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->nameSpace",
          "args": [],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->nameSpace",
          "args": [],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->nameSpace",
          "args": [],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->nameSpace",
          "args": [],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  string\n  YECall::qualifiedName () const\n  {\n      string n = m_sentry->nameSpace () && ! m_sentry->nameSpace ()->name ().empty ()?\n  \t(m_sentry->nameSpace ()->name () + string (\"::\")) :\n  \t\"\";\n      return n + m_sentry->name ();\n  }\n}"
  },
  {
    "function_name": "type",
    "container": "YECall",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "3017-3021",
    "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "m_sentry->type ()"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sentry->type",
          "args": [],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YECall",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2956-2976",
    "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_parameters[i]->toString",
          "args": [],
          "line": 2968
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "m_sentry->toString",
          "args": [
            "false"
          ],
          "line": 2962
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "158-232",
          "snippet": "string \nYSymbolEntry::toString (bool with_type) const\n{\n    string s = (with_type && m_global) ? \"global \" : \"\";\n#if DO_DEBUG\n    y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n    y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n#endif\n    switch (m_category)\n    {\n\tcase c_variable:\n\tcase c_reference:\n\tcase c_function:\n#if DO_DEBUG\n\t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n#endif\n\tcase c_builtin:\n\t{\n\t    if (with_type)\n\t    {\n\t\tconstFunctionTypePtr ftype = m_type;\n\t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n\t\tif (m_global\n\t\t    && m_namespace != 0\n\t\t    && !m_namespace->name().empty())\n\t\t{\n\t\t    s += (m_namespace->name() + \"::\");\n\t\t}\n\t\ts += m_name.asString();\n\t\tif ((m_category == c_builtin)\n\t\t    && (m_payload.m_decl != 0))\n\t\t{\n\t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n\t\t}\n\t\telse if ((m_category == c_function)\n\t\t\t && (m_code != 0))\n\t\t{\n\t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n\t\t}\n\t\treturn s;\n\t    }\n\t    else\n\t    {\n\t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n\t\treturn s;\n\t    }\n\t}\n\tbreak;\n\tcase c_typedef:\n\t{\n\t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n\t}\n\tbreak;\n\tcase c_const:\n\t{\n\t    return s + m_type->toString() + \" \" + m_name.asString();\n\t}\n\tbreak;\n\tcase c_namespace:\n\tcase c_self:\n\tcase c_filename:\n\tcase c_predefined:\n\t{\n\t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    return SymbolEntry::toString (with_type);\n\t}\n\tbreak;\n    }\n\n    return \"?SymbolEntry?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\n#define DO_DEBUG 0\n\nYSymbolEntry {\n  string \n  YSymbolEntry::toString (bool with_type) const\n  {\n      string s = (with_type && m_global) ? \"global \" : \"\";\n  #if DO_DEBUG\n      y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n      y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n  #endif\n      switch (m_category)\n      {\n  \tcase c_variable:\n  \tcase c_reference:\n  \tcase c_function:\n  #if DO_DEBUG\n  \t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n  #endif\n  \tcase c_builtin:\n  \t{\n  \t    if (with_type)\n  \t    {\n  \t\tconstFunctionTypePtr ftype = m_type;\n  \t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n  \t\tif (m_global\n  \t\t    && m_namespace != 0\n  \t\t    && !m_namespace->name().empty())\n  \t\t{\n  \t\t    s += (m_namespace->name() + \"::\");\n  \t\t}\n  \t\ts += m_name.asString();\n  \t\tif ((m_category == c_builtin)\n  \t\t    && (m_payload.m_decl != 0))\n  \t\t{\n  \t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n  \t\t}\n  \t\telse if ((m_category == c_function)\n  \t\t\t && (m_code != 0))\n  \t\t{\n  \t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n  \t\t}\n  \t\treturn s;\n  \t    }\n  \t    else\n  \t    {\n  \t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n  \t\treturn s;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase c_typedef:\n  \t{\n  \t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n  \t}\n  \tbreak;\n  \tcase c_const:\n  \t{\n  \t    return s + m_type->toString() + \" \" + m_name.asString();\n  \t}\n  \tbreak;\n  \tcase c_namespace:\n  \tcase c_self:\n  \tcase c_filename:\n  \tcase c_predefined:\n  \t{\n  \t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    return SymbolEntry::toString (with_type);\n  \t}\n  \tbreak;\n      }\n  \n      return \"?SymbolEntry?\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YECall::toString [%p]\"",
            "this"
          ],
          "line": 2960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
  },
  {
    "function_name": "finalize",
    "container": "YECall",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2830-2953",
    "snippet": "constTypePtr\nYECall::finalize()\n{\n    TableEntry* entry = m_entry;\n\n    while (entry)\n    {\n\t// now check the parameters really. if they don't match,\n\t// lookup also the overloaded ones    \n\tSymbolEntryPtr sentry = entry->sentry ();\n\n\t// prepare the overloaded one, if exists\n\tTableEntry* next_overloaded = entry->next_overloaded ();\n\n\t// retrieve function type for formal parameter list\n\tconstFunctionTypePtr ftype = sentry->type();\n\t\n\t// not the correct number of parameters?\n\tif ((int)m_next_param_id != ftype->parameterCount())\n\t{\n\t    // try to continue with the next one\n\t    entry = next_overloaded;\n\t    continue;\n\t}\n    \n\tbool accept = true;\n\t// ok, check whether types match\n\tfor (uint check_count = 0; check_count < m_next_param_id ; check_count++)\n\t{\n\t    constTypePtr expected_type = ftype->parameterType (check_count);\n\t    YCodePtr code = m_parameters[check_count];\n\t    constTypePtr type = m_parameter_types[check_count];\n\t    \n\t    // if the parameter type is block, find out the type for the actual param\n\t    if (expected_type->isBlock ())\n\t    {\n\t\tif (code->isBlock ())\n\t\t{\n\t\t    type = new BlockType(type->isUnspec () ? Type::Void : type);\n\t\t}\n\t    }\n\n#if DO_DEBUG\n\t    y2debug (\"checking parameter %d type: expected '%s', given '%s'\", check_count, expected_type->toString().c_str(), type->toString().c_str());\n#endif\n\n\t    int match = type->match (expected_type);\n\t    if (match < 0)\n\t    {\n#if DO_DEBUG\n\t\ty2debug (\"type mismatch\");\n#endif\n\t\t// type mismatch\n\t\tentry = next_overloaded;\n\t\taccept = false;\n\t\tbreak;\n\t    }\n\n\t    if (expected_type->isReference())\t// function expects a reference\n\t    {\n\t\tif (! code->isReferenceable())\t// but the actual parameter isn't referenceable\n\t\t{\n\t\t    y2debug (\"Can't take reference of '%s'\", code->toString().c_str());\n\t\t    entry = next_overloaded;\n\t\t    accept = false;\n\t\t    break;\n\t\t}\n\t\telse if (match > 0)\n\t\t{\n#if DO_DEBUG\n\t\t    y2debug (\"Can't reference to type propagation '%s' -> '%s'\", type->toString().c_str(), expected_type->toString().c_str());\n#endif\t\t    \n\t\t    entry = next_overloaded;\n\t\t    accept = false;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\t\n\tif (accept)\n\t{\n#if DO_DEBUG\n\t    y2debug (\"Accepting for: %s\", entry->sentry()->toString().c_str());\n#endif\n\t    // adapt the code (add propagation/references if needed)\n\t    for (uint check_count = 0 ; check_count < m_next_param_id; check_count++ )\n\t    {\n\t\tconstTypePtr expected_type = ftype->parameterType (check_count);\n\t\tconstTypePtr type = m_parameters[check_count]->type ();\n\t    \n\t\t// if the parameter type is block, find out the type for the actual param\n\t\tif (expected_type->isBlock ())\n\t\t{\n\t\t    if (m_parameters[check_count]->isBlock ())\n\t\t    {\n\t\t\ttype = new BlockType(type->isUnspec () ? Type::Void : type);\n\t\t    }\n\t\t}\n\n\t\tint match = type->match (expected_type);\n\n\t\tif (expected_type->isReference())\t// function expects a reference\n\t\t{\n\t\t    YEVariablePtr var = (YEVariablePtr)(m_parameters[check_count]);\n\t\t    m_parameters[check_count] = new YEReference (var->entry());\n\t\t}\n\n\t\tif (match > 0)\t\t\t\t// propagation\n\t\t{\n\t\t    m_parameters[check_count] = new YEPropagate (m_parameters[check_count], type, expected_type);\n\t\t}\n\t    }\n\t    \n\t    // update the sentry\n\t    m_entry = entry;\n\t    m_sentry = m_entry->sentry ();\n\n\t    return 0;\n\t}\n    }\n\n    // none was accepted;\n    return Type::Error;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_entry->sentry",
          "args": [],
          "line": 2945
        },
        "resolved": true,
        "details": {
          "function_name": "sentry",
          "container": "TableEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "97-101",
          "snippet": "SymbolEntryPtr \nTableEntry::sentry() const\n{\n    return m_entry;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  SymbolEntryPtr \n  TableEntry::sentry() const\n  {\n      return m_entry;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "var->entry",
          "args": [],
          "line": 2934
        },
        "resolved": true,
        "details": {
          "function_name": "entry",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2749-2753",
          "snippet": "const SymbolEntryPtr \nYECall::entry() const\n{\n    return m_sentry;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  const SymbolEntryPtr \n  YECall::entry() const\n  {\n      return m_sentry;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "m_parameters[check_count]"
          ],
          "line": 2933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected_type->isReference",
          "args": [],
          "line": 2931
        },
        "resolved": true,
        "details": {
          "function_name": "isReference",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "76-76",
          "snippet": "bool YCPValueRep::isReference()\t  const { return valuetype() == YT_REFERENCE; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isReference()\t  const { return valuetype() == YT_REFERENCE; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->match",
          "args": [
            "expected_type"
          ],
          "line": 2929
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1739-1797",
          "snippet": "int\nFunctionType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    int bm = basematch (expected);\n\n    if (bm == 1) return 0;\t\t// any or wildcard match\n\n    if ((bm == 0\n\t    && expected->isFunction()))\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (m_returntype->match (ft->m_returntype) < 0)\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return -1;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return 0;\n\t}\n\n\tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n\tif (!wildcard)\n\t{\n\t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter count mismatch\");\n#endif\n\t\treturn -1;\n\t    }\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > esize\t\t\t// don't check wildcard parameters\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n\t    {\n\t\treturn -1;\n\t    }\n\t}\n\treturn 0;\n    }\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  int\n  FunctionType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      int bm = basematch (expected);\n  \n      if (bm == 1) return 0;\t\t// any or wildcard match\n  \n      if ((bm == 0\n  \t    && expected->isFunction()))\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (m_returntype->match (ft->m_returntype) < 0)\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return -1;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return 0;\n  \t}\n  \n  \tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n  \tif (!wildcard)\n  \t{\n  \t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter count mismatch\");\n  #endif\n  \t\treturn -1;\n  \t    }\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > esize\t\t\t// don't check wildcard parameters\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n  \t    {\n  \t\treturn -1;\n  \t    }\n  \t}\n  \treturn 0;\n      }\n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isUnspec",
          "args": [],
          "line": 2925
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_parameters[check_count]->isBlock",
          "args": [],
          "line": 2923
        },
        "resolved": true,
        "details": {
          "function_name": "isBlock",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "73-77",
          "snippet": "bool\nYBreakpoint::isBlock () const\n{\n    return m_code->isBlock();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  bool\n  YBreakpoint::isBlock () const\n  {\n      return m_code->isBlock();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_parameters[check_count]->type",
          "args": [],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftype->parameterType",
          "args": [
            "check_count"
          ],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "parameterType",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1675-1683",
          "snippet": "constTypePtr\nFunctionType::parameterType (unsigned int parameter_number) const\n{\n    if (!m_arguments)\n    {\n\treturn Type::Error;\n    }\n    return m_arguments->parameterType (parameter_number);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nFunctionType {\n  constTypePtr\n  FunctionType::parameterType (unsigned int parameter_number) const\n  {\n      if (!m_arguments)\n      {\n  \treturn Type::Error;\n      }\n      return m_arguments->parameterType (parameter_number);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Accepting for: %s\"",
            "entry->sentry()->toString().c_str()"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Can't reference to type propagation '%s' -> '%s'\"",
            "type->toString().c_str()",
            "expected_type->toString().c_str()"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected_type->toString",
          "args": [],
          "line": 2900
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Can't take reference of '%s'\"",
            "code->toString().c_str()"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "code->isReferenceable",
          "args": [],
          "line": 2890
        },
        "resolved": true,
        "details": {
          "function_name": "isReferenceable",
          "container": "YEVariable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YExpression.h",
          "lines": "72-72",
          "snippet": "virtual bool isReferenceable () const { return true; }",
          "includes": [
            "#include \"y2/Y2Function.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2Function.h\"\n#include \"ycp/YCode.h\"\n#include <string>\n#include <iosfwd>\n\nYEVariable {\n  virtual bool isReferenceable () const { return true; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"type mismatch\""
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"checking parameter %d type: expected '%s', given '%s'\"",
            "check_count",
            "expected_type->toString().c_str()",
            "type->toString().c_str()"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftype->parameterCount",
          "args": [],
          "line": 2848
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry->next_overloaded",
          "args": [],
          "line": 2842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  constTypePtr\n  YECall::finalize()\n  {\n      TableEntry* entry = m_entry;\n  \n      while (entry)\n      {\n  \t// now check the parameters really. if they don't match,\n  \t// lookup also the overloaded ones    \n  \tSymbolEntryPtr sentry = entry->sentry ();\n  \n  \t// prepare the overloaded one, if exists\n  \tTableEntry* next_overloaded = entry->next_overloaded ();\n  \n  \t// retrieve function type for formal parameter list\n  \tconstFunctionTypePtr ftype = sentry->type();\n  \t\n  \t// not the correct number of parameters?\n  \tif ((int)m_next_param_id != ftype->parameterCount())\n  \t{\n  \t    // try to continue with the next one\n  \t    entry = next_overloaded;\n  \t    continue;\n  \t}\n      \n  \tbool accept = true;\n  \t// ok, check whether types match\n  \tfor (uint check_count = 0; check_count < m_next_param_id ; check_count++)\n  \t{\n  \t    constTypePtr expected_type = ftype->parameterType (check_count);\n  \t    YCodePtr code = m_parameters[check_count];\n  \t    constTypePtr type = m_parameter_types[check_count];\n  \t    \n  \t    // if the parameter type is block, find out the type for the actual param\n  \t    if (expected_type->isBlock ())\n  \t    {\n  \t\tif (code->isBlock ())\n  \t\t{\n  \t\t    type = new BlockType(type->isUnspec () ? Type::Void : type);\n  \t\t}\n  \t    }\n  \n  #if DO_DEBUG\n  \t    y2debug (\"checking parameter %d type: expected '%s', given '%s'\", check_count, expected_type->toString().c_str(), type->toString().c_str());\n  #endif\n  \n  \t    int match = type->match (expected_type);\n  \t    if (match < 0)\n  \t    {\n  #if DO_DEBUG\n  \t\ty2debug (\"type mismatch\");\n  #endif\n  \t\t// type mismatch\n  \t\tentry = next_overloaded;\n  \t\taccept = false;\n  \t\tbreak;\n  \t    }\n  \n  \t    if (expected_type->isReference())\t// function expects a reference\n  \t    {\n  \t\tif (! code->isReferenceable())\t// but the actual parameter isn't referenceable\n  \t\t{\n  \t\t    y2debug (\"Can't take reference of '%s'\", code->toString().c_str());\n  \t\t    entry = next_overloaded;\n  \t\t    accept = false;\n  \t\t    break;\n  \t\t}\n  \t\telse if (match > 0)\n  \t\t{\n  #if DO_DEBUG\n  \t\t    y2debug (\"Can't reference to type propagation '%s' -> '%s'\", type->toString().c_str(), expected_type->toString().c_str());\n  #endif\t\t    \n  \t\t    entry = next_overloaded;\n  \t\t    accept = false;\n  \t\t    break;\n  \t\t}\n  \t    }\n  \t}\n  \t\n  \tif (accept)\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"Accepting for: %s\", entry->sentry()->toString().c_str());\n  #endif\n  \t    // adapt the code (add propagation/references if needed)\n  \t    for (uint check_count = 0 ; check_count < m_next_param_id; check_count++ )\n  \t    {\n  \t\tconstTypePtr expected_type = ftype->parameterType (check_count);\n  \t\tconstTypePtr type = m_parameters[check_count]->type ();\n  \t    \n  \t\t// if the parameter type is block, find out the type for the actual param\n  \t\tif (expected_type->isBlock ())\n  \t\t{\n  \t\t    if (m_parameters[check_count]->isBlock ())\n  \t\t    {\n  \t\t\ttype = new BlockType(type->isUnspec () ? Type::Void : type);\n  \t\t    }\n  \t\t}\n  \n  \t\tint match = type->match (expected_type);\n  \n  \t\tif (expected_type->isReference())\t// function expects a reference\n  \t\t{\n  \t\t    YEVariablePtr var = (YEVariablePtr)(m_parameters[check_count]);\n  \t\t    m_parameters[check_count] = new YEReference (var->entry());\n  \t\t}\n  \n  \t\tif (match > 0)\t\t\t\t// propagation\n  \t\t{\n  \t\t    m_parameters[check_count] = new YEPropagate (m_parameters[check_count], type, expected_type);\n  \t\t}\n  \t    }\n  \t    \n  \t    // update the sentry\n  \t    m_entry = entry;\n  \t    m_sentry = m_entry->sentry ();\n  \n  \t    return 0;\n  \t}\n      }\n  \n      // none was accepted;\n      return Type::Error;\n  }\n}"
  },
  {
    "function_name": "attachParameter",
    "container": "YECall",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2770-2819",
    "snippet": "constTypePtr\nYECall::attachParameter (YCodePtr code, constTypePtr type)\n{\n#if DO_DEBUG\n    y2debug (\"YECall::attachParameter (%s:%s)\", code ? code->toString().c_str() : \"(NULL)\", type->toString().c_str());\n#endif\n\n    if (code == 0 || code->isError())\n    {\n\treturn Type::Unspec;\n    }\n    \n    // check, if there is not too many of params\n    if ((m_parameters == 0)\n\t|| (m_parameter_types == 0))\n    {\n\t// excessive parameter - we don't expect any\n\treturn Type::Error;\n    }\n    \n    // find next parameter slot to be filled, loop through chain\n    //  of overloaded functions\n\n    uint max = 0;\n    TableEntry* t = m_entry;\n    while (t)\n    {\n        uint curr = ((constFunctionTypePtr)t->sentry ()->type ())->parameterCount ();\n        if (curr > max)\n        {\n            max = curr;\n        }\n\n        t = t->next_overloaded ();\n    }\n    \n    if (m_next_param_id >= max)\n    {\n\treturn Type::Error;\n    }\n\n    m_parameters[m_next_param_id] = code;\n    m_parameter_types[m_next_param_id] = type;\n    m_next_param_id++;\n\n#if DO_DEBUG\n    y2debug (\"done\");\n#endif\n    return 0;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"done\""
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->next_overloaded",
          "args": [],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->sentry",
          "args": [],
          "line": 2797
        },
        "resolved": true,
        "details": {
          "function_name": "sentry",
          "container": "TableEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "97-101",
          "snippet": "SymbolEntryPtr \nTableEntry::sentry() const\n{\n    return m_entry;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  SymbolEntryPtr \n  TableEntry::sentry() const\n  {\n      return m_entry;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "code->isError",
          "args": [],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "isError",
          "container": "YCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "76-80",
          "snippet": "bool\nYCode::isError() const\n{\n    return false; \t\t// TODO unused in practice?\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  bool\n  YCode::isError() const\n  {\n      return false; \t\t// TODO unused in practice?\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YECall::attachParameter (%s:%s)\"",
            "code ? code->toString().c_str() : \"(NULL)\"",
            "type->toString().c_str()"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 2774
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  constTypePtr\n  YECall::attachParameter (YCodePtr code, constTypePtr type)\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::attachParameter (%s:%s)\", code ? code->toString().c_str() : \"(NULL)\", type->toString().c_str());\n  #endif\n  \n      if (code == 0 || code->isError())\n      {\n  \treturn Type::Unspec;\n      }\n      \n      // check, if there is not too many of params\n      if ((m_parameters == 0)\n  \t|| (m_parameter_types == 0))\n      {\n  \t// excessive parameter - we don't expect any\n  \treturn Type::Error;\n      }\n      \n      // find next parameter slot to be filled, loop through chain\n      //  of overloaded functions\n  \n      uint max = 0;\n      TableEntry* t = m_entry;\n      while (t)\n      {\n          uint curr = ((constFunctionTypePtr)t->sentry ()->type ())->parameterCount ();\n          if (curr > max)\n          {\n              max = curr;\n          }\n  \n          t = t->next_overloaded ();\n      }\n      \n      if (m_next_param_id >= max)\n      {\n  \treturn Type::Error;\n      }\n  \n      m_parameters[m_next_param_id] = code;\n      m_parameter_types[m_next_param_id] = type;\n      m_next_param_id++;\n  \n  #if DO_DEBUG\n      y2debug (\"done\");\n  #endif\n      return 0;\n  }\n}"
  },
  {
    "function_name": "entry",
    "container": "YECall",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2749-2753",
    "snippet": "const SymbolEntryPtr \nYECall::entry() const\n{\n    return m_sentry;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  const SymbolEntryPtr \n  YECall::entry() const\n  {\n      return m_sentry;\n  }\n}"
  },
  {
    "function_name": "readCall",
    "container": "YECall",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2700-2745",
    "snippet": "YECallPtr YECall::readCall (bytecodeistream & str)\n{\n    YECallPtr res = 0;\n\n    SymbolEntryPtr sentry = Bytecode::readEntry (str);\n    \n    if (!sentry)\n    {\n\treturn 0;\n    }\n    \n    if (str.isVersion (1,3,2) && sentry->isVariable ())\n    {\n\t// it is a function pointer from SLES9/9.1\n\tres = new YEFunctionPointer (0);\n    }\n    else\n    {\n\t// it is direct function call\n\tres = new YEFunction (0);\n    }\n    \n    res->m_sentry = sentry;\n    \n    // read the parameters\n    u_int32_t count = Bytecode::readInt32 (str);\n    \n    if (count>0)\n    {\n\tres->m_parameters = new YCodePtr[count];\n\n\tfor (uint i = 0 ; i < count; i++)\n\t{\n\t    res->m_parameters[i] = Bytecode::readCode (str);\n\t    if (res->m_parameters[i] == 0)\n\t    {\n\t\ty2error (\"parameter code read failed for %d\", i);\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n    res->m_next_param_id = count;\n\n    return res;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"parameter code read failed for %d\"",
            "i"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 2733
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readInt32",
          "args": [
            "str"
          ],
          "line": 2725
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sentry->isVariable",
          "args": [],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "isVariable",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "298-298",
          "snippet": "bool isVariable () const\t{ return m_kind == VariableT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isVariable () const\t{ return m_kind == VariableT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.isVersion",
          "args": [
            "1",
            "3",
            "2"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "isVersion",
          "container": "xmlcodeistream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Xmlcode.cc",
          "lines": "115-120",
          "snippet": "bool xmlcodeistream::isVersion( int major, int minor, int release)\n{\n    return( major == m_major) \n\t&&( minor == m_minor) \n\t&&( release == m_release);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Xmlcode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Xmlcode.h\"\n\nxmlcodeistream {\n  bool xmlcodeistream::isVersion( int major, int minor, int release)\n  {\n      return( major == m_major) \n  \t&&( minor == m_minor) \n  \t&&( release == m_release);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readEntry",
          "args": [
            "str"
          ],
          "line": 2704
        },
        "resolved": true,
        "details": {
          "function_name": "readEntry",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "762-815",
          "snippet": "SymbolEntryPtr \nBytecode::readEntry (bytecodeistream & str)\n{\n    // read reference to namespaces (namespace_id) symbol table (position)\n    int namespace_id = Bytecode::readInt32 (str);\n    int position = Bytecode::readInt32 (str);\n\n    if (namespace_id == -1)\n    {\n#if DO_DEBUG\n\ty2debug( \"Special entry without namespace\" );\n#endif\n\t// FIXME: this may be wrong\n\treturn 0;\n    }\n\n    // get namespace pointer and SymbolEntry within namespace\n    const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n    if (name_space == 0)\n    {\n\ty2error (\"invalid namespace %d for entry\", namespace_id);\n\treturn 0;\n    }\n\n    SymbolEntryPtr sentry;\n    if (position < 0)\t\t\t\t// it's an Xref !\n    {\n\tSymbolTable *table = name_space->table();\n\tif (table == 0)\n\t{\n\t    ycp2error (\"No table associated to xref namespace\\n\");\n\t    exit (1);\n\t}\n\tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n#if DO_DEBUG\n\ty2debug (\"get reference %d from table %p\", position, table);\n#endif\n\tsentry = table->getXRef(position);\n    }\n    else\n    {\n\tsentry = name_space->symbolEntry (position);\n    }\n\n    if (sentry == 0)\n    {\n\ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n\treturn 0;\n    }\n#if DO_DEBUG\n    y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n#endif\n    return sentry;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  SymbolEntryPtr \n  Bytecode::readEntry (bytecodeistream & str)\n  {\n      // read reference to namespaces (namespace_id) symbol table (position)\n      int namespace_id = Bytecode::readInt32 (str);\n      int position = Bytecode::readInt32 (str);\n  \n      if (namespace_id == -1)\n      {\n  #if DO_DEBUG\n  \ty2debug( \"Special entry without namespace\" );\n  #endif\n  \t// FIXME: this may be wrong\n  \treturn 0;\n      }\n  \n      // get namespace pointer and SymbolEntry within namespace\n      const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n      if (name_space == 0)\n      {\n  \ty2error (\"invalid namespace %d for entry\", namespace_id);\n  \treturn 0;\n      }\n  \n      SymbolEntryPtr sentry;\n      if (position < 0)\t\t\t\t// it's an Xref !\n      {\n  \tSymbolTable *table = name_space->table();\n  \tif (table == 0)\n  \t{\n  \t    ycp2error (\"No table associated to xref namespace\\n\");\n  \t    exit (1);\n  \t}\n  \tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n  #if DO_DEBUG\n  \ty2debug (\"get reference %d from table %p\", position, table);\n  #endif\n  \tsentry = table->getXRef(position);\n      }\n      else\n      {\n  \tsentry = name_space->symbolEntry (position);\n      }\n  \n      if (sentry == 0)\n      {\n  \ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n  \treturn 0;\n      }\n  #if DO_DEBUG\n      y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n  #endif\n      return sentry;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  YECallPtr YECall::readCall (bytecodeistream & str)\n  {\n      YECallPtr res = 0;\n  \n      SymbolEntryPtr sentry = Bytecode::readEntry (str);\n      \n      if (!sentry)\n      {\n  \treturn 0;\n      }\n      \n      if (str.isVersion (1,3,2) && sentry->isVariable ())\n      {\n  \t// it is a function pointer from SLES9/9.1\n  \tres = new YEFunctionPointer (0);\n      }\n      else\n      {\n  \t// it is direct function call\n  \tres = new YEFunction (0);\n      }\n      \n      res->m_sentry = sentry;\n      \n      // read the parameters\n      u_int32_t count = Bytecode::readInt32 (str);\n      \n      if (count>0)\n      {\n  \tres->m_parameters = new YCodePtr[count];\n  \n  \tfor (uint i = 0 ; i < count; i++)\n  \t{\n  \t    res->m_parameters[i] = Bytecode::readCode (str);\n  \t    if (res->m_parameters[i] == 0)\n  \t    {\n  \t\ty2error (\"parameter code read failed for %d\", i);\n  \t\treturn 0;\n  \t    }\n  \t}\n      }\n  \n      res->m_next_param_id = count;\n  \n      return res;\n  }\n}"
  },
  {
    "function_name": "~YECall",
    "container": "YECall",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2672-2689",
    "snippet": "YECall::~YECall ()\n{\n    if (m_parameters)\n    {\n\tdelete[] m_parameters;\n    }\n    \n    if (m_parameter_types)\n    {\n\tdelete[] m_parameter_types;\n    }\n\n    if (m_functioncall)\n    {\n\tdelete m_functioncall;\n\tm_functioncall = 0;\n    }\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  YECall::~YECall ()\n  {\n      if (m_parameters)\n      {\n  \tdelete[] m_parameters;\n      }\n      \n      if (m_parameter_types)\n      {\n  \tdelete[] m_parameter_types;\n      }\n  \n      if (m_functioncall)\n      {\n  \tdelete m_functioncall;\n  \tm_functioncall = 0;\n      }\n  }\n}"
  },
  {
    "function_name": "YECall",
    "container": "YECall",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2639-2669",
    "snippet": "YECall::YECall (bytecodeistream & str)\n    : YCode ()\n    , m_entry (0)\n    , m_sentry (Bytecode::readEntry (str))\n    , m_parameters (0)\n    , m_parameter_types (0)\n    , m_functioncall (0)\n    , m_next_param_id (0)\n{\n    u_int32_t count = Bytecode::readInt32 (str);\n    if (count>0)\n    {\n\tm_parameters = new YCodePtr[count];\n\t\n\tfor (uint i = 0 ; i < count; i++)\n\t{\n\t    m_parameters[i] = Bytecode::readCode (str);\n\t    if (m_parameters[i] == 0)\n\t    {\n\t\ty2error (\"parameter code read failed for %d\", i);\n\t\tthrow Bytecode::Invalid();\n\t    }\n\t}\n    }\n    \n    m_next_param_id = count;\n\n#if DO_DEBUG\n    y2debug (\"YECall (fromStream): %s\", toString().c_str());\n#endif\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YECall (fromStream): %s\"",
            "toString().c_str()"
          ],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::Invalid",
          "args": [],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"parameter code read failed for %d\"",
            "i"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readInt32",
          "args": [
            "str"
          ],
          "line": 2648
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readEntry",
          "args": [
            "str"
          ],
          "line": 2642
        },
        "resolved": true,
        "details": {
          "function_name": "readEntry",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "762-815",
          "snippet": "SymbolEntryPtr \nBytecode::readEntry (bytecodeistream & str)\n{\n    // read reference to namespaces (namespace_id) symbol table (position)\n    int namespace_id = Bytecode::readInt32 (str);\n    int position = Bytecode::readInt32 (str);\n\n    if (namespace_id == -1)\n    {\n#if DO_DEBUG\n\ty2debug( \"Special entry without namespace\" );\n#endif\n\t// FIXME: this may be wrong\n\treturn 0;\n    }\n\n    // get namespace pointer and SymbolEntry within namespace\n    const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n    if (name_space == 0)\n    {\n\ty2error (\"invalid namespace %d for entry\", namespace_id);\n\treturn 0;\n    }\n\n    SymbolEntryPtr sentry;\n    if (position < 0)\t\t\t\t// it's an Xref !\n    {\n\tSymbolTable *table = name_space->table();\n\tif (table == 0)\n\t{\n\t    ycp2error (\"No table associated to xref namespace\\n\");\n\t    exit (1);\n\t}\n\tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n#if DO_DEBUG\n\ty2debug (\"get reference %d from table %p\", position, table);\n#endif\n\tsentry = table->getXRef(position);\n    }\n    else\n    {\n\tsentry = name_space->symbolEntry (position);\n    }\n\n    if (sentry == 0)\n    {\n\ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n\treturn 0;\n    }\n#if DO_DEBUG\n    y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n#endif\n    return sentry;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  SymbolEntryPtr \n  Bytecode::readEntry (bytecodeistream & str)\n  {\n      // read reference to namespaces (namespace_id) symbol table (position)\n      int namespace_id = Bytecode::readInt32 (str);\n      int position = Bytecode::readInt32 (str);\n  \n      if (namespace_id == -1)\n      {\n  #if DO_DEBUG\n  \ty2debug( \"Special entry without namespace\" );\n  #endif\n  \t// FIXME: this may be wrong\n  \treturn 0;\n      }\n  \n      // get namespace pointer and SymbolEntry within namespace\n      const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n      if (name_space == 0)\n      {\n  \ty2error (\"invalid namespace %d for entry\", namespace_id);\n  \treturn 0;\n      }\n  \n      SymbolEntryPtr sentry;\n      if (position < 0)\t\t\t\t// it's an Xref !\n      {\n  \tSymbolTable *table = name_space->table();\n  \tif (table == 0)\n  \t{\n  \t    ycp2error (\"No table associated to xref namespace\\n\");\n  \t    exit (1);\n  \t}\n  \tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n  #if DO_DEBUG\n  \ty2debug (\"get reference %d from table %p\", position, table);\n  #endif\n  \tsentry = table->getXRef(position);\n      }\n      else\n      {\n  \tsentry = name_space->symbolEntry (position);\n      }\n  \n      if (sentry == 0)\n      {\n  \ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n  \treturn 0;\n      }\n  #if DO_DEBUG\n      y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n  #endif\n      return sentry;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  YECall::YECall (bytecodeistream & str)\n      : YCode ()\n      , m_entry (0)\n      , m_sentry (Bytecode::readEntry (str))\n      , m_parameters (0)\n      , m_parameter_types (0)\n      , m_functioncall (0)\n      , m_next_param_id (0)\n  {\n      u_int32_t count = Bytecode::readInt32 (str);\n      if (count>0)\n      {\n  \tm_parameters = new YCodePtr[count];\n  \t\n  \tfor (uint i = 0 ; i < count; i++)\n  \t{\n  \t    m_parameters[i] = Bytecode::readCode (str);\n  \t    if (m_parameters[i] == 0)\n  \t    {\n  \t\ty2error (\"parameter code read failed for %d\", i);\n  \t\tthrow Bytecode::Invalid();\n  \t    }\n  \t}\n      }\n      \n      m_next_param_id = count;\n  \n  #if DO_DEBUG\n      y2debug (\"YECall (fromStream): %s\", toString().c_str());\n  #endif\n  }\n}"
  },
  {
    "function_name": "YECall",
    "container": "YECall",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2603-2636",
    "snippet": "YECall::YECall (TableEntry* entry)\n    : YCode ()\n    , m_entry (entry)\n    , m_sentry ( entry ? entry->sentry () : 0)\n    , m_parameters (0)\n    , m_parameter_types (0)\n    , m_functioncall (0)\n{\n#if DO_DEBUG\n    y2debug (\"YECall[%p] (%s)\", this, entry ? entry->sentry()->toString().c_str() : 0);\n#endif\n    // lookup the maximal number of parameters for this entry (and overloads)\n    // retrieve function type for formal parameter list\n    int max = 0;\n    \n    TableEntry* t = entry;\n    while (t)\n    {\n\tint curr = ((constFunctionTypePtr)t->sentry ()->type ())->parameterCount ();\n\tif (curr > max)\n\t{\n\t    max = curr;\n\t}\n\t\n\tt = t->next_overloaded ();\n    }\n    \n    if (max>0)\n    {\n\tm_parameters = new YCodePtr[max];\n\tm_parameter_types = new constTypePtr[max];\n    }\n    m_next_param_id = 0;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->next_overloaded",
          "args": [],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->sentry",
          "args": [],
          "line": 2621
        },
        "resolved": true,
        "details": {
          "function_name": "sentry",
          "container": "TableEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "97-101",
          "snippet": "SymbolEntryPtr \nTableEntry::sentry() const\n{\n    return m_entry;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  SymbolEntryPtr \n  TableEntry::sentry() const\n  {\n      return m_entry;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YECall[%p] (%s)\"",
            "this",
            "entry ? entry->sentry()->toString().c_str() : 0"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  YECall::YECall (TableEntry* entry)\n      : YCode ()\n      , m_entry (entry)\n      , m_sentry ( entry ? entry->sentry () : 0)\n      , m_parameters (0)\n      , m_parameter_types (0)\n      , m_functioncall (0)\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall[%p] (%s)\", this, entry ? entry->sentry()->toString().c_str() : 0);\n  #endif\n      // lookup the maximal number of parameters for this entry (and overloads)\n      // retrieve function type for formal parameter list\n      int max = 0;\n      \n      TableEntry* t = entry;\n      while (t)\n      {\n  \tint curr = ((constFunctionTypePtr)t->sentry ()->type ())->parameterCount ();\n  \tif (curr > max)\n  \t{\n  \t    max = curr;\n  \t}\n  \t\n  \tt = t->next_overloaded ();\n      }\n      \n      if (max>0)\n      {\n  \tm_parameters = new YCodePtr[max];\n  \tm_parameter_types = new constTypePtr[max];\n      }\n      m_next_param_id = 0;\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YEBuiltin",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2416-2597",
    "snippet": "YCPValue\nYEBuiltin::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug (\"YEBuiltin::evaluate [%s:%s]\", YCode::toString (kind()).c_str(), m_decl->name);\n#endif\n\n    if (cse)\n    {\n\treturn YCPNull();\n    }\n\n    // init parameters\n\n    ycodelist_t *actualp = m_parameters;\n    const int maxargs = 10;\n    YCPValue args[maxargs] = { YCPNull(), YCPNull(), YCPNull(), YCPNull(), YCPNull(), YCPNull(), YCPNull(), YCPNull(), YCPNull(), YCPNull() };\n    YCPList list;\n\n    constFunctionTypePtr type = m_decl->type;\n    int typepos = -1; // position of w\n\n    // evaluate parameters\n\n    int i = 0;\n\n    while (i < maxargs)\n    {\n\tif (actualp == 0)\n\t{\n\t    break;\n\t}\n\n#if DO_DEBUG\n\ty2debug (\"actualp ([%d]%s)\", actualp->code->kind(), actualp->code->toString().c_str());\n#endif\n\n\tif (actualp->code->isBlock() || ( (m_decl->flags & DECL_NOEVAL) == DECL_NOEVAL))\n\t    // block as parameter to builtin function or builtin will eval on its own\n\t{\n\t    args[i] = YCPCode (actualp->code);\t// pass as-is\n\t}\n\telse if (actualp->code->kind() == ycEntry)\n\t{\n\t    args[i] = ((YConstPtr)(actualp->code))->value();\n\t}\n\telse\n\t{\n\t    args[i] = actualp->code->evaluate ();\n\t}\n\n\tif ((args[i].isNull() || args[i]->isVoid())\n\t    && ((m_decl->flags & DECL_NIL) == 0))\n\t{\n\t    ycp2error (\"Argument (%s) to %s(...) is nil\", actualp->code->toString().c_str(), m_decl->name);\n\t    return YCPNull ();\n\t}\n\n#if DO_DEBUG\n\ty2debug (\"==> (%s)\", args[i].isNull() ? \"NULL\" : args[i]->toString().c_str());\n#endif\n\n\tif ((typepos < 0)\t\t\t\t\t// not at wildcard yet\n\t    && type->parameterType(i)->isWildcard ())\t\t// at '...' now ?\n\t{\n\t    typepos = i;\n#if DO_DEBUG\n\t    y2debug (\"type '...' %d\", i);\n#endif\n\t}\n\n\tif (typepos >= 0)\t\t\t\t\t// at or beyond '...'\n\t{\n#if DO_DEBUG\n\t    y2debug (\"w! args[%d] = '%s'\", i, args[i].isNull() ? \"nil\" : args[i]->toString().c_str());\n#endif\n\t    list->add (args[i]);\t// Y: add value to list\n\t}\n\ti++;\n\tactualp = actualp->next;\n    }\n\n    // error checking\n\n    if (actualp != 0)\n    {\n\tycp2error (\"More than %d arguments\", maxargs);\n\treturn YCPNull();\n    }\n\n\n    // wildcard checking\n\n    if (typepos >= 0)\n    {\n#if DO_DEBUG\n\ty2debug (\"w! pos %d '%s'\", i, list->toString().c_str());\n#endif\n\ti = typepos+1;\n\targs[i-1] = list;\n    }\n\n\n    // call builtin function\n\n#if DO_DEBUG\n    y2debug (\"YEBuiltin::evaluate [%s (%d args)]\", StaticDeclaration::Decl2String (m_decl, false).c_str(), i);\n    y2debug (\"parameter 1: %s\", i > 0 ? (args[0].isNull() ? \"NULL\" : args[0]->toString().c_str()) : \"nil\" );\n#endif\n    YCPValue ret = YCPNull();\n    if (m_decl->ptr == 0)\n    {\n\treturn ret;\n    }\n\n    if (m_decl->name_space && ( m_decl->name_space->flags & DECL_CALL_HANDLER ) )\n    {\n\t// The bultin belongs to a name space with a special call handler -\n\t// don't simply call the builtin function via m_decl->ptr(),\n\t// call the call handler and pass the builtin function pointer and\n\t// arguments to the call handler\n\tcall_handler_t call_handler = (call_handler_t) m_decl->name_space->ptr;\n\tif (call_handler)\n\t{\n\t    return call_handler (m_decl->ptr, type->parameterCount (), args);\n\t}\n\telse\n\t{\n\t    ycp2error(\"YEBuiltin::evaluate [%s (%d args)]: Call handler declared, but not present\",\n\t\t    StaticDeclaration::Decl2String (m_decl, false).c_str(), i);\n\t    return YCPNull();\n\t}\n    }\n    else\n    {\n\tif (m_parameterblock) m_parameterblock->pushToStack ();\n\t\n\tswitch (type->parameterCount ())\n\t{\n\t    case 0:\n\t\tret = (*(v2)m_decl->ptr) ();\n\t    break;\n\t    case 1:\n\t\tret = (*(v2v)m_decl->ptr) (args[0]);\n\t    break;\n\t    case 2:\n\t\tret = (*(v2vv)m_decl->ptr) (args[0], args[1]);\n\t    break;\n\t    case 3:\n\t\tret = (*(v2vvv)m_decl->ptr) (args[0], args[1], args[2]);\n\t    break;\n\t    case 4:\n\t\tret = (*(v2vvvv)m_decl->ptr) (args[0], args[1], args[2], args[3]);\n\t    break;\n\t    case 5:\n\t\tret = (*(v2vvvvv)m_decl->ptr) (args[0], args[1], args[2], args[3], args[4]);\n\t    break;\n\t    default:\n\t    {\n\t\tycp2error (\"Bad builtin: Arg count %d\", i);\n\t\tret = YCPNull ();\n\t    }\n\t    break;\n\t}\n\tif (m_parameterblock) m_parameterblock->popFromStack ();\n    }\n\n#ifdef BUILTIN_STATISTICS\n    if (!ret.isNull ())\n    {\n\tFILE *fout = fopen (\"/tmp/builtin-use.txt\", \"a\");\n\tfprintf (fout, \"%s %s\\n\", m_decl->name, m_decl->type->toString().c_str());\n\tfclose (fout);\n    }\n#endif\n\n#if DO_DEBUG\n    y2debug (\"YEBuiltin ret (%s)\", ret.isNull() ? \"NULL\" : ret->toString().c_str());\n#endif\n\n    return ret;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEBuiltin ret (%s)\"",
            "ret.isNull() ? \"NULL\" : ret->toString().c_str()"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret->toString",
          "args": [],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ret.isNull",
          "args": [],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fout"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fout",
            "\"%s %s\\n\"",
            "m_decl->name",
            "m_decl->type->toString().c_str()"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/tmp/builtin-use.txt\"",
            "\"a\""
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret.isNull",
          "args": [],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_parameterblock->popFromStack",
          "args": [],
          "line": 2580
        },
        "resolved": true,
        "details": {
          "function_name": "popFromStack",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "267-277",
          "snippet": "void\nY2Namespace::popFromStack ()\n{\n    for (unsigned int p = 0; p < m_symbolcount; p++)\n    {\n\tif ( m_symbols[p] && m_symbols[p]->isVariable() )\n        {\n            m_symbols[p]->pop ();\n        }\n    }\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  void\n  Y2Namespace::popFromStack ()\n  {\n      for (unsigned int p = 0; p < m_symbolcount; p++)\n      {\n  \tif ( m_symbols[p] && m_symbols[p]->isVariable() )\n          {\n              m_symbols[p]->pop ();\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bad builtin: Arg count %d\"",
            "i"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "args[0]",
            "args[1]",
            "args[2]",
            "args[3]",
            "args[4]"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "args[0]",
            "args[1]",
            "args[2]",
            "args[3]"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "args[0]",
            "args[1]",
            "args[2]"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "args[0]",
            "args[1]"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "args[0]"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->parameterCount",
          "args": [],
          "line": 2553
        },
        "resolved": true,
        "details": {
          "function_name": "parameterCount",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1664-1672",
          "snippet": "int\nFunctionType::parameterCount () const\n{\n    if (!m_arguments)\n    {\n\treturn 0;\n    }\n    return m_arguments->parameterCount();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  int\n  FunctionType::parameterCount () const\n  {\n      if (!m_arguments)\n      {\n  \treturn 0;\n      }\n      return m_arguments->parameterCount();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_parameterblock->pushToStack",
          "args": [],
          "line": 2551
        },
        "resolved": true,
        "details": {
          "function_name": "pushToStack",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "254-264",
          "snippet": "void\nY2Namespace::pushToStack ()\n{\n    for (unsigned int p = 0; p < m_symbolcount; p++)\n    {\n\tif ( m_symbols[p] && m_symbols[p]->isVariable() )\n        {\n            m_symbols[p]->push ();\n        }\n    }\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  void\n  Y2Namespace::pushToStack ()\n  {\n      for (unsigned int p = 0; p < m_symbolcount; p++)\n      {\n  \tif ( m_symbols[p] && m_symbols[p]->isVariable() )\n          {\n              m_symbols[p]->push ();\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"YEBuiltin::evaluate [%s (%d args)]: Call handler declared, but not present\"",
            "StaticDeclaration::Decl2String (m_decl, false).c_str()",
            "i"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StaticDeclaration::Decl2String",
          "args": [],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StaticDeclaration::Decl2String",
          "args": [
            "m_decl",
            "false"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "Decl2String",
          "container": "StaticDeclaration",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/StaticDeclaration.cc",
          "lines": "250-272",
          "snippet": "string\nStaticDeclaration::Decl2String (const declaration_t *declaration, bool full)\n{\n    if (declaration == 0)\n    {\n\treturn \"(NULL)\";\n    }\n\n    const declaration_t *name_space = declaration->name_space;\n    const char *name = declaration->name;\n\n    if (!full)\n    {\n\treturn (name_space ? string (name_space->name) + \"::\" + string (name) : string (name));\n    }\n\n    if (name == 0)\n    {\n\treturn \"<NULL>\";\n    }\n\n    return string (name) + \" : \" + declaration->type->toString();\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Import.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include <map>",
            "#include <string>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <unistd.h>\n\nStaticDeclaration {\n  string\n  StaticDeclaration::Decl2String (const declaration_t *declaration, bool full)\n  {\n      if (declaration == 0)\n      {\n  \treturn \"(NULL)\";\n      }\n  \n      const declaration_t *name_space = declaration->name_space;\n      const char *name = declaration->name;\n  \n      if (!full)\n      {\n  \treturn (name_space ? string (name_space->name) + \"::\" + string (name) : string (name));\n      }\n  \n      if (name == 0)\n      {\n  \treturn \"<NULL>\";\n      }\n  \n      return string (name) + \" : \" + declaration->type->toString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_handler",
          "args": [
            "m_decl->ptr",
            "type->parameterCount ()",
            "args"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"parameter 1: %s\"",
            "i > 0 ? (args[0].isNull() ? \"NULL\" : args[0]->toString().c_str()) : \"nil\""
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args[0].isNull",
          "args": [],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEBuiltin::evaluate [%s (%d args)]\"",
            "StaticDeclaration::Decl2String (m_decl, false).c_str()",
            "i"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StaticDeclaration::Decl2String",
          "args": [],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"w! pos %d '%s'\"",
            "i",
            "list->toString().c_str()"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"More than %d arguments\"",
            "maxargs"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list->add",
          "args": [
            "args[i]"
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"w! args[%d] = '%s'\"",
            "i",
            "args[i].isNull() ? \"nil\" : args[i]->toString().c_str()"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args[i].isNull",
          "args": [],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"type '...' %d\"",
            "i"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->parameterType",
          "args": [],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->parameterType",
          "args": [
            "i"
          ],
          "line": 2479
        },
        "resolved": true,
        "details": {
          "function_name": "parameterType",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1675-1683",
          "snippet": "constTypePtr\nFunctionType::parameterType (unsigned int parameter_number) const\n{\n    if (!m_arguments)\n    {\n\treturn Type::Error;\n    }\n    return m_arguments->parameterType (parameter_number);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nconst constTypePtr Type::Error\t\t= TypePtr ( new Type (ErrorT));\n\nFunctionType {\n  constTypePtr\n  FunctionType::parameterType (unsigned int parameter_number) const\n  {\n      if (!m_arguments)\n      {\n  \treturn Type::Error;\n      }\n      return m_arguments->parameterType (parameter_number);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"==> (%s)\"",
            "args[i].isNull() ? \"NULL\" : args[i]->toString().c_str()"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args[i].isNull",
          "args": [],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Argument (%s) to %s(...) is nil\"",
            "actualp->code->toString().c_str()",
            "m_decl->name"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args[i]->isVoid",
          "args": [],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "args[i].isNull",
          "args": [],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "actualp->code->evaluate",
          "args": [],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "actualp->code"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "actualp->code->kind",
          "args": [],
          "line": 2458
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": "YEFunctionPointer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YExpression.h",
          "lines": "499-499",
          "snippet": "virtual ykind kind () const { return yeFunctionPointer; }",
          "includes": [
            "#include \"y2/Y2Function.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2Function.h\"\n#include \"ycp/YCode.h\"\n#include <string>\n#include <iosfwd>\n\nYEFunctionPointer {\n  virtual ykind kind () const { return yeFunctionPointer; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPCode",
          "args": [
            "actualp->code"
          ],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "YCPCode",
          "container": "YCPCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "103-107",
          "snippet": "YCPCode::YCPCode (bytecodeistream & str)\n    : YCPValue (YCPCode())\n{\n    (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPCode {\n  YCPCode::YCPCode (bytecodeistream & str)\n      : YCPValue (YCPCode())\n  {\n      (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "actualp->code->isBlock",
          "args": [],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "isBlock",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "73-77",
          "snippet": "bool\nYBreakpoint::isBlock () const\n{\n    return m_code->isBlock();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  bool\n  YBreakpoint::isBlock () const\n  {\n      return m_code->isBlock();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"actualp ([%d]%s)\"",
            "actualp->code->kind()",
            "actualp->code->toString().c_str()"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEBuiltin::evaluate [%s:%s]\"",
            "YCode::toString (kind()).c_str()",
            "m_decl->name"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCode::toString",
          "args": [
            "kind()"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "104-179",
          "snippet": "string\nYCode::toString (ykind kind)\n{\n    static const char *names[] = {\n\t\"yxError\",\n\t// [1] Constants\t(-> YCPValue, except(!) locale -> yeLocale)\n\t\"ycVoid\", \"ycBoolean\", \"ycInteger\", \"ycFloat\",\t// constants\n\t\"ycString\", \"ycByteblock\", \"ycPath\", \"ycSymbol\",\n\t\"ycList\",\t\t\t\t\t// list\n\t\"ycMap\",\t\t\t\t\t// map\n\t\"ycTerm\",\t\t\t\t\t// term\n\t\"ycEntry\",\n\n\t\"ycConstant\",\t\t// -- placeholder --\n\t\"ycLocale\",\t\t// locale constant (gettext)\n\t\"ycFunction\",\t\t// function definition (declaration and definition)\n\n\t// [16] Expressions\t(-> declaration_t + values)\n\t\"yePropagate\",\t\t// type propagation (value, type)\n\t\"yeUnary\",\t\t// unary (prefix) operator\n\t\"yeBinary\",\t\t// binary (infix) operator\n\t\"yeTriple\",\t\t// <exp> ? <exp> : <exp>\n\t\"yeCompare\",\t\t// compare\n\n\t// [21] Value expressions (-> values + internal)\n\t\"yeLocale\",\t\t// locale expression (ngettext)\n\t\"yeList\",\t\t// list expression\n\t\"yeMap\",\t\t// map expression\n\t\"yeTerm\",\t\t// <name> ( ...)\n\t\"yeIs\",\t\t\t// is()\n\t\"yeBracket\",\t\t// <name> [ <expr>, ... ] : <expr>\n\n\t// [27] Block (-> linked list of statements)\n\t\"yeBlock\",\t\t// block expression\n\t\"yeReturn\",\t\t// quoted expression\n\n\t// [29] Symbolref (-> SymbolEntry)\n\t\"yeVariable\",\t\t// variable ref\n\t\"yeBuiltin\",\t\t// builtin ref + args\n\t\"yeFunction\",\t\t// function ref + args\n\t\"yeReference\",\t\t// reference\n        // SuSE Linux v9.2\n        \"yeFunctionPointer\",      // function pointer\n\n\t\"yeExpression\",\t\t// -- placeholder --\n\n\t// [35] Statements\t(-> YCode + next)\n\t\"ysTypedef\",\t\t// typedef\n\t\"ysVariable\",\t\t// variable definition (-> YSAssign)\n\t\"ysFunction\",\t\t// function definition\n\t\"ysAssign\",\t\t// variable assignment or definition\n\t\"ysBracket\",\t\t// <name> [ <expr>, ... ] = <expr>\n\t\"ysIf\",\t\t\t// if\", then\", else\n\t\"ysWhile\",\t\t// while () do ...\n\t\"ysDo\",\t\t\t// do ... while ()\n\t\"ysRepeat\",\t\t// repeat ... until ()\n\t\"ysExpression\",\t\t// any expression (function call)\n\t\"ysReturn\",\n\t\"ysBreak\",\n\t\"ysContinue\",\n\t\"ysTextdomain\",\n\t\"ysInclude\",\n\t\"ysImport\",\n\t\"ysBlock\",\t\t// a block\n// FIXME ysSwitch is missing\n\t\"ysStatement\"\t\t// -- placeholder --\n    };\n\n    if ((int)kind < 0 || (unsigned int)kind >= (sizeof (names) / sizeof (*names)))\n    {\n\ty2error (\"Bad ykind %d\", kind);\n\treturn \"*** BAD YCode\";\n    }\n    char buf[16]; sprintf (buf, \"[%d]\", kind);\n    return string (buf) + names[kind];\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  string\n  YCode::toString (ykind kind)\n  {\n      static const char *names[] = {\n  \t\"yxError\",\n  \t// [1] Constants\t(-> YCPValue, except(!) locale -> yeLocale)\n  \t\"ycVoid\", \"ycBoolean\", \"ycInteger\", \"ycFloat\",\t// constants\n  \t\"ycString\", \"ycByteblock\", \"ycPath\", \"ycSymbol\",\n  \t\"ycList\",\t\t\t\t\t// list\n  \t\"ycMap\",\t\t\t\t\t// map\n  \t\"ycTerm\",\t\t\t\t\t// term\n  \t\"ycEntry\",\n  \n  \t\"ycConstant\",\t\t// -- placeholder --\n  \t\"ycLocale\",\t\t// locale constant (gettext)\n  \t\"ycFunction\",\t\t// function definition (declaration and definition)\n  \n  \t// [16] Expressions\t(-> declaration_t + values)\n  \t\"yePropagate\",\t\t// type propagation (value, type)\n  \t\"yeUnary\",\t\t// unary (prefix) operator\n  \t\"yeBinary\",\t\t// binary (infix) operator\n  \t\"yeTriple\",\t\t// <exp> ? <exp> : <exp>\n  \t\"yeCompare\",\t\t// compare\n  \n  \t// [21] Value expressions (-> values + internal)\n  \t\"yeLocale\",\t\t// locale expression (ngettext)\n  \t\"yeList\",\t\t// list expression\n  \t\"yeMap\",\t\t// map expression\n  \t\"yeTerm\",\t\t// <name> ( ...)\n  \t\"yeIs\",\t\t\t// is()\n  \t\"yeBracket\",\t\t// <name> [ <expr>, ... ] : <expr>\n  \n  \t// [27] Block (-> linked list of statements)\n  \t\"yeBlock\",\t\t// block expression\n  \t\"yeReturn\",\t\t// quoted expression\n  \n  \t// [29] Symbolref (-> SymbolEntry)\n  \t\"yeVariable\",\t\t// variable ref\n  \t\"yeBuiltin\",\t\t// builtin ref + args\n  \t\"yeFunction\",\t\t// function ref + args\n  \t\"yeReference\",\t\t// reference\n          // SuSE Linux v9.2\n          \"yeFunctionPointer\",      // function pointer\n  \n  \t\"yeExpression\",\t\t// -- placeholder --\n  \n  \t// [35] Statements\t(-> YCode + next)\n  \t\"ysTypedef\",\t\t// typedef\n  \t\"ysVariable\",\t\t// variable definition (-> YSAssign)\n  \t\"ysFunction\",\t\t// function definition\n  \t\"ysAssign\",\t\t// variable assignment or definition\n  \t\"ysBracket\",\t\t// <name> [ <expr>, ... ] = <expr>\n  \t\"ysIf\",\t\t\t// if\", then\", else\n  \t\"ysWhile\",\t\t// while () do ...\n  \t\"ysDo\",\t\t\t// do ... while ()\n  \t\"ysRepeat\",\t\t// repeat ... until ()\n  \t\"ysExpression\",\t\t// any expression (function call)\n  \t\"ysReturn\",\n  \t\"ysBreak\",\n  \t\"ysContinue\",\n  \t\"ysTextdomain\",\n  \t\"ysInclude\",\n  \t\"ysImport\",\n  \t\"ysBlock\",\t\t// a block\n  // FIXME ysSwitch is missing\n  \t\"ysStatement\"\t\t// -- placeholder --\n      };\n  \n      if ((int)kind < 0 || (unsigned int)kind >= (sizeof (names) / sizeof (*names)))\n      {\n  \ty2error (\"Bad ykind %d\", kind);\n  \treturn \"*** BAD YCode\";\n      }\n      char buf[16]; sprintf (buf, \"[%d]\", kind);\n      return string (buf) + names[kind];\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEBuiltin {\n  YCPValue\n  YEBuiltin::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug (\"YEBuiltin::evaluate [%s:%s]\", YCode::toString (kind()).c_str(), m_decl->name);\n  #endif\n  \n      if (cse)\n      {\n  \treturn YCPNull();\n      }\n  \n      // init parameters\n  \n      ycodelist_t *actualp = m_parameters;\n      const int maxargs = 10;\n      YCPValue args[maxargs] = { YCPNull(), YCPNull(), YCPNull(), YCPNull(), YCPNull(), YCPNull(), YCPNull(), YCPNull(), YCPNull(), YCPNull() };\n      YCPList list;\n  \n      constFunctionTypePtr type = m_decl->type;\n      int typepos = -1; // position of w\n  \n      // evaluate parameters\n  \n      int i = 0;\n  \n      while (i < maxargs)\n      {\n  \tif (actualp == 0)\n  \t{\n  \t    break;\n  \t}\n  \n  #if DO_DEBUG\n  \ty2debug (\"actualp ([%d]%s)\", actualp->code->kind(), actualp->code->toString().c_str());\n  #endif\n  \n  \tif (actualp->code->isBlock() || ( (m_decl->flags & DECL_NOEVAL) == DECL_NOEVAL))\n  \t    // block as parameter to builtin function or builtin will eval on its own\n  \t{\n  \t    args[i] = YCPCode (actualp->code);\t// pass as-is\n  \t}\n  \telse if (actualp->code->kind() == ycEntry)\n  \t{\n  \t    args[i] = ((YConstPtr)(actualp->code))->value();\n  \t}\n  \telse\n  \t{\n  \t    args[i] = actualp->code->evaluate ();\n  \t}\n  \n  \tif ((args[i].isNull() || args[i]->isVoid())\n  \t    && ((m_decl->flags & DECL_NIL) == 0))\n  \t{\n  \t    ycp2error (\"Argument (%s) to %s(...) is nil\", actualp->code->toString().c_str(), m_decl->name);\n  \t    return YCPNull ();\n  \t}\n  \n  #if DO_DEBUG\n  \ty2debug (\"==> (%s)\", args[i].isNull() ? \"NULL\" : args[i]->toString().c_str());\n  #endif\n  \n  \tif ((typepos < 0)\t\t\t\t\t// not at wildcard yet\n  \t    && type->parameterType(i)->isWildcard ())\t\t// at '...' now ?\n  \t{\n  \t    typepos = i;\n  #if DO_DEBUG\n  \t    y2debug (\"type '...' %d\", i);\n  #endif\n  \t}\n  \n  \tif (typepos >= 0)\t\t\t\t\t// at or beyond '...'\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"w! args[%d] = '%s'\", i, args[i].isNull() ? \"nil\" : args[i]->toString().c_str());\n  #endif\n  \t    list->add (args[i]);\t// Y: add value to list\n  \t}\n  \ti++;\n  \tactualp = actualp->next;\n      }\n  \n      // error checking\n  \n      if (actualp != 0)\n      {\n  \tycp2error (\"More than %d arguments\", maxargs);\n  \treturn YCPNull();\n      }\n  \n  \n      // wildcard checking\n  \n      if (typepos >= 0)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"w! pos %d '%s'\", i, list->toString().c_str());\n  #endif\n  \ti = typepos+1;\n  \targs[i-1] = list;\n      }\n  \n  \n      // call builtin function\n  \n  #if DO_DEBUG\n      y2debug (\"YEBuiltin::evaluate [%s (%d args)]\", StaticDeclaration::Decl2String (m_decl, false).c_str(), i);\n      y2debug (\"parameter 1: %s\", i > 0 ? (args[0].isNull() ? \"NULL\" : args[0]->toString().c_str()) : \"nil\" );\n  #endif\n      YCPValue ret = YCPNull();\n      if (m_decl->ptr == 0)\n      {\n  \treturn ret;\n      }\n  \n      if (m_decl->name_space && ( m_decl->name_space->flags & DECL_CALL_HANDLER ) )\n      {\n  \t// The bultin belongs to a name space with a special call handler -\n  \t// don't simply call the builtin function via m_decl->ptr(),\n  \t// call the call handler and pass the builtin function pointer and\n  \t// arguments to the call handler\n  \tcall_handler_t call_handler = (call_handler_t) m_decl->name_space->ptr;\n  \tif (call_handler)\n  \t{\n  \t    return call_handler (m_decl->ptr, type->parameterCount (), args);\n  \t}\n  \telse\n  \t{\n  \t    ycp2error(\"YEBuiltin::evaluate [%s (%d args)]: Call handler declared, but not present\",\n  \t\t    StaticDeclaration::Decl2String (m_decl, false).c_str(), i);\n  \t    return YCPNull();\n  \t}\n      }\n      else\n      {\n  \tif (m_parameterblock) m_parameterblock->pushToStack ();\n  \t\n  \tswitch (type->parameterCount ())\n  \t{\n  \t    case 0:\n  \t\tret = (*(v2)m_decl->ptr) ();\n  \t    break;\n  \t    case 1:\n  \t\tret = (*(v2v)m_decl->ptr) (args[0]);\n  \t    break;\n  \t    case 2:\n  \t\tret = (*(v2vv)m_decl->ptr) (args[0], args[1]);\n  \t    break;\n  \t    case 3:\n  \t\tret = (*(v2vvv)m_decl->ptr) (args[0], args[1], args[2]);\n  \t    break;\n  \t    case 4:\n  \t\tret = (*(v2vvvv)m_decl->ptr) (args[0], args[1], args[2], args[3]);\n  \t    break;\n  \t    case 5:\n  \t\tret = (*(v2vvvvv)m_decl->ptr) (args[0], args[1], args[2], args[3], args[4]);\n  \t    break;\n  \t    default:\n  \t    {\n  \t\tycp2error (\"Bad builtin: Arg count %d\", i);\n  \t\tret = YCPNull ();\n  \t    }\n  \t    break;\n  \t}\n  \tif (m_parameterblock) m_parameterblock->popFromStack ();\n      }\n  \n  #ifdef BUILTIN_STATISTICS\n      if (!ret.isNull ())\n      {\n  \tFILE *fout = fopen (\"/tmp/builtin-use.txt\", \"a\");\n  \tfprintf (fout, \"%s %s\\n\", m_decl->name, m_decl->type->toString().c_str());\n  \tfclose (fout);\n      }\n  #endif\n  \n  #if DO_DEBUG\n      y2debug (\"YEBuiltin ret (%s)\", ret.isNull() ? \"NULL\" : ret->toString().c_str());\n  #endif\n  \n      return ret;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YEBuiltin",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2396-2413",
    "snippet": "string\nYEBuiltin::toString() const\n{\n    string s = StaticDeclaration::Decl2String (m_decl) + \" (\";\n\n    ycodelist_t *parm = m_parameters;\n    while (parm)\n    {\n\ts += parm->code->toString();\n\tif (parm->next != 0)\n\t{\n\t    s += \", \";\n\t}\n\tparm = parm->next;\n    }\n    s += \")\";\n    return s;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parm->code->toString",
          "args": [],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "StaticDeclaration::Decl2String",
          "args": [
            "m_decl"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEBuiltin {\n  string\n  YEBuiltin::toString() const\n  {\n      string s = StaticDeclaration::Decl2String (m_decl) + \" (\";\n  \n      ycodelist_t *parm = m_parameters;\n      while (parm)\n      {\n  \ts += parm->code->toString();\n  \tif (parm->next != 0)\n  \t{\n  \t    s += \", \";\n  \t}\n  \tparm = parm->next;\n      }\n      s += \")\";\n      return s;\n  }\n}"
  },
  {
    "function_name": "attachSymVariable",
    "container": "YEBuiltin",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2344-2393",
    "snippet": "constTypePtr\nYEBuiltin::attachSymVariable (const char *name, constTypePtr type, unsigned int line, TableEntry *&tentry)\n{\n    extern StaticDeclaration static_declarations;\n\n    FunctionTypePtr matchedType;\n    constTypePtr addedType;\n\n#if DO_DEBUG\n    y2debug (\"YEBuiltin::attachSymVariable (%s:%s @%d, to %s:%s\", name, type->toString().c_str(), line, m_decl->name, m_type->toString().c_str());\n#endif\n\n    if (type->isUnspec())\t\t\t\t\t\t\t// no type given, might be symbol or untyped variable\n    {\n\t// try with symbol constant first\n\taddedType = Type::Symbol;\n\n\tmatchedType = m_type->clone();\n\tmatchedType->concat (addedType);\n\n\tdeclaration_t *decl = static_declarations.findDeclaration (m_decl, matchedType, true);\n\tif (decl != 0)\n\t{\n#if DO_DEBUG\n\t    y2debug (\"YEBuiltin::attachSymVariable() symbol constant matched\");\n#endif\n\t    return attachParameter (new YConst (YCode::ycSymbol, YCPSymbol (name)), addedType);\n\t}\n\n\t// no match, try with untyped variable\n\ttype = Type::Any;\n\n\textern ExecutionEnvironment ee;\n\tycp2warning (ee.filename().c_str(), ee.linenumber(), \"Parameter '%s' has unspecified type\", name);\n    }\n\n    addedType = VariableTypePtr (new VariableType (type));\t// it's a typed symbolic variable\n\n#if DO_DEBUG\n    y2debug (\"addedType %s\", addedType->toString().c_str());\n#endif\n\n    tentry = m_parameterblock->newEntry (name, SymbolEntry::c_variable, type, line);\n    if (tentry == 0)\n    {\n\treturn Type::Error;\n    }\n\n    return attachParameter (new YConst (ycEntry, YCPEntry (tentry->sentry())), addedType);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "attachParameter",
          "args": [
            "new YConst (ycEntry, YCPEntry (tentry->sentry()))",
            "addedType"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "attachParameter",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3421-3431",
          "snippet": "bool\nY2YCPFunction::attachParameter (const YCPValue& arg, int pos)\n{\n    if (pos < 0 || pos > ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount () )\n    {\n\ty2error (\"Attaching parameter to function '%s' at incorrect position: %d\", m_sentry->toString().c_str(), pos );\n\treturn false;\n    }\n    m_parameters[pos] = arg;\n    return true;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  bool\n  Y2YCPFunction::attachParameter (const YCPValue& arg, int pos)\n  {\n      if (pos < 0 || pos > ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount () )\n      {\n  \ty2error (\"Attaching parameter to function '%s' at incorrect position: %d\", m_sentry->toString().c_str(), pos );\n  \treturn false;\n      }\n      m_parameters[pos] = arg;\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPEntry",
          "args": [
            "tentry->sentry()"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "YCPEntryRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "149-155",
          "snippet": "YCPValue\nYCPEntryRep::evaluate (bool /*cse*/) const\n{\n    y2debug (\"YCPEntryRep::evaluate (%s)\", this->toString().c_str());\n\n    return m_entry->value();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPEntryRep {\n  YCPValue\n  YCPEntryRep::evaluate (bool /*cse*/) const\n  {\n      y2debug (\"YCPEntryRep::evaluate (%s)\", this->toString().c_str());\n  \n      return m_entry->value();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tentry->sentry",
          "args": [],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "sentry",
          "container": "TableEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "97-101",
          "snippet": "SymbolEntryPtr \nTableEntry::sentry() const\n{\n    return m_entry;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\nTableEntry {\n  SymbolEntryPtr \n  TableEntry::sentry() const\n  {\n      return m_entry;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_parameterblock->newEntry",
          "args": [
            "name",
            "SymbolEntry::c_variable",
            "type",
            "line"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"addedType %s\"",
            "addedType->toString().c_str()"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addedType->toString",
          "args": [],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VariableTypePtr",
          "args": [
            "new VariableType (type)"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2warning",
          "args": [
            "ee.filename().c_str()",
            "ee.linenumber()",
            "\"Parameter '%s' has unspecified type\"",
            "name"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee.linenumber",
          "args": [],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "linenumber",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "41-45",
          "snippet": "int\nExecutionEnvironment::linenumber () const\n{\n    return m_linenumber;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  int\n  ExecutionEnvironment::linenumber () const\n  {\n      return m_linenumber;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.filename",
          "args": [],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "filename",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "335-339",
          "snippet": "string\nScanner::filename () const\n{\n    return m_filename;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  string\n  Scanner::filename () const\n  {\n      return m_filename;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPSymbol",
          "args": [
            "name"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "YCPSymbol",
          "container": "YCPSymbol",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "104-107",
          "snippet": "YCPSymbol::YCPSymbol (bytecodeistream & str)\n    : YCPValue (new YCPSymbolRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbol {\n  YCPSymbol::YCPSymbol (bytecodeistream & str)\n      : YCPValue (new YCPSymbolRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEBuiltin::attachSymVariable() symbol constant matched\""
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_declarations.findDeclaration",
          "args": [
            "m_decl",
            "matchedType",
            "true"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "matchedType->concat",
          "args": [
            "addedType"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "concat",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1649-1661",
          "snippet": "void\nFunctionType::concat (constTypePtr t)\n{\n    if (!m_arguments)\n    {\n\tm_arguments = TupleTypePtr (new TupleType (t));\n    }\n    else\n    {\n\tm_arguments->concat (t);\n    }\n    return;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  void\n  FunctionType::concat (constTypePtr t)\n  {\n      if (!m_arguments)\n      {\n  \tm_arguments = TupleTypePtr (new TupleType (t));\n      }\n      else\n      {\n  \tm_arguments->concat (t);\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_type->clone",
          "args": [],
          "line": 2361
        },
        "resolved": true,
        "details": {
          "function_name": "clone",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1842-1854",
          "snippet": "TypePtr\nFunctionType::clone () const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType (index));\n\t}\n    }\n    return tp;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  TypePtr\n  FunctionType::clone () const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType (index));\n  \t}\n      }\n      return tp;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isUnspec",
          "args": [],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEBuiltin::attachSymVariable (%s:%s @%d, to %s:%s\"",
            "name",
            "type->toString().c_str()",
            "line",
            "m_decl->name",
            "m_type->toString().c_str()"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEBuiltin {\n  constTypePtr\n  YEBuiltin::attachSymVariable (const char *name, constTypePtr type, unsigned int line, TableEntry *&tentry)\n  {\n      extern StaticDeclaration static_declarations;\n  \n      FunctionTypePtr matchedType;\n      constTypePtr addedType;\n  \n  #if DO_DEBUG\n      y2debug (\"YEBuiltin::attachSymVariable (%s:%s @%d, to %s:%s\", name, type->toString().c_str(), line, m_decl->name, m_type->toString().c_str());\n  #endif\n  \n      if (type->isUnspec())\t\t\t\t\t\t\t// no type given, might be symbol or untyped variable\n      {\n  \t// try with symbol constant first\n  \taddedType = Type::Symbol;\n  \n  \tmatchedType = m_type->clone();\n  \tmatchedType->concat (addedType);\n  \n  \tdeclaration_t *decl = static_declarations.findDeclaration (m_decl, matchedType, true);\n  \tif (decl != 0)\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"YEBuiltin::attachSymVariable() symbol constant matched\");\n  #endif\n  \t    return attachParameter (new YConst (YCode::ycSymbol, YCPSymbol (name)), addedType);\n  \t}\n  \n  \t// no match, try with untyped variable\n  \ttype = Type::Any;\n  \n  \textern ExecutionEnvironment ee;\n  \tycp2warning (ee.filename().c_str(), ee.linenumber(), \"Parameter '%s' has unspecified type\", name);\n      }\n  \n      addedType = VariableTypePtr (new VariableType (type));\t// it's a typed symbolic variable\n  \n  #if DO_DEBUG\n      y2debug (\"addedType %s\", addedType->toString().c_str());\n  #endif\n  \n      tentry = m_parameterblock->newEntry (name, SymbolEntry::c_variable, type, line);\n      if (tentry == 0)\n      {\n  \treturn Type::Error;\n      }\n  \n      return attachParameter (new YConst (ycEntry, YCPEntry (tentry->sentry())), addedType);\n  }\n}"
  },
  {
    "function_name": "attachParameter",
    "container": "YEBuiltin",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2287-2334",
    "snippet": "constTypePtr\nYEBuiltin::attachParameter (YCodePtr code, constTypePtr type)\n{\n#if DO_DEBUG\n    y2debug (\"YEBuiltin::attachParameter (%s:%s)\", code ? code->toString().c_str() : \"<NULL>\", type->toString().c_str());\n#endif\n\n    if ((code == 0)\n\t|| (code->isError()))\n    {\n\ty2debug (\"Bad code\");\n\treturn Type::Unspec;\n    }\n\n\n    if (!type->isUnspec ())\n    {\n\tFunctionTypePtr ntype = m_type->clone();\n\tntype->concat (type);\n\n#if DO_DEBUG\n\ty2debug (\"YEBuiltin::attachParameter (%s:%s -> '%s')\", type->toString().c_str(), code->toString().c_str(), ntype->toString().c_str());\n#endif\n\tm_type = ntype;\n    }\n#if DO_DEBUG\n    else\n    {\n\ty2debug (\"type '%s' isUnspec\", type->toString().c_str());\n    }\n#endif\n\n    ycodelist_t *element = new ycodelist_t;\n    element->code = code;\n    element->next = 0;\n    if (m_parameters == 0)\n    {\n\tm_parameters = element;\n    }\n    else\n    {\n\tycodelist_t *ptr = m_parameters;\n\twhile (ptr->next != 0) ptr = ptr->next;\n\tptr->next = element;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"type '%s' isUnspec\"",
            "type->toString().c_str()"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->toString",
          "args": [],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEBuiltin::attachParameter (%s:%s -> '%s')\"",
            "type->toString().c_str()",
            "code->toString().c_str()",
            "ntype->toString().c_str()"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntype->concat",
          "args": [
            "type"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "concat",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1649-1661",
          "snippet": "void\nFunctionType::concat (constTypePtr t)\n{\n    if (!m_arguments)\n    {\n\tm_arguments = TupleTypePtr (new TupleType (t));\n    }\n    else\n    {\n\tm_arguments->concat (t);\n    }\n    return;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  void\n  FunctionType::concat (constTypePtr t)\n  {\n      if (!m_arguments)\n      {\n  \tm_arguments = TupleTypePtr (new TupleType (t));\n      }\n      else\n      {\n  \tm_arguments->concat (t);\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_type->clone",
          "args": [],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "clone",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1842-1854",
          "snippet": "TypePtr\nFunctionType::clone () const\n{\n    FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n    if (m_arguments != 0)\n    {\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    tp->concat (m_arguments->parameterType (index));\n\t}\n    }\n    return tp;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  TypePtr\n  FunctionType::clone () const\n  {\n      FunctionTypePtr tp = FunctionTypePtr (new FunctionType (m_returntype));\n      if (m_arguments != 0)\n      {\n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    tp->concat (m_arguments->parameterType (index));\n  \t}\n      }\n      return tp;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type->isUnspec",
          "args": [],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Bad code\""
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "code->isError",
          "args": [],
          "line": 2295
        },
        "resolved": true,
        "details": {
          "function_name": "isError",
          "container": "YCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "76-80",
          "snippet": "bool\nYCode::isError() const\n{\n    return false; \t\t// TODO unused in practice?\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  bool\n  YCode::isError() const\n  {\n      return false; \t\t// TODO unused in practice?\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEBuiltin::attachParameter (%s:%s)\"",
            "code ? code->toString().c_str() : \"<NULL>\"",
            "type->toString().c_str()"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEBuiltin {\n  constTypePtr\n  YEBuiltin::attachParameter (YCodePtr code, constTypePtr type)\n  {\n  #if DO_DEBUG\n      y2debug (\"YEBuiltin::attachParameter (%s:%s)\", code ? code->toString().c_str() : \"<NULL>\", type->toString().c_str());\n  #endif\n  \n      if ((code == 0)\n  \t|| (code->isError()))\n      {\n  \ty2debug (\"Bad code\");\n  \treturn Type::Unspec;\n      }\n  \n  \n      if (!type->isUnspec ())\n      {\n  \tFunctionTypePtr ntype = m_type->clone();\n  \tntype->concat (type);\n  \n  #if DO_DEBUG\n  \ty2debug (\"YEBuiltin::attachParameter (%s:%s -> '%s')\", type->toString().c_str(), code->toString().c_str(), ntype->toString().c_str());\n  #endif\n  \tm_type = ntype;\n      }\n  #if DO_DEBUG\n      else\n      {\n  \ty2debug (\"type '%s' isUnspec\", type->toString().c_str());\n      }\n  #endif\n  \n      ycodelist_t *element = new ycodelist_t;\n      element->code = code;\n      element->next = 0;\n      if (m_parameters == 0)\n      {\n  \tm_parameters = element;\n      }\n      else\n      {\n  \tycodelist_t *ptr = m_parameters;\n  \twhile (ptr->next != 0) ptr = ptr->next;\n  \tptr->next = element;\n      }\n  \n      return 0;\n  }\n}"
  },
  {
    "function_name": "completeType",
    "container": "YEBuiltin",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2269-2273",
    "snippet": "constTypePtr\nYEBuiltin::completeType () const\n{\n    return m_type;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEBuiltin {\n  constTypePtr\n  YEBuiltin::completeType () const\n  {\n      return m_type;\n  }\n}"
  },
  {
    "function_name": "type",
    "container": "YEBuiltin",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2242-2267",
    "snippet": "constTypePtr\nYEBuiltin::type () const\n{\n    constTypePtr ret = m_type->returnType ();\n#if DO_DEBUG\n    y2debug (\"ret '%s' -> %s\", m_type->toString().c_str(), ret->toString().c_str());\n#endif\n\n    if (!ret->isUnspec())\n    {\n\treturn ret;\n    }\n\n    // unfinished YEBuiltin (finalize() not yet called)\n\n    constFunctionTypePtr ft = m_decl->type;\n    if (!ft->isFunction())\n    {\n\treturn Type::Error;\n    }\n#if DO_DEBUG\n    y2debug (\"ret %s\", ft->returnType()->toString().c_str());\n#endif\n\n    return ft->returnType();\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ft->returnType",
          "args": [],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "returnType",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "513-513",
          "snippet": "constTypePtr returnType () const { return m_returntype; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nFunctionType {\n  constTypePtr returnType () const { return m_returntype; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"ret %s\"",
            "ft->returnType()->toString().c_str()"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ft->isFunction",
          "args": [],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "isFunction",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "303-303",
          "snippet": "bool isFunction () const\t{ return m_kind == FunctionT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isFunction () const\t{ return m_kind == FunctionT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ret->isUnspec",
          "args": [],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"ret '%s' -> %s\"",
            "m_type->toString().c_str()",
            "ret->toString().c_str()"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret->toString",
          "args": [],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEBuiltin {\n  constTypePtr\n  YEBuiltin::type () const\n  {\n      constTypePtr ret = m_type->returnType ();\n  #if DO_DEBUG\n      y2debug (\"ret '%s' -> %s\", m_type->toString().c_str(), ret->toString().c_str());\n  #endif\n  \n      if (!ret->isUnspec())\n      {\n  \treturn ret;\n      }\n  \n      // unfinished YEBuiltin (finalize() not yet called)\n  \n      constFunctionTypePtr ft = m_decl->type;\n      if (!ft->isFunction())\n      {\n  \treturn Type::Error;\n      }\n  #if DO_DEBUG\n      y2debug (\"ret %s\", ft->returnType()->toString().c_str());\n  #endif\n  \n      return ft->returnType();\n  }\n}"
  },
  {
    "function_name": "closeParameters",
    "container": "YEBuiltin",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2222-2239",
    "snippet": "void\nYEBuiltin::closeParameters ()\n{\n#if DO_DEBUG\n    y2debug (\"YEBuiltin::closeParameters (m_parameterblock %s)\", m_parameterblock ? \"SET\" : \"CLEAR\");\n#endif\n    if (m_parameterblock != 0)\n    {\n\tif (m_parameterblock->symbolCount() == 0)\n\t{\n#if DO_DEBUG\n\t    y2debug (\"YEBuiltin has no symbolic parameters\");\n#endif\n\t    m_parameterblock = 0;\n\t}\n    }\n\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEBuiltin has no symbolic parameters\""
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_parameterblock->symbolCount",
          "args": [],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "symbolCount",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "69-73",
          "snippet": "unsigned int\nY2Namespace::symbolCount () const\n{\n    return m_symbols.size();\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  unsigned int\n  Y2Namespace::symbolCount () const\n  {\n      return m_symbols.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEBuiltin::closeParameters (m_parameterblock %s)\"",
            "m_parameterblock ? \"SET\" : \"CLEAR\""
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEBuiltin {\n  void\n  YEBuiltin::closeParameters ()\n  {\n  #if DO_DEBUG\n      y2debug (\"YEBuiltin::closeParameters (m_parameterblock %s)\", m_parameterblock ? \"SET\" : \"CLEAR\");\n  #endif\n      if (m_parameterblock != 0)\n      {\n  \tif (m_parameterblock->symbolCount() == 0)\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"YEBuiltin has no symbolic parameters\");\n  #endif\n  \t    m_parameterblock = 0;\n  \t}\n      }\n  \n  }\n}"
  },
  {
    "function_name": "finalize",
    "container": "YEBuiltin",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2057-2216",
    "snippet": "constTypePtr\nYEBuiltin::finalize (Logger* problem_logger)\n{\n    extern StaticDeclaration static_declarations;\n    \n#if DO_DEBUG\n    y2debug (\"YEBuiltin::finalize (%s)\", StaticDeclaration::Decl2String (m_decl, true).c_str());\n    y2debug (\"m_type: %s\", m_type->toString ().c_str());\n#endif\n\n    // final type check for all parameters\n    declaration_t *decl = static_declarations.findDeclaration (m_decl, m_type, false);\n    if (decl == 0)\n    {\n\tStaticDeclaration::errorNoMatch (problem_logger, m_type, m_decl);\n\treturn Type::Error;\n    }\n    m_decl = decl;\t\t\t\t\t// remember matching declaration\n\n#if DO_DEBUG\n    y2debug (\"YEBuiltin::finalize found (%s : %s)\", StaticDeclaration::Decl2String (m_decl, true).c_str(), m_type->toString().c_str());\n#endif\n\n    if (m_decl->flags & DECL_FLEX)\n    {\n\t// expand template type to real type\n\n\tconstTypePtr rtype = Type::determineFlexType (m_type, m_decl->type);\n\tif (rtype == 0)\t\t\t\t\t// error\n\t{\n\t    return m_decl->type;\n\t}\n\telse if (m_type->isFunction()\n\t\t && rtype->isFunction())\n\t{\n\t    constFunctionTypePtr mft = m_type;\n\t    constFunctionTypePtr rft = rtype;\n\t    if (mft->parameters()->match (rft->parameters()) != 0)\t\t//  or realtype does not match actual type\n\t    {\n#if DO_DEBUG\n    y2debug (\"YEBuiltin::finalize (ERR : %s)\", rtype ? rtype->toString().c_str() : \"NULL\");\n#endif\n\t\treturn rtype;\n\t    }\n\t}\n\tm_type = rtype;\n    }\n    else\n    {\n\tm_type = m_decl->type;\n    }\n\n    // function has format string \"%1 ...\" as first arg, check number of %n against number of parameters\n\n    if (m_decl->flags & DECL_FORMATTED)\n    {\n\tYCodePtr formatcode = m_parameters ? m_parameters->code : 0;\n\tif (formatcode == 0)\n\t{\n\t    problem_logger->error (\"First parameter should be format string\");\n\t    return Type::Error;\n\t}\n\n\t// get the argument string\n\n\tconst char *cptr = NULL;\n\tYCPString ystring(\"\");\t\t\t// temporary string, just to keep the reference from going out of scope\n\n\tif (formatcode->kind() == YCode::ycString)\t\t\t// it might be a normal string constant\n\t{\n\t    // keep the reference in ystring\n\t    ystring = formatcode->evaluate()->asString();\n\t    cptr = ystring->value_cstr();\n\t}\n\telse if (formatcode->kind() == YCode::ycLocale)\t\t\t// or a translatable string\n\t{\n\t    // use the untranslated locale string (avoids warning for sformat)\n\t    cptr = ((YLocalePtr)formatcode)->value();\n\t}\n\telse\t\t\t\t\t\t\t\t// any other value we can't check here (defer to runtime checking)\n\t{\n\t    // otherwise accept only strings\n\t    problem_logger->warning (\"Format string is not constant, no parameter checking possible\");\n\t    return 0;\n\t}\n\n\t// save start of cptr, for error message\n\tconst char *cptr_start = cptr;\n\n\t// check %n values and set bits in 'mask' for every n\n\t// dont simply count the number of %n occurences, since they might be duplicate\n\n\tunsigned long long mask = 0;\n\tint bits = sizeof (unsigned long long) * 8;\n\twhile (*cptr != 0)\n\t{\n\t    if (*cptr == '%')\n\t    {\n\t\tcptr++;\n\t\t\n\t\tint number = 0;\n\t\t\n\t\tif ( (*cptr) > '0' && (*cptr) <= '9' )\n\t\t{\n\t\t    number = (*cptr)-'0'; // for more digits use atoi (cptr);\n\t\t}\n\t\tif (number > 0)\n\t\t{\n\t\t    if (number >= bits)\n\t\t    {\n\t\t\tproblem_logger->warning (string (\"Numeric value after % too large (\")\n\t\t\t    + *cptr + \"), cant check validity\");\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tmask |= 1LL << (number - 1);\n\t\t    }\n\t\t}\n\t\telse if ((number == 0)\t\t\t// no digit following %\n\t\t\t && (*cptr != '%'))\t\t// %% is allowed\n\t\t{\n\t\t    problem_logger->error (string(\"Bad '%' selector in format string at '\")\n\t\t\t+ (cptr-1) + \"', use '%n' (n=1,2,...) instead.\");\n\t\t    problem_logger->error (string(\"Full string: '\") + cptr_start + \"'.\");\n\t\t    return Type::Error;\n\t\t}\n\t    }\n\t    cptr++;\n\t}\n\n\t// now count the number of different %n's in the format string\n\n\tint count = 0;\n\twhile (mask != 0)\n\t{\n\t    if (mask & 1) count++;\n\t    mask >>= 1;\n\t}\n\n\t// now check the number of actual parameters\n\n\tycodelist_t *paramptr = m_parameters->next;\t// we already know that at least one parameter (the format string) exists.\n\twhile (paramptr != 0)\n\t{\n\t    count--;\n\t    paramptr = paramptr->next;\n\t}\n\tif (count != 0)\n\t{\n\t    problem_logger->error (\"Format string doesn't match number of parameters\");\n\t    return Type::Error;\n\t}\n    } // if DECL_FORMATTED\n\n#if DO_DEBUG\n    y2debug (\"YEBuiltin::finalize (%s : %s)\", StaticDeclaration::Decl2String (m_decl, true).c_str(), m_type->toString().c_str());\n#endif\n\n    return 0;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEBuiltin::finalize (%s : %s)\"",
            "StaticDeclaration::Decl2String (m_decl, true).c_str()",
            "m_type->toString().c_str()"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_type->toString",
          "args": [],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "StaticDeclaration::Decl2String",
          "args": [],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StaticDeclaration::Decl2String",
          "args": [
            "m_decl",
            "true"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "Decl2String",
          "container": "StaticDeclaration",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/StaticDeclaration.cc",
          "lines": "250-272",
          "snippet": "string\nStaticDeclaration::Decl2String (const declaration_t *declaration, bool full)\n{\n    if (declaration == 0)\n    {\n\treturn \"(NULL)\";\n    }\n\n    const declaration_t *name_space = declaration->name_space;\n    const char *name = declaration->name;\n\n    if (!full)\n    {\n\treturn (name_space ? string (name_space->name) + \"::\" + string (name) : string (name));\n    }\n\n    if (name == 0)\n    {\n\treturn \"<NULL>\";\n    }\n\n    return string (name) + \" : \" + declaration->type->toString();\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Import.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include <map>",
            "#include <string>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <unistd.h>\n\nStaticDeclaration {\n  string\n  StaticDeclaration::Decl2String (const declaration_t *declaration, bool full)\n  {\n      if (declaration == 0)\n      {\n  \treturn \"(NULL)\";\n      }\n  \n      const declaration_t *name_space = declaration->name_space;\n      const char *name = declaration->name;\n  \n      if (!full)\n      {\n  \treturn (name_space ? string (name_space->name) + \"::\" + string (name) : string (name));\n      }\n  \n      if (name == 0)\n      {\n  \treturn \"<NULL>\";\n      }\n  \n      return string (name) + \" : \" + declaration->type->toString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "problem_logger->error",
          "args": [
            "\"Format string doesn't match number of parameters\""
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "292-296",
          "snippet": "void\nScanner::error (string error_message)\n{\n    logError (\"%s\", m_lineNumber, error_message.c_str());\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  void\n  Scanner::error (string error_message)\n  {\n      logError (\"%s\", m_lineNumber, error_message.c_str());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"Full string: '\""
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "problem_logger->warning",
          "args": [
            "string (\"Numeric value after % too large (\")\n\t\t\t    + *cptr + \"), cant check validity\""
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "warning",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "299-303",
          "snippet": "void\nScanner::warning (string warning_message)\n{\n    logWarning (\"%s\", m_lineNumber, warning_message.c_str());\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  void\n  Scanner::warning (string warning_message)\n  {\n      logWarning (\"%s\", m_lineNumber, warning_message.c_str());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "formatcode->kind",
          "args": [],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": "YEFunctionPointer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YExpression.h",
          "lines": "499-499",
          "snippet": "virtual ykind kind () const { return yeFunctionPointer; }",
          "includes": [
            "#include \"y2/Y2Function.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2Function.h\"\n#include \"ycp/YCode.h\"\n#include <string>\n#include <iosfwd>\n\nYEFunctionPointer {\n  virtual ykind kind () const { return yeFunctionPointer; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ystring->value_cstr",
          "args": [],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "formatcode->evaluate",
          "args": [],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "formatcode->evaluate",
          "args": [],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEBuiltin::finalize (ERR : %s)\"",
            "rtype ? rtype->toString().c_str() : \"NULL\""
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mft->parameters",
          "args": [
            "rft->parameters()"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rft->parameters",
          "args": [],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "parameters",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1686-1690",
          "snippet": "constTupleTypePtr\nFunctionType::parameters () const\n{\n    return m_arguments;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  constTupleTypePtr\n  FunctionType::parameters () const\n  {\n      return m_arguments;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtype->isFunction",
          "args": [],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "isFunction",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "303-303",
          "snippet": "bool isFunction () const\t{ return m_kind == FunctionT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isFunction () const\t{ return m_kind == FunctionT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Type::determineFlexType",
          "args": [
            "m_type",
            "m_decl->type"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "determineFlexType",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/TypeStatics.cc",
          "lines": "524-564",
          "snippet": "constTypePtr\nType::determineFlexType (constFunctionTypePtr actual, constFunctionTypePtr declared)\n{\n    y2debug (\"determineFlexType (actual %s, declared %s)\", actual ? actual->toString().c_str() : \"NULL\", declared ? declared->toString().c_str() : \"NULL\");\n\n    // if builtin decl returns 'flex', the parameter deduces the return type\n\n    constTypePtr result;\n\n    if (declared->parameterCount() <= 0)\n    {\n\tycp2error (\"declared->parameterCount() <= 0\");\n\treturn 0;\n    }\n\n    unsigned int flexnumber = 0;\n\n    constTypePtr flextype;\n\n    do\n    {\n\tflextype = declared->matchFlex (actual, flexnumber);\n\n\ty2debug (\"flextype %d:'%s'\", flexnumber, flextype == 0 ? \"NONE\" : flextype->toString().c_str());\n\n\tif (flextype == 0)\n\t{\n\t    result = declared;\n\t}\n\telse\n\t{\n\t    // exchange <flex> with the correct type\n\t    result = declared->unflex (flextype, flexnumber);\n\t    declared = result;\n\t}\n    }\n    while ((flexnumber++ == 0) || (flextype != 0));\n\n    y2debug (\"determineFlexType returns '%s'\", result ? result->toString().c_str() : \"ERROR\");\n    return result;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  constTypePtr\n  Type::determineFlexType (constFunctionTypePtr actual, constFunctionTypePtr declared)\n  {\n      y2debug (\"determineFlexType (actual %s, declared %s)\", actual ? actual->toString().c_str() : \"NULL\", declared ? declared->toString().c_str() : \"NULL\");\n  \n      // if builtin decl returns 'flex', the parameter deduces the return type\n  \n      constTypePtr result;\n  \n      if (declared->parameterCount() <= 0)\n      {\n  \tycp2error (\"declared->parameterCount() <= 0\");\n  \treturn 0;\n      }\n  \n      unsigned int flexnumber = 0;\n  \n      constTypePtr flextype;\n  \n      do\n      {\n  \tflextype = declared->matchFlex (actual, flexnumber);\n  \n  \ty2debug (\"flextype %d:'%s'\", flexnumber, flextype == 0 ? \"NONE\" : flextype->toString().c_str());\n  \n  \tif (flextype == 0)\n  \t{\n  \t    result = declared;\n  \t}\n  \telse\n  \t{\n  \t    // exchange <flex> with the correct type\n  \t    result = declared->unflex (flextype, flexnumber);\n  \t    declared = result;\n  \t}\n      }\n      while ((flexnumber++ == 0) || (flextype != 0));\n  \n      y2debug (\"determineFlexType returns '%s'\", result ? result->toString().c_str() : \"ERROR\");\n      return result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEBuiltin::finalize found (%s : %s)\"",
            "StaticDeclaration::Decl2String (m_decl, true).c_str()",
            "m_type->toString().c_str()"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StaticDeclaration::Decl2String",
          "args": [],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StaticDeclaration::errorNoMatch",
          "args": [
            "problem_logger",
            "m_type",
            "m_decl"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "errorNoMatch",
          "container": "StaticDeclaration",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/StaticDeclaration.cc",
          "lines": "560-578",
          "snippet": "void\nStaticDeclaration::errorNoMatch (Logger* problem_logger, constFunctionTypePtr orig, declaration_t* first_decl)\n{\n    problem_logger->error (string(\"No match for '\")+first_decl->name+\" : \"+orig->toString ()+\"'\");\n    problem_logger->error (\"Please fix parameter types to match one of:\");\n    while (first_decl)\n    {\n        problem_logger->error (string(\"'\")+StaticDeclaration::Decl2String (first_decl,true)+\"'\");\n\n        if (first_decl->tentry->next_overloaded () != 0)\n        {\n            first_decl = ((YSymbolEntryPtr)first_decl->tentry->next_overloaded ()->sentry ())->declaration ();\n        }\n        else\n        {\n\t    return;\n        }\n    }\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Import.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include <map>",
            "#include <string>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <unistd.h>\n\nStaticDeclaration {\n  void\n  StaticDeclaration::errorNoMatch (Logger* problem_logger, constFunctionTypePtr orig, declaration_t* first_decl)\n  {\n      problem_logger->error (string(\"No match for '\")+first_decl->name+\" : \"+orig->toString ()+\"'\");\n      problem_logger->error (\"Please fix parameter types to match one of:\");\n      while (first_decl)\n      {\n          problem_logger->error (string(\"'\")+StaticDeclaration::Decl2String (first_decl,true)+\"'\");\n  \n          if (first_decl->tentry->next_overloaded () != 0)\n          {\n              first_decl = ((YSymbolEntryPtr)first_decl->tentry->next_overloaded ()->sentry ())->declaration ();\n          }\n          else\n          {\n  \t    return;\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_declarations.findDeclaration",
          "args": [
            "m_decl",
            "m_type",
            "false"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"m_type: %s\"",
            "m_type->toString ().c_str()"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEBuiltin::finalize (%s)\"",
            "StaticDeclaration::Decl2String (m_decl, true).c_str()"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StaticDeclaration::Decl2String",
          "args": [],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEBuiltin {\n  constTypePtr\n  YEBuiltin::finalize (Logger* problem_logger)\n  {\n      extern StaticDeclaration static_declarations;\n      \n  #if DO_DEBUG\n      y2debug (\"YEBuiltin::finalize (%s)\", StaticDeclaration::Decl2String (m_decl, true).c_str());\n      y2debug (\"m_type: %s\", m_type->toString ().c_str());\n  #endif\n  \n      // final type check for all parameters\n      declaration_t *decl = static_declarations.findDeclaration (m_decl, m_type, false);\n      if (decl == 0)\n      {\n  \tStaticDeclaration::errorNoMatch (problem_logger, m_type, m_decl);\n  \treturn Type::Error;\n      }\n      m_decl = decl;\t\t\t\t\t// remember matching declaration\n  \n  #if DO_DEBUG\n      y2debug (\"YEBuiltin::finalize found (%s : %s)\", StaticDeclaration::Decl2String (m_decl, true).c_str(), m_type->toString().c_str());\n  #endif\n  \n      if (m_decl->flags & DECL_FLEX)\n      {\n  \t// expand template type to real type\n  \n  \tconstTypePtr rtype = Type::determineFlexType (m_type, m_decl->type);\n  \tif (rtype == 0)\t\t\t\t\t// error\n  \t{\n  \t    return m_decl->type;\n  \t}\n  \telse if (m_type->isFunction()\n  \t\t && rtype->isFunction())\n  \t{\n  \t    constFunctionTypePtr mft = m_type;\n  \t    constFunctionTypePtr rft = rtype;\n  \t    if (mft->parameters()->match (rft->parameters()) != 0)\t\t//  or realtype does not match actual type\n  \t    {\n  #if DO_DEBUG\n      y2debug (\"YEBuiltin::finalize (ERR : %s)\", rtype ? rtype->toString().c_str() : \"NULL\");\n  #endif\n  \t\treturn rtype;\n  \t    }\n  \t}\n  \tm_type = rtype;\n      }\n      else\n      {\n  \tm_type = m_decl->type;\n      }\n  \n      // function has format string \"%1 ...\" as first arg, check number of %n against number of parameters\n  \n      if (m_decl->flags & DECL_FORMATTED)\n      {\n  \tYCodePtr formatcode = m_parameters ? m_parameters->code : 0;\n  \tif (formatcode == 0)\n  \t{\n  \t    problem_logger->error (\"First parameter should be format string\");\n  \t    return Type::Error;\n  \t}\n  \n  \t// get the argument string\n  \n  \tconst char *cptr = NULL;\n  \tYCPString ystring(\"\");\t\t\t// temporary string, just to keep the reference from going out of scope\n  \n  \tif (formatcode->kind() == YCode::ycString)\t\t\t// it might be a normal string constant\n  \t{\n  \t    // keep the reference in ystring\n  \t    ystring = formatcode->evaluate()->asString();\n  \t    cptr = ystring->value_cstr();\n  \t}\n  \telse if (formatcode->kind() == YCode::ycLocale)\t\t\t// or a translatable string\n  \t{\n  \t    // use the untranslated locale string (avoids warning for sformat)\n  \t    cptr = ((YLocalePtr)formatcode)->value();\n  \t}\n  \telse\t\t\t\t\t\t\t\t// any other value we can't check here (defer to runtime checking)\n  \t{\n  \t    // otherwise accept only strings\n  \t    problem_logger->warning (\"Format string is not constant, no parameter checking possible\");\n  \t    return 0;\n  \t}\n  \n  \t// save start of cptr, for error message\n  \tconst char *cptr_start = cptr;\n  \n  \t// check %n values and set bits in 'mask' for every n\n  \t// dont simply count the number of %n occurences, since they might be duplicate\n  \n  \tunsigned long long mask = 0;\n  \tint bits = sizeof (unsigned long long) * 8;\n  \twhile (*cptr != 0)\n  \t{\n  \t    if (*cptr == '%')\n  \t    {\n  \t\tcptr++;\n  \t\t\n  \t\tint number = 0;\n  \t\t\n  \t\tif ( (*cptr) > '0' && (*cptr) <= '9' )\n  \t\t{\n  \t\t    number = (*cptr)-'0'; // for more digits use atoi (cptr);\n  \t\t}\n  \t\tif (number > 0)\n  \t\t{\n  \t\t    if (number >= bits)\n  \t\t    {\n  \t\t\tproblem_logger->warning (string (\"Numeric value after % too large (\")\n  \t\t\t    + *cptr + \"), cant check validity\");\n  \t\t    }\n  \t\t    else\n  \t\t    {\n  \t\t\tmask |= 1LL << (number - 1);\n  \t\t    }\n  \t\t}\n  \t\telse if ((number == 0)\t\t\t// no digit following %\n  \t\t\t && (*cptr != '%'))\t\t// %% is allowed\n  \t\t{\n  \t\t    problem_logger->error (string(\"Bad '%' selector in format string at '\")\n  \t\t\t+ (cptr-1) + \"', use '%n' (n=1,2,...) instead.\");\n  \t\t    problem_logger->error (string(\"Full string: '\") + cptr_start + \"'.\");\n  \t\t    return Type::Error;\n  \t\t}\n  \t    }\n  \t    cptr++;\n  \t}\n  \n  \t// now count the number of different %n's in the format string\n  \n  \tint count = 0;\n  \twhile (mask != 0)\n  \t{\n  \t    if (mask & 1) count++;\n  \t    mask >>= 1;\n  \t}\n  \n  \t// now check the number of actual parameters\n  \n  \tycodelist_t *paramptr = m_parameters->next;\t// we already know that at least one parameter (the format string) exists.\n  \twhile (paramptr != 0)\n  \t{\n  \t    count--;\n  \t    paramptr = paramptr->next;\n  \t}\n  \tif (count != 0)\n  \t{\n  \t    problem_logger->error (\"Format string doesn't match number of parameters\");\n  \t    return Type::Error;\n  \t}\n      } // if DECL_FORMATTED\n  \n  #if DO_DEBUG\n      y2debug (\"YEBuiltin::finalize (%s : %s)\", StaticDeclaration::Decl2String (m_decl, true).c_str(), m_type->toString().c_str());\n  #endif\n  \n      return 0;\n  }\n}"
  },
  {
    "function_name": "parameterBlock",
    "container": "YEBuiltin",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2041-2045",
    "snippet": "YBlockPtr\nYEBuiltin::parameterBlock () const\n{\n    return m_parameterblock;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEBuiltin {\n  YBlockPtr\n  YEBuiltin::parameterBlock () const\n  {\n      return m_parameterblock;\n  }\n}"
  },
  {
    "function_name": "~YEBuiltin",
    "container": "YEBuiltin",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "2022-2031",
    "snippet": "YEBuiltin::~YEBuiltin ()\n{\n    ycodelist_t *parm = m_parameters;\n    while (parm)\n    {\n\tycodelist_t *next = parm->next;\n\tdelete parm;\n\tparm = next;\n    }\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEBuiltin {\n  YEBuiltin::~YEBuiltin ()\n  {\n      ycodelist_t *parm = m_parameters;\n      while (parm)\n      {\n  \tycodelist_t *next = parm->next;\n  \tdelete parm;\n  \tparm = next;\n      }\n  }\n}"
  },
  {
    "function_name": "YEBuiltin",
    "container": "YEBuiltin",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1895-1918",
    "snippet": "YEBuiltin::YEBuiltin (bytecodeistream & str)\n    : YCode ()\n    , m_parameterblock (0)\n    , m_parameters (0)\n{\n    m_type = FunctionTypePtr (Bytecode::readType (str));\n    extern StaticDeclaration static_declarations;\n    m_decl = static_declarations.readDeclaration (str);\n#if DO_DEBUG\n    y2debug (\"YEBuiltin::YEBuiltin(type '%s', decl '%s:%s')\", (m_type == 0) ? \"<NULL>\" : m_type->toString().c_str(), (m_decl == 0) ? \"<NULL>\" : m_decl->name, (m_decl && m_decl->type) ? m_decl->type->toString().c_str() : \"<NULL>\");\n#endif\n    if (Bytecode::readBool (str))\n    {\n\tm_parameterblock = (YBlockPtr)Bytecode::readCode (str);\n\tBytecode::pushNamespace (m_parameterblock->nameSpace());\n    }\n    Bytecode::readYCodelist (str, &m_parameters);\n    if (m_parameterblock != 0)\n    {\n\tBytecode::popNamespace (m_parameterblock->nameSpace());\n    }\n    // throw away type info\n    m_type = Type::Void;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::popNamespace",
          "args": [
            "m_parameterblock->nameSpace()"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "popNamespace",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "650-679",
          "snippet": "int\nBytecode::popNamespace (const Y2Namespace *name_space)\n{\n#if DO_DEBUG\n    y2debug (\"Bytecode::popNamespace (%p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n#endif\n    if (name_space == 0)\n    {\n\ty2error (\"Bytecode::popNamespace (%p) NULL\", name_space);\n\treturn -1;\n    }\n\n    if (m_namespace_nesting_level < m_namespace_tare_level)\n    {\n\ty2error (\"Bytecode::popNamespace (%p) empty stack\", name_space);\n    }\n    else if (m_namespace_nesting_array[m_namespace_nesting_level].name_space != name_space)\n    {\n\ty2error (\"Bytecode::popNamespace (%p) not top of stack [%d]%p\", name_space, m_namespace_nesting_level, m_namespace_nesting_array[m_namespace_nesting_level].name_space);\n    }\n    else\n    {\n\tif (m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs)\n\t{\n\t    name_space->table()->closeXRefs();\n\t}\n\tm_namespace_nesting_level--;\n    }\n    return 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "int Bytecode::m_namespace_nesting_level = -1;",
            "int Bytecode::m_namespace_nesting_array_size = 0;",
            "int Bytecode::m_namespace_tare_level = 0;",
            "Bytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nint Bytecode::m_namespace_nesting_level = -1;\nint Bytecode::m_namespace_nesting_array_size = 0;\nint Bytecode::m_namespace_tare_level = 0;\nBytecode::namespaceentry_t *Bytecode::m_namespace_nesting_array = 0;\n\nBytecode {\n  int\n  Bytecode::popNamespace (const Y2Namespace *name_space)\n  {\n  #if DO_DEBUG\n      y2debug (\"Bytecode::popNamespace (%p), level %d, size %d, tare %d\", name_space, m_namespace_nesting_level, m_namespace_nesting_array_size, m_namespace_tare_level);\n  #endif\n      if (name_space == 0)\n      {\n  \ty2error (\"Bytecode::popNamespace (%p) NULL\", name_space);\n  \treturn -1;\n      }\n  \n      if (m_namespace_nesting_level < m_namespace_tare_level)\n      {\n  \ty2error (\"Bytecode::popNamespace (%p) empty stack\", name_space);\n      }\n      else if (m_namespace_nesting_array[m_namespace_nesting_level].name_space != name_space)\n      {\n  \ty2error (\"Bytecode::popNamespace (%p) not top of stack [%d]%p\", name_space, m_namespace_nesting_level, m_namespace_nesting_array[m_namespace_nesting_level].name_space);\n      }\n      else\n      {\n  \tif (m_namespace_nesting_array[m_namespace_nesting_level].with_xrefs)\n  \t{\n  \t    name_space->table()->closeXRefs();\n  \t}\n  \tm_namespace_nesting_level--;\n      }\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_parameterblock->nameSpace",
          "args": [],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readYCodelist",
          "args": [
            "str",
            "&m_parameters"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "readYCodelist",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "540-578",
          "snippet": "bool\nBytecode::readYCodelist (bytecodeistream & str, ycodelist_t **anchor)\n{\n    u_int32_t count = readInt32 (str);\n\n#if DO_DEBUG\n    y2debug (\"Bytecode::readYCodelist %d entries\", count);\n#endif\n\n    ycodelist_t *last = 0;\n\n    while (count-- > 0)\n    {\n\tycodelist_t *element = new ycodelist_t;\n\n\telement->code = Bytecode::readCode (str);\n\telement->next = 0;\n\n\tif (element->code == 0)\n\t{\n\t    y2error (\"Bytecode::readYCodelist failed\");\n\t    delete element;\n\t    return false;\n\t}\n\n\tif (*anchor == 0)\t\t// anchor undefined\n\t{\n\t    *anchor = element;\n\t}\n\telse\n\t{\n\t    last->next = element;\n\t}\n\n\tlast = element;\n    }\n\n    return str.good();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readYCodelist (bytecodeistream & str, ycodelist_t **anchor)\n  {\n      u_int32_t count = readInt32 (str);\n  \n  #if DO_DEBUG\n      y2debug (\"Bytecode::readYCodelist %d entries\", count);\n  #endif\n  \n      ycodelist_t *last = 0;\n  \n      while (count-- > 0)\n      {\n  \tycodelist_t *element = new ycodelist_t;\n  \n  \telement->code = Bytecode::readCode (str);\n  \telement->next = 0;\n  \n  \tif (element->code == 0)\n  \t{\n  \t    y2error (\"Bytecode::readYCodelist failed\");\n  \t    delete element;\n  \t    return false;\n  \t}\n  \n  \tif (*anchor == 0)\t\t// anchor undefined\n  \t{\n  \t    *anchor = element;\n  \t}\n  \telse\n  \t{\n  \t    last->next = element;\n  \t}\n  \n  \tlast = element;\n      }\n  \n      return str.good();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::pushNamespace",
          "args": [
            "m_parameterblock->nameSpace()"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_parameterblock->nameSpace",
          "args": [],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readBool",
          "args": [
            "str"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "readBool",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "158-172",
          "snippet": "bool\nBytecode::readBool (bytecodeistream & str)\n{\n    char c;\n    str.get (c);\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n#endif\n\n    if (c != 0)\n    {\n\treturn true;\n    }\n    return false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readBool (bytecodeistream & str)\n  {\n      char c;\n      str.get (c);\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readBool 0x%02x\", (unsigned int)c);\n  #endif\n  \n      if (c != 0)\n      {\n  \treturn true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEBuiltin::YEBuiltin(type '%s', decl '%s:%s')\"",
            "(m_type == 0) ? \"<NULL>\" : m_type->toString().c_str()",
            "(m_decl == 0) ? \"<NULL>\" : m_decl->name",
            "(m_decl && m_decl->type) ? m_decl->type->toString().c_str() : \"<NULL>\""
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_decl->type->toString",
          "args": [],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_declarations.readDeclaration",
          "args": [
            "str"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionTypePtr",
          "args": [
            "Bytecode::readType (str)"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readType",
          "args": [
            "str"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "readType",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "349-387",
          "snippet": "TypePtr\nBytecode::readType (bytecodeistream & str)\n{\n    int kind = readInt32 (str);\n#if DO_DEBUG\ny2debug (\"Bytecode::readType(%d)\", kind);\n#endif\n    switch ((Type::tkind)kind)\n    {\n\tcase Type::UnspecT:\n\tcase Type::ErrorT:\n\tcase Type::AnyT:\n\tcase Type::BooleanT:\n\tcase Type::ByteblockT:\n\tcase Type::FloatT:\n\tcase Type::IntegerT:\n\tcase Type::LocaleT:\n\tcase Type::PathT:\n\tcase Type::StringT:\n\tcase Type::SymbolT:\n\tcase Type::TermT:\n\tcase Type::VoidT:\n\tcase Type::WildcardT:\n\tcase Type::FlexT:\n\tcase Type::NilT:\n\t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n\tbreak;\n\n\tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n\tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n\tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n\tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n\tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n\tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n\tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n    }\n    y2error (\"Unhandled type kind %d\", kind);\n    return Type::Error->clone();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  TypePtr\n  Bytecode::readType (bytecodeistream & str)\n  {\n      int kind = readInt32 (str);\n  #if DO_DEBUG\n  y2debug (\"Bytecode::readType(%d)\", kind);\n  #endif\n      switch ((Type::tkind)kind)\n      {\n  \tcase Type::UnspecT:\n  \tcase Type::ErrorT:\n  \tcase Type::AnyT:\n  \tcase Type::BooleanT:\n  \tcase Type::ByteblockT:\n  \tcase Type::FloatT:\n  \tcase Type::IntegerT:\n  \tcase Type::LocaleT:\n  \tcase Type::PathT:\n  \tcase Type::StringT:\n  \tcase Type::SymbolT:\n  \tcase Type::TermT:\n  \tcase Type::VoidT:\n  \tcase Type::WildcardT:\n  \tcase Type::FlexT:\n  \tcase Type::NilT:\n  \t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n  \tbreak;\n  \n  \tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n  \tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n  \tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n  \tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n  \tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n  \tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n  \tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n      }\n      y2error (\"Unhandled type kind %d\", kind);\n      return Type::Error->clone();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEBuiltin {\n  YEBuiltin::YEBuiltin (bytecodeistream & str)\n      : YCode ()\n      , m_parameterblock (0)\n      , m_parameters (0)\n  {\n      m_type = FunctionTypePtr (Bytecode::readType (str));\n      extern StaticDeclaration static_declarations;\n      m_decl = static_declarations.readDeclaration (str);\n  #if DO_DEBUG\n      y2debug (\"YEBuiltin::YEBuiltin(type '%s', decl '%s:%s')\", (m_type == 0) ? \"<NULL>\" : m_type->toString().c_str(), (m_decl == 0) ? \"<NULL>\" : m_decl->name, (m_decl && m_decl->type) ? m_decl->type->toString().c_str() : \"<NULL>\");\n  #endif\n      if (Bytecode::readBool (str))\n      {\n  \tm_parameterblock = (YBlockPtr)Bytecode::readCode (str);\n  \tBytecode::pushNamespace (m_parameterblock->nameSpace());\n      }\n      Bytecode::readYCodelist (str, &m_parameters);\n      if (m_parameterblock != 0)\n      {\n  \tBytecode::popNamespace (m_parameterblock->nameSpace());\n      }\n      // throw away type info\n      m_type = Type::Void;\n  }\n}"
  },
  {
    "function_name": "YEBuiltin",
    "container": "YEBuiltin",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1885-1892",
    "snippet": "YEBuiltin::YEBuiltin (declaration_t *decl, YBlockPtr parameterblock, constTypePtr type)\n    : YCode ()\n    , m_decl (decl)\n    , m_type (type==0 ? Type::Function(Type::Unspec) : (constFunctionTypePtr)type)\n    , m_parameterblock (parameterblock)\n    , m_parameters (0)\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Type::Function",
          "args": [
            "Type::Unspec"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "FunctionType",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1606-1620",
          "snippet": "FunctionType::FunctionType (bytecodeistream & str)\n    : Type (FunctionT, str)\n    , m_returntype (Bytecode::readType (str))\n{\n#if DO_DEBUG\n    y2debug (\"FunctionType::FunctionType (stream)\");\n#endif\n    if (Bytecode::readBool (str))\n    {\n\tm_arguments = Bytecode::readType (str);\n    }\n#if DO_DEBUG\n    y2debug (\"FunctionType::fromStream (m_returntype %p, m_arguments %p)\", (const void *)m_returntype, (const void *)m_arguments);\n#endif\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  FunctionType::FunctionType (bytecodeistream & str)\n      : Type (FunctionT, str)\n      , m_returntype (Bytecode::readType (str))\n  {\n  #if DO_DEBUG\n      y2debug (\"FunctionType::FunctionType (stream)\");\n  #endif\n      if (Bytecode::readBool (str))\n      {\n  \tm_arguments = Bytecode::readType (str);\n      }\n  #if DO_DEBUG\n      y2debug (\"FunctionType::fromStream (m_returntype %p, m_arguments %p)\", (const void *)m_returntype, (const void *)m_arguments);\n  #endif\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEBuiltin {\n  YEBuiltin::YEBuiltin (declaration_t *decl, YBlockPtr parameterblock, constTypePtr type)\n      : YCode ()\n      , m_decl (decl)\n      , m_type (type==0 ? Type::Function(Type::Unspec) : (constFunctionTypePtr)type)\n      , m_parameterblock (parameterblock)\n      , m_parameters (0)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YEBracket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1747-1856",
    "snippet": "YCPValue\nYEBracket::evaluate (bool cse)\n{\n    YCPValue var_value = m_var->evaluate (cse);\n\n    // parse time?\n    if (cse\n\t&& var_value.isNull ())\n    {\n\treturn YCPNull ();\n    }\n\n    if (var_value.isNull()\n\t|| var_value->isVoid())\n    {\n\treturn m_def->evaluate (cse);\n    }\n\n    YCPValue arg_value = m_arg->evaluate (cse);\n\n    // parse time?\n    if (cse\n\t&& arg_value.isNull () )\n    {\n\treturn YCPNull ();\n    }\n\n    if (arg_value.isNull()\n\t|| arg_value->isVoid()\n\t|| !arg_value->isList())\n    {\n\treturn m_def->evaluate (cse);\n    }\n\n    YCPValue result = var_value;\n\n    YCPList indices = arg_value->asList();\n    for (int i = 0; i < indices->size(); ++i) // loop over all bracket indices\n    {\n\tYCPValue v = indices->value(i);\n\tif (v.isNull())\n\t{\n\t    result = YCPNull();\n\t    ycp2error (\"Invalid bracket parameter nil\");\n\t    break;\n\t}\n\telse if (result->isList())\n\t{\n\t    YCPList l = result->asList();\n\t    if (!v->isInteger())\n\t    {\n\t\tresult = YCPNull();\n\t\tycp2error (\"Invalid bracket parameter for list\");\n\t\tbreak;\n\t    }\n\n\t    long long idx = v->asInteger()->value();\n\t    if ((idx < 0)\n\t\t|| (idx >= l->size()))\n\t    {\n\t\tresult = YCPNull();\n\t\tbreak;\n\t    }\n\t    result = l->value (idx);\n\t}\n\telse if (result->isTerm())\n\t{\n\t    YCPTerm t = result->asTerm();\n\t    if (!v->isInteger())\n\t    {\n\t\tresult = YCPNull();\n\t\tycp2error (\"Invalid bracket parameter for term\");\n\t\tbreak;\n\t    }\n\n\t    long long idx = v->asInteger()->value();\n\t    if ((idx < 0)\n\t\t|| (idx >= t->size()))\n\t    {\n\t\tresult = YCPNull();\n\t\tbreak;\n\t    }\n\t    result = t->value (idx);\n\t}\n\telse if (result->isMap())\n\t{\n\t    YCPMap m = result->asMap();\n\t    result = m->value (v);\n\t}\n\telse\n\t{\n\t    ycp2error (\"Bracket expression for '%s' does not evaluate to a list or a map.\", result->toString ().c_str ());\n\t    result = YCPNull();\n\t    break;\n\t}\n\n\tif (result.isNull())\n\t{\n\t    break;\n\t}\n\n    } // while bracket indices\n\n    if (result.isNull())\n    {\n\tresult = m_def->evaluate (cse);\n    }\n\n    return result;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_def->evaluate",
          "args": [
            "cse"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "YEFunctionPointer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3191-3273",
          "snippet": "YCPValue\nYEFunctionPointer::evaluate (bool cse)\n{\n    if (cse)\n    {\n\treturn YCPNull();\n    }\n\n#if DO_DEBUG\n    y2debug (\"YEFunctionPointer::evaluate (%s)\\n\", toString().c_str());\n#endif\n\n    YCPValue ptr = m_sentry->value ();\n    if (ptr.isNull () || ! ptr->isReference ())\n    {\n\tycp2error (\"Function pointer (%s) is %s\"\n\t    , m_sentry->toString().c_str()\n\t    , ptr.isNull () ? \"NULL\" : ptr->toString ().c_str ());\n\treturn YCPVoid ();\n    }\n    \n    SymbolEntryPtr ptr_sentry = ptr->asReference ()->entry ();\n\n    Y2Namespace* ns = const_cast<Y2Namespace*> (ptr_sentry->nameSpace ());\n\n    m_functioncall = ns->createFunctionCall (\n\tptr_sentry->name (),\n\tptr_sentry->type ()\n    );\n    \n    if (!m_functioncall)\n    {\n\ty2internal (\"Cannot get function call object for %s\", m_sentry->toString().c_str());\n\treturn YCPVoid ();\n    }\n\n    // FIXME: this could fail    \n    m_functioncall->reset ();\n    \n    YCPValue m_params [m_next_param_id];\n\n    for (unsigned int p = 0; p < m_next_param_id ; p++)\n    {\n\t// FIXME, check for symbol or block type and suppress evaluation\n\n\tYCPValue value = m_parameters[p]->evaluate ();\n\n\tif (value.isNull())\n\t{\n\t    ycp2error (\"Parameter eval failed (%s)\", m_parameters[p]->toString().c_str());\n\t    return value;\n\t}\n\t\n#if DO_DEBUG\n\ty2debug (\"parameter %d = (%s)\", p, value->toString().c_str());\n#endif\n\n\tm_params [p] = value;\n    }\n\n    // set the parameters for Y2Function\n    for (unsigned int p = 0; p < m_next_param_id ; p++)\n    {\n\tm_functioncall->attachParameter (m_params[p], p);\n    }\n    \n    extern ExecutionEnvironment ee;\n\n    // save the context info\n    int linenumber = ee.linenumber ();\n    string filename = ee.filename ();\n\n    YCPValue value = m_functioncall->evaluateCall ();\n\n    // restore the context info\n    ee.setLinenumber (linenumber);\n    ee.setFilename (filename);\n\n#if DO_DEBUG\n    y2debug(\"evaluate done (%s) = '%s'\", qualifiedName ().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n    return value;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEFunctionPointer {\n  YCPValue\n  YEFunctionPointer::evaluate (bool cse)\n  {\n      if (cse)\n      {\n  \treturn YCPNull();\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"YEFunctionPointer::evaluate (%s)\\n\", toString().c_str());\n  #endif\n  \n      YCPValue ptr = m_sentry->value ();\n      if (ptr.isNull () || ! ptr->isReference ())\n      {\n  \tycp2error (\"Function pointer (%s) is %s\"\n  \t    , m_sentry->toString().c_str()\n  \t    , ptr.isNull () ? \"NULL\" : ptr->toString ().c_str ());\n  \treturn YCPVoid ();\n      }\n      \n      SymbolEntryPtr ptr_sentry = ptr->asReference ()->entry ();\n  \n      Y2Namespace* ns = const_cast<Y2Namespace*> (ptr_sentry->nameSpace ());\n  \n      m_functioncall = ns->createFunctionCall (\n  \tptr_sentry->name (),\n  \tptr_sentry->type ()\n      );\n      \n      if (!m_functioncall)\n      {\n  \ty2internal (\"Cannot get function call object for %s\", m_sentry->toString().c_str());\n  \treturn YCPVoid ();\n      }\n  \n      // FIXME: this could fail    \n      m_functioncall->reset ();\n      \n      YCPValue m_params [m_next_param_id];\n  \n      for (unsigned int p = 0; p < m_next_param_id ; p++)\n      {\n  \t// FIXME, check for symbol or block type and suppress evaluation\n  \n  \tYCPValue value = m_parameters[p]->evaluate ();\n  \n  \tif (value.isNull())\n  \t{\n  \t    ycp2error (\"Parameter eval failed (%s)\", m_parameters[p]->toString().c_str());\n  \t    return value;\n  \t}\n  \t\n  #if DO_DEBUG\n  \ty2debug (\"parameter %d = (%s)\", p, value->toString().c_str());\n  #endif\n  \n  \tm_params [p] = value;\n      }\n  \n      // set the parameters for Y2Function\n      for (unsigned int p = 0; p < m_next_param_id ; p++)\n      {\n  \tm_functioncall->attachParameter (m_params[p], p);\n      }\n      \n      extern ExecutionEnvironment ee;\n  \n      // save the context info\n      int linenumber = ee.linenumber ();\n      string filename = ee.filename ();\n  \n      YCPValue value = m_functioncall->evaluateCall ();\n  \n      // restore the context info\n      ee.setLinenumber (linenumber);\n      ee.setFilename (filename);\n  \n  #if DO_DEBUG\n      y2debug(\"evaluate done (%s) = '%s'\", qualifiedName ().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.isNull",
          "args": [],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.isNull",
          "args": [],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Bracket expression for '%s' does not evaluate to a list or a map.\"",
            "result->toString ().c_str ()"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result->toString",
          "args": [],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->value",
          "args": [
            "v"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YEList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "773-783",
          "snippet": "YCodePtr\nYEList::value (int index) const\n{\n    ycodelist_t *element = m_first;\n    while (element && index)\n    {\n\telement = element->next;\n\tindex--;\n    }\n    return element != NULL ? element->code : NULL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEList {\n  YCodePtr\n  YEList::value (int index) const\n  {\n      ycodelist_t *element = m_first;\n      while (element && index)\n      {\n  \telement = element->next;\n  \tindex--;\n      }\n      return element != NULL ? element->code : NULL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result->asMap",
          "args": [],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result->isMap",
          "args": [],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "71-71",
          "snippet": "bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->size",
          "args": [],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "42-46",
          "snippet": "int\nYCPListRep::size() const\n{\n    return elements.size();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  int\n  YCPListRep::size() const\n  {\n      return elements.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->asInteger",
          "args": [],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "asInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "106-116",
          "snippet": "YCPInteger\nYCPValueRep::asInteger() const\n{\n    if (!isInteger())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPInteger\n  YCPValueRep::asInteger() const\n  {\n      if (!isInteger())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Invalid bracket parameter for term\""
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->isInteger",
          "args": [],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "63-63",
          "snippet": "bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result->asTerm",
          "args": [],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result->isTerm",
          "args": [],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "isTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "70-70",
          "snippet": "bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l->size",
          "args": [],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPByteblockRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPByteblock.cc",
          "lines": "59-63",
          "snippet": "long\nYCPByteblockRep::size() const\n{\n    return len;\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPByteblock.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPByteblock.h\"\n#include <ycp/y2log.h>\n\nYCPByteblockRep {\n  long\n  YCPByteblockRep::size() const\n  {\n      return len;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Invalid bracket parameter for list\""
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result->asList",
          "args": [],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result->isList",
          "args": [],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Invalid bracket parameter nil\""
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indices->size",
          "args": [],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg_value->isVoid",
          "args": [],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg_value.isNull",
          "args": [],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg_value.isNull",
          "args": [],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "var_value.isNull",
          "args": [],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "var_value.isNull",
          "args": [],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEBracket {\n  YCPValue\n  YEBracket::evaluate (bool cse)\n  {\n      YCPValue var_value = m_var->evaluate (cse);\n  \n      // parse time?\n      if (cse\n  \t&& var_value.isNull ())\n      {\n  \treturn YCPNull ();\n      }\n  \n      if (var_value.isNull()\n  \t|| var_value->isVoid())\n      {\n  \treturn m_def->evaluate (cse);\n      }\n  \n      YCPValue arg_value = m_arg->evaluate (cse);\n  \n      // parse time?\n      if (cse\n  \t&& arg_value.isNull () )\n      {\n  \treturn YCPNull ();\n      }\n  \n      if (arg_value.isNull()\n  \t|| arg_value->isVoid()\n  \t|| !arg_value->isList())\n      {\n  \treturn m_def->evaluate (cse);\n      }\n  \n      YCPValue result = var_value;\n  \n      YCPList indices = arg_value->asList();\n      for (int i = 0; i < indices->size(); ++i) // loop over all bracket indices\n      {\n  \tYCPValue v = indices->value(i);\n  \tif (v.isNull())\n  \t{\n  \t    result = YCPNull();\n  \t    ycp2error (\"Invalid bracket parameter nil\");\n  \t    break;\n  \t}\n  \telse if (result->isList())\n  \t{\n  \t    YCPList l = result->asList();\n  \t    if (!v->isInteger())\n  \t    {\n  \t\tresult = YCPNull();\n  \t\tycp2error (\"Invalid bracket parameter for list\");\n  \t\tbreak;\n  \t    }\n  \n  \t    long long idx = v->asInteger()->value();\n  \t    if ((idx < 0)\n  \t\t|| (idx >= l->size()))\n  \t    {\n  \t\tresult = YCPNull();\n  \t\tbreak;\n  \t    }\n  \t    result = l->value (idx);\n  \t}\n  \telse if (result->isTerm())\n  \t{\n  \t    YCPTerm t = result->asTerm();\n  \t    if (!v->isInteger())\n  \t    {\n  \t\tresult = YCPNull();\n  \t\tycp2error (\"Invalid bracket parameter for term\");\n  \t\tbreak;\n  \t    }\n  \n  \t    long long idx = v->asInteger()->value();\n  \t    if ((idx < 0)\n  \t\t|| (idx >= t->size()))\n  \t    {\n  \t\tresult = YCPNull();\n  \t\tbreak;\n  \t    }\n  \t    result = t->value (idx);\n  \t}\n  \telse if (result->isMap())\n  \t{\n  \t    YCPMap m = result->asMap();\n  \t    result = m->value (v);\n  \t}\n  \telse\n  \t{\n  \t    ycp2error (\"Bracket expression for '%s' does not evaluate to a list or a map.\", result->toString ().c_str ());\n  \t    result = YCPNull();\n  \t    break;\n  \t}\n  \n  \tif (result.isNull())\n  \t{\n  \t    break;\n  \t}\n  \n      } // while bracket indices\n  \n      if (result.isNull())\n      {\n  \tresult = m_def->evaluate (cse);\n      }\n  \n      return result;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YEBracket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1737-1744",
    "snippet": "string\nYEBracket::toString () const\n{\n    return m_var->toString()\n\t   + m_arg->toString()\n\t   + string (\":\")\n\t   + m_def->toString();\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_def->toString",
          "args": [],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\":\""
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEBracket {\n  string\n  YEBracket::toString () const\n  {\n      return m_var->toString()\n  \t   + m_arg->toString()\n  \t   + string (\":\")\n  \t   + m_def->toString();\n  }\n}"
  },
  {
    "function_name": "~YEBracket",
    "container": "YEBracket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1732-1734",
    "snippet": "YEBracket::~YEBracket ()\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEBracket {\n  YEBracket::~YEBracket ()\n  {\n  }\n}"
  },
  {
    "function_name": "YEBracket",
    "container": "YEBracket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1720-1729",
    "snippet": "YEBracket::YEBracket (bytecodeistream & str)\n    : YCode ()\n{\n    m_var = Bytecode::readCode (str);\n    m_arg = Bytecode::readCode (str);\n    m_def = Bytecode::readCode (str);\n    // throw away the type info\n    Bytecode::readType (str);\n    m_resultType = Type::Void;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readType",
          "args": [
            "str"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "readType",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "349-387",
          "snippet": "TypePtr\nBytecode::readType (bytecodeistream & str)\n{\n    int kind = readInt32 (str);\n#if DO_DEBUG\ny2debug (\"Bytecode::readType(%d)\", kind);\n#endif\n    switch ((Type::tkind)kind)\n    {\n\tcase Type::UnspecT:\n\tcase Type::ErrorT:\n\tcase Type::AnyT:\n\tcase Type::BooleanT:\n\tcase Type::ByteblockT:\n\tcase Type::FloatT:\n\tcase Type::IntegerT:\n\tcase Type::LocaleT:\n\tcase Type::PathT:\n\tcase Type::StringT:\n\tcase Type::SymbolT:\n\tcase Type::TermT:\n\tcase Type::VoidT:\n\tcase Type::WildcardT:\n\tcase Type::FlexT:\n\tcase Type::NilT:\n\t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n\tbreak;\n\n\tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n\tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n\tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n\tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n\tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n\tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n\tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n    }\n    y2error (\"Unhandled type kind %d\", kind);\n    return Type::Error->clone();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  TypePtr\n  Bytecode::readType (bytecodeistream & str)\n  {\n      int kind = readInt32 (str);\n  #if DO_DEBUG\n  y2debug (\"Bytecode::readType(%d)\", kind);\n  #endif\n      switch ((Type::tkind)kind)\n      {\n  \tcase Type::UnspecT:\n  \tcase Type::ErrorT:\n  \tcase Type::AnyT:\n  \tcase Type::BooleanT:\n  \tcase Type::ByteblockT:\n  \tcase Type::FloatT:\n  \tcase Type::IntegerT:\n  \tcase Type::LocaleT:\n  \tcase Type::PathT:\n  \tcase Type::StringT:\n  \tcase Type::SymbolT:\n  \tcase Type::TermT:\n  \tcase Type::VoidT:\n  \tcase Type::WildcardT:\n  \tcase Type::FlexT:\n  \tcase Type::NilT:\n  \t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n  \tbreak;\n  \n  \tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n  \tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n  \tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n  \tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n  \tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n  \tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n  \tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n      }\n      y2error (\"Unhandled type kind %d\", kind);\n      return Type::Error->clone();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEBracket {\n  YEBracket::YEBracket (bytecodeistream & str)\n      : YCode ()\n  {\n      m_var = Bytecode::readCode (str);\n      m_arg = Bytecode::readCode (str);\n      m_def = Bytecode::readCode (str);\n      // throw away the type info\n      Bytecode::readType (str);\n      m_resultType = Type::Void;\n  }\n}"
  },
  {
    "function_name": "YEBracket",
    "container": "YEBracket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1710-1717",
    "snippet": "YEBracket::YEBracket (YCodePtr var, YCodePtr arg, YCodePtr def, constTypePtr resultType)\n    : YCode ()\n    , m_var (var)\n    , m_arg (arg)\n    , m_def (def)\n    , m_resultType (resultType)\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEBracket {\n  YEBracket::YEBracket (YCodePtr var, YCodePtr arg, YCodePtr def, constTypePtr resultType)\n      : YCode ()\n      , m_var (var)\n      , m_arg (arg)\n      , m_def (def)\n      , m_resultType (resultType)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YEReturn",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1684-1688",
    "snippet": "YCPValue\nYEReturn::evaluate (bool /*cse*/)\n{\n    return YCPCode (m_expr);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPCode",
          "args": [
            "m_expr"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "YCPCode",
          "container": "YCPCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "103-107",
          "snippet": "YCPCode::YCPCode (bytecodeistream & str)\n    : YCPValue (YCPCode())\n{\n    (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPCode {\n  YCPCode::YCPCode (bytecodeistream & str)\n      : YCPValue (YCPCode())\n  {\n      (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEReturn {\n  YCPValue\n  YEReturn::evaluate (bool /*cse*/)\n  {\n      return YCPCode (m_expr);\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YEReturn",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1674-1681",
    "snippet": "string\nYEReturn::toString () const\n{\n    string s = \"{ return \"\n\t+ m_expr->toString()\n\t+ \"; }\";\n    return s;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_expr->toString",
          "args": [],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEReturn {\n  string\n  YEReturn::toString () const\n  {\n      string s = \"{ return \"\n  \t+ m_expr->toString()\n  \t+ \"; }\";\n      return s;\n  }\n}"
  },
  {
    "function_name": "~YEReturn",
    "container": "YEReturn",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1669-1671",
    "snippet": "YEReturn::~YEReturn ()\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEReturn {\n  YEReturn::~YEReturn ()\n  {\n  }\n}"
  },
  {
    "function_name": "YEReturn",
    "container": "YEReturn",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1662-1666",
    "snippet": "YEReturn::YEReturn (bytecodeistream & str)\n    : YCode ()\n{\n    m_expr = Bytecode::readCode (str);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEReturn {\n  YEReturn::YEReturn (bytecodeistream & str)\n      : YCode ()\n  {\n      m_expr = Bytecode::readCode (str);\n  }\n}"
  },
  {
    "function_name": "YEReturn",
    "container": "YEReturn",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1655-1659",
    "snippet": "YEReturn::YEReturn (YCodePtr expr)\n    : YCode ()\n    , m_expr (expr)\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEReturn {\n  YEReturn::YEReturn (YCodePtr expr)\n      : YCode ()\n      , m_expr (expr)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YEIs",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1584-1631",
    "snippet": "YCPValue\nYEIs::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug (\"YEIs::evaluate (%s)%s\", toString().c_str(), cse ? \"<cse>\" : \"\");\n#endif\n\n    YCPValue value = m_expr->evaluate (cse);\t\t// evaluate the value\n\n    if (value.isNull())\n    {\n\tif (!cse)\t\t\t\t\t// thats an error at runtime\n\t{\n\t    ycp2error (\"'is()' expression evaluates to nil.\");\n\t}\n\treturn value;\n    }\n\n    constTypePtr value_type;\t\t\t\t// now determine the values type\n\n    if (value->isCode())\t\t\t\t// value is YCode\n    {\n\tYCodePtr code = value->asCode()->code();\n\t\n\t// is it a function? => function pointer\n\tif (code->kind () != YCode::ycFunction)\n\t{\n\t    // assume the code was passed via doublequotes\n\t    value_type = new BlockType (code->type ());\n\t}\n\telse\n\t{\n\t    value_type = code->type ();\n\t}\n    }\n    else if (value->isReference ())\t\t\t// value is Reference\n    {\n\tvalue_type = value->asReference ()->entry ()->type ();\n    }\n    else\t\t\t\t\t\t// value is constant (YCPValue)\n    {\n        return YCPBoolean (m_type->matchvalue (value) >= 0);\n    }\n\n    // allow full or propagated match\n\n    return YCPBoolean (value_type->match (m_type) >= 0);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "value_type->match (m_type) >= 0"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value_type->match",
          "args": [
            "m_type"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1739-1797",
          "snippet": "int\nFunctionType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    int bm = basematch (expected);\n\n    if (bm == 1) return 0;\t\t// any or wildcard match\n\n    if ((bm == 0\n\t    && expected->isFunction()))\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (m_returntype->match (ft->m_returntype) < 0)\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return -1;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return 0;\n\t}\n\n\tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n\tif (!wildcard)\n\t{\n\t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter count mismatch\");\n#endif\n\t\treturn -1;\n\t    }\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > esize\t\t\t// don't check wildcard parameters\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n\t    {\n\t\treturn -1;\n\t    }\n\t}\n\treturn 0;\n    }\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  int\n  FunctionType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      int bm = basematch (expected);\n  \n      if (bm == 1) return 0;\t\t// any or wildcard match\n  \n      if ((bm == 0\n  \t    && expected->isFunction()))\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (m_returntype->match (ft->m_returntype) < 0)\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return -1;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return 0;\n  \t}\n  \n  \tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n  \tif (!wildcard)\n  \t{\n  \t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter count mismatch\");\n  #endif\n  \t\treturn -1;\n  \t    }\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > esize\t\t\t// don't check wildcard parameters\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n  \t    {\n  \t\treturn -1;\n  \t    }\n  \t}\n  \treturn 0;\n      }\n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_type->matchvalue",
          "args": [
            "value"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "matchvalue",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "364-499",
          "snippet": "int\nType::matchvalue (YCPValue value) const\n{\n#if DO_DEBUG\n    y2debug (\"matchvalue type '%s', value '%s'\", toString().c_str(), value.isNull()?\"NULL\":value->toString().c_str());\n#endif\n    y2debug (\"matchvalue type '%s'[%d], value '%s'[%s]\",\n\t     toString().c_str(), m_kind,\n\t     value.isNull()?\"NULL\":value->toString().c_str(),\n\t     value.isNull()?\"\":value->valuetype_str());\n\n    if (value.isNull()) return -1;\t\t\t// error value\n\n    if (isAny()) return 0;\t\t\t\t// type 'any' matches any value\n\n    int m = -1;\n\n    switch (value->valuetype())\n    {\n\tcase YT_VOID:\n\t    m = 0;\t\t\t\t\t// value 'nil' matches any type\n\tbreak;\n\tcase YT_BOOLEAN:\n\t    if (isBoolean ()) m = 0;\n\tbreak;\n\tcase YT_INTEGER:\n\t    if (isInteger ()) m = 0;\n\tbreak;\n\tcase YT_FLOAT:\n\t    if (isFloat ()) m = 0;\n\tbreak;\n\tcase YT_STRING:\n\t    if (isString ()) m = 0;\n\tbreak;\n\tcase YT_BYTEBLOCK:\n\t    if (isByteblock ()) m = 0;\n\tbreak;\n\tcase YT_PATH:\n\t    if (isPath ()) m = 0;\n\tbreak;\n\tcase YT_SYMBOL:\n\t    if (isSymbol ()) m = 0;\n\tbreak;\n\tcase YT_TERM:\n\t    if (isTerm ()) m = 0;\n\tbreak;\n\tcase YT_LIST:\n\t{\n\t    if (!isList()) break;\n\n\t    m = 0;\n\n\t    constTypePtr type = this;\n\t    constTypePtr element_type = ((constListTypePtr)type)->type();\n\t    y2debug (\"isList, element_type '%s'\", element_type->toString().c_str());\n\t    if (element_type->isAny()\t\t\t// list<any>\n\t\t|| element_type->isUnspec())\t\t// list\n\t    {\n\t\tbreak;\t\t\t\t\t// -> match\n\t    }\n\n\t    // check every list element\n\t    YCPList lvalue = value->asList();\n\t    for (int i = 0; i < lvalue->size(); i++)\n\t    {\n\t\tYCPValue evalue = lvalue->value (i);\t// get list element value\n\t\ty2debug (\"evalue '%s'\", evalue->toString().c_str());\n\t\tif (element_type->matchvalue (evalue) < 0)\n\t\t{\n\t\t    y2debug (\"Foul\");\n\t\t    m = -1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tbreak;\n\tcase YT_MAP:\n\t{\n\t    if (!isMap()) break;\n\n\t    m = 0;\n\n\t    constTypePtr type = this;\n\t    constTypePtr key_type = ((constMapTypePtr)type)->keytype();\n\t    constTypePtr element_type = ((constMapTypePtr)type)->valuetype();\n\t    y2debug (\"isMap, key_type '%s', element_type '%s'\", key_type->toString().c_str(), element_type->toString().c_str());\n\t    if (element_type->isAny()\t\t\t// map<keytype, any>\n\t\t|| element_type->isUnspec())\t\t// map\n\t    {\n\t\tbreak;\t\t\t\t\t// -> match\n\t    }\n\n\t    // check every map element\n\t    YCPMap mvalue = value->asMap();\n\t    for (YCPMap::const_iterator i = mvalue->begin(); i != mvalue->end(); ++i)\n\t    {\n\t\tYCPValue kvalue = i->first;\t\t\t// get map key value\n\t\tYCPValue evalue = i->second;\t\t\t// get map element value\n\t\ty2debug (\"kvalue '%s', evalue '%s'\", kvalue->toString().c_str(), evalue->toString().c_str());\n\t\tif (key_type->matchvalue (kvalue) < 0)\n\t\t{\n\t\t    y2debug (\"Key has bad type\");\n\t\t    m = -1;\n\t\t    break;\n\t\t}\n\t\tif (element_type->matchvalue (evalue) < 0)\n\t\t{\n\t\t    y2debug (\"Value has bad type\");\n\t\t    m = -1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tbreak;\n\tcase YT_CODE:\t\t\t\t\t// ``{ ... }\n\t{\n\t    YCPCode ycpcode = value->asCode();\n\t    y2debug (\"Code (%s)\", ycpcode->toString().c_str());\n\t}\n\tbreak;\n\tcase YT_EXTERNAL:\t\t\t\t// external entity\n\t{\n\t    y2debug (\"External payload (%s)\", value->toString().c_str());\n\t}\n\tbreak;\n\tcase YT_RETURN:\t\t\t\t\t// { return; }\n\t{\n\t    m = 0;\t\t\t\t\t// -> evaluates to 'nil' -> matches every type\n\t}\n\tbreak;\n\tdefault:\n\tbreak;\n    }\n    y2debug (\"matchvalue -> %d\", m);\n    return m;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nType {\n  int\n  Type::matchvalue (YCPValue value) const\n  {\n  #if DO_DEBUG\n      y2debug (\"matchvalue type '%s', value '%s'\", toString().c_str(), value.isNull()?\"NULL\":value->toString().c_str());\n  #endif\n      y2debug (\"matchvalue type '%s'[%d], value '%s'[%s]\",\n  \t     toString().c_str(), m_kind,\n  \t     value.isNull()?\"NULL\":value->toString().c_str(),\n  \t     value.isNull()?\"\":value->valuetype_str());\n  \n      if (value.isNull()) return -1;\t\t\t// error value\n  \n      if (isAny()) return 0;\t\t\t\t// type 'any' matches any value\n  \n      int m = -1;\n  \n      switch (value->valuetype())\n      {\n  \tcase YT_VOID:\n  \t    m = 0;\t\t\t\t\t// value 'nil' matches any type\n  \tbreak;\n  \tcase YT_BOOLEAN:\n  \t    if (isBoolean ()) m = 0;\n  \tbreak;\n  \tcase YT_INTEGER:\n  \t    if (isInteger ()) m = 0;\n  \tbreak;\n  \tcase YT_FLOAT:\n  \t    if (isFloat ()) m = 0;\n  \tbreak;\n  \tcase YT_STRING:\n  \t    if (isString ()) m = 0;\n  \tbreak;\n  \tcase YT_BYTEBLOCK:\n  \t    if (isByteblock ()) m = 0;\n  \tbreak;\n  \tcase YT_PATH:\n  \t    if (isPath ()) m = 0;\n  \tbreak;\n  \tcase YT_SYMBOL:\n  \t    if (isSymbol ()) m = 0;\n  \tbreak;\n  \tcase YT_TERM:\n  \t    if (isTerm ()) m = 0;\n  \tbreak;\n  \tcase YT_LIST:\n  \t{\n  \t    if (!isList()) break;\n  \n  \t    m = 0;\n  \n  \t    constTypePtr type = this;\n  \t    constTypePtr element_type = ((constListTypePtr)type)->type();\n  \t    y2debug (\"isList, element_type '%s'\", element_type->toString().c_str());\n  \t    if (element_type->isAny()\t\t\t// list<any>\n  \t\t|| element_type->isUnspec())\t\t// list\n  \t    {\n  \t\tbreak;\t\t\t\t\t// -> match\n  \t    }\n  \n  \t    // check every list element\n  \t    YCPList lvalue = value->asList();\n  \t    for (int i = 0; i < lvalue->size(); i++)\n  \t    {\n  \t\tYCPValue evalue = lvalue->value (i);\t// get list element value\n  \t\ty2debug (\"evalue '%s'\", evalue->toString().c_str());\n  \t\tif (element_type->matchvalue (evalue) < 0)\n  \t\t{\n  \t\t    y2debug (\"Foul\");\n  \t\t    m = -1;\n  \t\t    break;\n  \t\t}\n  \t    }\n  \t}\n  \tbreak;\n  \tcase YT_MAP:\n  \t{\n  \t    if (!isMap()) break;\n  \n  \t    m = 0;\n  \n  \t    constTypePtr type = this;\n  \t    constTypePtr key_type = ((constMapTypePtr)type)->keytype();\n  \t    constTypePtr element_type = ((constMapTypePtr)type)->valuetype();\n  \t    y2debug (\"isMap, key_type '%s', element_type '%s'\", key_type->toString().c_str(), element_type->toString().c_str());\n  \t    if (element_type->isAny()\t\t\t// map<keytype, any>\n  \t\t|| element_type->isUnspec())\t\t// map\n  \t    {\n  \t\tbreak;\t\t\t\t\t// -> match\n  \t    }\n  \n  \t    // check every map element\n  \t    YCPMap mvalue = value->asMap();\n  \t    for (YCPMap::const_iterator i = mvalue->begin(); i != mvalue->end(); ++i)\n  \t    {\n  \t\tYCPValue kvalue = i->first;\t\t\t// get map key value\n  \t\tYCPValue evalue = i->second;\t\t\t// get map element value\n  \t\ty2debug (\"kvalue '%s', evalue '%s'\", kvalue->toString().c_str(), evalue->toString().c_str());\n  \t\tif (key_type->matchvalue (kvalue) < 0)\n  \t\t{\n  \t\t    y2debug (\"Key has bad type\");\n  \t\t    m = -1;\n  \t\t    break;\n  \t\t}\n  \t\tif (element_type->matchvalue (evalue) < 0)\n  \t\t{\n  \t\t    y2debug (\"Value has bad type\");\n  \t\t    m = -1;\n  \t\t    break;\n  \t\t}\n  \t    }\n  \t}\n  \tbreak;\n  \tcase YT_CODE:\t\t\t\t\t// ``{ ... }\n  \t{\n  \t    YCPCode ycpcode = value->asCode();\n  \t    y2debug (\"Code (%s)\", ycpcode->toString().c_str());\n  \t}\n  \tbreak;\n  \tcase YT_EXTERNAL:\t\t\t\t// external entity\n  \t{\n  \t    y2debug (\"External payload (%s)\", value->toString().c_str());\n  \t}\n  \tbreak;\n  \tcase YT_RETURN:\t\t\t\t\t// { return; }\n  \t{\n  \t    m = 0;\t\t\t\t\t// -> evaluates to 'nil' -> matches every type\n  \t}\n  \tbreak;\n  \tdefault:\n  \tbreak;\n      }\n      y2debug (\"matchvalue -> %d\", m);\n      return m;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asReference",
          "args": [],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "asReference",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "239-249",
          "snippet": "YCPReference\nYCPValueRep::asReference() const\n{\n    if (!isReference())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Reference!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPReference (static_cast<const YCPReferenceRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPReference\n  YCPValueRep::asReference() const\n  {\n      if (!isReference())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Reference!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPReference (static_cast<const YCPReferenceRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->isReference",
          "args": [],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "isReference",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "76-76",
          "snippet": "bool YCPValueRep::isReference()\t  const { return valuetype() == YT_REFERENCE; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isReference()\t  const { return valuetype() == YT_REFERENCE; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "code->type",
          "args": [],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "code->kind",
          "args": [],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": "YEFunctionPointer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YExpression.h",
          "lines": "499-499",
          "snippet": "virtual ykind kind () const { return yeFunctionPointer; }",
          "includes": [
            "#include \"y2/Y2Function.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2Function.h\"\n#include \"ycp/YCode.h\"\n#include <string>\n#include <iosfwd>\n\nYEFunctionPointer {\n  virtual ykind kind () const { return yeFunctionPointer; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asCode",
          "args": [],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "asCode",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "215-225",
          "snippet": "YCPCode\nYCPValueRep::asCode() const\n{\n    if (!isCode())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Code !\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPCode (static_cast<const YCPCodeRep*>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPCode\n  YCPValueRep::asCode() const\n  {\n      if (!isCode())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Code !\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPCode (static_cast<const YCPCodeRep*>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->isCode",
          "args": [],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "isCode",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "72-72",
          "snippet": "bool YCPValueRep::isCode()\t  const { return valuetype() == YT_CODE; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isCode()\t  const { return valuetype() == YT_CODE; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"'is()' expression evaluates to nil.\""
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_expr->evaluate",
          "args": [
            "cse"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "YEFunctionPointer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3191-3273",
          "snippet": "YCPValue\nYEFunctionPointer::evaluate (bool cse)\n{\n    if (cse)\n    {\n\treturn YCPNull();\n    }\n\n#if DO_DEBUG\n    y2debug (\"YEFunctionPointer::evaluate (%s)\\n\", toString().c_str());\n#endif\n\n    YCPValue ptr = m_sentry->value ();\n    if (ptr.isNull () || ! ptr->isReference ())\n    {\n\tycp2error (\"Function pointer (%s) is %s\"\n\t    , m_sentry->toString().c_str()\n\t    , ptr.isNull () ? \"NULL\" : ptr->toString ().c_str ());\n\treturn YCPVoid ();\n    }\n    \n    SymbolEntryPtr ptr_sentry = ptr->asReference ()->entry ();\n\n    Y2Namespace* ns = const_cast<Y2Namespace*> (ptr_sentry->nameSpace ());\n\n    m_functioncall = ns->createFunctionCall (\n\tptr_sentry->name (),\n\tptr_sentry->type ()\n    );\n    \n    if (!m_functioncall)\n    {\n\ty2internal (\"Cannot get function call object for %s\", m_sentry->toString().c_str());\n\treturn YCPVoid ();\n    }\n\n    // FIXME: this could fail    \n    m_functioncall->reset ();\n    \n    YCPValue m_params [m_next_param_id];\n\n    for (unsigned int p = 0; p < m_next_param_id ; p++)\n    {\n\t// FIXME, check for symbol or block type and suppress evaluation\n\n\tYCPValue value = m_parameters[p]->evaluate ();\n\n\tif (value.isNull())\n\t{\n\t    ycp2error (\"Parameter eval failed (%s)\", m_parameters[p]->toString().c_str());\n\t    return value;\n\t}\n\t\n#if DO_DEBUG\n\ty2debug (\"parameter %d = (%s)\", p, value->toString().c_str());\n#endif\n\n\tm_params [p] = value;\n    }\n\n    // set the parameters for Y2Function\n    for (unsigned int p = 0; p < m_next_param_id ; p++)\n    {\n\tm_functioncall->attachParameter (m_params[p], p);\n    }\n    \n    extern ExecutionEnvironment ee;\n\n    // save the context info\n    int linenumber = ee.linenumber ();\n    string filename = ee.filename ();\n\n    YCPValue value = m_functioncall->evaluateCall ();\n\n    // restore the context info\n    ee.setLinenumber (linenumber);\n    ee.setFilename (filename);\n\n#if DO_DEBUG\n    y2debug(\"evaluate done (%s) = '%s'\", qualifiedName ().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n    return value;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEFunctionPointer {\n  YCPValue\n  YEFunctionPointer::evaluate (bool cse)\n  {\n      if (cse)\n      {\n  \treturn YCPNull();\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"YEFunctionPointer::evaluate (%s)\\n\", toString().c_str());\n  #endif\n  \n      YCPValue ptr = m_sentry->value ();\n      if (ptr.isNull () || ! ptr->isReference ())\n      {\n  \tycp2error (\"Function pointer (%s) is %s\"\n  \t    , m_sentry->toString().c_str()\n  \t    , ptr.isNull () ? \"NULL\" : ptr->toString ().c_str ());\n  \treturn YCPVoid ();\n      }\n      \n      SymbolEntryPtr ptr_sentry = ptr->asReference ()->entry ();\n  \n      Y2Namespace* ns = const_cast<Y2Namespace*> (ptr_sentry->nameSpace ());\n  \n      m_functioncall = ns->createFunctionCall (\n  \tptr_sentry->name (),\n  \tptr_sentry->type ()\n      );\n      \n      if (!m_functioncall)\n      {\n  \ty2internal (\"Cannot get function call object for %s\", m_sentry->toString().c_str());\n  \treturn YCPVoid ();\n      }\n  \n      // FIXME: this could fail    \n      m_functioncall->reset ();\n      \n      YCPValue m_params [m_next_param_id];\n  \n      for (unsigned int p = 0; p < m_next_param_id ; p++)\n      {\n  \t// FIXME, check for symbol or block type and suppress evaluation\n  \n  \tYCPValue value = m_parameters[p]->evaluate ();\n  \n  \tif (value.isNull())\n  \t{\n  \t    ycp2error (\"Parameter eval failed (%s)\", m_parameters[p]->toString().c_str());\n  \t    return value;\n  \t}\n  \t\n  #if DO_DEBUG\n  \ty2debug (\"parameter %d = (%s)\", p, value->toString().c_str());\n  #endif\n  \n  \tm_params [p] = value;\n      }\n  \n      // set the parameters for Y2Function\n      for (unsigned int p = 0; p < m_next_param_id ; p++)\n      {\n  \tm_functioncall->attachParameter (m_params[p], p);\n      }\n      \n      extern ExecutionEnvironment ee;\n  \n      // save the context info\n      int linenumber = ee.linenumber ();\n      string filename = ee.filename ();\n  \n      YCPValue value = m_functioncall->evaluateCall ();\n  \n      // restore the context info\n      ee.setLinenumber (linenumber);\n      ee.setFilename (filename);\n  \n  #if DO_DEBUG\n      y2debug(\"evaluate done (%s) = '%s'\", qualifiedName ().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEIs::evaluate (%s)%s\"",
            "toString().c_str()",
            "cse ? \"<cse>\" : \"\""
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEIs {\n  YCPValue\n  YEIs::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug (\"YEIs::evaluate (%s)%s\", toString().c_str(), cse ? \"<cse>\" : \"\");\n  #endif\n  \n      YCPValue value = m_expr->evaluate (cse);\t\t// evaluate the value\n  \n      if (value.isNull())\n      {\n  \tif (!cse)\t\t\t\t\t// thats an error at runtime\n  \t{\n  \t    ycp2error (\"'is()' expression evaluates to nil.\");\n  \t}\n  \treturn value;\n      }\n  \n      constTypePtr value_type;\t\t\t\t// now determine the values type\n  \n      if (value->isCode())\t\t\t\t// value is YCode\n      {\n  \tYCodePtr code = value->asCode()->code();\n  \t\n  \t// is it a function? => function pointer\n  \tif (code->kind () != YCode::ycFunction)\n  \t{\n  \t    // assume the code was passed via doublequotes\n  \t    value_type = new BlockType (code->type ());\n  \t}\n  \telse\n  \t{\n  \t    value_type = code->type ();\n  \t}\n      }\n      else if (value->isReference ())\t\t\t// value is Reference\n      {\n  \tvalue_type = value->asReference ()->entry ()->type ();\n      }\n      else\t\t\t\t\t\t// value is constant (YCPValue)\n      {\n          return YCPBoolean (m_type->matchvalue (value) >= 0);\n      }\n  \n      // allow full or propagated match\n  \n      return YCPBoolean (value_type->match (m_type) >= 0);\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YEIs",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1573-1581",
    "snippet": "string\nYEIs::toString () const\n{\n    string s = \"is (\"\n\t+ m_expr->toString()\n\t+ \", \" + m_type->toString()\n\t+ \")\";\n    return s;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_type->toString",
          "args": [],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEIs {\n  string\n  YEIs::toString () const\n  {\n      string s = \"is (\"\n  \t+ m_expr->toString()\n  \t+ \", \" + m_type->toString()\n  \t+ \")\";\n      return s;\n  }\n}"
  },
  {
    "function_name": "~YEIs",
    "container": "YEIs",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1568-1570",
    "snippet": "YEIs::~YEIs ()\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEIs {\n  YEIs::~YEIs ()\n  {\n  }\n}"
  },
  {
    "function_name": "YEIs",
    "container": "YEIs",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1560-1565",
    "snippet": "YEIs::YEIs (bytecodeistream & str)\n    : YCode ()\n    , m_type (Bytecode::readType (str))\n{\n    m_expr = Bytecode::readCode (str);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readType",
          "args": [
            "str"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "readType",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "349-387",
          "snippet": "TypePtr\nBytecode::readType (bytecodeistream & str)\n{\n    int kind = readInt32 (str);\n#if DO_DEBUG\ny2debug (\"Bytecode::readType(%d)\", kind);\n#endif\n    switch ((Type::tkind)kind)\n    {\n\tcase Type::UnspecT:\n\tcase Type::ErrorT:\n\tcase Type::AnyT:\n\tcase Type::BooleanT:\n\tcase Type::ByteblockT:\n\tcase Type::FloatT:\n\tcase Type::IntegerT:\n\tcase Type::LocaleT:\n\tcase Type::PathT:\n\tcase Type::StringT:\n\tcase Type::SymbolT:\n\tcase Type::TermT:\n\tcase Type::VoidT:\n\tcase Type::WildcardT:\n\tcase Type::FlexT:\n\tcase Type::NilT:\n\t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n\tbreak;\n\n\tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n\tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n\tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n\tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n\tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n\tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n\tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n    }\n    y2error (\"Unhandled type kind %d\", kind);\n    return Type::Error->clone();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  TypePtr\n  Bytecode::readType (bytecodeistream & str)\n  {\n      int kind = readInt32 (str);\n  #if DO_DEBUG\n  y2debug (\"Bytecode::readType(%d)\", kind);\n  #endif\n      switch ((Type::tkind)kind)\n      {\n  \tcase Type::UnspecT:\n  \tcase Type::ErrorT:\n  \tcase Type::AnyT:\n  \tcase Type::BooleanT:\n  \tcase Type::ByteblockT:\n  \tcase Type::FloatT:\n  \tcase Type::IntegerT:\n  \tcase Type::LocaleT:\n  \tcase Type::PathT:\n  \tcase Type::StringT:\n  \tcase Type::SymbolT:\n  \tcase Type::TermT:\n  \tcase Type::VoidT:\n  \tcase Type::WildcardT:\n  \tcase Type::FlexT:\n  \tcase Type::NilT:\n  \t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n  \tbreak;\n  \n  \tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n  \tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n  \tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n  \tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n  \tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n  \tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n  \tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n      }\n      y2error (\"Unhandled type kind %d\", kind);\n      return Type::Error->clone();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEIs {\n  YEIs::YEIs (bytecodeistream & str)\n      : YCode ()\n      , m_type (Bytecode::readType (str))\n  {\n      m_expr = Bytecode::readCode (str);\n  }\n}"
  },
  {
    "function_name": "YEIs",
    "container": "YEIs",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1552-1557",
    "snippet": "YEIs::YEIs (YCodePtr expr, constTypePtr type)\n    : YCode ()\n    , m_expr (expr)\n    , m_type (type)\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEIs {\n  YEIs::YEIs (YCodePtr expr, constTypePtr type)\n      : YCode ()\n      , m_expr (expr)\n      , m_type (type)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YETriple",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1490-1523",
    "snippet": "YCPValue\nYETriple::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug (\"YETriple::evaluate(%s)\\n\", toString().c_str());\n#endif\n    if (cse)\n    {\n\treturn YCPNull();\n    }\n\n    YCPValue expr = m_expr->evaluate ();\n\n    if (expr.isNull () || expr->isVoid())\n    {\n\textern ExecutionEnvironment ee;\n\tycp2warning (ee.filename().c_str(), ee.linenumber(), \"Condition expression evaluates to nil in ?: expression, using false instead.\");\n\treturn m_false->evaluate ();\n    }\n\n    if (expr->isBoolean())\n    {\n\tif (expr->asBoolean()->value() == true)\n\t{\n\t    return m_true->evaluate ();\n\t}\n\telse\n\t{\n\t    return m_false->evaluate ();\n\t}\n    }\n    ycp2error (\"Condition expression evaluates to a non boolean value %s in ?: expression\", expr->toString ().c_str ());\n    return YCPNull ();\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Condition expression evaluates to a non boolean value %s in ?: expression\"",
            "expr->toString ().c_str ()"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->toString",
          "args": [],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_false->evaluate",
          "args": [],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_true->evaluate",
          "args": [],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr->asBoolean",
          "args": [],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "asBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "94-104",
          "snippet": "YCPBoolean\nYCPValueRep::asBoolean() const\n{\n    if (!isBoolean())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPBoolean\n  YCPValueRep::asBoolean() const\n  {\n      if (!isBoolean())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Boolean!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPBoolean (static_cast<const YCPBooleanRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expr->isBoolean",
          "args": [],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "isBoolean",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "62-62",
          "snippet": "bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isBoolean()     const { return valuetype() == YT_BOOLEAN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_false->evaluate",
          "args": [],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2warning",
          "args": [
            "ee.filename().c_str()",
            "ee.linenumber()",
            "\"Condition expression evaluates to nil in ?: expression, using false instead.\""
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee.linenumber",
          "args": [],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "linenumber",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "41-45",
          "snippet": "int\nExecutionEnvironment::linenumber () const\n{\n    return m_linenumber;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  int\n  ExecutionEnvironment::linenumber () const\n  {\n      return m_linenumber;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.filename",
          "args": [],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "filename",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "335-339",
          "snippet": "string\nScanner::filename () const\n{\n    return m_filename;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  string\n  Scanner::filename () const\n  {\n      return m_filename;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expr->isVoid",
          "args": [],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expr.isNull",
          "args": [],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_expr->evaluate",
          "args": [],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YETriple::evaluate(%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYETriple {\n  YCPValue\n  YETriple::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug (\"YETriple::evaluate(%s)\\n\", toString().c_str());\n  #endif\n      if (cse)\n      {\n  \treturn YCPNull();\n      }\n  \n      YCPValue expr = m_expr->evaluate ();\n  \n      if (expr.isNull () || expr->isVoid())\n      {\n  \textern ExecutionEnvironment ee;\n  \tycp2warning (ee.filename().c_str(), ee.linenumber(), \"Condition expression evaluates to nil in ?: expression, using false instead.\");\n  \treturn m_false->evaluate ();\n      }\n  \n      if (expr->isBoolean())\n      {\n  \tif (expr->asBoolean()->value() == true)\n  \t{\n  \t    return m_true->evaluate ();\n  \t}\n  \telse\n  \t{\n  \t    return m_false->evaluate ();\n  \t}\n      }\n      ycp2error (\"Condition expression evaluates to a non boolean value %s in ?: expression\", expr->toString ().c_str ());\n      return YCPNull ();\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YETriple",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1481-1487",
    "snippet": "string\nYETriple::toString() const\n{\n    return m_expr->toString()\n\t   + \" ? \" + m_true->toString()\n\t   + \" : \" + m_false->toString();\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_false->toString",
          "args": [],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYETriple {\n  string\n  YETriple::toString() const\n  {\n      return m_expr->toString()\n  \t   + \" ? \" + m_true->toString()\n  \t   + \" : \" + m_false->toString();\n  }\n}"
  },
  {
    "function_name": "~YETriple",
    "container": "YETriple",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1476-1478",
    "snippet": "YETriple::~YETriple ()\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYETriple {\n  YETriple::~YETriple ()\n  {\n  }\n}"
  },
  {
    "function_name": "YETriple",
    "container": "YETriple",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1467-1473",
    "snippet": "YETriple::YETriple (bytecodeistream & str)\n    : YCode ()\n{\n    m_expr = Bytecode::readCode (str);\n    m_true = Bytecode::readCode (str);\n    m_false = Bytecode::readCode (str);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYETriple {\n  YETriple::YETriple (bytecodeistream & str)\n      : YCode ()\n  {\n      m_expr = Bytecode::readCode (str);\n      m_true = Bytecode::readCode (str);\n      m_false = Bytecode::readCode (str);\n  }\n}"
  },
  {
    "function_name": "YETriple",
    "container": "YETriple",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1458-1464",
    "snippet": "YETriple::YETriple (YCodePtr a_expr, YCodePtr a_true, YCodePtr a_false)\n    : YCode ()\n    , m_expr (a_expr)\n    , m_true (a_true)\n    , m_false (a_false)\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYETriple {\n  YETriple::YETriple (YCodePtr a_expr, YCodePtr a_true, YCodePtr a_false)\n      : YCode ()\n      , m_expr (a_expr)\n      , m_true (a_true)\n      , m_false (a_false)\n  {\n  }\n}"
  },
  {
    "function_name": "type",
    "container": "YEBinary",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1429-1453",
    "snippet": "constTypePtr\nYEBinary::type () const\n{\n    if (m_decl->flags && DECL_FLEX)\n    {\n\t// reconstruct type\n\tFunctionTypePtr ft = new FunctionType (Type::Unspec);\n\tft->concat (m_arg1->type ());\n\tft->concat (m_arg2->type ());\n\t\n\tconstTypePtr cft = Type::determineFlexType (ft, m_decl->type);\n        if (cft == 0)                                       // failed\n        {\n\t    y2internal (\"Cannot determine type of the binary operator: %s\", toString ().c_str ());\n            return Type::Unspec;\n        }\n\t\n\treturn ((constFunctionTypePtr)cft)->returnType ();\n\n    }\n    else\n    {\n\treturn ((constFunctionTypePtr)m_decl->type)->returnType (); \n    }\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2internal",
          "args": [
            "\"Cannot determine type of the binary operator: %s\"",
            "toString ().c_str ()"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Type::determineFlexType",
          "args": [
            "ft",
            "m_decl->type"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "determineFlexType",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/TypeStatics.cc",
          "lines": "524-564",
          "snippet": "constTypePtr\nType::determineFlexType (constFunctionTypePtr actual, constFunctionTypePtr declared)\n{\n    y2debug (\"determineFlexType (actual %s, declared %s)\", actual ? actual->toString().c_str() : \"NULL\", declared ? declared->toString().c_str() : \"NULL\");\n\n    // if builtin decl returns 'flex', the parameter deduces the return type\n\n    constTypePtr result;\n\n    if (declared->parameterCount() <= 0)\n    {\n\tycp2error (\"declared->parameterCount() <= 0\");\n\treturn 0;\n    }\n\n    unsigned int flexnumber = 0;\n\n    constTypePtr flextype;\n\n    do\n    {\n\tflextype = declared->matchFlex (actual, flexnumber);\n\n\ty2debug (\"flextype %d:'%s'\", flexnumber, flextype == 0 ? \"NONE\" : flextype->toString().c_str());\n\n\tif (flextype == 0)\n\t{\n\t    result = declared;\n\t}\n\telse\n\t{\n\t    // exchange <flex> with the correct type\n\t    result = declared->unflex (flextype, flexnumber);\n\t    declared = result;\n\t}\n    }\n    while ((flexnumber++ == 0) || (flextype != 0));\n\n    y2debug (\"determineFlexType returns '%s'\", result ? result->toString().c_str() : \"ERROR\");\n    return result;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  constTypePtr\n  Type::determineFlexType (constFunctionTypePtr actual, constFunctionTypePtr declared)\n  {\n      y2debug (\"determineFlexType (actual %s, declared %s)\", actual ? actual->toString().c_str() : \"NULL\", declared ? declared->toString().c_str() : \"NULL\");\n  \n      // if builtin decl returns 'flex', the parameter deduces the return type\n  \n      constTypePtr result;\n  \n      if (declared->parameterCount() <= 0)\n      {\n  \tycp2error (\"declared->parameterCount() <= 0\");\n  \treturn 0;\n      }\n  \n      unsigned int flexnumber = 0;\n  \n      constTypePtr flextype;\n  \n      do\n      {\n  \tflextype = declared->matchFlex (actual, flexnumber);\n  \n  \ty2debug (\"flextype %d:'%s'\", flexnumber, flextype == 0 ? \"NONE\" : flextype->toString().c_str());\n  \n  \tif (flextype == 0)\n  \t{\n  \t    result = declared;\n  \t}\n  \telse\n  \t{\n  \t    // exchange <flex> with the correct type\n  \t    result = declared->unflex (flextype, flexnumber);\n  \t    declared = result;\n  \t}\n      }\n      while ((flexnumber++ == 0) || (flextype != 0));\n  \n      y2debug (\"determineFlexType returns '%s'\", result ? result->toString().c_str() : \"ERROR\");\n      return result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ft->concat",
          "args": [
            "m_arg2->type ()"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "concat",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1649-1661",
          "snippet": "void\nFunctionType::concat (constTypePtr t)\n{\n    if (!m_arguments)\n    {\n\tm_arguments = TupleTypePtr (new TupleType (t));\n    }\n    else\n    {\n\tm_arguments->concat (t);\n    }\n    return;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nFunctionType {\n  void\n  FunctionType::concat (constTypePtr t)\n  {\n      if (!m_arguments)\n      {\n  \tm_arguments = TupleTypePtr (new TupleType (t));\n      }\n      else\n      {\n  \tm_arguments->concat (t);\n      }\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_arg2->type",
          "args": [],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEBinary {\n  constTypePtr\n  YEBinary::type () const\n  {\n      if (m_decl->flags && DECL_FLEX)\n      {\n  \t// reconstruct type\n  \tFunctionTypePtr ft = new FunctionType (Type::Unspec);\n  \tft->concat (m_arg1->type ());\n  \tft->concat (m_arg2->type ());\n  \t\n  \tconstTypePtr cft = Type::determineFlexType (ft, m_decl->type);\n          if (cft == 0)                                       // failed\n          {\n  \t    y2internal (\"Cannot determine type of the binary operator: %s\", toString ().c_str ());\n              return Type::Unspec;\n          }\n  \t\n  \treturn ((constFunctionTypePtr)cft)->returnType ();\n  \n      }\n      else\n      {\n  \treturn ((constFunctionTypePtr)m_decl->type)->returnType (); \n      }\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YEBinary",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1360-1401",
    "snippet": "YCPValue\nYEBinary::evaluate (bool cse)\n{\n    if (cse) return YCPNull();\n\n#if DO_DEBUG\n    y2debug (\"YEBinary::evaluate(%s)\\n\", toString().c_str());\n#endif\n\n    if ( (m_decl->flags & DECL_NOEVAL) == DECL_NOEVAL)\n    {\n\treturn (*(v2vv)m_decl->ptr) (YCPCode(m_arg1), YCPCode (m_arg2));\n    }\n\n    const YCPValue arg1 = m_arg1->evaluate ();\n    if ((arg1.isNull() || arg1->isVoid())\n\t&& ((m_decl->flags & DECL_NIL) == 0))\n    {\n\tycp2error (\"Argument (%s) to %s(...) evaluates to nil\", m_arg1->toString().c_str(), m_decl->name);\n\treturn YCPNull ();\n    }\n    const YCPValue arg2 = m_arg2->evaluate ();\n    if ((arg2.isNull() || arg2->isVoid())\n\t&& ((m_decl->flags & DECL_NIL) == 0))\n    {\n\tycp2error (\"Argument (%s) to %s(...) evaluates to nil\", m_arg2->toString().c_str(), m_decl->name);\n\treturn YCPNull ();\n    }\n    const declaration_t *decl = m_decl;\n#if DO_DEBUG\n    y2debug (\"func %s (%s) [%s,%s]\", decl->name, decl->type->toString().c_str(), arg1->toString().c_str(), arg2->toString().c_str());\n    y2debug (\"type1 %s, type2 %s\", arg1->valuetype_str(), arg2->valuetype_str());\n#endif\n\n#ifdef BUILTIN_STATISTICS\n    FILE *fout = fopen (\"/tmp/builtin-use.txt\", \"a\");\n    fprintf (fout, \"%s %s\\n\", decl->name, decl->type->toString().c_str());\n    fclose (fout);\n#endif\n\n    return (*(v2vv)decl->ptr) (arg1, arg2);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fout"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fout",
            "\"%s %s\\n\"",
            "decl->name",
            "decl->type->toString().c_str()"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl->type->toString",
          "args": [],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/tmp/builtin-use.txt\"",
            "\"a\""
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"type1 %s, type2 %s\"",
            "arg1->valuetype_str()",
            "arg2->valuetype_str()"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg2->valuetype_str",
          "args": [],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg1->valuetype_str",
          "args": [],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"func %s (%s) [%s,%s]\"",
            "decl->name",
            "decl->type->toString().c_str()",
            "arg1->toString().c_str()",
            "arg2->toString().c_str()"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Argument (%s) to %s(...) evaluates to nil\"",
            "m_arg2->toString().c_str()",
            "m_decl->name"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg2->isVoid",
          "args": [],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg2.isNull",
          "args": [],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_arg2->evaluate",
          "args": [],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Argument (%s) to %s(...) evaluates to nil\"",
            "m_arg1->toString().c_str()",
            "m_decl->name"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg1.isNull",
          "args": [],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_arg1->evaluate",
          "args": [],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "YCPCode(m_arg1)",
            "YCPCode (m_arg2)"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPCode",
          "args": [
            "m_arg2"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "YCPCode",
          "container": "YCPCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "103-107",
          "snippet": "YCPCode::YCPCode (bytecodeistream & str)\n    : YCPValue (YCPCode())\n{\n    (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPCode {\n  YCPCode::YCPCode (bytecodeistream & str)\n      : YCPValue (YCPCode())\n  {\n      (const_cast<YCPCodeRep*>(static_cast<const YCPCodeRep*>(element)))->m_code = Bytecode::readCode (str);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEBinary::evaluate(%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEBinary {\n  YCPValue\n  YEBinary::evaluate (bool cse)\n  {\n      if (cse) return YCPNull();\n  \n  #if DO_DEBUG\n      y2debug (\"YEBinary::evaluate(%s)\\n\", toString().c_str());\n  #endif\n  \n      if ( (m_decl->flags & DECL_NOEVAL) == DECL_NOEVAL)\n      {\n  \treturn (*(v2vv)m_decl->ptr) (YCPCode(m_arg1), YCPCode (m_arg2));\n      }\n  \n      const YCPValue arg1 = m_arg1->evaluate ();\n      if ((arg1.isNull() || arg1->isVoid())\n  \t&& ((m_decl->flags & DECL_NIL) == 0))\n      {\n  \tycp2error (\"Argument (%s) to %s(...) evaluates to nil\", m_arg1->toString().c_str(), m_decl->name);\n  \treturn YCPNull ();\n      }\n      const YCPValue arg2 = m_arg2->evaluate ();\n      if ((arg2.isNull() || arg2->isVoid())\n  \t&& ((m_decl->flags & DECL_NIL) == 0))\n      {\n  \tycp2error (\"Argument (%s) to %s(...) evaluates to nil\", m_arg2->toString().c_str(), m_decl->name);\n  \treturn YCPNull ();\n      }\n      const declaration_t *decl = m_decl;\n  #if DO_DEBUG\n      y2debug (\"func %s (%s) [%s,%s]\", decl->name, decl->type->toString().c_str(), arg1->toString().c_str(), arg2->toString().c_str());\n      y2debug (\"type1 %s, type2 %s\", arg1->valuetype_str(), arg2->valuetype_str());\n  #endif\n  \n  #ifdef BUILTIN_STATISTICS\n      FILE *fout = fopen (\"/tmp/builtin-use.txt\", \"a\");\n      fprintf (fout, \"%s %s\\n\", decl->name, decl->type->toString().c_str());\n      fclose (fout);\n  #endif\n  \n      return (*(v2vv)decl->ptr) (arg1, arg2);\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YEBinary",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1351-1357",
    "snippet": "string\nYEBinary::toString() const\n{\n    return \"(\" + m_arg1->toString()\n\t+ \" \" + StaticDeclaration::Decl2String (m_decl)\n\t+ \" \" + m_arg2->toString() + \")\";\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_arg2->toString",
          "args": [],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "StaticDeclaration::Decl2String",
          "args": [
            "m_decl"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEBinary {\n  string\n  YEBinary::toString() const\n  {\n      return \"(\" + m_arg1->toString()\n  \t+ \" \" + StaticDeclaration::Decl2String (m_decl)\n  \t+ \" \" + m_arg2->toString() + \")\";\n  }\n}"
  },
  {
    "function_name": "~YEBinary",
    "container": "YEBinary",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1339-1341",
    "snippet": "YEBinary::~YEBinary ()\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEBinary {\n  YEBinary::~YEBinary ()\n  {\n  }\n}"
  },
  {
    "function_name": "YEBinary",
    "container": "YEBinary",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1325-1336",
    "snippet": "YEBinary::YEBinary (bytecodeistream & str)\n    : YCode ()\n{\n    extern StaticDeclaration static_declarations;\n\n    m_decl = static_declarations.readDeclaration (str);\n    if (m_decl)\n    {\n\tm_arg1 = Bytecode::readCode (str);\n\tm_arg2 = Bytecode::readCode (str);\n    }\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_declarations.readDeclaration",
          "args": [
            "str"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEBinary {\n  YEBinary::YEBinary (bytecodeistream & str)\n      : YCode ()\n  {\n      extern StaticDeclaration static_declarations;\n  \n      m_decl = static_declarations.readDeclaration (str);\n      if (m_decl)\n      {\n  \tm_arg1 = Bytecode::readCode (str);\n  \tm_arg2 = Bytecode::readCode (str);\n      }\n  }\n}"
  },
  {
    "function_name": "YEBinary",
    "container": "YEBinary",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1316-1322",
    "snippet": "YEBinary::YEBinary (declaration_t *decl, YCodePtr arg1, YCodePtr arg2)\n    : YCode ()\n    , m_decl (decl)\n    , m_arg1 (arg1)\n    , m_arg2 (arg2)\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEBinary {\n  YEBinary::YEBinary (declaration_t *decl, YCodePtr arg1, YCodePtr arg2)\n      : YCode ()\n      , m_decl (decl)\n      , m_arg1 (arg1)\n      , m_arg2 (arg2)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YEUnary",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1255-1287",
    "snippet": "YCPValue\nYEUnary::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug (\"YEUnary::evaluate(%s)\\n\", toString().c_str());\n#endif\n    if (cse)\n    {\n\treturn YCPNull();\n    }\n\n    YCPValue arg = m_arg->evaluate ();\n    const declaration_t *decl = m_decl;\n\n    if (arg.isNull()\n\t&& ((decl->flags & DECL_NIL) == 0))\n    {\n\tycp2error (\"Argument (%s) to %s(...) is nil\", m_arg->toString().c_str(), m_decl->name);\n\treturn YCPNull ();\n    }\n\n#if DO_DEBUG\n    y2debug (\"func %s (%s)\", decl->name, decl->type->toString().c_str());\n#endif\n\n#ifdef BUILTIN_STATISTICS\n    FILE *fout = fopen (\"/tmp/builtin-use.txt\", \"a\");\n    fprintf (fout, \"%s %s\\n\", decl->name, decl->type->toString().c_str());\n    fclose (fout);\n#endif\n\n    return (*(v2v)decl->ptr) (arg);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "arg"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fout"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fout",
            "\"%s %s\\n\"",
            "decl->name",
            "decl->type->toString().c_str()"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl->type->toString",
          "args": [],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/tmp/builtin-use.txt\"",
            "\"a\""
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"func %s (%s)\"",
            "decl->name",
            "decl->type->toString().c_str()"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Argument (%s) to %s(...) is nil\"",
            "m_arg->toString().c_str()",
            "m_decl->name"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_arg->evaluate",
          "args": [],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEUnary::evaluate(%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEUnary {\n  YCPValue\n  YEUnary::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug (\"YEUnary::evaluate(%s)\\n\", toString().c_str());\n  #endif\n      if (cse)\n      {\n  \treturn YCPNull();\n      }\n  \n      YCPValue arg = m_arg->evaluate ();\n      const declaration_t *decl = m_decl;\n  \n      if (arg.isNull()\n  \t&& ((decl->flags & DECL_NIL) == 0))\n      {\n  \tycp2error (\"Argument (%s) to %s(...) is nil\", m_arg->toString().c_str(), m_decl->name);\n  \treturn YCPNull ();\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"func %s (%s)\", decl->name, decl->type->toString().c_str());\n  #endif\n  \n  #ifdef BUILTIN_STATISTICS\n      FILE *fout = fopen (\"/tmp/builtin-use.txt\", \"a\");\n      fprintf (fout, \"%s %s\\n\", decl->name, decl->type->toString().c_str());\n      fclose (fout);\n  #endif\n  \n      return (*(v2v)decl->ptr) (arg);\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YEUnary",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1247-1252",
    "snippet": "string\nYEUnary::toString() const\n{\n    return StaticDeclaration::Decl2String (m_decl)\n\t   + \" \" + m_arg->toString();\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_arg->toString",
          "args": [],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "StaticDeclaration::Decl2String",
          "args": [
            "m_decl"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEUnary {\n  string\n  YEUnary::toString() const\n  {\n      return StaticDeclaration::Decl2String (m_decl)\n  \t   + \" \" + m_arg->toString();\n  }\n}"
  },
  {
    "function_name": "~YEUnary",
    "container": "YEUnary",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1235-1237",
    "snippet": "YEUnary::~YEUnary ()\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEUnary {\n  YEUnary::~YEUnary ()\n  {\n  }\n}"
  },
  {
    "function_name": "YEUnary",
    "container": "YEUnary",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1222-1232",
    "snippet": "YEUnary::YEUnary (bytecodeistream & str)\n    : YCode ()\n{\n    extern StaticDeclaration static_declarations;\n\n    m_decl = static_declarations.readDeclaration (str);\n    if (m_decl)\n    {\n\tm_arg = Bytecode::readCode (str);\n    }\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_declarations.readDeclaration",
          "args": [
            "str"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEUnary {\n  YEUnary::YEUnary (bytecodeistream & str)\n      : YCode ()\n  {\n      extern StaticDeclaration static_declarations;\n  \n      m_decl = static_declarations.readDeclaration (str);\n      if (m_decl)\n      {\n  \tm_arg = Bytecode::readCode (str);\n      }\n  }\n}"
  },
  {
    "function_name": "YEUnary",
    "container": "YEUnary",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1214-1219",
    "snippet": "YEUnary::YEUnary (declaration_t *decl, YCodePtr arg)\n    : YCode ()\n    , m_decl (decl)\n    , m_arg (arg)\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEUnary {\n  YEUnary::YEUnary (declaration_t *decl, YCodePtr arg)\n      : YCode ()\n      , m_decl (decl)\n      , m_arg (arg)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YEPropagate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1147-1189",
    "snippet": "YCPValue\nYEPropagate::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug (\"YEPropagate::evaluate(%s)\\n\", toString().c_str());\n#endif\n    if (cse)\n    {\n\treturn YCPNull();\n    }\n\n    YCPValue v = m_value->evaluate ();\n    if (v.isNull() || v->isVoid ())\n    {\n\treturn v;\n    }\n\n    // If this proves too slow, maybe optimize it away completely\n    // by inventing YEPropagateIntegerFloat\n    if (m_to->isFloat()\n\t&& v->isInteger())\n    {\n\treturn YCPFloat (v->asInteger()->value());\n    }\n    else if (m_to->isInteger()\n\t     && v->isFloat())\n    {\n\treturn YCPInteger ((long long)(v->asFloat()->value()));\n    }\n    else if (v->isReference () \n\t&& m_to->match (v->asReference ()->entry ()->type ()) == 0)\n    {\n\treturn v;\n    }\n    else if (canPropagate (v, m_to))\n    {\n\treturn v;\n    }\n\n    ycp2error (\"Can't convert value '%s' to type '%s'\", v->toString().c_str(), m_to->toString().c_str());\n\n    return YCPNull ();\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Can't convert value '%s' to type '%s'\"",
            "v->toString().c_str()",
            "m_to->toString().c_str()"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_to->toString",
          "args": [],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "canPropagate",
          "args": [
            "v",
            "m_to"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "canPropagate",
          "container": "YEPropagate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "1068-1144",
          "snippet": "bool\nYEPropagate::canPropagate(const YCPValue& value, constTypePtr to_type) const\n{\n    if (value.isNull()\n\t|| value->isVoid()\t\t\t\t\t// value is nil, this is allowed everywhere\n\t|| to_type->isAny ()\t\t\t\t\t// casting to any\n\t|| to_type->isUnspec ()\t\t\t\t\t// casting to unspec\n\t|| ( to_type->isBasetype ()\t\t\t\t// casting to equivalent base type\n\t     && value->valuetype () == to_type->valueType ()))\n    {\n\treturn true;\t\t\t\t\t\t// this is all ok\n    }\n\n#if DO_DEBUG\n    y2debug (\"to type: %s\", to_type->toString ().c_str () );\n#endif\n    if (to_type->isList ()\t\t\t\t\t// casting to a list\n\t&& value->isList ())\n    {\n\t// check types of all elements\n\tconstTypePtr elem = ((constListTypePtr)to_type)->type ();\n\tif (elem->isAny ()) return true;\n\tif (elem->isUnspec ()) return true;\t\t\t// untyped list\n\n\tYCPList v = value->asList ();\n\n\tfor (int i=0; i < v->size (); i++ )\n\t{\n#if DO_DEBUG\n\t    y2debug (\"testing %s\", v->value (i)->toString ().c_str ());\n#endif\n\t    if (! canPropagate (v->value (i), elem) )\n\t    {\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n\n    if (to_type->isMap ()\t\t\t\t\t// casting to a map\n\t&& value->isMap ())\n    {\n\t// check types of all elements\n\tconstTypePtr key = ((constMapTypePtr)to_type)->keytype ();\n\tconstTypePtr elem = ((constMapTypePtr)to_type)->valuetype ();\n\n\tif (elem->isAny () && key->isAny ()) return true;\t// map<any,any>\n\n\t// not typed maps\n\tif (elem->isUnspec () && key->isUnspec ()) return true;\n\n\tYCPMap map = value->asMap ();\n\n\tfor (YCPMap::const_iterator pos = map->begin(); pos != map->end(); ++pos)\n\t{\n\t    if (! canPropagate (pos->first, key) )\n\t    {\n\t\treturn false;\n\t    }\n\t    if (! canPropagate (pos->second, elem) )\n\t    {\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n\n    if (to_type->isFunction ()\n\t&& value->isCode ())\n    {\n\tYCodePtr c = value->asCode ()->code ();\n\tconstFunctionTypePtr t = (constFunctionTypePtr)to_type;\n\treturn c->kind () == ycFunction;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEPropagate {\n  bool\n  YEPropagate::canPropagate(const YCPValue& value, constTypePtr to_type) const\n  {\n      if (value.isNull()\n  \t|| value->isVoid()\t\t\t\t\t// value is nil, this is allowed everywhere\n  \t|| to_type->isAny ()\t\t\t\t\t// casting to any\n  \t|| to_type->isUnspec ()\t\t\t\t\t// casting to unspec\n  \t|| ( to_type->isBasetype ()\t\t\t\t// casting to equivalent base type\n  \t     && value->valuetype () == to_type->valueType ()))\n      {\n  \treturn true;\t\t\t\t\t\t// this is all ok\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"to type: %s\", to_type->toString ().c_str () );\n  #endif\n      if (to_type->isList ()\t\t\t\t\t// casting to a list\n  \t&& value->isList ())\n      {\n  \t// check types of all elements\n  \tconstTypePtr elem = ((constListTypePtr)to_type)->type ();\n  \tif (elem->isAny ()) return true;\n  \tif (elem->isUnspec ()) return true;\t\t\t// untyped list\n  \n  \tYCPList v = value->asList ();\n  \n  \tfor (int i=0; i < v->size (); i++ )\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"testing %s\", v->value (i)->toString ().c_str ());\n  #endif\n  \t    if (! canPropagate (v->value (i), elem) )\n  \t    {\n  \t\treturn false;\n  \t    }\n  \t}\n  \treturn true;\n      }\n  \n      if (to_type->isMap ()\t\t\t\t\t// casting to a map\n  \t&& value->isMap ())\n      {\n  \t// check types of all elements\n  \tconstTypePtr key = ((constMapTypePtr)to_type)->keytype ();\n  \tconstTypePtr elem = ((constMapTypePtr)to_type)->valuetype ();\n  \n  \tif (elem->isAny () && key->isAny ()) return true;\t// map<any,any>\n  \n  \t// not typed maps\n  \tif (elem->isUnspec () && key->isUnspec ()) return true;\n  \n  \tYCPMap map = value->asMap ();\n  \n  \tfor (YCPMap::const_iterator pos = map->begin(); pos != map->end(); ++pos)\n  \t{\n  \t    if (! canPropagate (pos->first, key) )\n  \t    {\n  \t\treturn false;\n  \t    }\n  \t    if (! canPropagate (pos->second, elem) )\n  \t    {\n  \t\treturn false;\n  \t    }\n  \t}\n  \treturn true;\n      }\n  \n      if (to_type->isFunction ()\n  \t&& value->isCode ())\n      {\n  \tYCodePtr c = value->asCode ()->code ();\n  \tconstFunctionTypePtr t = (constFunctionTypePtr)to_type;\n  \treturn c->kind () == ycFunction;\n      }\n  \n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_to->match",
          "args": [
            "v->asReference ()->entry ()->type ()"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1739-1797",
          "snippet": "int\nFunctionType::match (constTypePtr expected) const\n{\n#if DO_DEBUG\n    y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n#endif\n    int bm = basematch (expected);\n\n    if (bm == 1) return 0;\t\t// any or wildcard match\n\n    if ((bm == 0\n\t    && expected->isFunction()))\n    {\n\tconstFunctionTypePtr ft (expected);\n\tif (m_returntype->match (ft->m_returntype) < 0)\n\t{\n#if DO_DEBUG\n//\t    y2debug (\"return type mismatch\");\n#endif\n\t    return -1;\n\t}\n\n\t// expected parameter size\n\tunsigned int esize = ft->parameterCount();\n\n\tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n\t    && (m_arguments == 0))\n\t{\n\t    return 0;\n\t}\n\n\tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n\tif (!wildcard)\n\t{\n\t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n\t    {\n#if DO_DEBUG\n//\t\ty2debug (\"parameter count mismatch\");\n#endif\n\t\treturn -1;\n\t    }\n\t}\n\n\tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n\t{\n\t    if (index > esize\t\t\t// don't check wildcard parameters\n\t\t&& wildcard)\n\t    {\n\t\tbreak;\n\t    }\n\t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n\t    {\n\t\treturn -1;\n\t    }\n\t}\n\treturn 0;\n    }\n    return -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nFunctionType {\n  int\n  FunctionType::match (constTypePtr expected) const\n  {\n  #if DO_DEBUG\n      y2debug (\"FunctionType::match '%s', expected '%s'\", toString().c_str(), expected->toString().c_str());\n  #endif\n      int bm = basematch (expected);\n  \n      if (bm == 1) return 0;\t\t// any or wildcard match\n  \n      if ((bm == 0\n  \t    && expected->isFunction()))\n      {\n  \tconstFunctionTypePtr ft (expected);\n  \tif (m_returntype->match (ft->m_returntype) < 0)\n  \t{\n  #if DO_DEBUG\n  //\t    y2debug (\"return type mismatch\");\n  #endif\n  \t    return -1;\n  \t}\n  \n  \t// expected parameter size\n  \tunsigned int esize = ft->parameterCount();\n  \n  \tif ((esize == 0)\t\t\t\t\t\t// both (void) ?\n  \t    && (m_arguments == 0))\n  \t{\n  \t    return 0;\n  \t}\n  \n  \tbool wildcard = ft->parameterType(esize-1)->isWildcard();\t// expect ... as last arg ?\n  \tif (!wildcard)\n  \t{\n  \t    if ((esize != 0 && m_arguments == NULL) || (esize != m_arguments->parameterCount()))\n  \t    {\n  #if DO_DEBUG\n  //\t\ty2debug (\"parameter count mismatch\");\n  #endif\n  \t\treturn -1;\n  \t    }\n  \t}\n  \n  \tfor (unsigned index = 0; index < m_arguments->parameterCount(); index++)\n  \t{\n  \t    if (index > esize\t\t\t// don't check wildcard parameters\n  \t\t&& wildcard)\n  \t    {\n  \t\tbreak;\n  \t    }\n  \t    if (m_arguments->parameterType(index)->match (ft->parameterType(index)) < 0)\n  \t    {\n  \t\treturn -1;\n  \t    }\n  \t}\n  \treturn 0;\n      }\n      return -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->asReference",
          "args": [],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "asReference",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "239-249",
          "snippet": "YCPReference\nYCPValueRep::asReference() const\n{\n    if (!isReference())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Reference!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPReference (static_cast<const YCPReferenceRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPReference\n  YCPValueRep::asReference() const\n  {\n      if (!isReference())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Reference!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPReference (static_cast<const YCPReferenceRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->isReference",
          "args": [],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "isReference",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "76-76",
          "snippet": "bool YCPValueRep::isReference()\t  const { return valuetype() == YT_REFERENCE; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isReference()\t  const { return valuetype() == YT_REFERENCE; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPInteger",
          "args": [
            "(long long)(v->asFloat()->value())"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "YCPInteger",
          "container": "YCPInteger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPInteger.cc",
          "lines": "142-145",
          "snippet": "YCPInteger::YCPInteger (bytecodeistream & str)\n    : YCPValue (new YCPIntegerRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/y2log.h\"\n\nYCPInteger {\n  YCPInteger::YCPInteger (bytecodeistream & str)\n      : YCPValue (new YCPIntegerRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->asFloat",
          "args": [],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "asFloat",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "118-128",
          "snippet": "YCPFloat\nYCPValueRep::asFloat() const\n{\n    if (!isFloat())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Float!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPFloat (static_cast<const YCPFloatRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPFloat\n  YCPValueRep::asFloat() const\n  {\n      if (!isFloat())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Float!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPFloat (static_cast<const YCPFloatRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->isFloat",
          "args": [],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "isFloat",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "64-64",
          "snippet": "bool YCPValueRep::isFloat()       const { return valuetype() == YT_FLOAT; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isFloat()       const { return valuetype() == YT_FLOAT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_to->isInteger",
          "args": [],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "63-63",
          "snippet": "bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPFloat",
          "args": [
            "v->asInteger()->value()"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "YCPFloat",
          "container": "YCPFloat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPFloat.cc",
          "lines": "119-122",
          "snippet": "YCPFloat::YCPFloat (bytecodeistream & str)\n    : YCPValue (new YCPFloatRep (fromStream (str).c_str()))\n{\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/y2log.h\"\n#include <ctype.h>\n\nYCPFloat {\n  YCPFloat::YCPFloat (bytecodeistream & str)\n      : YCPValue (new YCPFloatRep (fromStream (str).c_str()))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->asInteger",
          "args": [],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "asInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "106-116",
          "snippet": "YCPInteger\nYCPValueRep::asInteger() const\n{\n    if (!isInteger())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPInteger\n  YCPValueRep::asInteger() const\n  {\n      if (!isInteger())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->isVoid",
          "args": [],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_value->evaluate",
          "args": [],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEPropagate::evaluate(%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEPropagate {\n  YCPValue\n  YEPropagate::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug (\"YEPropagate::evaluate(%s)\\n\", toString().c_str());\n  #endif\n      if (cse)\n      {\n  \treturn YCPNull();\n      }\n  \n      YCPValue v = m_value->evaluate ();\n      if (v.isNull() || v->isVoid ())\n      {\n  \treturn v;\n      }\n  \n      // If this proves too slow, maybe optimize it away completely\n      // by inventing YEPropagateIntegerFloat\n      if (m_to->isFloat()\n  \t&& v->isInteger())\n      {\n  \treturn YCPFloat (v->asInteger()->value());\n      }\n      else if (m_to->isInteger()\n  \t     && v->isFloat())\n      {\n  \treturn YCPInteger ((long long)(v->asFloat()->value()));\n      }\n      else if (v->isReference () \n  \t&& m_to->match (v->asReference ()->entry ()->type ()) == 0)\n      {\n  \treturn v;\n      }\n      else if (canPropagate (v, m_to))\n      {\n  \treturn v;\n      }\n  \n      ycp2error (\"Can't convert value '%s' to type '%s'\", v->toString().c_str(), m_to->toString().c_str());\n  \n      return YCPNull ();\n  }\n}"
  },
  {
    "function_name": "canPropagate",
    "container": "YEPropagate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1068-1144",
    "snippet": "bool\nYEPropagate::canPropagate(const YCPValue& value, constTypePtr to_type) const\n{\n    if (value.isNull()\n\t|| value->isVoid()\t\t\t\t\t// value is nil, this is allowed everywhere\n\t|| to_type->isAny ()\t\t\t\t\t// casting to any\n\t|| to_type->isUnspec ()\t\t\t\t\t// casting to unspec\n\t|| ( to_type->isBasetype ()\t\t\t\t// casting to equivalent base type\n\t     && value->valuetype () == to_type->valueType ()))\n    {\n\treturn true;\t\t\t\t\t\t// this is all ok\n    }\n\n#if DO_DEBUG\n    y2debug (\"to type: %s\", to_type->toString ().c_str () );\n#endif\n    if (to_type->isList ()\t\t\t\t\t// casting to a list\n\t&& value->isList ())\n    {\n\t// check types of all elements\n\tconstTypePtr elem = ((constListTypePtr)to_type)->type ();\n\tif (elem->isAny ()) return true;\n\tif (elem->isUnspec ()) return true;\t\t\t// untyped list\n\n\tYCPList v = value->asList ();\n\n\tfor (int i=0; i < v->size (); i++ )\n\t{\n#if DO_DEBUG\n\t    y2debug (\"testing %s\", v->value (i)->toString ().c_str ());\n#endif\n\t    if (! canPropagate (v->value (i), elem) )\n\t    {\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n\n    if (to_type->isMap ()\t\t\t\t\t// casting to a map\n\t&& value->isMap ())\n    {\n\t// check types of all elements\n\tconstTypePtr key = ((constMapTypePtr)to_type)->keytype ();\n\tconstTypePtr elem = ((constMapTypePtr)to_type)->valuetype ();\n\n\tif (elem->isAny () && key->isAny ()) return true;\t// map<any,any>\n\n\t// not typed maps\n\tif (elem->isUnspec () && key->isUnspec ()) return true;\n\n\tYCPMap map = value->asMap ();\n\n\tfor (YCPMap::const_iterator pos = map->begin(); pos != map->end(); ++pos)\n\t{\n\t    if (! canPropagate (pos->first, key) )\n\t    {\n\t\treturn false;\n\t    }\n\t    if (! canPropagate (pos->second, elem) )\n\t    {\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n\n    if (to_type->isFunction ()\n\t&& value->isCode ())\n    {\n\tYCodePtr c = value->asCode ()->code ();\n\tconstFunctionTypePtr t = (constFunctionTypePtr)to_type;\n\treturn c->kind () == ycFunction;\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->kind",
          "args": [],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": "YEFunctionPointer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YExpression.h",
          "lines": "499-499",
          "snippet": "virtual ykind kind () const { return yeFunctionPointer; }",
          "includes": [
            "#include \"y2/Y2Function.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"y2/Y2Function.h\"\n#include \"ycp/YCode.h\"\n#include <string>\n#include <iosfwd>\n\nYEFunctionPointer {\n  virtual ykind kind () const { return yeFunctionPointer; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asCode",
          "args": [],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "asCode",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "215-225",
          "snippet": "YCPCode\nYCPValueRep::asCode() const\n{\n    if (!isCode())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Code !\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPCode (static_cast<const YCPCodeRep*>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPCode\n  YCPValueRep::asCode() const\n  {\n      if (!isCode())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Code !\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPCode (static_cast<const YCPCodeRep*>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->isCode",
          "args": [],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "isCode",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "72-72",
          "snippet": "bool YCPValueRep::isCode()\t  const { return valuetype() == YT_CODE; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isCode()\t  const { return valuetype() == YT_CODE; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_type->isFunction",
          "args": [],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "isFunction",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "303-303",
          "snippet": "bool isFunction () const\t{ return m_kind == FunctionT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isFunction () const\t{ return m_kind == FunctionT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "canPropagate",
          "args": [
            "pos->second",
            "elem"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "canPropagate",
          "container": "YEPropagate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "1068-1144",
          "snippet": "bool\nYEPropagate::canPropagate(const YCPValue& value, constTypePtr to_type) const\n{\n    if (value.isNull()\n\t|| value->isVoid()\t\t\t\t\t// value is nil, this is allowed everywhere\n\t|| to_type->isAny ()\t\t\t\t\t// casting to any\n\t|| to_type->isUnspec ()\t\t\t\t\t// casting to unspec\n\t|| ( to_type->isBasetype ()\t\t\t\t// casting to equivalent base type\n\t     && value->valuetype () == to_type->valueType ()))\n    {\n\treturn true;\t\t\t\t\t\t// this is all ok\n    }\n\n#if DO_DEBUG\n    y2debug (\"to type: %s\", to_type->toString ().c_str () );\n#endif\n    if (to_type->isList ()\t\t\t\t\t// casting to a list\n\t&& value->isList ())\n    {\n\t// check types of all elements\n\tconstTypePtr elem = ((constListTypePtr)to_type)->type ();\n\tif (elem->isAny ()) return true;\n\tif (elem->isUnspec ()) return true;\t\t\t// untyped list\n\n\tYCPList v = value->asList ();\n\n\tfor (int i=0; i < v->size (); i++ )\n\t{\n#if DO_DEBUG\n\t    y2debug (\"testing %s\", v->value (i)->toString ().c_str ());\n#endif\n\t    if (! canPropagate (v->value (i), elem) )\n\t    {\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n\n    if (to_type->isMap ()\t\t\t\t\t// casting to a map\n\t&& value->isMap ())\n    {\n\t// check types of all elements\n\tconstTypePtr key = ((constMapTypePtr)to_type)->keytype ();\n\tconstTypePtr elem = ((constMapTypePtr)to_type)->valuetype ();\n\n\tif (elem->isAny () && key->isAny ()) return true;\t// map<any,any>\n\n\t// not typed maps\n\tif (elem->isUnspec () && key->isUnspec ()) return true;\n\n\tYCPMap map = value->asMap ();\n\n\tfor (YCPMap::const_iterator pos = map->begin(); pos != map->end(); ++pos)\n\t{\n\t    if (! canPropagate (pos->first, key) )\n\t    {\n\t\treturn false;\n\t    }\n\t    if (! canPropagate (pos->second, elem) )\n\t    {\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n\n    if (to_type->isFunction ()\n\t&& value->isCode ())\n    {\n\tYCodePtr c = value->asCode ()->code ();\n\tconstFunctionTypePtr t = (constFunctionTypePtr)to_type;\n\treturn c->kind () == ycFunction;\n    }\n\n    return false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "map->end",
          "args": [],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->begin",
          "args": [],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asMap",
          "args": [],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "asMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "203-213",
          "snippet": "YCPMap\nYCPValueRep::asMap() const\n{\n    if (!isMap())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPMap (static_cast<const YCPMapRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPMap\n  YCPValueRep::asMap() const\n  {\n      if (!isMap())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Map!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPMap (static_cast<const YCPMapRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key->isUnspec",
          "args": [],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "isUnspec",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "281-281",
          "snippet": "bool isUnspec () const\t{ return m_kind == UnspecT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isUnspec () const\t{ return m_kind == UnspecT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key->isAny",
          "args": [],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "isAny",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "283-283",
          "snippet": "bool isAny () const\t\t{ return m_kind == AnyT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isAny () const\t\t{ return m_kind == AnyT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->isMap",
          "args": [],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "isMap",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "71-71",
          "snippet": "bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isMap()         const { return valuetype() == YT_MAP; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->value",
          "args": [
            "i"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YEList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "773-783",
          "snippet": "YCodePtr\nYEList::value (int index) const\n{\n    ycodelist_t *element = m_first;\n    while (element && index)\n    {\n\telement = element->next;\n\tindex--;\n    }\n    return element != NULL ? element->code : NULL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEList {\n  YCodePtr\n  YEList::value (int index) const\n  {\n      ycodelist_t *element = m_first;\n      while (element && index)\n      {\n  \telement = element->next;\n  \tindex--;\n      }\n      return element != NULL ? element->code : NULL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"testing %s\"",
            "v->value (i)->toString ().c_str ()"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->value",
          "args": [],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->size",
          "args": [],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->asList",
          "args": [],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->isList",
          "args": [],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"to type: %s\"",
            "to_type->toString ().c_str ()"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_type->toString",
          "args": [],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_type->valueType",
          "args": [],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "valueType",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1876-1909",
          "snippet": "YCPValueType\nType::valueType () const\n{\n    switch (m_kind)\n    {\n\tcase UnspecT:\treturn YT_ERROR;\n\tcase VoidT:\treturn YT_VOID;\n\tcase AnyT:\treturn YT_VOID;\n\tcase BooleanT:\treturn YT_BOOLEAN;\n\tcase IntegerT:\treturn YT_INTEGER;\n\tcase FloatT:\treturn YT_FLOAT;\n\tcase StringT:\treturn YT_STRING ;\n\tcase ByteblockT:return YT_BYTEBLOCK;\n\tcase PathT:\treturn YT_PATH;\n\tcase TermT:\treturn YT_TERM;\n\tcase SymbolT:\treturn YT_SYMBOL;\n\tcase ErrorT:\treturn YT_ERROR;\n\tcase LocaleT:\treturn YT_STRING;\n\tcase WildcardT: return YT_ERROR;\n\tcase FlexT:\treturn YT_ERROR;\n\tcase NFlexT:\treturn YT_ERROR;\n\n\tcase VariableT: return YT_ENTRY;\n\tcase BlockT:\treturn YT_CODE;\n\tcase ListT:\treturn YT_LIST;\n\tcase MapT:\treturn YT_MAP;\n\tcase TupleT:\treturn YT_ERROR;\t// not expressable\n\tcase FunctionT:\treturn YT_ERROR;\t// not expressable\n\n\tcase NilT:\treturn YT_VOID;\n    }\n\n    return YT_ERROR;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\nType {\n  YCPValueType\n  Type::valueType () const\n  {\n      switch (m_kind)\n      {\n  \tcase UnspecT:\treturn YT_ERROR;\n  \tcase VoidT:\treturn YT_VOID;\n  \tcase AnyT:\treturn YT_VOID;\n  \tcase BooleanT:\treturn YT_BOOLEAN;\n  \tcase IntegerT:\treturn YT_INTEGER;\n  \tcase FloatT:\treturn YT_FLOAT;\n  \tcase StringT:\treturn YT_STRING ;\n  \tcase ByteblockT:return YT_BYTEBLOCK;\n  \tcase PathT:\treturn YT_PATH;\n  \tcase TermT:\treturn YT_TERM;\n  \tcase SymbolT:\treturn YT_SYMBOL;\n  \tcase ErrorT:\treturn YT_ERROR;\n  \tcase LocaleT:\treturn YT_STRING;\n  \tcase WildcardT: return YT_ERROR;\n  \tcase FlexT:\treturn YT_ERROR;\n  \tcase NFlexT:\treturn YT_ERROR;\n  \n  \tcase VariableT: return YT_ENTRY;\n  \tcase BlockT:\treturn YT_CODE;\n  \tcase ListT:\treturn YT_LIST;\n  \tcase MapT:\treturn YT_MAP;\n  \tcase TupleT:\treturn YT_ERROR;\t// not expressable\n  \tcase FunctionT:\treturn YT_ERROR;\t// not expressable\n  \n  \tcase NilT:\treturn YT_VOID;\n      }\n  \n      return YT_ERROR;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->valuetype",
          "args": [],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "valuetype",
          "container": "YCPSymbolRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "69-73",
          "snippet": "YCPValueType\nYCPSymbolRep::valuetype() const\n{\n    return YT_SYMBOL;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbolRep {\n  YCPValueType\n  YCPSymbolRep::valuetype() const\n  {\n      return YT_SYMBOL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_type->isBasetype",
          "args": [],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "isBasetype",
          "container": "FunctionType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "502-502",
          "snippet": "bool isBasetype () const { return false; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nFunctionType {\n  bool isBasetype () const { return false; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->isVoid",
          "args": [],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEPropagate {\n  bool\n  YEPropagate::canPropagate(const YCPValue& value, constTypePtr to_type) const\n  {\n      if (value.isNull()\n  \t|| value->isVoid()\t\t\t\t\t// value is nil, this is allowed everywhere\n  \t|| to_type->isAny ()\t\t\t\t\t// casting to any\n  \t|| to_type->isUnspec ()\t\t\t\t\t// casting to unspec\n  \t|| ( to_type->isBasetype ()\t\t\t\t// casting to equivalent base type\n  \t     && value->valuetype () == to_type->valueType ()))\n      {\n  \treturn true;\t\t\t\t\t\t// this is all ok\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"to type: %s\", to_type->toString ().c_str () );\n  #endif\n      if (to_type->isList ()\t\t\t\t\t// casting to a list\n  \t&& value->isList ())\n      {\n  \t// check types of all elements\n  \tconstTypePtr elem = ((constListTypePtr)to_type)->type ();\n  \tif (elem->isAny ()) return true;\n  \tif (elem->isUnspec ()) return true;\t\t\t// untyped list\n  \n  \tYCPList v = value->asList ();\n  \n  \tfor (int i=0; i < v->size (); i++ )\n  \t{\n  #if DO_DEBUG\n  \t    y2debug (\"testing %s\", v->value (i)->toString ().c_str ());\n  #endif\n  \t    if (! canPropagate (v->value (i), elem) )\n  \t    {\n  \t\treturn false;\n  \t    }\n  \t}\n  \treturn true;\n      }\n  \n      if (to_type->isMap ()\t\t\t\t\t// casting to a map\n  \t&& value->isMap ())\n      {\n  \t// check types of all elements\n  \tconstTypePtr key = ((constMapTypePtr)to_type)->keytype ();\n  \tconstTypePtr elem = ((constMapTypePtr)to_type)->valuetype ();\n  \n  \tif (elem->isAny () && key->isAny ()) return true;\t// map<any,any>\n  \n  \t// not typed maps\n  \tif (elem->isUnspec () && key->isUnspec ()) return true;\n  \n  \tYCPMap map = value->asMap ();\n  \n  \tfor (YCPMap::const_iterator pos = map->begin(); pos != map->end(); ++pos)\n  \t{\n  \t    if (! canPropagate (pos->first, key) )\n  \t    {\n  \t\treturn false;\n  \t    }\n  \t    if (! canPropagate (pos->second, elem) )\n  \t    {\n  \t\treturn false;\n  \t    }\n  \t}\n  \treturn true;\n      }\n  \n      if (to_type->isFunction ()\n  \t&& value->isCode ())\n      {\n  \tYCodePtr c = value->asCode ()->code ();\n  \tconstFunctionTypePtr t = (constFunctionTypePtr)to_type;\n  \treturn c->kind () == ycFunction;\n      }\n  \n      return false;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YEPropagate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1061-1065",
    "snippet": "string\nYEPropagate::toString() const\n{\n    return string (\"/* \") + m_from->toString().c_str() + \" -> \" + m_to->toString().c_str() + \" */\" + m_value->toString();\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_value->toString",
          "args": [],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"/* \""
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEPropagate {\n  string\n  YEPropagate::toString() const\n  {\n      return string (\"/* \") + m_from->toString().c_str() + \" -> \" + m_to->toString().c_str() + \" */\" + m_value->toString();\n  }\n}"
  },
  {
    "function_name": "~YEPropagate",
    "container": "YEPropagate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1056-1058",
    "snippet": "YEPropagate::~YEPropagate ()\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEPropagate {\n  YEPropagate::~YEPropagate ()\n  {\n  }\n}"
  },
  {
    "function_name": "YEPropagate",
    "container": "YEPropagate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1047-1053",
    "snippet": "YEPropagate::YEPropagate (bytecodeistream & str)\n    : YCode ()\n    , m_from (Bytecode::readType (str))\n    , m_to (Bytecode::readType (str))\n{\n    m_value = Bytecode::readCode (str);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readType",
          "args": [
            "str"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "readType",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "349-387",
          "snippet": "TypePtr\nBytecode::readType (bytecodeistream & str)\n{\n    int kind = readInt32 (str);\n#if DO_DEBUG\ny2debug (\"Bytecode::readType(%d)\", kind);\n#endif\n    switch ((Type::tkind)kind)\n    {\n\tcase Type::UnspecT:\n\tcase Type::ErrorT:\n\tcase Type::AnyT:\n\tcase Type::BooleanT:\n\tcase Type::ByteblockT:\n\tcase Type::FloatT:\n\tcase Type::IntegerT:\n\tcase Type::LocaleT:\n\tcase Type::PathT:\n\tcase Type::StringT:\n\tcase Type::SymbolT:\n\tcase Type::TermT:\n\tcase Type::VoidT:\n\tcase Type::WildcardT:\n\tcase Type::FlexT:\n\tcase Type::NilT:\n\t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n\tbreak;\n\n\tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n\tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n\tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n\tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n\tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n\tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n\tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n    }\n    y2error (\"Unhandled type kind %d\", kind);\n    return Type::Error->clone();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  TypePtr\n  Bytecode::readType (bytecodeistream & str)\n  {\n      int kind = readInt32 (str);\n  #if DO_DEBUG\n  y2debug (\"Bytecode::readType(%d)\", kind);\n  #endif\n      switch ((Type::tkind)kind)\n      {\n  \tcase Type::UnspecT:\n  \tcase Type::ErrorT:\n  \tcase Type::AnyT:\n  \tcase Type::BooleanT:\n  \tcase Type::ByteblockT:\n  \tcase Type::FloatT:\n  \tcase Type::IntegerT:\n  \tcase Type::LocaleT:\n  \tcase Type::PathT:\n  \tcase Type::StringT:\n  \tcase Type::SymbolT:\n  \tcase Type::TermT:\n  \tcase Type::VoidT:\n  \tcase Type::WildcardT:\n  \tcase Type::FlexT:\n  \tcase Type::NilT:\n  \t    return TypePtr ( new Type ((Type::tkind)kind, str) );\n  \tbreak;\n  \n  \tcase Type::NFlexT:\treturn TypePtr ( new NFlexType (str) ); break;\n  \tcase Type::VariableT:\treturn TypePtr ( new VariableType (str) ); break;\n  \tcase Type::BlockT:\treturn TypePtr ( new BlockType (str) ); break;\n  \tcase Type::ListT:\treturn TypePtr ( new ListType (str) ); break;\n  \tcase Type::MapT:\treturn TypePtr ( new MapType (str) ); break;\n  \tcase Type::TupleT:\treturn TypePtr ( new TupleType (str) ); break;\n  \tcase Type::FunctionT:\treturn TypePtr ( new FunctionType (str) ); break;\n      }\n      y2error (\"Unhandled type kind %d\", kind);\n      return Type::Error->clone();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEPropagate {\n  YEPropagate::YEPropagate (bytecodeistream & str)\n      : YCode ()\n      , m_from (Bytecode::readType (str))\n      , m_to (Bytecode::readType (str))\n  {\n      m_value = Bytecode::readCode (str);\n  }\n}"
  },
  {
    "function_name": "YEPropagate",
    "container": "YEPropagate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "1032-1044",
    "snippet": "YEPropagate::YEPropagate (YCodePtr value, constTypePtr from, constTypePtr to)\n    : YCode ()\n    , m_from (from)\n    , m_to (to)\n    , m_value (value)\n{\n    //FIXME: save declaration/ptr to propagation function instead of from & to\n    if (m_from->isFloat())\n    {\n\textern ExecutionEnvironment ee;\n\tycp2warning (ee.filename().c_str(), ee.linenumber(), \"Implicit float conversion will loose accuracy\");\n    }\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ycp2warning",
          "args": [
            "ee.filename().c_str()",
            "ee.linenumber()",
            "\"Implicit float conversion will loose accuracy\""
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee.linenumber",
          "args": [],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "linenumber",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "41-45",
          "snippet": "int\nExecutionEnvironment::linenumber () const\n{\n    return m_linenumber;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  int\n  ExecutionEnvironment::linenumber () const\n  {\n      return m_linenumber;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.filename",
          "args": [],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "filename",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "335-339",
          "snippet": "string\nScanner::filename () const\n{\n    return m_filename;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  string\n  Scanner::filename () const\n  {\n      return m_filename;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_from->isFloat",
          "args": [],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "isFloat",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "64-64",
          "snippet": "bool YCPValueRep::isFloat()       const { return valuetype() == YT_FLOAT; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isFloat()       const { return valuetype() == YT_FLOAT; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEPropagate {\n  YEPropagate::YEPropagate (YCodePtr value, constTypePtr from, constTypePtr to)\n      : YCode ()\n      , m_from (from)\n      , m_to (to)\n      , m_value (value)\n  {\n      //FIXME: save declaration/ptr to propagation function instead of from & to\n      if (m_from->isFloat())\n      {\n  \textern ExecutionEnvironment ee;\n  \tycp2warning (ee.filename().c_str(), ee.linenumber(), \"Implicit float conversion will loose accuracy\");\n      }\n  }\n}"
  },
  {
    "function_name": "type",
    "container": "YEMap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "994-1012",
    "snippet": "constTypePtr\nYEMap::type () const\n{\n\n    mapval_t *element = m_first;\n\n    constTypePtr res_key = m_first->key->type ();\n    constTypePtr res_value = m_first->value->type ();\n    element = element->next;\n\n    while (element)\n    {\n\tres_key = res_key->commontype (element->key->type ());\n\tres_value = res_value->commontype (element->value->type ());\n\telement = element->next;\n    }\n    \n    return new MapType (res_key, res_value);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "res_value->commontype",
          "args": [
            "element->value->type ()"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "commontype",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1917-1944",
          "snippet": "constTypePtr\nType::commontype (constTypePtr type) const\n{\n    if (isVoid())\t\t// 'nil' does not influence the type\n    {\n\treturn type;\n    }\n\n    if (match (type) >= 0)\n    {\n#if DO_DEBUG\n\ty2debug (\"commontype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n    else if (!isAny()\n\t     && type->match (this) >= 0)\n    {\n#if DO_DEBUG\n    y2debug (\"commontype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n#if DO_DEBUG\n    y2debug (\"commontype '%s' ('%s') -> any\", toString().c_str(), type->toString().c_str());\n#endif\n    return Type::Any;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "const constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));\n\nType {\n  constTypePtr\n  Type::commontype (constTypePtr type) const\n  {\n      if (isVoid())\t\t// 'nil' does not influence the type\n      {\n  \treturn type;\n      }\n  \n      if (match (type) >= 0)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"commontype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n      else if (!isAny()\n  \t     && type->match (this) >= 0)\n      {\n  #if DO_DEBUG\n      y2debug (\"commontype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n  #if DO_DEBUG\n      y2debug (\"commontype '%s' ('%s') -> any\", toString().c_str(), type->toString().c_str());\n  #endif\n      return Type::Any;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "element->value->type",
          "args": [],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEMap {\n  constTypePtr\n  YEMap::type () const\n  {\n  \n      mapval_t *element = m_first;\n  \n      constTypePtr res_key = m_first->key->type ();\n      constTypePtr res_value = m_first->value->type ();\n      element = element->next;\n  \n      while (element)\n      {\n  \tres_key = res_key->commontype (element->key->type ());\n  \tres_value = res_value->commontype (element->value->type ());\n  \telement = element->next;\n      }\n      \n      return new MapType (res_key, res_value);\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YEMap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "909-942",
    "snippet": "YCPValue\nYEMap::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug (\"YEMap::evaluate (%s)\\n\", toString().c_str());\n#endif\n    YCPMap map;\n    mapval_t *element = m_first;\n    while (element)\n    {\n\tYCPValue key = element->key->evaluate (cse);\n\tif (key.isNull())\n\t{\n\t    if (element->key->isConstant())\n\t    {\n\t\tycp2error (\"Key evaluates to 'nil'\");\n\t\treturn YCPNull ();\n\t    }\n\t    if (cse)\t\t// parse time checking, not a constant\n\t    {\n\t\treturn key;\n\t    }\n\t}\n\tYCPValue value = element->value->evaluate (cse);\n\tif (value.isNull())\n\t{\n\t    if (cse)\t\t// parse time checking, not a constant\n\t\treturn value;\n\t}\n\tmap->add (key, value);\n\telement = element->next;\n    }\n    return map;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->add",
          "args": [
            "key",
            "value"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "50-76",
          "snippet": "void\nYCPMapRep::add (const YCPValue& key, const YCPValue& value)\n{\n    if (!key->isString()\n\t&& !key->isInteger()\n\t&& !key->isSymbol())\n    {\n\tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n\treturn;\n    }\n\n    // Note: 'stl_map[key] = value' would create a temporary object using the\n    // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n    // 24.\n\n    YCPMap::iterator pos = stl_map.lower_bound(key);\n    if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n    {\n\tpos->second = value;\n    }\n    else\n    {\n\t// pos is just a hint but can avoid a second search through the map\n\tstl_map.insert(pos, YCPMap::value_type(key, value));\n    }\n\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void\n  YCPMapRep::add (const YCPValue& key, const YCPValue& value)\n  {\n      if (!key->isString()\n  \t&& !key->isInteger()\n  \t&& !key->isSymbol())\n      {\n  \tycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n  \treturn;\n      }\n  \n      // Note: 'stl_map[key] = value' would create a temporary object using the\n      // default constructor for YCPValue. See Scott Meyers, Effective STL, Item\n      // 24.\n  \n      YCPMap::iterator pos = stl_map.lower_bound(key);\n      if (pos != stl_map.end() && !YCPMap::key_compare()(key, pos->first))\n      {\n  \tpos->second = value;\n      }\n      else\n      {\n  \t// pos is just a hint but can avoid a second search through the map\n  \tstl_map.insert(pos, YCPMap::value_type(key, value));\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "element->value->evaluate",
          "args": [
            "cse"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "YEFunctionPointer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3191-3273",
          "snippet": "YCPValue\nYEFunctionPointer::evaluate (bool cse)\n{\n    if (cse)\n    {\n\treturn YCPNull();\n    }\n\n#if DO_DEBUG\n    y2debug (\"YEFunctionPointer::evaluate (%s)\\n\", toString().c_str());\n#endif\n\n    YCPValue ptr = m_sentry->value ();\n    if (ptr.isNull () || ! ptr->isReference ())\n    {\n\tycp2error (\"Function pointer (%s) is %s\"\n\t    , m_sentry->toString().c_str()\n\t    , ptr.isNull () ? \"NULL\" : ptr->toString ().c_str ());\n\treturn YCPVoid ();\n    }\n    \n    SymbolEntryPtr ptr_sentry = ptr->asReference ()->entry ();\n\n    Y2Namespace* ns = const_cast<Y2Namespace*> (ptr_sentry->nameSpace ());\n\n    m_functioncall = ns->createFunctionCall (\n\tptr_sentry->name (),\n\tptr_sentry->type ()\n    );\n    \n    if (!m_functioncall)\n    {\n\ty2internal (\"Cannot get function call object for %s\", m_sentry->toString().c_str());\n\treturn YCPVoid ();\n    }\n\n    // FIXME: this could fail    \n    m_functioncall->reset ();\n    \n    YCPValue m_params [m_next_param_id];\n\n    for (unsigned int p = 0; p < m_next_param_id ; p++)\n    {\n\t// FIXME, check for symbol or block type and suppress evaluation\n\n\tYCPValue value = m_parameters[p]->evaluate ();\n\n\tif (value.isNull())\n\t{\n\t    ycp2error (\"Parameter eval failed (%s)\", m_parameters[p]->toString().c_str());\n\t    return value;\n\t}\n\t\n#if DO_DEBUG\n\ty2debug (\"parameter %d = (%s)\", p, value->toString().c_str());\n#endif\n\n\tm_params [p] = value;\n    }\n\n    // set the parameters for Y2Function\n    for (unsigned int p = 0; p < m_next_param_id ; p++)\n    {\n\tm_functioncall->attachParameter (m_params[p], p);\n    }\n    \n    extern ExecutionEnvironment ee;\n\n    // save the context info\n    int linenumber = ee.linenumber ();\n    string filename = ee.filename ();\n\n    YCPValue value = m_functioncall->evaluateCall ();\n\n    // restore the context info\n    ee.setLinenumber (linenumber);\n    ee.setFilename (filename);\n\n#if DO_DEBUG\n    y2debug(\"evaluate done (%s) = '%s'\", qualifiedName ().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n    return value;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEFunctionPointer {\n  YCPValue\n  YEFunctionPointer::evaluate (bool cse)\n  {\n      if (cse)\n      {\n  \treturn YCPNull();\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"YEFunctionPointer::evaluate (%s)\\n\", toString().c_str());\n  #endif\n  \n      YCPValue ptr = m_sentry->value ();\n      if (ptr.isNull () || ! ptr->isReference ())\n      {\n  \tycp2error (\"Function pointer (%s) is %s\"\n  \t    , m_sentry->toString().c_str()\n  \t    , ptr.isNull () ? \"NULL\" : ptr->toString ().c_str ());\n  \treturn YCPVoid ();\n      }\n      \n      SymbolEntryPtr ptr_sentry = ptr->asReference ()->entry ();\n  \n      Y2Namespace* ns = const_cast<Y2Namespace*> (ptr_sentry->nameSpace ());\n  \n      m_functioncall = ns->createFunctionCall (\n  \tptr_sentry->name (),\n  \tptr_sentry->type ()\n      );\n      \n      if (!m_functioncall)\n      {\n  \ty2internal (\"Cannot get function call object for %s\", m_sentry->toString().c_str());\n  \treturn YCPVoid ();\n      }\n  \n      // FIXME: this could fail    \n      m_functioncall->reset ();\n      \n      YCPValue m_params [m_next_param_id];\n  \n      for (unsigned int p = 0; p < m_next_param_id ; p++)\n      {\n  \t// FIXME, check for symbol or block type and suppress evaluation\n  \n  \tYCPValue value = m_parameters[p]->evaluate ();\n  \n  \tif (value.isNull())\n  \t{\n  \t    ycp2error (\"Parameter eval failed (%s)\", m_parameters[p]->toString().c_str());\n  \t    return value;\n  \t}\n  \t\n  #if DO_DEBUG\n  \ty2debug (\"parameter %d = (%s)\", p, value->toString().c_str());\n  #endif\n  \n  \tm_params [p] = value;\n      }\n  \n      // set the parameters for Y2Function\n      for (unsigned int p = 0; p < m_next_param_id ; p++)\n      {\n  \tm_functioncall->attachParameter (m_params[p], p);\n      }\n      \n      extern ExecutionEnvironment ee;\n  \n      // save the context info\n      int linenumber = ee.linenumber ();\n      string filename = ee.filename ();\n  \n      YCPValue value = m_functioncall->evaluateCall ();\n  \n      // restore the context info\n      ee.setLinenumber (linenumber);\n      ee.setFilename (filename);\n  \n  #if DO_DEBUG\n      y2debug(\"evaluate done (%s) = '%s'\", qualifiedName ().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Key evaluates to 'nil'\""
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "element->key->isConstant",
          "args": [],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "isConstant",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "59-63",
          "snippet": "bool\nYBreakpoint::isConstant() const\n{\n    return m_code->isConstant();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  bool\n  YBreakpoint::isConstant() const\n  {\n      return m_code->isConstant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.isNull",
          "args": [],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEMap::evaluate (%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEMap {\n  YCPValue\n  YEMap::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug (\"YEMap::evaluate (%s)\\n\", toString().c_str());\n  #endif\n      YCPMap map;\n      mapval_t *element = m_first;\n      while (element)\n      {\n  \tYCPValue key = element->key->evaluate (cse);\n  \tif (key.isNull())\n  \t{\n  \t    if (element->key->isConstant())\n  \t    {\n  \t\tycp2error (\"Key evaluates to 'nil'\");\n  \t\treturn YCPNull ();\n  \t    }\n  \t    if (cse)\t\t// parse time checking, not a constant\n  \t    {\n  \t\treturn key;\n  \t    }\n  \t}\n  \tYCPValue value = element->value->evaluate (cse);\n  \tif (value.isNull())\n  \t{\n  \t    if (cse)\t\t// parse time checking, not a constant\n  \t\treturn value;\n  \t}\n  \tmap->add (key, value);\n  \telement = element->next;\n      }\n      return map;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YEMap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "888-906",
    "snippet": "string\nYEMap::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YEMap::toString()\");\n#endif\n    mapval_t *element = m_first;\n    string s = \"$[\";\n    while (element)\n    {\n\tif (element != m_first)\n\t    s += \", \";\n\ts += element->key->toString();\n\ts += \":\";\n\ts += element->value->toString();\n\telement = element->next;\n    }\n    return s + \"]\";\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "element->value->toString",
          "args": [],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEMap::toString()\""
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEMap {\n  string\n  YEMap::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YEMap::toString()\");\n  #endif\n      mapval_t *element = m_first;\n      string s = \"$[\";\n      while (element)\n      {\n  \tif (element != m_first)\n  \t    s += \", \";\n  \ts += element->key->toString();\n  \ts += \":\";\n  \ts += element->value->toString();\n  \telement = element->next;\n      }\n      return s + \"]\";\n  }\n}"
  },
  {
    "function_name": "attach",
    "container": "YEMap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "867-885",
    "snippet": "void\nYEMap::attach (YCodePtr key, YCodePtr value)\n{\n    mapval_t *element = new mapval_t;\n    element->key = key;\n    element->value = value;\n    element->next = 0;\n\n    if (m_first == 0)\n    {\n\tm_first = element;\n    }\n    else\n    {\n\tmapval_t *ptr = m_first;\n\twhile (ptr->next) ptr = ptr->next;\n\tptr->next = element;\n    }\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEMap {\n  void\n  YEMap::attach (YCodePtr key, YCodePtr value)\n  {\n      mapval_t *element = new mapval_t;\n      element->key = key;\n      element->value = value;\n      element->next = 0;\n  \n      if (m_first == 0)\n      {\n  \tm_first = element;\n      }\n      else\n      {\n  \tmapval_t *ptr = m_first;\n  \twhile (ptr->next) ptr = ptr->next;\n  \tptr->next = element;\n      }\n  }\n}"
  },
  {
    "function_name": "~YEMap",
    "container": "YEMap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "854-864",
    "snippet": "YEMap::~YEMap ()\n{\n    mapval_t *element = m_first;\n    mapval_t *next;\n    while (element)\n    {\n\tnext = element->next;\n\tdelete element;\n\telement = next;\n    }\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEMap {\n  YEMap::~YEMap ()\n  {\n      mapval_t *element = m_first;\n      mapval_t *next;\n      while (element)\n      {\n  \tnext = element->next;\n  \tdelete element;\n  \telement = next;\n      }\n  }\n}"
  },
  {
    "function_name": "YEMap",
    "container": "YEMap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "840-851",
    "snippet": "YEMap::YEMap (bytecodeistream & str)\n    : YCode ()\n    , m_first (0)\n{\n    u_int32_t count = Bytecode::readInt32 (str);\n    while (count-- > 0)\n    {\n\tYCodePtr key = Bytecode::readCode (str);\n\tYCodePtr value = Bytecode::readCode (str);\n\tattach (key, value);\n    }\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "attach",
          "args": [
            "key",
            "value"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "attachParameter",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3421-3431",
          "snippet": "bool\nY2YCPFunction::attachParameter (const YCPValue& arg, int pos)\n{\n    if (pos < 0 || pos > ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount () )\n    {\n\ty2error (\"Attaching parameter to function '%s' at incorrect position: %d\", m_sentry->toString().c_str(), pos );\n\treturn false;\n    }\n    m_parameters[pos] = arg;\n    return true;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  bool\n  Y2YCPFunction::attachParameter (const YCPValue& arg, int pos)\n  {\n      if (pos < 0 || pos > ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount () )\n      {\n  \ty2error (\"Attaching parameter to function '%s' at incorrect position: %d\", m_sentry->toString().c_str(), pos );\n  \treturn false;\n      }\n      m_parameters[pos] = arg;\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readInt32",
          "args": [
            "str"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "readInt32",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "189-213",
          "snippet": "u_int32_t\nBytecode::readInt32 (bytecodeistream & str)\n{\n//    char c;\n//    str.get (c);\n//    if (c != 4)\n//    {\n//\treturn false;\n//    }\n\n    char v[5];\n\n    str.read (v, 5);\n    if (v[0] != 4)\n    {\n\treturn false;\n    }\n\n    u_int32_t cv, value = 0;\n    cv = (unsigned char)v[1]; value = cv;\n    cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n    cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n    cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n    return value;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\nBytecode {\n  u_int32_t\n  Bytecode::readInt32 (bytecodeistream & str)\n  {\n  //    char c;\n  //    str.get (c);\n  //    if (c != 4)\n  //    {\n  //\treturn false;\n  //    }\n  \n      char v[5];\n  \n      str.read (v, 5);\n      if (v[0] != 4)\n      {\n  \treturn false;\n      }\n  \n      u_int32_t cv, value = 0;\n      cv = (unsigned char)v[1]; value = cv;\n      cv = (unsigned char)v[2]; cv <<= 8; value |= cv;\n      cv = (unsigned char)v[3]; cv <<= 16; value |= cv;\n      cv = (unsigned char)v[4]; cv <<= 24; value |= cv;\n      return value;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEMap {\n  YEMap::YEMap (bytecodeistream & str)\n      : YCode ()\n      , m_first (0)\n  {\n      u_int32_t count = Bytecode::readInt32 (str);\n      while (count-- > 0)\n      {\n  \tYCodePtr key = Bytecode::readCode (str);\n  \tYCodePtr value = Bytecode::readCode (str);\n  \tattach (key, value);\n      }\n  }\n}"
  },
  {
    "function_name": "YEMap",
    "container": "YEMap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "832-837",
    "snippet": "YEMap::YEMap (YCodePtr key, YCodePtr value)\n    : YCode ()\n    , m_first (0)\n{\n    attach (key, value);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "attach",
          "args": [
            "key",
            "value"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "attachParameter",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3421-3431",
          "snippet": "bool\nY2YCPFunction::attachParameter (const YCPValue& arg, int pos)\n{\n    if (pos < 0 || pos > ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount () )\n    {\n\ty2error (\"Attaching parameter to function '%s' at incorrect position: %d\", m_sentry->toString().c_str(), pos );\n\treturn false;\n    }\n    m_parameters[pos] = arg;\n    return true;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nY2YCPFunction {\n  bool\n  Y2YCPFunction::attachParameter (const YCPValue& arg, int pos)\n  {\n      if (pos < 0 || pos > ((constFunctionTypePtr)(m_sentry->type ()))->parameterCount () )\n      {\n  \ty2error (\"Attaching parameter to function '%s' at incorrect position: %d\", m_sentry->toString().c_str(), pos );\n  \treturn false;\n      }\n      m_parameters[pos] = arg;\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEMap {\n  YEMap::YEMap (YCodePtr key, YCodePtr value)\n      : YCode ()\n      , m_first (0)\n  {\n      attach (key, value);\n  }\n}"
  },
  {
    "function_name": "type",
    "container": "YEList",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "811-826",
    "snippet": "constTypePtr\nYEList::type () const\n{\n    ycodelist_t *element = m_first;\n    \n    constTypePtr res = m_first->code->type ();\n    element = element->next;\n\n    while (element)\n    {\n\tres = res->commontype (element->code->type ());\n\telement = element->next;\n    }\n    \n    return new ListType (res);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "res->commontype",
          "args": [
            "element->code->type ()"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "commontype",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Type.cc",
          "lines": "1917-1944",
          "snippet": "constTypePtr\nType::commontype (constTypePtr type) const\n{\n    if (isVoid())\t\t// 'nil' does not influence the type\n    {\n\treturn type;\n    }\n\n    if (match (type) >= 0)\n    {\n#if DO_DEBUG\n\ty2debug (\"commontype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn this;\n    }\n    else if (!isAny()\n\t     && type->match (this) >= 0)\n    {\n#if DO_DEBUG\n    y2debug (\"commontype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n#endif\n\treturn type;\n    }\n#if DO_DEBUG\n    y2debug (\"commontype '%s' ('%s') -> any\", toString().c_str(), type->toString().c_str());\n#endif\n    return Type::Any;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "const constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/YCPCode.h\"\t// for YT_Code in matchvalue()\n#include \"ycp/YCPMap.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/Type.h\"\n#include \"ycp/y2log.h\"\n\n#define DO_DEBUG 0\n\nconst constTypePtr Type::Any\t\t= TypePtr ( new Type (AnyT));\n\nType {\n  constTypePtr\n  Type::commontype (constTypePtr type) const\n  {\n      if (isVoid())\t\t// 'nil' does not influence the type\n      {\n  \treturn type;\n      }\n  \n      if (match (type) >= 0)\n      {\n  #if DO_DEBUG\n  \ty2debug (\"commontype '%s'* ('%s')\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn this;\n      }\n      else if (!isAny()\n  \t     && type->match (this) >= 0)\n      {\n  #if DO_DEBUG\n      y2debug (\"commontype '%s' ('%s')*\", toString().c_str(), type->toString().c_str());\n  #endif\n  \treturn type;\n      }\n  #if DO_DEBUG\n      y2debug (\"commontype '%s' ('%s') -> any\", toString().c_str(), type->toString().c_str());\n  #endif\n      return Type::Any;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "element->code->type",
          "args": [],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEList {\n  constTypePtr\n  YEList::type () const\n  {\n      ycodelist_t *element = m_first;\n      \n      constTypePtr res = m_first->code->type ();\n      element = element->next;\n  \n      while (element)\n      {\n  \tres = res->commontype (element->code->type ());\n  \telement = element->next;\n      }\n      \n      return new ListType (res);\n  }\n}"
  },
  {
    "function_name": "value",
    "container": "YEList",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "773-783",
    "snippet": "YCodePtr\nYEList::value (int index) const\n{\n    ycodelist_t *element = m_first;\n    while (element && index)\n    {\n\telement = element->next;\n\tindex--;\n    }\n    return element != NULL ? element->code : NULL;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEList {\n  YCodePtr\n  YEList::value (int index) const\n  {\n      ycodelist_t *element = m_first;\n      while (element && index)\n      {\n  \telement = element->next;\n  \tindex--;\n      }\n      return element != NULL ? element->code : NULL;\n  }\n}"
  },
  {
    "function_name": "count",
    "container": "YEList",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "759-770",
    "snippet": "int\nYEList::count () const\n{\n    int res = 0;\n    ycodelist_t *element = m_first;\n    while (element)\n    {\n\telement = element->next;\n\tres ++;\n    }\n    return res;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEList {\n  int\n  YEList::count () const\n  {\n      int res = 0;\n      ycodelist_t *element = m_first;\n      while (element)\n      {\n  \telement = element->next;\n  \tres ++;\n      }\n      return res;\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YEList",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "729-756",
    "snippet": "YCPValue\nYEList::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug (\"YEList::evaluate(%s)\\n\", toString().c_str());\n#endif\n\n    YCPList list;\n    ycodelist_t *element = m_first;\n\n    while (element)\n    {\n\tYCPValue value = element->code->evaluate (cse);\n\n\tif (value.isNull())\n        {\n\t    if (cse) {\n\t        return value;   // expression is not a constant\n\t    }\n\t    else {\n\t        value = YCPVoid();\n\t    }\n\t}\n\tlist->add (value);\n\telement = element->next;\n    }\n    return list;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list->add",
          "args": [
            "value"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "element->code->evaluate",
          "args": [
            "cse"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "YEFunctionPointer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3191-3273",
          "snippet": "YCPValue\nYEFunctionPointer::evaluate (bool cse)\n{\n    if (cse)\n    {\n\treturn YCPNull();\n    }\n\n#if DO_DEBUG\n    y2debug (\"YEFunctionPointer::evaluate (%s)\\n\", toString().c_str());\n#endif\n\n    YCPValue ptr = m_sentry->value ();\n    if (ptr.isNull () || ! ptr->isReference ())\n    {\n\tycp2error (\"Function pointer (%s) is %s\"\n\t    , m_sentry->toString().c_str()\n\t    , ptr.isNull () ? \"NULL\" : ptr->toString ().c_str ());\n\treturn YCPVoid ();\n    }\n    \n    SymbolEntryPtr ptr_sentry = ptr->asReference ()->entry ();\n\n    Y2Namespace* ns = const_cast<Y2Namespace*> (ptr_sentry->nameSpace ());\n\n    m_functioncall = ns->createFunctionCall (\n\tptr_sentry->name (),\n\tptr_sentry->type ()\n    );\n    \n    if (!m_functioncall)\n    {\n\ty2internal (\"Cannot get function call object for %s\", m_sentry->toString().c_str());\n\treturn YCPVoid ();\n    }\n\n    // FIXME: this could fail    \n    m_functioncall->reset ();\n    \n    YCPValue m_params [m_next_param_id];\n\n    for (unsigned int p = 0; p < m_next_param_id ; p++)\n    {\n\t// FIXME, check for symbol or block type and suppress evaluation\n\n\tYCPValue value = m_parameters[p]->evaluate ();\n\n\tif (value.isNull())\n\t{\n\t    ycp2error (\"Parameter eval failed (%s)\", m_parameters[p]->toString().c_str());\n\t    return value;\n\t}\n\t\n#if DO_DEBUG\n\ty2debug (\"parameter %d = (%s)\", p, value->toString().c_str());\n#endif\n\n\tm_params [p] = value;\n    }\n\n    // set the parameters for Y2Function\n    for (unsigned int p = 0; p < m_next_param_id ; p++)\n    {\n\tm_functioncall->attachParameter (m_params[p], p);\n    }\n    \n    extern ExecutionEnvironment ee;\n\n    // save the context info\n    int linenumber = ee.linenumber ();\n    string filename = ee.filename ();\n\n    YCPValue value = m_functioncall->evaluateCall ();\n\n    // restore the context info\n    ee.setLinenumber (linenumber);\n    ee.setFilename (filename);\n\n#if DO_DEBUG\n    y2debug(\"evaluate done (%s) = '%s'\", qualifiedName ().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n    return value;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEFunctionPointer {\n  YCPValue\n  YEFunctionPointer::evaluate (bool cse)\n  {\n      if (cse)\n      {\n  \treturn YCPNull();\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"YEFunctionPointer::evaluate (%s)\\n\", toString().c_str());\n  #endif\n  \n      YCPValue ptr = m_sentry->value ();\n      if (ptr.isNull () || ! ptr->isReference ())\n      {\n  \tycp2error (\"Function pointer (%s) is %s\"\n  \t    , m_sentry->toString().c_str()\n  \t    , ptr.isNull () ? \"NULL\" : ptr->toString ().c_str ());\n  \treturn YCPVoid ();\n      }\n      \n      SymbolEntryPtr ptr_sentry = ptr->asReference ()->entry ();\n  \n      Y2Namespace* ns = const_cast<Y2Namespace*> (ptr_sentry->nameSpace ());\n  \n      m_functioncall = ns->createFunctionCall (\n  \tptr_sentry->name (),\n  \tptr_sentry->type ()\n      );\n      \n      if (!m_functioncall)\n      {\n  \ty2internal (\"Cannot get function call object for %s\", m_sentry->toString().c_str());\n  \treturn YCPVoid ();\n      }\n  \n      // FIXME: this could fail    \n      m_functioncall->reset ();\n      \n      YCPValue m_params [m_next_param_id];\n  \n      for (unsigned int p = 0; p < m_next_param_id ; p++)\n      {\n  \t// FIXME, check for symbol or block type and suppress evaluation\n  \n  \tYCPValue value = m_parameters[p]->evaluate ();\n  \n  \tif (value.isNull())\n  \t{\n  \t    ycp2error (\"Parameter eval failed (%s)\", m_parameters[p]->toString().c_str());\n  \t    return value;\n  \t}\n  \t\n  #if DO_DEBUG\n  \ty2debug (\"parameter %d = (%s)\", p, value->toString().c_str());\n  #endif\n  \n  \tm_params [p] = value;\n      }\n  \n      // set the parameters for Y2Function\n      for (unsigned int p = 0; p < m_next_param_id ; p++)\n      {\n  \tm_functioncall->attachParameter (m_params[p], p);\n      }\n      \n      extern ExecutionEnvironment ee;\n  \n      // save the context info\n      int linenumber = ee.linenumber ();\n      string filename = ee.filename ();\n  \n      YCPValue value = m_functioncall->evaluateCall ();\n  \n      // restore the context info\n      ee.setLinenumber (linenumber);\n      ee.setFilename (filename);\n  \n  #if DO_DEBUG\n      y2debug(\"evaluate done (%s) = '%s'\", qualifiedName ().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEList::evaluate(%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEList {\n  YCPValue\n  YEList::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug (\"YEList::evaluate(%s)\\n\", toString().c_str());\n  #endif\n  \n      YCPList list;\n      ycodelist_t *element = m_first;\n  \n      while (element)\n      {\n  \tYCPValue value = element->code->evaluate (cse);\n  \n  \tif (value.isNull())\n          {\n  \t    if (cse) {\n  \t        return value;   // expression is not a constant\n  \t    }\n  \t    else {\n  \t        value = YCPVoid();\n  \t    }\n  \t}\n  \tlist->add (value);\n  \telement = element->next;\n      }\n      return list;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YEList",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "711-726",
    "snippet": "string\nYEList::toString() const\n{\n    ycodelist_t *element = m_first;\n    string s = \"[\";\n    while (element)\n    {\n\tif (element != m_first)\n\t{\n\t    s += \", \";\n\t}\n\ts += element->code->toString();\n\telement = element->next;\n    }\n    return s + \"]\";\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "element->code->toString",
          "args": [],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEList {\n  string\n  YEList::toString() const\n  {\n      ycodelist_t *element = m_first;\n      string s = \"[\";\n      while (element)\n      {\n  \tif (element != m_first)\n  \t{\n  \t    s += \", \";\n  \t}\n  \ts += element->code->toString();\n  \telement = element->next;\n      }\n      return s + \"]\";\n  }\n}"
  },
  {
    "function_name": "attach",
    "container": "YEList",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "692-708",
    "snippet": "void\nYEList::attach (YCodePtr code)\n{\n    ycodelist_t *element = new ycodelist_t;\n    element->code = code;\n    element->next = 0;\n    if (m_first == 0)\n    {\n\tm_first = element;\n    }\n    else\n    {\n\tycodelist_t *ptr = m_first;\n\twhile (ptr->next) ptr = ptr->next;\n\tptr->next = element;\n    }\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEList {\n  void\n  YEList::attach (YCodePtr code)\n  {\n      ycodelist_t *element = new ycodelist_t;\n      element->code = code;\n      element->next = 0;\n      if (m_first == 0)\n      {\n  \tm_first = element;\n      }\n      else\n      {\n  \tycodelist_t *ptr = m_first;\n  \twhile (ptr->next) ptr = ptr->next;\n  \tptr->next = element;\n      }\n  }\n}"
  },
  {
    "function_name": "~YEList",
    "container": "YEList",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "679-689",
    "snippet": "YEList::~YEList ()\n{\n    ycodelist_t *element = m_first;\n    ycodelist_t *next;\n    while (element)\n    {\n\tnext = element->next;\n\tdelete element;\n\telement = next;\n    }\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEList {\n  YEList::~YEList ()\n  {\n      ycodelist_t *element = m_first;\n      ycodelist_t *next;\n      while (element)\n      {\n  \tnext = element->next;\n  \tdelete element;\n  \telement = next;\n      }\n  }\n}"
  },
  {
    "function_name": "YEList",
    "container": "YEList",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "671-676",
    "snippet": "YEList::YEList (bytecodeistream & str)\n    : YCode ()\n    , m_first (0)\n{\n    Bytecode::readYCodelist (str, &m_first);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readYCodelist",
          "args": [
            "str",
            "&m_first"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "readYCodelist",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "540-578",
          "snippet": "bool\nBytecode::readYCodelist (bytecodeistream & str, ycodelist_t **anchor)\n{\n    u_int32_t count = readInt32 (str);\n\n#if DO_DEBUG\n    y2debug (\"Bytecode::readYCodelist %d entries\", count);\n#endif\n\n    ycodelist_t *last = 0;\n\n    while (count-- > 0)\n    {\n\tycodelist_t *element = new ycodelist_t;\n\n\telement->code = Bytecode::readCode (str);\n\telement->next = 0;\n\n\tif (element->code == 0)\n\t{\n\t    y2error (\"Bytecode::readYCodelist failed\");\n\t    delete element;\n\t    return false;\n\t}\n\n\tif (*anchor == 0)\t\t// anchor undefined\n\t{\n\t    *anchor = element;\n\t}\n\telse\n\t{\n\t    last->next = element;\n\t}\n\n\tlast = element;\n    }\n\n    return str.good();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readYCodelist (bytecodeistream & str, ycodelist_t **anchor)\n  {\n      u_int32_t count = readInt32 (str);\n  \n  #if DO_DEBUG\n      y2debug (\"Bytecode::readYCodelist %d entries\", count);\n  #endif\n  \n      ycodelist_t *last = 0;\n  \n      while (count-- > 0)\n      {\n  \tycodelist_t *element = new ycodelist_t;\n  \n  \telement->code = Bytecode::readCode (str);\n  \telement->next = 0;\n  \n  \tif (element->code == 0)\n  \t{\n  \t    y2error (\"Bytecode::readYCodelist failed\");\n  \t    delete element;\n  \t    return false;\n  \t}\n  \n  \tif (*anchor == 0)\t\t// anchor undefined\n  \t{\n  \t    *anchor = element;\n  \t}\n  \telse\n  \t{\n  \t    last->next = element;\n  \t}\n  \n  \tlast = element;\n      }\n  \n      return str.good();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEList {\n  YEList::YEList (bytecodeistream & str)\n      : YCode ()\n      , m_first (0)\n  {\n      Bytecode::readYCodelist (str, &m_first);\n  }\n}"
  },
  {
    "function_name": "YEList",
    "container": "YEList",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "662-668",
    "snippet": "YEList::YEList (YCodePtr code)\n    : YCode ()\n{\n    m_first = new ycodelist_t;\n    m_first->code = code;\n    m_first->next = 0;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEList {\n  YEList::YEList (YCodePtr code)\n      : YCode ()\n  {\n      m_first = new ycodelist_t;\n      m_first->code = code;\n      m_first->next = 0;\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YELocale",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "602-633",
    "snippet": "YCPValue\nYELocale::evaluate (bool cse)\n{\n#if DO_DEBUG\n    y2debug (\"YELocale::evaluate(%s)\\n\", toString().c_str());\n#endif\n\n    if (cse)\n    {\n\treturn YCPNull();\n    }\n\n    YCPValue count = m_count->evaluate ();\n    if (count.isNull())\n    {\n\tycp2error (\"YELocale::evaluate invalid count\");\n\treturn YCPNull ();\n    }\n    if (!count->isInteger ())\n    {\n\tycp2error (\"YELocale::evaluate count not integer\");\n\treturn YCPNull ();\n    }\n\n    const char *ret = dngettext (m_domain->first, m_singular, m_plural, count->asInteger()->value());\n\n#if DO_DEBUG\n    y2debug (\"localize <%s, %s, %d> to <%s>\", m_singular, m_plural, (int)(count->asInteger()->value()), ret);\n#endif\n\n    return YCPString (ret);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "ret"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "YCPString",
          "container": "YCPString",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "152-155",
          "snippet": "YCPString::YCPString (bytecodeistream & str)\n    : YCPValue (new YCPStringRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPString {\n  YCPString::YCPString (bytecodeistream & str)\n      : YCPValue (new YCPStringRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"localize <%s, %s, %d> to <%s>\"",
            "m_singular",
            "m_plural",
            "(int)(count->asInteger()->value())",
            "ret"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count->asInteger",
          "args": [],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "asInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "106-116",
          "snippet": "YCPInteger\nYCPValueRep::asInteger() const\n{\n    if (!isInteger())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPInteger\n  YCPValueRep::asInteger() const\n  {\n      if (!isInteger())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Integer!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPInteger (static_cast<const YCPIntegerRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dngettext",
          "args": [
            "m_domain->first",
            "m_singular",
            "m_plural",
            "count->asInteger()->value()"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"YELocale::evaluate count not integer\""
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count->isInteger",
          "args": [],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "63-63",
          "snippet": "bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isInteger()     const { return valuetype() == YT_INTEGER; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"YELocale::evaluate invalid count\""
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count.isNull",
          "args": [],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_count->evaluate",
          "args": [],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YELocale::evaluate(%s)\\n\"",
            "toString().c_str()"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYELocale {\n  YCPValue\n  YELocale::evaluate (bool cse)\n  {\n  #if DO_DEBUG\n      y2debug (\"YELocale::evaluate(%s)\\n\", toString().c_str());\n  #endif\n  \n      if (cse)\n      {\n  \treturn YCPNull();\n      }\n  \n      YCPValue count = m_count->evaluate ();\n      if (count.isNull())\n      {\n  \tycp2error (\"YELocale::evaluate invalid count\");\n  \treturn YCPNull ();\n      }\n      if (!count->isInteger ())\n      {\n  \tycp2error (\"YELocale::evaluate count not integer\");\n  \treturn YCPNull ();\n      }\n  \n      const char *ret = dngettext (m_domain->first, m_singular, m_plural, count->asInteger()->value());\n  \n  #if DO_DEBUG\n      y2debug (\"localize <%s, %s, %d> to <%s>\", m_singular, m_plural, (int)(count->asInteger()->value()), ret);\n  #endif\n  \n      return YCPString (ret);\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YELocale",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "592-599",
    "snippet": "string\nYELocale::toString () const\n{\n    return \"_(\\\"\" + string (m_singular)\n\t   + \"\\\", \\\"\" + string (m_plural)\n\t   + \"\\\", \" + m_count->toString()\n\t   + \")\";\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_count->toString",
          "args": [],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "m_plural"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYELocale {\n  string\n  YELocale::toString () const\n  {\n      return \"_(\\\"\" + string (m_singular)\n  \t   + \"\\\", \\\"\" + string (m_plural)\n  \t   + \"\\\", \" + m_count->toString()\n  \t   + \")\";\n  }\n}"
  },
  {
    "function_name": "~YELocale",
    "container": "YELocale",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "585-589",
    "snippet": "YELocale::~YELocale ()\n{\n    delete[] m_singular;\n    delete[] m_plural;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYELocale {\n  YELocale::~YELocale ()\n  {\n      delete[] m_singular;\n      delete[] m_plural;\n  }\n}"
  },
  {
    "function_name": "YELocale",
    "container": "YELocale",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "562-582",
    "snippet": "YELocale::YELocale (bytecodeistream & str)\n    : YCode ()\n{\n    m_singular = Bytecode::readCharp (str);\t\t// text for singular\n    m_plural = Bytecode::readCharp (str);\t\t// text for plural\n    m_count = Bytecode::readCode (str);\n    const char * dom = Bytecode::readCharp (str);\n\n    if (YLocale::domains.find (dom) == YLocale::domains.end ())\n    {\n\tYLocale::domains.insert (std::make_pair(dom,false));\n\tm_domain = YLocale::domains.find (dom);\n    }\n    else\n    // the textdomain was already there, we can free the memory allocated in readCharp\n    {\n\tm_domain = YLocale::domains.find (dom);\n        delete[] dom;\n    }\n\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YLocale::domains.find",
          "args": [
            "dom"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YLocale::domains.find",
          "args": [
            "dom"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YLocale::domains.insert",
          "args": [
            "std::make_pair(dom,false)"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "dom",
            "false"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YLocale::domains.end",
          "args": [],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YLocale::domains.find",
          "args": [
            "dom"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readCharp",
          "args": [
            "str"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readCharp",
          "args": [
            "str"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bytecode::readCharp",
          "args": [
            "str"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYELocale {\n  YELocale::YELocale (bytecodeistream & str)\n      : YCode ()\n  {\n      m_singular = Bytecode::readCharp (str);\t\t// text for singular\n      m_plural = Bytecode::readCharp (str);\t\t// text for plural\n      m_count = Bytecode::readCode (str);\n      const char * dom = Bytecode::readCharp (str);\n  \n      if (YLocale::domains.find (dom) == YLocale::domains.end ())\n      {\n  \tYLocale::domains.insert (std::make_pair(dom,false));\n  \tm_domain = YLocale::domains.find (dom);\n      }\n      else\n      // the textdomain was already there, we can free the memory allocated in readCharp\n      {\n  \tm_domain = YLocale::domains.find (dom);\n          delete[] dom;\n      }\n  \n  }\n}"
  },
  {
    "function_name": "YELocale",
    "container": "YELocale",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "548-559",
    "snippet": "YELocale::YELocale (const char *singular, const char *plural, YCodePtr count, const char *textdomain)\n    : YCode ()\n    , m_singular (singular)\n    , m_plural (plural)\n    , m_count (count)\n{\n    if (YLocale::domains.find (textdomain) == YLocale::domains.end ())\n    {\n\tYLocale::domains.insert (std::make_pair(textdomain,false));\n    }\n    m_domain = YLocale::domains.find (textdomain);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YLocale::domains.find",
          "args": [
            "textdomain"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YLocale::domains.insert",
          "args": [
            "std::make_pair(textdomain,false)"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "textdomain",
            "false"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YLocale::domains.end",
          "args": [],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YLocale::domains.find",
          "args": [
            "textdomain"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYELocale {\n  YELocale::YELocale (const char *singular, const char *plural, YCodePtr count, const char *textdomain)\n      : YCode ()\n      , m_singular (singular)\n      , m_plural (plural)\n      , m_count (count)\n  {\n      if (YLocale::domains.find (textdomain) == YLocale::domains.end ())\n      {\n  \tYLocale::domains.insert (std::make_pair(textdomain,false));\n      }\n      m_domain = YLocale::domains.find (textdomain);\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YECompare",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "465-520",
    "snippet": "YCPValue\nYECompare::evaluate (bool cse)\n{\n    if (cse)\t\t// parse time\n    {\n\treturn YCPNull();\n    }\n\n    YCPValue vl = m_left->evaluate (cse);\n    YCPValue vr = m_right->evaluate (cse);\n#if DO_DEBUG\n    y2debug (\"YECompare::evaluate (%s, '%d', %s)\", vl.isNull() ? \"NULL\" : vl->toString().c_str(), m_op, vr.isNull() ? \"NULL\" : vr->toString().c_str());\n#endif\n\n    if ( (vl.isNull () || vl->isVoid () || vr.isNull () || vr->isVoid ()) && (m_op != C_EQ && m_op != C_NEQ) )\t// nil can be compared only for (n)equality\n    {\n\tycp2error (\"Nil can be compared only for equality and non-equality\");\n\treturn YCPNull ();\n    }\n\n    // left value is nil\n    if (vl.isNull() || vl->isVoid ())\n    {\n\tif (m_op == C_NEQ)\n\t{\n\t    return YCPBoolean (! (vr.isNull () || vr->isVoid ()));\n\t}\n\telse\n\t{\n\t    // only C_EQ, others are not permitted above\n\t    return YCPBoolean (vr.isNull() || vr->isVoid ());\t// 'nil == nil'\n\t}\n    }\n\n    // left != nil, right == nil\n\n    if (vr.isNull() || vr->isVoid ())\n    {\n\treturn YCPBoolean (m_op == C_NEQ);\t\t\t// 'x != nil'\n    }\n\n    enum YCPOrder order = vl->compare (vr);\n    switch (m_op)\n    {\n\tcase C_EQ:  return YCPBoolean (order == YO_EQUAL); break;\n\tcase C_NEQ: return YCPBoolean (order != YO_EQUAL); break;\n\tcase C_LT:  return YCPBoolean (order == YO_LESS);  break;\n\tcase C_GE:  return YCPBoolean (order != YO_LESS);  break;\n\tcase C_LE:  return YCPBoolean ((order == YO_EQUAL)||(order == YO_LESS)); break;\n\tcase C_GT:  return YCPBoolean (order == YO_GREATER); break;\n\tdefault:\n\t    break;\n    }\n    ycp2error (\"YECompare unknown type\");\n    return YCPBoolean (false);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "false"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"YECompare unknown type\""
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vl->compare",
          "args": [
            "vr"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "compare",
          "container": "YCPSymbolRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "54-59",
          "snippet": "YCPOrder\nYCPSymbolRep::compare(const YCPSymbol& s) const\n{\n    if (v == s->v) return YO_EQUAL;\n    else return v < s->v ? YO_LESS : YO_GREATER;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbolRep {\n  YCPOrder\n  YCPSymbolRep::compare(const YCPSymbol& s) const\n  {\n      if (v == s->v) return YO_EQUAL;\n      else return v < s->v ? YO_LESS : YO_GREATER;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr->isVoid",
          "args": [],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr.isNull",
          "args": [],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr.isNull",
          "args": [],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr.isNull",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vl.isNull",
          "args": [],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Nil can be compared only for equality and non-equality\""
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr.isNull",
          "args": [],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vl.isNull",
          "args": [],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YECompare::evaluate (%s, '%d', %s)\"",
            "vl.isNull() ? \"NULL\" : vl->toString().c_str()",
            "m_op",
            "vr.isNull() ? \"NULL\" : vr->toString().c_str()"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr->toString",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr.isNull",
          "args": [],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vl.isNull",
          "args": [],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_right->evaluate",
          "args": [
            "cse"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "YEFunctionPointer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3191-3273",
          "snippet": "YCPValue\nYEFunctionPointer::evaluate (bool cse)\n{\n    if (cse)\n    {\n\treturn YCPNull();\n    }\n\n#if DO_DEBUG\n    y2debug (\"YEFunctionPointer::evaluate (%s)\\n\", toString().c_str());\n#endif\n\n    YCPValue ptr = m_sentry->value ();\n    if (ptr.isNull () || ! ptr->isReference ())\n    {\n\tycp2error (\"Function pointer (%s) is %s\"\n\t    , m_sentry->toString().c_str()\n\t    , ptr.isNull () ? \"NULL\" : ptr->toString ().c_str ());\n\treturn YCPVoid ();\n    }\n    \n    SymbolEntryPtr ptr_sentry = ptr->asReference ()->entry ();\n\n    Y2Namespace* ns = const_cast<Y2Namespace*> (ptr_sentry->nameSpace ());\n\n    m_functioncall = ns->createFunctionCall (\n\tptr_sentry->name (),\n\tptr_sentry->type ()\n    );\n    \n    if (!m_functioncall)\n    {\n\ty2internal (\"Cannot get function call object for %s\", m_sentry->toString().c_str());\n\treturn YCPVoid ();\n    }\n\n    // FIXME: this could fail    \n    m_functioncall->reset ();\n    \n    YCPValue m_params [m_next_param_id];\n\n    for (unsigned int p = 0; p < m_next_param_id ; p++)\n    {\n\t// FIXME, check for symbol or block type and suppress evaluation\n\n\tYCPValue value = m_parameters[p]->evaluate ();\n\n\tif (value.isNull())\n\t{\n\t    ycp2error (\"Parameter eval failed (%s)\", m_parameters[p]->toString().c_str());\n\t    return value;\n\t}\n\t\n#if DO_DEBUG\n\ty2debug (\"parameter %d = (%s)\", p, value->toString().c_str());\n#endif\n\n\tm_params [p] = value;\n    }\n\n    // set the parameters for Y2Function\n    for (unsigned int p = 0; p < m_next_param_id ; p++)\n    {\n\tm_functioncall->attachParameter (m_params[p], p);\n    }\n    \n    extern ExecutionEnvironment ee;\n\n    // save the context info\n    int linenumber = ee.linenumber ();\n    string filename = ee.filename ();\n\n    YCPValue value = m_functioncall->evaluateCall ();\n\n    // restore the context info\n    ee.setLinenumber (linenumber);\n    ee.setFilename (filename);\n\n#if DO_DEBUG\n    y2debug(\"evaluate done (%s) = '%s'\", qualifiedName ().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n    return value;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEFunctionPointer {\n  YCPValue\n  YEFunctionPointer::evaluate (bool cse)\n  {\n      if (cse)\n      {\n  \treturn YCPNull();\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"YEFunctionPointer::evaluate (%s)\\n\", toString().c_str());\n  #endif\n  \n      YCPValue ptr = m_sentry->value ();\n      if (ptr.isNull () || ! ptr->isReference ())\n      {\n  \tycp2error (\"Function pointer (%s) is %s\"\n  \t    , m_sentry->toString().c_str()\n  \t    , ptr.isNull () ? \"NULL\" : ptr->toString ().c_str ());\n  \treturn YCPVoid ();\n      }\n      \n      SymbolEntryPtr ptr_sentry = ptr->asReference ()->entry ();\n  \n      Y2Namespace* ns = const_cast<Y2Namespace*> (ptr_sentry->nameSpace ());\n  \n      m_functioncall = ns->createFunctionCall (\n  \tptr_sentry->name (),\n  \tptr_sentry->type ()\n      );\n      \n      if (!m_functioncall)\n      {\n  \ty2internal (\"Cannot get function call object for %s\", m_sentry->toString().c_str());\n  \treturn YCPVoid ();\n      }\n  \n      // FIXME: this could fail    \n      m_functioncall->reset ();\n      \n      YCPValue m_params [m_next_param_id];\n  \n      for (unsigned int p = 0; p < m_next_param_id ; p++)\n      {\n  \t// FIXME, check for symbol or block type and suppress evaluation\n  \n  \tYCPValue value = m_parameters[p]->evaluate ();\n  \n  \tif (value.isNull())\n  \t{\n  \t    ycp2error (\"Parameter eval failed (%s)\", m_parameters[p]->toString().c_str());\n  \t    return value;\n  \t}\n  \t\n  #if DO_DEBUG\n  \ty2debug (\"parameter %d = (%s)\", p, value->toString().c_str());\n  #endif\n  \n  \tm_params [p] = value;\n      }\n  \n      // set the parameters for Y2Function\n      for (unsigned int p = 0; p < m_next_param_id ; p++)\n      {\n  \tm_functioncall->attachParameter (m_params[p], p);\n      }\n      \n      extern ExecutionEnvironment ee;\n  \n      // save the context info\n      int linenumber = ee.linenumber ();\n      string filename = ee.filename ();\n  \n      YCPValue value = m_functioncall->evaluateCall ();\n  \n      // restore the context info\n      ee.setLinenumber (linenumber);\n      ee.setFilename (filename);\n  \n  #if DO_DEBUG\n      y2debug(\"evaluate done (%s) = '%s'\", qualifiedName ().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECompare {\n  YCPValue\n  YECompare::evaluate (bool cse)\n  {\n      if (cse)\t\t// parse time\n      {\n  \treturn YCPNull();\n      }\n  \n      YCPValue vl = m_left->evaluate (cse);\n      YCPValue vr = m_right->evaluate (cse);\n  #if DO_DEBUG\n      y2debug (\"YECompare::evaluate (%s, '%d', %s)\", vl.isNull() ? \"NULL\" : vl->toString().c_str(), m_op, vr.isNull() ? \"NULL\" : vr->toString().c_str());\n  #endif\n  \n      if ( (vl.isNull () || vl->isVoid () || vr.isNull () || vr->isVoid ()) && (m_op != C_EQ && m_op != C_NEQ) )\t// nil can be compared only for (n)equality\n      {\n  \tycp2error (\"Nil can be compared only for equality and non-equality\");\n  \treturn YCPNull ();\n      }\n  \n      // left value is nil\n      if (vl.isNull() || vl->isVoid ())\n      {\n  \tif (m_op == C_NEQ)\n  \t{\n  \t    return YCPBoolean (! (vr.isNull () || vr->isVoid ()));\n  \t}\n  \telse\n  \t{\n  \t    // only C_EQ, others are not permitted above\n  \t    return YCPBoolean (vr.isNull() || vr->isVoid ());\t// 'nil == nil'\n  \t}\n      }\n  \n      // left != nil, right == nil\n  \n      if (vr.isNull() || vr->isVoid ())\n      {\n  \treturn YCPBoolean (m_op == C_NEQ);\t\t\t// 'x != nil'\n      }\n  \n      enum YCPOrder order = vl->compare (vr);\n      switch (m_op)\n      {\n  \tcase C_EQ:  return YCPBoolean (order == YO_EQUAL); break;\n  \tcase C_NEQ: return YCPBoolean (order != YO_EQUAL); break;\n  \tcase C_LT:  return YCPBoolean (order == YO_LESS);  break;\n  \tcase C_GE:  return YCPBoolean (order != YO_LESS);  break;\n  \tcase C_LE:  return YCPBoolean ((order == YO_EQUAL)||(order == YO_LESS)); break;\n  \tcase C_GT:  return YCPBoolean (order == YO_GREATER); break;\n  \tdefault:\n  \t    break;\n      }\n      ycp2error (\"YECompare unknown type\");\n      return YCPBoolean (false);\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YECompare",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "453-462",
    "snippet": "string\nYECompare::toString () const\n{\n    string s = \"(\" + m_left->toString();\n    s += \" \";\n    s += compare_op_string( m_op );\n    s += \" \";\n    s += m_right->toString();\n    return s + \")\";\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_right->toString",
          "args": [],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compare_op_string",
          "args": [
            "m_op"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECompare {\n  string\n  YECompare::toString () const\n  {\n      string s = \"(\" + m_left->toString();\n      s += \" \";\n      s += compare_op_string( m_op );\n      s += \" \";\n      s += m_right->toString();\n      return s + \")\";\n  }\n}"
  },
  {
    "function_name": "compare_op_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "435-450",
    "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
  },
  {
    "function_name": "~YECompare",
    "container": "YECompare",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "431-433",
    "snippet": "YECompare::~YECompare ()\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECompare {\n  YECompare::~YECompare ()\n  {\n  }\n}"
  },
  {
    "function_name": "YECompare",
    "container": "YECompare",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "420-428",
    "snippet": "YECompare::YECompare (bytecodeistream & str)\n    : YCode ()\n{\n    m_left = Bytecode::readCode (str);\n    char c;\n    str.get (c);\n    m_op = (c_op) c;\n    m_right = Bytecode::readCode (str);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readCode",
          "args": [
            "str"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "readCode",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "822-1062",
          "snippet": "YCodePtr\nBytecode::readCode (bytecodeistream & str)\n{\n    char code;\n    if (!str.get (code))\n    {\n\ty2error (\"Can't read from stream\");\n\treturn 0;\n    }\n#if DO_DEBUG\n//    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n#endif\n    if (code < YCode::ycConstant)\n    {\n\treturn new YConst ((YCode::ykind)code, str);\n    }\n    \n    // compatibility with 9.1/SLES\n    if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n    {\n\t// yeFunctionPointer did not exist then\n\tcode++;\n    }\n    \n    YCodePtr res = 0;\n\n    // there used to be a try/catch here but it was moved to readFile\n\n    switch (code)\n    {\n\tcase YCode::ycConstant:\n\t{\n\t    // this constant is a placeholder, typically used by\n\t    // language bindings that cannot provide type information\n\t    y2error (\"Unable to read constant, check the compilation of the module\");\n\t    return 0;\n\t}\n\tcase YCode::ycLocale:\n\t{\n\t    res = new YLocale (str);\n\t}\n\tbreak;\n\tcase YCode::ycFunction:\n\t{\n\t    res = new YFunction (str);\n\t}\n\tbreak;\n\tcase YCode::yePropagate:\n\t{\n\t    res = new YEPropagate (str);\n\t}\n\tbreak;\n\tcase YCode::yeUnary:\n\t{\n\t    res = new YEUnary (str);\n\t}\n\tbreak;\n\tcase YCode::yeBinary:\n\t{\n\t    res = new YEBinary (str);\n\t}\n\tbreak;\n\tcase YCode::yeTriple:\n\t{\n\t    res = new YETriple (str);\n\t}\n\tbreak;\n\tcase YCode::yeCompare:\n\t{\n\t    res = new YECompare (str);\n\t}\n\tbreak;\n\tcase YCode::yeLocale:\n\t{\n\t    res = new YELocale (str);\n\t}\n\tbreak;\n\tcase YCode::yeList:\n\t{\n\t    res = new YEList (str);\n\t}\n\tbreak;\n\tcase YCode::yeMap:\n\t{\n\t    res = new YEMap (str);\n\t}\n\tbreak;\n\tcase YCode::yeTerm:\n\t{\n\t    res = new YETerm (str);\n\t}\n\tbreak;\n\tcase YCode::yeIs:\n\t{\n\t    res = new YEIs (str);\n\t}\n\tbreak;\n\tcase YCode::yeBracket:\n\t{\n\t    res = new YEBracket (str);\n\t}\n\tbreak;\n\tcase YCode::yeBlock:\n\t{\n\t    res = new YBlock (str);\n\t}\n\tbreak;\n\tcase YCode::yeReturn:\n\t{\n\t    res = new YEReturn (str);\n\t}\n\tbreak;\n\tcase YCode::yeVariable:\n\t{\n\t    res = new YEVariable (str);\n\t}\n\tbreak;\n\tcase YCode::yeReference:\n\t{\n\t    res = new YEReference (str);\n\t}\n\tbreak;\n\tcase YCode::yeBuiltin:\n\t{\n\t    res = new YEBuiltin (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunction:\n\t{\n\t    res = YECall::readCall (str);\n\t}\n\tbreak;\n\tcase YCode::yeFunctionPointer:\n\t{\n\t    res = new YEFunctionPointer (str);\n\t}\n\tbreak;\n\tcase YCode::ysTypedef:\n\t{\n\t    res = new YSTypedef (str);\n\t}\n\tbreak;\n\tcase YCode::ysVariable:\n\t{\n\t    res = new YSVariable (str);\n\t}\n\tbreak;\n\tcase YCode::ysFunction:\n\t{\n\t    res = new YSFunction (str);\n\t}\n\tbreak;\n\tcase YCode::ysAssign:\n\t{\n\t    res = new YSAssign (str);\n\t}\n\tbreak;\n\tcase YCode::ysBracket:\n\t{\n\t    res = new YSBracket (str);\n\t}\n\tbreak;\n\tcase YCode::ysIf:\n\t{\n\t    res = new YSIf (str);\n\t}\n\tbreak;\n\tcase YCode::ysWhile:\n\t{\n\t    res = new YSWhile (str);\n\t}\n\tbreak;\n\tcase YCode::ysDo:\n\t{\n\t    res = new YSDo (str);\n\t}\n\tbreak;\n\tcase YCode::ysRepeat:\n\t{\n\t    res = new YSRepeat (str);\n\t}\n\tbreak;\n\tcase YCode::ysExpression:\n\t{\n\t    res = new YSExpression (str);\n\t}\n\tbreak;\n\tcase YCode::ysReturn:\n\t{\n\t    res = new YSReturn (str);\n\t}\n\tbreak;\n\tcase YCode::ysBreak:\n\t{\n\t    res = new YSBreak (str);\n\t}\n\tbreak;\n\tcase YCode::ysContinue:\n\t{\n\t    res = new YSContinue (str);\n\t}\n\tbreak;\n\tcase YCode::ysTextdomain:\n\t{\n\t    res = new YSTextdomain (str);\n\t}\n\tbreak;\n\tcase YCode::ysInclude:\n\t{\n\t    res = new YSInclude (str);\n\t}\n\tbreak;\n\tcase YCode::ysFilename:\n\t{\n\t    res = new YSFilename (str);\n\t}\n\tbreak;\n\tcase YCode::ysImport:\n\t{\n\t    res = new YSImport (str);\n\t}\n\tbreak;\n\tcase YCode::ysBlock:\n\t{\n\t    res = new YSBlock (str);\n\t}\n\tbreak;\n\tcase YCode::ysSwitch:\n\t{\n\t    res = new YSSwitch (str);\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    y2error (\"Unknown code %d\", code);\n\t}\n\tbreak;\n    }\n\n    return res;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  YCodePtr\n  Bytecode::readCode (bytecodeistream & str)\n  {\n      char code;\n      if (!str.get (code))\n      {\n  \ty2error (\"Can't read from stream\");\n  \treturn 0;\n      }\n  #if DO_DEBUG\n  //    y2debug (\"Bytecode::readCode (%d:%s)\", code, YCode::toString ((YCode::ykind)code).c_str());\n  #endif\n      if (code < YCode::ycConstant)\n      {\n  \treturn new YConst ((YCode::ykind)code, str);\n      }\n      \n      // compatibility with 9.1/SLES\n      if (str.isVersion (1,3,2) && code > YCode::yeExpression)\n      {\n  \t// yeFunctionPointer did not exist then\n  \tcode++;\n      }\n      \n      YCodePtr res = 0;\n  \n      // there used to be a try/catch here but it was moved to readFile\n  \n      switch (code)\n      {\n  \tcase YCode::ycConstant:\n  \t{\n  \t    // this constant is a placeholder, typically used by\n  \t    // language bindings that cannot provide type information\n  \t    y2error (\"Unable to read constant, check the compilation of the module\");\n  \t    return 0;\n  \t}\n  \tcase YCode::ycLocale:\n  \t{\n  \t    res = new YLocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ycFunction:\n  \t{\n  \t    res = new YFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yePropagate:\n  \t{\n  \t    res = new YEPropagate (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeUnary:\n  \t{\n  \t    res = new YEUnary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBinary:\n  \t{\n  \t    res = new YEBinary (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTriple:\n  \t{\n  \t    res = new YETriple (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeCompare:\n  \t{\n  \t    res = new YECompare (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeLocale:\n  \t{\n  \t    res = new YELocale (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeList:\n  \t{\n  \t    res = new YEList (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeMap:\n  \t{\n  \t    res = new YEMap (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeTerm:\n  \t{\n  \t    res = new YETerm (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeIs:\n  \t{\n  \t    res = new YEIs (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBracket:\n  \t{\n  \t    res = new YEBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBlock:\n  \t{\n  \t    res = new YBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReturn:\n  \t{\n  \t    res = new YEReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeVariable:\n  \t{\n  \t    res = new YEVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeReference:\n  \t{\n  \t    res = new YEReference (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeBuiltin:\n  \t{\n  \t    res = new YEBuiltin (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunction:\n  \t{\n  \t    res = YECall::readCall (str);\n  \t}\n  \tbreak;\n  \tcase YCode::yeFunctionPointer:\n  \t{\n  \t    res = new YEFunctionPointer (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTypedef:\n  \t{\n  \t    res = new YSTypedef (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysVariable:\n  \t{\n  \t    res = new YSVariable (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFunction:\n  \t{\n  \t    res = new YSFunction (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysAssign:\n  \t{\n  \t    res = new YSAssign (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBracket:\n  \t{\n  \t    res = new YSBracket (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysIf:\n  \t{\n  \t    res = new YSIf (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysWhile:\n  \t{\n  \t    res = new YSWhile (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysDo:\n  \t{\n  \t    res = new YSDo (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysRepeat:\n  \t{\n  \t    res = new YSRepeat (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysExpression:\n  \t{\n  \t    res = new YSExpression (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysReturn:\n  \t{\n  \t    res = new YSReturn (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBreak:\n  \t{\n  \t    res = new YSBreak (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysContinue:\n  \t{\n  \t    res = new YSContinue (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysTextdomain:\n  \t{\n  \t    res = new YSTextdomain (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysInclude:\n  \t{\n  \t    res = new YSInclude (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysFilename:\n  \t{\n  \t    res = new YSFilename (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysImport:\n  \t{\n  \t    res = new YSImport (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysBlock:\n  \t{\n  \t    res = new YSBlock (str);\n  \t}\n  \tbreak;\n  \tcase YCode::ysSwitch:\n  \t{\n  \t    res = new YSSwitch (str);\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    y2error (\"Unknown code %d\", code);\n  \t}\n  \tbreak;\n      }\n  \n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.get",
          "args": [
            "c"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECompare {\n  YECompare::YECompare (bytecodeistream & str)\n      : YCode ()\n  {\n      m_left = Bytecode::readCode (str);\n      char c;\n      str.get (c);\n      m_op = (c_op) c;\n      m_right = Bytecode::readCode (str);\n  }\n}"
  },
  {
    "function_name": "YECompare",
    "container": "YECompare",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "411-417",
    "snippet": "YECompare::YECompare (YCodePtr left, c_op op, YCodePtr right)\n    : YCode ()\n    , m_left (left)\n    , m_op (op)\n    , m_right (right)\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECompare {\n  YECompare::YECompare (YCodePtr left, c_op op, YCodePtr right)\n      : YCode ()\n      , m_left (left)\n      , m_op (op)\n      , m_right (right)\n  {\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YETerm",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "352-379",
    "snippet": "YCPValue\nYETerm::evaluate (bool cse)\n{\n    YCPTerm term (m_name);\n\n    ycodelist_t *actualp = m_parameters;\n\n    while (actualp != 0)\n    {\n\tYCPValue value = actualp->code->evaluate (cse);\n\tif (value.isNull())\n\t{\n\t    if (!cse)\t\t// not parse time\n\t    {\n\t\tycp2error (\"Term parameter evaluates to 'NULL'\");\n\t    }\n\t    return YCPNull ();\n\t}\n\tterm->add (value);\n\tactualp = actualp->next;\n    }\n\n#if DO_DEBUG\n    y2debug (\"YETerm::evaluate (%s) = '%s'\", toString().c_str(), term->toString().c_str());\n#endif\n\n    return term;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YETerm::evaluate (%s) = '%s'\"",
            "toString().c_str()",
            "term->toString().c_str()"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term->toString",
          "args": [],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->add",
          "args": [
            "value"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Term parameter evaluates to 'NULL'\""
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "actualp->code->evaluate",
          "args": [
            "cse"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "YEFunctionPointer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3191-3273",
          "snippet": "YCPValue\nYEFunctionPointer::evaluate (bool cse)\n{\n    if (cse)\n    {\n\treturn YCPNull();\n    }\n\n#if DO_DEBUG\n    y2debug (\"YEFunctionPointer::evaluate (%s)\\n\", toString().c_str());\n#endif\n\n    YCPValue ptr = m_sentry->value ();\n    if (ptr.isNull () || ! ptr->isReference ())\n    {\n\tycp2error (\"Function pointer (%s) is %s\"\n\t    , m_sentry->toString().c_str()\n\t    , ptr.isNull () ? \"NULL\" : ptr->toString ().c_str ());\n\treturn YCPVoid ();\n    }\n    \n    SymbolEntryPtr ptr_sentry = ptr->asReference ()->entry ();\n\n    Y2Namespace* ns = const_cast<Y2Namespace*> (ptr_sentry->nameSpace ());\n\n    m_functioncall = ns->createFunctionCall (\n\tptr_sentry->name (),\n\tptr_sentry->type ()\n    );\n    \n    if (!m_functioncall)\n    {\n\ty2internal (\"Cannot get function call object for %s\", m_sentry->toString().c_str());\n\treturn YCPVoid ();\n    }\n\n    // FIXME: this could fail    \n    m_functioncall->reset ();\n    \n    YCPValue m_params [m_next_param_id];\n\n    for (unsigned int p = 0; p < m_next_param_id ; p++)\n    {\n\t// FIXME, check for symbol or block type and suppress evaluation\n\n\tYCPValue value = m_parameters[p]->evaluate ();\n\n\tif (value.isNull())\n\t{\n\t    ycp2error (\"Parameter eval failed (%s)\", m_parameters[p]->toString().c_str());\n\t    return value;\n\t}\n\t\n#if DO_DEBUG\n\ty2debug (\"parameter %d = (%s)\", p, value->toString().c_str());\n#endif\n\n\tm_params [p] = value;\n    }\n\n    // set the parameters for Y2Function\n    for (unsigned int p = 0; p < m_next_param_id ; p++)\n    {\n\tm_functioncall->attachParameter (m_params[p], p);\n    }\n    \n    extern ExecutionEnvironment ee;\n\n    // save the context info\n    int linenumber = ee.linenumber ();\n    string filename = ee.filename ();\n\n    YCPValue value = m_functioncall->evaluateCall ();\n\n    // restore the context info\n    ee.setLinenumber (linenumber);\n    ee.setFilename (filename);\n\n#if DO_DEBUG\n    y2debug(\"evaluate done (%s) = '%s'\", qualifiedName ().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n    return value;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEFunctionPointer {\n  YCPValue\n  YEFunctionPointer::evaluate (bool cse)\n  {\n      if (cse)\n      {\n  \treturn YCPNull();\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"YEFunctionPointer::evaluate (%s)\\n\", toString().c_str());\n  #endif\n  \n      YCPValue ptr = m_sentry->value ();\n      if (ptr.isNull () || ! ptr->isReference ())\n      {\n  \tycp2error (\"Function pointer (%s) is %s\"\n  \t    , m_sentry->toString().c_str()\n  \t    , ptr.isNull () ? \"NULL\" : ptr->toString ().c_str ());\n  \treturn YCPVoid ();\n      }\n      \n      SymbolEntryPtr ptr_sentry = ptr->asReference ()->entry ();\n  \n      Y2Namespace* ns = const_cast<Y2Namespace*> (ptr_sentry->nameSpace ());\n  \n      m_functioncall = ns->createFunctionCall (\n  \tptr_sentry->name (),\n  \tptr_sentry->type ()\n      );\n      \n      if (!m_functioncall)\n      {\n  \ty2internal (\"Cannot get function call object for %s\", m_sentry->toString().c_str());\n  \treturn YCPVoid ();\n      }\n  \n      // FIXME: this could fail    \n      m_functioncall->reset ();\n      \n      YCPValue m_params [m_next_param_id];\n  \n      for (unsigned int p = 0; p < m_next_param_id ; p++)\n      {\n  \t// FIXME, check for symbol or block type and suppress evaluation\n  \n  \tYCPValue value = m_parameters[p]->evaluate ();\n  \n  \tif (value.isNull())\n  \t{\n  \t    ycp2error (\"Parameter eval failed (%s)\", m_parameters[p]->toString().c_str());\n  \t    return value;\n  \t}\n  \t\n  #if DO_DEBUG\n  \ty2debug (\"parameter %d = (%s)\", p, value->toString().c_str());\n  #endif\n  \n  \tm_params [p] = value;\n      }\n  \n      // set the parameters for Y2Function\n      for (unsigned int p = 0; p < m_next_param_id ; p++)\n      {\n  \tm_functioncall->attachParameter (m_params[p], p);\n      }\n      \n      extern ExecutionEnvironment ee;\n  \n      // save the context info\n      int linenumber = ee.linenumber ();\n      string filename = ee.filename ();\n  \n      YCPValue value = m_functioncall->evaluateCall ();\n  \n      // restore the context info\n      ee.setLinenumber (linenumber);\n      ee.setFilename (filename);\n  \n  #if DO_DEBUG\n      y2debug(\"evaluate done (%s) = '%s'\", qualifiedName ().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n      return value;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYETerm {\n  YCPValue\n  YETerm::evaluate (bool cse)\n  {\n      YCPTerm term (m_name);\n  \n      ycodelist_t *actualp = m_parameters;\n  \n      while (actualp != 0)\n      {\n  \tYCPValue value = actualp->code->evaluate (cse);\n  \tif (value.isNull())\n  \t{\n  \t    if (!cse)\t\t// not parse time\n  \t    {\n  \t\tycp2error (\"Term parameter evaluates to 'NULL'\");\n  \t    }\n  \t    return YCPNull ();\n  \t}\n  \tterm->add (value);\n  \tactualp = actualp->next;\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"YETerm::evaluate (%s) = '%s'\", toString().c_str(), term->toString().c_str());\n  #endif\n  \n      return term;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YETerm",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "328-349",
    "snippet": "string\nYETerm::toString () const\n{\n    string s = \"`\" + string (m_name) + \" (\";\n\n    ycodelist_t *parm = m_parameters;\n    while (parm)\n    {\n\tif (parm->code == 0)\n\t{\n\t    ycp2error( \"parameter without code\");\n\t    parm = parm->next;\n\t    continue;\n\t}\n\ts += parm->code->toString().c_str();\n\tif (parm->next != 0)\n\t    s += \", \";\n\tparm = parm->next;\n    }\n    s += \")\";\n    return s;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parm->code->toString",
          "args": [],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"parameter without code\""
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "m_name"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "compare_op_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "435-450",
          "snippet": "static string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nstatic string\ncompare_op_string( YECompare::c_op op )\n{\n    switch (op)\n    {\n\tcase YECompare::C_EQ:  return \"==\"; break;\n\tcase YECompare::C_NEQ: return \"!=\"; break;\n\tcase YECompare::C_LT:  return \"<\";  break;\n\tcase YECompare::C_GE:  return \">=\"; break;\n\tcase YECompare::C_LE:  return \"<=\"; break;\n\tcase YECompare::C_GT:  return \">\";  break;\n\tdefault:\n\t\tbreak;\n    }\n    return \"?compare?\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYETerm {\n  string\n  YETerm::toString () const\n  {\n      string s = \"`\" + string (m_name) + \" (\";\n  \n      ycodelist_t *parm = m_parameters;\n      while (parm)\n      {\n  \tif (parm->code == 0)\n  \t{\n  \t    ycp2error( \"parameter without code\");\n  \t    parm = parm->next;\n  \t    continue;\n  \t}\n  \ts += parm->code->toString().c_str();\n  \tif (parm->next != 0)\n  \t    s += \", \";\n  \tparm = parm->next;\n      }\n      s += \")\";\n      return s;\n  }\n}"
  },
  {
    "function_name": "attachParameter",
    "container": "YETerm",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "293-325",
    "snippet": "constTypePtr\nYETerm::attachParameter (YCodePtr code, constTypePtr /*dummy*/)\n{\n    if ((code == 0)\n\t|| (code->isError()))\n    {\n#if DO_DEBUG\n\ty2debug (\"YETerm::attachParameter (Error)\");\n#endif\n\treturn Type::Unspec;\n    }\n\n#if DO_DEBUG\n    y2debug (\"YETerm::attachParameter (%s)\", code->toString().c_str());\n#endif\n\n    ycodelist_t *element = new ycodelist_t;\n    element->code = code;\n    element->next = 0;\n\n    if (m_parameters == 0)\n    {\n\tm_parameters = element;\n    }\n    else\n    {\n\tycodelist_t *ptr = m_parameters;\n\twhile (ptr->next) ptr = ptr->next;\n\tptr->next = element;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YETerm::attachParameter (%s)\"",
            "code->toString().c_str()"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "code->toString",
          "args": [],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YETerm::attachParameter (Error)\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "code->isError",
          "args": [],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "isError",
          "container": "YCode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCode.cc",
          "lines": "76-80",
          "snippet": "bool\nYCode::isError() const\n{\n    return false; \t\t// TODO unused in practice?\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCode.h\"",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCode.h\"\n#include <libintl.h>\n\nYCode {\n  bool\n  YCode::isError() const\n  {\n      return false; \t\t// TODO unused in practice?\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYETerm {\n  constTypePtr\n  YETerm::attachParameter (YCodePtr code, constTypePtr /*dummy*/)\n  {\n      if ((code == 0)\n  \t|| (code->isError()))\n      {\n  #if DO_DEBUG\n  \ty2debug (\"YETerm::attachParameter (Error)\");\n  #endif\n  \treturn Type::Unspec;\n      }\n  \n  #if DO_DEBUG\n      y2debug (\"YETerm::attachParameter (%s)\", code->toString().c_str());\n  #endif\n  \n      ycodelist_t *element = new ycodelist_t;\n      element->code = code;\n      element->next = 0;\n  \n      if (m_parameters == 0)\n      {\n  \tm_parameters = element;\n      }\n      else\n      {\n  \tycodelist_t *ptr = m_parameters;\n  \twhile (ptr->next) ptr = ptr->next;\n  \tptr->next = element;\n      }\n  \n      return 0;\n  }\n}"
  },
  {
    "function_name": "~YETerm",
    "container": "YETerm",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "263-273",
    "snippet": "YETerm::~YETerm ()\n{\n    ycodelist_t *parm = m_parameters;\n    while (parm)\n    {\n\tycodelist_t *next = parm->next;\n\tdelete parm;\n\tparm = next;\n    }\n    delete [] m_name;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYETerm {\n  YETerm::~YETerm ()\n  {\n      ycodelist_t *parm = m_parameters;\n      while (parm)\n      {\n  \tycodelist_t *next = parm->next;\n  \tdelete parm;\n  \tparm = next;\n      }\n      delete [] m_name;\n  }\n}"
  },
  {
    "function_name": "YETerm",
    "container": "YETerm",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "247-260",
    "snippet": "YETerm::YETerm (bytecodeistream & str)\n    : YCode ()\n    , m_parameters (0)\n{\n    m_name = Bytecode::readCharp (str);\n    if (m_name)\n    {\n\tif (!Bytecode::readYCodelist (str, &m_parameters))\n\t{\n\t    delete [] m_name;\n\t    m_name = 0;\n\t}\n    }\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readYCodelist",
          "args": [
            "str",
            "&m_parameters"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "readYCodelist",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "540-578",
          "snippet": "bool\nBytecode::readYCodelist (bytecodeistream & str, ycodelist_t **anchor)\n{\n    u_int32_t count = readInt32 (str);\n\n#if DO_DEBUG\n    y2debug (\"Bytecode::readYCodelist %d entries\", count);\n#endif\n\n    ycodelist_t *last = 0;\n\n    while (count-- > 0)\n    {\n\tycodelist_t *element = new ycodelist_t;\n\n\telement->code = Bytecode::readCode (str);\n\telement->next = 0;\n\n\tif (element->code == 0)\n\t{\n\t    y2error (\"Bytecode::readYCodelist failed\");\n\t    delete element;\n\t    return false;\n\t}\n\n\tif (*anchor == 0)\t\t// anchor undefined\n\t{\n\t    *anchor = element;\n\t}\n\telse\n\t{\n\t    last->next = element;\n\t}\n\n\tlast = element;\n    }\n\n    return str.good();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  bool\n  Bytecode::readYCodelist (bytecodeistream & str, ycodelist_t **anchor)\n  {\n      u_int32_t count = readInt32 (str);\n  \n  #if DO_DEBUG\n      y2debug (\"Bytecode::readYCodelist %d entries\", count);\n  #endif\n  \n      ycodelist_t *last = 0;\n  \n      while (count-- > 0)\n      {\n  \tycodelist_t *element = new ycodelist_t;\n  \n  \telement->code = Bytecode::readCode (str);\n  \telement->next = 0;\n  \n  \tif (element->code == 0)\n  \t{\n  \t    y2error (\"Bytecode::readYCodelist failed\");\n  \t    delete element;\n  \t    return false;\n  \t}\n  \n  \tif (*anchor == 0)\t\t// anchor undefined\n  \t{\n  \t    *anchor = element;\n  \t}\n  \telse\n  \t{\n  \t    last->next = element;\n  \t}\n  \n  \tlast = element;\n      }\n  \n      return str.good();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bytecode::readCharp",
          "args": [
            "str"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYETerm {\n  YETerm::YETerm (bytecodeistream & str)\n      : YCode ()\n      , m_parameters (0)\n  {\n      m_name = Bytecode::readCharp (str);\n      if (m_name)\n      {\n  \tif (!Bytecode::readYCodelist (str, &m_parameters))\n  \t{\n  \t    delete [] m_name;\n  \t    m_name = 0;\n  \t}\n      }\n  }\n}"
  },
  {
    "function_name": "YETerm",
    "container": "YETerm",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "239-244",
    "snippet": "YETerm::YETerm (const char *name)\n    : YCode ()\n    , m_name (name)\n    , m_parameters (0)\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYETerm {\n  YETerm::YETerm (const char *name)\n      : YCode ()\n      , m_name (name)\n      , m_parameters (0)\n  {\n  }\n}"
  },
  {
    "function_name": "type",
    "container": "YEReference",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "228-234",
    "snippet": "constTypePtr\nYEReference::type () const\n{\n    TypePtr t = m_entry->type()->clone();\n    t->asReference();\n    return t;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->asReference",
          "args": [],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "asReference",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "239-249",
          "snippet": "YCPReference\nYCPValueRep::asReference() const\n{\n    if (!isReference())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Reference!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPReference (static_cast<const YCPReferenceRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPReference\n  YCPValueRep::asReference() const\n  {\n      if (!isReference())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Reference!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPReference (static_cast<const YCPReferenceRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_entry->type",
          "args": [],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3017-3021",
          "snippet": "constTypePtr\nYECall::type () const\n{\n    return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYECall {\n  constTypePtr\n  YECall::type () const\n  {\n      return ((constFunctionTypePtr)(m_sentry->type ()))->returnType ();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEReference {\n  constTypePtr\n  YEReference::type () const\n  {\n      TypePtr t = m_entry->type()->clone();\n      t->asReference();\n      return t;\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YEReference",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "197-207",
    "snippet": "YCPValue\nYEReference::evaluate (bool cse)\n{\n    if (cse) return YCPNull();\n\n    YCPValue value = YCPReference (m_entry);\n#if DO_DEBUG\n    y2debug (\"YEReference::evaluate (%s) = %s\", toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n    return value;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEReference::evaluate (%s) = %s\"",
            "toString().c_str()",
            "value.isNull() ? \"NULL\" : value->toString().c_str()"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPReference",
          "args": [
            "m_entry"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "YCPReferenceRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "212-218",
          "snippet": "YCPValue\nYCPReferenceRep::evaluate (bool /*cse*/) const\n{\n    y2debug (\"YCPReferenceRep::evaluate (%s)\", this->toString().c_str());\n\n    return m_entry->value();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPReferenceRep {\n  YCPValue\n  YCPReferenceRep::evaluate (bool /*cse*/) const\n  {\n      y2debug (\"YCPReferenceRep::evaluate (%s)\", this->toString().c_str());\n  \n      return m_entry->value();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEReference {\n  YCPValue\n  YEReference::evaluate (bool cse)\n  {\n      if (cse) return YCPNull();\n  \n      YCPValue value = YCPReference (m_entry);\n  #if DO_DEBUG\n      y2debug (\"YEReference::evaluate (%s) = %s\", toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n      return value;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YEReference",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "190-194",
    "snippet": "string\nYEReference::toString() const\n{\n    return m_entry->toString(false);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_entry->toString",
          "args": [
            "false"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "158-232",
          "snippet": "string \nYSymbolEntry::toString (bool with_type) const\n{\n    string s = (with_type && m_global) ? \"global \" : \"\";\n#if DO_DEBUG\n    y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n    y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n#endif\n    switch (m_category)\n    {\n\tcase c_variable:\n\tcase c_reference:\n\tcase c_function:\n#if DO_DEBUG\n\t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n#endif\n\tcase c_builtin:\n\t{\n\t    if (with_type)\n\t    {\n\t\tconstFunctionTypePtr ftype = m_type;\n\t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n\t\tif (m_global\n\t\t    && m_namespace != 0\n\t\t    && !m_namespace->name().empty())\n\t\t{\n\t\t    s += (m_namespace->name() + \"::\");\n\t\t}\n\t\ts += m_name.asString();\n\t\tif ((m_category == c_builtin)\n\t\t    && (m_payload.m_decl != 0))\n\t\t{\n\t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n\t\t}\n\t\telse if ((m_category == c_function)\n\t\t\t && (m_code != 0))\n\t\t{\n\t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n\t\t}\n\t\treturn s;\n\t    }\n\t    else\n\t    {\n\t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n\t\treturn s;\n\t    }\n\t}\n\tbreak;\n\tcase c_typedef:\n\t{\n\t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n\t}\n\tbreak;\n\tcase c_const:\n\t{\n\t    return s + m_type->toString() + \" \" + m_name.asString();\n\t}\n\tbreak;\n\tcase c_namespace:\n\tcase c_self:\n\tcase c_filename:\n\tcase c_predefined:\n\t{\n\t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    return SymbolEntry::toString (with_type);\n\t}\n\tbreak;\n    }\n\n    return \"?SymbolEntry?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\n#define DO_DEBUG 0\n\nYSymbolEntry {\n  string \n  YSymbolEntry::toString (bool with_type) const\n  {\n      string s = (with_type && m_global) ? \"global \" : \"\";\n  #if DO_DEBUG\n      y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n      y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n  #endif\n      switch (m_category)\n      {\n  \tcase c_variable:\n  \tcase c_reference:\n  \tcase c_function:\n  #if DO_DEBUG\n  \t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n  #endif\n  \tcase c_builtin:\n  \t{\n  \t    if (with_type)\n  \t    {\n  \t\tconstFunctionTypePtr ftype = m_type;\n  \t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n  \t\tif (m_global\n  \t\t    && m_namespace != 0\n  \t\t    && !m_namespace->name().empty())\n  \t\t{\n  \t\t    s += (m_namespace->name() + \"::\");\n  \t\t}\n  \t\ts += m_name.asString();\n  \t\tif ((m_category == c_builtin)\n  \t\t    && (m_payload.m_decl != 0))\n  \t\t{\n  \t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n  \t\t}\n  \t\telse if ((m_category == c_function)\n  \t\t\t && (m_code != 0))\n  \t\t{\n  \t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n  \t\t}\n  \t\treturn s;\n  \t    }\n  \t    else\n  \t    {\n  \t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n  \t\treturn s;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase c_typedef:\n  \t{\n  \t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n  \t}\n  \tbreak;\n  \tcase c_const:\n  \t{\n  \t    return s + m_type->toString() + \" \" + m_name.asString();\n  \t}\n  \tbreak;\n  \tcase c_namespace:\n  \tcase c_self:\n  \tcase c_filename:\n  \tcase c_predefined:\n  \t{\n  \t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    return SymbolEntry::toString (with_type);\n  \t}\n  \tbreak;\n      }\n  \n      return \"?SymbolEntry?\";\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEReference {\n  string\n  YEReference::toString() const\n  {\n      return m_entry->toString(false);\n  }\n}"
  },
  {
    "function_name": "entry",
    "container": "YEReference",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "176-180",
    "snippet": "SymbolEntryPtr \nYEReference::entry() const\n{\n    return m_entry;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEReference {\n  SymbolEntryPtr \n  YEReference::entry() const\n  {\n      return m_entry;\n  }\n}"
  },
  {
    "function_name": "YEReference",
    "container": "YEReference",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "169-173",
    "snippet": "YEReference::YEReference (bytecodeistream & str)\n    : YCode ()\n{\n    m_entry = Bytecode::readEntry (str);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readEntry",
          "args": [
            "str"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "readEntry",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "762-815",
          "snippet": "SymbolEntryPtr \nBytecode::readEntry (bytecodeistream & str)\n{\n    // read reference to namespaces (namespace_id) symbol table (position)\n    int namespace_id = Bytecode::readInt32 (str);\n    int position = Bytecode::readInt32 (str);\n\n    if (namespace_id == -1)\n    {\n#if DO_DEBUG\n\ty2debug( \"Special entry without namespace\" );\n#endif\n\t// FIXME: this may be wrong\n\treturn 0;\n    }\n\n    // get namespace pointer and SymbolEntry within namespace\n    const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n    if (name_space == 0)\n    {\n\ty2error (\"invalid namespace %d for entry\", namespace_id);\n\treturn 0;\n    }\n\n    SymbolEntryPtr sentry;\n    if (position < 0)\t\t\t\t// it's an Xref !\n    {\n\tSymbolTable *table = name_space->table();\n\tif (table == 0)\n\t{\n\t    ycp2error (\"No table associated to xref namespace\\n\");\n\t    exit (1);\n\t}\n\tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n#if DO_DEBUG\n\ty2debug (\"get reference %d from table %p\", position, table);\n#endif\n\tsentry = table->getXRef(position);\n    }\n    else\n    {\n\tsentry = name_space->symbolEntry (position);\n    }\n\n    if (sentry == 0)\n    {\n\ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n\treturn 0;\n    }\n#if DO_DEBUG\n    y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n#endif\n    return sentry;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  SymbolEntryPtr \n  Bytecode::readEntry (bytecodeistream & str)\n  {\n      // read reference to namespaces (namespace_id) symbol table (position)\n      int namespace_id = Bytecode::readInt32 (str);\n      int position = Bytecode::readInt32 (str);\n  \n      if (namespace_id == -1)\n      {\n  #if DO_DEBUG\n  \ty2debug( \"Special entry without namespace\" );\n  #endif\n  \t// FIXME: this may be wrong\n  \treturn 0;\n      }\n  \n      // get namespace pointer and SymbolEntry within namespace\n      const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n      if (name_space == 0)\n      {\n  \ty2error (\"invalid namespace %d for entry\", namespace_id);\n  \treturn 0;\n      }\n  \n      SymbolEntryPtr sentry;\n      if (position < 0)\t\t\t\t// it's an Xref !\n      {\n  \tSymbolTable *table = name_space->table();\n  \tif (table == 0)\n  \t{\n  \t    ycp2error (\"No table associated to xref namespace\\n\");\n  \t    exit (1);\n  \t}\n  \tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n  #if DO_DEBUG\n  \ty2debug (\"get reference %d from table %p\", position, table);\n  #endif\n  \tsentry = table->getXRef(position);\n      }\n      else\n      {\n  \tsentry = name_space->symbolEntry (position);\n      }\n  \n      if (sentry == 0)\n      {\n  \ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n  \treturn 0;\n      }\n  #if DO_DEBUG\n      y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n  #endif\n      return sentry;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEReference {\n  YEReference::YEReference (bytecodeistream & str)\n      : YCode ()\n  {\n      m_entry = Bytecode::readEntry (str);\n  }\n}"
  },
  {
    "function_name": "YEReference",
    "container": "YEReference",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "159-166",
    "snippet": "YEReference::YEReference (SymbolEntryPtr entry)\n    : YCode ()\n    , m_entry (entry)\n{\n#if DO_DEBUG\n    y2debug (\"YEReference::YEReference (%s)\", entry->toString().c_str());\n#endif\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEReference::YEReference (%s)\"",
            "entry->toString().c_str()"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry->toString",
          "args": [],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEReference {\n  YEReference::YEReference (SymbolEntryPtr entry)\n      : YCode ()\n      , m_entry (entry)\n  {\n  #if DO_DEBUG\n      y2debug (\"YEReference::YEReference (%s)\", entry->toString().c_str());\n  #endif\n  }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "YEVariable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "112-136",
    "snippet": "YCPValue\nYEVariable::evaluate (bool cse)\n{\n    if (cse) return YCPNull();\n\n    YCPValue value = m_entry->value();\t\t// get current value\n\n    if (value.isNull())\t\t\t\t// oops, no value yet\n    {\n\t// it's OK for the functions (somebody wants our code (function pointers)), but not others\n\tif (! m_entry->isFunction ())\n\t{\n\t    ycp2error (\"YEVariable::evaluate (%s) is not initialized\", toString().c_str());\n\t    value = YCPVoid ();\n\t}\n\telse\n\t{\n\t    value = YCPReference (m_entry);\n\t}\n    }\n#if DO_DEBUG\n    y2debug (\"YEVariable::evaluate (%s) = %s\", toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n    return value;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"YEVariable::evaluate (%s) = %s\"",
            "toString().c_str()",
            "value.isNull() ? \"NULL\" : value->toString().c_str()"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->toString",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YECall",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "2956-2976",
          "snippet": "string\nYECall::toString() const\n{\n#if DO_DEBUG\n    y2debug (\"YECall::toString [%p]\", this);\n#endif\n    string s = m_sentry->toString(false);\n\n    s += \" (\";\n    \n    for (uint i = 0 ; i < m_next_param_id ; i++)\n    {\n\ts += m_parameters[i]->toString().c_str();\n\tif (i + 1 < m_next_param_id)\n\t{\n\t    s += \", \";\n\t}\n    }\n    s += \")\";\n    return s;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYECall {\n  string\n  YECall::toString() const\n  {\n  #if DO_DEBUG\n      y2debug (\"YECall::toString [%p]\", this);\n  #endif\n      string s = m_sentry->toString(false);\n  \n      s += \" (\";\n      \n      for (uint i = 0 ; i < m_next_param_id ; i++)\n      {\n  \ts += m_parameters[i]->toString().c_str();\n  \tif (i + 1 < m_next_param_id)\n  \t{\n  \t    s += \", \";\n  \t}\n      }\n      s += \")\";\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPReference",
          "args": [
            "m_entry"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "YCPReferenceRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPCode.cc",
          "lines": "212-218",
          "snippet": "YCPValue\nYCPReferenceRep::evaluate (bool /*cse*/) const\n{\n    y2debug (\"YCPReferenceRep::evaluate (%s)\", this->toString().c_str());\n\n    return m_entry->value();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPReferenceRep {\n  YCPValue\n  YCPReferenceRep::evaluate (bool /*cse*/) const\n  {\n      y2debug (\"YCPReferenceRep::evaluate (%s)\", this->toString().c_str());\n  \n      return m_entry->value();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"YEVariable::evaluate (%s) is not initialized\"",
            "toString().c_str()"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_entry->isFunction",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "isFunction",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "303-303",
          "snippet": "bool isFunction () const\t{ return m_kind == FunctionT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isFunction () const\t{ return m_kind == FunctionT; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.isNull",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_entry->value",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nYEVariable {\n  YCPValue\n  YEVariable::evaluate (bool cse)\n  {\n      if (cse) return YCPNull();\n  \n      YCPValue value = m_entry->value();\t\t// get current value\n  \n      if (value.isNull())\t\t\t\t// oops, no value yet\n      {\n  \t// it's OK for the functions (somebody wants our code (function pointers)), but not others\n  \tif (! m_entry->isFunction ())\n  \t{\n  \t    ycp2error (\"YEVariable::evaluate (%s) is not initialized\", toString().c_str());\n  \t    value = YCPVoid ();\n  \t}\n  \telse\n  \t{\n  \t    value = YCPReference (m_entry);\n  \t}\n      }\n  #if DO_DEBUG\n      y2debug (\"YEVariable::evaluate (%s) = %s\", toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n      return value;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "YEVariable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "105-109",
    "snippet": "string\nYEVariable::toString() const\n{\n    return m_entry->toString(false);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_entry->toString",
          "args": [
            "false"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YSymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YSymbolEntry.cc",
          "lines": "158-232",
          "snippet": "string \nYSymbolEntry::toString (bool with_type) const\n{\n    string s = (with_type && m_global) ? \"global \" : \"\";\n#if DO_DEBUG\n    y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n    y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n#endif\n    switch (m_category)\n    {\n\tcase c_variable:\n\tcase c_reference:\n\tcase c_function:\n#if DO_DEBUG\n\t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n#endif\n\tcase c_builtin:\n\t{\n\t    if (with_type)\n\t    {\n\t\tconstFunctionTypePtr ftype = m_type;\n\t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n\t\tif (m_global\n\t\t    && m_namespace != 0\n\t\t    && !m_namespace->name().empty())\n\t\t{\n\t\t    s += (m_namespace->name() + \"::\");\n\t\t}\n\t\ts += m_name.asString();\n\t\tif ((m_category == c_builtin)\n\t\t    && (m_payload.m_decl != 0))\n\t\t{\n\t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n\t\t}\n\t\telse if ((m_category == c_function)\n\t\t\t && (m_code != 0))\n\t\t{\n\t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n\t\t}\n\t\treturn s;\n\t    }\n\t    else\n\t    {\n\t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n\t\treturn s;\n\t    }\n\t}\n\tbreak;\n\tcase c_typedef:\n\t{\n\t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n\t}\n\tbreak;\n\tcase c_const:\n\t{\n\t    return s + m_type->toString() + \" \" + m_name.asString();\n\t}\n\tbreak;\n\tcase c_namespace:\n\tcase c_self:\n\tcase c_filename:\n\tcase c_predefined:\n\t{\n\t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n\t}\n\tbreak;\n\tdefault:\n\t{\n\t    return SymbolEntry::toString (with_type);\n\t}\n\tbreak;\n    }\n\n    return \"?SymbolEntry?\";\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\n#define DO_DEBUG 0\n\nYSymbolEntry {\n  string \n  YSymbolEntry::toString (bool with_type) const\n  {\n      string s = (with_type && m_global) ? \"global \" : \"\";\n  #if DO_DEBUG\n      y2debug (\"YSymbolEntry::toString %p: name '%s'\", this, m_name.asString().c_str());\n      y2debug (\"YSymbolEntry::toString %p: with_type %d, cat %s, name '%s'\", this, with_type, catString().c_str(), m_name.asString().c_str());\n  #endif\n      switch (m_category)\n      {\n  \tcase c_variable:\n  \tcase c_reference:\n  \tcase c_function:\n  #if DO_DEBUG\n  \t    y2debug (\"m_namespace %p[%s], m_global %d, with_type %d\", m_namespace, m_namespace ? m_namespace->name().c_str() : \"\", m_global, with_type);\n  #endif\n  \tcase c_builtin:\n  \t{\n  \t    if (with_type)\n  \t    {\n  \t\tconstFunctionTypePtr ftype = m_type;\n  \t\ts += (((m_category == c_variable)||(m_category ==c_reference)) ? m_type->toString() : ftype->returnType()->toString()) + \" \";\n  \t\tif (m_global\n  \t\t    && m_namespace != 0\n  \t\t    && !m_namespace->name().empty())\n  \t\t{\n  \t\t    s += (m_namespace->name() + \"::\");\n  \t\t}\n  \t\ts += m_name.asString();\n  \t\tif ((m_category == c_builtin)\n  \t\t    && (m_payload.m_decl != 0))\n  \t\t{\n  \t\t    s += \"(\" + m_payload.m_decl->type->toString() + \")\";\n  \t\t}\n  \t\telse if ((m_category == c_function)\n  \t\t\t && (m_code != 0))\n  \t\t{\n  \t\t    s += ((YFunctionPtr)m_code)->toStringDeclaration();\n  \t\t}\n  \t\treturn s;\n  \t    }\n  \t    else\n  \t    {\n  \t\tstring s = string ((m_global && (m_namespace!=0)) ? (m_namespace->name() + \"::\") : \"\") + m_name.asString();\n  \t\treturn s;\n  \t    }\n  \t}\n  \tbreak;\n  \tcase c_typedef:\n  \t{\n  \t    return s + catString() + \" \" + m_type->toString() + \" \" + m_name.asString() + \";\";\n  \t}\n  \tbreak;\n  \tcase c_const:\n  \t{\n  \t    return s + m_type->toString() + \" \" + m_name.asString();\n  \t}\n  \tbreak;\n  \tcase c_namespace:\n  \tcase c_self:\n  \tcase c_filename:\n  \tcase c_predefined:\n  \t{\n  \t    return s + catString() + \" '\" + m_name.asString() + \"'\";\n  \t}\n  \tbreak;\n  \tdefault:\n  \t{\n  \t    return SymbolEntry::toString (with_type);\n  \t}\n  \tbreak;\n      }\n  \n      return \"?SymbolEntry?\";\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEVariable {\n  string\n  YEVariable::toString() const\n  {\n      return m_entry->toString(false);\n  }\n}"
  },
  {
    "function_name": "entry",
    "container": "YEVariable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "91-95",
    "snippet": "SymbolEntryPtr\nYEVariable::entry() const\n{\n    return m_entry;\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEVariable {\n  SymbolEntryPtr\n  YEVariable::entry() const\n  {\n      return m_entry;\n  }\n}"
  },
  {
    "function_name": "YEVariable",
    "container": "YEVariable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "84-88",
    "snippet": "YEVariable::YEVariable (bytecodeistream & str)\n    : YCode ()\n{\n    m_entry = Bytecode::readEntry (str);\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Bytecode::readEntry",
          "args": [
            "str"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "readEntry",
          "container": "Bytecode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Bytecode.cc",
          "lines": "762-815",
          "snippet": "SymbolEntryPtr \nBytecode::readEntry (bytecodeistream & str)\n{\n    // read reference to namespaces (namespace_id) symbol table (position)\n    int namespace_id = Bytecode::readInt32 (str);\n    int position = Bytecode::readInt32 (str);\n\n    if (namespace_id == -1)\n    {\n#if DO_DEBUG\n\ty2debug( \"Special entry without namespace\" );\n#endif\n\t// FIXME: this may be wrong\n\treturn 0;\n    }\n\n    // get namespace pointer and SymbolEntry within namespace\n    const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n    if (name_space == 0)\n    {\n\ty2error (\"invalid namespace %d for entry\", namespace_id);\n\treturn 0;\n    }\n\n    SymbolEntryPtr sentry;\n    if (position < 0)\t\t\t\t// it's an Xref !\n    {\n\tSymbolTable *table = name_space->table();\n\tif (table == 0)\n\t{\n\t    ycp2error (\"No table associated to xref namespace\\n\");\n\t    exit (1);\n\t}\n\tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n#if DO_DEBUG\n\ty2debug (\"get reference %d from table %p\", position, table);\n#endif\n\tsentry = table->getXRef(position);\n    }\n    else\n    {\n\tsentry = name_space->symbolEntry (position);\n    }\n\n    if (sentry == 0)\n    {\n\ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n\treturn 0;\n    }\n#if DO_DEBUG\n    y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n#endif\n    return sentry;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fstream>",
            "#include \"ycp/pathsearch.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2/Y2Namespace.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCode.h\"",
            "#include \"YCP.h\"",
            "#include \"ycp/Bytecode.h\""
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <fstream>\n#include \"ycp/pathsearch.h\"\n#include \"ycp/y2log.h\"\n#include \"y2/Y2Namespace.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCode.h\"\n#include \"YCP.h\"\n#include \"ycp/Bytecode.h\"\n\n#define DO_DEBUG 0\n\nBytecode {\n  SymbolEntryPtr \n  Bytecode::readEntry (bytecodeistream & str)\n  {\n      // read reference to namespaces (namespace_id) symbol table (position)\n      int namespace_id = Bytecode::readInt32 (str);\n      int position = Bytecode::readInt32 (str);\n  \n      if (namespace_id == -1)\n      {\n  #if DO_DEBUG\n  \ty2debug( \"Special entry without namespace\" );\n  #endif\n  \t// FIXME: this may be wrong\n  \treturn 0;\n      }\n  \n      // get namespace pointer and SymbolEntry within namespace\n      const Y2Namespace *name_space = Bytecode::namespacePtr (namespace_id);\n      if (name_space == 0)\n      {\n  \ty2error (\"invalid namespace %d for entry\", namespace_id);\n  \treturn 0;\n      }\n  \n      SymbolEntryPtr sentry;\n      if (position < 0)\t\t\t\t// it's an Xref !\n      {\n  \tSymbolTable *table = name_space->table();\n  \tif (table == 0)\n  \t{\n  \t    ycp2error (\"No table associated to xref namespace\\n\");\n  \t    exit (1);\n  \t}\n  \tposition = -position - 1;\t\t// -1 .. -n  --> 0 .. n-1\n  #if DO_DEBUG\n  \ty2debug (\"get reference %d from table %p\", position, table);\n  #endif\n  \tsentry = table->getXRef(position);\n      }\n      else\n      {\n  \tsentry = name_space->symbolEntry (position);\n      }\n  \n      if (sentry == 0)\n      {\n  \ty2error (\"invalid entry %d for namespace (%s)\", position, name_space->name().c_str());\n  \treturn 0;\n      }\n  #if DO_DEBUG\n      y2debug (\"entry <namespace id %d @ %p[%s]> pos %d = (%s)\", namespace_id, name_space, name_space->name().c_str(), position, sentry->toString().c_str());\n  #endif\n      return sentry;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEVariable {\n  YEVariable::YEVariable (bytecodeistream & str)\n      : YCode ()\n  {\n      m_entry = Bytecode::readEntry (str);\n  }\n}"
  },
  {
    "function_name": "YEVariable",
    "container": "YEVariable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
    "lines": "77-81",
    "snippet": "YEVariable::YEVariable (SymbolEntryPtr entry)\n    : YCode ()\n    , m_entry (entry)\n{\n}",
    "includes": [
      "#include \"ycp/Xmlcode.h\"",
      "#include \"ycp/Bytecode.h\"",
      "#include \"ycp/SymbolTable.h\"",
      "#include \"ycp/YExpression.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPMap.h\"",
      "#include \"ycp/YCPList.h\"",
      "#include \"ycp/YCPFloat.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPTerm.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YBlock.h\"",
      "#include \"ycp/YStatement.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/y2log.h\"",
      "#include <libintl.h>\t// for dngettext"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\nYEVariable {\n  YEVariable::YEVariable (SymbolEntryPtr entry)\n      : YCode ()\n      , m_entry (entry)\n  {\n  }\n}"
  }
]