[
  {
    "function_name": "writeFile",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "475-563",
    "snippet": "bool ModulesConf::writeFile(const string fname) {\n    updateIfModified();\n\n    if (modified) {\n\tstring dest_name;\n\tint dr;\n\n        string temp_name = ((fname != \"\") ? fname : file_name) + \".YaST2.tmp\";\n\n\tofstream of(temp_name.c_str ());\n\n\tif (!of.good())\n\t    Y2_RETURN_FALSE(\"Unable to write '%s'.\", temp_name.c_str ());\n\n\tModulesConfIndex::iterator it = modules_conf_index.begin ();\n\n\tstring localinclude = \"\";\n\tstring dir, mod, arg, com;\n\tfor (; it != modules_conf_index.end (); ++it)\n        {\n\n\t    dir = it->substr (1, it->find_first_of (\".\", 1) - 1);\n\t    mod = it->substr (it->find_first_of (\".\", 1) + 1, it->length ());\n\n\t    if (isModule (dir, mod))\n            {\n\t\t/* options directiove */\n\t\tif (dir == \"options\")\n\t\t    of << getComment(dir,mod) << dir + \" \" + mod + getOptionsAsString(mod) << endl;\n\t\t/* no arguments */\n\t\telse if(dir == \"keep\")\n\t\t    of << getComment(dir,mod) << dir << endl;\n\t\t/* comment at EOF */\n\t\telse if(dir == FINAL_COMMENT)\n\t\t    of << getComment(dir,mod); // << endl;\n\t\t/* postpone directive */\n\t\telse if(dir == \"include\" && (mod == \"/etc/modules.conf.local\" || mod == \"/etc/modprobe.conf.local\"))\n\t\t    localinclude = getComment(dir,mod) + dir + \" \" + mod + \" \" + getArgument(dir,mod) + \"\\n\";\n\t\t/* normal directive */\n\t\telse\n\t\t    of << getComment(dir,mod) << dir + \" \" + mod + \" \" + getArgument(dir,mod) << endl;\n\n                if (of.fail ())\n\t\t{\n\t\t    of.close ();\n\t\t    Y2_RETURN_FALSE (\"Unable to write '%s'.\", temp_name.c_str ());\n                }\n\n\t\tmodules_conf_map[dir][mod].Set(ModuleEntry::INIT);\n\n            }\n\t    else\n            {\n\t\ty2error(\"Wrong path in index '%s'.\", it->c_str ());\n            }\n        }\n\n\tif(localinclude != \"\") {\n\t    y2debug(\"Include last: %s\", localinclude.c_str());\n\t    of << localinclude;\n\t}\n\n\tif (fname == \"\")\n\t    dest_name = file_name;\n\telse\n\t    dest_name = fname;\n\n\tstring backup_name = dest_name + BACKUP_EXTENSION;\n\n\tif (rename (dest_name.c_str (), backup_name.c_str ()) < 0)\n\t    y2warning (\"Error while creating backup file in writeFile (): %s\", strerror(errno));\n\n\tif (rename (temp_name.c_str (), dest_name.c_str()) < 0)\n        {\n            rename (backup_name.c_str (), dest_name.c_str ());\n\t    Y2_RETURN_FALSE (\"Error while moving file in writeFile (): %s\", strerror(errno));\n        }\n\n\tdr = system (\"/sbin/depmod -a -F /boot/System.map-`uname -r` `uname -r` 2> /dev/null\");\n\tif (dr < 0 || dr == 127)\n\t    Y2_RETURN_FALSE (\"Error while calling depmod in writeFile ()\");\n\n\tmodified = false;\n    }\n    else\n\ty2milestone(\"Modules not modified, not writing\");\n\n    return updateTimeStamp ();\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FINAL_COMMENT \"YaST2_final_modules_conf_comment\"",
      "#define BACKUP_EXTENSION \".YaST2save\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "updateTimeStamp",
          "args": [],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "updateTimeStamp",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "265-268",
          "snippet": "bool ModulesConf::updateTimeStamp() {\n    time_stamp = getTimeStamp(file_name);\n    return (time_stamp != 0);\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::updateTimeStamp() {\n      time_stamp = getTimeStamp(file_name);\n      return (time_stamp != 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2milestone",
          "args": [
            "\"Modules not modified, not writing\""
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_FALSE",
          "args": [
            "\"Error while calling depmod in writeFile ()\""
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "\"/sbin/depmod -a -F /boot/System.map-`uname -r` `uname -r` 2> /dev/null\""
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_FALSE",
          "args": [
            "\"Error while moving file in writeFile (): %s\"",
            "strerror(errno)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "backup_name.c_str ()",
            "dest_name.c_str ()"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "rename",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "558-565",
          "snippet": "int PathInfo::rename( const Pathname & oldpath, const Pathname & newpath )\n{\n  DBG << \"rename \" << oldpath << \" -> \" << newpath;\n  if ( ::rename( oldpath.asString().c_str(), newpath.asString().c_str() ) == -1 ) {\n    return _Log_Result( errno );\n  }\n  return _Log_Result( 0 );\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::rename( const Pathname & oldpath, const Pathname & newpath )\n  {\n    DBG << \"rename \" << oldpath << \" -> \" << newpath;\n    if ( ::rename( oldpath.asString().c_str(), newpath.asString().c_str() ) == -1 ) {\n      return _Log_Result( errno );\n    }\n    return _Log_Result( 0 );\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dest_name.c_str",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backup_name.c_str",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dest_name.c_str",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temp_name.c_str",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"Error while creating backup file in writeFile (): %s\"",
            "strerror(errno)"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backup_name.c_str",
          "args": [],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dest_name.c_str",
          "args": [],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Include last: %s\"",
            "localinclude.c_str()"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localinclude.c_str",
          "args": [],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Wrong path in index '%s'.\"",
            "it->c_str ()"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it->c_str",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modules_conf_map[dir][mod].Set",
          "args": [
            "ModuleEntry::INIT"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "Set",
          "container": "ModuleEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "40-52",
          "snippet": "bool ModuleEntry::Set(Mode m) {\n    switch(m) {\n    case INIT:\n        dirtyflag=false;\n        return true;\n    case SET:\n        dirtyflag=true;\n        return true;\n    case REINIT:\n        return !dirtyflag;\n    }\n    return false;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModuleEntry {\n  bool ModuleEntry::Set(Mode m) {\n      switch(m) {\n      case INIT:\n          dirtyflag=false;\n          return true;\n      case SET:\n          dirtyflag=true;\n          return true;\n      case REINIT:\n          return !dirtyflag;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_FALSE",
          "args": [
            "\"Unable to write '%s'.\"",
            "temp_name.c_str ()"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temp_name.c_str",
          "args": [],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of.close",
          "args": [],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "325-351",
          "snippet": "int\nExternalProgram::close()\n{\n    if (pid > 0)\n    {\n\tExternalDataSource::close();\n\t// Wait for child to exit\n\tint ret;\n        int status = 0;\n\tdo\n\t{\n\t    ret = waitpid(pid, &status, 0);\n\t}\n\twhile (ret == -1 && errno == EINTR);\n\n\tif (ret != -1)\n\t{\n\t    status = checkStatus( status );\n\t}\n        pid = -1;\n        return status;\n    }\n    else\n    {\n        return _exitStatus;\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  int\n  ExternalProgram::close()\n  {\n      if (pid > 0)\n      {\n  \tExternalDataSource::close();\n  \t// Wait for child to exit\n  \tint ret;\n          int status = 0;\n  \tdo\n  \t{\n  \t    ret = waitpid(pid, &status, 0);\n  \t}\n  \twhile (ret == -1 && errno == EINTR);\n  \n  \tif (ret != -1)\n  \t{\n  \t    status = checkStatus( status );\n  \t}\n          pid = -1;\n          return status;\n      }\n      else\n      {\n          return _exitStatus;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "of.fail",
          "args": [],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getArgument",
          "args": [
            "dir",
            "mod"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "getArgument",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "143-156",
          "snippet": "string ModulesConf::getArgument(const string directive, const string module) {\n    updateIfModified ();\n    if(!isModule(directive,module))\n\tY2_RETURN_STR(\"Bad directive or module: %s, %s\", directive.c_str(), module.c_str());\n\n    ModuleEntry::EntryArg ea = modules_conf_map[directive][module].getArgument();\n    y2debug(\"getArgument(%s,%s) %p\",directive.c_str(),module.c_str(), this);\n    if(ea.find(MAGIC_ENTRY)==ea.end()) {\n        y2warning(\"Bad request for string while there are options (%s, %s).\", directive.c_str(), module.c_str());\n        return getOptionsAsString(module);\n    }\n    y2debug(\"MAGIC: %s\", ea[MAGIC_ENTRY].c_str());\n    return ea[MAGIC_ENTRY];\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  string ModulesConf::getArgument(const string directive, const string module) {\n      updateIfModified ();\n      if(!isModule(directive,module))\n  \tY2_RETURN_STR(\"Bad directive or module: %s, %s\", directive.c_str(), module.c_str());\n  \n      ModuleEntry::EntryArg ea = modules_conf_map[directive][module].getArgument();\n      y2debug(\"getArgument(%s,%s) %p\",directive.c_str(),module.c_str(), this);\n      if(ea.find(MAGIC_ENTRY)==ea.end()) {\n          y2warning(\"Bad request for string while there are options (%s, %s).\", directive.c_str(), module.c_str());\n          return getOptionsAsString(module);\n      }\n      y2debug(\"MAGIC: %s\", ea[MAGIC_ENTRY].c_str());\n      return ea[MAGIC_ENTRY];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getComment",
          "args": [
            "dir",
            "mod"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "getComment",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "158-164",
          "snippet": "string ModulesConf::getComment(const string directive, const string module) {\n    updateIfModified ();\n    if(!isModule(directive,module))\n\tY2_RETURN_STR(\"Bad directive or module: %s, %s\", directive.c_str(), module.c_str());\n\n    return modules_conf_map[directive][module].getComment();\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  string ModulesConf::getComment(const string directive, const string module) {\n      updateIfModified ();\n      if(!isModule(directive,module))\n  \tY2_RETURN_STR(\"Bad directive or module: %s, %s\", directive.c_str(), module.c_str());\n  \n      return modules_conf_map[directive][module].getComment();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getOptionsAsString",
          "args": [
            "mod"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "getOptionsAsString",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "200-211",
          "snippet": "string ModulesConf::getOptionsAsString (const string module) {\n    ModuleEntry::EntryArg::const_iterator it;\n    ModuleEntry::EntryArg entry;\n    string ret;\n\n    entry = getOptions(module);\n    it = entry.begin();\n    for (; it != entry.end(); ++it)\n\tret += \" \" + it->first + (it->second != \"\" ? (it->first == \"-o\" ? \" \" : \"=\") + it->second : \"\");\n\n    return ret;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  string ModulesConf::getOptionsAsString (const string module) {\n      ModuleEntry::EntryArg::const_iterator it;\n      ModuleEntry::EntryArg entry;\n      string ret;\n  \n      entry = getOptions(module);\n      it = entry.begin();\n      for (; it != entry.end(); ++it)\n  \tret += \" \" + it->first + (it->second != \"\" ? (it->first == \"-o\" ? \" \" : \"=\") + it->second : \"\");\n  \n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isModule",
          "args": [
            "dir",
            "mod"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "isModule",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "114-117",
          "snippet": "bool ModulesConf::isModule(const string directive, const string module) {\n    return isDirective (directive) &&\n\tmodules_conf_map[directive].find(module) != modules_conf_map[directive].end();\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::isModule(const string directive, const string module) {\n      return isDirective (directive) &&\n  \tmodules_conf_map[directive].find(module) != modules_conf_map[directive].end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "it->substr",
          "args": [
            "it->find_first_of (\".\", 1) + 1",
            "it->length ()"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it->length",
          "args": [],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "it->find_first_of",
          "args": [
            "\".\"",
            "1"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it->substr",
          "args": [
            "1",
            "it->find_first_of (\".\", 1) - 1"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it->find_first_of",
          "args": [
            "\".\"",
            "1"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modules_conf_index.end",
          "args": [],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf_index.begin",
          "args": [],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_FALSE",
          "args": [
            "\"Unable to write '%s'.\"",
            "temp_name.c_str ()"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temp_name.c_str",
          "args": [],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of.good",
          "args": [],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temp_name.c_str",
          "args": [],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "updateIfModified",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "updateIfModified",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "270-277",
          "snippet": "bool ModulesConf::updateIfModified() {\n    if (time_stamp != getTimeStamp(file_name)) {\n\ty2warning(\"Config file has been changed by an external program.\");\n\tif(!parseFile(file_name, ModuleEntry::REINIT))\n\t    Y2_RETURN_FALSE(\"updateIfModified: parseFile failed\");\n    }\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::updateIfModified() {\n      if (time_stamp != getTimeStamp(file_name)) {\n  \ty2warning(\"Config file has been changed by an external program.\");\n  \tif(!parseFile(file_name, ModuleEntry::REINIT))\n  \t    Y2_RETURN_FALSE(\"updateIfModified: parseFile failed\");\n      }\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define FINAL_COMMENT \"YaST2_final_modules_conf_comment\"\n#define BACKUP_EXTENSION \".YaST2save\"\n\nModulesConf {\n  bool ModulesConf::writeFile(const string fname) {\n      updateIfModified();\n  \n      if (modified) {\n  \tstring dest_name;\n  \tint dr;\n  \n          string temp_name = ((fname != \"\") ? fname : file_name) + \".YaST2.tmp\";\n  \n  \tofstream of(temp_name.c_str ());\n  \n  \tif (!of.good())\n  \t    Y2_RETURN_FALSE(\"Unable to write '%s'.\", temp_name.c_str ());\n  \n  \tModulesConfIndex::iterator it = modules_conf_index.begin ();\n  \n  \tstring localinclude = \"\";\n  \tstring dir, mod, arg, com;\n  \tfor (; it != modules_conf_index.end (); ++it)\n          {\n  \n  \t    dir = it->substr (1, it->find_first_of (\".\", 1) - 1);\n  \t    mod = it->substr (it->find_first_of (\".\", 1) + 1, it->length ());\n  \n  \t    if (isModule (dir, mod))\n              {\n  \t\t/* options directiove */\n  \t\tif (dir == \"options\")\n  \t\t    of << getComment(dir,mod) << dir + \" \" + mod + getOptionsAsString(mod) << endl;\n  \t\t/* no arguments */\n  \t\telse if(dir == \"keep\")\n  \t\t    of << getComment(dir,mod) << dir << endl;\n  \t\t/* comment at EOF */\n  \t\telse if(dir == FINAL_COMMENT)\n  \t\t    of << getComment(dir,mod); // << endl;\n  \t\t/* postpone directive */\n  \t\telse if(dir == \"include\" && (mod == \"/etc/modules.conf.local\" || mod == \"/etc/modprobe.conf.local\"))\n  \t\t    localinclude = getComment(dir,mod) + dir + \" \" + mod + \" \" + getArgument(dir,mod) + \"\\n\";\n  \t\t/* normal directive */\n  \t\telse\n  \t\t    of << getComment(dir,mod) << dir + \" \" + mod + \" \" + getArgument(dir,mod) << endl;\n  \n                  if (of.fail ())\n  \t\t{\n  \t\t    of.close ();\n  \t\t    Y2_RETURN_FALSE (\"Unable to write '%s'.\", temp_name.c_str ());\n                  }\n  \n  \t\tmodules_conf_map[dir][mod].Set(ModuleEntry::INIT);\n  \n              }\n  \t    else\n              {\n  \t\ty2error(\"Wrong path in index '%s'.\", it->c_str ());\n              }\n          }\n  \n  \tif(localinclude != \"\") {\n  \t    y2debug(\"Include last: %s\", localinclude.c_str());\n  \t    of << localinclude;\n  \t}\n  \n  \tif (fname == \"\")\n  \t    dest_name = file_name;\n  \telse\n  \t    dest_name = fname;\n  \n  \tstring backup_name = dest_name + BACKUP_EXTENSION;\n  \n  \tif (rename (dest_name.c_str (), backup_name.c_str ()) < 0)\n  \t    y2warning (\"Error while creating backup file in writeFile (): %s\", strerror(errno));\n  \n  \tif (rename (temp_name.c_str (), dest_name.c_str()) < 0)\n          {\n              rename (backup_name.c_str (), dest_name.c_str ());\n  \t    Y2_RETURN_FALSE (\"Error while moving file in writeFile (): %s\", strerror(errno));\n          }\n  \n  \tdr = system (\"/sbin/depmod -a -F /boot/System.map-`uname -r` `uname -r` 2> /dev/null\");\n  \tif (dr < 0 || dr == 127)\n  \t    Y2_RETURN_FALSE (\"Error while calling depmod in writeFile ()\");\n  \n  \tmodified = false;\n      }\n      else\n  \ty2milestone(\"Modules not modified, not writing\");\n  \n      return updateTimeStamp ();\n  }\n}"
  },
  {
    "function_name": "removeEntry",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "457-470",
    "snippet": "bool ModulesConf::removeEntry(const string directive, const string module) {\n    modified = true;\n    if(!isModule(directive,module)) {\n        y2warning(\"removeEntry: no such directive or module (%s,%s)\",directive.c_str(),module.c_str());\n\treturn false;\n    }\n    if(modules_conf_map[directive].erase(module) < 1)\n        Y2_RETURN_FALSE(\"removeEntry: erase failed (%s,%s)\",directive.c_str(),module.c_str());\n    if(modules_conf_map[directive].empty())\n        if(modules_conf_map.erase(directive) < 1)\n            Y2_RETURN_FALSE(\"removeEntry: erase failed (%s)\",directive.c_str());\n    modules_conf_index.remove(\".\"+directive+\".\"+module);\n    return true;\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "modules_conf_index.remove",
          "args": [
            "\".\"+directive+\".\"+module"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "remove",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "104-113",
          "snippet": "void YCPMapRep::remove(const YCPValue& key)\n{\n    if (!key->isString() && !key->isInteger() && !key->isSymbol())\n    {\n        ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n        return;\n    }\n\n    stl_map.erase (key);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void YCPMapRep::remove(const YCPValue& key)\n  {\n      if (!key->isString() && !key->isInteger() && !key->isSymbol())\n      {\n          ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n          return;\n      }\n  \n      stl_map.erase (key);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_FALSE",
          "args": [
            "\"removeEntry: erase failed (%s)\"",
            "directive.c_str()"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "directive.c_str",
          "args": [],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modules_conf_map.erase",
          "args": [
            "directive"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "683-695",
          "snippet": "int PathInfo::erase( const Pathname & path )\n{\n  int res = 0;\n  PathInfo p( path, LSTAT );\n  if ( p.isExist() )\n    {\n      if ( p.isDir() )\n        res = PathInfo::recursive_rmdir( path );\n      else\n        res = PathInfo::unlink( path );\n    }\n  return res;\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::erase( const Pathname & path )\n  {\n    int res = 0;\n    PathInfo p( path, LSTAT );\n    if ( p.isExist() )\n      {\n        if ( p.isDir() )\n          res = PathInfo::recursive_rmdir( path );\n        else\n          res = PathInfo::unlink( path );\n      }\n    return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf_map[directive].empty",
          "args": [],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_FALSE",
          "args": [
            "\"removeEntry: erase failed (%s,%s)\"",
            "directive.c_str()",
            "module.c_str()"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "directive.c_str",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"removeEntry: no such directive or module (%s,%s)\"",
            "directive.c_str()",
            "module.c_str()"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "directive.c_str",
          "args": [],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isModule",
          "args": [
            "directive",
            "module"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "isModule",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "114-117",
          "snippet": "bool ModulesConf::isModule(const string directive, const string module) {\n    return isDirective (directive) &&\n\tmodules_conf_map[directive].find(module) != modules_conf_map[directive].end();\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::isModule(const string directive, const string module) {\n      return isDirective (directive) &&\n  \tmodules_conf_map[directive].find(module) != modules_conf_map[directive].end();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::removeEntry(const string directive, const string module) {\n      modified = true;\n      if(!isModule(directive,module)) {\n          y2warning(\"removeEntry: no such directive or module (%s,%s)\",directive.c_str(),module.c_str());\n  \treturn false;\n      }\n      if(modules_conf_map[directive].erase(module) < 1)\n          Y2_RETURN_FALSE(\"removeEntry: erase failed (%s,%s)\",directive.c_str(),module.c_str());\n      if(modules_conf_map[directive].empty())\n          if(modules_conf_map.erase(directive) < 1)\n              Y2_RETURN_FALSE(\"removeEntry: erase failed (%s)\",directive.c_str());\n      modules_conf_index.remove(\".\"+directive+\".\"+module);\n      return true;\n  }\n}"
  },
  {
    "function_name": "parseFile",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "371-451",
    "snippet": "bool ModulesConf::parseFile(const string &fname, ModuleEntry::Mode m, const bool with_comment) {\n    ifstream is(fname.c_str());\n    string line, temp_line;\n    string comment;\n    bool backslash;\n    bool condition;\n\n    while (is) {\n\tbackslash = false;\n\tline = \"\";\n\tdo {\n\t    temp_line = \"\";\n\t    getline(is,temp_line);\n\t    temp_line.erase(temp_line.find_last_not_of (WHITESPACE) + 1, temp_line.length ());\n\n\t    if (!temp_line.empty ())\n\t\tif (backslash = (temp_line.substr (temp_line.length () - 1) == \"\\\\\"))\n\t\t    line += temp_line.substr (0, temp_line.length () - 1);\n\t} while (backslash && is);\n\n\tline += temp_line;\n\n\tif(line == \"\") {\n\t    comment += \"\\n\";\n\t    continue;\n\t}\n\n\tline.erase(0, line.find_first_not_of(WHITESPACE));\n\tstring::size_type hash =  line.find_first_of(\"#\");\n\n        condition = ((line.length () > 1) ? (line.substr (0, 2) == \"if\") : false);\n\n        /* process \"if-else\" directives as comment */\n        if (condition)\n        {\n            comment += line + \"\\n\";\n            while (condition && is) {\n                temp_line = \"\";\n                getline(is, temp_line);\n                temp_line.erase(temp_line.find_last_not_of (WHITESPACE) + 1, temp_line.length ());\n\n                if (!temp_line.empty ())\n                {\n                    comment += temp_line + \"\\n\";\n                    condition = (temp_line.find (\"endif\"));\n                }\n\n            }\n            continue;\n        }\n\n\ty2debug(\"parseFile(): %s\", line.c_str());\n        if(hash!=0) {\n            ModuleLine l;\n            parseLine(line,l);\n            y2debug(\"parseFile1: %s\", line.c_str());\n            y2debug(\"parseFile2: %s\", l.directive.c_str());\n            y2debug(\"parseFile3: %s\", l.module.c_str());\n            y2debug(\"parseFile4: %s\", l.argument.c_str());\n            comment += l.comment;\n            if(l.directive == \"options\")\n                setOptions(l.module, l.options, m);\n            else\n                setArgument(l.directive, l.module,l.argument, m);\n            if(with_comment)\n                setComment(l.directive, l.module,comment, m);\n            comment = \"\";\n        }\n        else\n            comment += line + \"\\n\";\n    }\n\n                                // keep the final comment\n    if (comment.length () && with_comment)\n    {\n        setArgument(FINAL_COMMENT, \"\", \"\", m);\n        setComment(FINAL_COMMENT, \"\", comment, m);\n    }\n\n    return updateTimeStamp();\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define FINAL_COMMENT \"YaST2_final_modules_conf_comment\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "updateTimeStamp",
          "args": [],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "updateTimeStamp",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "265-268",
          "snippet": "bool ModulesConf::updateTimeStamp() {\n    time_stamp = getTimeStamp(file_name);\n    return (time_stamp != 0);\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::updateTimeStamp() {\n      time_stamp = getTimeStamp(file_name);\n      return (time_stamp != 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setComment",
          "args": [
            "FINAL_COMMENT",
            "\"\"",
            "comment",
            "m"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "setComment",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "249-253",
          "snippet": "bool ModulesConf::setComment(const string directive, const string module, const string arg, ModuleEntry::Mode m) {\n    modified |= (m == ModuleEntry::SET);\n    modules_conf_map[directive][module].setComment(arg, m);\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::setComment(const string directive, const string module, const string arg, ModuleEntry::Mode m) {\n      modified |= (m == ModuleEntry::SET);\n      modules_conf_map[directive][module].setComment(arg, m);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setArgument",
          "args": [
            "FINAL_COMMENT",
            "\"\"",
            "\"\"",
            "m"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "setArgument",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "238-247",
          "snippet": "bool ModulesConf::setArgument(const string directive, const string module, const string arg, ModuleEntry::Mode m) {\n    if((directive == \"alias\" || directive == \"options\" || directive == \"pre-install\" || directive == \"post-install\" ) && (directive == \"\" || module == \"\" || arg == \"\")) {\n\ty2error(\"empty argument: %s, %s, %s\", directive.c_str(), module.c_str(), arg.c_str());\n\treturn false;\n    }\n    modified |= (m == ModuleEntry::SET);\n    updateIndex(directive,module);\n    modules_conf_map[directive][module].setArgument(arg, m);\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::setArgument(const string directive, const string module, const string arg, ModuleEntry::Mode m) {\n      if((directive == \"alias\" || directive == \"options\" || directive == \"pre-install\" || directive == \"post-install\" ) && (directive == \"\" || module == \"\" || arg == \"\")) {\n  \ty2error(\"empty argument: %s, %s, %s\", directive.c_str(), module.c_str(), arg.c_str());\n  \treturn false;\n      }\n      modified |= (m == ModuleEntry::SET);\n      updateIndex(directive,module);\n      modules_conf_map[directive][module].setArgument(arg, m);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "comment.length",
          "args": [],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setOptions",
          "args": [
            "l.module",
            "l.options",
            "m"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "setOptions",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "229-236",
          "snippet": "bool ModulesConf::setOptions(const string module, const ModuleEntry::EntryArg arg, ModuleEntry::Mode m) {\n    modified |= (m == ModuleEntry::SET);\n    if(arg.empty())\n        Y2_RETURN_FALSE(\"setOptions:Empty map\");\n    updateIndex(\"options\",module);\n    modules_conf_map[\"options\"][module].setOptions(arg, m);\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::setOptions(const string module, const ModuleEntry::EntryArg arg, ModuleEntry::Mode m) {\n      modified |= (m == ModuleEntry::SET);\n      if(arg.empty())\n          Y2_RETURN_FALSE(\"setOptions:Empty map\");\n      updateIndex(\"options\",module);\n      modules_conf_map[\"options\"][module].setOptions(arg, m);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"parseFile4: %s\"",
            "l.argument.c_str()"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l.argument.c_str",
          "args": [],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"parseFile3: %s\"",
            "l.module.c_str()"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l.module.c_str",
          "args": [],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"parseFile2: %s\"",
            "l.directive.c_str()"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l.directive.c_str",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"parseFile1: %s\"",
            "line.c_str()"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.c_str",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseLine",
          "args": [
            "line",
            "l"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "parseLine",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "311-366",
          "snippet": "bool ModulesConf::parseLine(const string &line, ModuleLine &l) const {\n    string::size_type length, hash;\n    string buf;\n    length = line.length();\n    hash = line.find_first_of(\"#\");\n\n    if(hash<length)\n\tl.comment = line.substr(hash,length) + \"\\n\";\n\n#define Y2_STRING(dest,source,ret) { \\\n  char *ss; \\\n  do { \\\n    ss = strsep(&source,WHITESPACE); \\\n    if(ss==NULL) { \\\n      if(!ret && line!=\"keep\") \\\n        y2error(\"Parse error: %s (%s)\",dest.c_str(),line.c_str()); \\\n      free (line_str); \\\n      return ret; \\\n    } \\\n  } while((dest=ss)==\"\"); \\\n}\n\n    char *line_str = strdup(line.substr(0,hash).c_str());\n    char *tmp = line_str;\n\n    Y2_STRING(l.directive,tmp,false)\n    Y2_STRING(l.module,tmp,false)\n\n    if(l.directive == \"options\")\n        for(;;) {\n            Y2_STRING(buf,tmp,true)\n            if(buf==\"-o\") {\n                Y2_STRING(buf,tmp,false)\n                l.options[\"-o\"] = buf;\n            }\n            else {\n                string::size_type equal = buf.find_first_of(\"=\");\n                string opt = buf.substr(0,equal);\n                if((signed)equal != -1) {\n                    string par = buf.substr(equal+1,buf.length());\n                    l.options[opt] = par;\n                }\n                else\n                    l.options[opt] = \"\";\n            }\n        }\n    else\n        l.argument = tmp?tmp:\"\";\n\n    l.argument = killspaces(l.argument);\n\n#undef Y2_STRING\n\n    free (line_str);\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::parseLine(const string &line, ModuleLine &l) const {\n      string::size_type length, hash;\n      string buf;\n      length = line.length();\n      hash = line.find_first_of(\"#\");\n  \n      if(hash<length)\n  \tl.comment = line.substr(hash,length) + \"\\n\";\n  \n  #define Y2_STRING(dest,source,ret) { \\\n    char *ss; \\\n    do { \\\n      ss = strsep(&source,WHITESPACE); \\\n      if(ss==NULL) { \\\n        if(!ret && line!=\"keep\") \\\n          y2error(\"Parse error: %s (%s)\",dest.c_str(),line.c_str()); \\\n        free (line_str); \\\n        return ret; \\\n      } \\\n    } while((dest=ss)==\"\"); \\\n  }\n  \n      char *line_str = strdup(line.substr(0,hash).c_str());\n      char *tmp = line_str;\n  \n      Y2_STRING(l.directive,tmp,false)\n      Y2_STRING(l.module,tmp,false)\n  \n      if(l.directive == \"options\")\n          for(;;) {\n              Y2_STRING(buf,tmp,true)\n              if(buf==\"-o\") {\n                  Y2_STRING(buf,tmp,false)\n                  l.options[\"-o\"] = buf;\n              }\n              else {\n                  string::size_type equal = buf.find_first_of(\"=\");\n                  string opt = buf.substr(0,equal);\n                  if((signed)equal != -1) {\n                      string par = buf.substr(equal+1,buf.length());\n                      l.options[opt] = par;\n                  }\n                  else\n                      l.options[opt] = \"\";\n              }\n          }\n      else\n          l.argument = tmp?tmp:\"\";\n  \n      l.argument = killspaces(l.argument);\n  \n  #undef Y2_STRING\n  \n      free (line_str);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"parseFile(): %s\"",
            "line.c_str()"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.c_str",
          "args": [],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temp_line.find",
          "args": [
            "\"endif\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temp_line.empty",
          "args": [],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "temp_line.erase",
          "args": [
            "temp_line.find_last_not_of (WHITESPACE) + 1",
            "temp_line.length ()"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temp_line.find_last_not_of",
          "args": [
            "WHITESPACE"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "is",
            "temp_line"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/stringutil.cc",
          "lines": "60-63",
          "snippet": "std::string getline( std::istream & str, bool trim )\n{\n  return _getline(str, trim?TRIM:NO_TRIM);\n}",
          "includes": [
            "#include <y2util/stringutil.h>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/stringutil.h>\n#include <fstream>\n#include <iostream>\n\nstd::string getline( std::istream & str, bool trim )\n{\n  return _getline(str, trim?TRIM:NO_TRIM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "line.substr",
          "args": [
            "0",
            "2"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.find_first_of",
          "args": [
            "\"#\""
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.erase",
          "args": [
            "0",
            "line.find_first_not_of(WHITESPACE)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.find_first_not_of",
          "args": [
            "WHITESPACE"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temp_line.substr",
          "args": [
            "0",
            "temp_line.length () - 1"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temp_line.substr",
          "args": [
            "temp_line.length () - 1"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temp_line.erase",
          "args": [
            "temp_line.find_last_not_of (WHITESPACE) + 1",
            "temp_line.length ()"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temp_line.find_last_not_of",
          "args": [
            "WHITESPACE"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fname.c_str",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define FINAL_COMMENT \"YaST2_final_modules_conf_comment\"\n\nModulesConf {\n  bool ModulesConf::parseFile(const string &fname, ModuleEntry::Mode m, const bool with_comment) {\n      ifstream is(fname.c_str());\n      string line, temp_line;\n      string comment;\n      bool backslash;\n      bool condition;\n  \n      while (is) {\n  \tbackslash = false;\n  \tline = \"\";\n  \tdo {\n  \t    temp_line = \"\";\n  \t    getline(is,temp_line);\n  \t    temp_line.erase(temp_line.find_last_not_of (WHITESPACE) + 1, temp_line.length ());\n  \n  \t    if (!temp_line.empty ())\n  \t\tif (backslash = (temp_line.substr (temp_line.length () - 1) == \"\\\\\"))\n  \t\t    line += temp_line.substr (0, temp_line.length () - 1);\n  \t} while (backslash && is);\n  \n  \tline += temp_line;\n  \n  \tif(line == \"\") {\n  \t    comment += \"\\n\";\n  \t    continue;\n  \t}\n  \n  \tline.erase(0, line.find_first_not_of(WHITESPACE));\n  \tstring::size_type hash =  line.find_first_of(\"#\");\n  \n          condition = ((line.length () > 1) ? (line.substr (0, 2) == \"if\") : false);\n  \n          /* process \"if-else\" directives as comment */\n          if (condition)\n          {\n              comment += line + \"\\n\";\n              while (condition && is) {\n                  temp_line = \"\";\n                  getline(is, temp_line);\n                  temp_line.erase(temp_line.find_last_not_of (WHITESPACE) + 1, temp_line.length ());\n  \n                  if (!temp_line.empty ())\n                  {\n                      comment += temp_line + \"\\n\";\n                      condition = (temp_line.find (\"endif\"));\n                  }\n  \n              }\n              continue;\n          }\n  \n  \ty2debug(\"parseFile(): %s\", line.c_str());\n          if(hash!=0) {\n              ModuleLine l;\n              parseLine(line,l);\n              y2debug(\"parseFile1: %s\", line.c_str());\n              y2debug(\"parseFile2: %s\", l.directive.c_str());\n              y2debug(\"parseFile3: %s\", l.module.c_str());\n              y2debug(\"parseFile4: %s\", l.argument.c_str());\n              comment += l.comment;\n              if(l.directive == \"options\")\n                  setOptions(l.module, l.options, m);\n              else\n                  setArgument(l.directive, l.module,l.argument, m);\n              if(with_comment)\n                  setComment(l.directive, l.module,comment, m);\n              comment = \"\";\n          }\n          else\n              comment += line + \"\\n\";\n      }\n  \n                                  // keep the final comment\n      if (comment.length () && with_comment)\n      {\n          setArgument(FINAL_COMMENT, \"\", \"\", m);\n          setComment(FINAL_COMMENT, \"\", comment, m);\n      }\n  \n      return updateTimeStamp();\n  }\n}"
  },
  {
    "function_name": "parseLine",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "311-366",
    "snippet": "bool ModulesConf::parseLine(const string &line, ModuleLine &l) const {\n    string::size_type length, hash;\n    string buf;\n    length = line.length();\n    hash = line.find_first_of(\"#\");\n\n    if(hash<length)\n\tl.comment = line.substr(hash,length) + \"\\n\";\n\n#define Y2_STRING(dest,source,ret) { \\\n  char *ss; \\\n  do { \\\n    ss = strsep(&source,WHITESPACE); \\\n    if(ss==NULL) { \\\n      if(!ret && line!=\"keep\") \\\n        y2error(\"Parse error: %s (%s)\",dest.c_str(),line.c_str()); \\\n      free (line_str); \\\n      return ret; \\\n    } \\\n  } while((dest=ss)==\"\"); \\\n}\n\n    char *line_str = strdup(line.substr(0,hash).c_str());\n    char *tmp = line_str;\n\n    Y2_STRING(l.directive,tmp,false)\n    Y2_STRING(l.module,tmp,false)\n\n    if(l.directive == \"options\")\n        for(;;) {\n            Y2_STRING(buf,tmp,true)\n            if(buf==\"-o\") {\n                Y2_STRING(buf,tmp,false)\n                l.options[\"-o\"] = buf;\n            }\n            else {\n                string::size_type equal = buf.find_first_of(\"=\");\n                string opt = buf.substr(0,equal);\n                if((signed)equal != -1) {\n                    string par = buf.substr(equal+1,buf.length());\n                    l.options[opt] = par;\n                }\n                else\n                    l.options[opt] = \"\";\n            }\n        }\n    else\n        l.argument = tmp?tmp:\"\";\n\n    l.argument = killspaces(l.argument);\n\n#undef Y2_STRING\n\n    free (line_str);\n    return true;\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line_str"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "killspaces",
          "args": [
            "l.argument"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "killspaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "295-304",
          "snippet": "string killspaces(const string s) {\n  string tmp = s;\n  signed ind = (signed) tmp.find_first_not_of(\" \");\n  if((signed)ind!=-1)\n    tmp = tmp.substr(ind);\n  ind = (signed) tmp.find_last_not_of(\" \");\n  if(ind < (signed)tmp.size()-1 && tmp.size())\n    tmp = tmp.substr(0,ind+1);\n  return tmp; //tmp.c_str();\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nstring killspaces(const string s) {\n  string tmp = s;\n  signed ind = (signed) tmp.find_first_not_of(\" \");\n  if((signed)ind!=-1)\n    tmp = tmp.substr(ind);\n  ind = (signed) tmp.find_last_not_of(\" \");\n  if(ind < (signed)tmp.size()-1 && tmp.size())\n    tmp = tmp.substr(0,ind+1);\n  return tmp; //tmp.c_str();\n}"
        }
      },
      {
        "call_info": {
          "callee": "buf.substr",
          "args": [
            "equal+1",
            "buf.length()"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf.length",
          "args": [],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buf.substr",
          "args": [
            "0",
            "equal"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf.find_first_of",
          "args": [
            "\"=\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_STRING",
          "args": [
            "buf",
            "tmp",
            "false"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_STRING",
          "args": [
            "buf",
            "tmp",
            "true"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_STRING",
          "args": [
            "l.module",
            "tmp",
            "false"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_STRING",
          "args": [
            "l.directive",
            "tmp",
            "false"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "line.substr(0,hash).c_str()"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.substr",
          "args": [],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.substr",
          "args": [
            "0",
            "hash"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.substr",
          "args": [
            "hash",
            "length"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.find_first_of",
          "args": [
            "\"#\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::parseLine(const string &line, ModuleLine &l) const {\n      string::size_type length, hash;\n      string buf;\n      length = line.length();\n      hash = line.find_first_of(\"#\");\n  \n      if(hash<length)\n  \tl.comment = line.substr(hash,length) + \"\\n\";\n  \n  #define Y2_STRING(dest,source,ret) { \\\n    char *ss; \\\n    do { \\\n      ss = strsep(&source,WHITESPACE); \\\n      if(ss==NULL) { \\\n        if(!ret && line!=\"keep\") \\\n          y2error(\"Parse error: %s (%s)\",dest.c_str(),line.c_str()); \\\n        free (line_str); \\\n        return ret; \\\n      } \\\n    } while((dest=ss)==\"\"); \\\n  }\n  \n      char *line_str = strdup(line.substr(0,hash).c_str());\n      char *tmp = line_str;\n  \n      Y2_STRING(l.directive,tmp,false)\n      Y2_STRING(l.module,tmp,false)\n  \n      if(l.directive == \"options\")\n          for(;;) {\n              Y2_STRING(buf,tmp,true)\n              if(buf==\"-o\") {\n                  Y2_STRING(buf,tmp,false)\n                  l.options[\"-o\"] = buf;\n              }\n              else {\n                  string::size_type equal = buf.find_first_of(\"=\");\n                  string opt = buf.substr(0,equal);\n                  if((signed)equal != -1) {\n                      string par = buf.substr(equal+1,buf.length());\n                      l.options[opt] = par;\n                  }\n                  else\n                      l.options[opt] = \"\";\n              }\n          }\n      else\n          l.argument = tmp?tmp:\"\";\n  \n      l.argument = killspaces(l.argument);\n  \n  #undef Y2_STRING\n  \n      free (line_str);\n      return true;\n  }\n}"
  },
  {
    "function_name": "killspaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "295-304",
    "snippet": "string killspaces(const string s) {\n  string tmp = s;\n  signed ind = (signed) tmp.find_first_not_of(\" \");\n  if((signed)ind!=-1)\n    tmp = tmp.substr(ind);\n  ind = (signed) tmp.find_last_not_of(\" \");\n  if(ind < (signed)tmp.size()-1 && tmp.size())\n    tmp = tmp.substr(0,ind+1);\n  return tmp; //tmp.c_str();\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tmp.substr",
          "args": [
            "0",
            "ind+1"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmp.size",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmp.find_last_not_of",
          "args": [
            "\" \""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmp.substr",
          "args": [
            "ind"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmp.find_first_not_of",
          "args": [
            "\" \""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nstring killspaces(const string s) {\n  string tmp = s;\n  signed ind = (signed) tmp.find_first_not_of(\" \");\n  if((signed)ind!=-1)\n    tmp = tmp.substr(ind);\n  ind = (signed) tmp.find_last_not_of(\" \");\n  if(ind < (signed)tmp.size()-1 && tmp.size())\n    tmp = tmp.substr(0,ind+1);\n  return tmp; //tmp.c_str();\n}"
  },
  {
    "function_name": "getTimeStamp",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "279-286",
    "snippet": "ModulesConf::TimeStamp ModulesConf::getTimeStamp(const string &fname) {\n    struct stat st;\n    if (stat(fname.c_str(), &st)) {\n\ty2error(\"Failed to stat %s: %s\", fname.c_str(), strerror(errno));\n\treturn 0;\n    }\n    return st.st_mtime;\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Failed to stat %s: %s\"",
            "fname.c_str()",
            "strerror(errno)"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fname.c_str",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname.c_str()",
            "&st"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fname.c_str",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  ModulesConf::TimeStamp ModulesConf::getTimeStamp(const string &fname) {\n      struct stat st;\n      if (stat(fname.c_str(), &st)) {\n  \ty2error(\"Failed to stat %s: %s\", fname.c_str(), strerror(errno));\n  \treturn 0;\n      }\n      return st.st_mtime;\n  }\n}"
  },
  {
    "function_name": "updateIfModified",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "270-277",
    "snippet": "bool ModulesConf::updateIfModified() {\n    if (time_stamp != getTimeStamp(file_name)) {\n\ty2warning(\"Config file has been changed by an external program.\");\n\tif(!parseFile(file_name, ModuleEntry::REINIT))\n\t    Y2_RETURN_FALSE(\"updateIfModified: parseFile failed\");\n    }\n    return true;\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Y2_RETURN_FALSE",
          "args": [
            "\"updateIfModified: parseFile failed\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseFile",
          "args": [
            "file_name",
            "ModuleEntry::REINIT"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "parseFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/base/tools/ycpc/ycpc.cc",
          "lines": "397-533",
          "snippet": "std::list <FileDep>\nparseFile (const char *path, const char *expected)\n{\n    if (verbose > 1) printf (\"List dependencies for '%s'\\n\", path);\n\n#define LBUFSIZE 8192\n    char lbuf[LBUFSIZE];\n\n    std::list <FileDep> deplist;\n\n    FILE *f = fopen (path, \"r\");\n    if (f == 0)\n    {\n\tperror (path);\n\treturn deplist;\n    }\n\n    char *lptr;\n    int lcount = 0;\n\n    bool have_module = false;\n\n    while (fgets (lbuf, LBUFSIZE-1, f) != 0)\n    {\n\tlcount++;\n\tlptr = lbuf;\n\twhile (isblank (*lptr)) lptr++;\n\n\tif ((*lptr == 'm')\n\t    && (strncmp (lptr + 1, \"odule\", 5) == 0))\t\t// module\n\t{\n\t    lptr += 6;\n\t    while (isblank (*lptr)) lptr++;\n\t    if (*lptr++ != '\"') continue;\n\t    char *name = lptr;\n\t    while (*lptr)\n\t    {\n\t\tif (*lptr == '\"')\n\t\t    break;\n\t\tlptr++;\n\t    }\n\t    *lptr++ = 0;\n\t    while (isblank (*lptr)) lptr++;\n\t    if (*lptr != ';') continue;\n\n\t    if (!deplist.empty())\n\t    {\n\t\tfprintf (stderr, \"Bad file '%s':\\nmodule statement at wrong postion\\nLine %d:[%s]\", path, lcount, lbuf);\n\t\tfprintf (stderr, \"Have already: %s\\n\", deplist.front().toString().c_str());\n\t\tdeplist.clear();\n\t\treturn deplist;\n\t    }\n\n\t    if (*expected\n\t\t&& strcmp (name, expected) != 0)\n\t    {\n\t\tfprintf (stderr, \"Module file %s does not have expected name '%s' but '%s'\\n\", path, expected, name);\n\t\treturn deplist;\n\t    }\n\t    have_module = true;\n\t    deplist.push_back (FileDep (name, path, true, false, 0, 0));\n\t}\n\telse if (*lptr == 'i')\n\t{\n\t    if (strncmp (lptr + 1, \"mport\", 5) == 0)\t\t// import\n\t    {\n\t\tlptr += 6;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr++ != '\"') continue;\n\t\tchar *name = lptr;\n\t\twhile (*lptr)\n\t\t{\n\t\t    if (*lptr == '\"')\n\t\t\tbreak;\n\t\t    lptr++;\n\t\t}\n\t\t*lptr++ = 0;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr != ';') continue;\n\n\t\tFileDep fd = resolveDep (name, true);\n\t\tif (fd.path().empty())\n\t\t{\n\t\t    fprintf (stderr, \"*** Error: Can't find module %s\\n\", name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    deplist.push_back (fd);\n\t\t}\n\t    }\n\t    else if (strncmp (lptr + 1, \"nclude\", 6) == 0)\t\t// include\n\t    {\n\t\tlptr += 7;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr++ != '\"') continue;\n\t\tchar *name = lptr;\n\t\twhile (*lptr)\n\t\t{\n\t\t    if (*lptr == '\"')\n\t\t    {\n\t\t\tbreak;\n\t\t    }\n\t\t    lptr++;\n\t\t}\n\t\t*lptr++ = 0;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr != ';') continue;\n\n\t\tFileDep fd = resolveDep (name, false);\n\t\tif (fd.path().empty())\n\t\t{\n\t\t    fprintf (stderr, \"*** Error: Can't find include %s\\n\", name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    deplist.push_back (fd);\n\t\t}\n\t    }\n\t} // 'i'include / 'i'mport\n    }\n\n    fclose (f);\n\n    // if no 'module' found -> generate fake include FileDep\n    if (!have_module)\n    {\n\tif (*expected == 0)\n\t{\n\t    fprintf (stderr, \"%s is not a module\\n\", path);\n\t    exit (1);\n\t}\n\tdeplist.push_front (FileDep (expected, path, false, false, 0, 0));\n    }\n\n    if (verbose > 1) printf (\"parseFile (%s) done\\n\", path);\n    return deplist;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <WFM.h>",
            "#include <scr/SCR.h>",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/pathsearch.h>",
            "#include <../../libycp/src/parser.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Import.h>",
            "#include <ycp/Xmlcode.h>",
            "#include <ycp/Bytecode.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YCode.h>",
            "#include <YCP.h>",
            "#include <map>",
            "#include <list>",
            "#include <fstream>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <utime.h>",
            "#include <stdio.h>",
            "#include <getopt.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [
            "#define LBUFSIZE 8192"
          ],
          "globals_used": [
            "static int verbose = 0;",
            "static recurseT *recurseStart (const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <WFM.h>\n#include <scr/SCR.h>\n#include <y2/Y2ComponentBroker.h>\n#include <y2/Y2Component.h>\n#include <ycp/pathsearch.h>\n#include <../../libycp/src/parser.h>\n#include <ycp/y2log.h>\n#include <ycp/Import.h>\n#include <ycp/Xmlcode.h>\n#include <ycp/Bytecode.h>\n#include <ycp/Parser.h>\n#include <ycp/YCode.h>\n#include <YCP.h>\n#include <map>\n#include <list>\n#include <fstream>\n#include <sys/stat.h>\n#include <errno.h>\n#include <utime.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <dirent.h>\n\n#define LBUFSIZE 8192\n\nstatic int verbose = 0;\nstatic recurseT *recurseStart (const char *path);\n\nstd::list <FileDep>\nparseFile (const char *path, const char *expected)\n{\n    if (verbose > 1) printf (\"List dependencies for '%s'\\n\", path);\n\n#define LBUFSIZE 8192\n    char lbuf[LBUFSIZE];\n\n    std::list <FileDep> deplist;\n\n    FILE *f = fopen (path, \"r\");\n    if (f == 0)\n    {\n\tperror (path);\n\treturn deplist;\n    }\n\n    char *lptr;\n    int lcount = 0;\n\n    bool have_module = false;\n\n    while (fgets (lbuf, LBUFSIZE-1, f) != 0)\n    {\n\tlcount++;\n\tlptr = lbuf;\n\twhile (isblank (*lptr)) lptr++;\n\n\tif ((*lptr == 'm')\n\t    && (strncmp (lptr + 1, \"odule\", 5) == 0))\t\t// module\n\t{\n\t    lptr += 6;\n\t    while (isblank (*lptr)) lptr++;\n\t    if (*lptr++ != '\"') continue;\n\t    char *name = lptr;\n\t    while (*lptr)\n\t    {\n\t\tif (*lptr == '\"')\n\t\t    break;\n\t\tlptr++;\n\t    }\n\t    *lptr++ = 0;\n\t    while (isblank (*lptr)) lptr++;\n\t    if (*lptr != ';') continue;\n\n\t    if (!deplist.empty())\n\t    {\n\t\tfprintf (stderr, \"Bad file '%s':\\nmodule statement at wrong postion\\nLine %d:[%s]\", path, lcount, lbuf);\n\t\tfprintf (stderr, \"Have already: %s\\n\", deplist.front().toString().c_str());\n\t\tdeplist.clear();\n\t\treturn deplist;\n\t    }\n\n\t    if (*expected\n\t\t&& strcmp (name, expected) != 0)\n\t    {\n\t\tfprintf (stderr, \"Module file %s does not have expected name '%s' but '%s'\\n\", path, expected, name);\n\t\treturn deplist;\n\t    }\n\t    have_module = true;\n\t    deplist.push_back (FileDep (name, path, true, false, 0, 0));\n\t}\n\telse if (*lptr == 'i')\n\t{\n\t    if (strncmp (lptr + 1, \"mport\", 5) == 0)\t\t// import\n\t    {\n\t\tlptr += 6;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr++ != '\"') continue;\n\t\tchar *name = lptr;\n\t\twhile (*lptr)\n\t\t{\n\t\t    if (*lptr == '\"')\n\t\t\tbreak;\n\t\t    lptr++;\n\t\t}\n\t\t*lptr++ = 0;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr != ';') continue;\n\n\t\tFileDep fd = resolveDep (name, true);\n\t\tif (fd.path().empty())\n\t\t{\n\t\t    fprintf (stderr, \"*** Error: Can't find module %s\\n\", name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    deplist.push_back (fd);\n\t\t}\n\t    }\n\t    else if (strncmp (lptr + 1, \"nclude\", 6) == 0)\t\t// include\n\t    {\n\t\tlptr += 7;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr++ != '\"') continue;\n\t\tchar *name = lptr;\n\t\twhile (*lptr)\n\t\t{\n\t\t    if (*lptr == '\"')\n\t\t    {\n\t\t\tbreak;\n\t\t    }\n\t\t    lptr++;\n\t\t}\n\t\t*lptr++ = 0;\n\t\twhile (isblank (*lptr)) lptr++;\n\t\tif (*lptr != ';') continue;\n\n\t\tFileDep fd = resolveDep (name, false);\n\t\tif (fd.path().empty())\n\t\t{\n\t\t    fprintf (stderr, \"*** Error: Can't find include %s\\n\", name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    deplist.push_back (fd);\n\t\t}\n\t    }\n\t} // 'i'include / 'i'mport\n    }\n\n    fclose (f);\n\n    // if no 'module' found -> generate fake include FileDep\n    if (!have_module)\n    {\n\tif (*expected == 0)\n\t{\n\t    fprintf (stderr, \"%s is not a module\\n\", path);\n\t    exit (1);\n\t}\n\tdeplist.push_front (FileDep (expected, path, false, false, 0, 0));\n    }\n\n    if (verbose > 1) printf (\"parseFile (%s) done\\n\", path);\n    return deplist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"Config file has been changed by an external program.\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getTimeStamp",
          "args": [
            "file_name"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "getTimeStamp",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "279-286",
          "snippet": "ModulesConf::TimeStamp ModulesConf::getTimeStamp(const string &fname) {\n    struct stat st;\n    if (stat(fname.c_str(), &st)) {\n\ty2error(\"Failed to stat %s: %s\", fname.c_str(), strerror(errno));\n\treturn 0;\n    }\n    return st.st_mtime;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  ModulesConf::TimeStamp ModulesConf::getTimeStamp(const string &fname) {\n      struct stat st;\n      if (stat(fname.c_str(), &st)) {\n  \ty2error(\"Failed to stat %s: %s\", fname.c_str(), strerror(errno));\n  \treturn 0;\n      }\n      return st.st_mtime;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::updateIfModified() {\n      if (time_stamp != getTimeStamp(file_name)) {\n  \ty2warning(\"Config file has been changed by an external program.\");\n  \tif(!parseFile(file_name, ModuleEntry::REINIT))\n  \t    Y2_RETURN_FALSE(\"updateIfModified: parseFile failed\");\n      }\n      return true;\n  }\n}"
  },
  {
    "function_name": "updateTimeStamp",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "265-268",
    "snippet": "bool ModulesConf::updateTimeStamp() {\n    time_stamp = getTimeStamp(file_name);\n    return (time_stamp != 0);\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getTimeStamp",
          "args": [
            "file_name"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "getTimeStamp",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "279-286",
          "snippet": "ModulesConf::TimeStamp ModulesConf::getTimeStamp(const string &fname) {\n    struct stat st;\n    if (stat(fname.c_str(), &st)) {\n\ty2error(\"Failed to stat %s: %s\", fname.c_str(), strerror(errno));\n\treturn 0;\n    }\n    return st.st_mtime;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  ModulesConf::TimeStamp ModulesConf::getTimeStamp(const string &fname) {\n      struct stat st;\n      if (stat(fname.c_str(), &st)) {\n  \ty2error(\"Failed to stat %s: %s\", fname.c_str(), strerror(errno));\n  \treturn 0;\n      }\n      return st.st_mtime;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::updateTimeStamp() {\n      time_stamp = getTimeStamp(file_name);\n      return (time_stamp != 0);\n  }\n}"
  },
  {
    "function_name": "updateIndex",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "259-263",
    "snippet": "bool ModulesConf::updateIndex(const string directive, const string module) {\n    if (!isModule (directive, module))\n\tmodules_conf_index.push_back(\".\"+directive+\".\"+module);\n    return true;\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "modules_conf_index.push_back",
          "args": [
            "\".\"+directive+\".\"+module"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isModule",
          "args": [
            "directive",
            "module"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "isModule",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "114-117",
          "snippet": "bool ModulesConf::isModule(const string directive, const string module) {\n    return isDirective (directive) &&\n\tmodules_conf_map[directive].find(module) != modules_conf_map[directive].end();\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::isModule(const string directive, const string module) {\n      return isDirective (directive) &&\n  \tmodules_conf_map[directive].find(module) != modules_conf_map[directive].end();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::updateIndex(const string directive, const string module) {\n      if (!isModule (directive, module))\n  \tmodules_conf_index.push_back(\".\"+directive+\".\"+module);\n      return true;\n  }\n}"
  },
  {
    "function_name": "setComment",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "249-253",
    "snippet": "bool ModulesConf::setComment(const string directive, const string module, const string arg, ModuleEntry::Mode m) {\n    modified |= (m == ModuleEntry::SET);\n    modules_conf_map[directive][module].setComment(arg, m);\n    return true;\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "modules_conf_map[directive][module].setComment",
          "args": [
            "arg",
            "m"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "setComment",
          "container": "ModuleEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.h",
          "lines": "70-70",
          "snippet": "bool setComment(const EntryCom &com, Mode m) { comment = com; return true; }",
          "includes": [
            "#include <map>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <list>\n#include <string>\n\nModuleEntry {\n  bool setComment(const EntryCom &com, Mode m) { comment = com; return true; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::setComment(const string directive, const string module, const string arg, ModuleEntry::Mode m) {\n      modified |= (m == ModuleEntry::SET);\n      modules_conf_map[directive][module].setComment(arg, m);\n      return true;\n  }\n}"
  },
  {
    "function_name": "setArgument",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "238-247",
    "snippet": "bool ModulesConf::setArgument(const string directive, const string module, const string arg, ModuleEntry::Mode m) {\n    if((directive == \"alias\" || directive == \"options\" || directive == \"pre-install\" || directive == \"post-install\" ) && (directive == \"\" || module == \"\" || arg == \"\")) {\n\ty2error(\"empty argument: %s, %s, %s\", directive.c_str(), module.c_str(), arg.c_str());\n\treturn false;\n    }\n    modified |= (m == ModuleEntry::SET);\n    updateIndex(directive,module);\n    modules_conf_map[directive][module].setArgument(arg, m);\n    return true;\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "modules_conf_map[directive][module].setArgument",
          "args": [
            "arg",
            "m"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "setArgument",
          "container": "ModuleEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "54-60",
          "snippet": "bool ModuleEntry::setArgument(const string arg, Mode m) {\n    y2debug(\"MAGIC_arg: %s\", arg.c_str());\n\n    if (!Set (m)) return false;\n    argument[MAGIC_ENTRY] = arg;\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModuleEntry {\n  bool ModuleEntry::setArgument(const string arg, Mode m) {\n      y2debug(\"MAGIC_arg: %s\", arg.c_str());\n  \n      if (!Set (m)) return false;\n      argument[MAGIC_ENTRY] = arg;\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "updateIndex",
          "args": [
            "directive",
            "module"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "updateIndex",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "259-263",
          "snippet": "bool ModulesConf::updateIndex(const string directive, const string module) {\n    if (!isModule (directive, module))\n\tmodules_conf_index.push_back(\".\"+directive+\".\"+module);\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::updateIndex(const string directive, const string module) {\n      if (!isModule (directive, module))\n  \tmodules_conf_index.push_back(\".\"+directive+\".\"+module);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"empty argument: %s, %s, %s\"",
            "directive.c_str()",
            "module.c_str()",
            "arg.c_str()"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.c_str",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "directive.c_str",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::setArgument(const string directive, const string module, const string arg, ModuleEntry::Mode m) {\n      if((directive == \"alias\" || directive == \"options\" || directive == \"pre-install\" || directive == \"post-install\" ) && (directive == \"\" || module == \"\" || arg == \"\")) {\n  \ty2error(\"empty argument: %s, %s, %s\", directive.c_str(), module.c_str(), arg.c_str());\n  \treturn false;\n      }\n      modified |= (m == ModuleEntry::SET);\n      updateIndex(directive,module);\n      modules_conf_map[directive][module].setArgument(arg, m);\n      return true;\n  }\n}"
  },
  {
    "function_name": "setOptions",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "229-236",
    "snippet": "bool ModulesConf::setOptions(const string module, const ModuleEntry::EntryArg arg, ModuleEntry::Mode m) {\n    modified |= (m == ModuleEntry::SET);\n    if(arg.empty())\n        Y2_RETURN_FALSE(\"setOptions:Empty map\");\n    updateIndex(\"options\",module);\n    modules_conf_map[\"options\"][module].setOptions(arg, m);\n    return true;\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "modules_conf_map[\"options\"][module].setOptions",
          "args": [
            "arg",
            "m"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "setOptions",
          "container": "ModuleEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "71-79",
          "snippet": "bool ModuleEntry::setOptions(const EntryArg &arg, Mode m) {\n    y2debug(\"OPTIONS_arg\");\n\n    if(!Set (m)) return false;\n    if(arg.empty())\n        Y2_RETURN_FALSE(\"setOptions:Empty map\");\n    argument = arg;\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModuleEntry {\n  bool ModuleEntry::setOptions(const EntryArg &arg, Mode m) {\n      y2debug(\"OPTIONS_arg\");\n  \n      if(!Set (m)) return false;\n      if(arg.empty())\n          Y2_RETURN_FALSE(\"setOptions:Empty map\");\n      argument = arg;\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "updateIndex",
          "args": [
            "\"options\"",
            "module"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "updateIndex",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "259-263",
          "snippet": "bool ModulesConf::updateIndex(const string directive, const string module) {\n    if (!isModule (directive, module))\n\tmodules_conf_index.push_back(\".\"+directive+\".\"+module);\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::updateIndex(const string directive, const string module) {\n      if (!isModule (directive, module))\n  \tmodules_conf_index.push_back(\".\"+directive+\".\"+module);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_FALSE",
          "args": [
            "\"setOptions:Empty map\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.empty",
          "args": [],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::setOptions(const string module, const ModuleEntry::EntryArg arg, ModuleEntry::Mode m) {\n      modified |= (m == ModuleEntry::SET);\n      if(arg.empty())\n          Y2_RETURN_FALSE(\"setOptions:Empty map\");\n      updateIndex(\"options\",module);\n      modules_conf_map[\"options\"][module].setOptions(arg, m);\n      return true;\n  }\n}"
  },
  {
    "function_name": "setOption",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "218-227",
    "snippet": "bool ModulesConf::setOption(const string module, const string option, const string value, ModuleEntry::Mode m) {\n    if(option == \"\" || module == \"\" || value == \"\") {\n\ty2error(\"empty argument: %s, %s, %s\", module.c_str(), option.c_str(), value.c_str());\n\treturn false;\n    }\n    modified |= (m == ModuleEntry::SET);\n    updateIndex(\"options\",module);\n    modules_conf_map[\"options\"][module].setOption(option, value, m);\n    return true;\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "modules_conf_map[\"options\"][module].setOption",
          "args": [
            "option",
            "value",
            "m"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "setOption",
          "container": "ModuleEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "62-69",
          "snippet": "bool ModuleEntry::setOption(const string option, const string value, Mode m) {\n    y2debug(\"OPTION_arg: %s %s\", option.c_str(), value.c_str());\n\n    if (!Set (m)) return false;\n    argument.erase(MAGIC_ENTRY);\n    argument[option]=value;\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModuleEntry {\n  bool ModuleEntry::setOption(const string option, const string value, Mode m) {\n      y2debug(\"OPTION_arg: %s %s\", option.c_str(), value.c_str());\n  \n      if (!Set (m)) return false;\n      argument.erase(MAGIC_ENTRY);\n      argument[option]=value;\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "updateIndex",
          "args": [
            "\"options\"",
            "module"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "updateIndex",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "259-263",
          "snippet": "bool ModulesConf::updateIndex(const string directive, const string module) {\n    if (!isModule (directive, module))\n\tmodules_conf_index.push_back(\".\"+directive+\".\"+module);\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::updateIndex(const string directive, const string module) {\n      if (!isModule (directive, module))\n  \tmodules_conf_index.push_back(\".\"+directive+\".\"+module);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"empty argument: %s, %s, %s\"",
            "module.c_str()",
            "option.c_str()",
            "value.c_str()"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.c_str",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "option.c_str",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::setOption(const string module, const string option, const string value, ModuleEntry::Mode m) {\n      if(option == \"\" || module == \"\" || value == \"\") {\n  \ty2error(\"empty argument: %s, %s, %s\", module.c_str(), option.c_str(), value.c_str());\n  \treturn false;\n      }\n      modified |= (m == ModuleEntry::SET);\n      updateIndex(\"options\",module);\n      modules_conf_map[\"options\"][module].setOption(option, value, m);\n      return true;\n  }\n}"
  },
  {
    "function_name": "getOptionsAsString",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "200-211",
    "snippet": "string ModulesConf::getOptionsAsString (const string module) {\n    ModuleEntry::EntryArg::const_iterator it;\n    ModuleEntry::EntryArg entry;\n    string ret;\n\n    entry = getOptions(module);\n    it = entry.begin();\n    for (; it != entry.end(); ++it)\n\tret += \" \" + it->first + (it->second != \"\" ? (it->first == \"-o\" ? \" \" : \"=\") + it->second : \"\");\n\n    return ret;\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "entry.end",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry.begin",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getOptions",
          "args": [
            "module"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "getOptionsAsString",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "200-211",
          "snippet": "string ModulesConf::getOptionsAsString (const string module) {\n    ModuleEntry::EntryArg::const_iterator it;\n    ModuleEntry::EntryArg entry;\n    string ret;\n\n    entry = getOptions(module);\n    it = entry.begin();\n    for (; it != entry.end(); ++it)\n\tret += \" \" + it->first + (it->second != \"\" ? (it->first == \"-o\" ? \" \" : \"=\") + it->second : \"\");\n\n    return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  string ModulesConf::getOptionsAsString (const string module) {\n      ModuleEntry::EntryArg::const_iterator it;\n      ModuleEntry::EntryArg entry;\n      string ret;\n  \n      entry = getOptions(module);\n      it = entry.begin();\n      for (; it != entry.end(); ++it)\n  \tret += \" \" + it->first + (it->second != \"\" ? (it->first == \"-o\" ? \" \" : \"=\") + it->second : \"\");\n  \n      return ret;\n  }\n}"
  },
  {
    "function_name": "getOption",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "187-198",
    "snippet": "string ModulesConf::getOption(const string module, const string option) {\n    updateIfModified ();\n    if(!isOption(module,option))\n\tY2_RETURN_STR(\"Bad module or option: %s, %s\", module.c_str(), option.c_str());\n    ModuleEntry::EntryArg ea = modules_conf_map[\"options\"][module].getArgument();\n    if(ea.find(MAGIC_ENTRY)!=ea.end())\n\tY2_RETURN_STR(\"Bad request for option while there is a string (%s, %s).\", module.c_str(), option.c_str());\n    if(ea.find(option)==ea.end())\n\tY2_RETURN_STR(\"Bad request for option %s (%s).\", option.c_str(), module.c_str());\n    y2debug(\"OPTION: %s\", ea[option].c_str());\n    return ea[option];\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"OPTION: %s\"",
            "ea[option].c_str()"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea[option].c_str",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_STR",
          "args": [
            "\"Bad request for option %s (%s).\"",
            "option.c_str()",
            "module.c_str()"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "option.c_str",
          "args": [],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea.end",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea.find",
          "args": [
            "option"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_STR",
          "args": [
            "\"Bad request for option while there is a string (%s, %s).\"",
            "module.c_str()",
            "option.c_str()"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "option.c_str",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea.find",
          "args": [
            "MAGIC_ENTRY"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modules_conf_map[\"options\"][module].getArgument",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "getArgument",
          "container": "ModuleEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.h",
          "lines": "63-63",
          "snippet": "EntryArg getArgument() const { return argument; }",
          "includes": [
            "#include <map>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <list>\n#include <string>\n\nModuleEntry {\n  EntryArg getArgument() const { return argument; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_STR",
          "args": [
            "\"Bad module or option: %s, %s\"",
            "module.c_str()",
            "option.c_str()"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "option.c_str",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isOption",
          "args": [
            "module",
            "option"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "isOption",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "119-122",
          "snippet": "bool ModulesConf::isOption(const string module, const string option) {\n    return isModule (\"options\", module) &&\n\tmodules_conf_map[\"options\"][module].getArgument().find(option) !=  modules_conf_map[\"options\"][module].getArgument().end();\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::isOption(const string module, const string option) {\n      return isModule (\"options\", module) &&\n  \tmodules_conf_map[\"options\"][module].getArgument().find(option) !=  modules_conf_map[\"options\"][module].getArgument().end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "updateIfModified",
          "args": [],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "updateIfModified",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "270-277",
          "snippet": "bool ModulesConf::updateIfModified() {\n    if (time_stamp != getTimeStamp(file_name)) {\n\ty2warning(\"Config file has been changed by an external program.\");\n\tif(!parseFile(file_name, ModuleEntry::REINIT))\n\t    Y2_RETURN_FALSE(\"updateIfModified: parseFile failed\");\n    }\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::updateIfModified() {\n      if (time_stamp != getTimeStamp(file_name)) {\n  \ty2warning(\"Config file has been changed by an external program.\");\n  \tif(!parseFile(file_name, ModuleEntry::REINIT))\n  \t    Y2_RETURN_FALSE(\"updateIfModified: parseFile failed\");\n      }\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  string ModulesConf::getOption(const string module, const string option) {\n      updateIfModified ();\n      if(!isOption(module,option))\n  \tY2_RETURN_STR(\"Bad module or option: %s, %s\", module.c_str(), option.c_str());\n      ModuleEntry::EntryArg ea = modules_conf_map[\"options\"][module].getArgument();\n      if(ea.find(MAGIC_ENTRY)!=ea.end())\n  \tY2_RETURN_STR(\"Bad request for option while there is a string (%s, %s).\", module.c_str(), option.c_str());\n      if(ea.find(option)==ea.end())\n  \tY2_RETURN_STR(\"Bad request for option %s (%s).\", option.c_str(), module.c_str());\n      y2debug(\"OPTION: %s\", ea[option].c_str());\n      return ea[option];\n  }\n}"
  },
  {
    "function_name": "getOptions",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "166-178",
    "snippet": "ModuleEntry::EntryArg ModulesConf::getOptions(const string module) {\n    updateIfModified ();\n    if(!isModule(\"options\",module)) {\n\ty2error(\"Bad options for module: %s\", module.c_str());\n        return ModuleEntry::EntryArg();\n    }\n    ModuleEntry::EntryArg ea = modules_conf_map[\"options\"][module].getArgument();\n    if(ea.find(MAGIC_ENTRY)!=ea.end()) {\n\ty2error(\"Bad request for options while there is only a string (%s).\", module.c_str());\n\treturn ModuleEntry::EntryArg();\n    }\n    return ea;\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ModuleEntry::EntryArg",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad request for options while there is only a string (%s).\"",
            "module.c_str()"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea.end",
          "args": [],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea.find",
          "args": [
            "MAGIC_ENTRY"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modules_conf_map[\"options\"][module].getArgument",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "getArgument",
          "container": "ModuleEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.h",
          "lines": "63-63",
          "snippet": "EntryArg getArgument() const { return argument; }",
          "includes": [
            "#include <map>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <list>\n#include <string>\n\nModuleEntry {\n  EntryArg getArgument() const { return argument; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ModuleEntry::EntryArg",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad options for module: %s\"",
            "module.c_str()"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isModule",
          "args": [
            "\"options\"",
            "module"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "isModule",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "114-117",
          "snippet": "bool ModulesConf::isModule(const string directive, const string module) {\n    return isDirective (directive) &&\n\tmodules_conf_map[directive].find(module) != modules_conf_map[directive].end();\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::isModule(const string directive, const string module) {\n      return isDirective (directive) &&\n  \tmodules_conf_map[directive].find(module) != modules_conf_map[directive].end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "updateIfModified",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "updateIfModified",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "270-277",
          "snippet": "bool ModulesConf::updateIfModified() {\n    if (time_stamp != getTimeStamp(file_name)) {\n\ty2warning(\"Config file has been changed by an external program.\");\n\tif(!parseFile(file_name, ModuleEntry::REINIT))\n\t    Y2_RETURN_FALSE(\"updateIfModified: parseFile failed\");\n    }\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::updateIfModified() {\n      if (time_stamp != getTimeStamp(file_name)) {\n  \ty2warning(\"Config file has been changed by an external program.\");\n  \tif(!parseFile(file_name, ModuleEntry::REINIT))\n  \t    Y2_RETURN_FALSE(\"updateIfModified: parseFile failed\");\n      }\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  ModuleEntry::EntryArg ModulesConf::getOptions(const string module) {\n      updateIfModified ();\n      if(!isModule(\"options\",module)) {\n  \ty2error(\"Bad options for module: %s\", module.c_str());\n          return ModuleEntry::EntryArg();\n      }\n      ModuleEntry::EntryArg ea = modules_conf_map[\"options\"][module].getArgument();\n      if(ea.find(MAGIC_ENTRY)!=ea.end()) {\n  \ty2error(\"Bad request for options while there is only a string (%s).\", module.c_str());\n  \treturn ModuleEntry::EntryArg();\n      }\n      return ea;\n  }\n}"
  },
  {
    "function_name": "getComment",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "158-164",
    "snippet": "string ModulesConf::getComment(const string directive, const string module) {\n    updateIfModified ();\n    if(!isModule(directive,module))\n\tY2_RETURN_STR(\"Bad directive or module: %s, %s\", directive.c_str(), module.c_str());\n\n    return modules_conf_map[directive][module].getComment();\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "modules_conf_map[directive][module].getComment",
          "args": [],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "getComment",
          "container": "ModuleEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "81-86",
          "snippet": "ModuleEntry::EntryCom ModuleEntry::getComment() const {\n\n    return (comment.length () ?\n            (comment.find_last_of (\"\\n\") + 1 == comment.length () ? comment : comment + \"\\n\") :\n            comment);\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModuleEntry {\n  ModuleEntry::EntryCom ModuleEntry::getComment() const {\n  \n      return (comment.length () ?\n              (comment.find_last_of (\"\\n\") + 1 == comment.length () ? comment : comment + \"\\n\") :\n              comment);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_STR",
          "args": [
            "\"Bad directive or module: %s, %s\"",
            "directive.c_str()",
            "module.c_str()"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "directive.c_str",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isModule",
          "args": [
            "directive",
            "module"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "isModule",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "114-117",
          "snippet": "bool ModulesConf::isModule(const string directive, const string module) {\n    return isDirective (directive) &&\n\tmodules_conf_map[directive].find(module) != modules_conf_map[directive].end();\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::isModule(const string directive, const string module) {\n      return isDirective (directive) &&\n  \tmodules_conf_map[directive].find(module) != modules_conf_map[directive].end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "updateIfModified",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "updateIfModified",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "270-277",
          "snippet": "bool ModulesConf::updateIfModified() {\n    if (time_stamp != getTimeStamp(file_name)) {\n\ty2warning(\"Config file has been changed by an external program.\");\n\tif(!parseFile(file_name, ModuleEntry::REINIT))\n\t    Y2_RETURN_FALSE(\"updateIfModified: parseFile failed\");\n    }\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::updateIfModified() {\n      if (time_stamp != getTimeStamp(file_name)) {\n  \ty2warning(\"Config file has been changed by an external program.\");\n  \tif(!parseFile(file_name, ModuleEntry::REINIT))\n  \t    Y2_RETURN_FALSE(\"updateIfModified: parseFile failed\");\n      }\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  string ModulesConf::getComment(const string directive, const string module) {\n      updateIfModified ();\n      if(!isModule(directive,module))\n  \tY2_RETURN_STR(\"Bad directive or module: %s, %s\", directive.c_str(), module.c_str());\n  \n      return modules_conf_map[directive][module].getComment();\n  }\n}"
  },
  {
    "function_name": "getArgument",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "143-156",
    "snippet": "string ModulesConf::getArgument(const string directive, const string module) {\n    updateIfModified ();\n    if(!isModule(directive,module))\n\tY2_RETURN_STR(\"Bad directive or module: %s, %s\", directive.c_str(), module.c_str());\n\n    ModuleEntry::EntryArg ea = modules_conf_map[directive][module].getArgument();\n    y2debug(\"getArgument(%s,%s) %p\",directive.c_str(),module.c_str(), this);\n    if(ea.find(MAGIC_ENTRY)==ea.end()) {\n        y2warning(\"Bad request for string while there are options (%s, %s).\", directive.c_str(), module.c_str());\n        return getOptionsAsString(module);\n    }\n    y2debug(\"MAGIC: %s\", ea[MAGIC_ENTRY].c_str());\n    return ea[MAGIC_ENTRY];\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"MAGIC: %s\"",
            "ea[MAGIC_ENTRY].c_str()"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea[MAGIC_ENTRY].c_str",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getOptionsAsString",
          "args": [
            "module"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "getOptionsAsString",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "200-211",
          "snippet": "string ModulesConf::getOptionsAsString (const string module) {\n    ModuleEntry::EntryArg::const_iterator it;\n    ModuleEntry::EntryArg entry;\n    string ret;\n\n    entry = getOptions(module);\n    it = entry.begin();\n    for (; it != entry.end(); ++it)\n\tret += \" \" + it->first + (it->second != \"\" ? (it->first == \"-o\" ? \" \" : \"=\") + it->second : \"\");\n\n    return ret;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  string ModulesConf::getOptionsAsString (const string module) {\n      ModuleEntry::EntryArg::const_iterator it;\n      ModuleEntry::EntryArg entry;\n      string ret;\n  \n      entry = getOptions(module);\n      it = entry.begin();\n      for (; it != entry.end(); ++it)\n  \tret += \" \" + it->first + (it->second != \"\" ? (it->first == \"-o\" ? \" \" : \"=\") + it->second : \"\");\n  \n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"Bad request for string while there are options (%s, %s).\"",
            "directive.c_str()",
            "module.c_str()"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "directive.c_str",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea.end",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea.find",
          "args": [
            "MAGIC_ENTRY"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"getArgument(%s,%s) %p\"",
            "directive.c_str()",
            "module.c_str()",
            "this"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "directive.c_str",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modules_conf_map[directive][module].getArgument",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "getArgument",
          "container": "ModuleEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.h",
          "lines": "63-63",
          "snippet": "EntryArg getArgument() const { return argument; }",
          "includes": [
            "#include <map>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <list>\n#include <string>\n\nModuleEntry {\n  EntryArg getArgument() const { return argument; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2_RETURN_STR",
          "args": [
            "\"Bad directive or module: %s, %s\"",
            "directive.c_str()",
            "module.c_str()"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module.c_str",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "directive.c_str",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isModule",
          "args": [
            "directive",
            "module"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "isModule",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "114-117",
          "snippet": "bool ModulesConf::isModule(const string directive, const string module) {\n    return isDirective (directive) &&\n\tmodules_conf_map[directive].find(module) != modules_conf_map[directive].end();\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::isModule(const string directive, const string module) {\n      return isDirective (directive) &&\n  \tmodules_conf_map[directive].find(module) != modules_conf_map[directive].end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "updateIfModified",
          "args": [],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "updateIfModified",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "270-277",
          "snippet": "bool ModulesConf::updateIfModified() {\n    if (time_stamp != getTimeStamp(file_name)) {\n\ty2warning(\"Config file has been changed by an external program.\");\n\tif(!parseFile(file_name, ModuleEntry::REINIT))\n\t    Y2_RETURN_FALSE(\"updateIfModified: parseFile failed\");\n    }\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::updateIfModified() {\n      if (time_stamp != getTimeStamp(file_name)) {\n  \ty2warning(\"Config file has been changed by an external program.\");\n  \tif(!parseFile(file_name, ModuleEntry::REINIT))\n  \t    Y2_RETURN_FALSE(\"updateIfModified: parseFile failed\");\n      }\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  string ModulesConf::getArgument(const string directive, const string module) {\n      updateIfModified ();\n      if(!isModule(directive,module))\n  \tY2_RETURN_STR(\"Bad directive or module: %s, %s\", directive.c_str(), module.c_str());\n  \n      ModuleEntry::EntryArg ea = modules_conf_map[directive][module].getArgument();\n      y2debug(\"getArgument(%s,%s) %p\",directive.c_str(),module.c_str(), this);\n      if(ea.find(MAGIC_ENTRY)==ea.end()) {\n          y2warning(\"Bad request for string while there are options (%s, %s).\", directive.c_str(), module.c_str());\n          return getOptionsAsString(module);\n      }\n      y2debug(\"MAGIC: %s\", ea[MAGIC_ENTRY].c_str());\n      return ea[MAGIC_ENTRY];\n  }\n}"
  },
  {
    "function_name": "getModules",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "134-141",
    "snippet": "ModulesConf::ModuleEntryMap ModulesConf::getModules(const string directive) {\n    updateIfModified ();\n    if(!isDirective(directive)) {\n\ty2error(\"Bad directive: %s\", directive.c_str());\n        return ModulesConf::ModuleEntryMap();\n    }\n    return modules_conf_map[directive];\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ModulesConf::ModuleEntryMap",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Bad directive: %s\"",
            "directive.c_str()"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "directive.c_str",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isDirective",
          "args": [
            "directive"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "isDirective",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "110-112",
          "snippet": "bool ModulesConf::isDirective(const string directive) const {\n    return modules_conf_map.find(directive) != modules_conf_map.end();\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::isDirective(const string directive) const {\n      return modules_conf_map.find(directive) != modules_conf_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "updateIfModified",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "updateIfModified",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "270-277",
          "snippet": "bool ModulesConf::updateIfModified() {\n    if (time_stamp != getTimeStamp(file_name)) {\n\ty2warning(\"Config file has been changed by an external program.\");\n\tif(!parseFile(file_name, ModuleEntry::REINIT))\n\t    Y2_RETURN_FALSE(\"updateIfModified: parseFile failed\");\n    }\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::updateIfModified() {\n      if (time_stamp != getTimeStamp(file_name)) {\n  \ty2warning(\"Config file has been changed by an external program.\");\n  \tif(!parseFile(file_name, ModuleEntry::REINIT))\n  \t    Y2_RETURN_FALSE(\"updateIfModified: parseFile failed\");\n      }\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  ModulesConf::ModuleEntryMap ModulesConf::getModules(const string directive) {\n      updateIfModified ();\n      if(!isDirective(directive)) {\n  \ty2error(\"Bad directive: %s\", directive.c_str());\n          return ModulesConf::ModuleEntryMap();\n      }\n      return modules_conf_map[directive];\n  }\n}"
  },
  {
    "function_name": "getDirectives",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "129-132",
    "snippet": "ModulesConf::ModulesConfMap ModulesConf::getDirectives() {\n    updateIfModified ();\n    return modules_conf_map;\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "updateIfModified",
          "args": [],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "updateIfModified",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "270-277",
          "snippet": "bool ModulesConf::updateIfModified() {\n    if (time_stamp != getTimeStamp(file_name)) {\n\ty2warning(\"Config file has been changed by an external program.\");\n\tif(!parseFile(file_name, ModuleEntry::REINIT))\n\t    Y2_RETURN_FALSE(\"updateIfModified: parseFile failed\");\n    }\n    return true;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::updateIfModified() {\n      if (time_stamp != getTimeStamp(file_name)) {\n  \ty2warning(\"Config file has been changed by an external program.\");\n  \tif(!parseFile(file_name, ModuleEntry::REINIT))\n  \t    Y2_RETURN_FALSE(\"updateIfModified: parseFile failed\");\n      }\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  ModulesConf::ModulesConfMap ModulesConf::getDirectives() {\n      updateIfModified ();\n      return modules_conf_map;\n  }\n}"
  },
  {
    "function_name": "isOption",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "119-122",
    "snippet": "bool ModulesConf::isOption(const string module, const string option) {\n    return isModule (\"options\", module) &&\n\tmodules_conf_map[\"options\"][module].getArgument().find(option) !=  modules_conf_map[\"options\"][module].getArgument().end();\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "modules_conf_map[\"options\"][module].getArgument",
          "args": [],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "getArgument",
          "container": "ModuleEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.h",
          "lines": "63-63",
          "snippet": "EntryArg getArgument() const { return argument; }",
          "includes": [
            "#include <map>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <list>\n#include <string>\n\nModuleEntry {\n  EntryArg getArgument() const { return argument; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf_map[\"options\"][module].getArgument",
          "args": [
            "option"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isModule",
          "args": [
            "\"options\"",
            "module"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "isModule",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "114-117",
          "snippet": "bool ModulesConf::isModule(const string directive, const string module) {\n    return isDirective (directive) &&\n\tmodules_conf_map[directive].find(module) != modules_conf_map[directive].end();\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::isModule(const string directive, const string module) {\n      return isDirective (directive) &&\n  \tmodules_conf_map[directive].find(module) != modules_conf_map[directive].end();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::isOption(const string module, const string option) {\n      return isModule (\"options\", module) &&\n  \tmodules_conf_map[\"options\"][module].getArgument().find(option) !=  modules_conf_map[\"options\"][module].getArgument().end();\n  }\n}"
  },
  {
    "function_name": "isModule",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "114-117",
    "snippet": "bool ModulesConf::isModule(const string directive, const string module) {\n    return isDirective (directive) &&\n\tmodules_conf_map[directive].find(module) != modules_conf_map[directive].end();\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "modules_conf_map[directive].end",
          "args": [],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf_map[directive].find",
          "args": [
            "module"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isDirective",
          "args": [
            "directive"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "isDirective",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "110-112",
          "snippet": "bool ModulesConf::isDirective(const string directive) const {\n    return modules_conf_map.find(directive) != modules_conf_map.end();\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::isDirective(const string directive) const {\n      return modules_conf_map.find(directive) != modules_conf_map.end();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::isModule(const string directive, const string module) {\n      return isDirective (directive) &&\n  \tmodules_conf_map[directive].find(module) != modules_conf_map[directive].end();\n  }\n}"
  },
  {
    "function_name": "isDirective",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "110-112",
    "snippet": "bool ModulesConf::isDirective(const string directive) const {\n    return modules_conf_map.find(directive) != modules_conf_map.end();\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "modules_conf_map.end",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules_conf_map.find",
          "args": [
            "directive"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  bool ModulesConf::isDirective(const string directive) const {\n      return modules_conf_map.find(directive) != modules_conf_map.end();\n  }\n}"
  },
  {
    "function_name": "~ModulesConf",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "101-104",
    "snippet": "ModulesConf::~ModulesConf() {\n    if (!writeFile())\n        y2error(\"Can't write configuration file in destructor.\");\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2error",
          "args": [
            "\"Can't write configuration file in destructor.\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeFile",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  ModulesConf::~ModulesConf() {\n      if (!writeFile())\n          y2error(\"Can't write configuration file in destructor.\");\n  }\n}"
  },
  {
    "function_name": "ModulesConf",
    "container": "ModulesConf",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "91-96",
    "snippet": "ModulesConf::ModulesConf(const string &fname)\n    : file_name (fname), modules_conf_map (), modules_conf_index (), modified (false) {\n    y2debug(\"ModulesConf()\");\n    if(!parseFile(fname, ModuleEntry::INIT, true))\n        y2warning(\"ModulesConf: parseFile failed\");\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"ModulesConf: parseFile failed\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseFile",
          "args": [
            "fname",
            "ModuleEntry::INIT",
            "true"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "parseFile",
          "container": "ModulesConf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "371-451",
          "snippet": "bool ModulesConf::parseFile(const string &fname, ModuleEntry::Mode m, const bool with_comment) {\n    ifstream is(fname.c_str());\n    string line, temp_line;\n    string comment;\n    bool backslash;\n    bool condition;\n\n    while (is) {\n\tbackslash = false;\n\tline = \"\";\n\tdo {\n\t    temp_line = \"\";\n\t    getline(is,temp_line);\n\t    temp_line.erase(temp_line.find_last_not_of (WHITESPACE) + 1, temp_line.length ());\n\n\t    if (!temp_line.empty ())\n\t\tif (backslash = (temp_line.substr (temp_line.length () - 1) == \"\\\\\"))\n\t\t    line += temp_line.substr (0, temp_line.length () - 1);\n\t} while (backslash && is);\n\n\tline += temp_line;\n\n\tif(line == \"\") {\n\t    comment += \"\\n\";\n\t    continue;\n\t}\n\n\tline.erase(0, line.find_first_not_of(WHITESPACE));\n\tstring::size_type hash =  line.find_first_of(\"#\");\n\n        condition = ((line.length () > 1) ? (line.substr (0, 2) == \"if\") : false);\n\n        /* process \"if-else\" directives as comment */\n        if (condition)\n        {\n            comment += line + \"\\n\";\n            while (condition && is) {\n                temp_line = \"\";\n                getline(is, temp_line);\n                temp_line.erase(temp_line.find_last_not_of (WHITESPACE) + 1, temp_line.length ());\n\n                if (!temp_line.empty ())\n                {\n                    comment += temp_line + \"\\n\";\n                    condition = (temp_line.find (\"endif\"));\n                }\n\n            }\n            continue;\n        }\n\n\ty2debug(\"parseFile(): %s\", line.c_str());\n        if(hash!=0) {\n            ModuleLine l;\n            parseLine(line,l);\n            y2debug(\"parseFile1: %s\", line.c_str());\n            y2debug(\"parseFile2: %s\", l.directive.c_str());\n            y2debug(\"parseFile3: %s\", l.module.c_str());\n            y2debug(\"parseFile4: %s\", l.argument.c_str());\n            comment += l.comment;\n            if(l.directive == \"options\")\n                setOptions(l.module, l.options, m);\n            else\n                setArgument(l.directive, l.module,l.argument, m);\n            if(with_comment)\n                setComment(l.directive, l.module,comment, m);\n            comment = \"\";\n        }\n        else\n            comment += line + \"\\n\";\n    }\n\n                                // keep the final comment\n    if (comment.length () && with_comment)\n    {\n        setArgument(FINAL_COMMENT, \"\", \"\", m);\n        setComment(FINAL_COMMENT, \"\", comment, m);\n    }\n\n    return updateTimeStamp();\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define FINAL_COMMENT \"YaST2_final_modules_conf_comment\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define FINAL_COMMENT \"YaST2_final_modules_conf_comment\"\n\nModulesConf {\n  bool ModulesConf::parseFile(const string &fname, ModuleEntry::Mode m, const bool with_comment) {\n      ifstream is(fname.c_str());\n      string line, temp_line;\n      string comment;\n      bool backslash;\n      bool condition;\n  \n      while (is) {\n  \tbackslash = false;\n  \tline = \"\";\n  \tdo {\n  \t    temp_line = \"\";\n  \t    getline(is,temp_line);\n  \t    temp_line.erase(temp_line.find_last_not_of (WHITESPACE) + 1, temp_line.length ());\n  \n  \t    if (!temp_line.empty ())\n  \t\tif (backslash = (temp_line.substr (temp_line.length () - 1) == \"\\\\\"))\n  \t\t    line += temp_line.substr (0, temp_line.length () - 1);\n  \t} while (backslash && is);\n  \n  \tline += temp_line;\n  \n  \tif(line == \"\") {\n  \t    comment += \"\\n\";\n  \t    continue;\n  \t}\n  \n  \tline.erase(0, line.find_first_not_of(WHITESPACE));\n  \tstring::size_type hash =  line.find_first_of(\"#\");\n  \n          condition = ((line.length () > 1) ? (line.substr (0, 2) == \"if\") : false);\n  \n          /* process \"if-else\" directives as comment */\n          if (condition)\n          {\n              comment += line + \"\\n\";\n              while (condition && is) {\n                  temp_line = \"\";\n                  getline(is, temp_line);\n                  temp_line.erase(temp_line.find_last_not_of (WHITESPACE) + 1, temp_line.length ());\n  \n                  if (!temp_line.empty ())\n                  {\n                      comment += temp_line + \"\\n\";\n                      condition = (temp_line.find (\"endif\"));\n                  }\n  \n              }\n              continue;\n          }\n  \n  \ty2debug(\"parseFile(): %s\", line.c_str());\n          if(hash!=0) {\n              ModuleLine l;\n              parseLine(line,l);\n              y2debug(\"parseFile1: %s\", line.c_str());\n              y2debug(\"parseFile2: %s\", l.directive.c_str());\n              y2debug(\"parseFile3: %s\", l.module.c_str());\n              y2debug(\"parseFile4: %s\", l.argument.c_str());\n              comment += l.comment;\n              if(l.directive == \"options\")\n                  setOptions(l.module, l.options, m);\n              else\n                  setArgument(l.directive, l.module,l.argument, m);\n              if(with_comment)\n                  setComment(l.directive, l.module,comment, m);\n              comment = \"\";\n          }\n          else\n              comment += line + \"\\n\";\n      }\n  \n                                  // keep the final comment\n      if (comment.length () && with_comment)\n      {\n          setArgument(FINAL_COMMENT, \"\", \"\", m);\n          setComment(FINAL_COMMENT, \"\", comment, m);\n      }\n  \n      return updateTimeStamp();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"ModulesConf()\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModulesConf {\n  ModulesConf::ModulesConf(const string &fname)\n      : file_name (fname), modules_conf_map (), modules_conf_index (), modified (false) {\n      y2debug(\"ModulesConf()\");\n      if(!parseFile(fname, ModuleEntry::INIT, true))\n          y2warning(\"ModulesConf: parseFile failed\");\n  }\n}"
  },
  {
    "function_name": "getComment",
    "container": "ModuleEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "81-86",
    "snippet": "ModuleEntry::EntryCom ModuleEntry::getComment() const {\n\n    return (comment.length () ?\n            (comment.find_last_of (\"\\n\") + 1 == comment.length () ? comment : comment + \"\\n\") :\n            comment);\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "comment.length",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "YCPPathRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPPath.cc",
          "lines": "124-128",
          "snippet": "long\nYCPPathRep::length() const\n{\n    return components.size();\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/y2log.h\"\n\nYCPPathRep {\n  long\n  YCPPathRep::length() const\n  {\n      return components.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "comment.find_last_of",
          "args": [
            "\"\\n\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModuleEntry {\n  ModuleEntry::EntryCom ModuleEntry::getComment() const {\n  \n      return (comment.length () ?\n              (comment.find_last_of (\"\\n\") + 1 == comment.length () ? comment : comment + \"\\n\") :\n              comment);\n  }\n}"
  },
  {
    "function_name": "setOptions",
    "container": "ModuleEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "71-79",
    "snippet": "bool ModuleEntry::setOptions(const EntryArg &arg, Mode m) {\n    y2debug(\"OPTIONS_arg\");\n\n    if(!Set (m)) return false;\n    if(arg.empty())\n        Y2_RETURN_FALSE(\"setOptions:Empty map\");\n    argument = arg;\n    return true;\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Y2_RETURN_FALSE",
          "args": [
            "\"setOptions:Empty map\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.empty",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Set",
          "args": [
            "m"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "Set",
          "container": "ModuleEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "40-52",
          "snippet": "bool ModuleEntry::Set(Mode m) {\n    switch(m) {\n    case INIT:\n        dirtyflag=false;\n        return true;\n    case SET:\n        dirtyflag=true;\n        return true;\n    case REINIT:\n        return !dirtyflag;\n    }\n    return false;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModuleEntry {\n  bool ModuleEntry::Set(Mode m) {\n      switch(m) {\n      case INIT:\n          dirtyflag=false;\n          return true;\n      case SET:\n          dirtyflag=true;\n          return true;\n      case REINIT:\n          return !dirtyflag;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"OPTIONS_arg\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModuleEntry {\n  bool ModuleEntry::setOptions(const EntryArg &arg, Mode m) {\n      y2debug(\"OPTIONS_arg\");\n  \n      if(!Set (m)) return false;\n      if(arg.empty())\n          Y2_RETURN_FALSE(\"setOptions:Empty map\");\n      argument = arg;\n      return true;\n  }\n}"
  },
  {
    "function_name": "setOption",
    "container": "ModuleEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "62-69",
    "snippet": "bool ModuleEntry::setOption(const string option, const string value, Mode m) {\n    y2debug(\"OPTION_arg: %s %s\", option.c_str(), value.c_str());\n\n    if (!Set (m)) return false;\n    argument.erase(MAGIC_ENTRY);\n    argument[option]=value;\n    return true;\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "argument.erase",
          "args": [
            "MAGIC_ENTRY"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "683-695",
          "snippet": "int PathInfo::erase( const Pathname & path )\n{\n  int res = 0;\n  PathInfo p( path, LSTAT );\n  if ( p.isExist() )\n    {\n      if ( p.isDir() )\n        res = PathInfo::recursive_rmdir( path );\n      else\n        res = PathInfo::unlink( path );\n    }\n  return res;\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::erase( const Pathname & path )\n  {\n    int res = 0;\n    PathInfo p( path, LSTAT );\n    if ( p.isExist() )\n      {\n        if ( p.isDir() )\n          res = PathInfo::recursive_rmdir( path );\n        else\n          res = PathInfo::unlink( path );\n      }\n    return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Set",
          "args": [
            "m"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "Set",
          "container": "ModuleEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "40-52",
          "snippet": "bool ModuleEntry::Set(Mode m) {\n    switch(m) {\n    case INIT:\n        dirtyflag=false;\n        return true;\n    case SET:\n        dirtyflag=true;\n        return true;\n    case REINIT:\n        return !dirtyflag;\n    }\n    return false;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModuleEntry {\n  bool ModuleEntry::Set(Mode m) {\n      switch(m) {\n      case INIT:\n          dirtyflag=false;\n          return true;\n      case SET:\n          dirtyflag=true;\n          return true;\n      case REINIT:\n          return !dirtyflag;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"OPTION_arg: %s %s\"",
            "option.c_str()",
            "value.c_str()"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.c_str",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "option.c_str",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModuleEntry {\n  bool ModuleEntry::setOption(const string option, const string value, Mode m) {\n      y2debug(\"OPTION_arg: %s %s\", option.c_str(), value.c_str());\n  \n      if (!Set (m)) return false;\n      argument.erase(MAGIC_ENTRY);\n      argument[option]=value;\n      return true;\n  }\n}"
  },
  {
    "function_name": "setArgument",
    "container": "ModuleEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "54-60",
    "snippet": "bool ModuleEntry::setArgument(const string arg, Mode m) {\n    y2debug(\"MAGIC_arg: %s\", arg.c_str());\n\n    if (!Set (m)) return false;\n    argument[MAGIC_ENTRY] = arg;\n    return true;\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Set",
          "args": [
            "m"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "Set",
          "container": "ModuleEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
          "lines": "40-52",
          "snippet": "bool ModuleEntry::Set(Mode m) {\n    switch(m) {\n    case INIT:\n        dirtyflag=false;\n        return true;\n    case SET:\n        dirtyflag=true;\n        return true;\n    case REINIT:\n        return !dirtyflag;\n    }\n    return false;\n}",
          "includes": [
            "#include \"Y2Logger.h\"",
            "#include \"ModulesConf.h\"",
            "#include <Y2.h>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <stdio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModuleEntry {\n  bool ModuleEntry::Set(Mode m) {\n      switch(m) {\n      case INIT:\n          dirtyflag=false;\n          return true;\n      case SET:\n          dirtyflag=true;\n          return true;\n      case REINIT:\n          return !dirtyflag;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"MAGIC_arg: %s\"",
            "arg.c_str()"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.c_str",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModuleEntry {\n  bool ModuleEntry::setArgument(const string arg, Mode m) {\n      y2debug(\"MAGIC_arg: %s\", arg.c_str());\n  \n      if (!Set (m)) return false;\n      argument[MAGIC_ENTRY] = arg;\n      return true;\n  }\n}"
  },
  {
    "function_name": "Set",
    "container": "ModuleEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "40-52",
    "snippet": "bool ModuleEntry::Set(Mode m) {\n    switch(m) {\n    case INIT:\n        dirtyflag=false;\n        return true;\n    case SET:\n        dirtyflag=true;\n        return true;\n    case REINIT:\n        return !dirtyflag;\n    }\n    return false;\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModuleEntry {\n  bool ModuleEntry::Set(Mode m) {\n      switch(m) {\n      case INIT:\n          dirtyflag=false;\n          return true;\n      case SET:\n          dirtyflag=true;\n          return true;\n      case REINIT:\n          return !dirtyflag;\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "~ModuleEntry",
    "container": "ModuleEntry",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-modules/src/ModulesConf.cc",
    "lines": "34-35",
    "snippet": "ModuleEntry::~ModuleEntry () {\n}",
    "includes": [
      "#include \"Y2Logger.h\"",
      "#include \"ModulesConf.h\"",
      "#include <Y2.h>",
      "#include <fstream>",
      "#include <iostream>",
      "#include <stdio.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"Y2Logger.h\"\n#include \"ModulesConf.h\"\n#include <Y2.h>\n#include <fstream>\n#include <iostream>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"config.h\"\n\nModuleEntry {\n  ModuleEntry::~ModuleEntry () {\n  }\n}"
  }
]