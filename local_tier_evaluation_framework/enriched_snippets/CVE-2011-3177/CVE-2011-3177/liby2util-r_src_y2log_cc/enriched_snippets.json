[
  {
    "function_name": "for_each",
    "container": "LogTail",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "653-656",
    "snippet": "void LogTail::for_each (LogTail::Consumer c)\n{\n    m_impl->for_each (c);\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_impl->for_each",
          "args": [
            "c"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "for_each",
          "container": "LogTail",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "653-656",
          "snippet": "void LogTail::for_each (LogTail::Consumer c)\n{\n    m_impl->for_each (c);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nLogTail {\n  void LogTail::for_each (LogTail::Consumer c)\n  {\n      m_impl->for_each (c);\n  }\n}"
  },
  {
    "function_name": "push_back",
    "container": "LogTail",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "649-652",
    "snippet": "void LogTail::push_back (const Data &d)\n{\n    m_impl->push_back (d);\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_impl->push_back",
          "args": [
            "d"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "LogTail",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "649-652",
          "snippet": "void LogTail::push_back (const Data &d)\n{\n    m_impl->push_back (d);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nLogTail {\n  void LogTail::push_back (const Data &d)\n  {\n      m_impl->push_back (d);\n  }\n}"
  },
  {
    "function_name": "~LogTail",
    "container": "LogTail",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "644-647",
    "snippet": "LogTail::~LogTail ()\n{\n    delete m_impl;\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nLogTail {\n  LogTail::~LogTail ()\n  {\n      delete m_impl;\n  }\n}"
  },
  {
    "function_name": "LogTail",
    "container": "LogTail",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "639-642",
    "snippet": "LogTail::LogTail (size_t max_size)\n{\n    m_impl = new Impl (max_size);\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nLogTail {\n  LogTail::LogTail (size_t max_size)\n  {\n      m_impl = new Impl (max_size);\n  }\n}"
  },
  {
    "function_name": "for_each",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "631-636",
    "snippet": "void for_each (Consumer c) {\n\tstd::list<Data>::iterator i;\n\tfor (i = m_items.begin (); i != m_items.end (); ++i)\n\t    if (! c(*i))\n\t\tbreak;\n    }",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c",
          "args": [
            "*i"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "for_each",
          "container": "LogTail",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "653-656",
          "snippet": "void LogTail::for_each (LogTail::Consumer c)\n{\n    m_impl->for_each (c);\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nLogTail {\n  void LogTail::for_each (LogTail::Consumer c)\n  {\n      m_impl->for_each (c);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_items.end",
          "args": [],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_items.begin",
          "args": [],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid for_each (Consumer c) {\n\tstd::list<Data>::iterator i;\n\tfor (i = m_items.begin (); i != m_items.end (); ++i)\n\t    if (! c(*i))\n\t\tbreak;\n    }"
  },
  {
    "function_name": "push_back",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "622-629",
    "snippet": "void push_back (const Data &d) {\n\tif (m_size >= m_max_size)\n\t    m_items.pop_front ();\n\telse\n\t    ++m_size;\n\n\tm_items.push_back (d);\n    }",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_items.push_back",
          "args": [
            "d"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "LogTail",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "649-652",
          "snippet": "void LogTail::push_back (const Data &d)\n{\n    m_impl->push_back (d);\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nLogTail {\n  void LogTail::push_back (const Data &d)\n  {\n      m_impl->push_back (d);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_items.pop_front",
          "args": [],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid push_back (const Data &d) {\n\tif (m_size >= m_max_size)\n\t    m_items.pop_front ();\n\telse\n\t    ++m_size;\n\n\tm_items.push_back (d);\n    }"
  },
  {
    "function_name": "Impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "617-620",
    "snippet": "Impl(size_t max_size = 42)\n    : m_size (0)\n    , m_max_size (max_size)\n\t{}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nImpl(size_t max_size = 42)\n    : m_size (0)\n    , m_max_size (max_size)\n\t{}"
  },
  {
    "function_name": "should_be_buffered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "606-609",
    "snippet": "bool should_be_buffered ()\n{\n    return getenv (Y2LOG_VAR_ONCRASH) != NULL;\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [
      "#define Y2LOG_VAR_ONCRASH \"Y2DEBUGONCRASH\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "Y2LOG_VAR_ONCRASH"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_VAR_ONCRASH \"Y2DEBUGONCRASH\"\n\nbool should_be_buffered ()\n{\n    return getenv (Y2LOG_VAR_ONCRASH) != NULL;\n}"
  },
  {
    "function_name": "get_log_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "598-601",
    "snippet": "bool get_log_debug()\n{\n\treturn log_debug;\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static sig_atomic_t log_debug = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic sig_atomic_t log_debug = false;\n\nbool get_log_debug()\n{\n\treturn log_debug;\n}"
  },
  {
    "function_name": "set_log_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "593-596",
    "snippet": "void set_log_debug(bool on)\n{\n\tlog_debug = on;\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static sig_atomic_t log_debug = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic sig_atomic_t log_debug = false;\n\nvoid set_log_debug(bool on)\n{\n\tlog_debug = on;\n}"
  },
  {
    "function_name": "set_log_simple_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "589-591",
    "snippet": "void set_log_simple_mode(bool simple) {\n    log_simple = simple;\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool log_simple = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic bool log_simple = false;\n\nvoid set_log_simple_mode(bool simple) {\n    log_simple = simple;\n}"
  },
  {
    "function_name": "should_be_logged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "560-583",
    "snippet": "bool should_be_logged (int loglevel, string componentname) {\n\n    if(log_simple && !log_debug) return loglevel > 1;\n\n    /* Only debug level is controllable */\n    if(loglevel > 0) return true;\n\n    /* Prepare the logfile name. */\n    if(!did_set_logname)\n\tset_log_filename(\"\");\n\n    /* Read log configuration. */\n    if(!did_read_logconf)\n\tset_log_conf(\"\");\n\n    /* Everything should be logged */\n    if(log_all_variable) return true;\n\n    /* Specific component */\n    if(logconf.find(componentname) != logconf.end())\n\treturn logconf[componentname] == \"true\";\n\n    return log_debug;\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "inisection logconf;",
      "static bool did_set_logname = false;",
      "static sig_atomic_t did_read_logconf = 0;",
      "static sig_atomic_t log_debug = false;",
      "static bool log_all_variable = false;",
      "static bool log_simple = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logconf.end",
          "args": [],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "logconf.find",
          "args": [
            "componentname"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_log_conf",
          "args": [
            "\"\""
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "set_log_conf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "516-554",
          "snippet": "void set_log_conf(string confname) {\n\n    did_read_logconf = true;\n\n    set_signal_handler (SIGUSR2);\n    set_signal_handler (SIGUSR1);\n\n    string logconfname = confname;\n    if(logconfname == \"\") {\n\t/* Read the logconf.ycp */\n\tstruct passwd *pw = getpwuid(geteuid());\n\tif(!pw) {\n\t    fprintf (stderr, \"Cannot read pwd entry for user \"\n\t\t    \"id %d. No logconf, using defaults.\\n\", geteuid ());\n\t    return;\n\t}\n\tif(getuid())\n\t    logconfname = string (pw->pw_dir) + \"/.yast2/\" + Y2LOG_CONF;\n\telse\n\t    logconfname = \"/etc/YaST2/\" Y2LOG_CONF;\n    }\n\n    if(getenv(Y2LOG_VAR_ALL)) log_all_variable = true;\n\n    /* We have to remember the errno. Otherwise a call of\n     * y2error (\"error: %m\") can display a wrong message. */\n    int save_errno = errno;\n    inifile i = miniini(logconfname.c_str());\n    logconf = i[\"Debug\"];\n\n    log_to_file = i[\"Log\"][\"file\"] != \"false\";\n    log_to_syslog = i[\"Log\"][\"syslog\"] == \"true\";\n    log_debug = (i[\"Log\"][\"debug\"] == \"true\") || getenv(Y2LOG_VAR_DEBUG);\n\n    if(i[\"Log\"][\"filename\"] != \"\")\n\tlogname = strdup(i[\"Log\"][\"filename\"].c_str());\n\n    errno = save_errno;\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2LOG_VAR_ALL\t\"Y2DEBUGALL\"",
            "#define Y2LOG_VAR_DEBUG\t\"Y2DEBUG\"",
            "#define Y2LOG_CONF\t\"log.conf\"\t/* Relative to $HOME or /etc/YaST2 */"
          ],
          "globals_used": [
            "inisection logconf;",
            "static sig_atomic_t did_read_logconf = 0;",
            "static const char *logname;",
            "static sig_atomic_t log_debug = false;",
            "static bool log_to_file = true;",
            "static bool log_to_syslog = false;",
            "static bool log_all_variable = false;",
            "static void shift_log_files(string filename);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_VAR_ALL\t\"Y2DEBUGALL\"\n#define Y2LOG_VAR_DEBUG\t\"Y2DEBUG\"\n#define Y2LOG_CONF\t\"log.conf\"\t/* Relative to $HOME or /etc/YaST2 */\n\ninisection logconf;\nstatic sig_atomic_t did_read_logconf = 0;\nstatic const char *logname;\nstatic sig_atomic_t log_debug = false;\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic bool log_all_variable = false;\nstatic void shift_log_files(string filename);\n\nvoid set_log_conf(string confname) {\n\n    did_read_logconf = true;\n\n    set_signal_handler (SIGUSR2);\n    set_signal_handler (SIGUSR1);\n\n    string logconfname = confname;\n    if(logconfname == \"\") {\n\t/* Read the logconf.ycp */\n\tstruct passwd *pw = getpwuid(geteuid());\n\tif(!pw) {\n\t    fprintf (stderr, \"Cannot read pwd entry for user \"\n\t\t    \"id %d. No logconf, using defaults.\\n\", geteuid ());\n\t    return;\n\t}\n\tif(getuid())\n\t    logconfname = string (pw->pw_dir) + \"/.yast2/\" + Y2LOG_CONF;\n\telse\n\t    logconfname = \"/etc/YaST2/\" Y2LOG_CONF;\n    }\n\n    if(getenv(Y2LOG_VAR_ALL)) log_all_variable = true;\n\n    /* We have to remember the errno. Otherwise a call of\n     * y2error (\"error: %m\") can display a wrong message. */\n    int save_errno = errno;\n    inifile i = miniini(logconfname.c_str());\n    logconf = i[\"Debug\"];\n\n    log_to_file = i[\"Log\"][\"file\"] != \"false\";\n    log_to_syslog = i[\"Log\"][\"syslog\"] == \"true\";\n    log_debug = (i[\"Log\"][\"debug\"] == \"true\") || getenv(Y2LOG_VAR_DEBUG);\n\n    if(i[\"Log\"][\"filename\"] != \"\")\n\tlogname = strdup(i[\"Log\"][\"filename\"].c_str());\n\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_log_filename",
          "args": [
            "\"\""
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "set_log_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "375-429",
          "snippet": "void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(!did_read_logconf) set_log_conf(\"\");\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2LOG_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2LOG_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2LOG_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2LOG_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2LOG_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2LOG_FALLBACK );\n\n\t\tlogname = Y2LOG_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2LOG_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2LOG_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2LOG_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2LOG_VAR_NUM\t\"Y2MAXLOGNUM\"",
            "#define Y2LOG_VAR_SIZE\t\"Y2MAXLOGSIZE\"",
            "#define Y2LOG_FALLBACK\t\"/y2log\"",
            "#define Y2LOG_USER\t\"/.y2log\"\t\t/* Relative to $HOME */",
            "#define Y2LOG_ROOT\tLOGDIR \"/y2log\"",
            "#define Y2LOG_MAXNUM\t10\t\t\t/* Maximum logfiles number */",
            "#define Y2LOG_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */"
          ],
          "globals_used": [
            "static bool did_set_logname = false;",
            "static sig_atomic_t did_read_logconf = 0;",
            "static const char *logname;",
            "static off_t maxlogsize;",
            "static int   maxlognum;",
            "static bool log_to_file = true;",
            "static bool log_to_syslog = false;",
            "static FILE *Y2LOG_STDERR = stderr;",
            "static void shift_log_files(string filename);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_VAR_NUM\t\"Y2MAXLOGNUM\"\n#define Y2LOG_VAR_SIZE\t\"Y2MAXLOGSIZE\"\n#define Y2LOG_FALLBACK\t\"/y2log\"\n#define Y2LOG_USER\t\"/.y2log\"\t\t/* Relative to $HOME */\n#define Y2LOG_ROOT\tLOGDIR \"/y2log\"\n#define Y2LOG_MAXNUM\t10\t\t\t/* Maximum logfiles number */\n#define Y2LOG_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */\n\nstatic bool did_set_logname = false;\nstatic sig_atomic_t did_read_logconf = 0;\nstatic const char *logname;\nstatic off_t maxlogsize;\nstatic int   maxlognum;\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic FILE *Y2LOG_STDERR = stderr;\nstatic void shift_log_files(string filename);\n\nvoid set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(!did_read_logconf) set_log_conf(\"\");\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2LOG_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2LOG_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2LOG_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2LOG_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2LOG_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2LOG_FALLBACK );\n\n\t\tlogname = Y2LOG_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2LOG_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2LOG_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2LOG_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\ninisection logconf;\nstatic bool did_set_logname = false;\nstatic sig_atomic_t did_read_logconf = 0;\nstatic sig_atomic_t log_debug = false;\nstatic bool log_all_variable = false;\nstatic bool log_simple = false;\n\nbool should_be_logged (int loglevel, string componentname) {\n\n    if(log_simple && !log_debug) return loglevel > 1;\n\n    /* Only debug level is controllable */\n    if(loglevel > 0) return true;\n\n    /* Prepare the logfile name. */\n    if(!did_set_logname)\n\tset_log_filename(\"\");\n\n    /* Read log configuration. */\n    if(!did_read_logconf)\n\tset_log_conf(\"\");\n\n    /* Everything should be logged */\n    if(log_all_variable) return true;\n\n    /* Specific component */\n    if(logconf.find(componentname) != logconf.end())\n\treturn logconf[componentname] == \"true\";\n\n    return log_debug;\n}"
  },
  {
    "function_name": "set_log_conf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "516-554",
    "snippet": "void set_log_conf(string confname) {\n\n    did_read_logconf = true;\n\n    set_signal_handler (SIGUSR2);\n    set_signal_handler (SIGUSR1);\n\n    string logconfname = confname;\n    if(logconfname == \"\") {\n\t/* Read the logconf.ycp */\n\tstruct passwd *pw = getpwuid(geteuid());\n\tif(!pw) {\n\t    fprintf (stderr, \"Cannot read pwd entry for user \"\n\t\t    \"id %d. No logconf, using defaults.\\n\", geteuid ());\n\t    return;\n\t}\n\tif(getuid())\n\t    logconfname = string (pw->pw_dir) + \"/.yast2/\" + Y2LOG_CONF;\n\telse\n\t    logconfname = \"/etc/YaST2/\" Y2LOG_CONF;\n    }\n\n    if(getenv(Y2LOG_VAR_ALL)) log_all_variable = true;\n\n    /* We have to remember the errno. Otherwise a call of\n     * y2error (\"error: %m\") can display a wrong message. */\n    int save_errno = errno;\n    inifile i = miniini(logconfname.c_str());\n    logconf = i[\"Debug\"];\n\n    log_to_file = i[\"Log\"][\"file\"] != \"false\";\n    log_to_syslog = i[\"Log\"][\"syslog\"] == \"true\";\n    log_debug = (i[\"Log\"][\"debug\"] == \"true\") || getenv(Y2LOG_VAR_DEBUG);\n\n    if(i[\"Log\"][\"filename\"] != \"\")\n\tlogname = strdup(i[\"Log\"][\"filename\"].c_str());\n\n    errno = save_errno;\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [
      "#define Y2LOG_VAR_ALL\t\"Y2DEBUGALL\"",
      "#define Y2LOG_VAR_DEBUG\t\"Y2DEBUG\"",
      "#define Y2LOG_CONF\t\"log.conf\"\t/* Relative to $HOME or /etc/YaST2 */"
    ],
    "globals_used": [
      "inisection logconf;",
      "static sig_atomic_t did_read_logconf = 0;",
      "static const char *logname;",
      "static sig_atomic_t log_debug = false;",
      "static bool log_to_file = true;",
      "static bool log_to_syslog = false;",
      "static bool log_all_variable = false;",
      "static void shift_log_files(string filename);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "i[\"Log\"][\"filename\"].c_str()"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i[\"Log\"][\"filename\"].c_str",
          "args": [],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "Y2LOG_VAR_DEBUG"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "miniini",
          "args": [
            "logconfname.c_str()"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "miniini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/miniini.cc",
          "lines": "22-59",
          "snippet": "inifile miniini(const char *file) {\n\n    inifile ret;\n\n    FILE *in = fopen(file, \"r\");\n    if(in == NULL) return ret;\n\n    char line[MAXLINE], *c;\n    char section[MAXLINE], *key;\n\n    while(fgets(line, MAXLINE, in) != NULL) {\n\tc = cutblanks(line);\n\tswitch(*c) {\n\t    /* comments */\n\t    case 0:\n\t    case '#':\n\t    case ';':\n\t    case '/':\n\t\tcontinue;\n\t    /* sections */\n\t    case '[':\n\t\t*c++;\n\t\tc[strlen(c) - 1] = 0;\n\t\tstrncpy(section, cutblanks(c), MAXLINE);\n\t\tbreak;\n\t    /* keys and values */\n\t    default:\n\t\tkey = strchr(c, '=');\n\t\tif(!key) break;\n\t\t*key++ = 0;\n\t\tret[section][cutblanks(c)] = cutblanks(key);\n\t\tbreak;\n\t}\n    }\n\n    fclose(in);\n    return ret;\n}",
          "includes": [
            "#include <string.h>",
            "#include \"y2util/miniini.h\""
          ],
          "macros_used": [
            "#define MAXLINE 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"y2util/miniini.h\"\n\n#define MAXLINE 1024\n\ninifile miniini(const char *file) {\n\n    inifile ret;\n\n    FILE *in = fopen(file, \"r\");\n    if(in == NULL) return ret;\n\n    char line[MAXLINE], *c;\n    char section[MAXLINE], *key;\n\n    while(fgets(line, MAXLINE, in) != NULL) {\n\tc = cutblanks(line);\n\tswitch(*c) {\n\t    /* comments */\n\t    case 0:\n\t    case '#':\n\t    case ';':\n\t    case '/':\n\t\tcontinue;\n\t    /* sections */\n\t    case '[':\n\t\t*c++;\n\t\tc[strlen(c) - 1] = 0;\n\t\tstrncpy(section, cutblanks(c), MAXLINE);\n\t\tbreak;\n\t    /* keys and values */\n\t    default:\n\t\tkey = strchr(c, '=');\n\t\tif(!key) break;\n\t\t*key++ = 0;\n\t\tret[section][cutblanks(c)] = cutblanks(key);\n\t\tbreak;\n\t}\n    }\n\n    fclose(in);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logconfname.c_str",
          "args": [],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "Y2LOG_VAR_ALL"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "pw->pw_dir"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Cannot read pwd entry for user \"\n\t\t    \"id %d. No logconf, using defaults.\\n\"",
            "geteuid ()"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "geteuid()"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_signal_handler",
          "args": [
            "SIGUSR1"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "set_signal_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "498-511",
          "snippet": "static void set_signal_handler (int signum)\n{\n    struct sigaction a;\n    a.sa_handler = signal_handler;\n    a.sa_flags = 0;\n    sigemptyset (&a.sa_mask);\n\n    int ret = sigaction (signum, &a, NULL);\n    if (ret != 0)\n    {\n\tfprintf (stderr, \"Could not set handler of signal #%d for y2log: %d\\n\",\n\t\t signum, ret);\n    }\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void set_signal_handler (int signum)\n{\n    struct sigaction a;\n    a.sa_handler = signal_handler;\n    a.sa_flags = 0;\n    sigemptyset (&a.sa_mask);\n\n    int ret = sigaction (signum, &a, NULL);\n    if (ret != 0)\n    {\n\tfprintf (stderr, \"Could not set handler of signal #%d for y2log: %d\\n\",\n\t\t signum, ret);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_VAR_ALL\t\"Y2DEBUGALL\"\n#define Y2LOG_VAR_DEBUG\t\"Y2DEBUG\"\n#define Y2LOG_CONF\t\"log.conf\"\t/* Relative to $HOME or /etc/YaST2 */\n\ninisection logconf;\nstatic sig_atomic_t did_read_logconf = 0;\nstatic const char *logname;\nstatic sig_atomic_t log_debug = false;\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic bool log_all_variable = false;\nstatic void shift_log_files(string filename);\n\nvoid set_log_conf(string confname) {\n\n    did_read_logconf = true;\n\n    set_signal_handler (SIGUSR2);\n    set_signal_handler (SIGUSR1);\n\n    string logconfname = confname;\n    if(logconfname == \"\") {\n\t/* Read the logconf.ycp */\n\tstruct passwd *pw = getpwuid(geteuid());\n\tif(!pw) {\n\t    fprintf (stderr, \"Cannot read pwd entry for user \"\n\t\t    \"id %d. No logconf, using defaults.\\n\", geteuid ());\n\t    return;\n\t}\n\tif(getuid())\n\t    logconfname = string (pw->pw_dir) + \"/.yast2/\" + Y2LOG_CONF;\n\telse\n\t    logconfname = \"/etc/YaST2/\" Y2LOG_CONF;\n    }\n\n    if(getenv(Y2LOG_VAR_ALL)) log_all_variable = true;\n\n    /* We have to remember the errno. Otherwise a call of\n     * y2error (\"error: %m\") can display a wrong message. */\n    int save_errno = errno;\n    inifile i = miniini(logconfname.c_str());\n    logconf = i[\"Debug\"];\n\n    log_to_file = i[\"Log\"][\"file\"] != \"false\";\n    log_to_syslog = i[\"Log\"][\"syslog\"] == \"true\";\n    log_debug = (i[\"Log\"][\"debug\"] == \"true\") || getenv(Y2LOG_VAR_DEBUG);\n\n    if(i[\"Log\"][\"filename\"] != \"\")\n\tlogname = strdup(i[\"Log\"][\"filename\"].c_str());\n\n    errno = save_errno;\n}"
  },
  {
    "function_name": "set_signal_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "498-511",
    "snippet": "static void set_signal_handler (int signum)\n{\n    struct sigaction a;\n    a.sa_handler = signal_handler;\n    a.sa_flags = 0;\n    sigemptyset (&a.sa_mask);\n\n    int ret = sigaction (signum, &a, NULL);\n    if (ret != 0)\n    {\n\tfprintf (stderr, \"Could not set handler of signal #%d for y2log: %d\\n\",\n\t\t signum, ret);\n    }\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not set handler of signal #%d for y2log: %d\\n\"",
            "signum",
            "ret"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "signum",
            "&a",
            "NULL"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&a.sa_mask"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void set_signal_handler (int signum)\n{\n    struct sigaction a;\n    a.sa_handler = signal_handler;\n    a.sa_flags = 0;\n    sigemptyset (&a.sa_mask);\n\n    int ret = sigaction (signum, &a, NULL);\n    if (ret != 0)\n    {\n\tfprintf (stderr, \"Could not set handler of signal #%d for y2log: %d\\n\",\n\t\t signum, ret);\n    }\n}"
  },
  {
    "function_name": "signal_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "486-496",
    "snippet": "static void signal_handler (int signum)\n{\n    if (signum == SIGUSR2)\n    {\n\tdid_read_logconf = false;\n    }\n    else if (signum == SIGUSR1)\n    {\n\tlog_debug = !log_debug;\n    }\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static sig_atomic_t did_read_logconf = 0;",
      "static sig_atomic_t log_debug = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic sig_atomic_t did_read_logconf = 0;\nstatic sig_atomic_t log_debug = false;\n\nstatic void signal_handler (int signum)\n{\n    if (signum == SIGUSR2)\n    {\n\tdid_read_logconf = false;\n    }\n    else if (signum == SIGUSR1)\n    {\n\tlog_debug = !log_debug;\n    }\n}"
  },
  {
    "function_name": "shift_log_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "452-479",
    "snippet": "static void shift_log_files(string filename)\n{\n    struct stat buf;\n\n    if( stat(filename.c_str(), &buf) )\n\treturn;\n\n    if( buf.st_size <= maxlogsize )\n\treturn;\n\n    static const char * gz = \".gz\";\n    // Delete the last logfile\n    remove (old (filename, maxlognum - 1, \"\"   ).c_str());\n    remove (old (filename, maxlognum - 1, gz).c_str());\n\n    // rename existing ones\n    for( int f = maxlognum-2; f > 0; f-- )\n    {\n\trename (old (filename, f, \"\").c_str(), old (filename, f+1, \"\").c_str());\n\trename (old (filename, f, gz).c_str(), old (filename, f+1, gz).c_str());\n    }\n\n    // rename and compress first one\n    rename( filename.c_str(), old (filename, 1, \"\").c_str() );\n    // fate#300637: compress!\n    // may fail, but so what\n    system( (\"nice -n 20 gzip \" + old (filename, 1, \"\") + \" &\").c_str());\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static off_t maxlogsize;",
      "static int   maxlognum;",
      "static void shift_log_files(string filename);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "system",
          "args": [
            "(\"nice -n 20 gzip \" + old (filename, 1, \"\") + \" &\").c_str()"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old",
          "args": [
            "filename",
            "1",
            "\"\""
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "old",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "441-445",
          "snippet": "static string old (const string & filename, int i, const char * suffix) {\n    char numbuf[8];\n    sprintf (numbuf, \"%d\", i);\n    return filename + \"-\" + numbuf + suffix;\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shift_log_files(string filename);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void shift_log_files(string filename);\n\nstatic string old (const string & filename, int i, const char * suffix) {\n    char numbuf[8];\n    sprintf (numbuf, \"%d\", i);\n    return filename + \"-\" + numbuf + suffix;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "filename.c_str()",
            "old (filename, 1, \"\").c_str()"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "rename",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "558-565",
          "snippet": "int PathInfo::rename( const Pathname & oldpath, const Pathname & newpath )\n{\n  DBG << \"rename \" << oldpath << \" -> \" << newpath;\n  if ( ::rename( oldpath.asString().c_str(), newpath.asString().c_str() ) == -1 ) {\n    return _Log_Result( errno );\n  }\n  return _Log_Result( 0 );\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::rename( const Pathname & oldpath, const Pathname & newpath )\n  {\n    DBG << \"rename \" << oldpath << \" -> \" << newpath;\n    if ( ::rename( oldpath.asString().c_str(), newpath.asString().c_str() ) == -1 ) {\n      return _Log_Result( errno );\n    }\n    return _Log_Result( 0 );\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "old",
          "args": [],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old",
          "args": [],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old",
          "args": [],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove",
          "args": [
            "old (filename, maxlognum - 1, gz).c_str()"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "remove",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "104-113",
          "snippet": "void YCPMapRep::remove(const YCPValue& key)\n{\n    if (!key->isString() && !key->isInteger() && !key->isSymbol())\n    {\n        ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n        return;\n    }\n\n    stl_map.erase (key);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  void YCPMapRep::remove(const YCPValue& key)\n  {\n      if (!key->isString() && !key->isInteger() && !key->isSymbol())\n      {\n          ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n          return;\n      }\n  \n      stl_map.erase (key);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "old",
          "args": [],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "filename.c_str()",
            "&buf"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic off_t maxlogsize;\nstatic int   maxlognum;\nstatic void shift_log_files(string filename);\n\nstatic void shift_log_files(string filename)\n{\n    struct stat buf;\n\n    if( stat(filename.c_str(), &buf) )\n\treturn;\n\n    if( buf.st_size <= maxlogsize )\n\treturn;\n\n    static const char * gz = \".gz\";\n    // Delete the last logfile\n    remove (old (filename, maxlognum - 1, \"\"   ).c_str());\n    remove (old (filename, maxlognum - 1, gz).c_str());\n\n    // rename existing ones\n    for( int f = maxlognum-2; f > 0; f-- )\n    {\n\trename (old (filename, f, \"\").c_str(), old (filename, f+1, \"\").c_str());\n\trename (old (filename, f, gz).c_str(), old (filename, f+1, gz).c_str());\n    }\n\n    // rename and compress first one\n    rename( filename.c_str(), old (filename, 1, \"\").c_str() );\n    // fate#300637: compress!\n    // may fail, but so what\n    system( (\"nice -n 20 gzip \" + old (filename, 1, \"\") + \" &\").c_str());\n}"
  },
  {
    "function_name": "old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "441-445",
    "snippet": "static string old (const string & filename, int i, const char * suffix) {\n    char numbuf[8];\n    sprintf (numbuf, \"%d\", i);\n    return filename + \"-\" + numbuf + suffix;\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shift_log_files(string filename);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "numbuf",
            "\"%d\"",
            "i"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void shift_log_files(string filename);\n\nstatic string old (const string & filename, int i, const char * suffix) {\n    char numbuf[8];\n    sprintf (numbuf, \"%d\", i);\n    return filename + \"-\" + numbuf + suffix;\n}"
  },
  {
    "function_name": "get_log_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "435-439",
    "snippet": "string get_log_filename()\n{\n    if(!did_set_logname) set_log_filename(\"\");\n    return string (logname);\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool did_set_logname = false;",
      "static const char *logname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "string",
          "args": [
            "logname"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_log_filename",
          "args": [
            "\"\""
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "set_log_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "375-429",
          "snippet": "void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(!did_read_logconf) set_log_conf(\"\");\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2LOG_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2LOG_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2LOG_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2LOG_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2LOG_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2LOG_FALLBACK );\n\n\t\tlogname = Y2LOG_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2LOG_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2LOG_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2LOG_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2LOG_VAR_NUM\t\"Y2MAXLOGNUM\"",
            "#define Y2LOG_VAR_SIZE\t\"Y2MAXLOGSIZE\"",
            "#define Y2LOG_FALLBACK\t\"/y2log\"",
            "#define Y2LOG_USER\t\"/.y2log\"\t\t/* Relative to $HOME */",
            "#define Y2LOG_ROOT\tLOGDIR \"/y2log\"",
            "#define Y2LOG_MAXNUM\t10\t\t\t/* Maximum logfiles number */",
            "#define Y2LOG_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */"
          ],
          "globals_used": [
            "static bool did_set_logname = false;",
            "static sig_atomic_t did_read_logconf = 0;",
            "static const char *logname;",
            "static off_t maxlogsize;",
            "static int   maxlognum;",
            "static bool log_to_file = true;",
            "static bool log_to_syslog = false;",
            "static FILE *Y2LOG_STDERR = stderr;",
            "static void shift_log_files(string filename);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_VAR_NUM\t\"Y2MAXLOGNUM\"\n#define Y2LOG_VAR_SIZE\t\"Y2MAXLOGSIZE\"\n#define Y2LOG_FALLBACK\t\"/y2log\"\n#define Y2LOG_USER\t\"/.y2log\"\t\t/* Relative to $HOME */\n#define Y2LOG_ROOT\tLOGDIR \"/y2log\"\n#define Y2LOG_MAXNUM\t10\t\t\t/* Maximum logfiles number */\n#define Y2LOG_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */\n\nstatic bool did_set_logname = false;\nstatic sig_atomic_t did_read_logconf = 0;\nstatic const char *logname;\nstatic off_t maxlogsize;\nstatic int   maxlognum;\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic FILE *Y2LOG_STDERR = stderr;\nstatic void shift_log_files(string filename);\n\nvoid set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(!did_read_logconf) set_log_conf(\"\");\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2LOG_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2LOG_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2LOG_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2LOG_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2LOG_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2LOG_FALLBACK );\n\n\t\tlogname = Y2LOG_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2LOG_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2LOG_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2LOG_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic bool did_set_logname = false;\nstatic const char *logname;\n\nstring get_log_filename()\n{\n    if(!did_set_logname) set_log_filename(\"\");\n    return string (logname);\n}"
  },
  {
    "function_name": "set_log_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "375-429",
    "snippet": "void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(!did_read_logconf) set_log_conf(\"\");\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2LOG_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2LOG_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2LOG_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2LOG_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2LOG_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2LOG_FALLBACK );\n\n\t\tlogname = Y2LOG_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2LOG_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2LOG_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2LOG_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [
      "#define Y2LOG_VAR_NUM\t\"Y2MAXLOGNUM\"",
      "#define Y2LOG_VAR_SIZE\t\"Y2MAXLOGSIZE\"",
      "#define Y2LOG_FALLBACK\t\"/y2log\"",
      "#define Y2LOG_USER\t\"/.y2log\"\t\t/* Relative to $HOME */",
      "#define Y2LOG_ROOT\tLOGDIR \"/y2log\"",
      "#define Y2LOG_MAXNUM\t10\t\t\t/* Maximum logfiles number */",
      "#define Y2LOG_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */"
    ],
    "globals_used": [
      "static bool did_set_logname = false;",
      "static sig_atomic_t did_read_logconf = 0;",
      "static const char *logname;",
      "static off_t maxlogsize;",
      "static int   maxlognum;",
      "static bool log_to_file = true;",
      "static bool log_to_syslog = false;",
      "static FILE *Y2LOG_STDERR = stderr;",
      "static void shift_log_files(string filename);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "filename"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "my_logname",
            "Y2LOG_USER"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "my_logname",
            "pw->pw_dir"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen (pw->pw_dir) + strlen (Y2LOG_USER) + 1"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "Y2LOG_USER"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pw->pw_dir"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "Y2LOG_STDERR",
            "\"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\"",
            "geteuid()",
            "Y2LOG_FALLBACK"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "env_maxlognum"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "Y2LOG_VAR_NUM"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::numeric_limits<off_t>::max",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringutil::strtonum",
          "args": [
            "env_maxlogsize",
            "maxlogsize"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "strtonum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/stringutil.h",
          "lines": "182-182",
          "snippet": "inline _It strtonum( const std::string & str, _It & i ) { return i = strtonum<_It>( str ); }",
          "includes": [
            "#include <list>",
            "#include <string>",
            "#include <vector>",
            "#include <iosfwd>",
            "#include <cstdlib>",
            "#include <cstdarg>",
            "#include <cstdio>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <string>\n#include <vector>\n#include <iosfwd>\n#include <cstdlib>\n#include <cstdarg>\n#include <cstdio>\n\ninline _It strtonum( const std::string & str, _It & i ) { return i = strtonum<_It>( str ); }"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "Y2LOG_VAR_SIZE"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fname.c_str",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "geteuid()"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openlog",
          "args": [
            "\"yast2\"",
            "LOG_PID",
            "LOG_DAEMON"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_log_conf",
          "args": [
            "\"\""
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "set_log_conf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "516-554",
          "snippet": "void set_log_conf(string confname) {\n\n    did_read_logconf = true;\n\n    set_signal_handler (SIGUSR2);\n    set_signal_handler (SIGUSR1);\n\n    string logconfname = confname;\n    if(logconfname == \"\") {\n\t/* Read the logconf.ycp */\n\tstruct passwd *pw = getpwuid(geteuid());\n\tif(!pw) {\n\t    fprintf (stderr, \"Cannot read pwd entry for user \"\n\t\t    \"id %d. No logconf, using defaults.\\n\", geteuid ());\n\t    return;\n\t}\n\tif(getuid())\n\t    logconfname = string (pw->pw_dir) + \"/.yast2/\" + Y2LOG_CONF;\n\telse\n\t    logconfname = \"/etc/YaST2/\" Y2LOG_CONF;\n    }\n\n    if(getenv(Y2LOG_VAR_ALL)) log_all_variable = true;\n\n    /* We have to remember the errno. Otherwise a call of\n     * y2error (\"error: %m\") can display a wrong message. */\n    int save_errno = errno;\n    inifile i = miniini(logconfname.c_str());\n    logconf = i[\"Debug\"];\n\n    log_to_file = i[\"Log\"][\"file\"] != \"false\";\n    log_to_syslog = i[\"Log\"][\"syslog\"] == \"true\";\n    log_debug = (i[\"Log\"][\"debug\"] == \"true\") || getenv(Y2LOG_VAR_DEBUG);\n\n    if(i[\"Log\"][\"filename\"] != \"\")\n\tlogname = strdup(i[\"Log\"][\"filename\"].c_str());\n\n    errno = save_errno;\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2LOG_VAR_ALL\t\"Y2DEBUGALL\"",
            "#define Y2LOG_VAR_DEBUG\t\"Y2DEBUG\"",
            "#define Y2LOG_CONF\t\"log.conf\"\t/* Relative to $HOME or /etc/YaST2 */"
          ],
          "globals_used": [
            "inisection logconf;",
            "static sig_atomic_t did_read_logconf = 0;",
            "static const char *logname;",
            "static sig_atomic_t log_debug = false;",
            "static bool log_to_file = true;",
            "static bool log_to_syslog = false;",
            "static bool log_all_variable = false;",
            "static void shift_log_files(string filename);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_VAR_ALL\t\"Y2DEBUGALL\"\n#define Y2LOG_VAR_DEBUG\t\"Y2DEBUG\"\n#define Y2LOG_CONF\t\"log.conf\"\t/* Relative to $HOME or /etc/YaST2 */\n\ninisection logconf;\nstatic sig_atomic_t did_read_logconf = 0;\nstatic const char *logname;\nstatic sig_atomic_t log_debug = false;\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic bool log_all_variable = false;\nstatic void shift_log_files(string filename);\n\nvoid set_log_conf(string confname) {\n\n    did_read_logconf = true;\n\n    set_signal_handler (SIGUSR2);\n    set_signal_handler (SIGUSR1);\n\n    string logconfname = confname;\n    if(logconfname == \"\") {\n\t/* Read the logconf.ycp */\n\tstruct passwd *pw = getpwuid(geteuid());\n\tif(!pw) {\n\t    fprintf (stderr, \"Cannot read pwd entry for user \"\n\t\t    \"id %d. No logconf, using defaults.\\n\", geteuid ());\n\t    return;\n\t}\n\tif(getuid())\n\t    logconfname = string (pw->pw_dir) + \"/.yast2/\" + Y2LOG_CONF;\n\telse\n\t    logconfname = \"/etc/YaST2/\" Y2LOG_CONF;\n    }\n\n    if(getenv(Y2LOG_VAR_ALL)) log_all_variable = true;\n\n    /* We have to remember the errno. Otherwise a call of\n     * y2error (\"error: %m\") can display a wrong message. */\n    int save_errno = errno;\n    inifile i = miniini(logconfname.c_str());\n    logconf = i[\"Debug\"];\n\n    log_to_file = i[\"Log\"][\"file\"] != \"false\";\n    log_to_syslog = i[\"Log\"][\"syslog\"] == \"true\";\n    log_debug = (i[\"Log\"][\"debug\"] == \"true\") || getenv(Y2LOG_VAR_DEBUG);\n\n    if(i[\"Log\"][\"filename\"] != \"\")\n\tlogname = strdup(i[\"Log\"][\"filename\"].c_str());\n\n    errno = save_errno;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_VAR_NUM\t\"Y2MAXLOGNUM\"\n#define Y2LOG_VAR_SIZE\t\"Y2MAXLOGSIZE\"\n#define Y2LOG_FALLBACK\t\"/y2log\"\n#define Y2LOG_USER\t\"/.y2log\"\t\t/* Relative to $HOME */\n#define Y2LOG_ROOT\tLOGDIR \"/y2log\"\n#define Y2LOG_MAXNUM\t10\t\t\t/* Maximum logfiles number */\n#define Y2LOG_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */\n\nstatic bool did_set_logname = false;\nstatic sig_atomic_t did_read_logconf = 0;\nstatic const char *logname;\nstatic off_t maxlogsize;\nstatic int   maxlognum;\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic FILE *Y2LOG_STDERR = stderr;\nstatic void shift_log_files(string filename);\n\nvoid set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(!did_read_logconf) set_log_conf(\"\");\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2LOG_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2LOG_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2LOG_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2LOG_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2LOG_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2LOG_FALLBACK );\n\n\t\tlogname = Y2LOG_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2LOG_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2LOG_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2LOG_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}"
  },
  {
    "function_name": "do_log_yast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "350-370",
    "snippet": "static\nvoid do_log_yast( const char* logmessage )\n{\n    /* Prepare the logfile name */\n    if(!did_set_logname) set_log_filename(\"\");\n\n    /* Prepare the logfile */\n    shift_log_files (string (logname));\n\n    FILE *logfile = open_logfile ();\n    if (!logfile)\n\treturn;\n\n    fprintf (logfile, \"%s\", logmessage);\n\n    /* Clean everything */\n    if (logfile && logfile != Y2LOG_STDERR)\n\tfclose (logfile);\n    else\n\tfflush (logfile);\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool did_set_logname = false;",
      "static const char *logname;",
      "static FILE *Y2LOG_STDERR = stderr;",
      "static void do_log_syslog( const char* logmessage );",
      "static void do_log_yast( const char* logmessage );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "logfile"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "logfile"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "logfile",
            "\"%s\"",
            "logmessage"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_logfile",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shift_log_files",
          "args": [
            "string (logname)"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "shift_log_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "452-479",
          "snippet": "static void shift_log_files(string filename)\n{\n    struct stat buf;\n\n    if( stat(filename.c_str(), &buf) )\n\treturn;\n\n    if( buf.st_size <= maxlogsize )\n\treturn;\n\n    static const char * gz = \".gz\";\n    // Delete the last logfile\n    remove (old (filename, maxlognum - 1, \"\"   ).c_str());\n    remove (old (filename, maxlognum - 1, gz).c_str());\n\n    // rename existing ones\n    for( int f = maxlognum-2; f > 0; f-- )\n    {\n\trename (old (filename, f, \"\").c_str(), old (filename, f+1, \"\").c_str());\n\trename (old (filename, f, gz).c_str(), old (filename, f+1, gz).c_str());\n    }\n\n    // rename and compress first one\n    rename( filename.c_str(), old (filename, 1, \"\").c_str() );\n    // fate#300637: compress!\n    // may fail, but so what\n    system( (\"nice -n 20 gzip \" + old (filename, 1, \"\") + \" &\").c_str());\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static off_t maxlogsize;",
            "static int   maxlognum;",
            "static void shift_log_files(string filename);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic off_t maxlogsize;\nstatic int   maxlognum;\nstatic void shift_log_files(string filename);\n\nstatic void shift_log_files(string filename)\n{\n    struct stat buf;\n\n    if( stat(filename.c_str(), &buf) )\n\treturn;\n\n    if( buf.st_size <= maxlogsize )\n\treturn;\n\n    static const char * gz = \".gz\";\n    // Delete the last logfile\n    remove (old (filename, maxlognum - 1, \"\"   ).c_str());\n    remove (old (filename, maxlognum - 1, gz).c_str());\n\n    // rename existing ones\n    for( int f = maxlognum-2; f > 0; f-- )\n    {\n\trename (old (filename, f, \"\").c_str(), old (filename, f+1, \"\").c_str());\n\trename (old (filename, f, gz).c_str(), old (filename, f+1, gz).c_str());\n    }\n\n    // rename and compress first one\n    rename( filename.c_str(), old (filename, 1, \"\").c_str() );\n    // fate#300637: compress!\n    // may fail, but so what\n    system( (\"nice -n 20 gzip \" + old (filename, 1, \"\") + \" &\").c_str());\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "logname"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_log_filename",
          "args": [
            "\"\""
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "set_log_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "375-429",
          "snippet": "void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(!did_read_logconf) set_log_conf(\"\");\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2LOG_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2LOG_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2LOG_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2LOG_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2LOG_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2LOG_FALLBACK );\n\n\t\tlogname = Y2LOG_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2LOG_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2LOG_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2LOG_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2LOG_VAR_NUM\t\"Y2MAXLOGNUM\"",
            "#define Y2LOG_VAR_SIZE\t\"Y2MAXLOGSIZE\"",
            "#define Y2LOG_FALLBACK\t\"/y2log\"",
            "#define Y2LOG_USER\t\"/.y2log\"\t\t/* Relative to $HOME */",
            "#define Y2LOG_ROOT\tLOGDIR \"/y2log\"",
            "#define Y2LOG_MAXNUM\t10\t\t\t/* Maximum logfiles number */",
            "#define Y2LOG_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */"
          ],
          "globals_used": [
            "static bool did_set_logname = false;",
            "static sig_atomic_t did_read_logconf = 0;",
            "static const char *logname;",
            "static off_t maxlogsize;",
            "static int   maxlognum;",
            "static bool log_to_file = true;",
            "static bool log_to_syslog = false;",
            "static FILE *Y2LOG_STDERR = stderr;",
            "static void shift_log_files(string filename);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_VAR_NUM\t\"Y2MAXLOGNUM\"\n#define Y2LOG_VAR_SIZE\t\"Y2MAXLOGSIZE\"\n#define Y2LOG_FALLBACK\t\"/y2log\"\n#define Y2LOG_USER\t\"/.y2log\"\t\t/* Relative to $HOME */\n#define Y2LOG_ROOT\tLOGDIR \"/y2log\"\n#define Y2LOG_MAXNUM\t10\t\t\t/* Maximum logfiles number */\n#define Y2LOG_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */\n\nstatic bool did_set_logname = false;\nstatic sig_atomic_t did_read_logconf = 0;\nstatic const char *logname;\nstatic off_t maxlogsize;\nstatic int   maxlognum;\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic FILE *Y2LOG_STDERR = stderr;\nstatic void shift_log_files(string filename);\n\nvoid set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(!did_read_logconf) set_log_conf(\"\");\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2LOG_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2LOG_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2LOG_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2LOG_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2LOG_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2LOG_FALLBACK );\n\n\t\tlogname = Y2LOG_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2LOG_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2LOG_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2LOG_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic bool did_set_logname = false;\nstatic const char *logname;\nstatic FILE *Y2LOG_STDERR = stderr;\nstatic void do_log_syslog( const char* logmessage );\nstatic void do_log_yast( const char* logmessage );\n\nstatic\nvoid do_log_yast( const char* logmessage )\n{\n    /* Prepare the logfile name */\n    if(!did_set_logname) set_log_filename(\"\");\n\n    /* Prepare the logfile */\n    shift_log_files (string (logname));\n\n    FILE *logfile = open_logfile ();\n    if (!logfile)\n\treturn;\n\n    fprintf (logfile, \"%s\", logmessage);\n\n    /* Clean everything */\n    if (logfile && logfile != Y2LOG_STDERR)\n\tfclose (logfile);\n    else\n\tfflush (logfile);\n}"
  },
  {
    "function_name": "do_log_syslog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "344-348",
    "snippet": "static\nvoid do_log_syslog( const char* logmessage )\n{\n    syslog (LOG_NOTICE, \"%s\", logmessage);\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void do_log_syslog( const char* logmessage );",
      "static void do_log_yast( const char* logmessage );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_NOTICE",
            "\"%s\"",
            "logmessage"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void do_log_syslog( const char* logmessage );\nstatic void do_log_yast( const char* logmessage );\n\nstatic\nvoid do_log_syslog( const char* logmessage )\n{\n    syslog (LOG_NOTICE, \"%s\", logmessage);\n}"
  },
  {
    "function_name": "y2_logger_raw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "333-342",
    "snippet": "void y2_logger_raw( const char* logmessage )\n{\n    if(log_to_syslog) {\n\tdo_log_syslog (logmessage);\n    }\n\n    if(log_to_file) {\n\tdo_log_yast (logmessage);\n    }\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool log_to_file = true;",
      "static bool log_to_syslog = false;",
      "static void do_log_syslog( const char* logmessage );",
      "static void do_log_yast( const char* logmessage );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_log_yast",
          "args": [
            "logmessage"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "do_log_yast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "350-370",
          "snippet": "static\nvoid do_log_yast( const char* logmessage )\n{\n    /* Prepare the logfile name */\n    if(!did_set_logname) set_log_filename(\"\");\n\n    /* Prepare the logfile */\n    shift_log_files (string (logname));\n\n    FILE *logfile = open_logfile ();\n    if (!logfile)\n\treturn;\n\n    fprintf (logfile, \"%s\", logmessage);\n\n    /* Clean everything */\n    if (logfile && logfile != Y2LOG_STDERR)\n\tfclose (logfile);\n    else\n\tfflush (logfile);\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool did_set_logname = false;",
            "static const char *logname;",
            "static FILE *Y2LOG_STDERR = stderr;",
            "static void do_log_syslog( const char* logmessage );",
            "static void do_log_yast( const char* logmessage );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic bool did_set_logname = false;\nstatic const char *logname;\nstatic FILE *Y2LOG_STDERR = stderr;\nstatic void do_log_syslog( const char* logmessage );\nstatic void do_log_yast( const char* logmessage );\n\nstatic\nvoid do_log_yast( const char* logmessage )\n{\n    /* Prepare the logfile name */\n    if(!did_set_logname) set_log_filename(\"\");\n\n    /* Prepare the logfile */\n    shift_log_files (string (logname));\n\n    FILE *logfile = open_logfile ();\n    if (!logfile)\n\treturn;\n\n    fprintf (logfile, \"%s\", logmessage);\n\n    /* Clean everything */\n    if (logfile && logfile != Y2LOG_STDERR)\n\tfclose (logfile);\n    else\n\tfflush (logfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_log_syslog",
          "args": [
            "logmessage"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "do_log_syslog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "344-348",
          "snippet": "static\nvoid do_log_syslog( const char* logmessage )\n{\n    syslog (LOG_NOTICE, \"%s\", logmessage);\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void do_log_syslog( const char* logmessage );",
            "static void do_log_yast( const char* logmessage );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void do_log_syslog( const char* logmessage );\nstatic void do_log_yast( const char* logmessage );\n\nstatic\nvoid do_log_syslog( const char* logmessage )\n{\n    syslog (LOG_NOTICE, \"%s\", logmessage);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic void do_log_syslog( const char* logmessage );\nstatic void do_log_yast( const char* logmessage );\n\nvoid y2_logger_raw( const char* logmessage )\n{\n    if(log_to_syslog) {\n\tdo_log_syslog (logmessage);\n    }\n\n    if(log_to_file) {\n\tdo_log_yast (logmessage);\n    }\n}"
  },
  {
    "function_name": "y2_vlogger_blanik",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "311-331",
    "snippet": "void y2_vlogger_blanik(loglevel_t level, const char *component, const char *file,\n\t   const int line, const char *function, const char *format, va_list ap)\n{\n    string common = y2_logfmt_common (log_simple,\n\t\t\t\t      component, file, line, function,\n\t\t\t\t      format, ap);\n\n    if(log_to_syslog || log_to_file) {\n\tstring tolog;\n\tif (log_simple || (log_to_syslog > log_to_file))\n\t    tolog = common;\n\telse\n\t    tolog = y2_logfmt_prefix (level) + common;\n\t// store the message for worse times\n\t// (lock the variable that is shared among threads, bnc#565918)\n\tstatic pthread_mutex_t blanik_mutex = PTHREAD_MUTEX_INITIALIZER;\n\tpthread_mutex_lock (&blanik_mutex);\n\tblanik.push_back (tolog);\n\tpthread_mutex_unlock (&blanik_mutex);\n    }\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool log_to_file = true;",
      "static bool log_to_syslog = false;",
      "static bool log_simple = false;",
      "LogTail blanik = LogTail ();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&blanik_mutex"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blanik.push_back",
          "args": [
            "tolog"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "LogTail",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "649-652",
          "snippet": "void LogTail::push_back (const Data &d)\n{\n    m_impl->push_back (d);\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nLogTail {\n  void LogTail::push_back (const Data &d)\n  {\n      m_impl->push_back (d);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&blanik_mutex"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2_logfmt_prefix",
          "args": [
            "level"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "y2_logfmt_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "240-287",
          "snippet": "string y2_logfmt_prefix (loglevel_t level)\n{\n    /* Prepare the PID */\n    pid_t pid = getpid();\n\n    /* Prepare the host name */\n    char hostname[1024];\n    if (gethostname(hostname, 1024))\n\tstrncpy(hostname, \"unknown\", 1024);\n\n    /* Prepare the date */\n#if 1\n    // just 1 second precision\n    time_t timestamp = time (NULL);\n    struct tm brokentime;\n    localtime_r (&timestamp, &brokentime);\n    char date[50];\t\t// that's big enough\n    strftime (date, sizeof (date), Y2LOG_DATE, &brokentime);\n#else\n    // 1 millisecond precision (use only for testing)\n    timeval time;\n    gettimeofday (&time, NULL);\n    time_t timestamp = time.tv_sec;\n    struct tm brokentime;\n    localtime_r (&timestamp, &brokentime);\n    char tmp1[50], date[50];\t// that's big enough\n    strftime (tmp1, sizeof (tmp1), Y2LOG_DATE, &brokentime);\n    snprintf (date, sizeof (date), \"%s.%03ld\", tmp1, time.tv_usec / 1000);\n#endif\n\n#if 0\n    // print \"bytes from system\" and \"bytes in use\" per thread (use only\n    // for testing)\n    struct mallinfo mi;\n    mi = mallinfo ();\n    char tmp2[50];\n    snprintf (tmp2, sizeof (tmp2), \" [%5dkB %5dkB]\", mi.arena >> 10,\n\t      mi.uordblks >> 10);\n    strcat (date, tmp2);\n#endif\n\n    char * result_c = NULL;\n    asprintf (&result_c, Y2LOG_FORMAT, date, level, hostname, pid);\n    string result = result_c;\n    free (result_c);\n\n    return result;\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2LOG_FORMAT\t\"%s <%d> %s(%d)\"",
            "#define Y2LOG_DATE\t\"%Y-%m-%d %H:%M:%S\"\t/* The date format */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_FORMAT\t\"%s <%d> %s(%d)\"\n#define Y2LOG_DATE\t\"%Y-%m-%d %H:%M:%S\"\t/* The date format */\n\nstring y2_logfmt_prefix (loglevel_t level)\n{\n    /* Prepare the PID */\n    pid_t pid = getpid();\n\n    /* Prepare the host name */\n    char hostname[1024];\n    if (gethostname(hostname, 1024))\n\tstrncpy(hostname, \"unknown\", 1024);\n\n    /* Prepare the date */\n#if 1\n    // just 1 second precision\n    time_t timestamp = time (NULL);\n    struct tm brokentime;\n    localtime_r (&timestamp, &brokentime);\n    char date[50];\t\t// that's big enough\n    strftime (date, sizeof (date), Y2LOG_DATE, &brokentime);\n#else\n    // 1 millisecond precision (use only for testing)\n    timeval time;\n    gettimeofday (&time, NULL);\n    time_t timestamp = time.tv_sec;\n    struct tm brokentime;\n    localtime_r (&timestamp, &brokentime);\n    char tmp1[50], date[50];\t// that's big enough\n    strftime (tmp1, sizeof (tmp1), Y2LOG_DATE, &brokentime);\n    snprintf (date, sizeof (date), \"%s.%03ld\", tmp1, time.tv_usec / 1000);\n#endif\n\n#if 0\n    // print \"bytes from system\" and \"bytes in use\" per thread (use only\n    // for testing)\n    struct mallinfo mi;\n    mi = mallinfo ();\n    char tmp2[50];\n    snprintf (tmp2, sizeof (tmp2), \" [%5dkB %5dkB]\", mi.arena >> 10,\n\t      mi.uordblks >> 10);\n    strcat (date, tmp2);\n#endif\n\n    char * result_c = NULL;\n    asprintf (&result_c, Y2LOG_FORMAT, date, level, hostname, pid);\n    string result = result_c;\n    free (result_c);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2_logfmt_common",
          "args": [
            "log_simple",
            "component",
            "file",
            "line",
            "function",
            "format",
            "ap"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "y2_logfmt_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "187-238",
          "snippet": "string y2_logfmt_common(bool simple, const char *component, const char *file,\n\t   const int line, const char *function, const char *format, va_list ap)\n{\n    /* Prepare the log text */\n    char *logtext = NULL;\n    vasprintf(&logtext, format, ap); /* GNU extension needs the define above */\n\n    /* Prepare the component */\n    string comp = component;\n    if (!comp.empty ())\n\tcomp = \" [\" + comp + \"]\";\n\n    /* Prepare the file, strip rooted path  */\n    if(*file == '/')\t\t     // rooted path\n    {\n\tconst char *slashptr = strrchr (file, '/');\n\tif (slashptr > file)\t\t    // last slash is second slash\n\t{\n\t    const char *slashptr2 = slashptr-1;\n\n\t    // find last but one slash\n\n\t    while ((slashptr2 > file) && (*slashptr2 != '/'))\n\t    {\n\t\tslashptr2--;\n\t    }\n\t    // if last but one slash exists, use this as start\n\t    if (slashptr2 != file)\n\t\tfile = slashptr2 + 1;\n\t}\n    }\n\n    /* Prepare the function */\n    string func = function;\n    if (!func.empty ())\n\tfunc = \"(\" + func + \")\";\n\n    /* do we need EOL? */\n    bool eol = false;\n    size_t len = strlen(logtext);\n    if ((len==0) || ((len>0) && (logtext[len-1]!='\\n')))\n\teol = true;\n\n    char * result_c;\n    asprintf(&result_c, simple? Y2LOG_SIMPLE: Y2LOG_COMMON,\n\t     comp.c_str (), file, func.c_str (), line, logtext, eol?\"\\n\":\"\");\n    string result = result_c;\n    free (result_c);\n\n    free (logtext);\n    return result;\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2LOG_SIMPLE\t\"%2$s%3$s:%4$d %1$s %5$s%6$s\"\t/* this is GNU gettext parameter reordering */",
            "#define Y2LOG_COMMON\t\"%s %s%s:%d %s%s\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_SIMPLE\t\"%2$s%3$s:%4$d %1$s %5$s%6$s\"\t/* this is GNU gettext parameter reordering */\n#define Y2LOG_COMMON\t\"%s %s%s:%d %s%s\"\n\nstring y2_logfmt_common(bool simple, const char *component, const char *file,\n\t   const int line, const char *function, const char *format, va_list ap)\n{\n    /* Prepare the log text */\n    char *logtext = NULL;\n    vasprintf(&logtext, format, ap); /* GNU extension needs the define above */\n\n    /* Prepare the component */\n    string comp = component;\n    if (!comp.empty ())\n\tcomp = \" [\" + comp + \"]\";\n\n    /* Prepare the file, strip rooted path  */\n    if(*file == '/')\t\t     // rooted path\n    {\n\tconst char *slashptr = strrchr (file, '/');\n\tif (slashptr > file)\t\t    // last slash is second slash\n\t{\n\t    const char *slashptr2 = slashptr-1;\n\n\t    // find last but one slash\n\n\t    while ((slashptr2 > file) && (*slashptr2 != '/'))\n\t    {\n\t\tslashptr2--;\n\t    }\n\t    // if last but one slash exists, use this as start\n\t    if (slashptr2 != file)\n\t\tfile = slashptr2 + 1;\n\t}\n    }\n\n    /* Prepare the function */\n    string func = function;\n    if (!func.empty ())\n\tfunc = \"(\" + func + \")\";\n\n    /* do we need EOL? */\n    bool eol = false;\n    size_t len = strlen(logtext);\n    if ((len==0) || ((len>0) && (logtext[len-1]!='\\n')))\n\teol = true;\n\n    char * result_c;\n    asprintf(&result_c, simple? Y2LOG_SIMPLE: Y2LOG_COMMON,\n\t     comp.c_str (), file, func.c_str (), line, logtext, eol?\"\\n\":\"\");\n    string result = result_c;\n    free (result_c);\n\n    free (logtext);\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic bool log_simple = false;\nLogTail blanik = LogTail ();\n\nvoid y2_vlogger_blanik(loglevel_t level, const char *component, const char *file,\n\t   const int line, const char *function, const char *format, va_list ap)\n{\n    string common = y2_logfmt_common (log_simple,\n\t\t\t\t      component, file, line, function,\n\t\t\t\t      format, ap);\n\n    if(log_to_syslog || log_to_file) {\n\tstring tolog;\n\tif (log_simple || (log_to_syslog > log_to_file))\n\t    tolog = common;\n\telse\n\t    tolog = y2_logfmt_prefix (level) + common;\n\t// store the message for worse times\n\t// (lock the variable that is shared among threads, bnc#565918)\n\tstatic pthread_mutex_t blanik_mutex = PTHREAD_MUTEX_INITIALIZER;\n\tpthread_mutex_lock (&blanik_mutex);\n\tblanik.push_back (tolog);\n\tpthread_mutex_unlock (&blanik_mutex);\n    }\n}"
  },
  {
    "function_name": "y2_vlogger_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "290-309",
    "snippet": "void y2_vlogger_function(loglevel_t level, const char *component, const char *file,\n\t   const int line, const char *function, const char *format, va_list ap)\n{\n    string common = y2_logfmt_common (log_simple,\n\t\t\t\t      component, file, line, function,\n\t\t\t\t      format, ap);\n\n    if(log_to_syslog) {\n\tsyslog (LOG_NOTICE, Y2LOG_SYSLOG, level, common.c_str ());\n    }\n\n    if(log_to_file) {\n\tstring tolog;\n\tif (log_simple)\n\t    tolog = common;\n\telse\n\t    tolog = y2_logfmt_prefix (level) + common;\n\tdo_log_yast (tolog.c_str ());\n    }\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [
      "#define Y2LOG_SYSLOG\t\"<%d>%s\""
    ],
    "globals_used": [
      "static bool log_to_file = true;",
      "static bool log_to_syslog = false;",
      "static bool log_simple = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_log_yast",
          "args": [
            "tolog.c_str ()"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "do_log_yast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "350-370",
          "snippet": "static\nvoid do_log_yast( const char* logmessage )\n{\n    /* Prepare the logfile name */\n    if(!did_set_logname) set_log_filename(\"\");\n\n    /* Prepare the logfile */\n    shift_log_files (string (logname));\n\n    FILE *logfile = open_logfile ();\n    if (!logfile)\n\treturn;\n\n    fprintf (logfile, \"%s\", logmessage);\n\n    /* Clean everything */\n    if (logfile && logfile != Y2LOG_STDERR)\n\tfclose (logfile);\n    else\n\tfflush (logfile);\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool did_set_logname = false;",
            "static const char *logname;",
            "static FILE *Y2LOG_STDERR = stderr;",
            "static void do_log_syslog( const char* logmessage );",
            "static void do_log_yast( const char* logmessage );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic bool did_set_logname = false;\nstatic const char *logname;\nstatic FILE *Y2LOG_STDERR = stderr;\nstatic void do_log_syslog( const char* logmessage );\nstatic void do_log_yast( const char* logmessage );\n\nstatic\nvoid do_log_yast( const char* logmessage )\n{\n    /* Prepare the logfile name */\n    if(!did_set_logname) set_log_filename(\"\");\n\n    /* Prepare the logfile */\n    shift_log_files (string (logname));\n\n    FILE *logfile = open_logfile ();\n    if (!logfile)\n\treturn;\n\n    fprintf (logfile, \"%s\", logmessage);\n\n    /* Clean everything */\n    if (logfile && logfile != Y2LOG_STDERR)\n\tfclose (logfile);\n    else\n\tfflush (logfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tolog.c_str",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2_logfmt_prefix",
          "args": [
            "level"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "y2_logfmt_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "240-287",
          "snippet": "string y2_logfmt_prefix (loglevel_t level)\n{\n    /* Prepare the PID */\n    pid_t pid = getpid();\n\n    /* Prepare the host name */\n    char hostname[1024];\n    if (gethostname(hostname, 1024))\n\tstrncpy(hostname, \"unknown\", 1024);\n\n    /* Prepare the date */\n#if 1\n    // just 1 second precision\n    time_t timestamp = time (NULL);\n    struct tm brokentime;\n    localtime_r (&timestamp, &brokentime);\n    char date[50];\t\t// that's big enough\n    strftime (date, sizeof (date), Y2LOG_DATE, &brokentime);\n#else\n    // 1 millisecond precision (use only for testing)\n    timeval time;\n    gettimeofday (&time, NULL);\n    time_t timestamp = time.tv_sec;\n    struct tm brokentime;\n    localtime_r (&timestamp, &brokentime);\n    char tmp1[50], date[50];\t// that's big enough\n    strftime (tmp1, sizeof (tmp1), Y2LOG_DATE, &brokentime);\n    snprintf (date, sizeof (date), \"%s.%03ld\", tmp1, time.tv_usec / 1000);\n#endif\n\n#if 0\n    // print \"bytes from system\" and \"bytes in use\" per thread (use only\n    // for testing)\n    struct mallinfo mi;\n    mi = mallinfo ();\n    char tmp2[50];\n    snprintf (tmp2, sizeof (tmp2), \" [%5dkB %5dkB]\", mi.arena >> 10,\n\t      mi.uordblks >> 10);\n    strcat (date, tmp2);\n#endif\n\n    char * result_c = NULL;\n    asprintf (&result_c, Y2LOG_FORMAT, date, level, hostname, pid);\n    string result = result_c;\n    free (result_c);\n\n    return result;\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2LOG_FORMAT\t\"%s <%d> %s(%d)\"",
            "#define Y2LOG_DATE\t\"%Y-%m-%d %H:%M:%S\"\t/* The date format */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_FORMAT\t\"%s <%d> %s(%d)\"\n#define Y2LOG_DATE\t\"%Y-%m-%d %H:%M:%S\"\t/* The date format */\n\nstring y2_logfmt_prefix (loglevel_t level)\n{\n    /* Prepare the PID */\n    pid_t pid = getpid();\n\n    /* Prepare the host name */\n    char hostname[1024];\n    if (gethostname(hostname, 1024))\n\tstrncpy(hostname, \"unknown\", 1024);\n\n    /* Prepare the date */\n#if 1\n    // just 1 second precision\n    time_t timestamp = time (NULL);\n    struct tm brokentime;\n    localtime_r (&timestamp, &brokentime);\n    char date[50];\t\t// that's big enough\n    strftime (date, sizeof (date), Y2LOG_DATE, &brokentime);\n#else\n    // 1 millisecond precision (use only for testing)\n    timeval time;\n    gettimeofday (&time, NULL);\n    time_t timestamp = time.tv_sec;\n    struct tm brokentime;\n    localtime_r (&timestamp, &brokentime);\n    char tmp1[50], date[50];\t// that's big enough\n    strftime (tmp1, sizeof (tmp1), Y2LOG_DATE, &brokentime);\n    snprintf (date, sizeof (date), \"%s.%03ld\", tmp1, time.tv_usec / 1000);\n#endif\n\n#if 0\n    // print \"bytes from system\" and \"bytes in use\" per thread (use only\n    // for testing)\n    struct mallinfo mi;\n    mi = mallinfo ();\n    char tmp2[50];\n    snprintf (tmp2, sizeof (tmp2), \" [%5dkB %5dkB]\", mi.arena >> 10,\n\t      mi.uordblks >> 10);\n    strcat (date, tmp2);\n#endif\n\n    char * result_c = NULL;\n    asprintf (&result_c, Y2LOG_FORMAT, date, level, hostname, pid);\n    string result = result_c;\n    free (result_c);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_NOTICE",
            "Y2LOG_SYSLOG",
            "level",
            "common.c_str ()"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "common.c_str",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2_logfmt_common",
          "args": [
            "log_simple",
            "component",
            "file",
            "line",
            "function",
            "format",
            "ap"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "y2_logfmt_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "187-238",
          "snippet": "string y2_logfmt_common(bool simple, const char *component, const char *file,\n\t   const int line, const char *function, const char *format, va_list ap)\n{\n    /* Prepare the log text */\n    char *logtext = NULL;\n    vasprintf(&logtext, format, ap); /* GNU extension needs the define above */\n\n    /* Prepare the component */\n    string comp = component;\n    if (!comp.empty ())\n\tcomp = \" [\" + comp + \"]\";\n\n    /* Prepare the file, strip rooted path  */\n    if(*file == '/')\t\t     // rooted path\n    {\n\tconst char *slashptr = strrchr (file, '/');\n\tif (slashptr > file)\t\t    // last slash is second slash\n\t{\n\t    const char *slashptr2 = slashptr-1;\n\n\t    // find last but one slash\n\n\t    while ((slashptr2 > file) && (*slashptr2 != '/'))\n\t    {\n\t\tslashptr2--;\n\t    }\n\t    // if last but one slash exists, use this as start\n\t    if (slashptr2 != file)\n\t\tfile = slashptr2 + 1;\n\t}\n    }\n\n    /* Prepare the function */\n    string func = function;\n    if (!func.empty ())\n\tfunc = \"(\" + func + \")\";\n\n    /* do we need EOL? */\n    bool eol = false;\n    size_t len = strlen(logtext);\n    if ((len==0) || ((len>0) && (logtext[len-1]!='\\n')))\n\teol = true;\n\n    char * result_c;\n    asprintf(&result_c, simple? Y2LOG_SIMPLE: Y2LOG_COMMON,\n\t     comp.c_str (), file, func.c_str (), line, logtext, eol?\"\\n\":\"\");\n    string result = result_c;\n    free (result_c);\n\n    free (logtext);\n    return result;\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2LOG_SIMPLE\t\"%2$s%3$s:%4$d %1$s %5$s%6$s\"\t/* this is GNU gettext parameter reordering */",
            "#define Y2LOG_COMMON\t\"%s %s%s:%d %s%s\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_SIMPLE\t\"%2$s%3$s:%4$d %1$s %5$s%6$s\"\t/* this is GNU gettext parameter reordering */\n#define Y2LOG_COMMON\t\"%s %s%s:%d %s%s\"\n\nstring y2_logfmt_common(bool simple, const char *component, const char *file,\n\t   const int line, const char *function, const char *format, va_list ap)\n{\n    /* Prepare the log text */\n    char *logtext = NULL;\n    vasprintf(&logtext, format, ap); /* GNU extension needs the define above */\n\n    /* Prepare the component */\n    string comp = component;\n    if (!comp.empty ())\n\tcomp = \" [\" + comp + \"]\";\n\n    /* Prepare the file, strip rooted path  */\n    if(*file == '/')\t\t     // rooted path\n    {\n\tconst char *slashptr = strrchr (file, '/');\n\tif (slashptr > file)\t\t    // last slash is second slash\n\t{\n\t    const char *slashptr2 = slashptr-1;\n\n\t    // find last but one slash\n\n\t    while ((slashptr2 > file) && (*slashptr2 != '/'))\n\t    {\n\t\tslashptr2--;\n\t    }\n\t    // if last but one slash exists, use this as start\n\t    if (slashptr2 != file)\n\t\tfile = slashptr2 + 1;\n\t}\n    }\n\n    /* Prepare the function */\n    string func = function;\n    if (!func.empty ())\n\tfunc = \"(\" + func + \")\";\n\n    /* do we need EOL? */\n    bool eol = false;\n    size_t len = strlen(logtext);\n    if ((len==0) || ((len>0) && (logtext[len-1]!='\\n')))\n\teol = true;\n\n    char * result_c;\n    asprintf(&result_c, simple? Y2LOG_SIMPLE: Y2LOG_COMMON,\n\t     comp.c_str (), file, func.c_str (), line, logtext, eol?\"\\n\":\"\");\n    string result = result_c;\n    free (result_c);\n\n    free (logtext);\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_SYSLOG\t\"<%d>%s\"\n\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic bool log_simple = false;\n\nvoid y2_vlogger_function(loglevel_t level, const char *component, const char *file,\n\t   const int line, const char *function, const char *format, va_list ap)\n{\n    string common = y2_logfmt_common (log_simple,\n\t\t\t\t      component, file, line, function,\n\t\t\t\t      format, ap);\n\n    if(log_to_syslog) {\n\tsyslog (LOG_NOTICE, Y2LOG_SYSLOG, level, common.c_str ());\n    }\n\n    if(log_to_file) {\n\tstring tolog;\n\tif (log_simple)\n\t    tolog = common;\n\telse\n\t    tolog = y2_logfmt_prefix (level) + common;\n\tdo_log_yast (tolog.c_str ());\n    }\n}"
  },
  {
    "function_name": "y2_logfmt_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "240-287",
    "snippet": "string y2_logfmt_prefix (loglevel_t level)\n{\n    /* Prepare the PID */\n    pid_t pid = getpid();\n\n    /* Prepare the host name */\n    char hostname[1024];\n    if (gethostname(hostname, 1024))\n\tstrncpy(hostname, \"unknown\", 1024);\n\n    /* Prepare the date */\n#if 1\n    // just 1 second precision\n    time_t timestamp = time (NULL);\n    struct tm brokentime;\n    localtime_r (&timestamp, &brokentime);\n    char date[50];\t\t// that's big enough\n    strftime (date, sizeof (date), Y2LOG_DATE, &brokentime);\n#else\n    // 1 millisecond precision (use only for testing)\n    timeval time;\n    gettimeofday (&time, NULL);\n    time_t timestamp = time.tv_sec;\n    struct tm brokentime;\n    localtime_r (&timestamp, &brokentime);\n    char tmp1[50], date[50];\t// that's big enough\n    strftime (tmp1, sizeof (tmp1), Y2LOG_DATE, &brokentime);\n    snprintf (date, sizeof (date), \"%s.%03ld\", tmp1, time.tv_usec / 1000);\n#endif\n\n#if 0\n    // print \"bytes from system\" and \"bytes in use\" per thread (use only\n    // for testing)\n    struct mallinfo mi;\n    mi = mallinfo ();\n    char tmp2[50];\n    snprintf (tmp2, sizeof (tmp2), \" [%5dkB %5dkB]\", mi.arena >> 10,\n\t      mi.uordblks >> 10);\n    strcat (date, tmp2);\n#endif\n\n    char * result_c = NULL;\n    asprintf (&result_c, Y2LOG_FORMAT, date, level, hostname, pid);\n    string result = result_c;\n    free (result_c);\n\n    return result;\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [
      "#define Y2LOG_FORMAT\t\"%s <%d> %s(%d)\"",
      "#define Y2LOG_DATE\t\"%Y-%m-%d %H:%M:%S\"\t/* The date format */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "result_c"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&result_c",
            "Y2LOG_FORMAT",
            "date",
            "level",
            "hostname",
            "pid"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "date",
            "tmp2"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmp2",
            "sizeof (tmp2)",
            "\" [%5dkB %5dkB]\"",
            "mi.arena >> 10",
            "mi.uordblks >> 10"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mallinfo",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "date",
            "sizeof (date)",
            "\"%s.%03ld\"",
            "tmp1",
            "time.tv_usec / 1000"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strftime",
          "args": [
            "tmp1",
            "sizeof (tmp1)",
            "Y2LOG_DATE",
            "&brokentime"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localtime_r",
          "args": [
            "&timestamp",
            "&brokentime"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettimeofday",
          "args": [
            "&time",
            "NULL"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strftime",
          "args": [
            "date",
            "sizeof (date)",
            "Y2LOG_DATE",
            "&brokentime"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localtime_r",
          "args": [
            "&timestamp",
            "&brokentime"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "hostname",
            "\"unknown\"",
            "1024"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gethostname",
          "args": [
            "hostname",
            "1024"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "getpid",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/ExternalProgram.h",
          "lines": "109-109",
          "snippet": "pid_t getpid() { return pid; }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <y2util/ExternalDataSource.h>",
            "#include <string>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <y2util/ExternalDataSource.h>\n#include <string>\n#include <map>\n\nExternalProgram {\n  pid_t getpid() { return pid; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_FORMAT\t\"%s <%d> %s(%d)\"\n#define Y2LOG_DATE\t\"%Y-%m-%d %H:%M:%S\"\t/* The date format */\n\nstring y2_logfmt_prefix (loglevel_t level)\n{\n    /* Prepare the PID */\n    pid_t pid = getpid();\n\n    /* Prepare the host name */\n    char hostname[1024];\n    if (gethostname(hostname, 1024))\n\tstrncpy(hostname, \"unknown\", 1024);\n\n    /* Prepare the date */\n#if 1\n    // just 1 second precision\n    time_t timestamp = time (NULL);\n    struct tm brokentime;\n    localtime_r (&timestamp, &brokentime);\n    char date[50];\t\t// that's big enough\n    strftime (date, sizeof (date), Y2LOG_DATE, &brokentime);\n#else\n    // 1 millisecond precision (use only for testing)\n    timeval time;\n    gettimeofday (&time, NULL);\n    time_t timestamp = time.tv_sec;\n    struct tm brokentime;\n    localtime_r (&timestamp, &brokentime);\n    char tmp1[50], date[50];\t// that's big enough\n    strftime (tmp1, sizeof (tmp1), Y2LOG_DATE, &brokentime);\n    snprintf (date, sizeof (date), \"%s.%03ld\", tmp1, time.tv_usec / 1000);\n#endif\n\n#if 0\n    // print \"bytes from system\" and \"bytes in use\" per thread (use only\n    // for testing)\n    struct mallinfo mi;\n    mi = mallinfo ();\n    char tmp2[50];\n    snprintf (tmp2, sizeof (tmp2), \" [%5dkB %5dkB]\", mi.arena >> 10,\n\t      mi.uordblks >> 10);\n    strcat (date, tmp2);\n#endif\n\n    char * result_c = NULL;\n    asprintf (&result_c, Y2LOG_FORMAT, date, level, hostname, pid);\n    string result = result_c;\n    free (result_c);\n\n    return result;\n}"
  },
  {
    "function_name": "y2_logfmt_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "187-238",
    "snippet": "string y2_logfmt_common(bool simple, const char *component, const char *file,\n\t   const int line, const char *function, const char *format, va_list ap)\n{\n    /* Prepare the log text */\n    char *logtext = NULL;\n    vasprintf(&logtext, format, ap); /* GNU extension needs the define above */\n\n    /* Prepare the component */\n    string comp = component;\n    if (!comp.empty ())\n\tcomp = \" [\" + comp + \"]\";\n\n    /* Prepare the file, strip rooted path  */\n    if(*file == '/')\t\t     // rooted path\n    {\n\tconst char *slashptr = strrchr (file, '/');\n\tif (slashptr > file)\t\t    // last slash is second slash\n\t{\n\t    const char *slashptr2 = slashptr-1;\n\n\t    // find last but one slash\n\n\t    while ((slashptr2 > file) && (*slashptr2 != '/'))\n\t    {\n\t\tslashptr2--;\n\t    }\n\t    // if last but one slash exists, use this as start\n\t    if (slashptr2 != file)\n\t\tfile = slashptr2 + 1;\n\t}\n    }\n\n    /* Prepare the function */\n    string func = function;\n    if (!func.empty ())\n\tfunc = \"(\" + func + \")\";\n\n    /* do we need EOL? */\n    bool eol = false;\n    size_t len = strlen(logtext);\n    if ((len==0) || ((len>0) && (logtext[len-1]!='\\n')))\n\teol = true;\n\n    char * result_c;\n    asprintf(&result_c, simple? Y2LOG_SIMPLE: Y2LOG_COMMON,\n\t     comp.c_str (), file, func.c_str (), line, logtext, eol?\"\\n\":\"\");\n    string result = result_c;\n    free (result_c);\n\n    free (logtext);\n    return result;\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [
      "#define Y2LOG_SIMPLE\t\"%2$s%3$s:%4$d %1$s %5$s%6$s\"\t/* this is GNU gettext parameter reordering */",
      "#define Y2LOG_COMMON\t\"%s %s%s:%d %s%s\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "logtext"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "result_c"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&result_c",
            "simple? Y2LOG_SIMPLE: Y2LOG_COMMON",
            "comp.c_str ()",
            "file",
            "func.c_str ()",
            "line",
            "logtext",
            "eol?\"\\n\":\"\""
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func.c_str",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comp.c_str",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "logtext"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func.empty",
          "args": [],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "file",
            "'/'"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vasprintf",
          "args": [
            "&logtext",
            "format",
            "ap"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_SIMPLE\t\"%2$s%3$s:%4$d %1$s %5$s%6$s\"\t/* this is GNU gettext parameter reordering */\n#define Y2LOG_COMMON\t\"%s %s%s:%d %s%s\"\n\nstring y2_logfmt_common(bool simple, const char *component, const char *file,\n\t   const int line, const char *function, const char *format, va_list ap)\n{\n    /* Prepare the log text */\n    char *logtext = NULL;\n    vasprintf(&logtext, format, ap); /* GNU extension needs the define above */\n\n    /* Prepare the component */\n    string comp = component;\n    if (!comp.empty ())\n\tcomp = \" [\" + comp + \"]\";\n\n    /* Prepare the file, strip rooted path  */\n    if(*file == '/')\t\t     // rooted path\n    {\n\tconst char *slashptr = strrchr (file, '/');\n\tif (slashptr > file)\t\t    // last slash is second slash\n\t{\n\t    const char *slashptr2 = slashptr-1;\n\n\t    // find last but one slash\n\n\t    while ((slashptr2 > file) && (*slashptr2 != '/'))\n\t    {\n\t\tslashptr2--;\n\t    }\n\t    // if last but one slash exists, use this as start\n\t    if (slashptr2 != file)\n\t\tfile = slashptr2 + 1;\n\t}\n    }\n\n    /* Prepare the function */\n    string func = function;\n    if (!func.empty ())\n\tfunc = \"(\" + func + \")\";\n\n    /* do we need EOL? */\n    bool eol = false;\n    size_t len = strlen(logtext);\n    if ((len==0) || ((len>0) && (logtext[len-1]!='\\n')))\n\teol = true;\n\n    char * result_c;\n    asprintf(&result_c, simple? Y2LOG_SIMPLE: Y2LOG_COMMON,\n\t     comp.c_str (), file, func.c_str (), line, logtext, eol?\"\\n\":\"\");\n    string result = result_c;\n    free (result_c);\n\n    free (logtext);\n    return result;\n}"
  },
  {
    "function_name": "y2_logger_blanik",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "175-182",
    "snippet": "void y2_logger_blanik(loglevel_t level, const char *component, const char *file,\n\t  const int line, const char *func, const char *format, ...)\n{\n    va_list ap;\n    va_start(ap, format);\n    y2_vlogger_blanik(level, component, file, line, func, format, ap);\n    va_end(ap);\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2_vlogger_blanik",
          "args": [
            "level",
            "component",
            "file",
            "line",
            "func",
            "format",
            "ap"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "y2_vlogger_blanik",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "311-331",
          "snippet": "void y2_vlogger_blanik(loglevel_t level, const char *component, const char *file,\n\t   const int line, const char *function, const char *format, va_list ap)\n{\n    string common = y2_logfmt_common (log_simple,\n\t\t\t\t      component, file, line, function,\n\t\t\t\t      format, ap);\n\n    if(log_to_syslog || log_to_file) {\n\tstring tolog;\n\tif (log_simple || (log_to_syslog > log_to_file))\n\t    tolog = common;\n\telse\n\t    tolog = y2_logfmt_prefix (level) + common;\n\t// store the message for worse times\n\t// (lock the variable that is shared among threads, bnc#565918)\n\tstatic pthread_mutex_t blanik_mutex = PTHREAD_MUTEX_INITIALIZER;\n\tpthread_mutex_lock (&blanik_mutex);\n\tblanik.push_back (tolog);\n\tpthread_mutex_unlock (&blanik_mutex);\n    }\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool log_to_file = true;",
            "static bool log_to_syslog = false;",
            "static bool log_simple = false;",
            "LogTail blanik = LogTail ();"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic bool log_simple = false;\nLogTail blanik = LogTail ();\n\nvoid y2_vlogger_blanik(loglevel_t level, const char *component, const char *file,\n\t   const int line, const char *function, const char *format, va_list ap)\n{\n    string common = y2_logfmt_common (log_simple,\n\t\t\t\t      component, file, line, function,\n\t\t\t\t      format, ap);\n\n    if(log_to_syslog || log_to_file) {\n\tstring tolog;\n\tif (log_simple || (log_to_syslog > log_to_file))\n\t    tolog = common;\n\telse\n\t    tolog = y2_logfmt_prefix (level) + common;\n\t// store the message for worse times\n\t// (lock the variable that is shared among threads, bnc#565918)\n\tstatic pthread_mutex_t blanik_mutex = PTHREAD_MUTEX_INITIALIZER;\n\tpthread_mutex_lock (&blanik_mutex);\n\tblanik.push_back (tolog);\n\tpthread_mutex_unlock (&blanik_mutex);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "format"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid y2_logger_blanik(loglevel_t level, const char *component, const char *file,\n\t  const int line, const char *func, const char *format, ...)\n{\n    va_list ap;\n    va_start(ap, format);\n    y2_vlogger_blanik(level, component, file, line, func, format, ap);\n    va_end(ap);\n}"
  },
  {
    "function_name": "y2_logger_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "166-173",
    "snippet": "void y2_logger_function(loglevel_t level, const char *component, const char *file,\n\t  const int line, const char *func, const char *format, ...)\n{\n    va_list ap;\n    va_start(ap, format);\n    y2_vlogger_function(level, component, file, line, func, format, ap);\n    va_end(ap);\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2_vlogger_function",
          "args": [
            "level",
            "component",
            "file",
            "line",
            "func",
            "format",
            "ap"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "y2_vlogger_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
          "lines": "290-309",
          "snippet": "void y2_vlogger_function(loglevel_t level, const char *component, const char *file,\n\t   const int line, const char *function, const char *format, va_list ap)\n{\n    string common = y2_logfmt_common (log_simple,\n\t\t\t\t      component, file, line, function,\n\t\t\t\t      format, ap);\n\n    if(log_to_syslog) {\n\tsyslog (LOG_NOTICE, Y2LOG_SYSLOG, level, common.c_str ());\n    }\n\n    if(log_to_file) {\n\tstring tolog;\n\tif (log_simple)\n\t    tolog = common;\n\telse\n\t    tolog = y2_logfmt_prefix (level) + common;\n\tdo_log_yast (tolog.c_str ());\n    }\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/miniini.h\"",
            "#include \"y2util/y2log.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2LOG_SYSLOG\t\"<%d>%s\""
          ],
          "globals_used": [
            "static bool log_to_file = true;",
            "static bool log_to_syslog = false;",
            "static bool log_simple = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2LOG_SYSLOG\t\"<%d>%s\"\n\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic bool log_simple = false;\n\nvoid y2_vlogger_function(loglevel_t level, const char *component, const char *file,\n\t   const int line, const char *function, const char *format, va_list ap)\n{\n    string common = y2_logfmt_common (log_simple,\n\t\t\t\t      component, file, line, function,\n\t\t\t\t      format, ap);\n\n    if(log_to_syslog) {\n\tsyslog (LOG_NOTICE, Y2LOG_SYSLOG, level, common.c_str ());\n    }\n\n    if(log_to_file) {\n\tstring tolog;\n\tif (log_simple)\n\t    tolog = common;\n\telse\n\t    tolog = y2_logfmt_prefix (level) + common;\n\tdo_log_yast (tolog.c_str ());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "format"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid y2_logger_function(loglevel_t level, const char *component, const char *file,\n\t  const int line, const char *func, const char *format, ...)\n{\n    va_list ap;\n    va_start(ap, format);\n    y2_vlogger_function(level, component, file, line, func, format, ap);\n    va_end(ap);\n}"
  },
  {
    "function_name": "dup_stderr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2log.cc",
    "lines": "115-138",
    "snippet": "static int dup_stderr()\n{\n    int dupstderr = dup( 2 );\n    if ( dupstderr != -1 ) {\n\tFILE * newstderr = fdopen( dupstderr, \"a\" );\n\n\tif ( newstderr == NULL ) {\n\t  char buf[100];\n\t  //bnc#493152#c22\n\t  strerror_r(errno, buf, sizeof(buf)-1);\n\t  fprintf( Y2LOG_STDERR, \"y2log: Can't fdopen new stderr: %s.\\n\", buf);\n\t}\n\telse {\n\t    fcntl (fileno (newstderr), F_SETFD, fcntl (fileno (newstderr), F_GETFD) | FD_CLOEXEC);\n\t    Y2LOG_STDERR = newstderr;\n\t}\n    }\n    else {\n        char buf[100];\n\tstrerror_r(errno, buf, sizeof(buf)-1);\n\tfprintf( Y2LOG_STDERR, \"y2log: Can't dup stderr: %s.\\n\", buf );\n    }\n    return 1;\n}",
    "includes": [
      "#include <syslog.h>",
      "#include \"y2util/PathInfo.h\"",
      "#include \"y2util/stringutil.h\"",
      "#include \"y2util/miniini.h\"",
      "#include \"y2util/y2log.h\"",
      "#include <list>",
      "#include <limits>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <malloc.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static FILE *Y2LOG_STDERR = stderr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "Y2LOG_STDERR",
            "\"y2log: Can't dup stderr: %s.\\n\"",
            "buf"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "buf",
            "sizeof(buf)-1"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fileno (newstderr)",
            "F_SETFD",
            "fcntl (fileno (newstderr), F_GETFD) | FD_CLOEXEC"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fileno (newstderr)",
            "F_GETFD"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "newstderr"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "newstderr"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "Y2LOG_STDERR",
            "\"y2log: Can't fdopen new stderr: %s.\\n\"",
            "buf"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "buf",
            "sizeof(buf)-1"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "dupstderr",
            "\"a\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup",
          "args": [
            "2"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/miniini.h\"\n#include \"y2util/y2log.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic FILE *Y2LOG_STDERR = stderr;\n\nstatic int dup_stderr()\n{\n    int dupstderr = dup( 2 );\n    if ( dupstderr != -1 ) {\n\tFILE * newstderr = fdopen( dupstderr, \"a\" );\n\n\tif ( newstderr == NULL ) {\n\t  char buf[100];\n\t  //bnc#493152#c22\n\t  strerror_r(errno, buf, sizeof(buf)-1);\n\t  fprintf( Y2LOG_STDERR, \"y2log: Can't fdopen new stderr: %s.\\n\", buf);\n\t}\n\telse {\n\t    fcntl (fileno (newstderr), F_SETFD, fcntl (fileno (newstderr), F_GETFD) | FD_CLOEXEC);\n\t    Y2LOG_STDERR = newstderr;\n\t}\n    }\n    else {\n        char buf[100];\n\tstrerror_r(errno, buf, sizeof(buf)-1);\n\tfprintf( Y2LOG_STDERR, \"y2log: Can't dup stderr: %s.\\n\", buf );\n    }\n    return 1;\n}"
  }
]