[
  {
    "function_name": "initialize",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "295-324",
    "snippet": "void\nY2Namespace::initialize ()\n{\n    if (m_initialized)\n    {\n\t// we are already initialized\n\treturn;\n    }\n    \n    // avoid recursion\n    m_initialized = true;\n\n    evaluate ();\n    \n    if (table ())\n    { \n\tSymbolTable* t = table ();\n\tt->disableUsage ();\n\tif (t->find (name ().c_str ()))\n\t{\n\t    Y2Function* c = createFunctionCall (name (), 0);\n\t    if (c)\n\t    {\n\t\tc->evaluateCall ();\n\t    }\n\t    delete c;\n\t}\n\tt->enableUsage ();\n    }\n}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->enableUsage",
          "args": [],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "enableUsage",
          "container": "SymbolTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "427-434",
          "snippet": "void\nSymbolTable::enableUsage ()\n{\n#if DO_DEBUG\n    y2debug (\"SymbolTable[%p]::enableUsage\", this);\n#endif\n    m_track_usage = true;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\n#define DO_DEBUG 0\n\nSymbolTable {\n  void\n  SymbolTable::enableUsage ()\n  {\n  #if DO_DEBUG\n      y2debug (\"SymbolTable[%p]::enableUsage\", this);\n  #endif\n      m_track_usage = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->evaluateCall",
          "args": [],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "evaluateCall",
          "container": "Y2YCPFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YExpression.cc",
          "lines": "3306-3388",
          "snippet": "YCPValue\nY2YCPFunction::evaluateCall ()\n{\n#if DO_DEBUG\n//    y2debug (\"Y2YCPFunction::evaluateCall (%s)\\n\", toString().c_str());\n#endif\n\n    YFunctionPtr func = (YFunctionPtr)(m_sentry->code());\n\n    // push parameter values for recursion\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tfunc->parameter (p)->push ();\n    }\n\n    // push also local parameters\n    YCodePtr definition = func->definition ();\n\n    if (definition == 0)\n    {\n\tycp2error (\"Function '%s' is only declared, but not defined yet.\", m_sentry->toString().c_str());\n\treturn YCPNull();\n    }\n\n    if (definition->isBlock())\n    {\n//       ((YBlockPtr)definition)->pushToStack ();\n    }\n\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tYCPValue value = m_parameters[p];\n\n\tif (value.isNull())\n\t{\n\t    ycp2error (\"Parameter not specified (%d)\", p);\n\n\t    // cleanup: pop parameter values for recursion\n\t    for (unsigned int p = 0; p < func->parameterCount(); p++)\n\t    {\n\t\tfunc->parameter (p)->pop ();\n\t    }\n\n\t    return value;\n\t}\n\t\n\tSymbolEntryPtr formalp = func->parameter (p);\n#if DO_DEBUG\n\ty2debug (\"formalp (%s) = (%s)\", formalp->toString().c_str(), value->toString().c_str());\n#endif\n\n\tformalp->setValue (value);\n    }\n    \n    extern ExecutionEnvironment ee;\n\n    // save the context info\n    int linenumber = ee.linenumber ();\n    string filename = ee.filename ();\n\n    YCPValue value = definition->evaluate ();\n\n    if (definition->isBlock())\n    {\n       // pop also local parameters\n//       ((YBlockPtr)definition)->popFromStack ();\n    }\n\n    // restore the context info\n    ee.setLinenumber (linenumber);\n    ee.setFilename (filename);\n\n    // pop parameter values for recursion\n    for (unsigned int p = 0; p < func->parameterCount(); p++)\n    {\n\tfunc->parameter (p)->pop ();\n    }\n\n#if DO_DEBUG\n    y2debug(\"evaluate done (%s) = '%s'\", definition->toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n#endif\n    return value;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/YExpression.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <libintl.h>\t// for dngettext"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/YExpression.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/y2log.h\"\n#include <libintl.h>\t// for dngettext\n\n#define DO_DEBUG 0\n\nY2YCPFunction {\n  YCPValue\n  Y2YCPFunction::evaluateCall ()\n  {\n  #if DO_DEBUG\n  //    y2debug (\"Y2YCPFunction::evaluateCall (%s)\\n\", toString().c_str());\n  #endif\n  \n      YFunctionPtr func = (YFunctionPtr)(m_sentry->code());\n  \n      // push parameter values for recursion\n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tfunc->parameter (p)->push ();\n      }\n  \n      // push also local parameters\n      YCodePtr definition = func->definition ();\n  \n      if (definition == 0)\n      {\n  \tycp2error (\"Function '%s' is only declared, but not defined yet.\", m_sentry->toString().c_str());\n  \treturn YCPNull();\n      }\n  \n      if (definition->isBlock())\n      {\n  //       ((YBlockPtr)definition)->pushToStack ();\n      }\n  \n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tYCPValue value = m_parameters[p];\n  \n  \tif (value.isNull())\n  \t{\n  \t    ycp2error (\"Parameter not specified (%d)\", p);\n  \n  \t    // cleanup: pop parameter values for recursion\n  \t    for (unsigned int p = 0; p < func->parameterCount(); p++)\n  \t    {\n  \t\tfunc->parameter (p)->pop ();\n  \t    }\n  \n  \t    return value;\n  \t}\n  \t\n  \tSymbolEntryPtr formalp = func->parameter (p);\n  #if DO_DEBUG\n  \ty2debug (\"formalp (%s) = (%s)\", formalp->toString().c_str(), value->toString().c_str());\n  #endif\n  \n  \tformalp->setValue (value);\n      }\n      \n      extern ExecutionEnvironment ee;\n  \n      // save the context info\n      int linenumber = ee.linenumber ();\n      string filename = ee.filename ();\n  \n      YCPValue value = definition->evaluate ();\n  \n      if (definition->isBlock())\n      {\n         // pop also local parameters\n  //       ((YBlockPtr)definition)->popFromStack ();\n      }\n  \n      // restore the context info\n      ee.setLinenumber (linenumber);\n      ee.setFilename (filename);\n  \n      // pop parameter values for recursion\n      for (unsigned int p = 0; p < func->parameterCount(); p++)\n      {\n  \tfunc->parameter (p)->pop ();\n      }\n  \n  #if DO_DEBUG\n      y2debug(\"evaluate done (%s) = '%s'\", definition->toString().c_str(), value.isNull() ? \"NULL\" : value->toString().c_str());\n  #endif\n      return value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "createFunctionCall",
          "args": [
            "name ()",
            "0"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "62-66",
          "snippet": "const string\nY2Namespace::name () const\n{\n    return \"\";\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  const string\n  Y2Namespace::name () const\n  {\n      return \"\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->find",
          "args": [
            "name ().c_str ()"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "findByPath",
          "container": "ScriptingAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/scr/src/ScriptingAgent.cc",
          "lines": "623-634",
          "snippet": "ScriptingAgent::SubAgents::iterator\nScriptingAgent::findByPath (const YCPPath &path)\n{\n    SubAgents::iterator agent = std::lower_bound (agents.begin (),\n\t\t\t\t\t\t  agents.end (),\n\t\t\t\t\t\t  path);\n\n    if (agent != agents.end () && (*agent)->get_path ()->equal (path))\n\treturn agent;\n\n    return agents.end ();\n}",
          "includes": [
            "#include \"ScriptingAgent.h\"",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <ycp/pathsearch.h>",
            "#include <ycp/y2log.h>",
            "#include <algorithm>",
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ScriptingAgent.h\"\n#include <y2/Y2ComponentBroker.h>\n#include <ycp/pathsearch.h>\n#include <ycp/y2log.h>\n#include <algorithm>\n#include <sys/stat.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdio.h>\n#include <errno.h>\n\nScriptingAgent {\n  ScriptingAgent::SubAgents::iterator\n  ScriptingAgent::findByPath (const YCPPath &path)\n  {\n      SubAgents::iterator agent = std::lower_bound (agents.begin (),\n  \t\t\t\t\t\t  agents.end (),\n  \t\t\t\t\t\t  path);\n  \n      if (agent != agents.end () && (*agent)->get_path ()->equal (path))\n  \treturn agent;\n  \n      return agents.end ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->disableUsage",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "disableUsage",
          "container": "SymbolTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/SymbolTable.cc",
          "lines": "437-444",
          "snippet": "void\nSymbolTable::disableUsage ()\n{\n#if DO_DEBUG\n    y2debug (\"SymbolTable[%p]::disableUsage\", this);\n#endif\n    m_track_usage = false;\n}",
          "includes": [
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Point.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include <stdlib.h>\n\n#define DO_DEBUG 0\n\nSymbolTable {\n  void\n  SymbolTable::disableUsage ()\n  {\n  #if DO_DEBUG\n      y2debug (\"SymbolTable[%p]::disableUsage\", this);\n  #endif\n      m_track_usage = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "table",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  void\n  Y2Namespace::initialize ()\n  {\n      if (m_initialized)\n      {\n  \t// we are already initialized\n  \treturn;\n      }\n      \n      // avoid recursion\n      m_initialized = true;\n  \n      evaluate ();\n      \n      if (table ())\n      { \n  \tSymbolTable* t = table ();\n  \tt->disableUsage ();\n  \tif (t->find (name ().c_str ()))\n  \t{\n  \t    Y2Function* c = createFunctionCall (name (), 0);\n  \t    if (c)\n  \t    {\n  \t\tc->evaluateCall ();\n  \t    }\n  \t    delete c;\n  \t}\n  \tt->enableUsage ();\n      }\n  }\n}"
  },
  {
    "function_name": "createTable",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "286-293",
    "snippet": "void\nY2Namespace::createTable ()\n{\n    if (m_table == 0)\n    {\n\tm_table = new SymbolTable (-1);\n    }\n}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  void\n  Y2Namespace::createTable ()\n  {\n      if (m_table == 0)\n      {\n  \tm_table = new SymbolTable (-1);\n      }\n  }\n}"
  },
  {
    "function_name": "popFromStack",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "267-277",
    "snippet": "void\nY2Namespace::popFromStack ()\n{\n    for (unsigned int p = 0; p < m_symbolcount; p++)\n    {\n\tif ( m_symbols[p] && m_symbols[p]->isVariable() )\n        {\n            m_symbols[p]->pop ();\n        }\n    }\n}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_symbols[p]->pop",
          "args": [],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "pop",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "159-167",
          "snippet": "void\nSymbolEntry::pop ()\n{\n    if (! m_recurse_stack)\n\treturn;\n\n    m_value = m_recurse_stack->top ();\n    m_recurse_stack->pop ();\n}",
          "includes": [
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  void\n  SymbolEntry::pop ()\n  {\n      if (! m_recurse_stack)\n  \treturn;\n  \n      m_value = m_recurse_stack->top ();\n      m_recurse_stack->pop ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_symbols[p]->isVariable",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "isVariable",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "298-298",
          "snippet": "bool isVariable () const\t{ return m_kind == VariableT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isVariable () const\t{ return m_kind == VariableT; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  void\n  Y2Namespace::popFromStack ()\n  {\n      for (unsigned int p = 0; p < m_symbolcount; p++)\n      {\n  \tif ( m_symbols[p] && m_symbols[p]->isVariable() )\n          {\n              m_symbols[p]->pop ();\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "pushToStack",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "254-264",
    "snippet": "void\nY2Namespace::pushToStack ()\n{\n    for (unsigned int p = 0; p < m_symbolcount; p++)\n    {\n\tif ( m_symbols[p] && m_symbols[p]->isVariable() )\n        {\n            m_symbols[p]->push ();\n        }\n    }\n}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_symbols[p]->push",
          "args": [],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "push",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "149-157",
          "snippet": "void\nSymbolEntry::push ()\n{\n    if (! m_recurse_stack)\n    {\n\tm_recurse_stack = new valuestack_t;\n    }\n    m_recurse_stack->push (m_value);\n}",
          "includes": [
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  void\n  SymbolEntry::push ()\n  {\n      if (! m_recurse_stack)\n      {\n  \tm_recurse_stack = new valuestack_t;\n      }\n      m_recurse_stack->push (m_value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_symbols[p]->isVariable",
          "args": [],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "isVariable",
          "container": "Type",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/Type.h",
          "lines": "298-298",
          "snippet": "bool isVariable () const\t{ return m_kind == VariableT; }",
          "includes": [
            "#include \"ycp/TypePtr.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/MemUsage.h>",
            "#include <vector>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/TypePtr.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/MemUsage.h>\n#include <vector>\n#include <iosfwd>\n\nType {\n  bool isVariable () const\t{ return m_kind == VariableT; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  void\n  Y2Namespace::pushToStack ()\n  {\n      for (unsigned int p = 0; p < m_symbolcount; p++)\n      {\n  \tif ( m_symbols[p] && m_symbols[p]->isVariable() )\n          {\n              m_symbols[p]->push ();\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "finish",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "205-251",
    "snippet": "void\nY2Namespace::finish ()\n{\n#if 0\n    // ATM, we only reorder sentries, so global ones are on top of the table\n    // it is important to allow a bytecode ignore changes in local symbols - the indexes for globals\n    // are not changed\n    if ( m_count == 0 ) return;\n    \n#if DO_DEBUG\n    y2debug (\"Going to reorder\");\n#endif\n\n    SymbolEntry** new_environment = (SymbolEntry **)calloc (sizeof (SymbolEntry *), m_count);\n\n    int next_index = 0;\n\n    // globals first\n    for (uint i = 0 ; i < m_count ; i++)\n    {\n\tif (m_senvironment[i]->isGlobal ())\n\t{\n\t    new_environment[next_index] = m_senvironment[i];\n\t    new_environment[next_index]->setPosition (next_index);\n\t    next_index++;\n\t}\n    }\n    \n    // then locals\n    for (uint i = 0 ; i < m_count ; i++)\n    {\n\tif (! m_senvironment[i]->isGlobal ())\n\t{\n\t    new_environment[next_index] = m_senvironment[i];\n\t    new_environment[next_index]->setPosition (next_index);\n\t    next_index++;\n\t}\n    }\n    free (m_senvironment);\n    m_senvironment = new_environment;\n#endif\n#if DO_DEBUG\n    y2debug (\"Reorder done\");\n#endif\n\n    return;\n}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Reorder done\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "m_senvironment"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_environment[next_index]->setPosition",
          "args": [
            "next_index"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "setPosition",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "96-101",
          "snippet": "void\nSymbolEntry::setPosition (unsigned int position)\n{\n    m_position = position;\n    return;\n}",
          "includes": [
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  void\n  SymbolEntry::setPosition (unsigned int position)\n  {\n      m_position = position;\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_senvironment[i]->isGlobal",
          "args": [],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "isGlobal",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "82-86",
          "snippet": "bool\nSymbolEntry::isGlobal () const\n{\n    return m_global;\n}",
          "includes": [
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  bool\n  SymbolEntry::isGlobal () const\n  {\n      return m_global;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "sizeof (SymbolEntry *)",
            "m_count"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Going to reorder\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\n#define DO_DEBUG 0\n\nY2Namespace {\n  void\n  Y2Namespace::finish ()\n  {\n  #if 0\n      // ATM, we only reorder sentries, so global ones are on top of the table\n      // it is important to allow a bytecode ignore changes in local symbols - the indexes for globals\n      // are not changed\n      if ( m_count == 0 ) return;\n      \n  #if DO_DEBUG\n      y2debug (\"Going to reorder\");\n  #endif\n  \n      SymbolEntry** new_environment = (SymbolEntry **)calloc (sizeof (SymbolEntry *), m_count);\n  \n      int next_index = 0;\n  \n      // globals first\n      for (uint i = 0 ; i < m_count ; i++)\n      {\n  \tif (m_senvironment[i]->isGlobal ())\n  \t{\n  \t    new_environment[next_index] = m_senvironment[i];\n  \t    new_environment[next_index]->setPosition (next_index);\n  \t    next_index++;\n  \t}\n      }\n      \n      // then locals\n      for (uint i = 0 ; i < m_count ; i++)\n      {\n  \tif (! m_senvironment[i]->isGlobal ())\n  \t{\n  \t    new_environment[next_index] = m_senvironment[i];\n  \t    new_environment[next_index]->setPosition (next_index);\n  \t    next_index++;\n  \t}\n      }\n      free (m_senvironment);\n      m_senvironment = new_environment;\n  #endif\n  #if DO_DEBUG\n      y2debug (\"Reorder done\");\n  #endif\n  \n      return;\n  }\n}"
  },
  {
    "function_name": "releaseSymbol",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "192-201",
    "snippet": "void\nY2Namespace::releaseSymbol (SymbolEntryPtr sentry)\n{\n    int p = findSymbol (sentry);\n    if (p >= 0)\n    {\n\treleaseSymbol (p);\n    }\n    return;\n}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "releaseSymbol",
          "args": [
            "p"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "releaseSymbol",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "192-201",
          "snippet": "void\nY2Namespace::releaseSymbol (SymbolEntryPtr sentry)\n{\n    int p = findSymbol (sentry);\n    if (p >= 0)\n    {\n\treleaseSymbol (p);\n    }\n    return;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "findSymbol",
          "args": [
            "sentry"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "findSymbol",
          "container": "Debugger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/debugger/Debugger.cc",
          "lines": "271-326",
          "snippet": "SymbolEntryPtr Debugger::findSymbol (std::string arg)\n{\n    std::vector<std::string> words;\n    SymbolEntryPtr sentry = NULL;\n\n    stringutil::split(arg, words, \":\");\n\n    if (words.size () > 1)\n    {\n\t// name contains namespace, handle here\n\tstd::string ns_name = words[0];\n\tstd::string name = words[1];\n\tY2Component* c = Y2ComponentBroker::getNamespaceComponent (ns_name.c_str());\n\tif( c )\n\t{\n\t    if (c->name () == \"wfm\")\n\t    {\n\t\tY2Namespace* ns = c->import (ns_name.c_str());\n\t\tif (ns) \n\t\t    // this returns NULL in case the name was not found\n\t\t    return ns->lookupSymbol (name.c_str());\n\t    }\n\t    else\n\t\treturn NULL; // this is not YCP symbol\n\t}\n    }\n    else \n    {\n\t// try parameters\n\tExecutionEnvironment::CallStack stack = ee.callstack();\n\t    \n\tif( stack.size() > 0 )\n\t{\n\t    ExecutionEnvironment::CallStack::const_reverse_iterator it = stack.rbegin();\n\t    \n    \t    YSymbolEntryPtr ysentry = (YSymbolEntryPtr)((*it)->function->entry());\n\n\t    // this returns NULL in case the name was not found\n\t    sentry = ((YFunctionPtr)ysentry->code())->declaration ()->lookupSymbol (words[0].c_str());\n\n\t    if (sentry)\n\t\treturn sentry;\n\t}\n\t    \n\t// try block stack\n\tfor( std::list<stackitem_t>::iterator blk = m_blockstack.begin(); blk != m_blockstack.end (); blk++)\n\t{\n\t    sentry = blk->ns->lookupSymbol (words[0].c_str());\n\t    if (sentry)\n\t\treturn sentry;\n\t}\n    }\n\n    // not found\n    return NULL;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"Debugger.h\"",
            "#include <y2util/stringutil.h>",
            "#include <ycp/Parser.h>",
            "#include <ycp/YBreakpoint.h>",
            "#include <ycp/YBlock.h>",
            "#include <ycp/ExecutionEnvironment.h>",
            "#include <ycp/y2log.h>",
            "#include <y2/Y2Namespace.h>",
            "#include <y2/Y2Component.h>",
            "#include <y2/Y2ComponentBroker.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ExecutionEnvironment ee;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"Debugger.h\"\n#include <y2util/stringutil.h>\n#include <ycp/Parser.h>\n#include <ycp/YBreakpoint.h>\n#include <ycp/YBlock.h>\n#include <ycp/ExecutionEnvironment.h>\n#include <ycp/y2log.h>\n#include <y2/Y2Namespace.h>\n#include <y2/Y2Component.h>\n#include <y2/Y2ComponentBroker.h>\n\nextern ExecutionEnvironment ee;\n\nDebugger {\n  SymbolEntryPtr Debugger::findSymbol (std::string arg)\n  {\n      std::vector<std::string> words;\n      SymbolEntryPtr sentry = NULL;\n  \n      stringutil::split(arg, words, \":\");\n  \n      if (words.size () > 1)\n      {\n  \t// name contains namespace, handle here\n  \tstd::string ns_name = words[0];\n  \tstd::string name = words[1];\n  \tY2Component* c = Y2ComponentBroker::getNamespaceComponent (ns_name.c_str());\n  \tif( c )\n  \t{\n  \t    if (c->name () == \"wfm\")\n  \t    {\n  \t\tY2Namespace* ns = c->import (ns_name.c_str());\n  \t\tif (ns) \n  \t\t    // this returns NULL in case the name was not found\n  \t\t    return ns->lookupSymbol (name.c_str());\n  \t    }\n  \t    else\n  \t\treturn NULL; // this is not YCP symbol\n  \t}\n      }\n      else \n      {\n  \t// try parameters\n  \tExecutionEnvironment::CallStack stack = ee.callstack();\n  \t    \n  \tif( stack.size() > 0 )\n  \t{\n  \t    ExecutionEnvironment::CallStack::const_reverse_iterator it = stack.rbegin();\n  \t    \n      \t    YSymbolEntryPtr ysentry = (YSymbolEntryPtr)((*it)->function->entry());\n  \n  \t    // this returns NULL in case the name was not found\n  \t    sentry = ((YFunctionPtr)ysentry->code())->declaration ()->lookupSymbol (words[0].c_str());\n  \n  \t    if (sentry)\n  \t\treturn sentry;\n  \t}\n  \t    \n  \t// try block stack\n  \tfor( std::list<stackitem_t>::iterator blk = m_blockstack.begin(); blk != m_blockstack.end (); blk++)\n  \t{\n  \t    sentry = blk->ns->lookupSymbol (words[0].c_str());\n  \t    if (sentry)\n  \t\treturn sentry;\n  \t}\n      }\n  \n      // not found\n      return NULL;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  void\n  Y2Namespace::releaseSymbol (SymbolEntryPtr sentry)\n  {\n      int p = findSymbol (sentry);\n      if (p >= 0)\n      {\n  \treleaseSymbol (p);\n      }\n      return;\n  }\n}"
  },
  {
    "function_name": "releaseSymbol",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "180-188",
    "snippet": "void\nY2Namespace::releaseSymbol (unsigned int position)\n{\n    if (position < m_symbolcount)\n    {\n\tm_symbols[position]->setNamespace (0);\n\tm_symbols[position] = 0;\n    }\n}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_symbols[position]->setNamespace",
          "args": [
            "0"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "setNamespace",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/SymbolEntry.cc",
          "lines": "75-79",
          "snippet": "void\nSymbolEntry::setNamespace (const Y2Namespace *name_space)\n{\n    m_namespace = name_space;\n}",
          "includes": [
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"y2/SymbolEntry.h\"",
            "#include \"ycp/y2log.h\"",
            "#include <string>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"y2/SymbolEntry.h\"\n#include \"ycp/y2log.h\"\n#include <string>\n#include <stdio.h>\n\nSymbolEntry {\n  void\n  SymbolEntry::setNamespace (const Y2Namespace *name_space)\n  {\n      m_namespace = name_space;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  void\n  Y2Namespace::releaseSymbol (unsigned int position)\n  {\n      if (position < m_symbolcount)\n      {\n  \tm_symbols[position]->setNamespace (0);\n  \tm_symbols[position] = 0;\n      }\n  }\n}"
  },
  {
    "function_name": "enterSymbol",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "165-177",
    "snippet": "void\nY2Namespace::enterSymbol (SymbolEntryPtr sentry, Point *point )\n{\n    addSymbol (sentry);\n    if (m_table == 0)\n    {\n\tm_table = new SymbolTable (-1);\n    }\n\n    m_table->enter (sentry->name(), sentry, point);\n\n    return;\n}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_table->enter",
          "args": [
            "sentry->name()",
            "sentry",
            "point"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sentry->name",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "62-66",
          "snippet": "const string\nY2Namespace::name () const\n{\n    return \"\";\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  const string\n  Y2Namespace::name () const\n  {\n      return \"\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addSymbol",
          "args": [
            "sentry"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "addSymbol",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "133-141",
          "snippet": "unsigned int\nY2Namespace::addSymbol (SymbolEntryPtr sentry)\n{\n#if DO_DEBUG\n    y2debug (\"addSymbol #%d:'%s'\", m_symbolcount, sentry->toString().c_str());\n#endif\n    m_symbols.push_back(sentry);\n    return m_symbolcount++;\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\n#define DO_DEBUG 0\n\nY2Namespace {\n  unsigned int\n  Y2Namespace::addSymbol (SymbolEntryPtr sentry)\n  {\n  #if DO_DEBUG\n      y2debug (\"addSymbol #%d:'%s'\", m_symbolcount, sentry->toString().c_str());\n  #endif\n      m_symbols.push_back(sentry);\n      return m_symbolcount++;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  void\n  Y2Namespace::enterSymbol (SymbolEntryPtr sentry, Point *point )\n  {\n      addSymbol (sentry);\n      if (m_table == 0)\n      {\n  \tm_table = new SymbolTable (-1);\n      }\n  \n      m_table->enter (sentry->name(), sentry, point);\n  \n      return;\n  }\n}"
  },
  {
    "function_name": "lookupSymbol",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "145-158",
    "snippet": "SymbolEntryPtr\nY2Namespace::lookupSymbol (const char *name) const\n{\n    for (unsigned int p = 0; p < m_symbolcount; p++)\n    {\n\tif ( m_symbols[p] && (strcmp (m_symbols[p]->name(), name) == 0)\n            && !m_symbols[p]->likeNamespace())\t\t\t// allow symbol if namespace of same name already declared\n        {\n            return m_symbols[p];\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_symbols[p]->likeNamespace",
          "args": [],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "likeNamespace",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/include/y2/SymbolEntry.h",
          "lines": "140-140",
          "snippet": "bool likeNamespace () const { return isModule() || isNamespace() || isSelf(); }",
          "includes": [
            "#include <stack>",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/RepDef.h>",
            "#include <y2util/Ustring.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stack>\n#include \"ycp/Type.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/RepDef.h>\n#include <y2util/Ustring.h>\n\nSymbolEntry {\n  bool likeNamespace () const { return isModule() || isNamespace() || isSelf(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "m_symbols[p]->name()",
            "name"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_symbols[p]->name",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "62-66",
          "snippet": "const string\nY2Namespace::name () const\n{\n    return \"\";\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  const string\n  Y2Namespace::name () const\n  {\n      return \"\";\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  SymbolEntryPtr\n  Y2Namespace::lookupSymbol (const char *name) const\n  {\n      for (unsigned int p = 0; p < m_symbolcount; p++)\n      {\n  \tif ( m_symbols[p] && (strcmp (m_symbols[p]->name(), name) == 0)\n              && !m_symbols[p]->likeNamespace())\t\t\t// allow symbol if namespace of same name already declared\n          {\n              return m_symbols[p];\n          }\n      }\n  \n      return 0;\n  }\n}"
  },
  {
    "function_name": "addSymbol",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "133-141",
    "snippet": "unsigned int\nY2Namespace::addSymbol (SymbolEntryPtr sentry)\n{\n#if DO_DEBUG\n    y2debug (\"addSymbol #%d:'%s'\", m_symbolcount, sentry->toString().c_str());\n#endif\n    m_symbols.push_back(sentry);\n    return m_symbolcount++;\n}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_symbols.push_back",
          "args": [
            "sentry"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "push_back",
          "container": "YCPListRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPList.cc",
          "lines": "70-74",
          "snippet": "void\nYCPListRep::push_back(const YCPValue& value)\n{\n    elements.push_back(value);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/YCPCodeCompare.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include <algorithm>",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"YCP.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/YCPCodeCompare.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include <algorithm>\n#include \"ycp/YCPList.h\"\n#include \"ycp/y2log.h\"\n#include \"YCP.h\"\n\nYCPListRep {\n  void\n  YCPListRep::push_back(const YCPValue& value)\n  {\n      elements.push_back(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"addSymbol #%d:'%s'\"",
            "m_symbolcount",
            "sentry->toString().c_str()"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sentry->toString",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "76-88",
          "snippet": "string\nY2Namespace::toString () const\n{\n    if (m_table == 0)\n    {\n\treturn \"<empty>\";\n    }\n\n    SymbolTable* t = m_table;\n    string s = t->toString ();\n\n    return s + symbolsToString ();\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  string\n  Y2Namespace::toString () const\n  {\n      if (m_table == 0)\n      {\n  \treturn \"<empty>\";\n      }\n  \n      SymbolTable* t = m_table;\n      string s = t->toString ();\n  \n      return s + symbolsToString ();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\n#define DO_DEBUG 0\n\nY2Namespace {\n  unsigned int\n  Y2Namespace::addSymbol (SymbolEntryPtr sentry)\n  {\n  #if DO_DEBUG\n      y2debug (\"addSymbol #%d:'%s'\", m_symbolcount, sentry->toString().c_str());\n  #endif\n      m_symbols.push_back(sentry);\n      return m_symbolcount++;\n  }\n}"
  },
  {
    "function_name": "symbolEntry",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "118-126",
    "snippet": "SymbolEntryPtr \nY2Namespace::symbolEntry (unsigned int position) const\n{\n    if (position >= m_symbolcount)\n    {\n\treturn 0;\n    }\n    return m_symbols[position];\n}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  SymbolEntryPtr \n  Y2Namespace::symbolEntry (unsigned int position) const\n  {\n      if (position >= m_symbolcount)\n      {\n  \treturn 0;\n      }\n      return m_symbols[position];\n  }\n}"
  },
  {
    "function_name": "symbolsToString",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "91-115",
    "snippet": "string\nY2Namespace::symbolsToString () const\n{\n    string s;\n\n    symbols_t::const_iterator it;\n    for (unsigned int p = 0; p < m_symbolcount; p++)\n    {\n\tif ( m_symbols[p] )\n\t{\n\t    if (!m_symbols[p]->isFilename ())\n\t    {\n\t\ts += \"\\n    // \";\n\t\ts += m_symbols[p]->toString();\n\t    }\n\t}\n\telse\n\t{\n\t    s += \"\\n    // \";\n\t    s += \"<released>\";\n\t}\n    }\n\n    return s;\n}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_symbols[p]->toString",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "76-88",
          "snippet": "string\nY2Namespace::toString () const\n{\n    if (m_table == 0)\n    {\n\treturn \"<empty>\";\n    }\n\n    SymbolTable* t = m_table;\n    string s = t->toString ();\n\n    return s + symbolsToString ();\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  string\n  Y2Namespace::toString () const\n  {\n      if (m_table == 0)\n      {\n  \treturn \"<empty>\";\n      }\n  \n      SymbolTable* t = m_table;\n      string s = t->toString ();\n  \n      return s + symbolsToString ();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_symbols[p]->isFilename",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "isFilename",
          "container": "SymbolEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/include/y2/SymbolEntry.h",
          "lines": "137-137",
          "snippet": "bool isFilename () const { return m_category == c_filename; }",
          "includes": [
            "#include <stack>",
            "#include \"ycp/Type.h\"",
            "#include \"ycp/YCPValue.h\"",
            "#include <y2util/RepDef.h>",
            "#include <y2util/Ustring.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stack>\n#include \"ycp/Type.h\"\n#include \"ycp/YCPValue.h\"\n#include <y2util/RepDef.h>\n#include <y2util/Ustring.h>\n\nSymbolEntry {\n  bool isFilename () const { return m_category == c_filename; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  string\n  Y2Namespace::symbolsToString () const\n  {\n      string s;\n  \n      symbols_t::const_iterator it;\n      for (unsigned int p = 0; p < m_symbolcount; p++)\n      {\n  \tif ( m_symbols[p] )\n  \t{\n  \t    if (!m_symbols[p]->isFilename ())\n  \t    {\n  \t\ts += \"\\n    // \";\n  \t\ts += m_symbols[p]->toString();\n  \t    }\n  \t}\n  \telse\n  \t{\n  \t    s += \"\\n    // \";\n  \t    s += \"<released>\";\n  \t}\n      }\n  \n      return s;\n  }\n}"
  },
  {
    "function_name": "toString",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "76-88",
    "snippet": "string\nY2Namespace::toString () const\n{\n    if (m_table == 0)\n    {\n\treturn \"<empty>\";\n    }\n\n    SymbolTable* t = m_table;\n    string s = t->toString ();\n\n    return s + symbolsToString ();\n}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "symbolsToString",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "symbolsToString",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "91-115",
          "snippet": "string\nY2Namespace::symbolsToString () const\n{\n    string s;\n\n    symbols_t::const_iterator it;\n    for (unsigned int p = 0; p < m_symbolcount; p++)\n    {\n\tif ( m_symbols[p] )\n\t{\n\t    if (!m_symbols[p]->isFilename ())\n\t    {\n\t\ts += \"\\n    // \";\n\t\ts += m_symbols[p]->toString();\n\t    }\n\t}\n\telse\n\t{\n\t    s += \"\\n    // \";\n\t    s += \"<released>\";\n\t}\n    }\n\n    return s;\n}",
          "includes": [
            "#include \"SymbolEntry.h\"",
            "#include \"Y2Function.h\"",
            "#include \"Y2Namespace.h\"",
            "#include <ycp/SymbolTable.h>",
            "#include <y2util/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  string\n  Y2Namespace::symbolsToString () const\n  {\n      string s;\n  \n      symbols_t::const_iterator it;\n      for (unsigned int p = 0; p < m_symbolcount; p++)\n      {\n  \tif ( m_symbols[p] )\n  \t{\n  \t    if (!m_symbols[p]->isFilename ())\n  \t    {\n  \t\ts += \"\\n    // \";\n  \t\ts += m_symbols[p]->toString();\n  \t    }\n  \t}\n  \telse\n  \t{\n  \t    s += \"\\n    // \";\n  \t    s += \"<released>\";\n  \t}\n      }\n  \n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->toString",
          "args": [],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "Y2Namespace",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
          "lines": "76-88",
          "snippet": "string\nY2Namespace::toString () const\n{\n    if (m_table == 0)\n    {\n\treturn \"<empty>\";\n    }\n\n    SymbolTable* t = m_table;\n    string s = t->toString ();\n\n    return s + symbolsToString ();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  string\n  Y2Namespace::toString () const\n  {\n      if (m_table == 0)\n      {\n  \treturn \"<empty>\";\n      }\n  \n      SymbolTable* t = m_table;\n      string s = t->toString ();\n  \n      return s + symbolsToString ();\n  }\n}"
  },
  {
    "function_name": "symbolCount",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "69-73",
    "snippet": "unsigned int\nY2Namespace::symbolCount () const\n{\n    return m_symbols.size();\n}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_symbols.size",
          "args": [],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  unsigned int\n  Y2Namespace::symbolCount () const\n  {\n      return m_symbols.size();\n  }\n}"
  },
  {
    "function_name": "name",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "62-66",
    "snippet": "const string\nY2Namespace::name () const\n{\n    return \"\";\n}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  const string\n  Y2Namespace::name () const\n  {\n      return \"\";\n  }\n}"
  },
  {
    "function_name": "~Y2Namespace",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "44-59",
    "snippet": "Y2Namespace::~Y2Namespace ()\n{\n#if DO_DEBUG\n    y2debug (\"Y2Namespace::~Y2Namespace [%p]\", this);\n#endif\n    if (m_table)\n    {\n\t// reset namespace of the symbol\n\tsymbols_t::const_iterator it;\n\tfor (it = m_symbols.begin(); it != m_symbols.end(); it++)\n\t{\n\t    (*it)->setNamespace(0);\n\t}\n\tdelete m_table;\n    }\n}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [
      "#define DO_DEBUG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "0"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_symbols.end",
          "args": [],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_symbols.begin",
          "args": [],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Y2Namespace::~Y2Namespace [%p]\"",
            "this"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\n#define DO_DEBUG 0\n\nY2Namespace {\n  Y2Namespace::~Y2Namespace ()\n  {\n  #if DO_DEBUG\n      y2debug (\"Y2Namespace::~Y2Namespace [%p]\", this);\n  #endif\n      if (m_table)\n      {\n  \t// reset namespace of the symbol\n  \tsymbols_t::const_iterator it;\n  \tfor (it = m_symbols.begin(); it != m_symbols.end(); it++)\n  \t{\n  \t    (*it)->setNamespace(0);\n  \t}\n  \tdelete m_table;\n      }\n  }\n}"
  },
  {
    "function_name": "Y2Namespace",
    "container": "Y2Namespace",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2Namespace.cc",
    "lines": "37-41",
    "snippet": "Y2Namespace::Y2Namespace ()\n    : m_table (0)\n    , m_symbolcount (0)\n    , m_initialized (false)\n{}",
    "includes": [
      "#include \"SymbolEntry.h\"",
      "#include \"Y2Function.h\"",
      "#include \"Y2Namespace.h\"",
      "#include <ycp/SymbolTable.h>",
      "#include <y2util/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"SymbolEntry.h\"\n#include \"Y2Function.h\"\n#include \"Y2Namespace.h\"\n#include <ycp/SymbolTable.h>\n#include <y2util/y2log.h>\n\nY2Namespace {\n  Y2Namespace::Y2Namespace ()\n      : m_table (0)\n      , m_symbolcount (0)\n      , m_initialized (false)\n  {}\n}"
  }
]