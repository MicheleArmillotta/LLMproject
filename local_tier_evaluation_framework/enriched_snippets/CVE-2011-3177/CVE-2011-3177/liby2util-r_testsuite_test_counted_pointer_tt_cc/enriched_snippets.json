[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "450-488",
    "snippet": "int main( int argc, const char * argv[] ) {\n  set_log_filename(\"-\");\n  SEC << \"START\" << endl;\n\n#define SZ(T) MIL << #T << \" \" << sizeof( T ) << endl\n  SZ( SLVPtr );\n  SZ( constSLVPtr );\n  SZ( OBJPtr );\n  SZ( constOBJPtr );\n  SZ( PKGPtr );\n  SZ( constPKGPtr );\n\n  bool do_test            = false;\n  bool do_genTestSrc      = false;\n  bool do_checkTestResult = false;\n\n  if ( argc <= 1 ) {\n    do_test = true;\n  } else {\n    for( int i = 1; i < argc; ++i ) {\n      if ( string(argv[i]) == \"gen\" ) {\n\tdo_genTestSrc = true;\n      } else if ( string(argv[i]) == \"check\" ) {\n\tdo_checkTestResult = true;\n      }\n    }\n  }\n\n  if ( do_genTestSrc )\n    genTestSrc();\n  if ( do_checkTestResult )\n    checkTestResult();\n\n  if ( do_test )\n    test();\n\n  SEC << \"STOP\" << endl;\n  return 0;\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test",
          "args": [],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "443-448",
          "snippet": "void test() {\n\n  OBJPtr a;\n  constSLVPtr b( a );\n\n}",
          "includes": [
            "#include \"PtrHier.h\"",
            "#include <y2util/PathInfo.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <string>",
            "#include <list>",
            "#include <map>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nvoid test() {\n\n  OBJPtr a;\n  constSLVPtr b( a );\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkTestResult",
          "args": [],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "checkTestResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "436-439",
          "snippet": "void checkTestResult() {\n  Pathname root( \"test\" );\n  subTestResult( root /*+ \"construct_via_assign\"*/ );\n}",
          "includes": [
            "#include \"PtrHier.h\"",
            "#include <y2util/PathInfo.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <string>",
            "#include <list>",
            "#include <map>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nvoid checkTestResult() {\n  Pathname root( \"test\" );\n  subTestResult( root /*+ \"construct_via_assign\"*/ );\n}"
        }
      },
      {
        "call_info": {
          "callee": "genTestSrc",
          "args": [],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "genTestSrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "317-321",
          "snippet": "void genTestSrc() {\n  genTestSrc( \"SLV\", \"SLV\" );\n  genTestSrc( \"OBJ\", \"PKG\" );\n  genTestSrc( \"PKG\", \"OBJ\" );\n}",
          "includes": [
            "#include \"PtrHier.h\"",
            "#include <y2util/PathInfo.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <string>",
            "#include <list>",
            "#include <map>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nvoid genTestSrc() {\n  genTestSrc( \"SLV\", \"SLV\" );\n  genTestSrc( \"OBJ\", \"PKG\" );\n  genTestSrc( \"PKG\", \"OBJ\" );\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "argv[i]"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniFile.cc",
          "lines": "29-37",
          "snippet": "string to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}",
          "includes": [
            "#include \"IniParser.h\"",
            "#include \"IniFile.h\"",
            "#include <cassert>",
            "#include <set>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniParser.h\"\n#include \"IniFile.h\"\n#include <cassert>\n#include <set>\n#include <ctype.h>\n#include <stdio.h>\n#include <ycp/y2log.h>\n\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SZ",
          "args": [
            "constPKGPtr"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SZ",
          "args": [
            "PKGPtr"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SZ",
          "args": [
            "constOBJPtr"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SZ",
          "args": [
            "OBJPtr"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SZ",
          "args": [
            "constSLVPtr"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SZ",
          "args": [
            "SLVPtr"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_log_filename",
          "args": [
            "\"-\""
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "set_log_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/y2changes.cc",
          "lines": "188-240",
          "snippet": "static void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2CHANGES_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2CHANGES_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2CHANGES_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2CHANGES_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2CHANGES_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2CHANGES_FALLBACK );\n\n\t\tlogname = Y2CHANGES_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2CHANGES_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2CHANGES_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2CHANGES_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}",
          "includes": [
            "#include <syslog.h>",
            "#include \"y2util/PathInfo.h\"",
            "#include \"y2util/stringutil.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include <list>",
            "#include <limits>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <malloc.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define Y2CHANGES_VAR_NUM\t\"Y2MAXLOGNUM\"",
            "#define Y2CHANGES_VAR_SIZE\t\"Y2MAXLOGSIZE\"",
            "#define Y2CHANGES_FALLBACK\t\"/y2changes\"",
            "#define Y2CHANGES_USER\t\"/.y2changes\"\t\t/* Relative to $HOME */",
            "#define Y2CHANGES_ROOT\tLOGDIR \"/y2changes\"",
            "#define Y2CHANGES_MAXNUM\t10\t\t\t/* Maximum logfiles number */",
            "#define Y2CHANGES_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */"
          ],
          "globals_used": [
            "static bool did_set_logname = false;",
            "static const char *logname;",
            "static off_t maxlogsize;",
            "static int   maxlognum;",
            "static bool log_to_file = true;",
            "static bool log_to_syslog = false;",
            "static FILE *Y2CHANGES_STDERR = stderr;",
            "static void shift_log_files(string filename);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syslog.h>\n#include \"y2util/PathInfo.h\"\n#include \"y2util/stringutil.h\"\n#include \"y2util/y2changes.h\"\n#include <list>\n#include <limits>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <malloc.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define Y2CHANGES_VAR_NUM\t\"Y2MAXLOGNUM\"\n#define Y2CHANGES_VAR_SIZE\t\"Y2MAXLOGSIZE\"\n#define Y2CHANGES_FALLBACK\t\"/y2changes\"\n#define Y2CHANGES_USER\t\"/.y2changes\"\t\t/* Relative to $HOME */\n#define Y2CHANGES_ROOT\tLOGDIR \"/y2changes\"\n#define Y2CHANGES_MAXNUM\t10\t\t\t/* Maximum logfiles number */\n#define Y2CHANGES_MAXSIZE\t10* 1024 * 1024\t\t/* Maximal logfile size */\n\nstatic bool did_set_logname = false;\nstatic const char *logname;\nstatic off_t maxlogsize;\nstatic int   maxlognum;\nstatic bool log_to_file = true;\nstatic bool log_to_syslog = false;\nstatic FILE *Y2CHANGES_STDERR = stderr;\nstatic void shift_log_files(string filename);\n\nstatic void set_log_filename (string fname)\n{\n    did_set_logname = true;\n\n    if(log_to_syslog) openlog(\"yast2\", LOG_PID, LOG_DAEMON);\n    if(!log_to_file) return;\n\n    struct passwd *pw = getpwuid( geteuid() );\n    const char *filename = fname.c_str();\n\n    char *env_maxlogsize = getenv(Y2CHANGES_VAR_SIZE);\n    if ( env_maxlogsize ) {\n      stringutil::strtonum( env_maxlogsize, maxlogsize );\n      // prevent overflow (#156149)\n      const off_t limit = std::numeric_limits<off_t>::max();\n      const off_t limit_k = limit / 1024;\n      if (maxlogsize <= limit_k)\n\t  maxlogsize *= 1024;\n      else\n\t  maxlogsize = limit;\n    } else \n      maxlogsize = Y2CHANGES_MAXSIZE;\n\n    char *env_maxlognum = getenv(Y2CHANGES_VAR_NUM);\n    maxlognum = env_maxlognum ? atoi(env_maxlognum) : Y2CHANGES_MAXNUM;\n\n    /* Assign logfile name */\n\n    if ((filename == 0) || (*filename == 0))\n    {\t\t/* No filename --> use defaults */\n\tif (geteuid()) {\t\t\t/* Non root */\n\t    if (!pw)\n\t    {\n\t\tfprintf( Y2CHANGES_STDERR,\n\t\t\t \"Cannot read pwd entry of user id %d. Logfile will be '%s'.\\n\",\n\t\t\t geteuid(), Y2CHANGES_FALLBACK );\n\n\t\tlogname = Y2CHANGES_FALLBACK;\n\t    }\n\t    else\n\t    {\n\t\t// never freed\n\t\tchar * my_logname = (char *)malloc (strlen (pw->pw_dir) + strlen (Y2CHANGES_USER) + 1);\n\t\tstrcpy (my_logname, pw->pw_dir);\n\t\tlogname = strcat (my_logname, Y2CHANGES_USER);\n\t    }\n\t}\n\telse\t\t    /* Root */\n\t    logname = Y2CHANGES_ROOT;\n    }\n    else\n\tlogname = strdup (filename);  /* Explicit assignment */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nint main( int argc, const char * argv[] ) {\n  set_log_filename(\"-\");\n  SEC << \"START\" << endl;\n\n#define SZ(T) MIL << #T << \" \" << sizeof( T ) << endl\n  SZ( SLVPtr );\n  SZ( constSLVPtr );\n  SZ( OBJPtr );\n  SZ( constOBJPtr );\n  SZ( PKGPtr );\n  SZ( constPKGPtr );\n\n  bool do_test            = false;\n  bool do_genTestSrc      = false;\n  bool do_checkTestResult = false;\n\n  if ( argc <= 1 ) {\n    do_test = true;\n  } else {\n    for( int i = 1; i < argc; ++i ) {\n      if ( string(argv[i]) == \"gen\" ) {\n\tdo_genTestSrc = true;\n      } else if ( string(argv[i]) == \"check\" ) {\n\tdo_checkTestResult = true;\n      }\n    }\n  }\n\n  if ( do_genTestSrc )\n    genTestSrc();\n  if ( do_checkTestResult )\n    checkTestResult();\n\n  if ( do_test )\n    test();\n\n  SEC << \"STOP\" << endl;\n  return 0;\n}"
  },
  {
    "function_name": "test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "443-448",
    "snippet": "void test() {\n\n  OBJPtr a;\n  constSLVPtr b( a );\n\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nvoid test() {\n\n  OBJPtr a;\n  constSLVPtr b( a );\n\n}"
  },
  {
    "function_name": "checkTestResult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "436-439",
    "snippet": "void checkTestResult() {\n  Pathname root( \"test\" );\n  subTestResult( root /*+ \"construct_via_assign\"*/ );\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "subTestResult",
          "args": [
            "root/*+ \"construct_via_assign\"*/"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "subTestResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "335-434",
          "snippet": "void subTestResult( const Pathname & path ) {\n  list<string> retlist;\n  int res = PathInfo::readdir( retlist, path, false );\n  if ( res ) {\n    ERR << \"Error reading content of \" << path << \" (readdir \" << res << \")\" << endl;\n    return;\n  }\n  map<string,Pathname> flst;\n  for ( list<string>::const_iterator it = retlist.begin(); it != retlist.end(); ++it ) {\n    PathInfo cpath( path + *it );\n    if ( cpath.isFile() ) {\n      if ( cpath.path().asString().find( \".testgpp\" ) != string::npos ) {\n\tflst[*it] = ( cpath.size() ? cpath.path() : Pathname() );\n      }\n    } else if ( cpath.isDir() ) {\n      subTestResult( cpath.path() );\n    }\n  }\n\n  if ( ! flst.empty() ) {\n    if ( flst.size() != CASEES ) {\n      INT << \"NOT \" << CASEES << \": \" << flst.size() << \": \" << path << endl;\n    }\n    namesplit spl( path.asString() );\n    vector<pair<Pathname,namesplit> > cases;\n    cases.resize( CASEES );\n    off_t casetag = -1;\n    bool caseok  = true;\n    for ( map<string,Pathname>::const_iterator it = flst.begin(); it != flst.end(); ++it ) {\n      namesplit sp( it->first );\n      if ( casetag == -1 ) {\n\tcasetag = it->second.empty();\n      }\n      if ( bool(casetag) != it->second.empty() ) {\n\tcaseok = false;\n      }\n      unsigned idx = CASEES;\n      if ( sp.tp == sp.fp ) {\n\tidx = ( sp.tp ? 2 : 0 );\n      } else {\n\tidx = ( sp.tp ? 3 : 1 ); // 3 must not occur\n\tif ( idx >= CASEES ) {\n\t  INT << \"Case idx \" << idx << \" must not occur!\" << endl;\n\t}\n      }\n      cases[idx] = pair<Pathname,namesplit>( it->second, sp );\n    }\n\n    if ( caseok ) {\n      MIL << stringutil::form( \"%s: %-20s from %-20s -> %s\"\n\t\t\t       , spl.func.c_str()\n\t\t\t       , spl.type.c_str()\n\t\t\t       , spl.from.c_str()\n\t\t\t       , (casetag?\"good\":\"fail\") ) << endl;\n      if ( casetag ) {\n\tfor( unsigned i = 0; i < CASEES; ++i ) {\n\t  Pathname ff( path );\n\t  string nn( cases[i].second.splitfrom );\n\t  nn.replace( nn.end()-3, nn.end(), \"run\" );\n\t  ff += nn;\n\t  SEC << stringutil::form( \"%s: %-20s from %-20s < %s\"\n\t\t\t\t   , cases[i].second.func.c_str()\n\t\t\t\t   , cases[i].second.type.c_str()\n\t\t\t\t   , cases[i].second.from.c_str()\n\t\t\t\t   , ff.basename().c_str() ) << endl;\n\t DumpOn( SEC, ff );\n\t}\n      }\n    } else {\n      ERR << stringutil::form( \"%s: %-20s from %-20s\"\n\t\t\t       , spl.func.c_str()\n\t\t\t       , spl.type.c_str()\n\t\t\t       , spl.from.c_str() ) << endl;\n      for( unsigned i = 0; i < CASEES; ++i ) {\n\tWAR << stringutil::form( \"    %s: %-20s from %-20s\",\n\t\t\t\t (cases[i].first.empty()?\"good\":\"fail\"),\n\t\t\t\t cases[i].second.type.c_str(),\n\t\t\t\t cases[i].second.from.c_str() ) << endl;\n      }\n      for( unsigned i = 0; i < CASEES; ++i ) {\n\tif ( ! cases[i].first.empty() ) {\n\t  PathInfo pi( cases[i].first );\n\t  DBG << pi << endl;\n\t  DumpOn( DBG, pi.path() );\n\t} else {\n\t  Pathname ff( path );\n\t  string nn( cases[i].second.splitfrom );\n\t  nn.replace( nn.end()-3, nn.end(), \"run\" );\n\t  ff += nn;\n\t  SEC << stringutil::form( \"%s: %-20s from %-20s < %s\"\n\t\t\t\t   , cases[i].second.func.c_str()\n\t\t\t\t   , cases[i].second.type.c_str()\n\t\t\t\t   , cases[i].second.from.c_str()\n\t\t\t\t   , ff.basename().c_str() ) << endl;\n\t DumpOn( SEC, ff );\n\t}\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"PtrHier.h\"",
            "#include <y2util/PathInfo.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <string>",
            "#include <list>",
            "#include <map>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [
            "#define CASEES 3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\n#define CASEES 3\n\nvoid subTestResult( const Pathname & path ) {\n  list<string> retlist;\n  int res = PathInfo::readdir( retlist, path, false );\n  if ( res ) {\n    ERR << \"Error reading content of \" << path << \" (readdir \" << res << \")\" << endl;\n    return;\n  }\n  map<string,Pathname> flst;\n  for ( list<string>::const_iterator it = retlist.begin(); it != retlist.end(); ++it ) {\n    PathInfo cpath( path + *it );\n    if ( cpath.isFile() ) {\n      if ( cpath.path().asString().find( \".testgpp\" ) != string::npos ) {\n\tflst[*it] = ( cpath.size() ? cpath.path() : Pathname() );\n      }\n    } else if ( cpath.isDir() ) {\n      subTestResult( cpath.path() );\n    }\n  }\n\n  if ( ! flst.empty() ) {\n    if ( flst.size() != CASEES ) {\n      INT << \"NOT \" << CASEES << \": \" << flst.size() << \": \" << path << endl;\n    }\n    namesplit spl( path.asString() );\n    vector<pair<Pathname,namesplit> > cases;\n    cases.resize( CASEES );\n    off_t casetag = -1;\n    bool caseok  = true;\n    for ( map<string,Pathname>::const_iterator it = flst.begin(); it != flst.end(); ++it ) {\n      namesplit sp( it->first );\n      if ( casetag == -1 ) {\n\tcasetag = it->second.empty();\n      }\n      if ( bool(casetag) != it->second.empty() ) {\n\tcaseok = false;\n      }\n      unsigned idx = CASEES;\n      if ( sp.tp == sp.fp ) {\n\tidx = ( sp.tp ? 2 : 0 );\n      } else {\n\tidx = ( sp.tp ? 3 : 1 ); // 3 must not occur\n\tif ( idx >= CASEES ) {\n\t  INT << \"Case idx \" << idx << \" must not occur!\" << endl;\n\t}\n      }\n      cases[idx] = pair<Pathname,namesplit>( it->second, sp );\n    }\n\n    if ( caseok ) {\n      MIL << stringutil::form( \"%s: %-20s from %-20s -> %s\"\n\t\t\t       , spl.func.c_str()\n\t\t\t       , spl.type.c_str()\n\t\t\t       , spl.from.c_str()\n\t\t\t       , (casetag?\"good\":\"fail\") ) << endl;\n      if ( casetag ) {\n\tfor( unsigned i = 0; i < CASEES; ++i ) {\n\t  Pathname ff( path );\n\t  string nn( cases[i].second.splitfrom );\n\t  nn.replace( nn.end()-3, nn.end(), \"run\" );\n\t  ff += nn;\n\t  SEC << stringutil::form( \"%s: %-20s from %-20s < %s\"\n\t\t\t\t   , cases[i].second.func.c_str()\n\t\t\t\t   , cases[i].second.type.c_str()\n\t\t\t\t   , cases[i].second.from.c_str()\n\t\t\t\t   , ff.basename().c_str() ) << endl;\n\t DumpOn( SEC, ff );\n\t}\n      }\n    } else {\n      ERR << stringutil::form( \"%s: %-20s from %-20s\"\n\t\t\t       , spl.func.c_str()\n\t\t\t       , spl.type.c_str()\n\t\t\t       , spl.from.c_str() ) << endl;\n      for( unsigned i = 0; i < CASEES; ++i ) {\n\tWAR << stringutil::form( \"    %s: %-20s from %-20s\",\n\t\t\t\t (cases[i].first.empty()?\"good\":\"fail\"),\n\t\t\t\t cases[i].second.type.c_str(),\n\t\t\t\t cases[i].second.from.c_str() ) << endl;\n      }\n      for( unsigned i = 0; i < CASEES; ++i ) {\n\tif ( ! cases[i].first.empty() ) {\n\t  PathInfo pi( cases[i].first );\n\t  DBG << pi << endl;\n\t  DumpOn( DBG, pi.path() );\n\t} else {\n\t  Pathname ff( path );\n\t  string nn( cases[i].second.splitfrom );\n\t  nn.replace( nn.end()-3, nn.end(), \"run\" );\n\t  ff += nn;\n\t  SEC << stringutil::form( \"%s: %-20s from %-20s < %s\"\n\t\t\t\t   , cases[i].second.func.c_str()\n\t\t\t\t   , cases[i].second.type.c_str()\n\t\t\t\t   , cases[i].second.from.c_str()\n\t\t\t\t   , ff.basename().c_str() ) << endl;\n\t DumpOn( SEC, ff );\n\t}\n      }\n    }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nvoid checkTestResult() {\n  Pathname root( \"test\" );\n  subTestResult( root /*+ \"construct_via_assign\"*/ );\n}"
  },
  {
    "function_name": "subTestResult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "335-434",
    "snippet": "void subTestResult( const Pathname & path ) {\n  list<string> retlist;\n  int res = PathInfo::readdir( retlist, path, false );\n  if ( res ) {\n    ERR << \"Error reading content of \" << path << \" (readdir \" << res << \")\" << endl;\n    return;\n  }\n  map<string,Pathname> flst;\n  for ( list<string>::const_iterator it = retlist.begin(); it != retlist.end(); ++it ) {\n    PathInfo cpath( path + *it );\n    if ( cpath.isFile() ) {\n      if ( cpath.path().asString().find( \".testgpp\" ) != string::npos ) {\n\tflst[*it] = ( cpath.size() ? cpath.path() : Pathname() );\n      }\n    } else if ( cpath.isDir() ) {\n      subTestResult( cpath.path() );\n    }\n  }\n\n  if ( ! flst.empty() ) {\n    if ( flst.size() != CASEES ) {\n      INT << \"NOT \" << CASEES << \": \" << flst.size() << \": \" << path << endl;\n    }\n    namesplit spl( path.asString() );\n    vector<pair<Pathname,namesplit> > cases;\n    cases.resize( CASEES );\n    off_t casetag = -1;\n    bool caseok  = true;\n    for ( map<string,Pathname>::const_iterator it = flst.begin(); it != flst.end(); ++it ) {\n      namesplit sp( it->first );\n      if ( casetag == -1 ) {\n\tcasetag = it->second.empty();\n      }\n      if ( bool(casetag) != it->second.empty() ) {\n\tcaseok = false;\n      }\n      unsigned idx = CASEES;\n      if ( sp.tp == sp.fp ) {\n\tidx = ( sp.tp ? 2 : 0 );\n      } else {\n\tidx = ( sp.tp ? 3 : 1 ); // 3 must not occur\n\tif ( idx >= CASEES ) {\n\t  INT << \"Case idx \" << idx << \" must not occur!\" << endl;\n\t}\n      }\n      cases[idx] = pair<Pathname,namesplit>( it->second, sp );\n    }\n\n    if ( caseok ) {\n      MIL << stringutil::form( \"%s: %-20s from %-20s -> %s\"\n\t\t\t       , spl.func.c_str()\n\t\t\t       , spl.type.c_str()\n\t\t\t       , spl.from.c_str()\n\t\t\t       , (casetag?\"good\":\"fail\") ) << endl;\n      if ( casetag ) {\n\tfor( unsigned i = 0; i < CASEES; ++i ) {\n\t  Pathname ff( path );\n\t  string nn( cases[i].second.splitfrom );\n\t  nn.replace( nn.end()-3, nn.end(), \"run\" );\n\t  ff += nn;\n\t  SEC << stringutil::form( \"%s: %-20s from %-20s < %s\"\n\t\t\t\t   , cases[i].second.func.c_str()\n\t\t\t\t   , cases[i].second.type.c_str()\n\t\t\t\t   , cases[i].second.from.c_str()\n\t\t\t\t   , ff.basename().c_str() ) << endl;\n\t DumpOn( SEC, ff );\n\t}\n      }\n    } else {\n      ERR << stringutil::form( \"%s: %-20s from %-20s\"\n\t\t\t       , spl.func.c_str()\n\t\t\t       , spl.type.c_str()\n\t\t\t       , spl.from.c_str() ) << endl;\n      for( unsigned i = 0; i < CASEES; ++i ) {\n\tWAR << stringutil::form( \"    %s: %-20s from %-20s\",\n\t\t\t\t (cases[i].first.empty()?\"good\":\"fail\"),\n\t\t\t\t cases[i].second.type.c_str(),\n\t\t\t\t cases[i].second.from.c_str() ) << endl;\n      }\n      for( unsigned i = 0; i < CASEES; ++i ) {\n\tif ( ! cases[i].first.empty() ) {\n\t  PathInfo pi( cases[i].first );\n\t  DBG << pi << endl;\n\t  DumpOn( DBG, pi.path() );\n\t} else {\n\t  Pathname ff( path );\n\t  string nn( cases[i].second.splitfrom );\n\t  nn.replace( nn.end()-3, nn.end(), \"run\" );\n\t  ff += nn;\n\t  SEC << stringutil::form( \"%s: %-20s from %-20s < %s\"\n\t\t\t\t   , cases[i].second.func.c_str()\n\t\t\t\t   , cases[i].second.type.c_str()\n\t\t\t\t   , cases[i].second.from.c_str()\n\t\t\t\t   , ff.basename().c_str() ) << endl;\n\t DumpOn( SEC, ff );\n\t}\n      }\n    }\n  }\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [
      "#define CASEES 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DumpOn",
          "args": [
            "SEC",
            "ff"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "DumpOn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "324-333",
          "snippet": "void DumpOn( ostream & str, const Pathname & file ) {\n  ifstream s( file.asString().c_str() );\n\n  while ( s ) {\n    string l = stringutil::getline( s );\n    if ( !(s.fail() || s.bad()) ) {\n       str << \"    \" << l << endl;\n    }\n  }\n}",
          "includes": [
            "#include \"PtrHier.h\"",
            "#include <y2util/PathInfo.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <string>",
            "#include <list>",
            "#include <map>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nvoid DumpOn( ostream & str, const Pathname & file ) {\n  ifstream s( file.asString().c_str() );\n\n  while ( s ) {\n    string l = stringutil::getline( s );\n    if ( !(s.fail() || s.bad()) ) {\n       str << \"    \" << l << endl;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stringutil::form",
          "args": [
            "\"%s: %-20s from %-20s < %s\"",
            "cases[i].second.func.c_str()",
            "cases[i].second.type.c_str()",
            "cases[i].second.from.c_str()",
            "ff.basename().c_str()"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff.basename",
          "args": [],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "basename",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "71-71",
          "snippet": "std::string basename()      const { return basename( *this ); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  std::string basename()      const { return basename( *this ); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cases[i].second.from.c_str",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cases[i].second.type.c_str",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cases[i].second.func.c_str",
          "args": [],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nn.replace",
          "args": [
            "nn.end()-3",
            "nn.end()",
            "\"run\""
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nn.end",
          "args": [],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pi.path",
          "args": [],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cases[i].first.empty",
          "args": [],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stringutil::form",
          "args": [
            "\"    %s: %-20s from %-20s\"",
            "(cases[i].first.empty()?\"good\":\"fail\")",
            "cases[i].second.type.c_str()",
            "cases[i].second.from.c_str()"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cases[i].second.from.c_str",
          "args": [],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cases[i].second.type.c_str",
          "args": [],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringutil::form",
          "args": [
            "\"%s: %-20s from %-20s\"",
            "spl.func.c_str()",
            "spl.type.c_str()",
            "spl.from.c_str()"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spl.from.c_str",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spl.type.c_str",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spl.func.c_str",
          "args": [],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringutil::form",
          "args": [
            "\"%s: %-20s from %-20s < %s\"",
            "cases[i].second.func.c_str()",
            "cases[i].second.type.c_str()",
            "cases[i].second.from.c_str()",
            "ff.basename().c_str()"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cases[i].second.from.c_str",
          "args": [],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cases[i].second.type.c_str",
          "args": [],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cases[i].second.func.c_str",
          "args": [],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nn.replace",
          "args": [
            "nn.end()-3",
            "nn.end()",
            "\"run\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringutil::form",
          "args": [
            "\"%s: %-20s from %-20s -> %s\"",
            "spl.func.c_str()",
            "spl.type.c_str()",
            "spl.from.c_str()",
            "(casetag?\"good\":\"fail\")"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spl.from.c_str",
          "args": [],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spl.type.c_str",
          "args": [],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spl.func.c_str",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pair<Pathname,namesplit>",
          "args": [
            "it->second",
            "sp"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "casetag"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flst.begin",
          "args": [],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cases.resize",
          "args": [
            "CASEES"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.asString",
          "args": [],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "flst.size",
          "args": [],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "subTestResult",
          "args": [
            "cpath.path()"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "subTestResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "335-434",
          "snippet": "void subTestResult( const Pathname & path ) {\n  list<string> retlist;\n  int res = PathInfo::readdir( retlist, path, false );\n  if ( res ) {\n    ERR << \"Error reading content of \" << path << \" (readdir \" << res << \")\" << endl;\n    return;\n  }\n  map<string,Pathname> flst;\n  for ( list<string>::const_iterator it = retlist.begin(); it != retlist.end(); ++it ) {\n    PathInfo cpath( path + *it );\n    if ( cpath.isFile() ) {\n      if ( cpath.path().asString().find( \".testgpp\" ) != string::npos ) {\n\tflst[*it] = ( cpath.size() ? cpath.path() : Pathname() );\n      }\n    } else if ( cpath.isDir() ) {\n      subTestResult( cpath.path() );\n    }\n  }\n\n  if ( ! flst.empty() ) {\n    if ( flst.size() != CASEES ) {\n      INT << \"NOT \" << CASEES << \": \" << flst.size() << \": \" << path << endl;\n    }\n    namesplit spl( path.asString() );\n    vector<pair<Pathname,namesplit> > cases;\n    cases.resize( CASEES );\n    off_t casetag = -1;\n    bool caseok  = true;\n    for ( map<string,Pathname>::const_iterator it = flst.begin(); it != flst.end(); ++it ) {\n      namesplit sp( it->first );\n      if ( casetag == -1 ) {\n\tcasetag = it->second.empty();\n      }\n      if ( bool(casetag) != it->second.empty() ) {\n\tcaseok = false;\n      }\n      unsigned idx = CASEES;\n      if ( sp.tp == sp.fp ) {\n\tidx = ( sp.tp ? 2 : 0 );\n      } else {\n\tidx = ( sp.tp ? 3 : 1 ); // 3 must not occur\n\tif ( idx >= CASEES ) {\n\t  INT << \"Case idx \" << idx << \" must not occur!\" << endl;\n\t}\n      }\n      cases[idx] = pair<Pathname,namesplit>( it->second, sp );\n    }\n\n    if ( caseok ) {\n      MIL << stringutil::form( \"%s: %-20s from %-20s -> %s\"\n\t\t\t       , spl.func.c_str()\n\t\t\t       , spl.type.c_str()\n\t\t\t       , spl.from.c_str()\n\t\t\t       , (casetag?\"good\":\"fail\") ) << endl;\n      if ( casetag ) {\n\tfor( unsigned i = 0; i < CASEES; ++i ) {\n\t  Pathname ff( path );\n\t  string nn( cases[i].second.splitfrom );\n\t  nn.replace( nn.end()-3, nn.end(), \"run\" );\n\t  ff += nn;\n\t  SEC << stringutil::form( \"%s: %-20s from %-20s < %s\"\n\t\t\t\t   , cases[i].second.func.c_str()\n\t\t\t\t   , cases[i].second.type.c_str()\n\t\t\t\t   , cases[i].second.from.c_str()\n\t\t\t\t   , ff.basename().c_str() ) << endl;\n\t DumpOn( SEC, ff );\n\t}\n      }\n    } else {\n      ERR << stringutil::form( \"%s: %-20s from %-20s\"\n\t\t\t       , spl.func.c_str()\n\t\t\t       , spl.type.c_str()\n\t\t\t       , spl.from.c_str() ) << endl;\n      for( unsigned i = 0; i < CASEES; ++i ) {\n\tWAR << stringutil::form( \"    %s: %-20s from %-20s\",\n\t\t\t\t (cases[i].first.empty()?\"good\":\"fail\"),\n\t\t\t\t cases[i].second.type.c_str(),\n\t\t\t\t cases[i].second.from.c_str() ) << endl;\n      }\n      for( unsigned i = 0; i < CASEES; ++i ) {\n\tif ( ! cases[i].first.empty() ) {\n\t  PathInfo pi( cases[i].first );\n\t  DBG << pi << endl;\n\t  DumpOn( DBG, pi.path() );\n\t} else {\n\t  Pathname ff( path );\n\t  string nn( cases[i].second.splitfrom );\n\t  nn.replace( nn.end()-3, nn.end(), \"run\" );\n\t  ff += nn;\n\t  SEC << stringutil::form( \"%s: %-20s from %-20s < %s\"\n\t\t\t\t   , cases[i].second.func.c_str()\n\t\t\t\t   , cases[i].second.type.c_str()\n\t\t\t\t   , cases[i].second.from.c_str()\n\t\t\t\t   , ff.basename().c_str() ) << endl;\n\t DumpOn( SEC, ff );\n\t}\n      }\n    }\n  }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "cpath.path",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpath.isDir",
          "args": [],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "isDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/PathInfo.h",
          "lines": "389-389",
          "snippet": "bool   isDir ()  const { return S_ISDIR( _mode ); }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <map>",
            "#include <set>",
            "#include <list>",
            "#include <iosfwd>",
            "#include <cerrno>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <map>\n#include <set>\n#include <list>\n#include <iosfwd>\n#include <cerrno>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nbool   isDir ()  const { return S_ISDIR( _mode ); }"
        }
      },
      {
        "call_info": {
          "callee": "Pathname",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "relativename",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "73-73",
          "snippet": "Pathname    relativename()  const { return relativename( *this ); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  Pathname    relativename()  const { return relativename( *this ); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpath.path",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpath.path",
          "args": [
            "\".testgpp\""
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpath.path",
          "args": [],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpath.path",
          "args": [],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpath.isFile",
          "args": [],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "isFile",
          "container": "YBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/include/ycp/YBlock.h",
          "lines": "206-206",
          "snippet": "bool isFile () const\t{ return (m_kind == b_file); }",
          "includes": [
            "#include \"ycp/YStatement.h\"",
            "#include <y2/Y2Namespace.h>",
            "#include <y2util/Ustring.h>",
            "#include <list>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YStatement.h\"\n#include <y2/Y2Namespace.h>\n#include <y2util/Ustring.h>\n#include <list>\n#include <string>\n\nYBlock {\n  bool isFile () const\t{ return (m_kind == b_file); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PathInfo::readdir",
          "args": [
            "retlist",
            "path",
            "false"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "readdir",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "477-506",
          "snippet": "int PathInfo::readdir( std::list<std::string> & retlist,\n\t\t       const Pathname & path, bool dots )\n{\n  retlist.clear();\n\n  DBG << \"readdir \" << path << ' ';\n\n  DIR * dir = ::opendir( path.asString().c_str() );\n  if ( ! dir ) {\n    return _Log_Result( errno );\n  }\n\n  struct dirent *entry;\n  while ( (entry = ::readdir( dir )) != 0 ) {\n\n    if ( entry->d_name[0] == '.' ) {\n      if ( !dots )\n\tcontinue;\n      if ( entry->d_name[1] == '\\0'\n\t   || (    entry->d_name[1] == '.'\n\t\t&& entry->d_name[2] == '\\0' ) )\n\tcontinue;\n    }\n    retlist.push_back( entry->d_name );\n  }\n\n  ::closedir( dir );\n\n  return _Log_Result( 0 );\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::readdir( std::list<std::string> & retlist,\n  \t\t       const Pathname & path, bool dots )\n  {\n    retlist.clear();\n  \n    DBG << \"readdir \" << path << ' ';\n  \n    DIR * dir = ::opendir( path.asString().c_str() );\n    if ( ! dir ) {\n      return _Log_Result( errno );\n    }\n  \n    struct dirent *entry;\n    while ( (entry = ::readdir( dir )) != 0 ) {\n  \n      if ( entry->d_name[0] == '.' ) {\n        if ( !dots )\n  \tcontinue;\n        if ( entry->d_name[1] == '\\0'\n  \t   || (    entry->d_name[1] == '.'\n  \t\t&& entry->d_name[2] == '\\0' ) )\n  \tcontinue;\n      }\n      retlist.push_back( entry->d_name );\n    }\n  \n    ::closedir( dir );\n  \n    return _Log_Result( 0 );\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\n#define CASEES 3\n\nvoid subTestResult( const Pathname & path ) {\n  list<string> retlist;\n  int res = PathInfo::readdir( retlist, path, false );\n  if ( res ) {\n    ERR << \"Error reading content of \" << path << \" (readdir \" << res << \")\" << endl;\n    return;\n  }\n  map<string,Pathname> flst;\n  for ( list<string>::const_iterator it = retlist.begin(); it != retlist.end(); ++it ) {\n    PathInfo cpath( path + *it );\n    if ( cpath.isFile() ) {\n      if ( cpath.path().asString().find( \".testgpp\" ) != string::npos ) {\n\tflst[*it] = ( cpath.size() ? cpath.path() : Pathname() );\n      }\n    } else if ( cpath.isDir() ) {\n      subTestResult( cpath.path() );\n    }\n  }\n\n  if ( ! flst.empty() ) {\n    if ( flst.size() != CASEES ) {\n      INT << \"NOT \" << CASEES << \": \" << flst.size() << \": \" << path << endl;\n    }\n    namesplit spl( path.asString() );\n    vector<pair<Pathname,namesplit> > cases;\n    cases.resize( CASEES );\n    off_t casetag = -1;\n    bool caseok  = true;\n    for ( map<string,Pathname>::const_iterator it = flst.begin(); it != flst.end(); ++it ) {\n      namesplit sp( it->first );\n      if ( casetag == -1 ) {\n\tcasetag = it->second.empty();\n      }\n      if ( bool(casetag) != it->second.empty() ) {\n\tcaseok = false;\n      }\n      unsigned idx = CASEES;\n      if ( sp.tp == sp.fp ) {\n\tidx = ( sp.tp ? 2 : 0 );\n      } else {\n\tidx = ( sp.tp ? 3 : 1 ); // 3 must not occur\n\tif ( idx >= CASEES ) {\n\t  INT << \"Case idx \" << idx << \" must not occur!\" << endl;\n\t}\n      }\n      cases[idx] = pair<Pathname,namesplit>( it->second, sp );\n    }\n\n    if ( caseok ) {\n      MIL << stringutil::form( \"%s: %-20s from %-20s -> %s\"\n\t\t\t       , spl.func.c_str()\n\t\t\t       , spl.type.c_str()\n\t\t\t       , spl.from.c_str()\n\t\t\t       , (casetag?\"good\":\"fail\") ) << endl;\n      if ( casetag ) {\n\tfor( unsigned i = 0; i < CASEES; ++i ) {\n\t  Pathname ff( path );\n\t  string nn( cases[i].second.splitfrom );\n\t  nn.replace( nn.end()-3, nn.end(), \"run\" );\n\t  ff += nn;\n\t  SEC << stringutil::form( \"%s: %-20s from %-20s < %s\"\n\t\t\t\t   , cases[i].second.func.c_str()\n\t\t\t\t   , cases[i].second.type.c_str()\n\t\t\t\t   , cases[i].second.from.c_str()\n\t\t\t\t   , ff.basename().c_str() ) << endl;\n\t DumpOn( SEC, ff );\n\t}\n      }\n    } else {\n      ERR << stringutil::form( \"%s: %-20s from %-20s\"\n\t\t\t       , spl.func.c_str()\n\t\t\t       , spl.type.c_str()\n\t\t\t       , spl.from.c_str() ) << endl;\n      for( unsigned i = 0; i < CASEES; ++i ) {\n\tWAR << stringutil::form( \"    %s: %-20s from %-20s\",\n\t\t\t\t (cases[i].first.empty()?\"good\":\"fail\"),\n\t\t\t\t cases[i].second.type.c_str(),\n\t\t\t\t cases[i].second.from.c_str() ) << endl;\n      }\n      for( unsigned i = 0; i < CASEES; ++i ) {\n\tif ( ! cases[i].first.empty() ) {\n\t  PathInfo pi( cases[i].first );\n\t  DBG << pi << endl;\n\t  DumpOn( DBG, pi.path() );\n\t} else {\n\t  Pathname ff( path );\n\t  string nn( cases[i].second.splitfrom );\n\t  nn.replace( nn.end()-3, nn.end(), \"run\" );\n\t  ff += nn;\n\t  SEC << stringutil::form( \"%s: %-20s from %-20s < %s\"\n\t\t\t\t   , cases[i].second.func.c_str()\n\t\t\t\t   , cases[i].second.type.c_str()\n\t\t\t\t   , cases[i].second.from.c_str()\n\t\t\t\t   , ff.basename().c_str() ) << endl;\n\t DumpOn( SEC, ff );\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "DumpOn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "324-333",
    "snippet": "void DumpOn( ostream & str, const Pathname & file ) {\n  ifstream s( file.asString().c_str() );\n\n  while ( s ) {\n    string l = stringutil::getline( s );\n    if ( !(s.fail() || s.bad()) ) {\n       str << \"    \" << l << endl;\n    }\n  }\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s.bad",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.fail",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringutil::getline",
          "args": [
            "s"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.asString",
          "args": [],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nvoid DumpOn( ostream & str, const Pathname & file ) {\n  ifstream s( file.asString().c_str() );\n\n  while ( s ) {\n    string l = stringutil::getline( s );\n    if ( !(s.fail() || s.bad()) ) {\n       str << \"    \" << l << endl;\n    }\n  }\n}"
  },
  {
    "function_name": "genTestSrc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "317-321",
    "snippet": "void genTestSrc() {\n  genTestSrc( \"SLV\", \"SLV\" );\n  genTestSrc( \"OBJ\", \"PKG\" );\n  genTestSrc( \"PKG\", \"OBJ\" );\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "genTestSrc",
          "args": [
            "\"PKG\"",
            "\"OBJ\""
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "genTestSrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "308-315",
          "snippet": "void genTestSrc( const string & type, const string & from ) {\n  Pathname subd ( type + \"_from_\" + from );\n  allComb( construct,       type, from, subd );\n  allComb( constructAss,    type, from, subd );\n  allComb( constructRef,    type, from, subd );\n  allComb( constructRefAss, type, from, subd );\n  allComb( assign,          type, from, subd );\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nvoid genTestSrc() {\n  genTestSrc( \"SLV\", \"SLV\" );\n  genTestSrc( \"OBJ\", \"PKG\" );\n  genTestSrc( \"PKG\", \"OBJ\" );\n}"
  },
  {
    "function_name": "genTestSrc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "308-315",
    "snippet": "void genTestSrc( const string & type, const string & from ) {\n  Pathname subd ( type + \"_from_\" + from );\n  allComb( construct,       type, from, subd );\n  allComb( constructAss,    type, from, subd );\n  allComb( constructRef,    type, from, subd );\n  allComb( constructRefAss, type, from, subd );\n  allComb( assign,          type, from, subd );\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "allComb",
          "args": [
            "assign",
            "type",
            "from",
            "subd"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "allComb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "290-305",
          "snippet": "void allComb( bodyfnc fnc, const string & type, const string & from, Pathname subd ) {\n  string dname( srcfile( fnc ) );\n  if ( dname.empty() )\n    return;\n  subd += dname;\n\n  unsigned d = 4;\n  D td[] = { DP(type), cDP(type), DPc(type), cDPc(type) };\n  D fd[] = { DP(from), cDP(from), DPc(from), cDPc(from) };\n\n  for ( unsigned t = 0; t < d; ++t ) {\n    for ( unsigned f = 0; f < d; ++f ) {\n      allProgs( fnc, td[t], fd[f], from, subd );\n    }\n  }\n}",
          "includes": [
            "#include \"PtrHier.h\"",
            "#include <y2util/PathInfo.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <string>",
            "#include <list>",
            "#include <map>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nvoid allComb( bodyfnc fnc, const string & type, const string & from, Pathname subd ) {\n  string dname( srcfile( fnc ) );\n  if ( dname.empty() )\n    return;\n  subd += dname;\n\n  unsigned d = 4;\n  D td[] = { DP(type), cDP(type), DPc(type), cDPc(type) };\n  D fd[] = { DP(from), cDP(from), DPc(from), cDPc(from) };\n\n  for ( unsigned t = 0; t < d; ++t ) {\n    for ( unsigned f = 0; f < d; ++f ) {\n      allProgs( fnc, td[t], fd[f], from, subd );\n    }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nvoid genTestSrc( const string & type, const string & from ) {\n  Pathname subd ( type + \"_from_\" + from );\n  allComb( construct,       type, from, subd );\n  allComb( constructAss,    type, from, subd );\n  allComb( constructRef,    type, from, subd );\n  allComb( constructRefAss, type, from, subd );\n  allComb( assign,          type, from, subd );\n}"
  },
  {
    "function_name": "allComb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "290-305",
    "snippet": "void allComb( bodyfnc fnc, const string & type, const string & from, Pathname subd ) {\n  string dname( srcfile( fnc ) );\n  if ( dname.empty() )\n    return;\n  subd += dname;\n\n  unsigned d = 4;\n  D td[] = { DP(type), cDP(type), DPc(type), cDPc(type) };\n  D fd[] = { DP(from), cDP(from), DPc(from), cDPc(from) };\n\n  for ( unsigned t = 0; t < d; ++t ) {\n    for ( unsigned f = 0; f < d; ++f ) {\n      allProgs( fnc, td[t], fd[f], from, subd );\n    }\n  }\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "allProgs",
          "args": [
            "fnc",
            "td[t]",
            "fd[f]",
            "from",
            "subd"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "allProgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "263-287",
          "snippet": "void allProgs( bodyfnc fnc, const D & type, const D & from, const string & frombase, Pathname subd ) {\n  string dname( srcfile( fnc, type.Ptr, from.Ptr ) );\n  if ( dname.empty() )\n    return;\n  subd += dname;\n\n#if 0\n  unsigned d = 2;\n#endif\n  string td[] = { type.Ptr, type.p };\n  string fd[] = { from.Ptr, from.p };\n\n#if 0\n  for ( unsigned t = 0; t < d; ++t ) {\n    for ( unsigned f = 0; f < d; ++f ) {\n      prog( fnc, td[t], fd[f], subd );\n    }\n  }\n#endif\n\n  prog( fnc, td[0], fd[0], frombase, subd );\n  prog( fnc, td[0], fd[1], frombase, subd );\n  // no (*,Ptr) combination\n  prog( fnc, td[1], fd[1], frombase, subd );\n}",
          "includes": [
            "#include \"PtrHier.h\"",
            "#include <y2util/PathInfo.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <string>",
            "#include <list>",
            "#include <map>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nvoid allProgs( bodyfnc fnc, const D & type, const D & from, const string & frombase, Pathname subd ) {\n  string dname( srcfile( fnc, type.Ptr, from.Ptr ) );\n  if ( dname.empty() )\n    return;\n  subd += dname;\n\n#if 0\n  unsigned d = 2;\n#endif\n  string td[] = { type.Ptr, type.p };\n  string fd[] = { from.Ptr, from.p };\n\n#if 0\n  for ( unsigned t = 0; t < d; ++t ) {\n    for ( unsigned f = 0; f < d; ++f ) {\n      prog( fnc, td[t], fd[f], subd );\n    }\n  }\n#endif\n\n  prog( fnc, td[0], fd[0], frombase, subd );\n  prog( fnc, td[0], fd[1], frombase, subd );\n  // no (*,Ptr) combination\n  prog( fnc, td[1], fd[1], frombase, subd );\n}"
        }
      },
      {
        "call_info": {
          "callee": "cDPc",
          "args": [
            "from"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPc",
          "args": [
            "from"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cDP",
          "args": [
            "from"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DP",
          "args": [
            "from"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cDPc",
          "args": [
            "type"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPc",
          "args": [
            "type"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cDP",
          "args": [
            "type"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DP",
          "args": [
            "type"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dname.empty",
          "args": [],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nvoid allComb( bodyfnc fnc, const string & type, const string & from, Pathname subd ) {\n  string dname( srcfile( fnc ) );\n  if ( dname.empty() )\n    return;\n  subd += dname;\n\n  unsigned d = 4;\n  D td[] = { DP(type), cDP(type), DPc(type), cDPc(type) };\n  D fd[] = { DP(from), cDP(from), DPc(from), cDPc(from) };\n\n  for ( unsigned t = 0; t < d; ++t ) {\n    for ( unsigned f = 0; f < d; ++f ) {\n      allProgs( fnc, td[t], fd[f], from, subd );\n    }\n  }\n}"
  },
  {
    "function_name": "allProgs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "263-287",
    "snippet": "void allProgs( bodyfnc fnc, const D & type, const D & from, const string & frombase, Pathname subd ) {\n  string dname( srcfile( fnc, type.Ptr, from.Ptr ) );\n  if ( dname.empty() )\n    return;\n  subd += dname;\n\n#if 0\n  unsigned d = 2;\n#endif\n  string td[] = { type.Ptr, type.p };\n  string fd[] = { from.Ptr, from.p };\n\n#if 0\n  for ( unsigned t = 0; t < d; ++t ) {\n    for ( unsigned f = 0; f < d; ++f ) {\n      prog( fnc, td[t], fd[f], subd );\n    }\n  }\n#endif\n\n  prog( fnc, td[0], fd[0], frombase, subd );\n  prog( fnc, td[0], fd[1], frombase, subd );\n  // no (*,Ptr) combination\n  prog( fnc, td[1], fd[1], frombase, subd );\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prog",
          "args": [
            "fnc",
            "td[1]",
            "fd[1]",
            "frombase",
            "subd"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "prog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "219-258",
          "snippet": "void prog( bodyfnc fnc, const string & type, const string & from, const string & frombase, Pathname subd ) {\n  string fname;\n  Pathname ddir( Pathname(\"test\")+subd );\n  if ( assertPath( ddir ) ) {\n    fname = srcfile( fnc, type, from );\n  }\n  if ( ! fname.empty() ) {\n    fname = (ddir + (fname+\".cc\")).asString();\n    PSTR.close();\n    PSTR.open( fname.c_str() );\n    DBG << \"Writing \" << fname << endl;\n  }\n  PSTR << \"#include <iostream>\" << endl;\n  PSTR << \"#include <set>\" << endl;\n  PSTR << \"using namespace std;\" << endl;\n  PSTR << \"#include \\\"PtrHier.h\\\"\" << endl;\n  PSTR << \"#define TG cout << \\\"===[\\\" << __LINE__ << \\\"]=============================================\\\" << endl;\" << endl;\n  PSTR << \"typedef \" << type     << \" type;\" << endl;\n  PSTR << \"typedef \" << from     << \" from;\" << endl;\n  PSTR << \"typedef \" << frombase << \" fobj;\" << endl;\n  PSTR << \"ostream & operator<<( ostream & str, const set<unsigned> & obj ) {\" << endl;\n  PSTR << \"  str << \\\"Set(\\\" << obj.size() << \\\")\\\";\" << endl;\n  PSTR << \"  for ( set<unsigned>::const_iterator it = obj.begin(); it != obj.end(); ++it ) {\" << endl;\n  PSTR << \"    str << endl << \\\"  \\\" << *it;\" << endl;\n  PSTR << \"  }\" << endl;\n  PSTR << \"  str << endl;\" << endl;\n  PSTR << \"  return str;\" << endl;\n  PSTR << \"}\" << endl;\n  PSTR << \"int main() {\" << endl;\n  fnc();\n  PSTR << \"  TG;\" << endl;\n  PSTR << \"  cout << \\\"SLV\\\" << SLV::_IDS;\" << endl;\n  PSTR << \"  cout << \\\"XXX\\\" << XXX::_IDS;\" << endl;\n  PSTR << \"return 0; }\" << endl;\n\n  if ( ! fname.empty() ) {\n    PSTR.close();\n    PSTR.open( \"/dev/stdout\" );\n  }\n}",
          "includes": [
            "#include \"PtrHier.h\"",
            "#include <y2util/PathInfo.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <string>",
            "#include <list>",
            "#include <map>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [
            "#define TG cout << \"===[\" << __LINE__ << \"]=============================================\" << endl"
          ],
          "globals_used": [
            "static ofstream PSTR( \"/dev/stdout\" );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\n#define TG cout << \"===[\" << __LINE__ << \"]=============================================\" << endl\n\nstatic ofstream PSTR( \"/dev/stdout\" );\n\nvoid prog( bodyfnc fnc, const string & type, const string & from, const string & frombase, Pathname subd ) {\n  string fname;\n  Pathname ddir( Pathname(\"test\")+subd );\n  if ( assertPath( ddir ) ) {\n    fname = srcfile( fnc, type, from );\n  }\n  if ( ! fname.empty() ) {\n    fname = (ddir + (fname+\".cc\")).asString();\n    PSTR.close();\n    PSTR.open( fname.c_str() );\n    DBG << \"Writing \" << fname << endl;\n  }\n  PSTR << \"#include <iostream>\" << endl;\n  PSTR << \"#include <set>\" << endl;\n  PSTR << \"using namespace std;\" << endl;\n  PSTR << \"#include \\\"PtrHier.h\\\"\" << endl;\n  PSTR << \"#define TG cout << \\\"===[\\\" << __LINE__ << \\\"]=============================================\\\" << endl;\" << endl;\n  PSTR << \"typedef \" << type     << \" type;\" << endl;\n  PSTR << \"typedef \" << from     << \" from;\" << endl;\n  PSTR << \"typedef \" << frombase << \" fobj;\" << endl;\n  PSTR << \"ostream & operator<<( ostream & str, const set<unsigned> & obj ) {\" << endl;\n  PSTR << \"  str << \\\"Set(\\\" << obj.size() << \\\")\\\";\" << endl;\n  PSTR << \"  for ( set<unsigned>::const_iterator it = obj.begin(); it != obj.end(); ++it ) {\" << endl;\n  PSTR << \"    str << endl << \\\"  \\\" << *it;\" << endl;\n  PSTR << \"  }\" << endl;\n  PSTR << \"  str << endl;\" << endl;\n  PSTR << \"  return str;\" << endl;\n  PSTR << \"}\" << endl;\n  PSTR << \"int main() {\" << endl;\n  fnc();\n  PSTR << \"  TG;\" << endl;\n  PSTR << \"  cout << \\\"SLV\\\" << SLV::_IDS;\" << endl;\n  PSTR << \"  cout << \\\"XXX\\\" << XXX::_IDS;\" << endl;\n  PSTR << \"return 0; }\" << endl;\n\n  if ( ! fname.empty() ) {\n    PSTR.close();\n    PSTR.open( \"/dev/stdout\" );\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "prog",
          "args": [
            "fnc",
            "td[t]",
            "fd[f]",
            "subd"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dname.empty",
          "args": [],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcfile",
          "args": [
            "fnc",
            "type.Ptr",
            "from.Ptr"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "srcfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "133-155",
          "snippet": "string srcfile( bodyfnc fnc, const string & type, const string & from ) {\n  string ret( srcfile( fnc ) );\n  if ( ! ret.empty() ) {\n    ret = ( stringutil::form( (ret+\"@%s from %s\").c_str(), type.c_str(), from.c_str() ) );\n    for ( unsigned i = 0; i < ret.size(); ++i ) {\n      switch ( ret[i] ) {\n      case ' ':\n\tret[i] = '_';\n\tbreak;\n      case '<':\n\tret[i] = '[';\n\tbreak;\n      case '>':\n\tret[i] = ']';\n\tbreak;\n      case '*':\n\tret[i] = '+';\n\tbreak;\n      }\n    }\n  }\n  return ret;\n}",
          "includes": [
            "#include \"PtrHier.h\"",
            "#include <y2util/PathInfo.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <string>",
            "#include <list>",
            "#include <map>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nstring srcfile( bodyfnc fnc, const string & type, const string & from ) {\n  string ret( srcfile( fnc ) );\n  if ( ! ret.empty() ) {\n    ret = ( stringutil::form( (ret+\"@%s from %s\").c_str(), type.c_str(), from.c_str() ) );\n    for ( unsigned i = 0; i < ret.size(); ++i ) {\n      switch ( ret[i] ) {\n      case ' ':\n\tret[i] = '_';\n\tbreak;\n      case '<':\n\tret[i] = '[';\n\tbreak;\n      case '>':\n\tret[i] = ']';\n\tbreak;\n      case '*':\n\tret[i] = '+';\n\tbreak;\n      }\n    }\n  }\n  return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nvoid allProgs( bodyfnc fnc, const D & type, const D & from, const string & frombase, Pathname subd ) {\n  string dname( srcfile( fnc, type.Ptr, from.Ptr ) );\n  if ( dname.empty() )\n    return;\n  subd += dname;\n\n#if 0\n  unsigned d = 2;\n#endif\n  string td[] = { type.Ptr, type.p };\n  string fd[] = { from.Ptr, from.p };\n\n#if 0\n  for ( unsigned t = 0; t < d; ++t ) {\n    for ( unsigned f = 0; f < d; ++f ) {\n      prog( fnc, td[t], fd[f], subd );\n    }\n  }\n#endif\n\n  prog( fnc, td[0], fd[0], frombase, subd );\n  prog( fnc, td[0], fd[1], frombase, subd );\n  // no (*,Ptr) combination\n  prog( fnc, td[1], fd[1], frombase, subd );\n}"
  },
  {
    "function_name": "prog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "219-258",
    "snippet": "void prog( bodyfnc fnc, const string & type, const string & from, const string & frombase, Pathname subd ) {\n  string fname;\n  Pathname ddir( Pathname(\"test\")+subd );\n  if ( assertPath( ddir ) ) {\n    fname = srcfile( fnc, type, from );\n  }\n  if ( ! fname.empty() ) {\n    fname = (ddir + (fname+\".cc\")).asString();\n    PSTR.close();\n    PSTR.open( fname.c_str() );\n    DBG << \"Writing \" << fname << endl;\n  }\n  PSTR << \"#include <iostream>\" << endl;\n  PSTR << \"#include <set>\" << endl;\n  PSTR << \"using namespace std;\" << endl;\n  PSTR << \"#include \\\"PtrHier.h\\\"\" << endl;\n  PSTR << \"#define TG cout << \\\"===[\\\" << __LINE__ << \\\"]=============================================\\\" << endl;\" << endl;\n  PSTR << \"typedef \" << type     << \" type;\" << endl;\n  PSTR << \"typedef \" << from     << \" from;\" << endl;\n  PSTR << \"typedef \" << frombase << \" fobj;\" << endl;\n  PSTR << \"ostream & operator<<( ostream & str, const set<unsigned> & obj ) {\" << endl;\n  PSTR << \"  str << \\\"Set(\\\" << obj.size() << \\\")\\\";\" << endl;\n  PSTR << \"  for ( set<unsigned>::const_iterator it = obj.begin(); it != obj.end(); ++it ) {\" << endl;\n  PSTR << \"    str << endl << \\\"  \\\" << *it;\" << endl;\n  PSTR << \"  }\" << endl;\n  PSTR << \"  str << endl;\" << endl;\n  PSTR << \"  return str;\" << endl;\n  PSTR << \"}\" << endl;\n  PSTR << \"int main() {\" << endl;\n  fnc();\n  PSTR << \"  TG;\" << endl;\n  PSTR << \"  cout << \\\"SLV\\\" << SLV::_IDS;\" << endl;\n  PSTR << \"  cout << \\\"XXX\\\" << XXX::_IDS;\" << endl;\n  PSTR << \"return 0; }\" << endl;\n\n  if ( ! fname.empty() ) {\n    PSTR.close();\n    PSTR.open( \"/dev/stdout\" );\n  }\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [
      "#define TG cout << \"===[\" << __LINE__ << \"]=============================================\" << endl"
    ],
    "globals_used": [
      "static ofstream PSTR( \"/dev/stdout\" );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PSTR.open",
          "args": [
            "\"/dev/stdout\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PSTR.close",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "325-351",
          "snippet": "int\nExternalProgram::close()\n{\n    if (pid > 0)\n    {\n\tExternalDataSource::close();\n\t// Wait for child to exit\n\tint ret;\n        int status = 0;\n\tdo\n\t{\n\t    ret = waitpid(pid, &status, 0);\n\t}\n\twhile (ret == -1 && errno == EINTR);\n\n\tif (ret != -1)\n\t{\n\t    status = checkStatus( status );\n\t}\n        pid = -1;\n        return status;\n    }\n    else\n    {\n        return _exitStatus;\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  int\n  ExternalProgram::close()\n  {\n      if (pid > 0)\n      {\n  \tExternalDataSource::close();\n  \t// Wait for child to exit\n  \tint ret;\n          int status = 0;\n  \tdo\n  \t{\n  \t    ret = waitpid(pid, &status, 0);\n  \t}\n  \twhile (ret == -1 && errno == EINTR);\n  \n  \tif (ret != -1)\n  \t{\n  \t    status = checkStatus( status );\n  \t}\n          pid = -1;\n          return status;\n      }\n      else\n      {\n          return _exitStatus;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fname.empty",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnc",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PSTR.open",
          "args": [
            "fname.c_str()"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fname.c_str",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcfile",
          "args": [
            "fnc",
            "type",
            "from"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "srcfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "133-155",
          "snippet": "string srcfile( bodyfnc fnc, const string & type, const string & from ) {\n  string ret( srcfile( fnc ) );\n  if ( ! ret.empty() ) {\n    ret = ( stringutil::form( (ret+\"@%s from %s\").c_str(), type.c_str(), from.c_str() ) );\n    for ( unsigned i = 0; i < ret.size(); ++i ) {\n      switch ( ret[i] ) {\n      case ' ':\n\tret[i] = '_';\n\tbreak;\n      case '<':\n\tret[i] = '[';\n\tbreak;\n      case '>':\n\tret[i] = ']';\n\tbreak;\n      case '*':\n\tret[i] = '+';\n\tbreak;\n      }\n    }\n  }\n  return ret;\n}",
          "includes": [
            "#include \"PtrHier.h\"",
            "#include <y2util/PathInfo.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <string>",
            "#include <list>",
            "#include <map>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nstring srcfile( bodyfnc fnc, const string & type, const string & from ) {\n  string ret( srcfile( fnc ) );\n  if ( ! ret.empty() ) {\n    ret = ( stringutil::form( (ret+\"@%s from %s\").c_str(), type.c_str(), from.c_str() ) );\n    for ( unsigned i = 0; i < ret.size(); ++i ) {\n      switch ( ret[i] ) {\n      case ' ':\n\tret[i] = '_';\n\tbreak;\n      case '<':\n\tret[i] = '[';\n\tbreak;\n      case '>':\n\tret[i] = ']';\n\tbreak;\n      case '*':\n\tret[i] = '+';\n\tbreak;\n      }\n    }\n  }\n  return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assertPath",
          "args": [
            "ddir"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "assertPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "17-26",
          "snippet": "bool assertPath( const Pathname & path ) {\n  PathInfo ddir( path );\n  if ( ddir.isDir() ) {\n    return true;\n  }\n  if ( assertPath( path.dirname() ) ) {\n    return( PathInfo::mkdir( path ) == 0 );\n  }\n  return false;\n}",
          "includes": [
            "#include \"PtrHier.h\"",
            "#include <y2util/PathInfo.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <string>",
            "#include <list>",
            "#include <map>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nbool assertPath( const Pathname & path ) {\n  PathInfo ddir( path );\n  if ( ddir.isDir() ) {\n    return true;\n  }\n  if ( assertPath( path.dirname() ) ) {\n    return( PathInfo::mkdir( path ) == 0 );\n  }\n  return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Pathname",
          "args": [
            "\"test\""
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "basename",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/Pathname.cc",
          "lines": "220-233",
          "snippet": "string Pathname::basename( const Pathname & name_tv )\n{\n  if ( name_tv.empty() )\n    return \"\";\n\n  string ret_t( name_tv.asString() );\n  ret_t.erase( 0, name_tv.prfx_i );\n  string::size_type idx = ret_t.find_last_of( '/' );\n  if ( idx != string::npos ) {\n    ret_t.erase( 0, idx+1 );\n  }\n\n  return ret_t;\n}",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <iostream>\n\nPathname {\n  string Pathname::basename( const Pathname & name_tv )\n  {\n    if ( name_tv.empty() )\n      return \"\";\n  \n    string ret_t( name_tv.asString() );\n    ret_t.erase( 0, name_tv.prfx_i );\n    string::size_type idx = ret_t.find_last_of( '/' );\n    if ( idx != string::npos ) {\n      ret_t.erase( 0, idx+1 );\n    }\n  \n    return ret_t;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\n#define TG cout << \"===[\" << __LINE__ << \"]=============================================\" << endl\n\nstatic ofstream PSTR( \"/dev/stdout\" );\n\nvoid prog( bodyfnc fnc, const string & type, const string & from, const string & frombase, Pathname subd ) {\n  string fname;\n  Pathname ddir( Pathname(\"test\")+subd );\n  if ( assertPath( ddir ) ) {\n    fname = srcfile( fnc, type, from );\n  }\n  if ( ! fname.empty() ) {\n    fname = (ddir + (fname+\".cc\")).asString();\n    PSTR.close();\n    PSTR.open( fname.c_str() );\n    DBG << \"Writing \" << fname << endl;\n  }\n  PSTR << \"#include <iostream>\" << endl;\n  PSTR << \"#include <set>\" << endl;\n  PSTR << \"using namespace std;\" << endl;\n  PSTR << \"#include \\\"PtrHier.h\\\"\" << endl;\n  PSTR << \"#define TG cout << \\\"===[\\\" << __LINE__ << \\\"]=============================================\\\" << endl;\" << endl;\n  PSTR << \"typedef \" << type     << \" type;\" << endl;\n  PSTR << \"typedef \" << from     << \" from;\" << endl;\n  PSTR << \"typedef \" << frombase << \" fobj;\" << endl;\n  PSTR << \"ostream & operator<<( ostream & str, const set<unsigned> & obj ) {\" << endl;\n  PSTR << \"  str << \\\"Set(\\\" << obj.size() << \\\")\\\";\" << endl;\n  PSTR << \"  for ( set<unsigned>::const_iterator it = obj.begin(); it != obj.end(); ++it ) {\" << endl;\n  PSTR << \"    str << endl << \\\"  \\\" << *it;\" << endl;\n  PSTR << \"  }\" << endl;\n  PSTR << \"  str << endl;\" << endl;\n  PSTR << \"  return str;\" << endl;\n  PSTR << \"}\" << endl;\n  PSTR << \"int main() {\" << endl;\n  fnc();\n  PSTR << \"  TG;\" << endl;\n  PSTR << \"  cout << \\\"SLV\\\" << SLV::_IDS;\" << endl;\n  PSTR << \"  cout << \\\"XXX\\\" << XXX::_IDS;\" << endl;\n  PSTR << \"return 0; }\" << endl;\n\n  if ( ! fname.empty() ) {\n    PSTR.close();\n    PSTR.open( \"/dev/stdout\" );\n  }\n}"
  },
  {
    "function_name": "split",
    "container": "namesplit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "190-214",
    "snippet": "void split( string name ) {\n    *this = namesplit();\n    splitfrom = name;\n    string::size_type pos = name.rfind( \"/\" );\n    if ( pos != string::npos ) {\n      name.erase( 0, pos+1 );\n    }\n    pos = name.rfind( \".\" );\n    if ( pos != string::npos ) {\n      name.erase( pos );\n    }\n    pos = name.find( \"@\" );\n    if ( pos == string::npos ) {\n      return;\n    }\n    func = name.substr( 0, pos );\n    name.erase( 0, pos+1 );\n    pos = name.find( \"_from_\" );\n    type = name.substr( 0, pos );\n    from = name.substr( pos+6 );\n    reconv( func );\n    reconv( type, tp );\n    reconv( from, fp );\n    //DBG << func << \": \" << tp << fp << \": \" << type << \" \" << from << endl;\n  }",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reconv",
          "args": [
            "from",
            "fp"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "reconv",
          "container": "namesplit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "166-185",
          "snippet": "void reconv( string & name, bool & isp ) {\n    isp = false;\n    for ( unsigned i = 0; i < name.size(); ++i ) {\n      switch ( name[i] ) {\n      case '_':\n\tname[i] = ' ';\n\tbreak;\n      case '[':\n\tname[i] = '<';\n\tbreak;\n      case ']':\n\tname[i] = '>';\n\tbreak;\n      case '+':\n\tname[i] = '*';\n\tisp = true;\n\tbreak;\n      }\n    }\n  }",
          "includes": [
            "#include \"PtrHier.h\"",
            "#include <y2util/PathInfo.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <string>",
            "#include <list>",
            "#include <map>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nnamesplit {\n  void reconv( string & name, bool & isp ) {\n      isp = false;\n      for ( unsigned i = 0; i < name.size(); ++i ) {\n        switch ( name[i] ) {\n        case '_':\n  \tname[i] = ' ';\n  \tbreak;\n        case '[':\n  \tname[i] = '<';\n  \tbreak;\n        case ']':\n  \tname[i] = '>';\n  \tbreak;\n        case '+':\n  \tname[i] = '*';\n  \tisp = true;\n  \tbreak;\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "name.substr",
          "args": [
            "pos+6"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.substr",
          "args": [
            "0",
            "pos"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.find",
          "args": [
            "\"_from_\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.erase",
          "args": [
            "0",
            "pos+1"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.substr",
          "args": [
            "0",
            "pos"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.find",
          "args": [
            "\"@\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.erase",
          "args": [
            "pos"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "PathInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/PathInfo.cc",
          "lines": "683-695",
          "snippet": "int PathInfo::erase( const Pathname & path )\n{\n  int res = 0;\n  PathInfo p( path, LSTAT );\n  if ( p.isExist() )\n    {\n      if ( p.isDir() )\n        res = PathInfo::recursive_rmdir( path );\n      else\n        res = PathInfo::unlink( path );\n    }\n  return res;\n}",
          "includes": [
            "#include <y2util/PathInfo.h>",
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <iomanip>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/PathInfo.h>\n#include <y2util/ExternalProgram.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <iomanip>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n\nPathInfo {\n  int PathInfo::erase( const Pathname & path )\n  {\n    int res = 0;\n    PathInfo p( path, LSTAT );\n    if ( p.isExist() )\n      {\n        if ( p.isDir() )\n          res = PathInfo::recursive_rmdir( path );\n        else\n          res = PathInfo::unlink( path );\n      }\n    return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "name.rfind",
          "args": [
            "\".\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.erase",
          "args": [
            "0",
            "pos+1"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.rfind",
          "args": [
            "\"/\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namesplit",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "namesplit",
          "container": "namesplit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "164-164",
          "snippet": "namesplit() {tp=fp=false;}",
          "includes": [
            "#include \"PtrHier.h\"",
            "#include <y2util/PathInfo.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <string>",
            "#include <list>",
            "#include <map>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nnamesplit {\n  namesplit() {tp=fp=false;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nnamesplit {\n  void split( string name ) {\n      *this = namesplit();\n      splitfrom = name;\n      string::size_type pos = name.rfind( \"/\" );\n      if ( pos != string::npos ) {\n        name.erase( 0, pos+1 );\n      }\n      pos = name.rfind( \".\" );\n      if ( pos != string::npos ) {\n        name.erase( pos );\n      }\n      pos = name.find( \"@\" );\n      if ( pos == string::npos ) {\n        return;\n      }\n      func = name.substr( 0, pos );\n      name.erase( 0, pos+1 );\n      pos = name.find( \"_from_\" );\n      type = name.substr( 0, pos );\n      from = name.substr( pos+6 );\n      reconv( func );\n      reconv( type, tp );\n      reconv( from, fp );\n      //DBG << func << \": \" << tp << fp << \": \" << type << \" \" << from << endl;\n    }\n}"
  },
  {
    "function_name": "reconv",
    "container": "namesplit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "186-189",
    "snippet": "void reconv( string & name ) {\n    bool isp;\n    reconv( name, isp );\n  }",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reconv",
          "args": [
            "name",
            "isp"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "reconv",
          "container": "namesplit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "166-185",
          "snippet": "void reconv( string & name, bool & isp ) {\n    isp = false;\n    for ( unsigned i = 0; i < name.size(); ++i ) {\n      switch ( name[i] ) {\n      case '_':\n\tname[i] = ' ';\n\tbreak;\n      case '[':\n\tname[i] = '<';\n\tbreak;\n      case ']':\n\tname[i] = '>';\n\tbreak;\n      case '+':\n\tname[i] = '*';\n\tisp = true;\n\tbreak;\n      }\n    }\n  }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nnamesplit {\n  void reconv( string & name ) {\n      bool isp;\n      reconv( name, isp );\n    }\n}"
  },
  {
    "function_name": "reconv",
    "container": "namesplit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "166-185",
    "snippet": "void reconv( string & name, bool & isp ) {\n    isp = false;\n    for ( unsigned i = 0; i < name.size(); ++i ) {\n      switch ( name[i] ) {\n      case '_':\n\tname[i] = ' ';\n\tbreak;\n      case '[':\n\tname[i] = '<';\n\tbreak;\n      case ']':\n\tname[i] = '>';\n\tbreak;\n      case '+':\n\tname[i] = '*';\n\tisp = true;\n\tbreak;\n      }\n    }\n  }",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "name.size",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nnamesplit {\n  void reconv( string & name, bool & isp ) {\n      isp = false;\n      for ( unsigned i = 0; i < name.size(); ++i ) {\n        switch ( name[i] ) {\n        case '_':\n  \tname[i] = ' ';\n  \tbreak;\n        case '[':\n  \tname[i] = '<';\n  \tbreak;\n        case ']':\n  \tname[i] = '>';\n  \tbreak;\n        case '+':\n  \tname[i] = '*';\n  \tisp = true;\n  \tbreak;\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "namesplit",
    "container": "namesplit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "165-165",
    "snippet": "namesplit( const string & name ) { split( name ); }",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "split",
          "args": [
            "name"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "split",
          "container": "namesplit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "190-214",
          "snippet": "void split( string name ) {\n    *this = namesplit();\n    splitfrom = name;\n    string::size_type pos = name.rfind( \"/\" );\n    if ( pos != string::npos ) {\n      name.erase( 0, pos+1 );\n    }\n    pos = name.rfind( \".\" );\n    if ( pos != string::npos ) {\n      name.erase( pos );\n    }\n    pos = name.find( \"@\" );\n    if ( pos == string::npos ) {\n      return;\n    }\n    func = name.substr( 0, pos );\n    name.erase( 0, pos+1 );\n    pos = name.find( \"_from_\" );\n    type = name.substr( 0, pos );\n    from = name.substr( pos+6 );\n    reconv( func );\n    reconv( type, tp );\n    reconv( from, fp );\n    //DBG << func << \": \" << tp << fp << \": \" << type << \" \" << from << endl;\n  }",
          "includes": [
            "#include \"PtrHier.h\"",
            "#include <y2util/PathInfo.h>",
            "#include <y2util/stringutil.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <string>",
            "#include <list>",
            "#include <map>",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nnamesplit {\n  void split( string name ) {\n      *this = namesplit();\n      splitfrom = name;\n      string::size_type pos = name.rfind( \"/\" );\n      if ( pos != string::npos ) {\n        name.erase( 0, pos+1 );\n      }\n      pos = name.rfind( \".\" );\n      if ( pos != string::npos ) {\n        name.erase( pos );\n      }\n      pos = name.find( \"@\" );\n      if ( pos == string::npos ) {\n        return;\n      }\n      func = name.substr( 0, pos );\n      name.erase( 0, pos+1 );\n      pos = name.find( \"_from_\" );\n      type = name.substr( 0, pos );\n      from = name.substr( pos+6 );\n      reconv( func );\n      reconv( type, tp );\n      reconv( from, fp );\n      //DBG << func << \": \" << tp << fp << \": \" << type << \" \" << from << endl;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nnamesplit {\n  namesplit( const string & name ) { split( name ); }\n}"
  },
  {
    "function_name": "namesplit",
    "container": "namesplit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "164-164",
    "snippet": "namesplit() {tp=fp=false;}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nnamesplit {\n  namesplit() {tp=fp=false;}\n}"
  },
  {
    "function_name": "srcfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "133-155",
    "snippet": "string srcfile( bodyfnc fnc, const string & type, const string & from ) {\n  string ret( srcfile( fnc ) );\n  if ( ! ret.empty() ) {\n    ret = ( stringutil::form( (ret+\"@%s from %s\").c_str(), type.c_str(), from.c_str() ) );\n    for ( unsigned i = 0; i < ret.size(); ++i ) {\n      switch ( ret[i] ) {\n      case ' ':\n\tret[i] = '_';\n\tbreak;\n      case '<':\n\tret[i] = '[';\n\tbreak;\n      case '>':\n\tret[i] = ']';\n\tbreak;\n      case '*':\n\tret[i] = '+';\n\tbreak;\n      }\n    }\n  }\n  return ret;\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret.size",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stringutil::form",
          "args": [
            "(ret+\"@%s from %s\").c_str()",
            "type.c_str()",
            "from.c_str()"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from.c_str",
          "args": [],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.c_str",
          "args": [],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret.empty",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nstring srcfile( bodyfnc fnc, const string & type, const string & from ) {\n  string ret( srcfile( fnc ) );\n  if ( ! ret.empty() ) {\n    ret = ( stringutil::form( (ret+\"@%s from %s\").c_str(), type.c_str(), from.c_str() ) );\n    for ( unsigned i = 0; i < ret.size(); ++i ) {\n      switch ( ret[i] ) {\n      case ' ':\n\tret[i] = '_';\n\tbreak;\n      case '<':\n\tret[i] = '[';\n\tbreak;\n      case '>':\n\tret[i] = ']';\n\tbreak;\n      case '*':\n\tret[i] = '+';\n\tbreak;\n      }\n    }\n  }\n  return ret;\n}"
  },
  {
    "function_name": "srcfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "121-131",
    "snippet": "string srcfile( bodyfnc fnc ) {\n  static map<bodyfnc,string> _srcfile;\n  if ( _srcfile.empty() ) {\n    _srcfile[construct]       = \"construct\";\n    _srcfile[constructAss]    = \"construct_via_assign\";\n    _srcfile[constructRef]    = \"construct_reference\";\n    _srcfile[constructRefAss] = \"construct_reference_via_assign\";\n    _srcfile[assign]          = \"assign\";\n  }\n  return _srcfile[fnc];\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_srcfile.empty",
          "args": [],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nstring srcfile( bodyfnc fnc ) {\n  static map<bodyfnc,string> _srcfile;\n  if ( _srcfile.empty() ) {\n    _srcfile[construct]       = \"construct\";\n    _srcfile[constructAss]    = \"construct_via_assign\";\n    _srcfile[constructRef]    = \"construct_reference\";\n    _srcfile[constructRefAss] = \"construct_reference_via_assign\";\n    _srcfile[assign]          = \"assign\";\n  }\n  return _srcfile[fnc];\n}"
  },
  {
    "function_name": "assign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "108-117",
    "snippet": "void assign() {\n  PSTR <<\n\" {\\n\"\n\"  from f = new fobj;\"\tLE\n\"  type a = 0;\"\t\tLE\n\"  a = f;\"\t\tLE\n\"  cout << \\\"RESULT: \\\" << a << endl;\"\tLE\n\" }\\n\"\n  << endl;\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [
      "#define LE \" TG;\\n\""
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\n#define LE \" TG;\\n\"\n\nvoid assign() {\n  PSTR <<\n\" {\\n\"\n\"  from f = new fobj;\"\tLE\n\"  type a = 0;\"\t\tLE\n\"  a = f;\"\t\tLE\n\"  cout << \\\"RESULT: \\\" << a << endl;\"\tLE\n\" }\\n\"\n  << endl;\n}"
  },
  {
    "function_name": "constructRefAss",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "98-106",
    "snippet": "void constructRefAss() {\n  PSTR <<\n\" {\\n\"\n\"  from f = new fobj;\"\tLE\n\"  type & a = f;\\n\"\tLE\n\"  cout << \\\"RESULT: \\\" << a << endl;\"\tLE\n\" }\\n\"\n  << endl;\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [
      "#define LE \" TG;\\n\""
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\n#define LE \" TG;\\n\"\n\nvoid constructRefAss() {\n  PSTR <<\n\" {\\n\"\n\"  from f = new fobj;\"\tLE\n\"  type & a = f;\\n\"\tLE\n\"  cout << \\\"RESULT: \\\" << a << endl;\"\tLE\n\" }\\n\"\n  << endl;\n}"
  },
  {
    "function_name": "constructRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "88-96",
    "snippet": "void constructRef() {\n  PSTR <<\n\" {\\n\"\n\"  from f = new fobj;\"\tLE\n\"  type & a( f );\\n\"\tLE\n\"  cout << \\\"RESULT: \\\" << a << endl;\"\tLE\n\" }\\n\"\n  << endl;\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [
      "#define LE \" TG;\\n\""
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\n#define LE \" TG;\\n\"\n\nvoid constructRef() {\n  PSTR <<\n\" {\\n\"\n\"  from f = new fobj;\"\tLE\n\"  type & a( f );\\n\"\tLE\n\"  cout << \\\"RESULT: \\\" << a << endl;\"\tLE\n\" }\\n\"\n  << endl;\n}"
  },
  {
    "function_name": "constructAss",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "78-86",
    "snippet": "void constructAss() {\n  PSTR <<\n\" {\\n\"\n\"  from f = new fobj;\"\tLE\n\"  type a = f; \"\tLE\n\"  cout << \\\"RESULT: \\\" << a << endl;\"\tLE\n\" }\\n\"\n  << endl;\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [
      "#define LE \" TG;\\n\""
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\n#define LE \" TG;\\n\"\n\nvoid constructAss() {\n  PSTR <<\n\" {\\n\"\n\"  from f = new fobj;\"\tLE\n\"  type a = f; \"\tLE\n\"  cout << \\\"RESULT: \\\" << a << endl;\"\tLE\n\" }\\n\"\n  << endl;\n}"
  },
  {
    "function_name": "construct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "68-76",
    "snippet": "void construct() {\n  PSTR <<\n\" {\\n\"\n\"  from f = new fobj;\"\tLE\n\"  type a( f );\"\tLE\n\"  cout << \\\"RESULT: \\\" << a << endl;\"\tLE\n\" }\\n\"\n  << endl;\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [
      "#define LE \" TG;\\n\""
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\n#define LE \" TG;\\n\"\n\nvoid construct() {\n  PSTR <<\n\" {\\n\"\n\"  from f = new fobj;\"\tLE\n\"  type a( f );\"\tLE\n\"  cout << \\\"RESULT: \\\" << a << endl;\"\tLE\n\" }\\n\"\n  << endl;\n}"
  },
  {
    "function_name": "D",
    "container": "D",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "33-36",
    "snippet": "D( const string & Pt, const string & P ) {\n    Ptr = Pt;\n    p = P;\n  }",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nD {\n  D( const string & Pt, const string & P ) {\n      Ptr = Pt;\n      p = P;\n    }\n}"
  },
  {
    "function_name": "assertPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
    "lines": "17-26",
    "snippet": "bool assertPath( const Pathname & path ) {\n  PathInfo ddir( path );\n  if ( ddir.isDir() ) {\n    return true;\n  }\n  if ( assertPath( path.dirname() ) ) {\n    return( PathInfo::mkdir( path ) == 0 );\n  }\n  return false;\n}",
    "includes": [
      "#include \"PtrHier.h\"",
      "#include <y2util/PathInfo.h>",
      "#include <y2util/stringutil.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <string>",
      "#include <list>",
      "#include <map>",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PathInfo::mkdir",
          "args": [
            "path"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assertPath",
          "args": [
            "path.dirname()"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "assertPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/testsuite/test_counted_pointer/tt.cc",
          "lines": "17-26",
          "snippet": "bool assertPath( const Pathname & path ) {\n  PathInfo ddir( path );\n  if ( ddir.isDir() ) {\n    return true;\n  }\n  if ( assertPath( path.dirname() ) ) {\n    return( PathInfo::mkdir( path ) == 0 );\n  }\n  return false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "path.dirname",
          "args": [],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "dirname",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "70-70",
          "snippet": "Pathname    dirname()       const { return dirname( *this ); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  Pathname    dirname()       const { return dirname( *this ); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ddir.isDir",
          "args": [],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "isDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/PathInfo.h",
          "lines": "389-389",
          "snippet": "bool   isDir ()  const { return S_ISDIR( _mode ); }",
          "includes": [
            "#include <y2util/Pathname.h>",
            "#include <map>",
            "#include <set>",
            "#include <list>",
            "#include <iosfwd>",
            "#include <cerrno>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/Pathname.h>\n#include <map>\n#include <set>\n#include <list>\n#include <iosfwd>\n#include <cerrno>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nbool   isDir ()  const { return S_ISDIR( _mode ); }"
        }
      }
    ],
    "contextual_snippet": "#include \"PtrHier.h\"\n#include <y2util/PathInfo.h>\n#include <y2util/stringutil.h>\n#include <y2util/Y2SLog.h>\n#include <string>\n#include <list>\n#include <map>\n#include <fstream>\n#include <iostream>\n\nbool assertPath( const Pathname & path ) {\n  PathInfo ddir( path );\n  if ( ddir.isDir() ) {\n    return true;\n  }\n  if ( assertPath( path.dirname() ) ) {\n    return( PathInfo::mkdir( path ) == 0 );\n  }\n  return false;\n}"
  }
]