[
  {
    "function_name": "unmount",
    "container": "SCRSubAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/scr/src/SCRSubAgent.cc",
    "lines": "103-113",
    "snippet": "void\nSCRSubAgent::unmount ()\n{\n    if (my_comp)\n    {\n\ty2debug (\"Unmounting agent at '%s'\", my_path->toString ().c_str ());\n\tmy_comp->result (YCPVoid ()); // tell server to terminate\n\tdelete my_comp;\n\tmy_comp = 0;\n    }\n}",
    "includes": [
      "#include \"SCRSubAgent.h\"",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "my_comp->result",
          "args": [
            "YCPVoid ()"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "result",
          "container": "Y2ProgramComponent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2/src/Y2ProgramComponent.cc",
          "lines": "141-163",
          "snippet": "void Y2ProgramComponent::result(const YCPValue& result)\n{\n    // It may be, that no evaluate() call has been issued at all\n    // before the call to this function(). This is likely to happen\n    // in the context of the SCR. For each MountAgent() all it\n    // creates the component that handles the certain path. But\n    // if it may well be that some paths are not used in one\n    // run of YaST2. In that case no evaluate() for that agent\n    // has been issued. Therefore at this point the external\n    // program may not have been started after all. So we need\n    // to check, if it's running.\n    \n    if (pid != -1)\n    {\n\tYCPTerm resultterm(\"result\");\n\tresultterm->add(result);\n\tsendToExternal(resultterm);\n\n        y2milestone (\"Sending result: %s\", resultterm->toString ().c_str ());\n\n\tterminateExternalProgram();\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <ycp/YCPCode.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>",
            "#include <ycp/Parser.h>",
            "#include \"Y2ProgramComponent.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <ycp/YCPCode.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include \"Y2ProgramComponent.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n\nY2ProgramComponent {\n  void Y2ProgramComponent::result(const YCPValue& result)\n  {\n      // It may be, that no evaluate() call has been issued at all\n      // before the call to this function(). This is likely to happen\n      // in the context of the SCR. For each MountAgent() all it\n      // creates the component that handles the certain path. But\n      // if it may well be that some paths are not used in one\n      // run of YaST2. In that case no evaluate() for that agent\n      // has been issued. Therefore at this point the external\n      // program may not have been started after all. So we need\n      // to check, if it's running.\n      \n      if (pid != -1)\n      {\n  \tYCPTerm resultterm(\"result\");\n  \tresultterm->add(result);\n  \tsendToExternal(resultterm);\n  \n          y2milestone (\"Sending result: %s\", resultterm->toString ().c_str ());\n  \n  \tterminateExternalProgram();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Unmounting agent at '%s'\"",
            "my_path->toString ().c_str ()"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_path->toString",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"SCRSubAgent.h\"\n#include <y2/Y2ComponentBroker.h>\n#include <ycp/y2log.h>\n\nSCRSubAgent {\n  void\n  SCRSubAgent::unmount ()\n  {\n      if (my_comp)\n      {\n  \ty2debug (\"Unmounting agent at '%s'\", my_path->toString ().c_str ());\n  \tmy_comp->result (YCPVoid ()); // tell server to terminate\n  \tdelete my_comp;\n  \tmy_comp = 0;\n      }\n  }\n}"
  },
  {
    "function_name": "mount",
    "container": "SCRSubAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/scr/src/SCRSubAgent.cc",
    "lines": "42-100",
    "snippet": "YCPValue\nSCRSubAgent::mount (SCRAgent *parent)\n{\n    if (!my_comp)\n    {\n\ty2debug (\"Mounting agent at '%s'\", my_path->toString ().c_str ());\n\n\t// get term with description or something like that\n\tYCPTerm term = YCPTerm (YCPNull ());\n\tif (my_value->isString ())\n\t{\n\t    YCPValue confval = parent->readconf (my_value->asString ()->value_cstr ());\n\t    if (confval.isNull () || !confval->isTerm ())\n\t    {\n\t\treturn confval;\n\t    }\n\t    term = confval->asTerm ();\n\t}\n\telse if (my_value->isTerm ())\n\t{\n\t    term = my_value->asTerm ();\n\t}\n\telse\n\t{\n\t    ycp2error (\"value has wrong type\");\n\t    return YCPBoolean (false);\n\t}\n\n\tif (term.isNull ())\n\t{\n\t    ycp2error (\"term is null\");\n\t    return YCPBoolean (false);\n\t}\n\n\tstring componentname = term->name ();\n\tmy_comp = Y2ComponentBroker::createServer (componentname.c_str ());\n\n\tif (!my_comp)\n\t{\n\t    ycp2error (\"Can't find component '%s'\", componentname.c_str ());\n\t    return YCPBoolean (false);\n\t}\n\n\t// set mainscragent of new agent\n\tSCRAgent *tmpscragent = my_comp->getSCRAgent ();\n\tif (tmpscragent)\n\t{\n\t    tmpscragent->mainscragent = parent;\n\t}\n\n\t// term's arguments are preloaded into the server component\n\tfor (int i = 0; i < term->size (); i++)\n\t{\n\t    my_comp->evaluate (term->value (i));\n\t}\n    }\n\n    return YCPBoolean (true);\n}",
    "includes": [
      "#include \"SCRSubAgent.h\"",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "true"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "my_comp->evaluate",
          "args": [
            "term->value (i)"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Y2AgentComp<Agent>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "91-166",
          "snippet": "YCPValue\nY2AgentComp<Agent>::evaluate (const YCPValue& v)\n{\n    y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n\n    if (!agent)\n\tgetSCRAgent ();\n\n    y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n\t\n    YCPValue value = v;\n    if (value->isCode ())\n    {\n\tYCodePtr c = v->asCode ()->code ();\n\n\t\n\tif ( c->kind () != YCode::yeTerm)\n\t{\n\t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n\t    value = value->asCode ()->evaluate ();\n\t    return value;\n\t}\n\n\tvalue = value->asCode ()->evaluate ();\n    }\n\t\n    if (value.isNull () || value->isVoid ())\n\treturn value;\n\n    y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n\n    if( value->isTerm () ) {\n\tYCPTerm term = value ->asTerm ();\n\tstring command = term->name ();\n\tYCPList args = term->args ();\n\n\t// evaluate the term in native functions\n\tif( command == \"Read\" ) {\n\t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n\t}\n\telse if( command == \"Write\" ) {\n\t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n\t}\n\telse if( command == \"Dir\" ) {\n\t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Error\" ) {\n\t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n\t}\n\telse if( command == \"Execute\" ) {\n\t    y2debug( \"Execute, arg size is %d\", args->size() );\n\t    switch( args->size() ) {\n\t\tcase 1:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n\t\tcase 2:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n\t\tdefault:\n\t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n\t    }\n\t}\n\telse {\n\t    y2debug( \"Passing term to otherCommand\" );\n\t    return getSCRAgent ()-> otherCommand (term);\n\t}\n    }\n#if 0\n    if( value->isCode () ) {\n\ty2debug( \"Passing (evaluated) code to otherCommand\" );\n\treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n    }\n#endif\n\n    y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n\n    return YCPVoid();\n}",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp<Agent> {\n  YCPValue\n  Y2AgentComp<Agent>::evaluate (const YCPValue& v)\n  {\n      y2debug (\"evaluate (%s)\", v->toString ().c_str ());\n  \n      if (!agent)\n  \tgetSCRAgent ();\n  \n      y2debug (\"Going to evaluate %s\", v->toString ().c_str ());\n  \t\n      YCPValue value = v;\n      if (value->isCode ())\n      {\n  \tYCodePtr c = v->asCode ()->code ();\n  \n  \t\n  \tif ( c->kind () != YCode::yeTerm)\n  \t{\n  \t    y2milestone (\"Evaluating an expression, not SCR builtin\");\n  \t    value = value->asCode ()->evaluate ();\n  \t    return value;\n  \t}\n  \n  \tvalue = value->asCode ()->evaluate ();\n      }\n  \t\n      if (value.isNull () || value->isVoid ())\n  \treturn value;\n  \n      y2debug (\"After code evaluation: %s\", value->toString ().c_str ());\n  \n      if( value->isTerm () ) {\n  \tYCPTerm term = value ->asTerm ();\n  \tstring command = term->name ();\n  \tYCPList args = term->args ();\n  \n  \t// evaluate the term in native functions\n  \tif( command == \"Read\" ) {\n  \t    return getSCRAgent ()-> Read (args->value (0)->asPath (), args->size() > 1 ? args->value (1) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Write\" ) {\n  \t    return getSCRAgent ()-> Write (args->value (0)->asPath (), args->value (1), args->size () > 2 ? args->value (2) : YCPNull ()) ;\n  \t}\n  \telse if( command == \"Dir\" ) {\n  \t    return getSCRAgent ()-> Dir (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Error\" ) {\n  \t    return getSCRAgent ()-> Error (args->value (0)->asPath ()) ;\n  \t}\n  \telse if( command == \"Execute\" ) {\n  \t    y2debug( \"Execute, arg size is %d\", args->size() );\n  \t    switch( args->size() ) {\n  \t\tcase 1:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath ()) ;\n  \t\tcase 2:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1)) ;\n  \t\tdefault:\n  \t\t    return getSCRAgent ()-> Execute (args->value (0)->asPath (), args->value (1), args->value (2)) ;\n  \t    }\n  \t}\n  \telse {\n  \t    y2debug( \"Passing term to otherCommand\" );\n  \t    return getSCRAgent ()-> otherCommand (term);\n  \t}\n      }\n  #if 0\n      if( value->isCode () ) {\n  \ty2debug( \"Passing (evaluated) code to otherCommand\" );\n  \treturn getSCRAgent ()-> otherCommand (value->asCode ()->evaluate ()->asTerm ());\n      }\n  #endif\n  \n      y2error( \"Unhandled value (%s): %s\", value->valuetype_str (), value->toString ().c_str () );\n  \n      return YCPVoid();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->value",
          "args": [
            "i"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "term->size",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "my_comp->getSCRAgent",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Can't find component '%s'\"",
            "componentname.c_str ()"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "componentname.c_str",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y2ComponentBroker::createServer",
          "args": [
            "componentname.c_str ()"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "componentname.c_str",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term->name",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Y2AgentComp",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/include/scr/Y2AgentComponent.h",
          "lines": "44-44",
          "snippet": "string name () const { return my_name; }",
          "includes": [
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPCode.h>",
            "#include <y2/Y2Component.h>",
            "#include <ycp/YCPTerm.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ycp/YCPTerm.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPCode.h>\n#include <y2/Y2Component.h>\n#include <ycp/YCPTerm.h>\n#include <ycp/y2log.h>\n\nY2AgentComp {\n  string name () const { return my_name; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"term is null\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "term.isNull",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"value has wrong type\""
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_value->asTerm",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "my_value->isTerm",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "isTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "70-70",
          "snippet": "bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isTerm()        const { return valuetype() == YT_TERM; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "confval.isNull",
          "args": [],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent->readconf",
          "args": [
            "my_value->asString ()->value_cstr ()"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "readconf",
          "container": "SCRAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libscr/src/SCRAgent.cc",
          "lines": "73-108",
          "snippet": "YCPValue\nSCRAgent::readconf (const char *filename)\n{\n    FILE *file = fopen (filename, \"r\");\n    if (!file)\n    {\n\tycp2error (\"Can't open %s for reading.\", filename);\n\treturn YCPNull ();\n    }\n\n    // find first line starting with \".\"\n    const int size = 250;\n    char line[size];\n    char *fgets_result;\n    do\n    {\n\tfgets_result = fgets (line, size, file);\n    }\n    while ((fgets_result != 0) && (line[0] != '.'));\n\n    Parser parser (file, filename);\n    YCodePtr tmpvalue = parser.parse ();\n    fclose (file);\n\n    y2debug( \"Parsed value '%s'\", tmpvalue != 0 ? tmpvalue->toString().c_str() : \"not available\" );\n    if (tmpvalue == 0 || tmpvalue->kind () != YCode::yeTerm )\n    {\n\tycp2error (\"Not a term in scr file.\");\n\treturn YCPNull();\n    }\n\n    // it is a term, generate YCPValue through its evaluation\n    YCPValue ret = tmpvalue->evaluate();\n\n    return ret;\n}",
          "includes": [
            "#include \"ycp/YCode.h\"",
            "#include \"ycp/Parser.h\"",
            "#include \"include/scr/SCR.h\"",
            "#include \"include/scr/SCRAgent.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCode.h\"\n#include \"ycp/Parser.h\"\n#include \"include/scr/SCR.h\"\n#include \"include/scr/SCRAgent.h\"\n#include <ycp/y2log.h>\n\nSCRAgent {\n  YCPValue\n  SCRAgent::readconf (const char *filename)\n  {\n      FILE *file = fopen (filename, \"r\");\n      if (!file)\n      {\n  \tycp2error (\"Can't open %s for reading.\", filename);\n  \treturn YCPNull ();\n      }\n  \n      // find first line starting with \".\"\n      const int size = 250;\n      char line[size];\n      char *fgets_result;\n      do\n      {\n  \tfgets_result = fgets (line, size, file);\n      }\n      while ((fgets_result != 0) && (line[0] != '.'));\n  \n      Parser parser (file, filename);\n      YCodePtr tmpvalue = parser.parse ();\n      fclose (file);\n  \n      y2debug( \"Parsed value '%s'\", tmpvalue != 0 ? tmpvalue->toString().c_str() : \"not available\" );\n      if (tmpvalue == 0 || tmpvalue->kind () != YCode::yeTerm )\n      {\n  \tycp2error (\"Not a term in scr file.\");\n  \treturn YCPNull();\n      }\n  \n      // it is a term, generate YCPValue through its evaluation\n      YCPValue ret = tmpvalue->evaluate();\n  \n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "my_value->asString",
          "args": [],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "my_value->isString",
          "args": [],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPTerm",
          "args": [
            "YCPNull ()"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "YCPTerm",
          "container": "YCPTerm",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "178-194",
          "snippet": "YCPTerm::YCPTerm (bytecodeistream & str)\n    : YCPValue (YCPTerm(\"no-name-so-far\"))\n{\n    string s;\n    if (Bytecode::readString (str, s))\n    {\n\tYCPList list (str);\n\tif (!list.isNull())\n\t{\n\t    (const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->setName(s);\n\t    for (int i = 0 ; i < list->size () ; i++)\n\t    {\n\t\t(const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->add (list->value (i));\n\t    }\n\t}\n    }\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTerm {\n  YCPTerm::YCPTerm (bytecodeistream & str)\n      : YCPValue (YCPTerm(\"no-name-so-far\"))\n  {\n      string s;\n      if (Bytecode::readString (str, s))\n      {\n  \tYCPList list (str);\n  \tif (!list.isNull())\n  \t{\n  \t    (const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->setName(s);\n  \t    for (int i = 0 ; i < list->size () ; i++)\n  \t    {\n  \t\t(const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->add (list->value (i));\n  \t    }\n  \t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y2debug",
          "args": [
            "\"Mounting agent at '%s'\"",
            "my_path->toString ().c_str ()"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_path->toString",
          "args": [],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "YBreakpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YBreakpoint.cc",
          "lines": "87-91",
          "snippet": "string\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBreakpoint.h\"",
            "#include <debugger/Debugger.h>",
            "#include <libintl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBreakpoint.h\"\n#include <debugger/Debugger.h>\n#include <libintl.h>\n\nYBreakpoint {\n  string\n  YBreakpoint::toString() const\n  {\n      return m_code->toString ();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"SCRSubAgent.h\"\n#include <y2/Y2ComponentBroker.h>\n#include <ycp/y2log.h>\n\nSCRSubAgent {\n  YCPValue\n  SCRSubAgent::mount (SCRAgent *parent)\n  {\n      if (!my_comp)\n      {\n  \ty2debug (\"Mounting agent at '%s'\", my_path->toString ().c_str ());\n  \n  \t// get term with description or something like that\n  \tYCPTerm term = YCPTerm (YCPNull ());\n  \tif (my_value->isString ())\n  \t{\n  \t    YCPValue confval = parent->readconf (my_value->asString ()->value_cstr ());\n  \t    if (confval.isNull () || !confval->isTerm ())\n  \t    {\n  \t\treturn confval;\n  \t    }\n  \t    term = confval->asTerm ();\n  \t}\n  \telse if (my_value->isTerm ())\n  \t{\n  \t    term = my_value->asTerm ();\n  \t}\n  \telse\n  \t{\n  \t    ycp2error (\"value has wrong type\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tif (term.isNull ())\n  \t{\n  \t    ycp2error (\"term is null\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tstring componentname = term->name ();\n  \tmy_comp = Y2ComponentBroker::createServer (componentname.c_str ());\n  \n  \tif (!my_comp)\n  \t{\n  \t    ycp2error (\"Can't find component '%s'\", componentname.c_str ());\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \t// set mainscragent of new agent\n  \tSCRAgent *tmpscragent = my_comp->getSCRAgent ();\n  \tif (tmpscragent)\n  \t{\n  \t    tmpscragent->mainscragent = parent;\n  \t}\n  \n  \t// term's arguments are preloaded into the server component\n  \tfor (int i = 0; i < term->size (); i++)\n  \t{\n  \t    my_comp->evaluate (term->value (i));\n  \t}\n      }\n  \n      return YCPBoolean (true);\n  }\n}"
  },
  {
    "function_name": "~SCRSubAgent",
    "container": "SCRSubAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/scr/src/SCRSubAgent.cc",
    "lines": "36-39",
    "snippet": "SCRSubAgent::~SCRSubAgent ()\n{\n    unmount ();\n}",
    "includes": [
      "#include \"SCRSubAgent.h\"",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmount",
          "args": [],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "unmount",
          "container": "SCRSubAgent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/scr/src/SCRSubAgent.cc",
          "lines": "103-113",
          "snippet": "void\nSCRSubAgent::unmount ()\n{\n    if (my_comp)\n    {\n\ty2debug (\"Unmounting agent at '%s'\", my_path->toString ().c_str ());\n\tmy_comp->result (YCPVoid ()); // tell server to terminate\n\tdelete my_comp;\n\tmy_comp = 0;\n    }\n}",
          "includes": [
            "#include \"SCRSubAgent.h\"",
            "#include <y2/Y2ComponentBroker.h>",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"SCRSubAgent.h\"\n#include <y2/Y2ComponentBroker.h>\n#include <ycp/y2log.h>\n\nSCRSubAgent {\n  void\n  SCRSubAgent::unmount ()\n  {\n      if (my_comp)\n      {\n  \ty2debug (\"Unmounting agent at '%s'\", my_path->toString ().c_str ());\n  \tmy_comp->result (YCPVoid ()); // tell server to terminate\n  \tdelete my_comp;\n  \tmy_comp = 0;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"SCRSubAgent.h\"\n#include <y2/Y2ComponentBroker.h>\n#include <ycp/y2log.h>\n\nSCRSubAgent {\n  SCRSubAgent::~SCRSubAgent ()\n  {\n      unmount ();\n  }\n}"
  },
  {
    "function_name": "SCRSubAgent",
    "container": "SCRSubAgent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/scr/src/SCRSubAgent.cc",
    "lines": "28-33",
    "snippet": "SCRSubAgent::SCRSubAgent (YCPPath path, YCPValue value)\n    : my_path (path),\n      my_value (value),\n      my_comp (0)\n{\n}",
    "includes": [
      "#include \"SCRSubAgent.h\"",
      "#include <y2/Y2ComponentBroker.h>",
      "#include <ycp/y2log.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"SCRSubAgent.h\"\n#include <y2/Y2ComponentBroker.h>\n#include <ycp/y2log.h>\n\nSCRSubAgent {\n  SCRSubAgent::SCRSubAgent (YCPPath path, YCPValue value)\n      : my_path (path),\n        my_value (value),\n        my_comp (0)\n  {\n  }\n}"
  }
]