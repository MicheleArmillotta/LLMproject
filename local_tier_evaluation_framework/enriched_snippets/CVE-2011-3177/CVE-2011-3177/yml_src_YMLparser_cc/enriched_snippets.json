[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/yml/src/YMLparser.cc",
    "lines": "225-277",
    "snippet": "int main( void )\n{\n    xmlDocPtr xmldoc;\n    xmlNodePtr current;\n\n    xmldoc = xmlParseFile(TESTFILE);\n\n    if (xmldoc == NULL)\n    {\n        fprintf(stderr, \"error: could not parse document.\\n\");\n        return 0;\n    }\n\n    current = xmlDocGetRootElement(xmldoc);\n\n    if (current == NULL)\n    {\n        fprintf(stderr, \"info: document is empty.\\n\");\n        xmlFreeDoc(xmldoc);\n        return 0;\n    }\n\n    if ( xmlStrcmp(current->name, (const xmlChar*) \"YML\") )\n    {\n       fprintf(stderr, \"error: wrong document type, root node YML expected\"); \n       xmlFreeDoc(xmldoc); \n       return 0;\n    }\n\n   // fprintf(stderr, \"success: obviously parsing the document worked quite fine!\\n\");\n\n    YCPValue yt;\n    //yt = YMLParser(current);\n    printf(\"{\\n\\n%s\\n}\", YMLDocumentParser(current).c_str() );\n\n\n/*  temporary disabled\n    if ( yt.isNull() ) printf(\"yt is NULL\\n\");\n    else\n    {\n        // printf(\" yt is not NULL\\n\");\n        if ( yt->isVoid() )\n        {\n            printf(\"yt is VOID\\n\");\n            return 0;\n        }\n        else printf(\"\\n%s\\n\", yt->toString().c_str() );\n    }\n*/\n\n    xmlFreeDoc(xmldoc);\n    return 0;\n}",
    "includes": [
      "#include <string>",
      "#include <libxml2/libxml/xmlstring.h>",
      "#include <libxml2/libxml/parser.h>",
      "#include <libxml2/libxml/xmlreader.h>",
      "#include <libxml2/libxml/tree.h>",
      "#include <ycp/YCPString.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPValue.h>",
      "#include <ycp/YCPTerm.h>"
    ],
    "macros_used": [
      "#define TESTFILE    \"test/minitest.xml\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xmldoc"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"{\\n\\n%s\\n}\"",
            "YMLDocumentParser(current).c_str()"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YMLDocumentParser",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YMLDocumentParser",
          "args": [
            "current"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "YMLDocumentParser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/yml/src/YMLparser.cc",
          "lines": "162-193",
          "snippet": "string YMLDocumentParser(xmlNodePtr &node)\n{\n    if ( xmlStrcmp(node->name, (const xmlChar*) \"YML\") )\n    {   printf(\"no yml-tag found\\n\"); \n        exit (0);\n    }\n\n    xmlNodePtr commands;\n    commands=node->children;\n    string commandString;\n    string subtree;\n\n    for ( ; commands ;  commands=commands->next)\n    {\n        if ( !xmlStrcmp(commands->name, (const xmlChar*) \"command\") )\n        {\n            // we found a command node - lets create a string\n\n            commandString += \"UI::\";\n            commandString += (char*) xmlGetProp(commands, (const xmlChar*) \"action\");\n            commandString += \"(\";\n\n            //subtree = xml2ycp(commands->children);\n            subtree = YMLParser(commands->children);\n            commandString += subtree;\n\n            commandString += \");\\n\";\n        }\n\n    }\n    return commandString;\n}",
          "includes": [
            "#include <string>",
            "#include <libxml2/libxml/xmlstring.h>",
            "#include <libxml2/libxml/parser.h>",
            "#include <libxml2/libxml/xmlreader.h>",
            "#include <libxml2/libxml/tree.h>",
            "#include <ycp/YCPString.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPValue.h>",
            "#include <ycp/YCPTerm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <libxml2/libxml/xmlstring.h>\n#include <libxml2/libxml/parser.h>\n#include <libxml2/libxml/xmlreader.h>\n#include <libxml2/libxml/tree.h>\n#include <ycp/YCPString.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPValue.h>\n#include <ycp/YCPTerm.h>\n\nstring YMLDocumentParser(xmlNodePtr &node)\n{\n    if ( xmlStrcmp(node->name, (const xmlChar*) \"YML\") )\n    {   printf(\"no yml-tag found\\n\"); \n        exit (0);\n    }\n\n    xmlNodePtr commands;\n    commands=node->children;\n    string commandString;\n    string subtree;\n\n    for ( ; commands ;  commands=commands->next)\n    {\n        if ( !xmlStrcmp(commands->name, (const xmlChar*) \"command\") )\n        {\n            // we found a command node - lets create a string\n\n            commandString += \"UI::\";\n            commandString += (char*) xmlGetProp(commands, (const xmlChar*) \"action\");\n            commandString += \"(\";\n\n            //subtree = xml2ycp(commands->children);\n            subtree = YMLParser(commands->children);\n            commandString += subtree;\n\n            commandString += \");\\n\";\n        }\n\n    }\n    return commandString;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xmldoc"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"error: wrong document type, root node YML expected\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrcmp",
          "args": [
            "current->name",
            "(const xmlChar*) \"YML\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xmldoc"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"info: document is empty.\\n\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "xmldoc"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"error: could not parse document.\\n\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlParseFile",
          "args": [
            "TESTFILE"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string>\n#include <libxml2/libxml/xmlstring.h>\n#include <libxml2/libxml/parser.h>\n#include <libxml2/libxml/xmlreader.h>\n#include <libxml2/libxml/tree.h>\n#include <ycp/YCPString.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPValue.h>\n#include <ycp/YCPTerm.h>\n\n#define TESTFILE    \"test/minitest.xml\"\n\nint main( void )\n{\n    xmlDocPtr xmldoc;\n    xmlNodePtr current;\n\n    xmldoc = xmlParseFile(TESTFILE);\n\n    if (xmldoc == NULL)\n    {\n        fprintf(stderr, \"error: could not parse document.\\n\");\n        return 0;\n    }\n\n    current = xmlDocGetRootElement(xmldoc);\n\n    if (current == NULL)\n    {\n        fprintf(stderr, \"info: document is empty.\\n\");\n        xmlFreeDoc(xmldoc);\n        return 0;\n    }\n\n    if ( xmlStrcmp(current->name, (const xmlChar*) \"YML\") )\n    {\n       fprintf(stderr, \"error: wrong document type, root node YML expected\"); \n       xmlFreeDoc(xmldoc); \n       return 0;\n    }\n\n   // fprintf(stderr, \"success: obviously parsing the document worked quite fine!\\n\");\n\n    YCPValue yt;\n    //yt = YMLParser(current);\n    printf(\"{\\n\\n%s\\n}\", YMLDocumentParser(current).c_str() );\n\n\n/*  temporary disabled\n    if ( yt.isNull() ) printf(\"yt is NULL\\n\");\n    else\n    {\n        // printf(\" yt is not NULL\\n\");\n        if ( yt->isVoid() )\n        {\n            printf(\"yt is VOID\\n\");\n            return 0;\n        }\n        else printf(\"\\n%s\\n\", yt->toString().c_str() );\n    }\n*/\n\n    xmlFreeDoc(xmldoc);\n    return 0;\n}"
  },
  {
    "function_name": "YMLDocumentParser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/yml/src/YMLparser.cc",
    "lines": "162-193",
    "snippet": "string YMLDocumentParser(xmlNodePtr &node)\n{\n    if ( xmlStrcmp(node->name, (const xmlChar*) \"YML\") )\n    {   printf(\"no yml-tag found\\n\"); \n        exit (0);\n    }\n\n    xmlNodePtr commands;\n    commands=node->children;\n    string commandString;\n    string subtree;\n\n    for ( ; commands ;  commands=commands->next)\n    {\n        if ( !xmlStrcmp(commands->name, (const xmlChar*) \"command\") )\n        {\n            // we found a command node - lets create a string\n\n            commandString += \"UI::\";\n            commandString += (char*) xmlGetProp(commands, (const xmlChar*) \"action\");\n            commandString += \"(\";\n\n            //subtree = xml2ycp(commands->children);\n            subtree = YMLParser(commands->children);\n            commandString += subtree;\n\n            commandString += \");\\n\";\n        }\n\n    }\n    return commandString;\n}",
    "includes": [
      "#include <string>",
      "#include <libxml2/libxml/xmlstring.h>",
      "#include <libxml2/libxml/parser.h>",
      "#include <libxml2/libxml/xmlreader.h>",
      "#include <libxml2/libxml/tree.h>",
      "#include <ycp/YCPString.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPValue.h>",
      "#include <ycp/YCPTerm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YMLParser",
          "args": [
            "commands->children"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "YMLParser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/yml/src/YMLparser.cc",
          "lines": "143-157",
          "snippet": "string YMLParser(xmlNodePtr &node)\n{\n    YCPList ymlList;\n    ymlList = xml2ycp(node);\n    string ycpString=\"\";\n\n    for(int i=0; i<=ymlList->size() ; i++ )\n        if ( !ymlList->value(i).isNull() && !ymlList->value(i)->isVoid() )\n        {\n            ycpString += ymlList->value(i)->toString().c_str();\n            if (i != ymlList->size()-1) ycpString += \", \";\n        }\n\n    return ycpString;\n}",
          "includes": [
            "#include <string>",
            "#include <libxml2/libxml/xmlstring.h>",
            "#include <libxml2/libxml/parser.h>",
            "#include <libxml2/libxml/xmlreader.h>",
            "#include <libxml2/libxml/tree.h>",
            "#include <ycp/YCPString.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPValue.h>",
            "#include <ycp/YCPTerm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <libxml2/libxml/xmlstring.h>\n#include <libxml2/libxml/parser.h>\n#include <libxml2/libxml/xmlreader.h>\n#include <libxml2/libxml/tree.h>\n#include <ycp/YCPString.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPValue.h>\n#include <ycp/YCPTerm.h>\n\nstring YMLParser(xmlNodePtr &node)\n{\n    YCPList ymlList;\n    ymlList = xml2ycp(node);\n    string ycpString=\"\";\n\n    for(int i=0; i<=ymlList->size() ; i++ )\n        if ( !ymlList->value(i).isNull() && !ymlList->value(i)->isVoid() )\n        {\n            ycpString += ymlList->value(i)->toString().c_str();\n            if (i != ymlList->size()-1) ycpString += \", \";\n        }\n\n    return ycpString;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlGetProp",
          "args": [
            "commands",
            "(const xmlChar*) \"action\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrcmp",
          "args": [
            "commands->name",
            "(const xmlChar*) \"command\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"no yml-tag found\\n\""
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrcmp",
          "args": [
            "node->name",
            "(const xmlChar*) \"YML\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string>\n#include <libxml2/libxml/xmlstring.h>\n#include <libxml2/libxml/parser.h>\n#include <libxml2/libxml/xmlreader.h>\n#include <libxml2/libxml/tree.h>\n#include <ycp/YCPString.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPValue.h>\n#include <ycp/YCPTerm.h>\n\nstring YMLDocumentParser(xmlNodePtr &node)\n{\n    if ( xmlStrcmp(node->name, (const xmlChar*) \"YML\") )\n    {   printf(\"no yml-tag found\\n\"); \n        exit (0);\n    }\n\n    xmlNodePtr commands;\n    commands=node->children;\n    string commandString;\n    string subtree;\n\n    for ( ; commands ;  commands=commands->next)\n    {\n        if ( !xmlStrcmp(commands->name, (const xmlChar*) \"command\") )\n        {\n            // we found a command node - lets create a string\n\n            commandString += \"UI::\";\n            commandString += (char*) xmlGetProp(commands, (const xmlChar*) \"action\");\n            commandString += \"(\";\n\n            //subtree = xml2ycp(commands->children);\n            subtree = YMLParser(commands->children);\n            commandString += subtree;\n\n            commandString += \");\\n\";\n        }\n\n    }\n    return commandString;\n}"
  },
  {
    "function_name": "YMLParser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/yml/src/YMLparser.cc",
    "lines": "143-157",
    "snippet": "string YMLParser(xmlNodePtr &node)\n{\n    YCPList ymlList;\n    ymlList = xml2ycp(node);\n    string ycpString=\"\";\n\n    for(int i=0; i<=ymlList->size() ; i++ )\n        if ( !ymlList->value(i).isNull() && !ymlList->value(i)->isVoid() )\n        {\n            ycpString += ymlList->value(i)->toString().c_str();\n            if (i != ymlList->size()-1) ycpString += \", \";\n        }\n\n    return ycpString;\n}",
    "includes": [
      "#include <string>",
      "#include <libxml2/libxml/xmlstring.h>",
      "#include <libxml2/libxml/parser.h>",
      "#include <libxml2/libxml/xmlreader.h>",
      "#include <libxml2/libxml/tree.h>",
      "#include <ycp/YCPString.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPValue.h>",
      "#include <ycp/YCPTerm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ymlList->size",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ymlList->value",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ymlList->value",
          "args": [
            "i"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "xml2ycp",
          "args": [
            "node"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "xml2ycp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/yml/src/YMLparser.cc",
          "lines": "65-140",
          "snippet": "YCPList xml2ycp(xmlNode * node, bool symbol = false)\n{\n    xmlNode *cur_node = node;\n    YCPList ymlList;\n\n    for (  ; cur_node ; cur_node = cur_node->next)\n    {\n        YCPValue newelement;\n        YCPList childs;\n        newelement = YCPVoid();\n\n        // identify kind of element; create a YCPValue\n        switch (cur_node->type)\n        {\n            case XML_ELEMENT_NODE       :\n   \n                  if ( !xmlStrcmp(cur_node->name,  (const xmlChar*) \"symbol\" ) ) {\n                      char *prop = (char*) xmlGetProp(cur_node, (const xmlChar *)\"name\");\n                      if (prop)\n                        newelement = YCPSymbol( prop );\n                      else {\n                        fprintf (stderr, \"Error! Symbol without a name!\\n\");\n                        newelement = YCPVoid();\n                      }\n                  }\n                  else newelement = YCPTerm(  (char*) cur_node->name );\n                  break;\n\n            case XML_ATTRIBUTE_NODE     :\n                  newelement = YCPVoid();\n                  break;\n\n            case XML_TEXT_NODE          :\n                  if ( xmlIsBlankNode(cur_node) )\n                      newelement = YCPVoid();\n                  else newelement = YCPString( (char*) cur_node->content );\n                      break;\n\n            case XML_CDATA_SECTION_NODE : newelement = YCPVoid(); break;\n                  // cur_node->content);\n\n            case XML_ENTITY_REF_NODE    : newelement = YCPVoid(); break;\n            case XML_ENTITY_NODE        : newelement = YCPVoid(); break;\n            case XML_PI_NODE            : newelement = YCPVoid(); break;\n            case XML_COMMENT_NODE       : newelement = YCPVoid(); break;\n            case XML_DOCUMENT_NODE      : newelement = YCPVoid(); break;\n            case XML_DOCUMENT_TYPE_NODE : newelement = YCPVoid(); break;\n            case XML_DOCUMENT_FRAG_NODE : newelement = YCPVoid(); break;\n            case XML_NOTATION_NODE      : newelement = YCPVoid(); break;\n            case XML_HTML_DOCUMENT_NODE : newelement = YCPVoid(); break;\n            case XML_DTD_NODE           : newelement = YCPVoid(); break;\n            case XML_ELEMENT_DECL       : newelement = YCPVoid(); break;\n            case XML_ATTRIBUTE_DECL     : newelement = YCPVoid(); break;\n            case XML_ENTITY_DECL        : newelement = YCPVoid(); break;\n            case XML_NAMESPACE_DECL     : newelement = YCPVoid(); break;\n            case XML_XINCLUDE_START     : newelement = YCPVoid(); break;\n            case XML_XINCLUDE_END       : newelement = YCPVoid(); break;\n            case XML_DOCB_DOCUMENT_NODE : newelement = YCPVoid(); break;\n            default                     : newelement = YCPVoid(); break;\n        }\n\n\n        // now we've got to add the found element to our ymlList\n        if ( !newelement.isNull() )\n        {\n            // at first - get the elements childs\n            childs = xml2ycp(cur_node->children);\n\n            if ( ! childs.isEmpty() )\n                for (int i=0; i < childs.size(); i++ )\n                    newelement = newelement->asTerm()->functionalAdd( childs->value(i) );\n            if ( !newelement->isVoid() ) ymlList.add( newelement );\n        }\n    }\n    return ymlList;\n}",
          "includes": [
            "#include <string>",
            "#include <libxml2/libxml/xmlstring.h>",
            "#include <libxml2/libxml/parser.h>",
            "#include <libxml2/libxml/xmlreader.h>",
            "#include <libxml2/libxml/tree.h>",
            "#include <ycp/YCPString.h>",
            "#include <ycp/YCPVoid.h>",
            "#include <ycp/YCPValue.h>",
            "#include <ycp/YCPTerm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <libxml2/libxml/xmlstring.h>\n#include <libxml2/libxml/parser.h>\n#include <libxml2/libxml/xmlreader.h>\n#include <libxml2/libxml/tree.h>\n#include <ycp/YCPString.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPValue.h>\n#include <ycp/YCPTerm.h>\n\nYCPList xml2ycp(xmlNode * node, bool symbol = false)\n{\n    xmlNode *cur_node = node;\n    YCPList ymlList;\n\n    for (  ; cur_node ; cur_node = cur_node->next)\n    {\n        YCPValue newelement;\n        YCPList childs;\n        newelement = YCPVoid();\n\n        // identify kind of element; create a YCPValue\n        switch (cur_node->type)\n        {\n            case XML_ELEMENT_NODE       :\n   \n                  if ( !xmlStrcmp(cur_node->name,  (const xmlChar*) \"symbol\" ) ) {\n                      char *prop = (char*) xmlGetProp(cur_node, (const xmlChar *)\"name\");\n                      if (prop)\n                        newelement = YCPSymbol( prop );\n                      else {\n                        fprintf (stderr, \"Error! Symbol without a name!\\n\");\n                        newelement = YCPVoid();\n                      }\n                  }\n                  else newelement = YCPTerm(  (char*) cur_node->name );\n                  break;\n\n            case XML_ATTRIBUTE_NODE     :\n                  newelement = YCPVoid();\n                  break;\n\n            case XML_TEXT_NODE          :\n                  if ( xmlIsBlankNode(cur_node) )\n                      newelement = YCPVoid();\n                  else newelement = YCPString( (char*) cur_node->content );\n                      break;\n\n            case XML_CDATA_SECTION_NODE : newelement = YCPVoid(); break;\n                  // cur_node->content);\n\n            case XML_ENTITY_REF_NODE    : newelement = YCPVoid(); break;\n            case XML_ENTITY_NODE        : newelement = YCPVoid(); break;\n            case XML_PI_NODE            : newelement = YCPVoid(); break;\n            case XML_COMMENT_NODE       : newelement = YCPVoid(); break;\n            case XML_DOCUMENT_NODE      : newelement = YCPVoid(); break;\n            case XML_DOCUMENT_TYPE_NODE : newelement = YCPVoid(); break;\n            case XML_DOCUMENT_FRAG_NODE : newelement = YCPVoid(); break;\n            case XML_NOTATION_NODE      : newelement = YCPVoid(); break;\n            case XML_HTML_DOCUMENT_NODE : newelement = YCPVoid(); break;\n            case XML_DTD_NODE           : newelement = YCPVoid(); break;\n            case XML_ELEMENT_DECL       : newelement = YCPVoid(); break;\n            case XML_ATTRIBUTE_DECL     : newelement = YCPVoid(); break;\n            case XML_ENTITY_DECL        : newelement = YCPVoid(); break;\n            case XML_NAMESPACE_DECL     : newelement = YCPVoid(); break;\n            case XML_XINCLUDE_START     : newelement = YCPVoid(); break;\n            case XML_XINCLUDE_END       : newelement = YCPVoid(); break;\n            case XML_DOCB_DOCUMENT_NODE : newelement = YCPVoid(); break;\n            default                     : newelement = YCPVoid(); break;\n        }\n\n\n        // now we've got to add the found element to our ymlList\n        if ( !newelement.isNull() )\n        {\n            // at first - get the elements childs\n            childs = xml2ycp(cur_node->children);\n\n            if ( ! childs.isEmpty() )\n                for (int i=0; i < childs.size(); i++ )\n                    newelement = newelement->asTerm()->functionalAdd( childs->value(i) );\n            if ( !newelement->isVoid() ) ymlList.add( newelement );\n        }\n    }\n    return ymlList;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string>\n#include <libxml2/libxml/xmlstring.h>\n#include <libxml2/libxml/parser.h>\n#include <libxml2/libxml/xmlreader.h>\n#include <libxml2/libxml/tree.h>\n#include <ycp/YCPString.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPValue.h>\n#include <ycp/YCPTerm.h>\n\nstring YMLParser(xmlNodePtr &node)\n{\n    YCPList ymlList;\n    ymlList = xml2ycp(node);\n    string ycpString=\"\";\n\n    for(int i=0; i<=ymlList->size() ; i++ )\n        if ( !ymlList->value(i).isNull() && !ymlList->value(i)->isVoid() )\n        {\n            ycpString += ymlList->value(i)->toString().c_str();\n            if (i != ymlList->size()-1) ycpString += \", \";\n        }\n\n    return ycpString;\n}"
  },
  {
    "function_name": "xml2ycp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/yml/src/YMLparser.cc",
    "lines": "65-140",
    "snippet": "YCPList xml2ycp(xmlNode * node, bool symbol = false)\n{\n    xmlNode *cur_node = node;\n    YCPList ymlList;\n\n    for (  ; cur_node ; cur_node = cur_node->next)\n    {\n        YCPValue newelement;\n        YCPList childs;\n        newelement = YCPVoid();\n\n        // identify kind of element; create a YCPValue\n        switch (cur_node->type)\n        {\n            case XML_ELEMENT_NODE       :\n   \n                  if ( !xmlStrcmp(cur_node->name,  (const xmlChar*) \"symbol\" ) ) {\n                      char *prop = (char*) xmlGetProp(cur_node, (const xmlChar *)\"name\");\n                      if (prop)\n                        newelement = YCPSymbol( prop );\n                      else {\n                        fprintf (stderr, \"Error! Symbol without a name!\\n\");\n                        newelement = YCPVoid();\n                      }\n                  }\n                  else newelement = YCPTerm(  (char*) cur_node->name );\n                  break;\n\n            case XML_ATTRIBUTE_NODE     :\n                  newelement = YCPVoid();\n                  break;\n\n            case XML_TEXT_NODE          :\n                  if ( xmlIsBlankNode(cur_node) )\n                      newelement = YCPVoid();\n                  else newelement = YCPString( (char*) cur_node->content );\n                      break;\n\n            case XML_CDATA_SECTION_NODE : newelement = YCPVoid(); break;\n                  // cur_node->content);\n\n            case XML_ENTITY_REF_NODE    : newelement = YCPVoid(); break;\n            case XML_ENTITY_NODE        : newelement = YCPVoid(); break;\n            case XML_PI_NODE            : newelement = YCPVoid(); break;\n            case XML_COMMENT_NODE       : newelement = YCPVoid(); break;\n            case XML_DOCUMENT_NODE      : newelement = YCPVoid(); break;\n            case XML_DOCUMENT_TYPE_NODE : newelement = YCPVoid(); break;\n            case XML_DOCUMENT_FRAG_NODE : newelement = YCPVoid(); break;\n            case XML_NOTATION_NODE      : newelement = YCPVoid(); break;\n            case XML_HTML_DOCUMENT_NODE : newelement = YCPVoid(); break;\n            case XML_DTD_NODE           : newelement = YCPVoid(); break;\n            case XML_ELEMENT_DECL       : newelement = YCPVoid(); break;\n            case XML_ATTRIBUTE_DECL     : newelement = YCPVoid(); break;\n            case XML_ENTITY_DECL        : newelement = YCPVoid(); break;\n            case XML_NAMESPACE_DECL     : newelement = YCPVoid(); break;\n            case XML_XINCLUDE_START     : newelement = YCPVoid(); break;\n            case XML_XINCLUDE_END       : newelement = YCPVoid(); break;\n            case XML_DOCB_DOCUMENT_NODE : newelement = YCPVoid(); break;\n            default                     : newelement = YCPVoid(); break;\n        }\n\n\n        // now we've got to add the found element to our ymlList\n        if ( !newelement.isNull() )\n        {\n            // at first - get the elements childs\n            childs = xml2ycp(cur_node->children);\n\n            if ( ! childs.isEmpty() )\n                for (int i=0; i < childs.size(); i++ )\n                    newelement = newelement->asTerm()->functionalAdd( childs->value(i) );\n            if ( !newelement->isVoid() ) ymlList.add( newelement );\n        }\n    }\n    return ymlList;\n}",
    "includes": [
      "#include <string>",
      "#include <libxml2/libxml/xmlstring.h>",
      "#include <libxml2/libxml/parser.h>",
      "#include <libxml2/libxml/xmlreader.h>",
      "#include <libxml2/libxml/tree.h>",
      "#include <ycp/YCPString.h>",
      "#include <ycp/YCPVoid.h>",
      "#include <ycp/YCPValue.h>",
      "#include <ycp/YCPTerm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ymlList.add",
          "args": [
            "newelement"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "141-145",
          "snippet": "void\nYCPTermRep::add (const YCPValue& value)\n{\n    l->add(value);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  void\n  YCPTermRep::add (const YCPValue& value)\n  {\n      l->add(value);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "newelement->isVoid",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "isVoid",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "60-61",
          "snippet": "bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n\t\t\t\t\t\t|| valuetype() == YT_RETURN; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isVoid()        const { return valuetype() == YT_VOID \n  \t\t\t\t\t\t|| valuetype() == YT_RETURN; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "newelement->asTerm",
          "args": [
            "childs->value(i)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "childs->value",
          "args": [
            "i"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "newelement->asTerm",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "asTerm",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "191-201",
          "snippet": "YCPTerm\nYCPValueRep::asTerm() const\n{\n    if (!isTerm())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPTerm (static_cast<const YCPTermRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPTerm\n  YCPValueRep::asTerm() const\n  {\n      if (!isTerm())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Term!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPTerm (static_cast<const YCPTermRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "childs.size",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "childs.isEmpty",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "isEmpty",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "101-105",
          "snippet": "bool\nYCPTermRep::isEmpty() const\n{\n  return l->isEmpty();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  bool\n  YCPTermRep::isEmpty() const\n  {\n    return l->isEmpty();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "xml2ycp",
          "args": [
            "cur_node->children"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "xml2ycp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/yml/src/YMLparser.cc",
          "lines": "65-140",
          "snippet": "YCPList xml2ycp(xmlNode * node, bool symbol = false)\n{\n    xmlNode *cur_node = node;\n    YCPList ymlList;\n\n    for (  ; cur_node ; cur_node = cur_node->next)\n    {\n        YCPValue newelement;\n        YCPList childs;\n        newelement = YCPVoid();\n\n        // identify kind of element; create a YCPValue\n        switch (cur_node->type)\n        {\n            case XML_ELEMENT_NODE       :\n   \n                  if ( !xmlStrcmp(cur_node->name,  (const xmlChar*) \"symbol\" ) ) {\n                      char *prop = (char*) xmlGetProp(cur_node, (const xmlChar *)\"name\");\n                      if (prop)\n                        newelement = YCPSymbol( prop );\n                      else {\n                        fprintf (stderr, \"Error! Symbol without a name!\\n\");\n                        newelement = YCPVoid();\n                      }\n                  }\n                  else newelement = YCPTerm(  (char*) cur_node->name );\n                  break;\n\n            case XML_ATTRIBUTE_NODE     :\n                  newelement = YCPVoid();\n                  break;\n\n            case XML_TEXT_NODE          :\n                  if ( xmlIsBlankNode(cur_node) )\n                      newelement = YCPVoid();\n                  else newelement = YCPString( (char*) cur_node->content );\n                      break;\n\n            case XML_CDATA_SECTION_NODE : newelement = YCPVoid(); break;\n                  // cur_node->content);\n\n            case XML_ENTITY_REF_NODE    : newelement = YCPVoid(); break;\n            case XML_ENTITY_NODE        : newelement = YCPVoid(); break;\n            case XML_PI_NODE            : newelement = YCPVoid(); break;\n            case XML_COMMENT_NODE       : newelement = YCPVoid(); break;\n            case XML_DOCUMENT_NODE      : newelement = YCPVoid(); break;\n            case XML_DOCUMENT_TYPE_NODE : newelement = YCPVoid(); break;\n            case XML_DOCUMENT_FRAG_NODE : newelement = YCPVoid(); break;\n            case XML_NOTATION_NODE      : newelement = YCPVoid(); break;\n            case XML_HTML_DOCUMENT_NODE : newelement = YCPVoid(); break;\n            case XML_DTD_NODE           : newelement = YCPVoid(); break;\n            case XML_ELEMENT_DECL       : newelement = YCPVoid(); break;\n            case XML_ATTRIBUTE_DECL     : newelement = YCPVoid(); break;\n            case XML_ENTITY_DECL        : newelement = YCPVoid(); break;\n            case XML_NAMESPACE_DECL     : newelement = YCPVoid(); break;\n            case XML_XINCLUDE_START     : newelement = YCPVoid(); break;\n            case XML_XINCLUDE_END       : newelement = YCPVoid(); break;\n            case XML_DOCB_DOCUMENT_NODE : newelement = YCPVoid(); break;\n            default                     : newelement = YCPVoid(); break;\n        }\n\n\n        // now we've got to add the found element to our ymlList\n        if ( !newelement.isNull() )\n        {\n            // at first - get the elements childs\n            childs = xml2ycp(cur_node->children);\n\n            if ( ! childs.isEmpty() )\n                for (int i=0; i < childs.size(); i++ )\n                    newelement = newelement->asTerm()->functionalAdd( childs->value(i) );\n            if ( !newelement->isVoid() ) ymlList.add( newelement );\n        }\n    }\n    return ymlList;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "newelement.isNull",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "(char*) cur_node->content"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "isYCPStringPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
          "lines": "92-102",
          "snippet": "bool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}",
          "includes": [
            "#include \"IniFile.h\"",
            "#include \"IniParser.h\"",
            "#include <cassert>",
            "#include <glob.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <set>",
            "#include <vector>",
            "#include <ycp/y2log.h>",
            "#include <y2util/PathInfo.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nbool isYCPStringPair (const YCPValue &v)\n{\n    if (!v->isList ())\n\treturn false;\n    YCPList l = v->asList ();\n    if (l->size () != 2)\n\treturn false;\n    return\n\tl->value (0)->isString () &&\n\tl->value (1)->isString ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlIsBlankNode",
          "args": [
            "cur_node"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPTerm",
          "args": [
            "(char*) cur_node->name"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "YCPTerm",
          "container": "YCPTerm",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "178-194",
          "snippet": "YCPTerm::YCPTerm (bytecodeistream & str)\n    : YCPValue (YCPTerm(\"no-name-so-far\"))\n{\n    string s;\n    if (Bytecode::readString (str, s))\n    {\n\tYCPList list (str);\n\tif (!list.isNull())\n\t{\n\t    (const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->setName(s);\n\t    for (int i = 0 ; i < list->size () ; i++)\n\t    {\n\t\t(const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->add (list->value (i));\n\t    }\n\t}\n    }\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTerm {\n  YCPTerm::YCPTerm (bytecodeistream & str)\n      : YCPValue (YCPTerm(\"no-name-so-far\"))\n  {\n      string s;\n      if (Bytecode::readString (str, s))\n      {\n  \tYCPList list (str);\n  \tif (!list.isNull())\n  \t{\n  \t    (const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->setName(s);\n  \t    for (int i = 0 ; i < list->size () ; i++)\n  \t    {\n  \t\t(const_cast<YCPTermRep*>(static_cast<const YCPTermRep*>(element)))->add (list->value (i));\n  \t    }\n  \t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error! Symbol without a name!\\n\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPSymbol",
          "args": [
            "prop"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "YCPSymbol",
          "container": "YCPSymbol",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPSymbol.cc",
          "lines": "104-107",
          "snippet": "YCPSymbol::YCPSymbol (bytecodeistream & str)\n    : YCPValue (new YCPSymbolRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/y2log.h\"\n\nYCPSymbol {\n  YCPSymbol::YCPSymbol (bytecodeistream & str)\n      : YCPValue (new YCPSymbolRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlGetProp",
          "args": [
            "cur_node",
            "(const xmlChar *)\"name\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrcmp",
          "args": [
            "cur_node->name",
            "(const xmlChar*) \"symbol\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string>\n#include <libxml2/libxml/xmlstring.h>\n#include <libxml2/libxml/parser.h>\n#include <libxml2/libxml/xmlreader.h>\n#include <libxml2/libxml/tree.h>\n#include <ycp/YCPString.h>\n#include <ycp/YCPVoid.h>\n#include <ycp/YCPValue.h>\n#include <ycp/YCPTerm.h>\n\nYCPList xml2ycp(xmlNode * node, bool symbol = false)\n{\n    xmlNode *cur_node = node;\n    YCPList ymlList;\n\n    for (  ; cur_node ; cur_node = cur_node->next)\n    {\n        YCPValue newelement;\n        YCPList childs;\n        newelement = YCPVoid();\n\n        // identify kind of element; create a YCPValue\n        switch (cur_node->type)\n        {\n            case XML_ELEMENT_NODE       :\n   \n                  if ( !xmlStrcmp(cur_node->name,  (const xmlChar*) \"symbol\" ) ) {\n                      char *prop = (char*) xmlGetProp(cur_node, (const xmlChar *)\"name\");\n                      if (prop)\n                        newelement = YCPSymbol( prop );\n                      else {\n                        fprintf (stderr, \"Error! Symbol without a name!\\n\");\n                        newelement = YCPVoid();\n                      }\n                  }\n                  else newelement = YCPTerm(  (char*) cur_node->name );\n                  break;\n\n            case XML_ATTRIBUTE_NODE     :\n                  newelement = YCPVoid();\n                  break;\n\n            case XML_TEXT_NODE          :\n                  if ( xmlIsBlankNode(cur_node) )\n                      newelement = YCPVoid();\n                  else newelement = YCPString( (char*) cur_node->content );\n                      break;\n\n            case XML_CDATA_SECTION_NODE : newelement = YCPVoid(); break;\n                  // cur_node->content);\n\n            case XML_ENTITY_REF_NODE    : newelement = YCPVoid(); break;\n            case XML_ENTITY_NODE        : newelement = YCPVoid(); break;\n            case XML_PI_NODE            : newelement = YCPVoid(); break;\n            case XML_COMMENT_NODE       : newelement = YCPVoid(); break;\n            case XML_DOCUMENT_NODE      : newelement = YCPVoid(); break;\n            case XML_DOCUMENT_TYPE_NODE : newelement = YCPVoid(); break;\n            case XML_DOCUMENT_FRAG_NODE : newelement = YCPVoid(); break;\n            case XML_NOTATION_NODE      : newelement = YCPVoid(); break;\n            case XML_HTML_DOCUMENT_NODE : newelement = YCPVoid(); break;\n            case XML_DTD_NODE           : newelement = YCPVoid(); break;\n            case XML_ELEMENT_DECL       : newelement = YCPVoid(); break;\n            case XML_ATTRIBUTE_DECL     : newelement = YCPVoid(); break;\n            case XML_ENTITY_DECL        : newelement = YCPVoid(); break;\n            case XML_NAMESPACE_DECL     : newelement = YCPVoid(); break;\n            case XML_XINCLUDE_START     : newelement = YCPVoid(); break;\n            case XML_XINCLUDE_END       : newelement = YCPVoid(); break;\n            case XML_DOCB_DOCUMENT_NODE : newelement = YCPVoid(); break;\n            default                     : newelement = YCPVoid(); break;\n        }\n\n\n        // now we've got to add the found element to our ymlList\n        if ( !newelement.isNull() )\n        {\n            // at first - get the elements childs\n            childs = xml2ycp(cur_node->children);\n\n            if ( ! childs.isEmpty() )\n                for (int i=0; i < childs.size(); i++ )\n                    newelement = newelement->asTerm()->functionalAdd( childs->value(i) );\n            if ( !newelement->isVoid() ) ymlList.add( newelement );\n        }\n    }\n    return ymlList;\n}"
  }
]